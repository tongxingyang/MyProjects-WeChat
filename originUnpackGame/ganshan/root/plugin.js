	define("__plugin__/wx0446ba2621dda60a", function(require, module, exports){			
module.exports = require('wx0446ba2621dda60a/base.js'); 
 			});
 		define("__plugin__/wx0446ba2621dda60a/2d.js", function(require, module, exports){ 			
"use strict";

System.register(["./texture-barrier-60b5983b.js", "./json-asset-933a1d4c.js", "./index-f2b92470.js", "./renderable-component-7c6600ed.js", "./deprecated-26630860.js", "./deprecated-ef6bb945.js", "./index-07804d0e.js", "./sprite-frame-1edab3eb.js", "./sprite-827770a8.js", "./renderable-2d-e2838949.js", "./graphics-f99ac3d9.js", "./deprecated-e75f11b6.js", "./deprecated-5f7f37d5.js", "./static-vb-accessor-3aa47319.js"], function (e) {
  "use strict";

  return {
    setters: [function () {}, function () {}, function () {}, function () {}, function () {}, function () {}, function (t) {
      var n = {};
      n.QuadRenderData = t.Q, n.UI = t.B, n.earcut = t.e, n.graphicsAssembler = t.g, n.labelAssembler = t.l, n.spriteAssembler = t.s, e(n);
    }, function (t) {
      var n = {};
      n.SpriteFrame = t.S, n.dynamicAtlasManager = t.d, e(n);
    }, function (t) {
      var n = {};
      n.BASELINE_RATIO = t.d, n.BitmapFont = t.B, n.CacheMode = t.b, n.CanvasPool = t.C, n.Font = t.F, n.HorizontalTextAlignment = t.H, n.Label = t.c, n.LabelAtlas = t.L, n.LabelComponent = t.c, n.MIDDLE_RATIO = t.M, n.Overflow = t.O, n.Sprite = t.a, n.SpriteAtlas = t.S, n.SpriteComponent = t.a, n.TTFFont = t.T, n.VerticalTextAlignment = t.V, n.fragmentText = t.l, n.getBaselineOffset = t.g, n.getEnglishWordPartAtFirst = t.j, n.getEnglishWordPartAtLast = t.k, n.isEnglishWordPartAtFirst = t.f, n.isEnglishWordPartAtLast = t.h, n.isUnicodeCJK = t.i, n.isUnicodeSpace = t.e, n.safeMeasureText = t.s, e(n);
    }, function (t) {
      var n = {};
      n.BaseRenderData = t.B, n.InstanceMaterialType = t.I, n.MeshRenderData = t.M, n.RenderComponent = t.R, n.RenderData = t.a, n.Renderable2D = t.R, n.StencilManager = t.S, n.UIRenderable = t.R, n.UITransform = t.U, n.UITransformComponent = t.U, n.UIVertexFormat = t.v, e(n);
    }, function (t) {
      var n = {};
      n.Graphics = t.G, n.GraphicsComponent = t.G, e(n);
    }, function (t) {
      var n = {};
      n.HtmlTextParser = t.H, n.LabelOutline = t.L, n.LabelOutlineComponent = t.L, n.LabelShadow = t.b, n.Mask = t.M, n.MaskComponent = t.M, n.RichText = t.R, n.RichTextComponent = t.R, n.UIDrawBatch = t.D, n.UIMeshRenderer = t.U, n.UIModelComponent = t.U, n.UIOpacity = t.c, n.UIOpacityComponent = t.c, n.UIStaticBatch = t.a, n.UIStaticBatchComponent = t.a, e(n);
    }, function (t) {
      var n = {};
      n.Canvas = t.C, n.CanvasComponent = t.C, n.RenderRoot2D = t.R, n.UIComponent = t.U, e(n);
    }, function (t) {
      e("MeshBuffer", t.M);
    }],
    execute: function execute() {}
  };
}); 
 			}); 
		define("__plugin__/wx0446ba2621dda60a/3d.js", function(require, module, exports){ 			
"use strict";

System.register(["./texture-barrier-60b5983b.js", "./json-asset-933a1d4c.js", "./index-f2b92470.js", "./renderable-component-7c6600ed.js", "./deprecated-26630860.js", "./deprecated-ef6bb945.js", "./index-5d4b7661.js", "./create-mesh-39923017.js", "./mesh-f5415e9d.js", "./mesh-renderer-fb3b7695.js", "./deprecated-6c081405.js", "./skeleton-b0039cea.js", "./skeletal-animation-utils-121f35a2.js", "./deprecated-e75308d4.js"], function (e) {
  "use strict";

  return {
    setters: [function () {}, function () {}, function () {}, function () {}, function () {}, function () {}, function (n) {
      var t = {};
      t.BatchingUtility = n.B, t.DirectionalLight = n.D, t.DirectionalLightComponent = n.D, t.Light = n.L, t.LightComponent = n.L, t.SphereLight = n.S, t.SphereLightComponent = n.S, t.SpotLight = n.a, t.SpotLightComponent = n.a, t.utils = n.u, e(t);
    }, function () {}, function (n) {
      e("Mesh", n.M);
    }, function (n) {
      var t = {};
      t.MeshRenderer = n.M, t.ModelComponent = n.M, e(t);
    }, function () {}, function (n) {
      e("Skeleton", n.S);
    }, function () {}, function (n) {
      var t = {};
      t.BatchedSkinningModelComponent = n.a, t.SkinnedMeshBatchRenderer = n.a, t.SkinnedMeshRenderer = n.S, t.SkinnedMeshUnit = n.b, t.SkinningModelComponent = n.S, t.SkinningModelUnit = n.b, e(t);
    }],
    execute: function execute() {}
  };
}); 
 			}); 
		define("__plugin__/wx0446ba2621dda60a/@babel/runtime/helpers/Arrayincludes.js", function(require, module, exports){ 			
Array.prototype.includes||Object.defineProperty(Array.prototype,"includes",{value:function(r,e){if(null==this)throw new TypeError('"this" is null or not defined');var t=Object(this),n=t.length>>>0;if(0==n)return!1;for(var i,o,a=0|e,u=Math.max(0<=a?a:n-Math.abs(a),0);u<n;){if((i=t[u])===(o=r)||"number"==typeof i&&"number"==typeof o&&isNaN(i)&&isNaN(o))return!0;u++}return!1}}); 
 			}); 
		define("__plugin__/wx0446ba2621dda60a/@babel/runtime/helpers/typeof.js", function(require, module, exports){ 			
function _typeof(o){return"function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?module.exports=_typeof=function(o){return typeof o}:module.exports=_typeof=function(o){return o&&"function"==typeof Symbol&&o.constructor===Symbol&&o!==Symbol.prototype?"symbol":typeof o},_typeof(o)}module.exports=_typeof; 
 			}); 
		define("__plugin__/wx0446ba2621dda60a/ZipUtils-3ae2be0b.js", function(require, module, exports){ 			
"use strict";

System.register([], function (t) {
  "use strict";

  return {
    execute: function execute() {
      /** @license zlib.js 2012 - imaya [ https://github.com/imaya/zlib.js ] The MIT License */
      var e = {};
      (function () {
        function t(t) {
          throw t;
        }

        var e = void 0,
            r = !0,
            i = this;

        function s(t, r) {
          var s,
              a = t.split("."),
              h = i;
          !(a[0] in h) && h.execScript && h.execScript("var " + a[0]);

          for (; a.length && (s = a.shift());) {
            a.length || r === e ? h = h[s] ? h[s] : h[s] = {} : h[s] = r;
          }
        }

        var a = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Uint32Array;

        function h(t) {
          if ("string" == typeof t) {
            var e,
                r,
                i = t.split("");

            for (e = 0, r = i.length; e < r; e++) {
              i[e] = (255 & i[e].charCodeAt(0)) >>> 0;
            }

            t = i;
          }

          for (var s, a = 1, h = 0, n = t.length, f = 0; 0 < n;) {
            n -= s = 1024 < n ? 1024 : n;

            do {
              h += a += t[f++];
            } while (--s);

            a %= 65521, h %= 65521;
          }

          return (h << 16 | a) >>> 0;
        }

        function n(e, r) {
          this.index = "number" == typeof r ? r : 0, this.i = 0, this.buffer = e instanceof (a ? Uint8Array : Array) ? e : new (a ? Uint8Array : Array)(32768), 2 * this.buffer.length <= this.index && t(Error("invalid index")), this.buffer.length <= this.index && this.f();
        }

        n.prototype.f = function () {
          var t,
              e = this.buffer,
              r = e.length,
              i = new (a ? Uint8Array : Array)(r << 1);
          if (a) i.set(e);else for (t = 0; t < r; ++t) {
            i[t] = e[t];
          }
          return this.buffer = i;
        }, n.prototype.d = function (t, e, r) {
          var i,
              s = this.buffer,
              a = this.index,
              h = this.i,
              n = s[a];
          if (r && 1 < e && (t = 8 < e ? (d[255 & t] << 24 | d[t >>> 8 & 255] << 16 | d[t >>> 16 & 255] << 8 | d[t >>> 24 & 255]) >> 32 - e : d[t] >> 8 - e), 8 > e + h) n = n << e | t, h += e;else for (i = 0; i < e; ++i) {
            n = n << 1 | t >> e - i - 1 & 1, 8 == ++h && (h = 0, s[a++] = d[n], n = 0, a === s.length && (s = this.f()));
          }
          s[a] = n, this.buffer = s, this.i = h, this.index = a;
        }, n.prototype.finish = function () {
          var t,
              e = this.buffer,
              r = this.index;
          return 0 < this.i && (e[r] <<= 8 - this.i, e[r] = d[e[r]], r++), a ? t = e.subarray(0, r) : (e.length = r, t = e), t;
        };
        var f,
            o = new (a ? Uint8Array : Array)(256);

        for (f = 0; 256 > f; ++f) {
          for (var u = c = f, l = 7, c = c >>> 1; c; c >>>= 1) {
            u <<= 1, u |= 1 & c, --l;
          }

          o[f] = (u << l & 255) >>> 0;
        }

        var d = o;

        function p(t) {
          this.buffer = new (a ? Uint16Array : Array)(2 * t), this.length = 0;
        }

        function y(t) {
          var e,
              r,
              i,
              s,
              h,
              n,
              f,
              o,
              u,
              l = t.length,
              c = 0,
              d = Number.POSITIVE_INFINITY;

          for (o = 0; o < l; ++o) {
            t[o] > c && (c = t[o]), t[o] < d && (d = t[o]);
          }

          for (e = 1 << c, r = new (a ? Uint32Array : Array)(e), i = 1, s = 0, h = 2; i <= c;) {
            for (o = 0; o < l; ++o) {
              if (t[o] === i) {
                for (n = 0, f = s, u = 0; u < i; ++u) {
                  n = n << 1 | 1 & f, f >>= 1;
                }

                for (u = n; u < e; u += h) {
                  r[u] = i << 16 | o;
                }

                ++s;
              }
            }

            ++i, s <<= 1, h <<= 1;
          }

          return [r, c, d];
        }

        function b(t, e) {
          this.h = A, this.w = 0, this.input = t, this.b = 0, e && (e.lazy && (this.w = e.lazy), "number" == typeof e.compressionType && (this.h = e.compressionType), e.outputBuffer && (this.a = a && e.outputBuffer instanceof Array ? new Uint8Array(e.outputBuffer) : e.outputBuffer), "number" == typeof e.outputIndex && (this.b = e.outputIndex)), this.a || (this.a = new (a ? Uint8Array : Array)(32768));
        }

        p.prototype.getParent = function (t) {
          return 2 * ((t - 2) / 4 | 0);
        }, p.prototype.push = function (t, e) {
          var r,
              i,
              s,
              a = this.buffer;

          for (r = this.length, a[this.length++] = e, a[this.length++] = t; 0 < r && (i = this.getParent(r), a[r] > a[i]);) {
            s = a[r], a[r] = a[i], a[i] = s, s = a[r + 1], a[r + 1] = a[i + 1], a[i + 1] = s, r = i;
          }

          return this.length;
        }, p.prototype.pop = function () {
          var t,
              e,
              r,
              i,
              s,
              a = this.buffer;

          for (e = a[0], t = a[1], this.length -= 2, a[0] = a[this.length], a[1] = a[this.length + 1], s = 0; !((i = 2 * s + 2) >= this.length) && (i + 2 < this.length && a[i + 2] > a[i] && (i += 2), a[i] > a[s]);) {
            r = a[s], a[s] = a[i], a[i] = r, r = a[s + 1], a[s + 1] = a[i + 1], a[i + 1] = r, s = i;
          }

          return {
            index: t,
            value: e,
            length: this.length
          };
        };
        var g,
            A = 2,
            B = {
          NONE: 0,
          r: 1,
          j: A,
          N: 3
        },
            v = [];

        for (g = 0; 288 > g; g++) {
          switch (r) {
            case 143 >= g:
              v.push([g + 48, 8]);
              break;

            case 255 >= g:
              v.push([g - 144 + 400, 9]);
              break;

            case 279 >= g:
              v.push([g - 256 + 0, 7]);
              break;

            case 287 >= g:
              v.push([g - 280 + 192, 8]);
              break;

            default:
              t("invalid literal: " + g);
          }
        }

        function k(t, e) {
          this.length = t, this.G = e;
        }

        function w() {
          var e = m;

          switch (r) {
            case 3 === e:
              return [257, e - 3, 0];

            case 4 === e:
              return [258, e - 4, 0];

            case 5 === e:
              return [259, e - 5, 0];

            case 6 === e:
              return [260, e - 6, 0];

            case 7 === e:
              return [261, e - 7, 0];

            case 8 === e:
              return [262, e - 8, 0];

            case 9 === e:
              return [263, e - 9, 0];

            case 10 === e:
              return [264, e - 10, 0];

            case 12 >= e:
              return [265, e - 11, 1];

            case 14 >= e:
              return [266, e - 13, 1];

            case 16 >= e:
              return [267, e - 15, 1];

            case 18 >= e:
              return [268, e - 17, 1];

            case 22 >= e:
              return [269, e - 19, 2];

            case 26 >= e:
              return [270, e - 23, 2];

            case 30 >= e:
              return [271, e - 27, 2];

            case 34 >= e:
              return [272, e - 31, 2];

            case 42 >= e:
              return [273, e - 35, 3];

            case 50 >= e:
              return [274, e - 43, 3];

            case 58 >= e:
              return [275, e - 51, 3];

            case 66 >= e:
              return [276, e - 59, 3];

            case 82 >= e:
              return [277, e - 67, 4];

            case 98 >= e:
              return [278, e - 83, 4];

            case 114 >= e:
              return [279, e - 99, 4];

            case 130 >= e:
              return [280, e - 115, 4];

            case 162 >= e:
              return [281, e - 131, 5];

            case 194 >= e:
              return [282, e - 163, 5];

            case 226 >= e:
              return [283, e - 195, 5];

            case 257 >= e:
              return [284, e - 227, 5];

            case 258 === e:
              return [285, e - 258, 0];

            default:
              t("invalid length: " + e);
          }
        }

        b.prototype.n = function () {
          var i,
              s,
              h,
              f,
              o = this.input;

          switch (this.h) {
            case 0:
              for (h = 0, f = o.length; h < f;) {
                var u,
                    l,
                    c,
                    d = s = a ? o.subarray(h, h + 65535) : o.slice(h, h + 65535),
                    p = (h += s.length) === f,
                    y = e,
                    b = e,
                    g = this.a,
                    B = this.b;

                if (a) {
                  for (g = new Uint8Array(this.a.buffer); g.length <= B + d.length + 5;) {
                    g = new Uint8Array(g.length << 1);
                  }

                  g.set(this.a);
                }

                if (u = p ? 1 : 0, g[B++] = 0 | u, c = 65536 + ~(l = d.length) & 65535, g[B++] = 255 & l, g[B++] = l >>> 8 & 255, g[B++] = 255 & c, g[B++] = c >>> 8 & 255, a) g.set(d, B), B += d.length, g = g.subarray(0, B);else {
                  for (y = 0, b = d.length; y < b; ++y) {
                    g[B++] = d[y];
                  }

                  g.length = B;
                }
                this.b = B, this.a = g;
              }

              break;

            case 1:
              var k = new n(new Uint8Array(this.a.buffer), this.b);
              k.d(1, 1, r), k.d(1, 2, r);
              var w,
                  m,
                  U,
                  x = I(this, o);

              for (w = 0, m = x.length; w < m; w++) {
                if (U = x[w], n.prototype.d.apply(k, v[U]), 256 < U) k.d(x[++w], x[++w], r), k.d(x[++w], 5), k.d(x[++w], x[++w], r);else if (256 === U) break;
              }

              this.a = k.finish(), this.b = this.a.length;
              break;

            case A:
              var T,
                  C,
                  N,
                  D,
                  Z,
                  L,
                  P,
                  j,
                  S,
                  M,
                  R,
                  F,
                  G,
                  O,
                  _,
                  H = new n(new Uint8Array(this.a), this.b),
                  V = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],
                  J = Array(19);

              for (T = A, H.d(1, 1, r), H.d(T, 2, r), C = I(this, o), P = z(L = E(this.L, 15)), S = z(j = E(this.K, 7)), N = 286; 257 < N && 0 === L[N - 1]; N--) {
                ;
              }

              for (D = 30; 1 < D && 0 === j[D - 1]; D--) {
                ;
              }

              var X,
                  q,
                  K,
                  Y,
                  Q,
                  W,
                  $ = N,
                  tt = D,
                  et = new (a ? Uint32Array : Array)($ + tt),
                  rt = new (a ? Uint32Array : Array)(316),
                  it = new (a ? Uint8Array : Array)(19);

              for (X = q = 0; X < $; X++) {
                et[q++] = L[X];
              }

              for (X = 0; X < tt; X++) {
                et[q++] = j[X];
              }

              if (!a) for (X = 0, Y = it.length; X < Y; ++X) {
                it[X] = 0;
              }

              for (X = Q = 0, Y = et.length; X < Y; X += q) {
                for (q = 1; X + q < Y && et[X + q] === et[X]; ++q) {
                  ;
                }

                if (K = q, 0 === et[X]) {
                  if (3 > K) for (; 0 < K--;) {
                    rt[Q++] = 0, it[0]++;
                  } else for (; 0 < K;) {
                    (W = 138 > K ? K : 138) > K - 3 && W < K && (W = K - 3), 10 >= W ? (rt[Q++] = 17, rt[Q++] = W - 3, it[17]++) : (rt[Q++] = 18, rt[Q++] = W - 11, it[18]++), K -= W;
                  }
                } else if (rt[Q++] = et[X], it[et[X]]++, 3 > --K) for (; 0 < K--;) {
                  rt[Q++] = et[X], it[et[X]]++;
                } else for (; 0 < K;) {
                  (W = 6 > K ? K : 6) > K - 3 && W < K && (W = K - 3), rt[Q++] = 16, rt[Q++] = W - 3, it[16]++, K -= W;
                }
              }

              for (i = a ? rt.subarray(0, Q) : rt.slice(0, Q), M = E(it, 7), O = 0; 19 > O; O++) {
                J[O] = M[V[O]];
              }

              for (Z = 19; 4 < Z && 0 === J[Z - 1]; Z--) {
                ;
              }

              for (R = z(M), H.d(N - 257, 5, r), H.d(D - 1, 5, r), H.d(Z - 4, 4, r), O = 0; O < Z; O++) {
                H.d(J[O], 3, r);
              }

              for (O = 0, _ = i.length; O < _; O++) {
                if (F = i[O], H.d(R[F], M[F], r), 16 <= F) {
                  switch (O++, F) {
                    case 16:
                      G = 2;
                      break;

                    case 17:
                      G = 3;
                      break;

                    case 18:
                      G = 7;
                      break;

                    default:
                      t("invalid code: " + F);
                  }

                  H.d(i[O], G, r);
                }
              }

              var st,
                  at,
                  ht,
                  nt,
                  ft,
                  ot,
                  ut,
                  lt,
                  ct = [P, L],
                  dt = [S, j];

              for (ft = ct[0], ot = ct[1], ut = dt[0], lt = dt[1], st = 0, at = C.length; st < at; ++st) {
                if (ht = C[st], H.d(ft[ht], ot[ht], r), 256 < ht) H.d(C[++st], C[++st], r), nt = C[++st], H.d(ut[nt], lt[nt], r), H.d(C[++st], C[++st], r);else if (256 === ht) break;
              }

              this.a = H.finish(), this.b = this.a.length;
              break;

            default:
              t("invalid compression type");
          }

          return this.a;
        };

        var m,
            U,
            x = [];

        for (m = 3; 258 >= m; m++) {
          U = w(), x[m] = U[2] << 24 | U[1] << 16 | U[0];
        }

        var T = a ? new Uint32Array(x) : x;

        function I(i, s) {
          function h(e, i) {
            var s,
                a,
                h,
                n,
                f = e.G,
                o = [],
                u = 0;

            switch (s = T[e.length], o[u++] = 65535 & s, o[u++] = s >> 16 & 255, o[u++] = s >> 24, r) {
              case 1 === f:
                a = [0, f - 1, 0];
                break;

              case 2 === f:
                a = [1, f - 2, 0];
                break;

              case 3 === f:
                a = [2, f - 3, 0];
                break;

              case 4 === f:
                a = [3, f - 4, 0];
                break;

              case 6 >= f:
                a = [4, f - 5, 1];
                break;

              case 8 >= f:
                a = [5, f - 7, 1];
                break;

              case 12 >= f:
                a = [6, f - 9, 2];
                break;

              case 16 >= f:
                a = [7, f - 13, 2];
                break;

              case 24 >= f:
                a = [8, f - 17, 3];
                break;

              case 32 >= f:
                a = [9, f - 25, 3];
                break;

              case 48 >= f:
                a = [10, f - 33, 4];
                break;

              case 64 >= f:
                a = [11, f - 49, 4];
                break;

              case 96 >= f:
                a = [12, f - 65, 5];
                break;

              case 128 >= f:
                a = [13, f - 97, 5];
                break;

              case 192 >= f:
                a = [14, f - 129, 6];
                break;

              case 256 >= f:
                a = [15, f - 193, 6];
                break;

              case 384 >= f:
                a = [16, f - 257, 7];
                break;

              case 512 >= f:
                a = [17, f - 385, 7];
                break;

              case 768 >= f:
                a = [18, f - 513, 8];
                break;

              case 1024 >= f:
                a = [19, f - 769, 8];
                break;

              case 1536 >= f:
                a = [20, f - 1025, 9];
                break;

              case 2048 >= f:
                a = [21, f - 1537, 9];
                break;

              case 3072 >= f:
                a = [22, f - 2049, 10];
                break;

              case 4096 >= f:
                a = [23, f - 3073, 10];
                break;

              case 6144 >= f:
                a = [24, f - 4097, 11];
                break;

              case 8192 >= f:
                a = [25, f - 6145, 11];
                break;

              case 12288 >= f:
                a = [26, f - 8193, 12];
                break;

              case 16384 >= f:
                a = [27, f - 12289, 12];
                break;

              case 24576 >= f:
                a = [28, f - 16385, 13];
                break;

              case 32768 >= f:
                a = [29, f - 24577, 13];
                break;

              default:
                t("invalid distance");
            }

            for (s = a, o[u++] = s[0], o[u++] = s[1], o[u++] = s[2], h = 0, n = o.length; h < n; ++h) {
              g[A++] = o[h];
            }

            v[o[0]]++, w[o[3]]++, B = e.length + i - 1, p = null;
          }

          var n,
              f,
              o,
              u,
              l,
              c,
              d,
              p,
              y,
              b = {},
              g = a ? new Uint16Array(2 * s.length) : [],
              A = 0,
              B = 0,
              v = new (a ? Uint32Array : Array)(286),
              w = new (a ? Uint32Array : Array)(30),
              m = i.w;

          if (!a) {
            for (o = 0; 285 >= o;) {
              v[o++] = 0;
            }

            for (o = 0; 29 >= o;) {
              w[o++] = 0;
            }
          }

          for (v[256] = 1, n = 0, f = s.length; n < f; ++n) {
            for (o = l = 0, u = 3; o < u && n + o !== f; ++o) {
              l = l << 8 | s[n + o];
            }

            if (b[l] === e && (b[l] = []), c = b[l], !(0 < B--)) {
              for (; 0 < c.length && 32768 < n - c[0];) {
                c.shift();
              }

              if (n + 3 >= f) {
                for (p && h(p, -1), o = 0, u = f - n; o < u; ++o) {
                  y = s[n + o], g[A++] = y, ++v[y];
                }

                break;
              }

              if (0 < c.length) {
                var U = e,
                    x = e,
                    I = 0,
                    E = e,
                    z = e,
                    C = e,
                    N = s.length,
                    D = (z = 0, c.length);

                t: for (; z < D; z++) {
                  if (U = c[D - z - 1], E = 3, 3 < I) {
                    for (C = I; 3 < C; C--) {
                      if (s[U + C - 1] !== s[n + C - 1]) continue t;
                    }

                    E = I;
                  }

                  for (; 258 > E && n + E < N && s[U + E] === s[n + E];) {
                    ++E;
                  }

                  if (E > I && (x = U, I = E), 258 === E) break;
                }

                d = new k(I, n - x), p ? p.length < d.length ? (y = s[n - 1], g[A++] = y, ++v[y], h(d, 0)) : h(p, -1) : d.length < m ? p = d : h(d, 0);
              } else p ? h(p, -1) : (y = s[n], g[A++] = y, ++v[y]);
            }

            c.push(n);
          }

          return g[A++] = 256, v[256]++, i.L = v, i.K = w, a ? g.subarray(0, A) : g;
        }

        function E(t, e) {
          function r(t) {
            var e = m[t][U[t]];
            e === A ? (r(t + 1), r(t + 1)) : --k[e], ++U[t];
          }

          var i,
              s,
              h,
              n,
              f,
              o = t.length,
              u = new p(572),
              l = new (a ? Uint8Array : Array)(o);
          if (!a) for (n = 0; n < o; n++) {
            l[n] = 0;
          }

          for (n = 0; n < o; ++n) {
            0 < t[n] && u.push(n, t[n]);
          }

          if (i = Array(u.length / 2), s = new (a ? Uint32Array : Array)(u.length / 2), 1 === i.length) return l[u.pop().index] = 1, l;

          for (n = 0, f = u.length / 2; n < f; ++n) {
            i[n] = u.pop(), s[n] = i[n].value;
          }

          var c,
              d,
              y,
              b,
              g,
              A = s.length,
              B = new (a ? Uint16Array : Array)(e),
              v = new (a ? Uint8Array : Array)(e),
              k = new (a ? Uint8Array : Array)(A),
              w = Array(e),
              m = Array(e),
              U = Array(e),
              x = (1 << e) - A,
              T = 1 << e - 1;

          for (B[e - 1] = A, d = 0; d < e; ++d) {
            x < T ? v[d] = 0 : (v[d] = 1, x -= T), x <<= 1, B[e - 2 - d] = (B[e - 1 - d] / 2 | 0) + A;
          }

          for (B[0] = v[0], w[0] = Array(B[0]), m[0] = Array(B[0]), d = 1; d < e; ++d) {
            B[d] > 2 * B[d - 1] + v[d] && (B[d] = 2 * B[d - 1] + v[d]), w[d] = Array(B[d]), m[d] = Array(B[d]);
          }

          for (c = 0; c < A; ++c) {
            k[c] = e;
          }

          for (y = 0; y < B[e - 1]; ++y) {
            w[e - 1][y] = s[y], m[e - 1][y] = y;
          }

          for (c = 0; c < e; ++c) {
            U[c] = 0;
          }

          for (1 === v[e - 1] && (--k[0], ++U[e - 1]), d = e - 2; 0 <= d; --d) {
            for (b = c = 0, g = U[d + 1], y = 0; y < B[d]; y++) {
              (b = w[d + 1][g] + w[d + 1][g + 1]) > s[c] ? (w[d][y] = b, m[d][y] = A, g += 2) : (w[d][y] = s[c], m[d][y] = c, ++c);
            }

            U[d] = 0, 1 === v[d] && r(d);
          }

          for (h = k, n = 0, f = i.length; n < f; ++n) {
            l[i[n].index] = h[n];
          }

          return l;
        }

        function z(e) {
          var r,
              i,
              s,
              h,
              n = new (a ? Uint16Array : Array)(e.length),
              f = [],
              o = [],
              u = 0;

          for (r = 0, i = e.length; r < i; r++) {
            f[e[r]] = 1 + (0 | f[e[r]]);
          }

          for (r = 1, i = 16; r <= i; r++) {
            o[r] = u, (u += 0 | f[r]) > 1 << r && t("overcommitted"), u <<= 1;
          }

          for (65536 > u && t("undercommitted"), r = 0, i = e.length; r < i; r++) {
            for (u = o[e[r]], o[e[r]] += 1, s = n[r] = 0, h = e[r]; s < h; s++) {
              n[r] = n[r] << 1 | 1 & u, u >>>= 1;
            }
          }

          return n;
        }

        function C(t, e) {
          this.input = t, this.a = new (a ? Uint8Array : Array)(32768), this.h = N.j;
          var r,
              i = {};

          for (r in !e && (e = {}) || "number" != typeof e.compressionType || (this.h = e.compressionType), e) {
            i[r] = e[r];
          }

          i.outputBuffer = this.a, this.z = new b(this.input, i);
        }

        var N = B;

        function D(e, r) {
          switch (this.k = [], this.l = 32768, this.e = this.g = this.c = this.q = 0, this.input = a ? new Uint8Array(e) : e, this.s = !1, this.m = L, this.B = !1, !r && (r = {}) || (r.index && (this.c = r.index), r.bufferSize && (this.l = r.bufferSize), r.bufferType && (this.m = r.bufferType), r.resize && (this.B = r.resize)), this.m) {
            case Z:
              this.b = 32768, this.a = new (a ? Uint8Array : Array)(32768 + this.l + 258);
              break;

            case L:
              this.b = 0, this.a = new (a ? Uint8Array : Array)(this.l), this.f = this.J, this.t = this.H, this.o = this.I;
              break;

            default:
              t(Error("invalid inflate mode"));
          }
        }

        C.prototype.n = function () {
          var e,
              r,
              i,
              s,
              n,
              f,
              o,
              u = 0;

          switch (o = this.a, e = ut) {
            case ut:
              r = Math.LOG2E * Math.log(32768) - 8;
              break;

            default:
              t(Error("invalid compression method"));
          }

          switch (i = r << 4 | e, o[u++] = i, e) {
            case ut:
              switch (this.h) {
                case N.NONE:
                  n = 0;
                  break;

                case N.r:
                  n = 1;
                  break;

                case N.j:
                  n = 2;
                  break;

                default:
                  t(Error("unsupported compression type"));
              }

              break;

            default:
              t(Error("invalid compression method"));
          }

          return s = n << 6 | 0, o[u++] = s | 31 - (256 * i + s) % 31, f = h(this.input), this.z.b = u, u = (o = this.z.n()).length, a && ((o = new Uint8Array(o.buffer)).length <= u + 4 && (this.a = new Uint8Array(o.length + 4), this.a.set(o), o = this.a), o = o.subarray(0, u + 4)), o[u++] = f >> 24 & 255, o[u++] = f >> 16 & 255, o[u++] = f >> 8 & 255, o[u++] = 255 & f, o;
        }, s("Zlib.Deflate", C), s("Zlib.Deflate.compress", function (t, e) {
          return new C(t, e).n();
        }), s("Zlib.Deflate.CompressionType", N), s("Zlib.Deflate.CompressionType.NONE", N.NONE), s("Zlib.Deflate.CompressionType.FIXED", N.r), s("Zlib.Deflate.CompressionType.DYNAMIC", N.j);
        var Z = 0,
            L = 1,
            P = {
          D: Z,
          C: L
        };

        D.prototype.p = function () {
          for (; !this.s;) {
            var i = tt(this, 3);

            switch (1 & i && (this.s = r), i >>>= 1) {
              case 0:
                var s = this.input,
                    h = this.c,
                    n = this.a,
                    f = this.b,
                    o = e,
                    u = e,
                    l = e,
                    c = n.length,
                    d = e;

                switch (this.e = this.g = 0, (o = s[h++]) === e && t(Error("invalid uncompressed block header: LEN (first byte)")), u = o, (o = s[h++]) === e && t(Error("invalid uncompressed block header: LEN (second byte)")), u |= o << 8, (o = s[h++]) === e && t(Error("invalid uncompressed block header: NLEN (first byte)")), l = o, (o = s[h++]) === e && t(Error("invalid uncompressed block header: NLEN (second byte)")), u === ~(l |= o << 8) && t(Error("invalid uncompressed block header: length verify")), h + u > s.length && t(Error("input buffer is broken")), this.m) {
                  case Z:
                    for (; f + u > n.length;) {
                      if (u -= d = c - f, a) n.set(s.subarray(h, h + d), f), f += d, h += d;else for (; d--;) {
                        n[f++] = s[h++];
                      }
                      this.b = f, n = this.f(), f = this.b;
                    }

                    break;

                  case L:
                    for (; f + u > n.length;) {
                      n = this.f({
                        v: 2
                      });
                    }

                    break;

                  default:
                    t(Error("invalid inflate mode"));
                }

                if (a) n.set(s.subarray(h, h + u), f), f += u, h += u;else for (; u--;) {
                  n[f++] = s[h++];
                }
                this.c = h, this.b = f, this.a = n;
                break;

              case 1:
                this.o(Q, $);
                break;

              case 2:
                rt(this);
                break;

              default:
                t(Error("unknown BTYPE: " + i));
            }
          }

          return this.t();
        };

        var j,
            S,
            M = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],
            R = a ? new Uint16Array(M) : M,
            F = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 258, 258],
            G = a ? new Uint16Array(F) : F,
            O = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0],
            _ = a ? new Uint8Array(O) : O,
            H = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577],
            V = a ? new Uint16Array(H) : H,
            J = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13],
            X = a ? new Uint8Array(J) : J,
            q = new (a ? Uint8Array : Array)(288);

        for (j = 0, S = q.length; j < S; ++j) {
          q[j] = 143 >= j ? 8 : 255 >= j ? 9 : 279 >= j ? 7 : 8;
        }

        var K,
            Y,
            Q = y(q),
            W = new (a ? Uint8Array : Array)(30);

        for (K = 0, Y = W.length; K < Y; ++K) {
          W[K] = 5;
        }

        var $ = y(W);

        function tt(r, i) {
          for (var s, a = r.g, h = r.e, n = r.input, f = r.c; h < i;) {
            (s = n[f++]) === e && t(Error("input buffer is broken")), a |= s << h, h += 8;
          }

          return s = a & (1 << i) - 1, r.g = a >>> i, r.e = h - i, r.c = f, s;
        }

        function et(r, i) {
          for (var s, a, h, n = r.g, f = r.e, o = r.input, u = r.c, l = i[0], c = i[1]; f < c;) {
            (s = o[u++]) === e && t(Error("input buffer is broken")), n |= s << f, f += 8;
          }

          return h = (a = l[n & (1 << c) - 1]) >>> 16, r.g = n >> h, r.e = f - h, r.c = u, 65535 & a;
        }

        function rt(t) {
          function e(t, e, r) {
            var i, s, a, h;

            for (h = 0; h < t;) {
              switch (i = et(this, e)) {
                case 16:
                  for (a = 3 + tt(this, 2); a--;) {
                    r[h++] = s;
                  }

                  break;

                case 17:
                  for (a = 3 + tt(this, 3); a--;) {
                    r[h++] = 0;
                  }

                  s = 0;
                  break;

                case 18:
                  for (a = 11 + tt(this, 7); a--;) {
                    r[h++] = 0;
                  }

                  s = 0;
                  break;

                default:
                  s = r[h++] = i;
              }
            }

            return r;
          }

          var r,
              i,
              s,
              h,
              n = tt(t, 5) + 257,
              f = tt(t, 5) + 1,
              o = tt(t, 4) + 4,
              u = new (a ? Uint8Array : Array)(R.length);

          for (h = 0; h < o; ++h) {
            u[R[h]] = tt(t, 3);
          }

          r = y(u), i = new (a ? Uint8Array : Array)(n), s = new (a ? Uint8Array : Array)(f), t.o(y(e.call(t, n, r, i)), y(e.call(t, f, r, s)));
        }

        function it(e, r) {
          var i, s;

          switch (this.input = e, this.c = 0, !r && (r = {}) || (r.index && (this.c = r.index), r.verify && (this.M = r.verify)), i = e[this.c++], s = e[this.c++], 15 & i) {
            case ut:
              this.method = ut;
              break;

            default:
              t(Error("unsupported compression method"));
          }

          0 != ((i << 8) + s) % 31 && t(Error("invalid fcheck flag:" + ((i << 8) + s) % 31)), 32 & s && t(Error("fdict flag is not supported")), this.A = new D(e, {
            index: this.c,
            bufferSize: r.bufferSize,
            bufferType: r.bufferType,
            resize: r.resize
          });
        }

        D.prototype.o = function (t, e) {
          var r = this.a,
              i = this.b;
          this.u = t;

          for (var s, a, h, n, f = r.length - 258; 256 !== (s = et(this, t));) {
            if (256 > s) i >= f && (this.b = i, r = this.f(), i = this.b), r[i++] = s;else for (n = G[a = s - 257], 0 < _[a] && (n += tt(this, _[a])), s = et(this, e), h = V[s], 0 < X[s] && (h += tt(this, X[s])), i >= f && (this.b = i, r = this.f(), i = this.b); n--;) {
              r[i] = r[i++ - h];
            }
          }

          for (; 8 <= this.e;) {
            this.e -= 8, this.c--;
          }

          this.b = i;
        }, D.prototype.I = function (t, e) {
          var r = this.a,
              i = this.b;
          this.u = t;

          for (var s, a, h, n, f = r.length; 256 !== (s = et(this, t));) {
            if (256 > s) i >= f && (f = (r = this.f()).length), r[i++] = s;else for (n = G[a = s - 257], 0 < _[a] && (n += tt(this, _[a])), s = et(this, e), h = V[s], 0 < X[s] && (h += tt(this, X[s])), i + n > f && (f = (r = this.f()).length); n--;) {
              r[i] = r[i++ - h];
            }
          }

          for (; 8 <= this.e;) {
            this.e -= 8, this.c--;
          }

          this.b = i;
        }, D.prototype.f = function () {
          var t,
              e,
              r = new (a ? Uint8Array : Array)(this.b - 32768),
              i = this.b - 32768,
              s = this.a;
          if (a) r.set(s.subarray(32768, r.length));else for (t = 0, e = r.length; t < e; ++t) {
            r[t] = s[t + 32768];
          }
          if (this.k.push(r), this.q += r.length, a) s.set(s.subarray(i, i + 32768));else for (t = 0; 32768 > t; ++t) {
            s[t] = s[i + t];
          }
          return this.b = 32768, s;
        }, D.prototype.J = function (t) {
          var e,
              r,
              i,
              s = this.input.length / this.c + 1 | 0,
              h = this.input,
              n = this.a;
          return t && ("number" == typeof t.v && (s = t.v), "number" == typeof t.F && (s += t.F)), r = 2 > s ? (i = (h.length - this.c) / this.u[2] / 2 * 258 | 0) < n.length ? n.length + i : n.length << 1 : n.length * s, a ? (e = new Uint8Array(r)).set(n) : e = n, this.a = e;
        }, D.prototype.t = function () {
          var t,
              e,
              r,
              i,
              s,
              h = 0,
              n = this.a,
              f = this.k,
              o = new (a ? Uint8Array : Array)(this.q + (this.b - 32768));
          if (0 === f.length) return a ? this.a.subarray(32768, this.b) : this.a.slice(32768, this.b);

          for (e = 0, r = f.length; e < r; ++e) {
            for (i = 0, s = (t = f[e]).length; i < s; ++i) {
              o[h++] = t[i];
            }
          }

          for (e = 32768, r = this.b; e < r; ++e) {
            o[h++] = n[e];
          }

          return this.k = [], this.buffer = o;
        }, D.prototype.H = function () {
          var t,
              e = this.b;
          return a ? this.B ? (t = new Uint8Array(e)).set(this.a.subarray(0, e)) : t = this.a.subarray(0, e) : (this.a.length > e && (this.a.length = e), t = this.a), this.buffer = t;
        }, it.prototype.p = function () {
          var e,
              r = this.input;
          return e = this.A.p(), this.c = this.A.c, this.M && (r[this.c++] << 24 | r[this.c++] << 16 | r[this.c++] << 8 | r[this.c++]) >>> 0 !== h(e) && t(Error("invalid adler-32 checksum")), e;
        }, s("Zlib.Inflate", it), s("Zlib.Inflate.BufferType", P), P.ADAPTIVE = P.C, P.BLOCK = P.D, s("Zlib.Inflate.prototype.decompress", it.prototype.p);
        var st,
            at,
            ht = new (a ? Uint8Array : Array)(288);

        for (st = 0, at = ht.length; st < at; ++st) {
          ht[st] = 143 >= st ? 8 : 255 >= st ? 9 : 279 >= st ? 7 : 8;
        }

        y(ht);
        var nt,
            ft,
            ot = new (a ? Uint8Array : Array)(30);

        for (nt = 0, ft = ot.length; nt < ft; ++nt) {
          ot[nt] = 5;
        }

        y(ot);
        var ut = 8;
      }).call(e);
      var r = t("_", e.Zlib);
      r.Deflate = r.Deflate, r.Deflate.compress = r.Deflate.compress, r.Inflate = r.Inflate, r.Inflate.BufferType = r.Inflate.BufferType, r.Inflate.prototype.decompress = r.Inflate.prototype.decompress;

      for (var i = new Array(123), s = 0; s < 123; ++s) {
        i[s] = 64;
      }

      for (var a = 0; a < 64; ++a) {
        i["ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".charCodeAt(a)] = a;
      }

      var h = {
        name: "Jacob__Codec__Base64",
        decode: function decode(t) {
          var e,
              r,
              s,
              a,
              h,
              n,
              f = [],
              o = 0;

          for (t = t.replace(/[^A-Za-z0-9\+\/\=]/g, ""); o < t.length;) {
            e = i[t.charCodeAt(o++)] << 2 | (a = i[t.charCodeAt(o++)]) >> 4, r = (15 & a) << 4 | (h = i[t.charCodeAt(o++)]) >> 2, s = (3 & h) << 6 | (n = i[t.charCodeAt(o++)]), f.push(String.fromCharCode(e)), 64 !== h && f.push(String.fromCharCode(r)), 64 !== n && f.push(String.fromCharCode(s));
          }

          return f.join("");
        },
        decodeAsArray: function decodeAsArray(t, e) {
          var r,
              i,
              s,
              a = this.decode(t),
              h = [];

          for (r = 0, s = a.length / e; r < s; r++) {
            for (h[r] = 0, i = e - 1; i >= 0; --i) {
              h[r] += a.charCodeAt(r * e + i) << 8 * i;
            }
          }

          return h;
        }
      },
          n = function n(t) {
        this.data = t, this.debug = !1, this.gpflags = void 0, this.files = 0, this.unzipped = [], this.buf32k = new Array(32768), this.bIdx = 0, this.modeZIP = !1, this.bytepos = 0, this.bb = 1, this.bits = 0, this.nameBuf = [], this.fileout = void 0, this.literalTree = new Array(n.LITERALS), this.distanceTree = new Array(32), this.treepos = 0, this.Places = null, this.len = 0, this.fpos = new Array(17), this.fpos[0] = 0, this.flens = void 0, this.fmax = void 0;
      };

      n.gunzip = function (t) {
        return t.constructor === Array || t.constructor, new n(t).gunzip()[0][0];
      }, n.HufNode = function () {
        this.b0 = 0, this.b1 = 0, this.jump = null, this.jumppos = -1;
      }, n.LITERALS = 288, n.NAMEMAX = 256, n.bitReverse = [0, 128, 64, 192, 32, 160, 96, 224, 16, 144, 80, 208, 48, 176, 112, 240, 8, 136, 72, 200, 40, 168, 104, 232, 24, 152, 88, 216, 56, 184, 120, 248, 4, 132, 68, 196, 36, 164, 100, 228, 20, 148, 84, 212, 52, 180, 116, 244, 12, 140, 76, 204, 44, 172, 108, 236, 28, 156, 92, 220, 60, 188, 124, 252, 2, 130, 66, 194, 34, 162, 98, 226, 18, 146, 82, 210, 50, 178, 114, 242, 10, 138, 74, 202, 42, 170, 106, 234, 26, 154, 90, 218, 58, 186, 122, 250, 6, 134, 70, 198, 38, 166, 102, 230, 22, 150, 86, 214, 54, 182, 118, 246, 14, 142, 78, 206, 46, 174, 110, 238, 30, 158, 94, 222, 62, 190, 126, 254, 1, 129, 65, 193, 33, 161, 97, 225, 17, 145, 81, 209, 49, 177, 113, 241, 9, 137, 73, 201, 41, 169, 105, 233, 25, 153, 89, 217, 57, 185, 121, 249, 5, 133, 69, 197, 37, 165, 101, 229, 21, 149, 85, 213, 53, 181, 117, 245, 13, 141, 77, 205, 45, 173, 109, 237, 29, 157, 93, 221, 61, 189, 125, 253, 3, 131, 67, 195, 35, 163, 99, 227, 19, 147, 83, 211, 51, 179, 115, 243, 11, 139, 75, 203, 43, 171, 107, 235, 27, 155, 91, 219, 59, 187, 123, 251, 7, 135, 71, 199, 39, 167, 103, 231, 23, 151, 87, 215, 55, 183, 119, 247, 15, 143, 79, 207, 47, 175, 111, 239, 31, 159, 95, 223, 63, 191, 127, 255], n.cplens = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], n.cplext = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 99, 99], n.cpdist = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577], n.cpdext = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], n.border = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], n.prototype.gunzip = function () {
        return this.outputArr = [], this.nextFile(), this.unzipped;
      }, n.prototype.readByte = function () {
        return this.bits += 8, this.bytepos < this.data.length ? this.data.charCodeAt(this.bytepos++) : -1;
      }, n.prototype.byteAlign = function () {
        this.bb = 1;
      }, n.prototype.readBit = function () {
        var t;
        return this.bits++, t = 1 & this.bb, this.bb >>= 1, 0 === this.bb && (this.bb = this.readByte(), t = 1 & this.bb, this.bb = this.bb >> 1 | 128), t;
      }, n.prototype.readBits = function (t) {
        for (var e = 0, r = t; r--;) {
          e = e << 1 | this.readBit();
        }

        return t && (e = n.bitReverse[e] >> 8 - t), e;
      }, n.prototype.flushBuffer = function () {
        this.bIdx = 0;
      }, n.prototype.addBuffer = function (t) {
        this.buf32k[this.bIdx++] = t, this.outputArr.push(String.fromCharCode(t)), 32768 === this.bIdx && (this.bIdx = 0);
      }, n.prototype.IsPat = function () {
        for (;;) {
          if (this.fpos[this.len] >= this.fmax) return -1;
          if (this.flens[this.fpos[this.len]] === this.len) return this.fpos[this.len]++;
          this.fpos[this.len]++;
        }
      }, n.prototype.Rec = function () {
        var t,
            e = this.Places[this.treepos];
        if (17 === this.len) return -1;
        if (this.treepos++, this.len++, (t = this.IsPat()) >= 0) e.b0 = t;else if (e.b0 = 32768, this.Rec()) return -1;
        if ((t = this.IsPat()) >= 0) e.b1 = t, e.jump = null;else if (e.b1 = 32768, e.jump = this.Places[this.treepos], e.jumppos = this.treepos, this.Rec()) return -1;
        return this.len--, 0;
      }, n.prototype.CreateTree = function (t, e, r) {
        var i;

        for (this.Places = t, this.treepos = 0, this.flens = r, this.fmax = e, i = 0; i < 17; i++) {
          this.fpos[i] = 0;
        }

        return this.len = 0, this.Rec() ? -1 : 0;
      }, n.prototype.DecodeValue = function (t) {
        for (var e, r, i = 0, s = t[i];;) {
          if (this.readBit()) {
            if (!(32768 & s.b1)) return s.b1;

            for (s = s.jump, e = t.length, r = 0; r < e; r++) {
              if (t[r] === s) {
                i = r;
                break;
              }
            }
          } else {
            if (!(32768 & s.b0)) return s.b0;
            s = t[++i];
          }
        }

        return -1;
      }, n.prototype.DeflateLoop = function () {
        var t, e, r;

        do {
          var i, s;
          if (t = this.readBit(), 0 === (e = this.readBits(2))) for (this.byteAlign(), i = this.readByte(), i |= this.readByte() << 8, s = this.readByte(), 65535 & (i ^ ~(s |= this.readByte() << 8)) && document.write("BlockLen checksum mismatch\n"); i--;) {
            a = this.readByte(), this.addBuffer(a);
          } else if (1 === e) for (;;) {
            if ((h = n.bitReverse[this.readBits(7)] >> 1) > 23 ? (h = h << 1 | this.readBit()) > 199 ? h = (h -= 128) << 1 | this.readBit() : (h -= 48) > 143 && (h += 136) : h += 256, h < 256) this.addBuffer(h);else {
              if (256 === h) break;

              for (h -= 257, y = this.readBits(n.cplext[h]) + n.cplens[h], h = n.bitReverse[this.readBits(5)] >> 3, n.cpdext[h] > 8 ? (b = this.readBits(8), b |= this.readBits(n.cpdext[h] - 8) << 8) : b = this.readBits(n.cpdext[h]), b += n.cpdist[h], h = 0; h < y; h++) {
                var a = this.buf32k[this.bIdx - b & 32767];
                this.addBuffer(a);
              }
            }
          } else if (2 === e) {
            var h,
                f,
                o,
                u,
                l,
                c = new Array(320);

            for (o = 257 + this.readBits(5), u = 1 + this.readBits(5), l = 4 + this.readBits(4), h = 0; h < 19; h++) {
              c[h] = 0;
            }

            for (h = 0; h < l; h++) {
              c[n.border[h]] = this.readBits(3);
            }

            for (y = this.distanceTree.length, r = 0; r < y; r++) {
              this.distanceTree[r] = new n.HufNode();
            }

            if (this.CreateTree(this.distanceTree, 19, c, 0)) return this.flushBuffer(), 1;

            for (f = o + u, r = 0; r < f;) {
              if ((h = this.DecodeValue(this.distanceTree)) < 16) c[r++] = h;else if (16 === h) {
                var d;
                if (r + (h = 3 + this.readBits(2)) > f) return this.flushBuffer(), 1;

                for (d = r ? c[r - 1] : 0; h--;) {
                  c[r++] = d;
                }
              } else {
                if (r + (h = 17 === h ? 3 + this.readBits(3) : 11 + this.readBits(7)) > f) return this.flushBuffer(), 1;

                for (; h--;) {
                  c[r++] = 0;
                }
              }
            }

            for (y = this.literalTree.length, r = 0; r < y; r++) {
              this.literalTree[r] = new n.HufNode();
            }

            if (this.CreateTree(this.literalTree, o, c, 0)) return this.flushBuffer(), 1;

            for (y = this.literalTree.length, r = 0; r < y; r++) {
              this.distanceTree[r] = new n.HufNode();
            }

            var p = new Array();

            for (r = o; r < c.length; r++) {
              p[r - o] = c[r];
            }

            if (this.CreateTree(this.distanceTree, u, p, 0)) return this.flushBuffer(), 1;

            for (;;) {
              if ((h = this.DecodeValue(this.literalTree)) >= 256) {
                var y, b;
                if (0 == (h -= 256)) break;

                for (h--, y = this.readBits(n.cplext[h]) + n.cplens[h], h = this.DecodeValue(this.distanceTree), n.cpdext[h] > 8 ? (b = this.readBits(8), b |= this.readBits(n.cpdext[h] - 8) << 8) : b = this.readBits(n.cpdext[h]), b += n.cpdist[h]; y--;) {
                  a = this.buf32k[this.bIdx - b & 32767], this.addBuffer(a);
                }
              } else this.addBuffer(h);
            }
          }
        } while (!t);

        return this.flushBuffer(), this.byteAlign(), 0;
      }, n.prototype.unzipFile = function (t) {
        var e;

        for (this.gunzip(), e = 0; e < this.unzipped.length; e++) {
          if (this.unzipped[e][1] === t) return this.unzipped[e][0];
        }
      }, n.prototype.nextFile = function () {
        this.outputArr = [], this.modeZIP = !1;
        var t = [];

        if (t[0] = this.readByte(), t[1] = this.readByte(), 120 === t[0] && 218 === t[1] && (this.DeflateLoop(), this.unzipped[this.files] = [this.outputArr.join(""), "geonext.gxt"], this.files++), 31 === t[0] && 139 === t[1] && (this.skipdir(), this.unzipped[this.files] = [this.outputArr.join(""), "file"], this.files++), 80 === t[0] && 75 === t[1] && (this.modeZIP = !0, t[2] = this.readByte(), t[3] = this.readByte(), 3 === t[2] && 4 === t[3])) {
          t[0] = this.readByte(), t[1] = this.readByte(), this.gpflags = this.readByte(), this.gpflags |= this.readByte() << 8;
          var e = this.readByte();
          e |= this.readByte() << 8, this.readByte(), this.readByte(), this.readByte(), this.readByte(), this.readByte(), this.readByte(), this.readByte(), this.readByte(), this.readByte(), this.readByte(), this.readByte(), this.readByte();
          var r = this.readByte();
          r |= this.readByte() << 8;
          var i = this.readByte();

          for (i |= this.readByte() << 8, a = 0, this.nameBuf = []; r--;) {
            var s = this.readByte();
            "/" === s | ":" === s ? a = 0 : a < n.NAMEMAX - 1 && (this.nameBuf[a++] = String.fromCharCode(s));
          }

          this.fileout || (this.fileout = this.nameBuf);

          for (var a = 0; a < i;) {
            s = this.readByte(), a++;
          }

          8 === e && (this.DeflateLoop(), this.unzipped[this.files] = [this.outputArr.join(""), this.nameBuf.join("")], this.files++), this.skipdir();
        }
      }, n.prototype.skipdir = function () {
        var t,
            e,
            r = [];
        if (8 & this.gpflags && (r[0] = this.readByte(), r[1] = this.readByte(), r[2] = this.readByte(), r[3] = this.readByte(), this.readByte(), this.readByte(), this.readByte(), this.readByte(), this.readByte(), this.readByte(), this.readByte(), this.readByte()), this.modeZIP && this.nextFile(), r[0] = this.readByte(), 8 !== r[0]) return 0;
        if (this.gpflags = this.readByte(), this.readByte(), this.readByte(), this.readByte(), this.readByte(), this.readByte(), this.readByte(), 4 & this.gpflags) for (r[0] = this.readByte(), r[2] = this.readByte(), this.len = r[0] + 256 * r[1], t = 0; t < this.len; t++) {
          this.readByte();
        }
        if (8 & this.gpflags) for (t = 0, this.nameBuf = []; e = this.readByte();) {
          "7" !== e && ":" !== e || (t = 0), t < n.NAMEMAX - 1 && (this.nameBuf[t++] = e);
        }
        if (16 & this.gpflags) for (; e = this.readByte();) {
          ;
        }
        2 & this.gpflags && (this.readByte(), this.readByte()), this.DeflateLoop(), this.readByte(), this.readByte(), this.readByte(), this.readByte(), this.modeZIP && this.nextFile();
      };
      var f = t("c", {
        name: "Jacob__Codec"
      });
      f.Base64 = h, f.GZip = n, f.unzip = function () {
        return f.GZip.gunzip.apply(f.GZip, arguments);
      }, f.unzipBase64 = function () {
        var t = f.Base64.decode.apply(f.Base64, arguments);

        try {
          return f.GZip.gunzip.call(f.GZip, t);
        } catch (e) {
          return t.slice(7);
        }
      }, f.unzipBase64AsArray = function (t, e) {
        e = e || 1;
        var r,
            i,
            s,
            a = this.unzipBase64(t),
            h = [];

        for (r = 0, s = a.length / e; r < s; r++) {
          for (h[r] = 0, i = e - 1; i >= 0; --i) {
            h[r] += a.charCodeAt(r * e + i) << 8 * i;
          }
        }

        return h;
      }, f.unzipAsArray = function (t, e) {
        e = e || 1;
        var r,
            i,
            s,
            a = this.unzip(t),
            h = [];

        for (r = 0, s = a.length / e; r < s; r++) {
          for (h[r] = 0, i = e - 1; i >= 0; --i) {
            h[r] += a.charCodeAt(r * e + i) << 8 * i;
          }
        }

        return h;
      };
    }
  };
}); 
 			}); 
		define("__plugin__/wx0446ba2621dda60a/audio.js", function(require, module, exports){ 			
"use strict";

var _typeof2 = require("@babel/runtime/helpers/typeof");

System.register(["./texture-barrier-60b5983b.js", "./json-asset-933a1d4c.js", "./index-f2b92470.js", "./renderable-component-7c6600ed.js", "./deprecated-26630860.js", "./deprecated-ef6bb945.js"], function (t) {
  "use strict";

  var e, n, o, i, r, u, a, s, c, d, l, h, f, _, p, y, v, g, m, T, N, E, P, I, A, O, S;

  return {
    setters: [function (t) {
      e = t.bU, n = t.bR, o = t.c0, i = t.bJ, r = t.c7, u = t.l, a = t.bT, s = t.c1, c = t.b$, d = t.cr, l = t.bX;
    }, function (t) {
      h = t.aa, f = t.ab, _ = t.bW, p = t.aL, y = t.dz, v = t.bX, g = t.bZ, m = t.cg, T = t.ch, N = t.cc, E = t.dj, P = t.bm, I = t.ax, A = t.az;
    }, function (t) {
      O = t.d, S = t.f;
    }, function () {}, function () {}, function () {}],
    execute: function execute() {
      var w, D, b;
      !function (t) {
        t.PLAYED = "play", t.PAUSED = "pause", t.STOPPED = "stop", t.SEEKED = "seeked", t.ENDED = "ended", t.INTERRUPTION_BEGIN = "interruptionBegin", t.INTERRUPTION_END = "interruptionEnd", t.USER_GESTURE = "on_gesture";
      }(w || (w = {})), function (t) {
        t[t.DOM_AUDIO = 0] = "DOM_AUDIO", t[t.WEB_AUDIO = 1] = "WEB_AUDIO", t[t.MINIGAME_AUDIO = 2] = "MINIGAME_AUDIO", t[t.NATIVE_AUDIO = 3] = "NATIVE_AUDIO", t[t.UNKNOWN_AUDIO = 4] = "UNKNOWN_AUDIO";
      }(D || (D = {})), function (t) {
        t[t.INIT = 0] = "INIT", t[t.PLAYING = 1] = "PLAYING", t[t.PAUSED = 2] = "PAUSED", t[t.STOPPED = 3] = "STOPPED", t[t.INTERRUPTED = 4] = "INTERRUPTED";
      }(b || (b = {}));
      var C = 0;

      function k(t, e) {
        var n;
        e.invoking || (e.invoking = !0, (n = e.func).call.apply(n, [t].concat(e.args)).then(function () {
          e.invoking = !1, t._operationQueue.shift(), t._eventTarget.emit(e.id.toString());
          var n = t._operationQueue[0];
          n && k(t, n);
        }).catch(function () {}));
      }

      function R(t, e, n) {
        var o = n.value;

        n.value = function () {
          for (var t = this, e = arguments.length, n = new Array(e), i = 0; i < e; i++) {
            n[i] = arguments[i];
          }

          return new Promise(function (e) {
            var i = C++,
                r = t;
            r._operationQueue.push({
              id: i,
              func: o,
              args: n,
              invoking: !1
            }), r._eventTarget.once(i.toString(), e), k(r, r._operationQueue[0]);
          });
        };
      }

      var U,
          B,
          L,
          x,
          M,
          G,
          j,
          H,
          Y,
          W,
          z,
          K = function () {
        function t(t) {
          this._nativeAudio = void 0, this._startTime = 0, this._startOffset = 0, this._isPaused = !0, this._nativeAudio = t;
        }

        var n = t.prototype;
        return n.destroy = function () {
          this._nativeAudio = void 0;
        }, n._now = function () {
          return performance.now() / 1e3;
        }, n._calculateCurrentTime = function () {
          var t = this._now() - this._startTime,
              e = this._startOffset + t;

          return e >= this.duration && (this._startTime = this._now(), this._startOffset = 0), e % this.duration;
        }, n.start = function () {
          this._isPaused = !1, this._startTime = this._now();
        }, n.pause = function () {
          this._isPaused || (this._isPaused = !0, this._startOffset = this._calculateCurrentTime());
        }, n.stop = function () {
          this._isPaused = !0, this._startOffset = 0;
        }, n.seek = function (t) {
          this._startTime = this._now(), this._startOffset = h(t, 0, this.duration);
        }, e(t, [{
          key: "duration",
          get: function get() {
            return this._nativeAudio.duration;
          }
        }, {
          key: "currentTime",
          get: function get() {
            return this._isPaused ? this._startOffset : this._calculateCurrentTime();
          }
        }]), t;
      }(),
          Q = function () {
        function t(t, e) {
          var n = this;
          this._innerAudioContext = void 0, this._onPlayCb = void 0, this._onEndCb = void 0, this._innerAudioContext = t, t.volume = e, t.onPlay(function () {
            var t;
            null === (t = n._onPlayCb) || void 0 === t || t.call(n);
          }), t.onEnded(function () {
            var e;
            null === (e = n._onEndCb) || void 0 === e || e.call(n), t.destroy(), n._innerAudioContext = null;
          });
        }

        var n = t.prototype;
        return n.play = function () {
          this._innerAudioContext.play();
        }, n.stop = function () {
          this._innerAudioContext.stop();
        }, e(t, [{
          key: "onPlay",
          get: function get() {
            return this._onPlayCb;
          },
          set: function set(t) {
            this._onPlayCb = t;
          }
        }, {
          key: "onEnd",
          get: function get() {
            return this._onEndCb;
          },
          set: function set(t) {
            this._onEndCb = t;
          }
        }]), t;
      }(),
          V = (B = function () {
        function t(t) {
          var e = this;
          this._innerAudioContext = void 0, this._state = b.INIT, this._onPlay = void 0, this._onPause = void 0, this._onStop = void 0, this._onSeeked = void 0, this._onEnded = void 0, this._audioTimer = void 0, this._readyToHandleOnShow = !1, this._eventTarget = new i(), this._operationQueue = [], this._innerAudioContext = t, this._audioTimer = new K(t), this._eventTarget = new i(), n.on("hide", this._onHide, this), n.on("show", this._onShow, this);
          var o = this._eventTarget;
          this._onPlay = function () {
            e._state = b.PLAYING, o.emit(w.PLAYED);
          }, t.onPlay(this._onPlay), this._onPause = function () {
            e._state = b.PAUSED, o.emit(w.PAUSED);
          }, t.onPause(this._onPause), this._onStop = function () {
            e._state = b.STOPPED, o.emit(w.STOPPED);
          }, t.onStop(this._onStop), this._onSeeked = function () {
            o.emit(w.SEEKED);
          }, t.onSeeked(this._onSeeked), this._onEnded = function () {
            e._audioTimer.stop(), e._state = b.INIT, o.emit(w.ENDED);
          }, t.onEnded(this._onEnded);
        }

        var o = t.prototype;
        return o.destroy = function () {
          var t = this;
          this._audioTimer.destroy(), n.off("hide", this._onHide, this), n.off("show", this._onShow, this), this._innerAudioContext && (["Play", "Pause", "Stop", "Seeked", "Ended"].forEach(function (e) {
            t._offEvent(e);
          }), this._innerAudioContext.destroy(), this._innerAudioContext = null);
        }, o._onHide = function () {
          var t = this;
          this._state === b.PLAYING && this.pause().then(function () {
            t._state = b.INTERRUPTED, t._readyToHandleOnShow = !0, t._eventTarget.emit(w.INTERRUPTION_BEGIN);
          }).catch(function () {});
        }, o._onShow = function () {
          var t = this;
          this._readyToHandleOnShow ? (this._state === b.INTERRUPTED && this.play().then(function () {
            t._eventTarget.emit(w.INTERRUPTION_END);
          }).catch(function () {}), this._readyToHandleOnShow = !1) : this._eventTarget.once(w.INTERRUPTION_BEGIN, this._onShow, this);
        }, o._offEvent = function (t) {
          this["_on" + t] && (this._innerAudioContext["off" + t](this["_on" + t]), this["_on" + t] = null);
        }, t.load = function (e) {
          return new Promise(function (n) {
            t.loadNative(e).then(function (e) {
              n(new t(e));
            }).catch(function () {});
          });
        }, t.loadNative = function (t) {
          return new Promise(function (e, n) {
            var o = r.createInnerAudioContext(),
                i = setTimeout(function () {
              u(), e(o);
            }, 8e3);

            function u() {
              o.offCanplay(a), o.offError(s);
            }

            function a() {
              u(), clearTimeout(i), e(o);
            }

            function s(t) {
              u(), clearTimeout(i), console.error("failed to load innerAudioContext"), n(new Error(t));
            }

            o.onCanplay(a), o.onError(s), o.src = t;
          });
        }, t.loadOneShotAudio = function (e, n) {
          return new Promise(function (o, i) {
            t.loadNative(e).then(function (t) {
              o(new Q(t, n));
            }).catch(i);
          });
        }, o.seek = function (t) {
          var e = this;
          return new Promise(function (n) {
            t = h(t, 0, e.duration), e._eventTarget.once(w.SEEKED, n), e._innerAudioContext.seek(t), e._audioTimer.seek(t);
          });
        }, o.play = function () {
          var t = this;
          return new Promise(function (e) {
            t._eventTarget.once(w.PLAYED, e), t._innerAudioContext.play(), t._audioTimer.start();
          });
        }, o.pause = function () {
          var t = this;
          return new Promise(function (e) {
            t._eventTarget.once(w.PAUSED, e), t._innerAudioContext.pause(), t._audioTimer.pause();
          });
        }, o.stop = function () {
          var t = this;
          return new Promise(function (e) {
            t._eventTarget.once(w.STOPPED, e), t._innerAudioContext.stop(), t._audioTimer.stop();
          });
        }, o.onInterruptionBegin = function (t) {
          this._eventTarget.on(w.INTERRUPTION_BEGIN, t);
        }, o.offInterruptionBegin = function (t) {
          this._eventTarget.off(w.INTERRUPTION_BEGIN, t);
        }, o.onInterruptionEnd = function (t) {
          this._eventTarget.on(w.INTERRUPTION_END, t);
        }, o.offInterruptionEnd = function (t) {
          this._eventTarget.off(w.INTERRUPTION_END, t);
        }, o.onEnded = function (t) {
          this._eventTarget.on(w.ENDED, t);
        }, o.offEnded = function (t) {
          this._eventTarget.off(w.ENDED, t);
        }, e(t, [{
          key: "src",
          get: function get() {
            return this._innerAudioContext ? this._innerAudioContext.src : "";
          }
        }, {
          key: "type",
          get: function get() {
            return D.MINIGAME_AUDIO;
          }
        }, {
          key: "state",
          get: function get() {
            return this._state;
          }
        }, {
          key: "loop",
          get: function get() {
            return this._innerAudioContext.loop;
          },
          set: function set(t) {
            this._innerAudioContext.loop = t;
          }
        }, {
          key: "volume",
          get: function get() {
            return this._innerAudioContext.volume;
          },
          set: function set(t) {
            t = f(t), this._innerAudioContext.volume = t;
          }
        }, {
          key: "duration",
          get: function get() {
            return this._innerAudioContext.duration;
          }
        }, {
          key: "currentTime",
          get: function get() {
            return this._audioTimer ? this._audioTimer.currentTime : 0;
          }
        }]), t;
      }(), o((U = B).prototype, "seek", [R], Object.getOwnPropertyDescriptor(U.prototype, "seek"), U.prototype), o(U.prototype, "play", [R], Object.getOwnPropertyDescriptor(U.prototype, "play"), U.prototype), o(U.prototype, "pause", [R], Object.getOwnPropertyDescriptor(U.prototype, "pause"), U.prototype), o(U.prototype, "stop", [R], Object.getOwnPropertyDescriptor(U.prototype, "stop"), U.prototype), U),
          X = new (function () {
        function t() {
          this._audioBufferDataMap = {};
        }

        var e = t.prototype;
        return e.addCache = function (t, e) {
          this._audioBufferDataMap[t] ? console.warn("Audio buffer " + t + " has been cached") : this._audioBufferDataMap[t] = {
            usedCount: 1,
            audioBuffer: e
          };
        }, e.retainCache = function (t) {
          var e = this._audioBufferDataMap[t];
          e ? e.usedCount++ : console.warn("Audio buffer cache " + t + " has not been added.");
        }, e.getCache = function (t) {
          var e = this._audioBufferDataMap[t];
          return null == e ? void 0 : e.audioBuffer;
        }, e.tryReleasingCache = function (t) {
          var e = this._audioBufferDataMap[t];
          e ? --e.usedCount <= 0 && delete this._audioBufferDataMap[t] : console.warn("Audio buffer cache " + t + " has not been added.");
        }, t;
      }())(),
          J = null === (L = r.tt) || void 0 === L || null === (x = L.getAudioContext) || void 0 === x ? void 0 : x.call(L),
          Z = function () {
        function t(t, e, n) {
          this._bufferSourceNode = void 0, this._onPlayCb = void 0, this._url = void 0, this._onEndCb = void 0, this._bufferSourceNode = J.createBufferSource(), this._bufferSourceNode.buffer = t, this._bufferSourceNode.loop = !1, this._url = n;
          var o = J.createGain();
          o.gain.value = e, this._bufferSourceNode.connect(o), o.connect(J.destination);
        }

        var n = t.prototype;
        return n.play = function () {
          var t,
              e = this;
          this._bufferSourceNode.start(), null === (t = this.onPlay) || void 0 === t || t.call(this), this._bufferSourceNode.onended = function () {
            var t;
            X.tryReleasingCache(e._url), null === (t = e._onEndCb) || void 0 === t || t.call(e);
          };
        }, n.stop = function () {
          this._bufferSourceNode.onended = null, X.tryReleasingCache(this._url), this._bufferSourceNode.stop(), this._bufferSourceNode.buffer = null;
        }, e(t, [{
          key: "onPlay",
          get: function get() {
            return this._onPlayCb;
          },
          set: function set(t) {
            this._onPlayCb = t;
          }
        }, {
          key: "onEnd",
          get: function get() {
            return this._onEndCb;
          },
          set: function set(t) {
            this._onEndCb = t;
          }
        }]), t;
      }(),
          $ = (G = function () {
        function t(t, e) {
          this._src = void 0, this._audioBuffer = void 0, this._sourceNode = void 0, this._gainNode = void 0, this._volume = 1, this._loop = !1, this._state = b.INIT, this._audioTimer = void 0, this._readyToHandleOnShow = !1, this._eventTarget = new i(), this._operationQueue = [], this._audioBuffer = t, this._audioTimer = new K(t), this._gainNode = J.createGain(), this._gainNode.connect(J.destination), this._src = e, n.on("hide", this._onHide, this), n.on("show", this._onShow, this);
        }

        var o = t.prototype;
        return o.destroy = function () {
          this._audioTimer.destroy(), this._audioBuffer && (this._audioBuffer = null), X.tryReleasingCache(this._src), n.off("hide", this._onHide, this), n.off("show", this._onShow, this);
        }, o._onHide = function () {
          var t = this;
          this._state === b.PLAYING && this.pause().then(function () {
            t._state = b.INTERRUPTED, t._readyToHandleOnShow = !0, t._eventTarget.emit(w.INTERRUPTION_BEGIN);
          }).catch(function () {});
        }, o._onShow = function () {
          var t = this;
          this._readyToHandleOnShow ? (this._state === b.INTERRUPTED && this.play().then(function () {
            t._eventTarget.emit(w.INTERRUPTION_END);
          }).catch(function () {}), this._readyToHandleOnShow = !1) : this._eventTarget.once(w.INTERRUPTION_BEGIN, this._onShow, this);
        }, t.load = function (e) {
          return new Promise(function (n) {
            t.loadNative(e).then(function (o) {
              n(new t(o, e));
            }).catch(function () {});
          });
        }, t.loadNative = function (t) {
          return new Promise(function (e, n) {
            var o = X.getCache(t);
            if (o) return X.retainCache(t), void e(o);
            fsUtils.readArrayBuffer(t, function (o, i) {
              o ? n(o) : J.decodeAudioData(i).then(function (n) {
                X.addCache(t, n), e(n);
              }).catch(function () {});
            });
          });
        }, t.loadOneShotAudio = function (e, n) {
          return new Promise(function (o, i) {
            t.loadNative(e).then(function (t) {
              var i = new Z(t, n, e);
              o(i);
            }).catch(i);
          });
        }, o.seek = function (t) {
          var e = this;
          return new Promise(function (n) {
            e._audioTimer.seek(t), e._state === b.PLAYING ? e._doPlay().then(n).catch(function () {}) : n();
          });
        }, o.play = function () {
          return this._doPlay();
        }, o._doPlay = function () {
          var t = this;
          return new Promise(function (e) {
            t._stopSourceNode(), t._sourceNode = J.createBufferSource(), t._sourceNode.buffer = t._audioBuffer, t._sourceNode.loop = t._loop, t._sourceNode.connect(t._gainNode), t._sourceNode.start(0, t._audioTimer.currentTime), t._state = b.PLAYING, t._audioTimer.start(), t._sourceNode.onended = function () {
              t._audioTimer.stop(), t._eventTarget.emit(w.ENDED), t._state = b.INIT;
            }, e();
          });
        }, o._stopSourceNode = function () {
          try {
            this._sourceNode && (this._sourceNode.onended = null, this._sourceNode.stop(), this._sourceNode.buffer = null);
          } catch (t) {}
        }, o.pause = function () {
          return this._state === b.PLAYING && this._sourceNode ? (this._audioTimer.pause(), this._state = b.PAUSED, this._stopSourceNode(), Promise.resolve()) : Promise.resolve();
        }, o.stop = function () {
          return this._sourceNode ? (this._audioTimer.stop(), this._state = b.STOPPED, this._stopSourceNode(), Promise.resolve()) : Promise.resolve();
        }, o.onInterruptionBegin = function (t) {
          this._eventTarget.on(w.INTERRUPTION_BEGIN, t);
        }, o.offInterruptionBegin = function (t) {
          this._eventTarget.off(w.INTERRUPTION_BEGIN, t);
        }, o.onInterruptionEnd = function (t) {
          this._eventTarget.on(w.INTERRUPTION_END, t);
        }, o.offInterruptionEnd = function (t) {
          this._eventTarget.off(w.INTERRUPTION_END, t);
        }, o.onEnded = function (t) {
          this._eventTarget.on(w.ENDED, t);
        }, o.offEnded = function (t) {
          this._eventTarget.off(w.ENDED, t);
        }, e(t, [{
          key: "src",
          get: function get() {
            return this._src;
          }
        }, {
          key: "type",
          get: function get() {
            return D.WEB_AUDIO;
          }
        }, {
          key: "state",
          get: function get() {
            return this._state;
          }
        }, {
          key: "loop",
          get: function get() {
            return this._loop;
          },
          set: function set(t) {
            this._loop = t, this._sourceNode && (this._sourceNode.loop = t);
          }
        }, {
          key: "volume",
          get: function get() {
            return this._volume;
          },
          set: function set(t) {
            t = f(t), this._volume = t, this._gainNode.gain.value = t;
          }
        }, {
          key: "duration",
          get: function get() {
            return this._audioBuffer.duration;
          }
        }, {
          key: "currentTime",
          get: function get() {
            return this._audioTimer.currentTime;
          }
        }]), t;
      }(), o((M = G).prototype, "seek", [R], Object.getOwnPropertyDescriptor(M.prototype, "seek"), M.prototype), o(M.prototype, "play", [R], Object.getOwnPropertyDescriptor(M.prototype, "play"), M.prototype), o(M.prototype, "pause", [R], Object.getOwnPropertyDescriptor(M.prototype, "pause"), M.prototype), o(M.prototype, "stop", [R], Object.getOwnPropertyDescriptor(M.prototype, "stop"), M.prototype), M),
          q = function () {
        function t(t) {
          this._audio = void 0, this._audio = t;
        }

        var n = t.prototype;
        return n.play = function () {
          this._audio.play();
        }, n.stop = function () {
          this._audio.stop();
        }, e(t, [{
          key: "onPlay",
          get: function get() {
            return this._audio.onPlay;
          },
          set: function set(t) {
            this._audio.onPlay = t;
          }
        }, {
          key: "onEnd",
          get: function get() {
            return this._audio.onEnd;
          },
          set: function set(t) {
            this._audio.onEnd = t;
          }
        }]), t;
      }(),
          F = function () {
        function t(t) {
          this._player = void 0, this._player = t;
        }

        t.load = function (e) {
          return new Promise(function (n) {
            "object" == _typeof2(r.tt) && void 0 !== r.tt.getAudioContext ? $.load(e).then(function (e) {
              n(new t(e));
            }).catch(function () {}) : V.load(e).then(function (e) {
              n(new t(e));
            }).catch(function () {});
          });
        };

        var n = t.prototype;
        return n.destroy = function () {
          this._player.destroy();
        }, t.loadNative = function (t) {
          return "object" == _typeof2(r.tt) && void 0 !== r.tt.getAudioContext ? $.loadNative(t) : V.loadNative(t);
        }, t.loadOneShotAudio = function (t, e) {
          return new Promise(function (n, o) {
            "object" == _typeof2(r.tt) && void 0 !== r.tt.getAudioContext ? $.loadOneShotAudio(t, e).then(function (t) {
              n(new q(t));
            }).catch(o) : V.loadOneShotAudio(t, e).then(function (t) {
              n(new q(t));
            }).catch(o);
          });
        }, n.seek = function (t) {
          return this._player.seek(t);
        }, n.play = function () {
          return this._player.play();
        }, n.pause = function () {
          return this._player.pause();
        }, n.stop = function () {
          return this._player.stop();
        }, n.onInterruptionBegin = function (t) {
          this._player.onInterruptionBegin(t);
        }, n.offInterruptionBegin = function (t) {
          this._player.offInterruptionBegin(t);
        }, n.onInterruptionEnd = function (t) {
          this._player.onInterruptionEnd(t);
        }, n.offInterruptionEnd = function (t) {
          this._player.offInterruptionEnd(t);
        }, n.onEnded = function (t) {
          this._player.onEnded(t);
        }, n.offEnded = function (t) {
          this._player.offEnded(t);
        }, e(t, [{
          key: "src",
          get: function get() {
            return this._player.src;
          }
        }, {
          key: "type",
          get: function get() {
            return this._player.type;
          }
        }, {
          key: "state",
          get: function get() {
            return this._player.state;
          }
        }, {
          key: "loop",
          get: function get() {
            return this._player.loop;
          },
          set: function set(t) {
            this._player.loop = t;
          }
        }, {
          key: "volume",
          get: function get() {
            return this._player.volume;
          },
          set: function set(t) {
            this._player.volume = t;
          }
        }, {
          key: "duration",
          get: function get() {
            return this._player.duration;
          }
        }, {
          key: "currentTime",
          get: function get() {
            return this._player.currentTime;
          }
        }]), t;
      }();

      F.maxAudioChannel = 10, u.AudioPlayer = F;
      var tt = t("AudioClip", _("cc.AudioClip")((z = W = function (t) {
        function n() {
          for (var e, n = arguments.length, o = new Array(n), i = 0; i < n; i++) {
            o[i] = arguments[i];
          }

          return e = t.call.apply(t, [this].concat(o)) || this, s(e, "_duration", Y, c(e)), e._loadMode = D.UNKNOWN_AUDIO, e._meta = null, e._player = null, e;
        }

        a(n, t);
        var o = n.prototype;
        return o.destroy = function () {
          var e,
              n = t.prototype.destroy.call(this);
          return null === (e = this._player) || void 0 === e || e.destroy(), this._player = null, this._meta && (this._meta.player = null), n;
        }, o.validate = function () {
          return !!this._meta;
        }, o.getDuration = function () {
          return this._duration ? this._duration : this._meta ? this._meta.duration : 0;
        }, o.getCurrentTime = function () {
          return this._player ? this._player.currentTime : 0;
        }, o.getVolume = function () {
          return this._player ? this._player.volume : 0;
        }, o.getLoop = function () {
          return !!this._player && this._player.loop;
        }, o.setCurrentTime = function (t) {
          var e;
          null === (e = this._player) || void 0 === e || e.seek(t).catch(function () {});
        }, o.setVolume = function (t) {
          this._player && (this._player.volume = t);
        }, o.setLoop = function (t) {
          this._player && (this._player.loop = t);
        }, o.play = function () {
          var t;
          null === (t = this._player) || void 0 === t || t.play().catch(function () {});
        }, o.pause = function () {
          var t;
          null === (t = this._player) || void 0 === t || t.pause().catch(function () {});
        }, o.stop = function () {
          var t;
          null === (t = this._player) || void 0 === t || t.stop().catch(function () {});
        }, o.playOneShot = function (t) {
          void 0 === t && (t = 1), this._nativeAsset && F.loadOneShotAudio(this._nativeAsset.url, t).then(function (t) {
            t.play();
          }).catch(function () {});
        }, e(n, [{
          key: "_nativeAsset",
          get: function get() {
            return this._meta;
          },
          set: function set(t) {
            this._meta = t, t ? (this._loadMode = t.type, this._player = t.player) : (this._meta = null, this._loadMode = D.UNKNOWN_AUDIO, this._duration = 0);
          }
        }, {
          key: "_nativeDep",
          get: function get() {
            return {
              uuid: this._uuid,
              audioLoadMode: this.loadMode,
              ext: this._native,
              __isNative__: !0
            };
          }
        }, {
          key: "loadMode",
          get: function get() {
            return this._loadMode;
          }
        }, {
          key: "state",
          get: function get() {
            return this._player ? this._player.state : b.INIT;
          }
        }]), n;
      }(p), W.AudioType = D, Y = o((H = z).prototype, "_duration", [v], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 0;
        }
      }), o(H.prototype, "_nativeDep", [y], Object.getOwnPropertyDescriptor(H.prototype, "_nativeDep"), H.prototype), j = H)) || j);

      function et(t, e, n) {
        F.load(t, {
          audioLoadMode: e.audioLoadMode
        }).then(function (e) {
          var o = {
            player: e,
            url: t,
            duration: e.duration,
            type: e.type
          };
          n(null, o);
        }).catch(function (t) {
          n(t);
        });
      }

      function nt(t, e, n, o) {
        var i = new tt();
        i._nativeUrl = t, i._nativeAsset = e, i._duration = e.duration, o(null, i);
      }

      u.AudioClip = tt, O.register({
        ".mp3": et,
        ".ogg": et,
        ".wav": et,
        ".m4a": et
      }), S.register({
        ".mp3": nt,
        ".ogg": nt,
        ".wav": nt,
        ".m4a": nt
      });

      var ot,
          it,
          rt,
          ut,
          at,
          st,
          ct,
          dt,
          lt,
          ht,
          ft,
          _t,
          pt,
          yt,
          vt,
          gt,
          mt,
          Tt,
          Nt,
          Et = new (function () {
        function t() {
          this._oneShotAudioInfoList = [], this._audioPlayerInfoList = [];
        }

        var e = t.prototype;
        return e._findIndex = function (t, e) {
          return t.findIndex(function (t) {
            return t.audio === e;
          });
        }, e._tryAddPlaying = function (t, e) {
          var n = this._findIndex(t, e);

          return n > -1 ? (t[n].playTime = performance.now(), !1) : (t.push({
            audio: e,
            playTime: performance.now()
          }), !0);
        }, e.addPlaying = function (t) {
          if (t instanceof F) {
            if (this._tryAddPlaying(this._audioPlayerInfoList, t)) return;
          } else this._tryAddPlaying(this._oneShotAudioInfoList, t);
        }, e._tryRemovePlaying = function (t, e) {
          var n = this._findIndex(t, e);

          return -1 !== n && (d(t, n), !0);
        }, e.removePlaying = function (t) {
          if (t instanceof F) {
            if (this._tryRemovePlaying(this._audioPlayerInfoList, t)) return;
          } else this._tryRemovePlaying(this._oneShotAudioInfoList, t);
        }, e.discardOnePlayingIfNeeded = function () {
          var t;
          this._audioPlayerInfoList.length + this._oneShotAudioInfoList.length < F.maxAudioChannel || (this._oneShotAudioInfoList.length > 0 ? this._oneShotAudioInfoList.forEach(function (e) {
            (!t || e.playTime < t.playTime) && (t = e);
          }) : this._audioPlayerInfoList.forEach(function (e) {
            (!t || e.playTime < t.playTime) && (t = e);
          }), t && (t.audio.stop(), this.removePlaying(t.audio)));
        }, t;
      }())();

      !function (t) {
        t.STARTED = "started", t.ENDED = "ended";
      }(Nt || (Nt = {}));
      var Pt,
          It = (ot = _("cc.AudioSource"), it = m(), rt = T(), ut = g(tt), at = g(tt), st = N(), ct = N(), dt = N(), lt = E(), ht = N(), Pt = ot(ft = it(ft = rt((Tt = mt = function (t) {
        function n() {
          for (var e, n = arguments.length, o = new Array(n), i = 0; i < n; i++) {
            o[i] = arguments[i];
          }

          return e = t.call.apply(t, [this].concat(o)) || this, s(e, "_clip", pt, c(e)), e._player = null, s(e, "_loop", yt, c(e)), s(e, "_playOnAwake", vt, c(e)), s(e, "_volume", gt, c(e)), e._cachedCurrentTime = 0, e._operationsBeforeLoading = [], e._isLoaded = !1, e._lastSetClip = null, e;
        }

        a(n, t);
        var o = n.prototype;
        return o._syncPlayer = function () {
          var t = this,
              e = this._clip;
          this._isLoaded = !1, this._lastSetClip !== e && (e ? e._nativeAsset ? (this._lastSetClip = e, F.load(e._nativeAsset.url, {
            audioLoadMode: e.loadMode
          }).then(function (n) {
            t._lastSetClip === e ? (t._isLoaded = !0, t._player && (Et.removePlaying(t._player), t._player.offEnded(), t._player.offInterruptionBegin(), t._player.offInterruptionEnd(), t._player.destroy()), t._player = n, n.onEnded(function () {
              Et.removePlaying(n), t.node.emit(Nt.ENDED, t);
            }), n.onInterruptionBegin(function () {
              Et.removePlaying(n);
            }), n.onInterruptionEnd(function () {
              Et.addPlaying(n);
            }), t._syncStates()) : n.destroy();
          }).catch(function () {})) : console.error("Invalid audio clip") : this._lastSetClip = null);
        }, o.onLoad = function () {
          this._syncPlayer();
        }, o.onEnable = function () {
          this._playOnAwake && !this.playing && this.play();
        }, o.onDisable = function () {
          var t = this._getRootNode();

          (null == t ? void 0 : t._persistNode) || this.pause();
        }, o.onDestroy = function () {
          var t;
          this.stop(), null === (t = this._player) || void 0 === t || t.destroy(), this._player = null;
        }, o._getRootNode = function () {
          for (var t, e, n = this.node, o = null === (t = n) || void 0 === t || null === (e = t.parent) || void 0 === e ? void 0 : e.parent; o;) {
            var i, r, u;
            o = null === (r = n = null === (i = n) || void 0 === i ? void 0 : i.parent) || void 0 === r || null === (u = r.parent) || void 0 === u ? void 0 : u.parent;
          }

          return n;
        }, o.play = function () {
          var t,
              e,
              n = this;
          this._isLoaded ? (Et.discardOnePlayingIfNeeded(), this.state === b.PLAYING && (null === (e = this._player) || void 0 === e || e.stop().catch(function () {})), null === (t = this._player) || void 0 === t || t.play().then(function () {
            Et.addPlaying(n._player), n.node.emit(Nt.STARTED, n);
          }).catch(function () {})) : this._operationsBeforeLoading.push("play");
        }, o.pause = function () {
          var t,
              e = this;
          this._isLoaded ? null === (t = this._player) || void 0 === t || t.pause().then(function () {
            Et.removePlaying(e._player);
          }).catch(function () {}) : this._operationsBeforeLoading.push("pause");
        }, o.stop = function () {
          var t,
              e = this;
          this._isLoaded ? null === (t = this._player) || void 0 === t || t.stop().then(function () {
            Et.removePlaying(e._player);
          }).catch(function () {}) : this._operationsBeforeLoading.push("stop");
        }, o.playOneShot = function (t, e) {
          void 0 === e && (e = 1), t._nativeAsset ? F.loadOneShotAudio(t._nativeAsset.url, this._volume * e, {
            audioLoadMode: t.loadMode
          }).then(function (t) {
            Et.discardOnePlayingIfNeeded(), t.onPlay = function () {
              Et.addPlaying(t);
            }, t.onEnd = function () {
              Et.removePlaying(t);
            }, t.play();
          }).catch(function () {}) : console.error("Invalid audio clip");
        }, o._syncStates = function () {
          var t = this;
          this._player && this._player.seek(this._cachedCurrentTime).then(function () {
            t._player && (t._player.loop = t._loop, t._player.volume = t._volume, t._operationsBeforeLoading.forEach(function (e) {
              var n;
              null === (n = t[e]) || void 0 === n || n.call(t);
            }), t._operationsBeforeLoading.length = 0);
          }).catch(function () {});
        }, e(n, [{
          key: "clip",
          get: function get() {
            return this._clip;
          },
          set: function set(t) {
            t !== this._clip && (this._clip = t, this._syncPlayer());
          }
        }, {
          key: "loop",
          get: function get() {
            return this._loop;
          },
          set: function set(t) {
            this._loop = t, this._player && (this._player.loop = t);
          }
        }, {
          key: "playOnAwake",
          get: function get() {
            return this._playOnAwake;
          },
          set: function set(t) {
            this._playOnAwake = t;
          }
        }, {
          key: "volume",
          get: function get() {
            return this._volume;
          },
          set: function set(t) {
            Number.isNaN(t) ? console.warn("illegal audio volume!") : (t = h(t, 0, 1), this._player ? (this._player.volume = t, this._volume = this._player.volume) : this._volume = t);
          }
        }, {
          key: "currentTime",
          get: function get() {
            return this._player ? this._player.currentTime : this._cachedCurrentTime;
          },
          set: function set(t) {
            var e;
            Number.isNaN(t) ? console.warn("illegal audio time!") : (t = h(t, 0, this.duration), this._cachedCurrentTime = t, null === (e = this._player) || void 0 === e || e.seek(this._cachedCurrentTime).catch(function () {}));
          }
        }, {
          key: "duration",
          get: function get() {
            var t, e;
            return null !== (t = null === (e = this._clip) || void 0 === e ? void 0 : e.getDuration()) && void 0 !== t ? t : this._player ? this._player.duration : 0;
          }
        }, {
          key: "state",
          get: function get() {
            return this._player ? this._player.state : b.INIT;
          }
        }, {
          key: "playing",
          get: function get() {
            return this.state === n.AudioState.PLAYING;
          }
        }], [{
          key: "maxAudioChannel",
          get: function get() {
            return F.maxAudioChannel;
          }
        }]), n;
      }(P), mt.AudioState = b, mt.EventType = Nt, pt = o((_t = Tt).prototype, "_clip", [ut], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return null;
        }
      }), yt = o(_t.prototype, "_loop", [v], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !1;
        }
      }), vt = o(_t.prototype, "_playOnAwake", [v], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !0;
        }
      }), gt = o(_t.prototype, "_volume", [v], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 1;
        }
      }), o(_t.prototype, "clip", [at, st], Object.getOwnPropertyDescriptor(_t.prototype, "clip"), _t.prototype), o(_t.prototype, "loop", [ct], Object.getOwnPropertyDescriptor(_t.prototype, "loop"), _t.prototype), o(_t.prototype, "playOnAwake", [dt], Object.getOwnPropertyDescriptor(_t.prototype, "playOnAwake"), _t.prototype), o(_t.prototype, "volume", [lt, ht], Object.getOwnPropertyDescriptor(_t.prototype, "volume"), _t.prototype), ft = _t)) || ft) || ft) || ft, t({
        AudioSource: Pt,
        AudioSourceComponent: Pt
      }), Pt);
      I(tt, "AudioClip", [{
        name: "PlayingState",
        newName: "AudioState",
        target: It,
        targetName: "AudioSource"
      }]), A(tt.prototype, "AudioClip.prototype", ["state", "play", "pause", "stop", "playOneShot", "setCurrentTime", "setVolume", "setLoop", "getCurrentTime", "getVolume", "getLoop"].map(function (t) {
        return {
          name: t,
          suggest: "please use AudioSource.prototype." + t + " instead"
        };
      })), u.AudioSourceComponent = It, l.setClassAlias(It, "cc.AudioSourceComponent");
    }
  };
}); 
 			}); 
		define("__plugin__/wx0446ba2621dda60a/base.js", function(require, module, exports){ 			
"use strict";

System.register(["./texture-barrier-60b5983b.js", "./json-asset-933a1d4c.js", "./index-f2b92470.js", "./renderable-component-7c6600ed.js", "./deprecated-26630860.js", "./deprecated-ef6bb945.js"], function (e) {
  "use strict";

  var t, r, a, n, o, i, l, u, s, g, p, c, d, b, f, m, S, h, v, T, y, I, C, P, A, R, D, B, F, _, N, E, M, w, O, L, x, V, j, z, U, G, H, k, Q, W, J, X, Y, q, K, Z, $, ee, te, re, ae, ne, oe, ie, le, ue, se, ge, pe, ce, de, be, fe, me, Se, he, ve, Te, ye, Ie, Ce, Pe, Ae, Re, De, Be, Fe, _e, Ne, Ee, Me, we, Oe, Le, xe, Ve, je, ze, Ue, Ge, He, ke, Qe, We, Je, Xe, Ye, qe, Ke, Ze, $e, et, tt, rt, at, nt, ot, it, lt, ut, st, gt, pt, ct, dt, bt, ft, mt, St, ht, vt, Tt, yt, It, Ct, Pt, At, Rt, Dt, Bt, Ft, _t, Nt, Et, Mt, wt, Ot, Lt, xt, Vt, jt, zt, Ut, Gt, Ht, kt, Qt, Wt, Jt, Xt, Yt, qt, Kt, Zt, $t, er, tr, rr, ar, nr, or, ir, lr, ur, sr, gr, pr, cr, dr, br, fr, mr, Sr, hr, vr, Tr, yr, Ir, Cr, Pr, Ar, Rr, Dr, Br, Fr, _r, Nr, Er, Mr, wr, Or, Lr, xr, Vr, jr, zr, Ur, Gr, Hr, kr, Qr, Wr, Jr, Xr, Yr, qr, Kr;

  return {
    setters: [function (Vt) {
      t = Vt.P, r = Vt.R, a = Vt.C, n = Vt.l, o = Vt.a, i = Vt.w, l = Vt.e, u = Vt.b, s = Vt._, g = Vt.c, p = Vt.d, c = Vt.f, d = Vt.g, b = Vt.h, Vt.i, f = Vt.D, m = Vt.B, S = Vt.j, h = Vt.O, v = Vt.S, T = Vt.A, y = Vt.k, I = Vt.F, C = Vt.m, P = Vt.n, A = Vt.T, R = Vt.o, D = Vt.p, B = Vt.M, F = Vt.q, _ = Vt.r, N = Vt.s, E = Vt.t, M = Vt.u, w = Vt.v, O = Vt.V, L = Vt.x, x = Vt.y, V = Vt.z, j = Vt.E, z = Vt.G, U = Vt.H, G = Vt.I, H = Vt.J, k = Vt.L, Q = Vt.K, W = Vt.N, J = Vt.Q, X = Vt.U, Y = Vt.W, q = Vt.X, K = Vt.Y, Z = Vt.Z, $ = Vt.$, ee = Vt.a0, te = Vt.a1, re = Vt.a2, ae = Vt.a3, ne = Vt.a4, oe = Vt.a5, ie = Vt.a6, le = Vt.a7, ue = Vt.a8, se = Vt.a9, ge = Vt.aa, pe = Vt.ab, ce = Vt.ac, de = Vt.ad, be = Vt.ae, fe = Vt.af, me = Vt.ag, Se = Vt.ah, he = Vt.ai, ve = Vt.aj, Te = Vt.ak, ye = Vt.al, Ie = Vt.am, Ce = Vt.an, Pe = Vt.ao, Ae = Vt.ap, Re = Vt.aq, De = Vt.ar, Be = Vt.as, Fe = Vt.at, _e = Vt.au, Ne = Vt.av, Ee = Vt.aw, Me = Vt.ax, we = Vt.ay, Oe = Vt.az, Le = Vt.aA, xe = Vt.aB, Ve = Vt.aC, je = Vt.aD, ze = Vt.aE, Ue = Vt.aF, Ge = Vt.aG, He = Vt.aH, ke = Vt.aI, Qe = Vt.aJ, We = Vt.aK, Je = Vt.aL, Xe = Vt.aM, Ye = Vt.aN, qe = Vt.aO, Ke = Vt.aP, Ze = Vt.aQ, $e = Vt.aR, et = Vt.aS, tt = Vt.aT, rt = Vt.aU, at = Vt.aV, nt = Vt.aW, ot = Vt.aX, it = Vt.aY, lt = Vt.aZ, ut = Vt.a_, st = Vt.a$, gt = Vt.b0, pt = Vt.b1, ct = Vt.b2, dt = Vt.b3, bt = Vt.b4, ft = Vt.b5, mt = Vt.b6, St = Vt.b7, ht = Vt.b8, vt = Vt.b9, Tt = Vt.ba, yt = Vt.bb, It = Vt.bc, Ct = Vt.bd, Pt = Vt.be, At = Vt.bf, Rt = Vt.bg, Dt = Vt.bh, Bt = Vt.bi, Ft = Vt.bj, _t = Vt.bk, Nt = Vt.bl, Et = Vt.bm, Mt = Vt.bn, wt = Vt.bo, Ot = Vt.bp, Lt = Vt.bq, xt = Vt.br;
      var jt = {};
      jt.BitMask = Vt.bu, jt.CCBoolean = Vt.bG, jt.CCClass = Vt.bB, jt.CCFloat = Vt.bF, jt.CCInteger = Vt.bE, jt.CCObject = Vt.bC, jt.CCString = Vt.bH, jt.CachedArray = Vt.C, jt.DebugMode = Vt.bP, jt.Enum = Vt.bv, jt.EventTarget = Vt.bJ, jt.Eventify = Vt.bK, jt.Pool = Vt.P, jt.RecyclePool = Vt.R, jt.VERSION = Vt.bs, jt.ValueType = Vt.bx, jt.assert = Vt.b, jt.assertID = Vt.g, jt.bits = Vt.bt, jt.ccenum = Vt.bw, jt.cclegacy = Vt.l, jt.debug = Vt.bL, jt.editorExtrasTag = Vt.bI, jt.error = Vt.e, jt.errorID = Vt.f, jt.getError = Vt.bO, jt.isDisplayStats = Vt.bM, jt.isValid = Vt.bD, jt.js = Vt.by, jt.log = Vt.a, jt.logID = Vt.c, jt.macro = Vt.bQ, jt.misc = Vt.bz, jt.murmurhash2_32_gc = Vt.bA, jt.setDisplayStats = Vt.bN, jt.warn = Vt.w, jt.warnID = Vt.d, e(jt);
    }, function (t) {
      Vt = t.j, jt = t.e, zt = t.m, Ut = t.b, Gt = t.d, Ht = t.c, kt = t.a, Qt = t._, Wt = t.s, Jt = t.g, Xt = t.A, Yt = t.E, qt = t.S, Kt = t.f, Zt = t.h, $t = t.P, er = t.i, tr = t.F, rr = t.k, ar = t.l, nr = t.n, or = t.o, ir = t.p, lr = t.q, ur = t.r, sr = t.t, gr = t.u, pr = t.v, cr = t.w, dr = t.B, br = t.x, fr = t.y, mr = t.z, Sr = t.M, hr = t.C, vr = t.D, Tr = t.N, yr = t.G, Ir = t.H, Cr = t.I, Pr = t.J, Ar = t.K, Rr = t.L;
      var r = {};
      r.Acceleration = t.bC, r.AffineTransform = t.a0, r.AmbientInfo = t.bb, r.Asset = t.aL, r.BaseNode = t.b5, r.BufferAsset = t.aM, r.Color = t.a5, r.CompactValueTypeArray = t.aI, r.Component = t.bm, r.DEFAULT_OCTREE_DEPTH = t.bh, r.DEFAULT_WORLD_MAX_POS = t.bg, r.DEFAULT_WORLD_MIN_POS = t.bf, r.Details = t.aF, r.EPSILON = t.a7, r.EffectAsset = t.aV, r.Event = t.bx, r.EventAcceleration = t.by, r.EventKeyboard = t.bz, r.EventMouse = t.bA, r.EventTouch = t.bB, r.ExtrapolationMode = t.br, r.FogInfo = t.bd, r.ImageAsset = t.aS, r.Input = t.bG, r.InstancedBuffer = t.b2, r.JavaScript = t.aZ, r.JsonAsset = t.aR, r.KeyCode = t.bD, r.Layers = t.b8, r.MATH_FLOAT_ARRAY = t.as, r.Mat3 = t.Y, r.Mat4 = t.Z, r.Material = t.aW, r.MathBase = t.at, r.MissingScript = t.bl, r.Node = t.b6, r.NodeActivator = t.ba, r.ObjectCurve = t.bv, r.OctreeInfo = t.bi, r.PipelineStateManager = t.b3, r.Prefab = t.aN, r.PrefabLink = t.av, r.PrivateNode = t.bk, r.Quat = t.W, r.QuatCurve = t.bt, r.QuatInterpolationMode = t.bu, r.RealCurve = t.bp, r.RealInterpolationMode = t.bq, r.Rect = t.a3, r.RenderTexture = t.aX, r.RenderingSubMesh = t.aO, r.Scene = t.b7, r.SceneAsset = t.aP, r.SceneGlobals = t.bj, r.Script = t.aY, r.ShadowsInfo = t.be, r.Size = t.a1, r.SkyboxInfo = t.bc, r.SystemEvent = t.bI, r.SystemEventType = t.bw, r.TangentWeightMode = t.bs, r.TextAsset = t.aQ, r.Texture2D = t.aT, r.TextureCube = t.aU, r.Touch = t.bE, r.TypeScript = t.a_, r.Vec2 = t.V, r.Vec3 = t.Q, r.Vec4 = t.T, r.WorldNode3DToLocalNodeUI = t.aA, r.WorldNode3DToWorldNodeUI = t.aB, r._decorator = t.aD, r.absMax = t.aq, r.absMaxComponent = t.ap, r.approx = t.a9, r.builtinResMgr = t.bo, r.clamp = t.aa, r.clamp01 = t.ab, r.color = t.a6, r.convertUtils = t.aC, r.deserialize = t.aE, r.deserializeTag = t.aJ, r.effects = t.bn, r.enumerableProps = t.ar, r.equals = t.a8, r.find = t.b9, r.getPhaseID = t.b4, r.getSerializationMetadata = t.aG, r.input = t.bF, r.instantiate = t.aH, r.inverseLerp = t.ao, r.lerp = t.ac, r.markAsWarning = t.az, r.mat4 = t.$, r.nextPow2 = t.al, r.path = t.au, r.pingPong = t.an, r.pipeline = t.b1, r.pseudoRandom = t.ai, r.pseudoRandomRange = t.aj, r.pseudoRandomRangeInt = t.ak, r.quat = t.X, r.random = t.af, r.randomRange = t.ag, r.randomRangeInt = t.ah, r.rect = t.a4, r.removeProperty = t.ay, r.repeat = t.am, r.replaceProperty = t.ax, r.screen = t.a$, r.serializeTag = t.aK, r.setDefaultLogTimes = t.aw, r.size = t.a2, r.sys = t.b0, r.systemEvent = t.bH, r.toDegree = t.ae, r.toRadian = t.ad, r.v2 = t.O, r.v3 = t.R, r.v4 = t.U, e(r);
    }, function (t) {
      var r = {};
      r.AssetLibrary = t.b, r.AssetManager = t.A, r.CCLoader = t.C, r.assetManager = t.a, r.geometry = t.g, r.loader = t.l, r.math = t.m, r.resources = t.r, r.url = t.u, e(r);
    }, function (t) {
      Dr = t.C, Br = t.a, Fr = t.b, _r = t.c, Nr = t.d, Er = t.S, Mr = t.e, wr = t.M, Or = t.f, Lr = t.g, xr = t.O, Vr = t.h, jr = t.L, zr = t.n, Ur = t.i, Gr = t.D, Hr = t.j, kr = t.k, Qr = t.R, Wr = t.l, Jr = t.P, Xr = t.m, Yr = t.T, qr = t.o, Kr = t.V, e("RenderableComponent", t.p);
    }, function (t) {
      var r = {};
      r.BloomStage = t.B, r.DeferredPipeline = t.D, r.ForwardFlow = t.d, r.ForwardPipeline = t.F, r.ForwardStage = t.e, r.Game = t.G, r.GbufferStage = t.f, r.LightingStage = t.L, r.MainFlow = t.M, r.PipelineEventProcessor = t.i, r.PipelineEventType = t.j, r.PostProcessStage = t.P, r.RenderFlow = t.b, r.RenderPipeline = t.a, r.RenderStage = t.c, r.ResolutionPolicy = t.R, r.ShadowFlow = t.S, r.ShadowStage = t.h, r.View = t.V, r.game = t.g, r.view = t.v, e(r);
    }, function (t) {
      var r = {};
      r.Camera = t.C, r.CameraComponent = t.C, r.Director = t.D, r.EventHandler = t.E, r.Scheduler = t.S, r.System = t.a, r.createDefaultPipeline = t.c, r.director = t.d, e(r);
    }],
    execute: function execute() {
      e("memop", Object.freeze({
        __proto__: null,
        Pool: t,
        RecyclePool: r,
        CachedArray: a
      })), n.log = o, n.warn = i, n.error = l, n.assert = u, n._throw = s, n.logID = g, n.warnID = p, n.errorID = c, n.assertID = d, n.debug = b, n.path = {
        join: Vt,
        extname: jt,
        mainFileName: zt,
        basename: Ut,
        dirname: Gt,
        changeExtname: Ht,
        changeBasename: kt,
        _normalize: Qt,
        stripSep: Wt,

        get sep() {
          return Jt();
        }

      };
      var Zr = 0,
          $r = {};
      e("gfx", Object.freeze({
        __proto__: null,
        DescriptorSet: f,
        Buffer: m,
        CommandBuffer: S,

        get ObjectType() {
          return h;
        },

        get Status() {
          return v;
        },

        get API() {
          return T;
        },

        get SurfaceTransform() {
          return y;
        },

        get Feature() {
          return I;
        },

        get Format() {
          return C;
        },

        get FormatType() {
          return P;
        },

        get Type() {
          return A;
        },

        get BufferUsageBit() {
          return R;
        },

        get BufferFlagBit() {
          return D;
        },

        get MemoryAccessBit() {
          return B;
        },

        get MemoryUsageBit() {
          return F;
        },

        get TextureType() {
          return _;
        },

        get TextureUsageBit() {
          return N;
        },

        get TextureFlagBit() {
          return E;
        },

        get FormatFeatureBit() {
          return M;
        },

        get SampleCount() {
          return w;
        },

        get VsyncMode() {
          return O;
        },

        get Filter() {
          return L;
        },

        get Address() {
          return x;
        },

        get ComparisonFunc() {
          return V;
        },

        get StencilOp() {
          return j;
        },

        get BlendFactor() {
          return z;
        },

        get BlendOp() {
          return U;
        },

        get ColorMask() {
          return G;
        },

        get ShaderStageFlagBit() {
          return H;
        },

        get LoadOp() {
          return k;
        },

        get StoreOp() {
          return Q;
        },

        get AccessFlagBit() {
          return W;
        },

        get ResolveMode() {
          return J;
        },

        get PipelineBindPoint() {
          return X;
        },

        get PrimitiveMode() {
          return Y;
        },

        get PolygonMode() {
          return q;
        },

        get ShadeModel() {
          return K;
        },

        get CullMode() {
          return Z;
        },

        get DynamicStateFlagBit() {
          return $;
        },

        get StencilFace() {
          return ee;
        },

        get DescriptorType() {
          return te;
        },

        get QueueType() {
          return re;
        },

        get QueryType() {
          return ae;
        },

        get CommandBufferType() {
          return ne;
        },

        get ClearFlagBit() {
          return oe;
        },

        Size: ie,
        DeviceCaps: le,
        Offset: ue,
        Rect: se,
        Extent: ge,
        TextureSubresLayers: pe,
        TextureSubresRange: ce,
        TextureCopy: de,
        TextureBlit: be,
        BufferTextureCopy: fe,
        Viewport: me,
        Color: Se,
        BindingMappingInfo: he,
        SwapchainInfo: ve,
        DeviceInfo: Te,
        BufferInfo: ye,
        BufferViewInfo: Ie,
        DrawInfo: Ce,
        DispatchInfo: Pe,
        IndirectBuffer: Ae,
        TextureInfo: Re,
        TextureViewInfo: De,
        SamplerInfo: Be,
        Uniform: Fe,
        UniformBlock: _e,
        UniformSamplerTexture: Ne,
        UniformSampler: Ee,
        UniformTexture: Me,
        UniformStorageImage: we,
        UniformStorageBuffer: Oe,
        UniformInputAttachment: Le,
        ShaderStage: xe,
        Attribute: Ve,
        ShaderInfo: je,
        InputAssemblerInfo: ze,
        ColorAttachment: Ue,
        DepthStencilAttachment: Ge,
        SubpassInfo: He,
        SubpassDependency: ke,
        RenderPassInfo: Qe,
        GeneralBarrierInfo: We,
        TextureBarrierInfo: Je,
        FramebufferInfo: Xe,
        DescriptorSetLayoutBinding: Ye,
        DescriptorSetLayoutInfo: qe,
        DescriptorSetInfo: Ke,
        PipelineLayoutInfo: Ze,
        InputState: $e,
        CommandBufferInfo: et,
        QueueInfo: tt,
        QueryPoolInfo: rt,
        FormatInfo: at,
        MemoryStatus: nt,
        DynamicStencilStates: ot,
        DynamicStates: it,
        GFXObject: lt,

        get AttributeName() {
          return ut;
        },

        FormatInfos: st,
        DESCRIPTOR_BUFFER_TYPE: gt,
        DESCRIPTOR_SAMPLER_TYPE: pt,
        DESCRIPTOR_DYNAMIC_TYPE: ct,
        DRAW_INFO_SIZE: dt,
        IsPowerOf2: bt,
        FormatSize: ft,
        FormatSurfaceSize: mt,
        GetTypeSize: St,
        getTypedArrayConstructor: ht,
        Device: vt,
        Swapchain: Tt,
        Framebuffer: yt,
        InputAssembler: It,
        DescriptorSetLayout: Ct,
        PipelineLayout: Pt,
        RasterizerState: At,
        DepthStencilState: Rt,
        BlendTarget: Dt,
        BlendState: Bt,
        PipelineStateInfo: Ft,
        PipelineState: _t,
        Queue: Nt,
        RenderPass: Et,
        Sampler: Mt,
        Shader: wt,
        Texture: Ot,
        GeneralBarrier: Lt,
        TextureBarrier: xt
      }));

      var ea = Object.freeze({
        __proto__: null,

        get CameraFOVAxis() {
          return Dr;
        },

        get CameraProjection() {
          return Br;
        },

        get CameraAperture() {
          return Fr;
        },

        get CameraISO() {
          return _r;
        },

        get CameraShutter() {
          return Nr;
        },

        SKYBOX_FLAG: Er,
        Camera: Mr,

        get ModelType() {
          return wr;
        },

        Model: Or,
        SubModel: Lr,
        Ambient: Xt,
        EnvironmentLightingType: Yt,
        Skybox: qt,
        ShadowSize: Kt,
        ShadowType: Zt,
        PCFType: $t,
        Shadows: er,
        FogType: tr,
        Fog: rr,
        Octree: xr,
        ColorTemperatureToRGB: Vr,

        get LightType() {
          return jr;
        },

        nt2lm: zr,
        Light: Ur,
        DirectionalLight: Gr,
        SphereLight: Hr,
        SpotLight: kr,
        RenderScene: Qr
      }),
          ta = function ta(e) {
        if (void 0 === $r[e]) {
          var t = 1 << Zr;
          $r[e] = t, Zr += 1;
        }
      },
          ra = Object.freeze({
        __proto__: null,
        addStage: ta,
        scene: ea,
        createIA: function createIA(e, t) {
          if (!t.positions) return console.error("The data must have positions field"), null;

          for (var r = [], a = t.positions.length / 3, n = 0; n < a; ++n) {
            r.push(t.positions[3 * n], t.positions[3 * n + 1], t.positions[3 * n + 2]), t.normals && r.push(t.normals[3 * n], t.normals[3 * n + 1], t.normals[3 * n + 2]), t.uvs && r.push(t.uvs[2 * n], t.uvs[2 * n + 1]), t.colors && r.push(t.colors[3 * n], t.colors[3 * n + 1], t.colors[3 * n + 2]);
          }

          var o = [];
          o.push(new Ve(ut.ATTR_POSITION, C.RGB32F)), t.normals && o.push(new Ve(ut.ATTR_NORMAL, C.RGB32F)), t.uvs && o.push(new Ve(ut.ATTR_TEX_COORD, C.RG32F)), t.colors && o.push(new Ve(ut.ATTR_COLOR, C.RGB32F));
          var i = e.createBuffer(new ye(R.VERTEX | R.TRANSFER_DST, F.DEVICE, 4 * r.length, 4 * r.length / a));
          i.update(new Float32Array(r));
          var l = null;
          return t.indices && (l = e.createBuffer(new ye(R.INDEX | R.TRANSFER_DST, F.DEVICE, 2 * t.indices.length, 2))).update(new Uint16Array(t.indices)), e.createInputAssembler(new ze(o, [i], l));
        },

        get RenderQueue() {
          return Wr;
        },

        get PassStage() {
          return Jr;
        },

        genHandle: ar,
        getTypeFromHandle: nr,
        getBindingFromHandle: or,
        getCountFromHandle: ir,
        getOffsetFromHandle: lr,
        customizeType: ur,
        type2reader: sr,
        type2writer: gr,
        getDefaultFromType: pr,
        overrideMacros: cr,

        get BatchingSchemes() {
          return dr;
        },

        Pass: br,
        getDeviceShaderVersion: fr,
        programLib: mr,
        nearestPOT: Xr,
        TextureBufferPool: Yr,
        MaterialInstance: Sr,
        PassInstance: hr,

        get PoolType() {
          return vr;
        },

        NULL_HANDLE: Tr,

        get NodeView() {
          return yr;
        },

        NodePool: Ir,

        get PassView() {
          return Cr;
        },

        PassPool: Pr,

        get AABBView() {
          return Ar;
        },

        AABBPool: Rr,
        RenderScene: Qr,
        NativeNode: null,
        NativeScene: null,
        NativeAABB: null,
        NativeModel: null,
        NativeSkinningModel: null,
        NativeBakedAnimInfo: null,
        NativeBakedJointInfo: null,
        NativeBakedSkinningModel: null,
        NativeLight: null,
        NativeDirectionalLight: null,
        NativeSphereLight: null,
        NativeSpotLight: null,
        NaitveSkybox: null,
        NativeFog: null,
        NativeRenderWindow: null,
        NativeCamera: null,
        NativePass: null,
        NativeSubModel: null,
        NativeDrawBatch2D: null,
        NativeRenderScene: null,
        NativeOctree: null,
        NativeAmbient: null,
        NativeShadow: null,
        NativeRoot: null,
        NativeJointTransform: null,
        NativeJointInfo: null,
        NativePipelineSharedSceneData: null,
        NativeGeometryRenderer: null,
        CameraVisFlags: qr,
        VisibilityFlags: Kr
      });

      e("renderer", ra);
      var aa = e("NodePool", function () {
        function e(e) {
          this.poolHandlerComp = void 0, this._pool = void 0, this.poolHandlerComp = e, this._pool = [];
        }

        var t = e.prototype;
        return t.size = function () {
          return this._pool.length;
        }, t.clear = function () {
          for (var e = this._pool.length, t = 0; t < e; ++t) {
            this._pool[t].destroy();
          }

          this._pool.length = 0;
        }, t.put = function (e) {
          if (e && -1 === this._pool.indexOf(e)) {
            e.removeFromParent();
            var t = this.poolHandlerComp ? e.getComponent(this.poolHandlerComp) : null;
            t && t.unuse && t.unuse(), this._pool.push(e);
          }
        }, t.get = function () {
          for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) {
            t[r] = arguments[r];
          }

          var a = this._pool.length - 1;
          if (a < 0) return null;
          var n = this._pool[a];
          this._pool.length = a;
          var o = this.poolHandlerComp ? n.getComponent(this.poolHandlerComp) : null;
          return o && o.reuse && o.reuse(arguments), n;
        }, e;
      }());
      n.NodePool = aa, n.renderer = ra;
    }
  };
}); 
 			}); 
		define("__plugin__/wx0446ba2621dda60a/capsule-3dc9b423.js", function(require, module, exports){ 			
"use strict";

System.register(["./texture-barrier-60b5983b.js", "./json-asset-933a1d4c.js"], function (n) {
  "use strict";

  var s;
  return {
    setters: [function () {}, function (n) {
      s = n.Q;
    }],
    execute: function execute() {
      function e(n) {
        return void 0 === (n = n || {}).includeNormal && (n.includeNormal = !0), void 0 === n.includeUV && (n.includeUV = !0), n;
      }

      n({
        a: e,
        b: function b(n) {
          var e = (n = n || {}).widthSegments || 1,
              w = n.heightSegments || 1,
              l = n.lengthSegments || 1,
              g = (n.width || 1) / 2,
              m = (n.height || 1) / 2,
              M = (n.length || 1) / 2,
              P = [s.set(i, -g, -m, M), s.set(o, g, -m, M), s.set(u, g, m, M), s.set(v, -g, m, M), s.set(p, g, -m, -M), s.set(d, -g, -m, -M), s.set(c, -g, m, -M), s.set(f, g, m, -M)],
              S = [[2, 3, 1], [4, 5, 7], [7, 6, 2], [1, 0, 4], [1, 4, 2], [5, 0, 6]],
              x = [[0, 0, 1], [0, 0, -1], [0, 1, 0], [0, -1, 0], [1, 0, 0], [-1, 0, 0]],
              b = [[-1, 0, 0, 1], [-1, 0, 0, 1], [-1, 0, 0, 1], [-1, 0, 0, 1], [0, 0, -1, 1], [0, 0, 1, 1]],
              y = [],
              I = [],
              z = [],
              A = [],
              R = [],
              U = new s(-g, -m, -M),
              V = new s(g, m, M),
              j = Math.sqrt(g * g + m * m + M * M);

          function q(n, e, i) {
            var o,
                u,
                v,
                p,
                d = y.length / 3,
                c = S[n],
                f = x[n],
                w = b[n];

            for (p = 0; p <= i; p++) {
              for (v = 0; v <= e; v++) {
                if (o = v / e, u = p / i, s.lerp(t, P[c[0]], P[c[1]], o), s.lerp(r, P[c[0]], P[c[2]], u), s.subtract(a, r, P[c[0]]), s.add(h, t, a), y.push(h.x, h.y, h.z), I.push(f[0], f[1], f[2]), z.push(o, u), A.push(w[0], w[1], w[2], w[3]), v < e && p < i) {
                  var l = e + 1,
                      g = v + p * l,
                      m = v + (p + 1) * l,
                      M = v + 1 + (p + 1) * l,
                      U = v + 1 + p * l;
                  R.push(d + g, d + U, d + m), R.push(d + m, d + U, d + M);
                }
              }
            }
          }

          return q(0, e, w), q(4, l, w), q(1, e, w), q(5, l, w), q(3, e, l), q(2, e, l), {
            positions: y,
            normals: I,
            uvs: z,
            tangents: A,
            indices: R,
            minPos: U,
            maxPos: V,
            boundingRadius: j
          };
        },
        c: function c(n, e, t, r) {
          void 0 === n && (n = .5), void 0 === e && (e = .5), void 0 === t && (t = 2), void 0 === r && (r = {});
          var a = .5 * t,
              h = r.radialSegments || 32,
              i = r.heightSegments || 1,
              o = void 0 === r.capped || r.capped,
              u = r.arc || 2 * Math.PI,
              v = 0;
          o || (n > 0 && v++, e > 0 && v++);
          var p = (h + 1) * (i + 1);
          o && (p += (h + 1) * v + h * v);
          var d = h * i * 6;
          o && (d += h * v * 3);
          var c = new Array(d),
              f = new Array(3 * p),
              g = new Array(3 * p),
              m = new Array(2 * p),
              M = Math.max(n, e),
              P = new s(-M, -a, -M),
              S = new s(M, a, M),
              x = Math.sqrt(M * M + a * a),
              b = 0,
              y = 0;
          return function () {
            for (var r = [], o = n - e, v = o * o / t * Math.sign(o), p = 0; p <= i; p++) {
              for (var d = [], M = p / i, P = M * o + e, S = 0; S <= h; ++S) {
                var x = S / h,
                    I = x * u,
                    z = Math.sin(I),
                    A = Math.cos(I);
                f[3 * b] = P * z, f[3 * b + 1] = M * t - a, f[3 * b + 2] = P * A, s.normalize(w, s.set(l, z, -v, A)), g[3 * b] = w.x, g[3 * b + 1] = w.y, g[3 * b + 2] = w.z, m[2 * b] = 2 * (1 - x) % 1, m[2 * b + 1] = M, d.push(b), ++b;
              }

              r.push(d);
            }

            for (var R = 0; R < i; ++R) {
              for (var U = 0; U < h; ++U) {
                var V = r[R][U],
                    j = r[R + 1][U],
                    q = r[R + 1][U + 1],
                    N = r[R][U + 1];
                c[y] = V, ++y, c[y] = N, ++y, c[y] = j, ++y, c[y] = N, ++y, c[y] = q, ++y, c[y] = j, ++y;
              }
            }
          }(), o && (e > 0 && I(!1), n > 0 && I(!0)), {
            positions: f,
            normals: g,
            uvs: m,
            indices: c,
            minPos: P,
            maxPos: S,
            boundingRadius: x
          };

          function I(s) {
            for (var t = s ? n : e, r = s ? 1 : -1, i = b, o = 1; o <= h; ++o) {
              f[3 * b] = 0, f[3 * b + 1] = a * r, f[3 * b + 2] = 0, g[3 * b] = 0, g[3 * b + 1] = r, g[3 * b + 2] = 0, m[2 * b] = .5, m[2 * b + 1] = .5, ++b;
            }

            for (var v = b, p = 0; p <= h; ++p) {
              var d = p / h * u,
                  w = Math.cos(d),
                  l = Math.sin(d);
              f[3 * b] = t * l, f[3 * b + 1] = a * r, f[3 * b + 2] = t * w, g[3 * b] = 0, g[3 * b + 1] = r, g[3 * b + 2] = 0, m[2 * b] = .5 - .5 * l * r, m[2 * b + 1] = .5 + .5 * w, ++b;
            }

            for (var M = 0; M < h; ++M) {
              var P = i + M,
                  S = v + M;
              s ? (c[y] = S + 1, ++y, c[y] = P, ++y, c[y] = S, ++y) : (c[y] = P, ++y, c[y] = S + 1, ++y, c[y] = S, ++y);
            }
          }
        },
        d: function d(n, e, t, r) {
          void 0 === n && (n = .5), void 0 === e && (e = .5), void 0 === t && (t = 2), void 0 === r && (r = {});
          var a = t - n - e,
              h = r.sides || 32,
              i = r.heightSegments || 32,
              o = e / t,
              u = a / t,
              v = n / t,
              p = Math.floor(i * o),
              d = Math.floor(i * v),
              c = Math.floor(i * u),
              f = a + e - t / 2,
              w = e - t / 2,
              l = e - t / 2,
              g = r.arc || 2 * Math.PI,
              m = [],
              M = [],
              P = [],
              S = [],
              x = Math.max(n, e),
              b = new s(-x, -t / 2, -x),
              z = new s(x, t / 2, x),
              A = t / 2,
              R = 0,
              U = [];
          return function () {
            for (var n = 0; n <= p; ++n) {
              for (var s = n * Math.PI / p / 2, t = Math.sin(s), r = -Math.cos(s), a = 0; a <= h; ++a) {
                var o = 2 * a * Math.PI / h - Math.PI / 2,
                    u = Math.sin(o) * t,
                    v = r,
                    d = Math.cos(o) * t,
                    c = a / h,
                    f = n / i;

                if (m.push(u * e, v * e + l, d * e), M.push(u, v, d), P.push(c, f), n < p && a < h) {
                  var w = h + 1,
                      g = w * n + a,
                      x = w * (n + 1) + a,
                      b = w * (n + 1) + a + 1,
                      y = w * n + a + 1;
                  S.push(g, y, x), S.push(y, b, x);
                }

                ++R;
              }
            }
          }(), function () {
            for (var t = (n - e) / a, r = 0; r <= c; r++) {
              for (var i = [], v = r / c, p = v * (n - e) + e, d = 0; d <= h; ++d) {
                var f = d / h,
                    l = v * u + o,
                    x = f * g - g / 4,
                    b = Math.sin(x),
                    z = Math.cos(x);
                m.push(p * b), m.push(v * a + w), m.push(p * z), s.normalize(y, s.set(I, b, -t, z)), M.push(y.x), M.push(y.y), M.push(y.z), P.push(f, l), i.push(R), ++R;
              }

              U.push(i);
            }

            for (var A = 0; A < c; ++A) {
              for (var V = 0; V < h; ++V) {
                var j = U[A][V],
                    q = U[A + 1][V],
                    N = U[A + 1][V + 1],
                    Q = U[A][V + 1];
                S.push(j), S.push(Q), S.push(q), S.push(Q), S.push(N), S.push(q);
              }
            }
          }(), function () {
            for (var s = 0; s <= d; ++s) {
              for (var e = s * Math.PI / d / 2 + Math.PI / 2, t = Math.sin(e), r = -Math.cos(e), a = 0; a <= h; ++a) {
                var o = 2 * a * Math.PI / h - Math.PI / 2,
                    u = Math.sin(o) * t,
                    p = r,
                    w = Math.cos(o) * t,
                    l = a / h,
                    g = s / i + (1 - v);

                if (m.push(u * n, p * n + f, w * n), M.push(u, p, w), P.push(l, g), s < d && a < h) {
                  var x = h + 1,
                      b = x * s + a + U[c][h] + 1,
                      y = x * (s + 1) + a + U[c][h] + 1,
                      I = x * (s + 1) + a + 1 + U[c][h] + 1,
                      z = x * s + a + 1 + U[c][h] + 1;
                  S.push(b, z, y), S.push(z, I, y);
                }
              }
            }
          }(), {
            positions: m,
            normals: M,
            uvs: P,
            indices: S,
            minPos: b,
            maxPos: z,
            boundingRadius: A
          };
        },
        p: function p(n) {
          var t = function (n) {
            return (n = e(n)).width = n.width || 10, n.length = n.length || 10, n.widthSegments = n.widthSegments || 10, n.lengthSegments = n.lengthSegments || 10, n;
          }(n),
              r = t.width,
              a = t.length,
              h = t.widthSegments,
              i = t.lengthSegments,
              o = .5 * r,
              u = .5 * a,
              v = [],
              p = [],
              d = [],
              c = new s(-o, 0, -u),
              f = new s(o, 0, u),
              w = Math.sqrt(r * r + a * a);

          s.set(S, -o, 0, u), s.set(x, o, 0, u), s.set(b, -o, 0, -u);

          for (var l = 0; l <= i; l++) {
            for (var y = 0; y <= h; y++) {
              var I = y / h,
                  z = l / i;

              if (s.lerp(g, S, x, I), s.lerp(m, S, b, z), s.subtract(M, m, S), s.add(P, g, M), v.push(P.x, P.y, P.z), t.includeUV && p.push(I, z), y < h && l < i) {
                var A = h + 1,
                    R = y + l * A,
                    U = y + (l + 1) * A,
                    V = y + 1 + (l + 1) * A,
                    j = y + 1 + l * A;
                d.push(R, j, U), d.push(j, V, U);
              }
            }
          }

          var q = {
            positions: v,
            indices: d,
            minPos: c,
            maxPos: f,
            boundingRadius: w
          };

          if (t.includeNormal) {
            var N = (i + 1) * (h + 1),
                Q = new Array(3 * N);
            q.normals = Q;

            for (var k = 0; k < N; ++k) {
              Q[3 * k + 0] = 0, Q[3 * k + 1] = 1, Q[3 * k + 2] = 0;
            }
          }

          return t.includeUV && (q.uvs = p), q;
        }
      });
      var t = new s(),
          r = new s(),
          a = new s(),
          h = new s(),
          i = new s(),
          o = new s(),
          u = new s(),
          v = new s(),
          p = new s(),
          d = new s(),
          c = new s(),
          f = new s(),
          w = new s(0, 0, 0),
          l = new s(0, 0, 0),
          g = new s(0, 0, 0),
          m = new s(0, 0, 0),
          M = new s(0, 0, 0),
          P = new s(0, 0, 0),
          S = new s(0, 0, 0),
          x = new s(0, 0, 0),
          b = new s(0, 0, 0),
          y = new s(0, 0, 0),
          I = new s(0, 0, 0);
    }
  };
}); 
 			}); 
		define("__plugin__/wx0446ba2621dda60a/create-mesh-39923017.js", function(require, module, exports){ 			
"use strict";

System.register(["./texture-barrier-60b5983b.js", "./json-asset-933a1d4c.js", "./mesh-f5415e9d.js"], function (t) {
  "use strict";

  var e, a, _r, n, s, i, o, u, f, l, v;

  return {
    setters: [function (t) {
      e = t.a_, a = t.i, _r = t.a$, n = t.m, s = t.aC, i = t.W;
    }, function (t) {
      o = t.df, u = t.Q, f = t.dg;
    }, function (t) {
      l = t.M, v = t.B;
    }],
    execute: function execute() {
      var d;
      t({
        c: function c(t, s, o) {
          o = o || {};
          var d,
              c = [],
              T = 0,
              b = [],
              g = 0,
              R = t.positions.slice();

          if (R.length > 0) {
            if (d = null, t.attributes) for (var A, w = a(t.attributes); !(A = w()).done;) {
              var O = A.value;

              if (O.name === e.ATTR_POSITION) {
                d = O;
                break;
              }
            }
            d || (d = h[0]), c.push(d);
            var x = _r[d.format];
            g = Math.max(g, Math.floor(R.length / x.count)), b.push({
              offset: T,
              data: R,
              attribute: d
            }), T += x.size;
          }

          if (t.normals && t.normals.length > 0) {
            if (d = null, t.attributes) for (var p, _ = a(t.attributes); !(p = _()).done;) {
              var M = p.value;

              if (M.name === e.ATTR_NORMAL) {
                d = M;
                break;
              }
            }
            d || (d = h[1]);
            var B = _r[d.format];
            c.push(d), g = Math.max(g, Math.floor(t.normals.length / B.count)), b.push({
              offset: T,
              data: t.normals,
              attribute: d
            }), T += B.size;
          }

          if (t.uvs && t.uvs.length > 0) {
            if (d = null, t.attributes) for (var L, N = a(t.attributes); !(L = N()).done;) {
              var I = L.value;

              if (I.name === e.ATTR_TEX_COORD) {
                d = I;
                break;
              }
            }
            d || (d = h[2]);
            var y = _r[d.format];
            c.push(d), g = Math.max(g, Math.floor(t.uvs.length / y.count)), b.push({
              offset: T,
              data: t.uvs,
              attribute: d
            }), T += y.size;
          }

          if (t.tangents && t.tangents.length > 0) {
            if (d = null, t.attributes) for (var z, C = a(t.attributes); !(z = C()).done;) {
              var G = z.value;

              if (G.name === e.ATTR_TANGENT) {
                d = G;
                break;
              }
            }
            d || (d = h[3]);
            var P = _r[d.format];
            c.push(d), g = Math.max(g, Math.floor(t.tangents.length / P.count)), b.push({
              offset: T,
              data: t.tangents,
              attribute: d
            }), T += P.size;
          }

          if (t.colors && t.colors.length > 0) {
            if (d = null, t.attributes) for (var D, E = a(t.attributes); !(D = E()).done;) {
              var k = D.value;

              if (k.name === e.ATTR_COLOR) {
                d = k;
                break;
              }
            }
            d || (d = h[4]);
            var F = _r[d.format];
            c.push(d), g = Math.max(g, Math.floor(t.colors.length / F.count)), b.push({
              offset: T,
              data: t.colors,
              attribute: d
            }), T += F.size;
          }

          if (t.customAttributes) for (var S, V = a(t.customAttributes); !(S = V()).done;) {
            var j = S.value,
                U = _r[j.attr.format];
            c.push(j.attr), g = Math.max(g, Math.floor(j.values.length / U.count)), b.push({
              offset: T,
              data: j.values,
              attribute: j.attr
            }), T += U.size;
          }

          for (var X = new v(), Q = new ArrayBuffer(g * T), W = new DataView(Q), $ = 0, q = b; $ < q.length; $++) {
            var H = q[$];
            f(W, H.data, H.attribute.format, H.offset, T);
          }

          X.setNextAlignment(0);
          var J = {
            attributes: c,
            view: {
              offset: X.getLength(),
              length: Q.byteLength,
              count: g,
              stride: T
            }
          };
          X.addBuffer(Q);
          var K = null,
              Y = 0;

          if (t.indices) {
            var Z = t.indices;
            Y = Z.length, K = new ArrayBuffer(2 * Y);
            var tt = new DataView(K);
            f(tt, Z, n.R16UI);
          }

          var et = {
            primitiveMode: t.primitiveMode || i.TRIANGLE_LIST,
            vertexBundelIndices: [0]
          };
          K && (X.setNextAlignment(2), et.indexView = {
            offset: X.getLength(),
            length: K.byteLength,
            count: Y,
            stride: 2
          }, X.addBuffer(K));
          var at = t.minPos;

          if (!at && o.calculateBounds) {
            at = u.set(new u(), 1 / 0, 1 / 0, 1 / 0);

            for (var rt = 0; rt < g; ++rt) {
              u.set(m, R[3 * rt + 0], R[3 * rt + 1], R[3 * rt + 2]), u.min(at, at, m);
            }
          }

          var nt = t.maxPos;

          if (!nt && o.calculateBounds) {
            nt = u.set(new u(), -1 / 0, -1 / 0, -1 / 0);

            for (var st = 0; st < g; ++st) {
              u.set(m, R[3 * st + 0], R[3 * st + 1], R[3 * st + 2]), u.max(nt, nt, m);
            }
          }

          var it = {
            vertexBundles: [J],
            primitives: [et]
          };
          return at && (it.minPosition = new u(at.x, at.y, at.z)), nt && (it.maxPosition = new u(nt.x, nt.y, nt.z)), s || (s = new l()), s.reset({
            struct: it,
            data: new Uint8Array(X.getCombined())
          }), s;
        },
        r: function r(t, e) {
          void 0 === e && (e = 0);

          for (var s, i = {
            positions: []
          }, u = new DataView(t.data.buffer, t.data.byteOffset, t.data.byteLength), f = t.struct, l = f.primitives[e], v = a(l.vertexBundelIndices); !(s = v()).done;) {
            for (var h, m = s.value, c = f.vertexBundles[m], T = c.view.offset, b = c.view, g = b.length, R = b.stride, A = a(c.attributes); !(h = A()).done;) {
              var w = h.value,
                  O = d[w.name];
              O && (i[O] = (i[O] || []).concat(o(u, w.format, T, g, R))), T += _r[w.format].size;
            }
          }

          var x = l.indexView;
          return i.indices = o(u, n["R" + 8 * x.stride + "UI"], x.offset, x.length), i;
        }
      }), function (t) {
        t[t.positions = e.ATTR_POSITION] = "positions", t[t.normals = e.ATTR_NORMAL] = "normals", t[t.uvs = e.ATTR_TEX_COORD] = "uvs", t[t.colors = e.ATTR_COLOR] = "colors";
      }(d || (d = {}));
      var h = [new s(e.ATTR_POSITION, n.RGB32F), new s(e.ATTR_NORMAL, n.RGB32F), new s(e.ATTR_TEX_COORD, n.RG32F), new s(e.ATTR_TANGENT, n.RGBA32F), new s(e.ATTR_COLOR, n.RGBA32F)],
          m = new u();
    }
  };
}); 
 			}); 
		define("__plugin__/wx0446ba2621dda60a/deprecated-26630860.js", function(require, module, exports){ 			
"use strict";

System.register(["./texture-barrier-60b5983b.js", "./json-asset-933a1d4c.js", "./renderable-component-7c6600ed.js"], function (e) {
  "use strict";

  var t, i, r, n, a, s, o, h, d, u, l, c, _, f, p, g, S, m, v, w, A, E, T, O, y, b, R, I, F, N, D, B, P, L, C, M, x, z, H, G, U, W, Q, V, q, k, X, Y, K, Z, J, j, $, ee, te, ie, re, ne, ae, se, oe, he, de, ue, le, ce, _e, fe, pe, ge, Se, me, ve, we, Ae, Ee, Te, Oe, ye, be, Re, Ie, Fe, Ne, De, Be, Pe, Le, Ce, Me, xe, ze, He, Ge, Ue, We, Qe, Ve, qe, ke, Xe, Ye, Ke, Ze, Je, je, $e, et, tt, it, rt, nt, at, st, ot, ht, dt, ut, lt, ct, _t, ft, pt, gt, St, mt;

  return {
    setters: [function (e) {
      t = e.P, i = e.as, r = e.x, n = e.y, a = e.aP, s = e.al, o = e.o, h = e.q, d = e.bU, u = e.aO, l = e.aC, c = e.a_, _ = e.m, f = e.d, p = e.an, g = e.aE, S = e.l, m = e.c0, v = e.c1, w = e.bT, A = e.bJ, E = e.aF, T = e.aG, O = e.K, y = e.a5, b = e.L, R = e.aK, I = e.N, F = e.aJ, N = e.aM, D = e.k, B = e.u, P = e.F, L = e.bR, C = e.bS, M = e.bQ, x = e.aq, z = e.r, H = e.s, G = e.a9, U = e.ag, W = e.b$, Q = e.bw, V = e.bH, q = e.R, k = e.C, X = e.am, Y = e.ah, K = e.f, Z = e.cq, J = e.a, j = e.bs, $ = e.cw, ee = e.bN, te = e.bP, ie = e.cC, re = e.bO, ne = e.cd, ae = e.b9, se = e.ak, oe = e.e, he = e.aj, de = e.w, ue = e.c8;
    }, function (e) {
      le = e.Q, ce = e.Z, _e = e.bJ, fe = e.bK, pe = e.bL, ge = e.V, Se = e.bM, me = e.bN, ve = e.h, we = e.bO, Ae = e.bP, Ee = e.b3, Te = e.bQ, Oe = e.a5, ye = e.T, be = e.ad, Re = e.bR, Ie = e.bS, Fe = e.bT, Ne = e.bo, De = e.bU, Be = e.bV, Pe = e.bW, Le = e.bX, Ce = e.bY, Me = e.bZ, xe = e.b_, ze = e.aL, He = e.aX, Ge = e.aW, Ue = e.b$, We = e.b4, Qe = e.c0, Ve = e.B, qe = e.al, ke = e.b8, Xe = e.c1, Ye = e.c2, Ke = e.c3, Ze = e.k, Je = e.A, je = e.S, $e = e.i, et = e.c4, tt = e.c5, it = e.c6, rt = e.c7, nt = e.bF, at = e.c8, st = e.a$, ot = e.b0, ht = e.c9, dt = e.a1, ut = e.ca, lt = e.a3, ct = e.ay, _t = e.az, ft = e.ax;
    }, function (e) {
      pt = e.S, gt = e.e, St = e.L, mt = e.O;
    }],
    execute: function execute() {
      e("j", void 0);
      var vt = new le(),
          wt = (new le(), new le(), new le()),
          At = new ce(),
          Et = new _e(),
          Tt = new _e(),
          Ot = !1,
          yt = fe.create(0, 0, 0, 1),
          bt = new fe(),
          Rt = new pe();
      Rt.accurate = !0;
      var It = new pe();
      It.accurate = !0;
      var Ft = new pe(),
          Nt = new ce(),
          Dt = new ce(),
          Bt = new ce(),
          Pt = new ce(),
          Lt = new ce(),
          Ct = new ce(),
          Mt = new ce(),
          xt = new le(),
          zt = new ge(),
          Ht = new le(),
          Gt = new le(),
          Ut = new le(0, 0, 0),
          Wt = (new _e(), new t(function () {
        return {
          model: null,
          depth: 0
        };
      }, 128)),
          Qt = new t(function () {
        return {
          model: null,
          depth: 0
        };
      }, 128),
          Vt = new t(function () {
        return {
          model: null,
          depth: 0
        };
      }, 128);

      function qt(e, t) {
        var i = 0;
        e.node && (le.subtract(vt, e.node.worldPosition, t.position), i = le.dot(vt, t.forward));
        var r = Wt.alloc();
        return r.model = e, r.depth = i, r;
      }

      function kt(e, t) {
        var i = 0;
        e.node && (le.subtract(vt, e.node.worldPosition, t.position), i = le.dot(vt, t.forward));
        var r = Qt.alloc();
        return r.model = e, r.depth = i, r;
      }

      function Xt(e, t) {
        var i = 0;
        e.node && (le.subtract(vt, e.node.worldPosition, t.position), i = le.dot(vt, t.forward));
        var r = Vt.alloc();
        return r.model = e, r.depth = i, r;
      }

      function Yt(e, t, i) {
        var r = t.direction,
            n = e.normal,
            a = e.distance + .001,
            s = 1 / le.dot(n, r),
            o = r.x * s,
            h = r.y * s,
            d = r.z * s,
            u = n.x,
            l = n.y,
            c = n.z,
            _ = e.matLight;
        _.m00 = 1 - u * o, _.m01 = -u * h, _.m02 = -u * d, _.m03 = 0, _.m04 = -l * o, _.m05 = 1 - l * h, _.m06 = -l * d, _.m07 = 0, _.m08 = -c * o, _.m09 = -c * h, _.m10 = 1 - c * d, _.m11 = 0, _.m12 = o * a, _.m13 = h * a, _.m14 = d * a, _.m15 = 1, ce.toArray(i, _, me.MAT_LIGHT_PLANE_PROJ_OFFSET);
      }

      function Kt(e, t) {
        le.normalize(vt, e.normal), t[me.PLANAR_NORMAL_DISTANCE_INFO_OFFSET + 0] = vt.x, t[me.PLANAR_NORMAL_DISTANCE_INFO_OFFSET + 1] = vt.y, t[me.PLANAR_NORMAL_DISTANCE_INFO_OFFSET + 2] = vt.z, t[me.PLANAR_NORMAL_DISTANCE_INFO_OFFSET + 3] = e.distance;
      }

      function Zt(e, t) {
        var i = e.pipelineSceneData.validPunctualLights;
        i.length = 0;

        for (var r = t.scene.spotLights, n = 0; n < r.length; n++) {
          var a = r[n];
          a.baked || (fe.set(yt, a.position.x, a.position.y, a.position.z, a.range), Se.sphereFrustum(yt, t.frustum) && i.push(a));
        }

        for (var s = t.scene.sphereLights, o = 0; o < s.length; o++) {
          var h = s[o];
          h.baked || (fe.set(yt, h.position.x, h.position.y, h.position.z, h.range), Se.sphereFrustum(yt, t.frustum) && i.push(h));
        }
      }

      function Jt(e, t) {
        var i = t.scene,
            r = i.mainLight,
            n = e.pipelineSceneData,
            a = n.shadows,
            s = n.skybox,
            o = n.renderObjects;
        Wt.freeArray(o), o.length = 0;
        var h = n.castShadowObjects;
        Vt.freeArray(h), h.length = 0, Ot = !1;
        var d = null;
        if (a.enabled && (e.pipelineUBO.updateShadowUBORange(me.SHADOW_COLOR_OFFSET, a.shadowColor), a.type === ve.ShadowMap)) if (d = e.pipelineSceneData.dirShadowObjects, Qt.freeArray(d), d.length = 0, r && r.node) !function (e, t, i, r, n) {
          var a = t.device;

          if (i.shadowFixedArea) {
            var s = i.shadowOrthoSize,
                o = i.shadowOrthoSize,
                h = i.shadowNear,
                d = i.shadowFar;
            ce.fromRT(Nt, i.node.getWorldRotation(), i.node.getWorldPosition()), ce.invert(Dt, Nt), ce.ortho(Pt, -s, s, -o, o, h, d, a.capabilities.clipSpaceMinZ, a.capabilities.clipSpaceSignY), ce.multiply(Lt, Pt, Dt), ce.invert(Bt, Dt), n.matShadowView = Dt, n.matShadowProj = Pt, n.matShadowViewProj = Lt, pe.createOrtho(e, 2 * s, 2 * o, h, d, Bt);
          } else {
            var u = i.shadowInvisibleOcclusionRange,
                l = n.size.x;
            !function (e, t) {
              if (t.node) {
                var i = t.node,
                    r = i.getWorldPosition(),
                    n = i.getWorldRotation();
                ce.fromRT(e, n, r), e.m08 *= -1, e.m09 *= -1, e.m10 *= -1;
              }
            }(At, r), pe.split(Rt, r, At, .1, i.shadowDistance), It = pe.clone(Rt), ce.fromRT(Nt, i.node.rotation, Ut), ce.invert(Dt, Nt), ce.invert(Bt, Dt);
            var c = Dt.clone();
            It.transform(Dt), _e.fromPoints(Et, new le(1e7, 1e7, 1e7), new le(-1e7, -1e7, -1e7)), Et.mergeFrustum(It);

            var _ = 2 * Et.halfExtents.z;

            wt.set(Et.center.x, Et.center.y, Et.center.z + Et.halfExtents.z + u), le.transformMat4(wt, wt, Bt), ce.fromRT(Nt, i.node.rotation, wt), ce.invert(Dt, Nt), ce.invert(Bt, Dt);
            var f = le.distance(Rt.vertices[0], Rt.vertices[6]);
            bt.center.set(0, 0, 0), bt.radius = -1, bt.mergePoints(Rt.vertices);
            var p = .8 * f + .4 * bt.radius;
            n.shadowCameraFar = _ + u;
            var g = .5 * p;

            if (ce.ortho(Pt, -g, g, -g, g, .1, n.shadowCameraFar, a.capabilities.clipSpaceMinZ, a.capabilities.clipSpaceSignY), l > 0) {
              ce.multiply(Ct, Pt, c), le.transformMat4(xt, wt, Ct);
              var S = 2 / l;
              zt.set(S, S);
              var m = xt.x % zt.x,
                  v = xt.y % zt.y;
              Ht.set(xt.x - m, xt.y - v, xt.z), ce.invert(Mt, Ct), le.transformMat4(Gt, Ht, Mt), ce.fromRT(Nt, i.node.rotation, Gt), ce.invert(Dt, Nt), ce.invert(Bt, Dt), pe.createOrtho(e, p, p, .1, n.shadowCameraFar, Bt);
            } else {
              for (var w = 0; w < 8; w++) {
                e.vertices[w].set(0, 0, 0);
              }

              e.updatePlanes();
            }

            ce.multiply(Lt, Pt, Dt), n.matShadowView = Dt, n.matShadowProj = Pt, n.matShadowViewProj = Lt;
          }
        }(Ft, e, r, t, a);else {
          for (var u = 0; u < 8; u++) {
            Ft.vertices[u].set(0, 0, 0);
          }

          Ft.updatePlanes();
        }
        r && a.type === ve.Planar && function (e, t) {
          var i = e.pipelineSceneData.shadows,
              r = t.direction,
              n = i.normal,
              a = i.distance + .001,
              s = 1 / le.dot(n, r),
              o = r.x * s,
              h = r.y * s,
              d = r.z * s,
              u = n.x,
              l = n.y,
              c = n.z,
              _ = i.matLight;
          _.m00 = 1 - u * o, _.m01 = -u * h, _.m02 = -u * d, _.m03 = 0, _.m04 = -l * o, _.m05 = 1 - l * h, _.m06 = -l * d, _.m07 = 0, _.m08 = -c * o, _.m09 = -c * h, _.m10 = 1 - c * d, _.m11 = 0, _.m12 = o * a, _.m13 = h * a, _.m14 = d * a, _.m15 = 1, e.pipelineUBO.updateShadowUBORange(me.MAT_LIGHT_PLANE_PROJ_OFFSET, i.matLight);
        }(e, r), s.enabled && s.model && t.clearFlag & pt && o.push(qt(s.model, t));

        for (var l = i.models, c = t.visibility, _ = 0; _ < l.length; _++) {
          var f = l[_];

          if (f.enabled && (f.castShadow && h.push(Xt(f, t)), a.firstSetCSM && f.worldBounds && (Ot || (Tt.copy(f.worldBounds), Ot = !0), _e.merge(Tt, Tt, f.worldBounds)), f.node && (c & f.node.layer) === f.node.layer || c & f.visFlags)) {
            if (null != d && f.castShadow && f.worldBounds && Se.aabbFrustum(f.worldBounds, Ft) && d.push(kt(f, t)), f.worldBounds && !Se.aabbFrustum(f.worldBounds, t.frustum)) continue;
            o.push(qt(f, t));
          }
        }
      }

      var jt,
          $t = new i(r.LINEAR, r.LINEAR, r.NONE, n.CLAMP, n.CLAMP, n.CLAMP),
          ei = new i(r.POINT, r.POINT, r.NONE, n.CLAMP, n.CLAMP, n.CLAMP),
          ti = function () {
        function e(e) {
          this._device = void 0, this._descriptorSetMap = new Map(), this._globalDescriptorSet = void 0, this._descriptorSetLayout = void 0, this._linearSampler = void 0, this._pointSampler = void 0, this._device = e.device, this._linearSampler = this._device.getSampler($t), this._pointSampler = this._device.getSampler(ei);
          var t = new u(Ae.bindings);
          this._descriptorSetLayout = this._device.createDescriptorSetLayout(t), this._globalDescriptorSet = this._device.createDescriptorSet(new a(this._descriptorSetLayout));
        }

        var t = e.prototype;
        return t.bindBuffer = function (e, t) {
          this._globalDescriptorSet.bindBuffer(e, t);

          for (var i = this._descriptorSetMap.values(), r = i.next(); !r.done;) {
            r.value.bindBuffer(e, t), r = i.next();
          }
        }, t.bindSampler = function (e, t) {
          this._globalDescriptorSet.bindSampler(e, t);

          for (var i = this._descriptorSetMap.values(), r = i.next(); !r.done;) {
            r.value.bindSampler(e, t), r = i.next();
          }
        }, t.bindTexture = function (e, t) {
          this._globalDescriptorSet.bindTexture(e, t);

          for (var i = this._descriptorSetMap.values(), r = i.next(); !r.done;) {
            r.value.bindTexture(e, t), r = i.next();
          }
        }, t.update = function () {
          this._globalDescriptorSet.update();

          for (var e = this._descriptorSetMap.values(), t = e.next(); !t.done;) {
            t.value.update(), t = e.next();
          }
        }, t.getOrCreateDescriptorSet = function (e) {
          var t = this._device;

          if (!this._descriptorSetMap.has(e)) {
            var i = this._globalDescriptorSet,
                r = t.createDescriptorSet(new a(this._descriptorSetLayout));

            this._descriptorSetMap.set(e, r);

            for (var n = we.UBO_GLOBAL; n < we.COUNT; n++) {
              r.bindBuffer(n, i.getBuffer(n)), r.bindSampler(n, i.getSampler(n)), r.bindTexture(n, i.getTexture(n));
            }

            var d = t.createBuffer(new s(o.UNIFORM | o.TRANSFER_DST, h.HOST | h.DEVICE, me.SIZE, me.SIZE));
            r.bindBuffer(me.BINDING, d), r.update();
          }

          return this._descriptorSetMap.get(e);
        }, t.destroy = function () {
          this._descriptorSetLayout.destroy();
        }, d(e, [{
          key: "descriptorSetMap",
          get: function get() {
            return this._descriptorSetMap;
          }
        }, {
          key: "linearSampler",
          get: function get() {
            return this._linearSampler;
          }
        }, {
          key: "pointSampler",
          get: function get() {
            return this._pointSampler;
          }
        }, {
          key: "descriptorSetLayout",
          get: function get() {
            return this._descriptorSetLayout;
          }
        }, {
          key: "globalDescriptorSet",
          get: function get() {
            return this._globalDescriptorSet;
          }
        }]), e;
      }(),
          ii = new le(),
          ri = new le(),
          ni = new le(),
          ai = new le(),
          si = new le(),
          oi = new le(),
          hi = new le(),
          di = new le(),
          ui = new le(),
          li = new le();

      !function (e) {
        e[e.LINE = 0] = "LINE", e[e.DASHED_LINE = 1] = "DASHED_LINE", e[e.TRIANGLE = 2] = "TRIANGLE";
      }(jt || (jt = {}));

      var ci,
          _i,
          fi,
          pi,
          gi,
          Si,
          mi,
          vi,
          wi,
          Ai,
          Ei = function () {
        function e() {
          this._maxVertices = 0, this._vertexCount = 0, this._stride = 0;
        }

        var t = e.prototype;
        return t.init = function (e, t, i, r) {
          this._maxVertices = t, this._vertexCount = 0, this._stride = i, this._vertices = new Float32Array(t * i / Float32Array.BYTES_PER_ELEMENT), this._buffer = e.createBuffer(new s(o.VERTEX | o.TRANSFER_DST, h.DEVICE, t * i, i)), this._inputAssembler = e.createInputAssembler(new g(r, [this._buffer], null));
        }, t.empty = function () {
          return 0 === this._vertexCount;
        }, t.reset = function () {
          this._vertexCount = 0;
        }, t.update = function () {
          if (!this.empty()) {
            var e = Math.min(this._vertexCount, this._maxVertices) * this._stride;

            this._buffer.update(this._vertices, e);
          }
        }, t.destroy = function () {
          this._inputAssembler && this._inputAssembler.destroy(), this._buffer && this._buffer.destroy();
        }, e;
      }(),
          Ti = function Ti() {
        this.lines = [], this.dashedLines = [], this.triangles = [];

        for (var e = 0; e < 2; e++) {
          this.lines[e] = new Ei(), this.dashedLines[e] = new Ei(), this.triangles[e] = new Ei();
        }
      },
          Oi = function () {
        function e() {
          this._device = null, this._pipeline = null, this._buffers = void 0, this._nativeObj = null, this._buffers = new Ti();
        }

        var t = e.prototype;
        return t.activate = function (e, t, i) {
          this._device = e, this._pipeline = t;

          for (var r = [new l(c.ATTR_POSITION, _.RGB32F), new l(c.ATTR_COLOR, _.RGBA32F)], n = [new l(c.ATTR_POSITION, _.RGB32F), new l(c.ATTR_NORMAL, _.RGBA32F), new l(c.ATTR_COLOR, _.RGBA32F)], a = i ? i.maxLines : 1e5, s = i ? i.maxDashedLines : 1e4, o = i ? i.maxTriangles : 1e4, h = Float32Array.BYTES_PER_ELEMENT * (le.length + Oe.length), d = Float32Array.BYTES_PER_ELEMENT * (le.length + ye.length + Oe.length), u = 0; u < 2; u++) {
            this._buffers.lines[u].init(this._device, 2 * a, h, r), this._buffers.dashedLines[u].init(this._device, 2 * s, h, r), this._buffers.triangles[u].init(this._device, 3 * o, d, n);
          }
        }, t.flush = function () {}, t.render = function (e, t) {
          this.update();

          for (var i = this._pipeline.pipelineSceneData.geometryRendererPasses, r = this._pipeline.pipelineSceneData.geometryRendererShaders, n = 0, a = [1, 2], s = 0; s < 2; s++) {
            var o = this._buffers.lines[s];

            if (!o.empty()) {
              var h = new p();
              h.vertexCount = o._vertexCount;

              for (var d = 0; d < a[s]; d++) {
                var u = i[n + d],
                    l = r[n + d],
                    c = Ee.getOrCreatePipelineState(this._device, u, l, e, o._inputAssembler);
                t.bindPipelineState(c), t.bindDescriptorSet(Te.MATERIAL, u.descriptorSet), t.bindInputAssembler(o._inputAssembler), t.draw(h);
              }
            }

            n += a[s];
          }

          for (var _ = 0; _ < 2; _++) {
            var f = this._buffers.dashedLines[_];

            if (!f.empty()) {
              var g = new p();
              g.vertexCount = f._vertexCount;

              for (var S = 0; S < a[_]; S++) {
                var m = i[n + S],
                    v = r[n + S],
                    w = Ee.getOrCreatePipelineState(this._device, m, v, e, f._inputAssembler);
                t.bindPipelineState(w), t.bindDescriptorSet(Te.MATERIAL, m.descriptorSet), t.bindInputAssembler(f._inputAssembler), t.draw(g);
              }
            }

            n += a[_];
          }

          for (var A = 0; A < 2; A++) {
            var E = this._buffers.triangles[A];

            if (!E.empty()) {
              var T = new p();
              T.vertexCount = E._vertexCount;

              for (var O = 0; O < a[A]; O++) {
                var y = i[n + O],
                    b = r[n + O],
                    R = Ee.getOrCreatePipelineState(this._device, y, b, e, E._inputAssembler);
                t.bindPipelineState(R), t.bindDescriptorSet(Te.MATERIAL, y.descriptorSet), t.bindInputAssembler(E._inputAssembler), t.draw(T);
              }
            }

            n += a[A];
          }

          this.reset();
        }, t.destroy = function () {
          for (var e = 0; e < 2; e++) {
            this._buffers.lines[e].destroy(), this._buffers.dashedLines[e].destroy(), this._buffers.triangles[e].destroy();
          }
        }, t.empty = function () {
          for (var e = 0; e < 2; e++) {
            if (!this._buffers.lines[e].empty() || !this._buffers.dashedLines[e].empty() || !this._buffers.triangles[e].empty()) return !1;
          }

          return !0;
        }, t.update = function () {
          for (var e = 0; e < 2; e++) {
            this._buffers.lines[e].update(), this._buffers.dashedLines[e].update(), this._buffers.triangles[e].update();
          }
        }, t.reset = function () {
          for (var e = 0; e < 2; e++) {
            this._buffers.lines[e].reset(), this._buffers.dashedLines[e].reset(), this._buffers.triangles[e].reset();
          }
        }, t.addDashedLine = function (e, t, i, r) {
          void 0 === r && (r = !0);
          var n = this._buffers.dashedLines[r ? 1 : 0];
          if (n._vertexCount + 2 > n._maxVertices) f(12008);else {
            var a = n._vertexCount * (le.length + Oe.length);
            le.toArray(n._vertices, e, a), a += le.length, Oe.toArray(n._vertices, i, a), a += Oe.length, le.toArray(n._vertices, t, a), a += le.length, Oe.toArray(n._vertices, i, a), n._vertexCount += 2;
          }
        }, t.addLine = function (e, t, i, r) {
          void 0 === r && (r = !0);
          var n = this._buffers.lines[r ? 1 : 0];
          if (n._vertexCount + 2 > n._maxVertices) f(12008);else {
            var a = n._vertexCount * (le.length + Oe.length);
            le.toArray(n._vertices, e, a), a += le.length, Oe.toArray(n._vertices, i, a), a += Oe.length, le.toArray(n._vertices, t, a), a += le.length, Oe.toArray(n._vertices, i, a), n._vertexCount += 2;
          }
        }, t.addTriangle = function (e, t, i, r, n, a, s) {
          if (void 0 === n && (n = !0), void 0 === a && (a = !0), void 0 === s && (s = !1), n) return this.addLine(e, t, r, a), this.addLine(t, i, r, a), void this.addLine(i, e, r, a);
          var o = this._buffers.triangles[a ? 1 : 0];
          if (o._vertexCount + 3 > o._maxVertices) f(12009);else {
            var h = new ye(ye.ZERO);

            if (!s) {
              var d = new le(t.x - e.x, t.y - e.y, t.z - e.z),
                  u = new le(i.x - e.x, i.y - e.y, i.z - e.z),
                  l = new le();
              le.normalize(l, le.cross(l, d, u)), h.set(l.x, l.y, l.z, 1);
            }

            var c = o._vertexCount * (le.length + ye.length + Oe.length);
            le.toArray(o._vertices, e, c), c += le.length, ye.toArray(o._vertices, h, c), c += ye.length, Oe.toArray(o._vertices, r, c), c += Oe.length, le.toArray(o._vertices, t, c), c += le.length, ye.toArray(o._vertices, h, c), c += ye.length, Oe.toArray(o._vertices, r, c), c += Oe.length, le.toArray(o._vertices, i, c), c += le.length, ye.toArray(o._vertices, h, c), c += ye.length, Oe.toArray(o._vertices, r, c), o._vertexCount += 3;
          }
        }, t.addQuad = function (e, t, i, r, n, a, s, o) {
          void 0 === a && (a = !0), void 0 === s && (s = !0), void 0 === o && (o = !1), a ? (this.addLine(e, t, n, s), this.addLine(t, i, n, s), this.addLine(i, r, n, s), this.addLine(r, e, n, s)) : (this.addTriangle(e, t, i, n, a, s, o), this.addTriangle(e, i, r, n, a, s, o));
        }, t.addBoundingBox = function (e, t, i, r, n, a, s) {
          void 0 === i && (i = !0), void 0 === r && (r = !0), void 0 === n && (n = !1), void 0 === a && (a = !1), void 0 === s && (s = new ce()), ii.set(e.center.x - e.halfExtents.x, e.center.y - e.halfExtents.y, e.center.z - e.halfExtents.z), ri.set(e.center.x + e.halfExtents.x, e.center.y + e.halfExtents.y, e.center.z + e.halfExtents.z), ni.set(ii.x, ii.y, ii.z), ai.set(ri.x, ii.y, ii.z), si.set(ii.x, ri.y, ii.z), oi.set(ri.x, ri.y, ii.z), hi.set(ii.x, ii.y, ri.z), di.set(ri.x, ii.y, ri.z), ui.set(ii.x, ri.y, ri.z), li.set(ri.x, ri.y, ri.z), a && (le.transformMat4(ni, ni, s), le.transformMat4(ai, ai, s), le.transformMat4(si, si, s), le.transformMat4(oi, oi, s), le.transformMat4(hi, hi, s), le.transformMat4(di, di, s), le.transformMat4(ui, ui, s), le.transformMat4(li, li, s)), i ? (this.addLine(ui, li, t, r), this.addLine(li, oi, t, r), this.addLine(oi, si, t, r), this.addLine(si, ui, t, r), this.addLine(hi, di, t, r), this.addLine(di, ai, t, r), this.addLine(ai, ni, t, r), this.addLine(ni, hi, t, r), this.addLine(ui, hi, t, r), this.addLine(li, di, t, r), this.addLine(oi, ai, t, r), this.addLine(si, ni, t, r)) : (this.addQuad(hi, di, li, ui, t, i, r, n), this.addQuad(di, ai, oi, li, t, i, r, n), this.addQuad(ai, ni, si, oi, t, i, r, n), this.addQuad(ni, hi, ui, si, t, i, r, n), this.addQuad(ui, li, oi, si, t, i, r, n), this.addQuad(ni, ai, di, hi, t, i, r, n));
        }, t.addCross = function (e, t, i, r) {
          void 0 === r && (r = !0);
          var n = .5 * t,
              a = new le(e.x - n, e.y, e.z),
              s = new le(e.x + n, e.y, e.z);
          this.addLine(a, s, i, r), a.set(e.x, e.y - n, e.z), s.set(e.x, e.y + n, e.z), this.addLine(a, s, i, r), a.set(e.x, e.y, e.z - n), s.set(e.x, e.y, e.z + n), this.addLine(a, s, i, r);
        }, t.addFrustum = function (e, t, i) {
          void 0 === i && (i = !0);
          var r = e.vertices;
          this.addLine(r[0], r[1], t, i), this.addLine(r[1], r[2], t, i), this.addLine(r[2], r[3], t, i), this.addLine(r[3], r[0], t, i), this.addLine(r[4], r[5], t, i), this.addLine(r[5], r[6], t, i), this.addLine(r[6], r[7], t, i), this.addLine(r[7], r[4], t, i), this.addLine(r[0], r[4], t, i), this.addLine(r[1], r[5], t, i), this.addLine(r[2], r[6], t, i), this.addLine(r[3], r[7], t, i);
        }, t.addCapsule = function (e, t, i, r, n, a, s, o, h, d, u) {
          void 0 === n && (n = 32), void 0 === a && (a = 8), void 0 === s && (s = !0), void 0 === o && (o = !0), void 0 === h && (h = !1), void 0 === d && (d = !1), void 0 === u && (u = new ce());

          for (var l = 2 * Math.PI / n, c = Math.PI / 2 / a, _ = new le(e.x, e.y - i / 2, e.z), f = new le(e.x, e.y + i / 2, e.z), p = new Array(), g = new Array(), S = 0; S < a + 1; S++) {
            for (var m = new Array(), v = new Array(), w = S * c, A = Math.sin(w), E = Math.cos(w), T = 0; T < n + 1; T++) {
              var O = T * l,
                  y = Math.sin(O),
                  b = Math.cos(O),
                  R = new le(t * A * b, t * E, t * A * y),
                  I = new le(_.x + R.x, _.y - R.y, _.z + R.z),
                  F = new le(f.x + R.x, f.y + R.y, f.z + R.z);
              m.push(I), v.push(F);
            }

            p.push(m), g.push(v);
          }

          if (d) for (var N = 0; N < a + 1; N++) {
            for (var D = 0; D < n + 1; D++) {
              le.transformMat4(p[N][D], p[N][D], u), le.transformMat4(g[N][D], g[N][D], u);
            }
          }

          for (var B = 0; B < a; B++) {
            for (var P = 0; P < n; P++) {
              this.addTriangle(p[B + 1][P], p[B][P + 1], p[B][P], r, s, o, h), this.addTriangle(p[B + 1][P], p[B + 1][P + 1], p[B][P + 1], r, s, o, h), this.addTriangle(g[B][P], g[B + 1][P + 1], g[B + 1][P], r, s, o, h), this.addTriangle(g[B][P], g[B][P + 1], g[B + 1][P + 1], r, s, o, h);
            }
          }

          for (var L = p[a], C = g[a], M = 0; M < n; M++) {
            this.addTriangle(C[M], L[M + 1], L[M], r, s, o, h), this.addTriangle(C[M], C[M + 1], L[M + 1], r, s, o, h);
          }
        }, t.addCylinder = function (e, t, i, r, n, a, s, o, h, d) {
          void 0 === n && (n = 32), void 0 === a && (a = !0), void 0 === s && (s = !0), void 0 === o && (o = !1), void 0 === h && (h = !1), void 0 === d && (d = new ce());

          for (var u = 2 * Math.PI / n, l = new le(e.x, e.y - i / 2, e.z), c = new le(e.x, e.y + i / 2, e.z), _ = new Array(), f = new Array(), p = 0; p < n + 1; p++) {
            var g = p * u,
                S = new le(t * Math.cos(g), 0, t * Math.sin(g)),
                m = new le(S.x + l.x, S.y + l.y, S.z + l.z),
                v = new le(S.x + c.x, S.y + c.y, S.z + c.z);
            _.push(m), f.push(v);
          }

          if (h) {
            le.transformMat4(l, l, d), le.transformMat4(c, c, d);

            for (var w = 0; w < n + 1; w++) {
              le.transformMat4(_[w], _[w], d), le.transformMat4(f[w], f[w], d);
            }
          }

          for (var A = 0; A < n; A++) {
            this.addTriangle(c, f[A + 1], f[A], r, a, s, o), this.addTriangle(l, _[A], _[A + 1], r, a, s, o), this.addTriangle(f[A], _[A + 1], _[A], r, a, s, o), this.addTriangle(f[A], f[A + 1], _[A + 1], r, a, s, o);
          }
        }, t.addCone = function (e, t, i, r, n, a, s, o, h, d) {
          void 0 === n && (n = 32), void 0 === a && (a = !0), void 0 === s && (s = !0), void 0 === o && (o = !1), void 0 === h && (h = !1), void 0 === d && (d = new ce());

          for (var u = 2 * Math.PI / n, l = new le(e.x, e.y - i / 2, e.z), c = new le(e.x, e.y + i / 2, e.z), _ = new Array(), f = 0; f < n + 1; f++) {
            var p = new le(t * Math.cos(f * u), 0, t * Math.sin(f * u)),
                g = new le(p.x + l.x, p.y + l.y, p.z + l.z);

            _.push(g);
          }

          if (h) {
            le.transformMat4(l, l, d), le.transformMat4(c, c, d);

            for (var S = 0; S < n + 1; S++) {
              le.transformMat4(_[S], _[S], d);
            }
          }

          for (var m = 0; m < n; m++) {
            this.addTriangle(c, _[m + 1], _[m], r, a, s, o), this.addTriangle(l, _[m], _[m + 1], r, a, s, o);
          }
        }, t.addCircle = function (e, t, i, r, n, a, s) {
          void 0 === r && (r = 32), void 0 === n && (n = !0), void 0 === a && (a = !1), void 0 === s && (s = new ce());

          for (var o = 2 * Math.PI / r, h = new Array(), d = 0; d < r + 1; d++) {
            var u = new le(t * Math.cos(d * o), 0, t * Math.sin(d * o)),
                l = new le(u.x + e.x, u.y + e.y, u.z + e.z);
            h.push(l);
          }

          if (a) for (var c = 0; c < r + 1; c++) {
            le.transformMat4(h[c], h[c], s);
          }

          for (var _ = 0; _ < r; _++) {
            this.addLine(h[_], h[_ + 1], i, n);
          }
        }, t.addArc = function (e, t, i, r, n, a, s, o, h) {
          void 0 === a && (a = 32), void 0 === s && (s = !0), void 0 === o && (o = !1), void 0 === h && (h = new ce());

          for (var d = be(r), u = (be(n) - d) / a, l = new Array(), c = 0; c < a + 1; c++) {
            var _ = new le(t * Math.cos(c * u + d), 0, t * Math.sin(c * u + d)),
                f = new le(_.x + e.x, _.y + e.y, _.z + e.z);

            l.push(f);
          }

          if (o) for (var p = 0; p < a + 1; p++) {
            le.transformMat4(l[p], l[p], h);
          }

          for (var g = 0; g < a; g++) {
            this.addLine(l[g], l[g + 1], i, s);
          }
        }, t.addPolygon = function (e, t, i, r, n, a, s, o, h) {
          void 0 === r && (r = 6), void 0 === n && (n = !0), void 0 === a && (a = !0), void 0 === s && (s = !1), void 0 === o && (o = !1), void 0 === h && (h = new ce()), n ? this.addCircle(e, t, i, r, a, o, h) : this.addDisc(e, t, i, r, n, a, s, o, h);
        }, t.addDisc = function (e, t, i, r, n, a, s, o, h) {
          void 0 === r && (r = 32), void 0 === n && (n = !0), void 0 === a && (a = !0), void 0 === s && (s = !1), void 0 === o && (o = !1), void 0 === h && (h = new ce());

          for (var d = 2 * Math.PI / r, u = new Array(), l = new le(e), c = 0; c < r + 1; c++) {
            var _ = new le(t * Math.cos(c * d), 0, t * Math.sin(c * d)),
                f = new le(_.x + l.x, _.y + l.y, _.z + l.z);

            u.push(f);
          }

          if (o) {
            le.transformMat4(l, l, h);

            for (var p = 0; p < r + 1; p++) {
              le.transformMat4(u[p], u[p], h);
            }
          }

          for (var g = 0; g < r; g++) {
            this.addTriangle(l, u[g], u[g + 1], i, n, a, s);
          }

          if (!n) for (var S = 0; S < r; S++) {
            this.addTriangle(l, u[S + 1], u[S], i, n, a, s);
          }
        }, t.addSector = function (e, t, i, r, n, a, s, o, h, d, u) {
          void 0 === a && (a = 32), void 0 === s && (s = !0), void 0 === o && (o = !0), void 0 === h && (h = !1), void 0 === d && (d = !1), void 0 === u && (u = new ce());

          for (var l = be(r), c = (be(n) - l) / a, _ = new Array(), f = new le(e), p = 0; p < a + 1; p++) {
            var g = new le(t * Math.cos(p * c), 0, t * Math.sin(p * c)),
                S = new le(g.x + f.x, g.y + f.y, g.z + f.z);

            _.push(S);
          }

          if (d) {
            le.transformMat4(f, f, u);

            for (var m = 0; m < a + 1; m++) {
              le.transformMat4(_[m], _[m], u);
            }
          }

          for (var v = 0; v < a; v++) {
            this.addTriangle(f, _[v], _[v + 1], i, s, o, h);
          }

          if (!s) for (var w = 0; w < a; w++) {
            this.addTriangle(f, _[w + 1], _[w], i, s, o, h);
          }
        }, t.addSphere = function (e, t, i, r, n, a, s, o, h, d) {
          void 0 === r && (r = 32), void 0 === n && (n = 16), void 0 === a && (a = !0), void 0 === s && (s = !0), void 0 === o && (o = !1), void 0 === h && (h = !1), void 0 === d && (d = new ce());

          for (var u = 2 * Math.PI / r, l = Math.PI / n, c = new Array(), _ = 0; _ < n + 1; _++) {
            for (var f = new Array(), p = _ * l, g = Math.sin(p), S = Math.cos(p), m = 0; m < r + 1; m++) {
              var v = m * u,
                  w = Math.sin(v),
                  A = Math.cos(v),
                  E = new le(t * g * A, t * S, t * g * w),
                  T = new le(e.x + E.x, e.y + E.y, e.z + E.z);
              f.push(T);
            }

            c.push(f);
          }

          if (h) for (var O = 0; O < n + 1; O++) {
            for (var y = 0; y < r + 1; y++) {
              le.transformMat4(c[O][y], c[O][y], d);
            }
          }

          for (var b = 0; b < n; b++) {
            for (var R = 0; R < r; R++) {
              this.addTriangle(c[b][R], c[b + 1][R + 1], c[b + 1][R], i, a, s, o), this.addTriangle(c[b][R], c[b][R + 1], c[b + 1][R + 1], i, a, s, o);
            }
          }
        }, t.addTorus = function (e, t, i, r, n, a, s, o, h, d, u) {
          void 0 === n && (n = 32), void 0 === a && (a = 16), void 0 === s && (s = !0), void 0 === o && (o = !0), void 0 === h && (h = !1), void 0 === d && (d = !1), void 0 === u && (u = new ce());

          for (var l = 2 * Math.PI / n, c = 2 * Math.PI / a, _ = new Array(), f = 0; f < n + 1; f++) {
            for (var p = new Array(), g = f * l, S = Math.sin(g), m = Math.cos(g), v = 0; v < a + 1; v++) {
              var w = v * c,
                  A = Math.sin(w),
                  E = Math.cos(w),
                  T = new le((t + i * E) * m, i * A, (t + i * E) * S),
                  O = new le(e.x + T.x, e.y + T.y, e.z + T.z);
              p.push(O);
            }

            _.push(p);
          }

          if (d) for (var y = 0; y < n + 1; y++) {
            for (var b = 0; b < a + 1; b++) {
              le.transformMat4(_[y][b], _[y][b], u);
            }
          }

          for (var R = 0; R < n; R++) {
            for (var I = 0; I < a; I++) {
              this.addTriangle(_[R][I + 1], _[R + 1][I], _[R][I], r, s, o, h), this.addTriangle(_[R][I + 1], _[R + 1][I + 1], _[R + 1][I], r, s, o, h);
            }
          }
        }, t.addOctahedron = function (e, t, i, r, n, a, s, o) {
          void 0 === r && (r = !0), void 0 === n && (n = !0), void 0 === a && (a = !1), void 0 === s && (s = !1), void 0 === o && (o = new ce());
          var h = new Array();
          if (h.push(new le(t + e.x, e.y, e.z)), h.push(new le(e.x, e.y, e.z - t)), h.push(new le(-t + e.x, e.y, e.z)), h.push(new le(e.x, e.y, e.z + t)), h.push(new le(e.x, e.y + t, e.z)), h.push(new le(e.x, e.y - t, e.z)), s) for (var d = 0; d < h.length; d++) {
            le.transformMat4(h[d], h[d], o);
          }
          r ? (this.addLine(h[0], h[1], i, n), this.addLine(h[1], h[2], i, n), this.addLine(h[2], h[3], i, n), this.addLine(h[3], h[0], i, n), this.addLine(h[0], h[4], i, n), this.addLine(h[1], h[4], i, n), this.addLine(h[2], h[4], i, n), this.addLine(h[3], h[4], i, n), this.addLine(h[0], h[5], i, n), this.addLine(h[1], h[5], i, n), this.addLine(h[2], h[5], i, n), this.addLine(h[3], h[5], i, n)) : (this.addTriangle(h[0], h[1], h[4], i, r, n, a), this.addTriangle(h[1], h[2], h[4], i, r, n, a), this.addTriangle(h[2], h[3], h[4], i, r, n, a), this.addTriangle(h[3], h[0], h[4], i, r, n, a), this.addTriangle(h[0], h[3], h[5], i, r, n, a), this.addTriangle(h[3], h[2], h[5], i, r, n, a), this.addTriangle(h[2], h[1], h[5], i, r, n, a), this.addTriangle(h[1], h[0], h[5], i, r, n, a));
        }, t.addBezier = function (e, t, i, r, n, a, s, o, h) {
          void 0 === a && (a = 32), void 0 === s && (s = !0), void 0 === o && (o = !1), void 0 === h && (h = new ce());

          var d = 1 / a,
              u = new Array(),
              l = new le(e),
              c = new le(t),
              _ = new le(i),
              f = new le(r);

          o && (le.transformMat4(l, l, h), le.transformMat4(c, c, h), le.transformMat4(_, _, h), le.transformMat4(f, f, h));

          for (var p = 0; p < a + 1; p++) {
            var g = p * d,
                S = (1 - g) * (1 - g) * (1 - g),
                m = 3 * g * (1 - g) * (1 - g),
                v = 3 * g * g * (1 - g),
                w = g * g * g,
                A = new le(S * l.x + m * c.x + v * _.x + w * f.x, S * l.y + m * c.y + v * _.y + w * f.y, S * l.z + m * c.z + v * _.z + w * f.z);
            u.push(A);
          }

          for (var E = 0; E < a; E++) {
            this.addLine(u[E], u[E + 1], n, s);
          }
        }, t.addMesh = function (e, t, i, r, n, a) {
          void 0 === r && (r = !0), void 0 === n && (n = !1), void 0 === a && (a = new ce());

          for (var s = 0; s < t.length; s += 3) {
            var o = new le(e.x + t[s].x, e.y + t[s].y, e.z + t[s].z),
                h = new le(e.x + t[s + 1].x, e.y + t[s + 1].y, e.z + t[s + 1].z),
                d = new le(e.x + t[s + 2].x, e.y + t[s + 2].y, e.z + t[s + 2].z);
            n && (le.transformMat4(o, o, a), le.transformMat4(h, h, a), le.transformMat4(d, d, a)), this.addLine(o, h, i, r), this.addLine(h, d, i, r), this.addLine(d, o, i, r);
          }
        }, t.addIndexedMesh = function (e, t, i, r, n, a, s) {
          void 0 === n && (n = !0), void 0 === a && (a = !1), void 0 === s && (s = new ce());

          for (var o = 0; o < i.length; o += 3) {
            var h = new le(e.x + t[i[o]].x, e.y + t[i[o]].y, e.z + t[i[o]].z),
                d = new le(e.x + t[i[o + 1]].x, e.y + t[i[o + 1]].y, e.z + t[i[o + 1]].z),
                u = new le(e.x + t[i[o + 2]].x, e.y + t[i[o + 2]].y, e.z + t[i[o + 2]].z);
            a && (le.transformMat4(h, h, s), le.transformMat4(d, d, s), le.transformMat4(u, u, s)), this.addLine(h, d, r, n), this.addLine(d, u, r, n), this.addLine(u, h, r, n);
          }
        }, d(e, [{
          key: "native",
          get: function get() {
            return this._nativeObj;
          }
        }]), e;
      }(),
          yi = new ce(),
          bi = new ce(),
          Ri = new ce(),
          Ii = new ye(),
          Fi = new ye(0, 0, 1, 0),
          Ni = function () {
        function e() {
          this._globalUBO = new Float32Array(Re.COUNT), this._cameraUBO = new Float32Array(Ie.COUNT), this._shadowUBO = new Float32Array(me.COUNT);
        }

        e.updateGlobalUBOView = function (e, t) {
          var i = S.director.root,
              r = t,
              n = Math.floor(e.width),
              a = Math.floor(e.height);
          r[Re.TIME_OFFSET] = i.cumulativeTime, r[Re.TIME_OFFSET + 1] = i.frameTime, r[Re.TIME_OFFSET + 2] = S.director.getTotalFrames(), r[Re.SCREEN_SIZE_OFFSET] = n, r[Re.SCREEN_SIZE_OFFSET + 1] = a, r[Re.SCREEN_SIZE_OFFSET + 2] = 1 / n, r[Re.SCREEN_SIZE_OFFSET + 3] = 1 / a, r[Re.NATIVE_SIZE_OFFSET] = n, r[Re.NATIVE_SIZE_OFFSET + 1] = a, r[Re.NATIVE_SIZE_OFFSET + 2] = 1 / r[Re.NATIVE_SIZE_OFFSET], r[Re.NATIVE_SIZE_OFFSET + 3] = 1 / r[Re.NATIVE_SIZE_OFFSET + 1];
        }, e.updateCameraUBOView = function (e, t, i) {
          var r,
              n = (i.scene ? i.scene : S.director.getScene().renderScene).mainLight,
              a = e.pipelineSceneData,
              s = a.ambient,
              o = a.skybox,
              h = a.fog,
              d = a.shadows,
              u = t,
              l = i.exposure,
              c = a.isHDR;

          if (u[Ie.SCREEN_SCALE_OFFSET] = a.shadingScale, u[Ie.SCREEN_SCALE_OFFSET + 1] = a.shadingScale, u[Ie.SCREEN_SCALE_OFFSET + 2] = 1 / u[Ie.SCREEN_SCALE_OFFSET], u[Ie.SCREEN_SCALE_OFFSET + 3] = 1 / u[Ie.SCREEN_SCALE_OFFSET + 1], u[Ie.EXPOSURE_OFFSET] = l, u[Ie.EXPOSURE_OFFSET + 1] = 1 / l, u[Ie.EXPOSURE_OFFSET + 2] = c ? 1 : 0, u[Ie.EXPOSURE_OFFSET + 3] = 1 / gt.standardExposureValue, n) {
            var _ = n.shadowEnabled && d.type === ve.ShadowMap ? 1 : 0,
                f = n.direction;

            if (Fi.set(f.x, f.y, f.z, _), ye.toArray(u, Fi, Ie.MAIN_LIT_DIR_OFFSET), le.toArray(u, n.color, Ie.MAIN_LIT_COLOR_OFFSET), n.useColorTemperature) {
              var p = n.colorTemperatureRGB;
              u[Ie.MAIN_LIT_COLOR_OFFSET] *= p.x, u[Ie.MAIN_LIT_COLOR_OFFSET + 1] *= p.y, u[Ie.MAIN_LIT_COLOR_OFFSET + 2] *= p.z;
            }

            u[Ie.MAIN_LIT_COLOR_OFFSET + 3] = c ? n.illuminance * l : n.illuminance;
          } else Fi.set(0, 0, 1, 0), ye.toArray(u, Fi, Ie.MAIN_LIT_DIR_OFFSET), ye.toArray(u, ye.ZERO, Ie.MAIN_LIT_COLOR_OFFSET);

          var g = s.skyColor;
          g.w = c ? s.skyIllum * l : s.skyIllum, u[Ie.AMBIENT_SKY_OFFSET + 0] = g.x, u[Ie.AMBIENT_SKY_OFFSET + 1] = g.y, u[Ie.AMBIENT_SKY_OFFSET + 2] = g.z, u[Ie.AMBIENT_SKY_OFFSET + 3] = g.w, u[Ie.AMBIENT_GROUND_OFFSET + 0] = s.groundAlbedo.x, u[Ie.AMBIENT_GROUND_OFFSET + 1] = s.groundAlbedo.y, u[Ie.AMBIENT_GROUND_OFFSET + 2] = s.groundAlbedo.z, u[Ie.AMBIENT_GROUND_OFFSET + 3] = o.envmap ? null === (r = o.envmap) || void 0 === r ? void 0 : r.mipmapLevel : 1, ce.toArray(u, i.matView, Ie.MAT_VIEW_OFFSET), ce.toArray(u, i.node.worldMatrix, Ie.MAT_VIEW_INV_OFFSET), le.toArray(u, i.position, Ie.CAMERA_POS_OFFSET), ce.toArray(u, i.matProj, Ie.MAT_PROJ_OFFSET), ce.toArray(u, i.matProjInv, Ie.MAT_PROJ_INV_OFFSET), ce.toArray(u, i.matViewProj, Ie.MAT_VIEW_PROJ_OFFSET), ce.toArray(u, i.matViewProjInv, Ie.MAT_VIEW_PROJ_INV_OFFSET), u[Ie.CAMERA_POS_OFFSET + 3] = this.getCombineSignY();
          var m = h.colorArray;
          u[Ie.GLOBAL_FOG_COLOR_OFFSET] = m.x, u[Ie.GLOBAL_FOG_COLOR_OFFSET + 1] = m.y, u[Ie.GLOBAL_FOG_COLOR_OFFSET + 2] = m.z, u[Ie.GLOBAL_FOG_COLOR_OFFSET + 3] = m.z, u[Ie.GLOBAL_FOG_BASE_OFFSET] = h.fogStart, u[Ie.GLOBAL_FOG_BASE_OFFSET + 1] = h.fogEnd, u[Ie.GLOBAL_FOG_BASE_OFFSET + 2] = h.fogDensity, u[Ie.GLOBAL_FOG_ADD_OFFSET] = h.fogTop, u[Ie.GLOBAL_FOG_ADD_OFFSET + 1] = h.fogRange, u[Ie.GLOBAL_FOG_ADD_OFFSET + 2] = h.fogAtten, u[Ie.NEAR_FAR_OFFSET] = i.nearClip, u[Ie.NEAR_FAR_OFFSET + 1] = i.farClip, u[Ie.VIEW_PORT_OFFSET] = a.shadingScale * i.window.width * i.viewport.x, u[Ie.VIEW_PORT_OFFSET + 1] = a.shadingScale * i.window.height * i.viewport.y, u[Ie.VIEW_PORT_OFFSET + 2] = a.shadingScale * i.window.width * i.viewport.z, u[Ie.VIEW_PORT_OFFSET + 3] = a.shadingScale * i.window.height * i.viewport.w;
        }, e.updateShadowUBOView = function (e, t, i) {
          var r = e.device,
              n = i.scene.mainLight,
              a = e.pipelineSceneData.shadows,
              s = t;

          if (a.enabled) {
            if (n && n.shadowEnabled && a.type === ve.ShadowMap) {
              var o = .1,
                  h = 0,
                  d = a.matShadowView,
                  u = a.matShadowProj,
                  l = a.matShadowViewProj;
              n.shadowFixedArea ? (o = n.shadowNear, h = n.shadowFar) : (o = .1, h = a.shadowCameraFar), ce.toArray(t, d, me.MAT_LIGHT_VIEW_OFFSET), s[me.SHADOW_PROJ_DEPTH_INFO_OFFSET + 0] = u.m10, s[me.SHADOW_PROJ_DEPTH_INFO_OFFSET + 1] = u.m14, s[me.SHADOW_PROJ_DEPTH_INFO_OFFSET + 2] = u.m11, s[me.SHADOW_PROJ_DEPTH_INFO_OFFSET + 3] = u.m15, s[me.SHADOW_PROJ_INFO_OFFSET + 0] = u.m00, s[me.SHADOW_PROJ_INFO_OFFSET + 1] = u.m05, s[me.SHADOW_PROJ_INFO_OFFSET + 2] = 1 / u.m00, s[me.SHADOW_PROJ_INFO_OFFSET + 3] = 1 / u.m05, ce.toArray(t, l, me.MAT_LIGHT_VIEW_PROJ_OFFSET);
              var c = Be(r) ? 0 : 1;
              s[me.SHADOW_NEAR_FAR_LINEAR_SATURATION_INFO_OFFSET + 0] = o, s[me.SHADOW_NEAR_FAR_LINEAR_SATURATION_INFO_OFFSET + 1] = h, s[me.SHADOW_NEAR_FAR_LINEAR_SATURATION_INFO_OFFSET + 2] = 0, s[me.SHADOW_NEAR_FAR_LINEAR_SATURATION_INFO_OFFSET + 3] = 1 - n.shadowSaturation, s[me.SHADOW_WIDTH_HEIGHT_PCF_BIAS_INFO_OFFSET + 0] = a.size.x, s[me.SHADOW_WIDTH_HEIGHT_PCF_BIAS_INFO_OFFSET + 1] = a.size.y, s[me.SHADOW_WIDTH_HEIGHT_PCF_BIAS_INFO_OFFSET + 2] = n.shadowPcf, s[me.SHADOW_WIDTH_HEIGHT_PCF_BIAS_INFO_OFFSET + 3] = n.shadowBias, s[me.SHADOW_LIGHT_PACKING_NBIAS_NULL_INFO_OFFSET + 0] = 0, s[me.SHADOW_LIGHT_PACKING_NBIAS_NULL_INFO_OFFSET + 1] = c, s[me.SHADOW_LIGHT_PACKING_NBIAS_NULL_INFO_OFFSET + 2] = n.shadowNormalBias, s[me.SHADOW_LIGHT_PACKING_NBIAS_NULL_INFO_OFFSET + 3] = 0;
            } else n && a.type === ve.Planar && (Yt(a, n, s), Kt(a, s));

            Oe.toArray(s, a.shadowColor, me.SHADOW_COLOR_OFFSET);
          }
        }, e.updateShadowUBOLightView = function (e, t, i) {
          var r = e.device,
              n = e.pipelineSceneData.shadows,
              a = t,
              s = Be(r) ? 0 : 1,
              o = .1,
              h = 0,
              d = n.matShadowView,
              u = n.matShadowProj,
              l = n.matShadowViewProj;

          switch (i.type) {
            case St.DIRECTIONAL:
              var c = i;
              c.shadowFixedArea ? (o = c.shadowNear, h = c.shadowFar) : (o = .1, h = n.shadowCameraFar), ce.toArray(t, d, me.MAT_LIGHT_VIEW_OFFSET), a[me.SHADOW_PROJ_DEPTH_INFO_OFFSET + 0] = u.m10, a[me.SHADOW_PROJ_DEPTH_INFO_OFFSET + 1] = u.m14, a[me.SHADOW_PROJ_DEPTH_INFO_OFFSET + 2] = u.m11, a[me.SHADOW_PROJ_DEPTH_INFO_OFFSET + 3] = u.m15, a[me.SHADOW_PROJ_INFO_OFFSET + 0] = u.m00, a[me.SHADOW_PROJ_INFO_OFFSET + 1] = u.m05, a[me.SHADOW_PROJ_INFO_OFFSET + 2] = 1 / u.m00, a[me.SHADOW_PROJ_INFO_OFFSET + 3] = 1 / u.m05, ce.toArray(t, l, me.MAT_LIGHT_VIEW_PROJ_OFFSET), Ii.set(o, h, 0, 1 - c.shadowSaturation), ye.toArray(a, Ii, me.SHADOW_NEAR_FAR_LINEAR_SATURATION_INFO_OFFSET), Ii.set(0, s, c.shadowNormalBias, 0), ye.toArray(a, Ii, me.SHADOW_LIGHT_PACKING_NBIAS_NULL_INFO_OFFSET), Ii.set(n.size.x, n.size.y, c.shadowPcf, c.shadowBias), ye.toArray(a, Ii, me.SHADOW_WIDTH_HEIGHT_PCF_BIAS_INFO_OFFSET);
              break;

            case St.SPOT:
              var _ = i;
              ce.invert(yi, i.node.getWorldMatrix()), ce.toArray(a, yi, me.MAT_LIGHT_VIEW_OFFSET), ce.perspective(bi, i.angle, 1, .001, i.range), ce.multiply(Ri, bi, yi), ce.toArray(a, Ri, me.MAT_LIGHT_VIEW_PROJ_OFFSET), Ii.set(.01, i.range, 0, 0), ye.toArray(a, Ii, me.SHADOW_NEAR_FAR_LINEAR_SATURATION_INFO_OFFSET), Ii.set(1, s, _.shadowNormalBias, 0), ye.toArray(a, Ii, me.SHADOW_LIGHT_PACKING_NBIAS_NULL_INFO_OFFSET), Ii.set(n.size.x, n.size.y, _.shadowPcf, _.shadowBias), ye.toArray(a, Ii, me.SHADOW_WIDTH_HEIGHT_PCF_BIAS_INFO_OFFSET);
          }

          Oe.toArray(a, n.shadowColor, me.SHADOW_COLOR_OFFSET);
        }, e.getCombineSignY = function () {
          return e._combineSignY;
        };
        var t = e.prototype;
        return t._initCombineSignY = function () {
          var t = this._device;
          e._combineSignY = .5 * t.capabilities.screenSpaceSignY + .5 << 1 | .5 * t.capabilities.clipSpaceSignY + .5;
        }, t.activate = function (e, t) {
          this._device = e, this._pipeline = t;
          var i = this._pipeline.descriptorSet;

          this._initCombineSignY();

          var r = e.createBuffer(new s(o.UNIFORM | o.TRANSFER_DST, h.HOST | h.DEVICE, Re.SIZE, Re.SIZE));
          i.bindBuffer(Re.BINDING, r);
          var n = e.createBuffer(new s(o.UNIFORM | o.TRANSFER_DST, h.HOST | h.DEVICE, Ie.SIZE, Ie.SIZE));
          i.bindBuffer(Ie.BINDING, n);
          var a = e.createBuffer(new s(o.UNIFORM | o.TRANSFER_DST, h.HOST | h.DEVICE, me.SIZE, me.SIZE));
          i.bindBuffer(me.BINDING, a);
        }, t.updateGlobalUBO = function (t) {
          var i = this._pipeline.globalDSManager,
              r = this._pipeline.descriptorSet,
              n = this._pipeline.commandBuffers;
          r.update(), e.updateGlobalUBOView(t, this._globalUBO), n[0].updateBuffer(r.getBuffer(Re.BINDING), this._globalUBO), i.bindBuffer(Re.BINDING, r.getBuffer(Re.BINDING)), i.update();
        }, t.updateCameraUBO = function (t) {
          var i = this._pipeline.globalDSManager,
              r = this._pipeline.descriptorSet,
              n = this._pipeline.commandBuffers;
          e.updateCameraUBOView(this._pipeline, this._cameraUBO, t), n[0].updateBuffer(r.getBuffer(Ie.BINDING), this._cameraUBO), i.bindBuffer(Ie.BINDING, r.getBuffer(Ie.BINDING)), i.update();
        }, t.updateShadowUBO = function (t) {
          var i = this._pipeline.pipelineSceneData;

          if (i.shadows.enabled) {
            var r = this._pipeline.descriptorSet,
                n = this._pipeline.commandBuffers,
                a = i.shadowFrameBufferMap,
                s = t.scene.mainLight;
            s && a.has(s) && r.bindTexture(Fe, a.get(s).colorTextures[0]), e.updateShadowUBOView(this._pipeline, this._shadowUBO, t), r.update(), n[0].updateBuffer(r.getBuffer(me.BINDING), this._shadowUBO);
          }
        }, t.updateShadowUBOLight = function (t, i) {
          e.updateShadowUBOLightView(this._pipeline, this._shadowUBO, i), t.bindTexture(Fe, Ne.get("default-texture").getGFXTexture()), t.bindTexture(De, Ne.get("default-texture").getGFXTexture()), t.update(), t.getBuffer(me.BINDING).update(this._shadowUBO);
        }, t.updateShadowUBORange = function (e, t) {
          t instanceof ce ? ce.toArray(this._shadowUBO, t, e) : t instanceof Oe && Oe.toArray(this._shadowUBO, t, e);
        }, t.destroy = function () {}, e;
      }();

      Ni._combineSignY = 0;
      var Di,
          Bi,
          Pi,
          Li,
          Ci,
          Mi,
          xi,
          zi,
          Hi,
          Gi,
          Ui,
          Wi,
          Qi,
          Vi = e("c", (ci = Pe("RenderStage"), _i = Ce(), fi = Ce(), pi = Ce(), ci((Ai = function () {
        function e() {
          v(this, "_name", mi, this), v(this, "_priority", vi, this), this._enabled = !0, v(this, "_tag", wi, this);
        }

        var t = e.prototype;
        return t.initialize = function (e) {
          return this._name = e.name, this._priority = e.priority, e.tag && (this._tag = e.tag), !0;
        }, t.activate = function (e, t) {
          this._pipeline = e, this._flow = t;
        }, d(e, [{
          key: "name",
          get: function get() {
            return this._name;
          }
        }, {
          key: "priority",
          get: function get() {
            return this._priority;
          }
        }, {
          key: "tag",
          get: function get() {
            return this._tag;
          }
        }, {
          key: "enabled",
          get: function get() {
            return this._enabled;
          },
          set: function set(e) {
            this._enabled = e;
          }
        }]), e;
      }(), mi = m((Si = Ai).prototype, "_name", [_i, Le], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return "";
        }
      }), vi = m(Si.prototype, "_priority", [fi, Le], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 0;
        }
      }), wi = m(Si.prototype, "_tag", [pi, Le], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 0;
        }
      }), gi = Si)) || gi));
      S.RenderStage = Vi;
      var qi,
          ki = e("b", (Di = Pe("RenderFlow"), Bi = Ce(), Pi = Ce(), Li = Ce(), Ci = Ce(), Mi = Me([Vi]), Di((Qi = function () {
        function e() {
          v(this, "_name", Hi, this), v(this, "_priority", Gi, this), v(this, "_tag", Ui, this), v(this, "_stages", Wi, this);
        }

        var t = e.prototype;
        return t.initialize = function (e) {
          return this._name = e.name, this._priority = e.priority, this._stages = e.stages, e.tag && (this._tag = e.tag), !0;
        }, t.activate = function (e) {
          this._pipeline = e, this._stages.sort(function (e, t) {
            return e.priority - t.priority;
          });

          for (var t = 0, i = this._stages.length; t < i; t++) {
            this._stages[t].activate(e, this);
          }
        }, t.render = function (e) {
          for (var t = 0, i = this._stages.length; t < i; t++) {
            this._stages[t].enabled && this._stages[t].render(e);
          }
        }, t.destroy = function () {
          for (var e = 0, t = this._stages.length; e < t; e++) {
            this._stages[e].destroy();
          }

          this._stages.length = 0;
        }, d(e, [{
          key: "name",
          get: function get() {
            return this._name;
          }
        }, {
          key: "priority",
          get: function get() {
            return this._priority;
          }
        }, {
          key: "tag",
          get: function get() {
            return this._tag;
          }
        }, {
          key: "stages",
          get: function get() {
            return this._stages;
          }
        }, {
          key: "pipeline",
          get: function get() {
            return this._pipeline;
          }
        }]), e;
      }(), Hi = m((zi = Qi).prototype, "_name", [Bi, Le], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return "";
        }
      }), Gi = m(zi.prototype, "_priority", [Pi, Le], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 0;
        }
      }), Ui = m(zi.prototype, "_tag", [Li, Le], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 0;
        }
      }), Wi = m(zi.prototype, "_stages", [Ci, Mi, Le], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return [];
        }
      }), xi = zi)) || xi));
      S.RenderFlow = ki, function (e) {
        e.RENDER_FRAME_BEGIN = "render-frame-begin", e.RENDER_FRAME_END = "render-frame-end", e.RENDER_CAMERA_BEGIN = "render-camera-begin", e.RENDER_CAMERA_END = "render-camera-end", e.ATTACHMENT_SCALE_CAHNGED = "attachment-scale-changed";
      }(qi || (qi = e("j", {})));

      var Xi,
          Yi,
          Ki,
          Zi,
          Ji,
          ji,
          $i,
          er,
          tr,
          ir,
          rr,
          nr,
          ar,
          sr,
          or,
          hr,
          dr,
          ur,
          lr,
          cr,
          _r,
          fr,
          pr,
          gr,
          Sr,
          mr,
          vr,
          wr,
          Ar,
          Er,
          Tr,
          Or,
          yr,
          br,
          Rr,
          Ir,
          Fr,
          Nr,
          Dr,
          Br,
          Pr,
          Lr,
          Cr,
          Mr,
          xr,
          zr,
          Hr,
          Gr,
          Ur,
          Wr,
          Qr,
          Vr,
          qr,
          kr,
          Xr,
          Yr,
          Kr,
          Zr,
          Jr,
          jr,
          $r,
          en,
          tn,
          rn,
          nn,
          an,
          sn,
          on,
          hn,
          dn,
          un,
          ln,
          cn,
          _n,
          fn,
          pn,
          gn,
          Sn,
          mn,
          vn,
          wn,
          An,
          En,
          Tn,
          On,
          yn,
          bn,
          Rn,
          In,
          Fn,
          Nn,
          Dn,
          Bn,
          Pn = e("i", function (e) {
        function t() {
          for (var t, i = arguments.length, r = new Array(i), n = 0; n < i; n++) {
            r[n] = arguments[n];
          }

          return (t = e.call.apply(e, [this].concat(r)) || this).eventTargetOn = e.prototype.on, t.eventTargetOnce = e.prototype.once, t;
        }

        w(t, e);
        var i = t.prototype;
        return i.on = function (e, t, i, r) {
          return this.eventTargetOn(e, t, i, r);
        }, i.once = function (e, t, i) {
          return this.eventTargetOnce(e, t, i);
        }, t;
      }(A)),
          Ln = new G(),
          Cn = new U(),
          Mn = function Mn() {
        this.renderPass = null, this.sampler = null, this.prefiterTex = null, this.downsampleTexs = [], this.upsampleTexs = [], this.combineTex = null, this.prefilterFramebuffer = null, this.downsampleFramebuffers = [], this.upsampleFramebuffers = [], this.combineFramebuffer = null;
      },
          xn = function xn() {
        this.quadIB = null, this.quadVB = null, this.quadIA = null;
      },
          zn = e("a", (Xi = Pe("cc.RenderPipeline"), Yi = Ce(), Ki = Ce(), Zi = Me([ki]), Xi((tr = function (e) {
        function t() {
          for (var t, i = arguments.length, r = new Array(i), n = 0; n < i; n++) {
            r[n] = arguments[n];
          }

          return t = e.call.apply(e, [this].concat(r)) || this, v(t, "_tag", $i, W(t)), v(t, "_flows", er, W(t)), t._quadIB = null, t._quadVBOnscreen = null, t._quadVBOffscreen = null, t._quadIAOnscreen = null, t._quadIAOffscreen = null, t._eventProcessor = new Pn(), t._commandBuffers = [], t._pipelineUBO = new Ni(), t._macros = {}, t._constantMacros = "", t._profiler = null, t._geometryRenderer = new Oi(), t._pipelineRenderData = null, t._renderPasses = new Map(), t._width = 0, t._height = 0, t._lastUsedRenderArea = new G(), t._clusterEnabled = !1, t._bloomEnabled = !1, t;
        }

        w(t, e);
        var i = t.prototype;
        return i.getPipelineRenderData = function () {
          return this._pipelineRenderData;
        }, i.initialize = function (e) {
          return this._flows = e.flows, e.tag && (this._tag = e.tag), !0;
        }, i.createRenderPass = function (e, t, i) {
          var r = this._device,
              n = new E(),
              a = new T();
          n.format = t, a.format = i, a.stencilStoreOp = O.DISCARD, a.depthStoreOp = O.DISCARD, e & y.COLOR || (e & pt ? n.loadOp = b.DISCARD : (n.loadOp = b.LOAD, n.barrier = r.getGeneralBarrier(new R(I.COLOR_ATTACHMENT_WRITE, I.COLOR_ATTACHMENT_WRITE)))), (e & y.DEPTH_STENCIL) !== y.DEPTH_STENCIL && (e & y.DEPTH || (a.depthLoadOp = b.LOAD), e & y.STENCIL || (a.stencilLoadOp = b.LOAD)), a.barrier = r.getGeneralBarrier(new R(I.DEPTH_STENCIL_ATTACHMENT_WRITE, I.DEPTH_STENCIL_ATTACHMENT_WRITE));
          var s = new F([n], a);
          return r.createRenderPass(s);
        }, i.getRenderPass = function (e, t) {
          var i = this._renderPasses.get(e);

          return i || (i = this.createRenderPass(e, t.colorTextures[0].format, t.depthStencilTexture.format), this._renderPasses.set(e, i), i);
        }, i.applyFramebufferRatio = function (e) {
          for (var t = this.pipelineSceneData, i = this._width * t.shadingScale, r = this._height * t.shadingScale, n = e.colorTextures, a = 0; a < n.length; a++) {
            n[a].resize(i, r);
          }

          e.depthStencilTexture && e.depthStencilTexture.resize(i, r), e.destroy(), e.initialize(new N(e.renderPass, n, e.depthStencilTexture));
        }, i.generateRenderArea = function (e, t) {
          var i = e.viewport,
              r = e.window.width,
              n = e.window.height;
          t.x = i.x * r, t.y = i.y * n, t.width = i.width * r, t.height = i.height * n;
        }, i.generateViewport = function (e, t) {
          this.generateRenderArea(e, Ln), t || (t = Cn);
          var i = this.pipelineSceneData.shadingScale;
          return t.left = Ln.x * i, t.top = Ln.y * i, t.width = Ln.width * i, t.height = Ln.height * i, t;
        }, i.generateScissor = function (e, t) {
          t || (t = Ln), this.generateRenderArea(e, t);
          var i = this.pipelineSceneData.shadingScale;
          return t.x *= i, t.y *= i, t.width *= i, t.height *= i, t;
        }, i.activate = function () {
          var e = S.director.root;
          this._device = e.device, this._generateConstantMacros(), this._globalDSManager = new ti(this), this._descriptorSet = this._globalDSManager.globalDescriptorSet, this._pipelineUBO.activate(this._device, this), this._macros.CC_USE_HDR = this._pipelineSceneData.isHDR, this._generateConstantMacros(), this._pipelineSceneData.activate(this._device, this), this._geometryRenderer.activate(this._device, this);

          for (var t = 0; t < this._flows.length; t++) {
            this._flows[t].activate(this);
          }

          return !0;
        }, i._ensureEnoughSize = function () {}, i.render = function (e) {
          if (0 !== e.length) {
            this._commandBuffers[0].begin(), this.emit(qi.RENDER_FRAME_BEGIN, e), this._ensureEnoughSize(e), xe(e);

            for (var t = 0; t < e.length; t++) {
              var i = e[t];

              if (i.scene) {
                this.emit(qi.RENDER_CAMERA_BEGIN, i), Zt(this, i), Jt(this, i), this._pipelineUBO.updateGlobalUBO(i.window), this._pipelineUBO.updateCameraUBO(i);

                for (var r = 0; r < this._flows.length; r++) {
                  this._flows[r].render(i);
                }

                this.emit(qi.RENDER_CAMERA_END, i);
              }
            }

            this.emit(qi.RENDER_FRAME_END, e), this._commandBuffers[0].end(), this._device.queue.submit(this._commandBuffers);
          }
        }, i._destroyQuadInputAssembler = function () {
          this._quadIB && (this._quadIB.destroy(), this._quadIB = null), this._quadVBOnscreen && (this._quadVBOnscreen.destroy(), this._quadVBOnscreen = null), this._quadVBOffscreen && (this._quadVBOffscreen.destroy(), this._quadVBOffscreen = null), this._quadIAOnscreen && (this._quadIAOnscreen.destroy(), this._quadIAOnscreen = null), this._quadIAOffscreen && (this._quadIAOffscreen.destroy(), this._quadIAOffscreen = null);
        }, i._destroyBloomData = function () {
          var e,
              t = this._pipelineRenderData.bloom;

          if (null !== t) {
            t.prefiterTex && t.prefiterTex.destroy(), t.prefilterFramebuffer && t.prefilterFramebuffer.destroy();

            for (var i = 0; i < t.downsampleTexs.length; ++i) {
              t.downsampleTexs[i].destroy(), t.downsampleFramebuffers[i].destroy();
            }

            t.downsampleTexs.length = 0, t.downsampleFramebuffers.length = 0;

            for (var r = 0; r < t.upsampleTexs.length; ++r) {
              t.upsampleTexs[r].destroy(), t.upsampleFramebuffers[r].destroy();
            }

            t.upsampleTexs.length = 0, t.upsampleFramebuffers.length = 0, t.combineTex && t.combineTex.destroy(), t.combineFramebuffer && t.combineFramebuffer.destroy(), null === (e = t.renderPass) || void 0 === e || e.destroy(), this._pipelineRenderData.bloom = null;
          }
        }, i._genQuadVertexData = function (e, t) {
          var i = new Float32Array(16),
              r = t.x / this._width,
              n = (t.x + t.width) / this._width,
              a = t.y / this._height,
              s = (t.y + t.height) / this._height;

          if (this.device.capabilities.screenSpaceSignY > 0) {
            var o = s;
            s = a, a = o;
          }

          var h = 0;

          switch (e) {
            case D.IDENTITY:
              h = 0, i[h++] = -1, i[h++] = -1, i[h++] = r, i[h++] = s, i[h++] = 1, i[h++] = -1, i[h++] = n, i[h++] = s, i[h++] = -1, i[h++] = 1, i[h++] = r, i[h++] = a, i[h++] = 1, i[h++] = 1, i[h++] = n, i[h++] = a;
              break;

            case D.ROTATE_90:
              h = 0, i[h++] = -1, i[h++] = -1, i[h++] = n, i[h++] = s, i[h++] = 1, i[h++] = -1, i[h++] = n, i[h++] = a, i[h++] = -1, i[h++] = 1, i[h++] = r, i[h++] = s, i[h++] = 1, i[h++] = 1, i[h++] = r, i[h++] = a;
              break;

            case D.ROTATE_180:
              h = 0, i[h++] = -1, i[h++] = -1, i[h++] = r, i[h++] = a, i[h++] = 1, i[h++] = -1, i[h++] = n, i[h++] = a, i[h++] = -1, i[h++] = 1, i[h++] = r, i[h++] = s, i[h++] = 1, i[h++] = 1, i[h++] = n, i[h++] = s;
              break;

            case D.ROTATE_270:
              h = 0, i[h++] = -1, i[h++] = -1, i[h++] = r, i[h++] = a, i[h++] = 1, i[h++] = -1, i[h++] = r, i[h++] = s, i[h++] = -1, i[h++] = 1, i[h++] = n, i[h++] = a, i[h++] = 1, i[h++] = 1, i[h++] = n, i[h++] = s;
          }

          return i;
        }, i._createQuadInputAssembler = function () {
          var e = new xn(),
              t = 4 * Float32Array.BYTES_PER_ELEMENT,
              i = 4 * t,
              r = this._device.createBuffer(new s(o.VERTEX | o.TRANSFER_DST, h.DEVICE | h.HOST, i, t));

          if (!r) return e;

          var n = Uint8Array.BYTES_PER_ELEMENT,
              a = 6 * n,
              d = this._device.createBuffer(new s(o.INDEX | o.TRANSFER_DST, h.DEVICE, a, n));

          if (!d) return e;
          var u = new Uint8Array(6);
          u[0] = 0, u[1] = 1, u[2] = 2, u[3] = 1, u[4] = 3, u[5] = 2, d.update(u);
          var c = new Array(2);
          c[0] = new l("a_position", _.RG32F), c[1] = new l("a_texCoord", _.RG32F);

          var f = this._device.createInputAssembler(new g(c, [r], d));

          return e.quadIB = d, e.quadVB = r, e.quadIA = f, e;
        }, i.updateQuadVertexData = function (e, t) {
          var i = this._lastUsedRenderArea;

          if (i.x !== e.x || i.y !== e.y || i.width !== e.width || i.height !== e.height) {
            var r = this._genQuadVertexData(D.IDENTITY, e);

            this._quadVBOffscreen.update(r);

            var n = this._genQuadVertexData(t.swapchain && t.swapchain.surfaceTransform || D.IDENTITY, e);

            this._quadVBOnscreen.update(n), i.copy(e);
          }
        }, i.destroy = function () {
          for (var t, i, r = 0; r < this._flows.length; r++) {
            this._flows[r].destroy();
          }

          this._flows.length = 0, this._descriptorSet && this._descriptorSet.destroy(), null === (t = this._globalDSManager) || void 0 === t || t.destroy();

          for (var n = 0; n < this._commandBuffers.length; n++) {
            this._commandBuffers[n].destroy();
          }

          return this._commandBuffers.length = 0, this._pipelineUBO.destroy(), null === (i = this._pipelineSceneData) || void 0 === i || i.destroy(), this._geometryRenderer.destroy(), e.prototype.destroy.call(this);
        }, i._generateConstantMacros = function () {
          var e = "";
          e += "#define CC_DEVICE_SUPPORT_FLOAT_TEXTURE " + (this.device.getFormatFeatures(_.RGBA32F) & (B.RENDER_TARGET | B.SAMPLED_TEXTURE) ? 1 : 0) + "\n", e += "#define CC_ENABLE_CLUSTERED_LIGHT_CULLING " + (this._clusterEnabled ? 1 : 0) + "\n", e += "#define CC_DEVICE_MAX_VERTEX_UNIFORM_VECTORS " + this.device.capabilities.maxVertexUniformVectors + "\n", e += "#define CC_DEVICE_MAX_FRAGMENT_UNIFORM_VECTORS " + this.device.capabilities.maxFragmentUniformVectors + "\n", e += "#define CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT " + (this.device.hasFeature(P.INPUT_ATTACHMENT_BENEFIT) ? 1 : 0) + "\n", e += "#define CC_PLATFORM_ANDROID_AND_WEBGL " + (L.os === C.ANDROID && L.isBrowser ? 1 : 0) + "\n", e += "#define CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES " + (M.ENABLE_WEBGL_HIGHP_STRUCT_VALUES ? 1 : 0) + "\n", this._constantMacros = e;
        }, i.generateBloomRenderData = function () {
          if (null == this._pipelineRenderData.bloom) {
            var e = this._pipelineRenderData.bloom = new Mn(),
                t = this.device,
                i = new E();
            i.format = _.RGBA8, i.loadOp = b.CLEAR, i.storeOp = O.STORE, i.barrier = t.getGeneralBarrier(new R(I.NONE, I.COLOR_ATTACHMENT_WRITE)), e.renderPass = t.createRenderPass(new F([i]));
            var r = this._width,
                n = this._height;
            e.prefiterTex = t.createTexture(new x(z.TEX2D, H.COLOR_ATTACHMENT | H.SAMPLED, _.RGBA8, r >> 1, n >> 1)), e.prefilterFramebuffer = t.createFramebuffer(new N(e.renderPass, [e.prefiterTex])), r >>= 1, n >>= 1;

            for (var a = 0; a < 6; ++a) {
              e.downsampleTexs.push(t.createTexture(new x(z.TEX2D, H.COLOR_ATTACHMENT | H.SAMPLED, _.RGBA8, r >> 1, n >> 1))), e.downsampleFramebuffers[a] = t.createFramebuffer(new N(e.renderPass, [e.downsampleTexs[a]])), e.upsampleTexs.push(t.createTexture(new x(z.TEX2D, H.COLOR_ATTACHMENT | H.SAMPLED, _.RGBA8, r, n))), e.upsampleFramebuffers[a] = t.createFramebuffer(new N(e.renderPass, [e.upsampleTexs[a]])), r >>= 1, n >>= 1;
            }

            e.combineTex = t.createTexture(new x(z.TEX2D, H.COLOR_ATTACHMENT | H.SAMPLED, _.RGBA8, this._width, this._height)), e.combineFramebuffer = t.createFramebuffer(new N(e.renderPass, [e.combineTex])), e.sampler = this.globalDSManager.linearSampler;
          }
        }, i.on = function (e, t, i, r) {
          return this._eventProcessor.on(e, t, i, r);
        }, i.once = function (e, t, i) {
          return this._eventProcessor.once(e, t, i);
        }, i.off = function (e, t, i) {
          this._eventProcessor.off(e, t, i);
        }, i.emit = function (e, t, i, r, n, a) {
          this._eventProcessor.emit(e, t, i, r, n, a);
        }, i.targetOff = function (e) {
          this._eventProcessor.targetOff(e);
        }, i.removeAll = function (e) {
          this._eventProcessor.removeAll(e);
        }, i.hasEventListener = function (e, t, i) {
          return this._eventProcessor.hasEventListener(e, t, i);
        }, d(t, [{
          key: "tag",
          get: function get() {
            return this._tag;
          }
        }, {
          key: "flows",
          get: function get() {
            return this._flows;
          }
        }, {
          key: "quadIAOnscreen",
          get: function get() {
            return this._quadIAOnscreen;
          }
        }, {
          key: "quadIAOffscreen",
          get: function get() {
            return this._quadIAOffscreen;
          }
        }, {
          key: "constantMacros",
          get: function get() {
            return this._constantMacros;
          }
        }, {
          key: "macros",
          get: function get() {
            return this._macros;
          }
        }, {
          key: "device",
          get: function get() {
            return this._device;
          }
        }, {
          key: "globalDSManager",
          get: function get() {
            return this._globalDSManager;
          }
        }, {
          key: "descriptorSetLayout",
          get: function get() {
            return this._globalDSManager.descriptorSetLayout;
          }
        }, {
          key: "descriptorSet",
          get: function get() {
            return this._descriptorSet;
          }
        }, {
          key: "commandBuffers",
          get: function get() {
            return this._commandBuffers;
          }
        }, {
          key: "pipelineUBO",
          get: function get() {
            return this._pipelineUBO;
          }
        }, {
          key: "pipelineSceneData",
          get: function get() {
            return this._pipelineSceneData;
          }
        }, {
          key: "profiler",
          get: function get() {
            return this._profiler;
          },
          set: function set(e) {
            this._profiler = e;
          }
        }, {
          key: "geometryRenderer",
          get: function get() {
            return this._geometryRenderer;
          }
        }, {
          key: "clusterEnabled",
          get: function get() {
            return this._clusterEnabled;
          },
          set: function set(e) {
            this._clusterEnabled = e;
          }
        }, {
          key: "bloomEnabled",
          get: function get() {
            return this._bloomEnabled;
          },
          set: function set(e) {
            this._bloomEnabled = e;
          }
        }]), t;
      }(ze), $i = m((ji = tr).prototype, "_tag", [Yi, Le], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 0;
        }
      }), er = m(ji.prototype, "_flows", [Ki, Zi, Le], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return [];
        }
      }), Ji = ji)) || Ji));

      S.RenderPipeline = zn, function (e) {
        e[e.BLOOM = 18] = "BLOOM", e[e.POST_PROCESS = 19] = "POST_PROCESS", e[e.UI = 20] = "UI";
      }(ir || (ir = {})), function (e) {
        e[e.FORWARD = 10] = "FORWARD";
      }(rr || (rr = {})), function (e) {
        e[e.SHADOW = 0] = "SHADOW", e[e.FORWARD = 1] = "FORWARD", e[e.UI = 10] = "UI";
      }(nr || (nr = {})), function (e) {
        e[e.GBUFFER = 10] = "GBUFFER", e[e.LIGHTING = 15] = "LIGHTING", e[e.TRANSPARENT = 18] = "TRANSPARENT";
      }(ar || (ar = {})), function (e) {
        e[e.SHADOW = 0] = "SHADOW", e[e.MAIN = 1] = "MAIN", e[e.UI = 10] = "UI";
      }(sr || (sr = {})), Q(z), Q(H), Q(O), Q(b), Q(I), function (e) {
        e[e.SCENE = 0] = "SCENE", e[e.POSTPROCESS = 1] = "POSTPROCESS", e[e.UI = 2] = "UI";
      }(Bn || (Bn = {})), Q(Bn), or = Pe("RenderTextureDesc"), hr = Me(z), dr = Me(H), ur = Me(_), or((cr = m((lr = function lr() {
        v(this, "name", cr, this), v(this, "type", _r, this), v(this, "usage", fr, this), v(this, "format", pr, this), v(this, "width", gr, this), v(this, "height", Sr, this);
      }).prototype, "name", [Le, Ue], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return "";
        }
      }), _r = m(lr.prototype, "type", [hr], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return z.TEX2D;
        }
      }), fr = m(lr.prototype, "usage", [dr], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return H.COLOR_ATTACHMENT;
        }
      }), pr = m(lr.prototype, "format", [ur], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return _.UNKNOWN;
        }
      }), gr = m(lr.prototype, "width", [Le, Ue], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return -1;
        }
      }), Sr = m(lr.prototype, "height", [Le, Ue], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return -1;
        }
      }), lr));
      var Hn,
          Gn = (mr = Pe("RenderTextureConfig"), vr = Me(He), mr((Er = m((Ar = function Ar() {
        v(this, "name", Er, this), v(this, "texture", Tr, this);
      }).prototype, "name", [Le, Ue], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return "";
        }
      }), Tr = m(Ar.prototype, "texture", [vr], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return null;
        }
      }), wr = Ar)) || wr),
          Un = (Or = Pe("MaterialConfig"), yr = Me(Ge), Or((Rr = m((br = function br() {
        v(this, "name", Rr, this), v(this, "material", Ir, this);
      }).prototype, "name", [Le, Ue], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return "";
        }
      }), Ir = m(br.prototype, "material", [yr], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return null;
        }
      }), br)), Fr = Pe("FrameBufferDesc"), Nr = Me([V]), Dr = Me(He), Fr((Pr = m((Br = function Br() {
        v(this, "name", Pr, this), v(this, "renderPass", Lr, this), v(this, "colorTextures", Cr, this), v(this, "depthStencilTexture", Mr, this), v(this, "texture", xr, this);
      }).prototype, "name", [Le, Ue], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return "";
        }
      }), Lr = m(Br.prototype, "renderPass", [Le, Ue], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 0;
        }
      }), Cr = m(Br.prototype, "colorTextures", [Nr], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return [];
        }
      }), Mr = m(Br.prototype, "depthStencilTexture", [Le, Ue], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return "";
        }
      }), xr = m(Br.prototype, "texture", [Dr], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return null;
        }
      }), Br)), zr = Pe("ColorDesc"), Hr = Me(_), Gr = Me(b), Ur = Me(O), Wr = Me([I]), Qr = Me([I]), zr((kr = m((qr = function qr() {
        v(this, "format", kr, this), v(this, "loadOp", Xr, this), v(this, "storeOp", Yr, this), v(this, "sampleCount", Kr, this), v(this, "beginAccesses", Zr, this), v(this, "endAccesses", Jr, this);
      }).prototype, "format", [Hr], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return _.UNKNOWN;
        }
      }), Xr = m(qr.prototype, "loadOp", [Gr], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return b.CLEAR;
        }
      }), Yr = m(qr.prototype, "storeOp", [Ur], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return O.STORE;
        }
      }), Kr = m(qr.prototype, "sampleCount", [Le, Ue], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 1;
        }
      }), Zr = m(qr.prototype, "beginAccesses", [Wr], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return I.NONE;
        }
      }), Jr = m(qr.prototype, "endAccesses", [Qr], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return I.COLOR_ATTACHMENT_WRITE;
        }
      }), Vr = qr)) || Vr),
          Wn = (jr = Pe("DepthStencilDesc"), $r = Me(_), en = Me(b), tn = Me(O), rn = Me(b), nn = Me(O), an = Me(I), sn = Me(I), jr((dn = m((hn = function hn() {
        v(this, "format", dn, this), v(this, "depthLoadOp", un, this), v(this, "depthStoreOp", ln, this), v(this, "stencilLoadOp", cn, this), v(this, "stencilStoreOp", _n, this), v(this, "sampleCount", fn, this), v(this, "beginAccesses", pn, this), v(this, "endAccesses", gn, this);
      }).prototype, "format", [$r], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return _.UNKNOWN;
        }
      }), un = m(hn.prototype, "depthLoadOp", [en], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return b.CLEAR;
        }
      }), ln = m(hn.prototype, "depthStoreOp", [tn], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return O.STORE;
        }
      }), cn = m(hn.prototype, "stencilLoadOp", [rn], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return b.CLEAR;
        }
      }), _n = m(hn.prototype, "stencilStoreOp", [nn], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return O.STORE;
        }
      }), fn = m(hn.prototype, "sampleCount", [Le, Ue], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 1;
        }
      }), pn = m(hn.prototype, "beginAccesses", [an], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return I.NONE;
        }
      }), gn = m(hn.prototype, "endAccesses", [sn], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return I.DEPTH_STENCIL_ATTACHMENT_WRITE;
        }
      }), on = hn)) || on);
      Sn = Pe("RenderPassDesc"), mn = Me([Un]), vn = Me(Wn), Sn((An = m((wn = function wn() {
        v(this, "index", An, this), v(this, "colorAttachments", En, this), v(this, "depthStencilAttachment", Tn, this);
      }).prototype, "index", [Le, Ue], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return -1;
        }
      }), En = m(wn.prototype, "colorAttachments", [mn], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return [];
        }
      }), Tn = m(wn.prototype, "depthStencilAttachment", [vn], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return new Wn();
        }
      }), wn)), function (e) {
        e[e.FRONT_TO_BACK = 0] = "FRONT_TO_BACK", e[e.BACK_TO_FRONT = 1] = "BACK_TO_FRONT";
      }(Hn || (Hn = {})), Q(Hn);
      var Qn = (On = Pe("RenderQueueDesc"), yn = Me(Hn), bn = Me([V]), On((Fn = m((In = function In() {
        v(this, "isTransparent", Fn, this), v(this, "sortMode", Nn, this), v(this, "stages", Dn, this);
      }).prototype, "isTransparent", [Le, Ue], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !1;
        }
      }), Nn = m(In.prototype, "sortMode", [yn], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return Hn.FRONT_TO_BACK;
        }
      }), Dn = m(In.prototype, "stages", [bn], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return [];
        }
      }), Rn = In)) || Rn);

      function Vn(e, t) {
        return e.hash - t.hash || e.depth - t.depth || e.shaderId - t.shaderId;
      }

      function qn(e, t) {
        return e.hash - t.hash || t.depth - e.depth || e.shaderId - t.shaderId;
      }

      var kn = function () {
        function e(e) {
          this.queue = void 0, this._passDesc = void 0, this._passPool = void 0, this._passDesc = e, this._passPool = new q(function () {
            return {
              hash: 0,
              depth: 0,
              shaderId: 0,
              subModel: null,
              passIdx: 0
            };
          }, 64), this.queue = new k(64, this._passDesc.sortFunc);
        }

        var t = e.prototype;
        return t.clear = function () {
          this.queue.clear(), this._passPool.reset();
        }, t.insertRenderPass = function (e, t, i) {
          var r = e.model.subModels[t],
              n = r.passes[i],
              a = r.shaders[i];
          if (n.blendState.targets[0].blend !== this._passDesc.isTransparent || !(n.phase & this._passDesc.phases)) return !1;

          var s = 0 | n.priority << 16 | r.priority << 8 | i,
              o = this._passPool.add();

          return o.hash = s, o.depth = e.depth || 0, o.shaderId = a.typedID, o.subModel = r, o.passIdx = i, this.queue.push(o), !0;
        }, t.sort = function () {
          this.queue.sort();
        }, t.recordCommandBuffer = function (e, t, i) {
          for (var r = 0; r < this.queue.length; ++r) {
            var n = this.queue.array[r],
                a = n.subModel,
                s = n.passIdx,
                o = a.inputAssembler,
                h = a.passes[s],
                d = a.shaders[s],
                u = Ee.getOrCreatePipelineState(e, h, d, t, o);
            i.bindPipelineState(u), i.bindDescriptorSet(Te.MATERIAL, h.descriptorSet), i.bindDescriptorSet(Te.LOCAL, a.descriptorSet), i.bindInputAssembler(o), i.draw(o);
          }
        }, e;
      }();

      function Xn(e) {
        for (var t = 0, i = 0; i < e.stages.length; i++) {
          t |= We(e.stages[i]);
        }

        var r = Vn;

        switch (e.sortMode) {
          case Hn.BACK_TO_FRONT:
            r = qn;
            break;

          case Hn.FRONT_TO_BACK:
            r = Vn;
        }

        return new kn({
          isTransparent: e.isTransparent,
          phases: t,
          sortFunc: r
        });
      }

      function Yn(e) {
        e.clear();
      }

      function Kn(e) {
        e.sort();
      }

      var Zn = function () {
        function e() {
          this.queue = new Set();
        }

        var t = e.prototype;
        return t.clear = function () {
          for (var e = this.queue.values(), t = e.next(); !t.done;) {
            t.value.clear(), t = e.next();
          }

          this.queue.clear();
        }, t.uploadBuffers = function (e) {
          for (var t = this.queue.values(), i = t.next(); !i.done;) {
            for (var r = 0; r < i.value.batches.length; ++r) {
              var n = i.value.batches[r];

              if (n.mergeCount) {
                for (var a = 0; a < n.vbs.length; ++a) {
                  n.vbs[a].update(n.vbDatas[a]);
                }

                e.updateBuffer(n.vbIdx, n.vbIdxData.buffer), e.updateBuffer(n.ubo, n.uboData);
              }
            }

            i = t.next();
          }
        }, t.recordCommandBuffer = function (e, t, i, r) {
          void 0 === r && (r = null);

          for (var n = this.queue.values(), a = n.next(); !a.done;) {
            for (var s = !1, o = 0; o < a.value.batches.length; ++o) {
              var h = a.value.batches[o];

              if (h.mergeCount) {
                if (!s) {
                  var d = h.shader,
                      u = Ee.getOrCreatePipelineState(e, h.pass, d, t, h.ia);
                  i.bindPipelineState(u), i.bindDescriptorSet(Te.MATERIAL, h.pass.descriptorSet), s = !0;
                }

                r && i.bindDescriptorSet(Te.GLOBAL, r), i.bindDescriptorSet(Te.LOCAL, h.descriptorSet, a.value.dynamicOffsets), i.bindInputAssembler(h.ia), i.draw(h.ia);
              }
            }

            a = n.next();
          }
        }, e;
      }(),
          Jn = function () {
        function e() {
          this.queue = new Set();
        }

        var t = e.prototype;
        return t.clear = function () {
          for (var e = this.queue.values(), t = e.next(); !t.done;) {
            t.value.clear(), t = e.next();
          }

          this.queue.clear();
        }, t.uploadBuffers = function (e) {
          for (var t = this.queue.values(), i = t.next(); !i.done;) {
            i.value.hasPendingModels && i.value.uploadBuffers(e), i = t.next();
          }
        }, t.recordCommandBuffer = function (e, t, i, r) {
          void 0 === r && (r = null);

          for (var n = this.queue.values(), a = n.next(); !a.done;) {
            var s = a.value,
                o = s.instances,
                h = s.pass;

            if (s.hasPendingModels) {
              i.bindDescriptorSet(Te.MATERIAL, h.descriptorSet);

              for (var d = null, u = 0; u < o.length; ++u) {
                var l = o[u];

                if (l.count) {
                  var c = l.shader,
                      _ = Ee.getOrCreatePipelineState(e, h, c, t, l.ia);

                  d !== _ && (i.bindPipelineState(_), d = _), r && i.bindDescriptorSet(Te.GLOBAL, r), i.bindDescriptorSet(Te.LOCAL, l.descriptorSet, a.value.dynamicOffsets), i.bindInputAssembler(l.ia), i.draw(l.ia);
                }
              }
            }

            a = n.next();
          }
        }, e;
      }(),
          jn = new t(function () {
        return {
          subModel: null,
          passIdx: -1,
          dynamicOffsets: [],
          lights: []
        };
      }, 16),
          $n = new Float32Array(4),
          ea = [],
          ta = [],
          ia = new ce(),
          ra = new ce();

      function na(e, t) {
        return !(!t.worldBounds || Se.aabbWithAABB(t.worldBounds, e.aabb));
      }

      function aa(e, t) {
        return !(!t.worldBounds || Se.aabbWithAABB(t.worldBounds, e.aabb) && Se.aabbFrustum(t.worldBounds, e.frustum));
      }

      var sa = We("forward-add"),
          oa = [];

      function ha(e, t) {
        t.length = 0;

        for (var i = !1, r = 0; r < e.length; r++) {
          for (var n = e[r].passes, a = -1, s = 0; s < n.length; s++) {
            if (n[s].phase === sa) {
              a = s, i = !0;
              break;
            }
          }

          t.push(a);
        }

        return i;
      }

      var da,
          ua,
          la,
          ca,
          _a,
          fa,
          pa,
          ga,
          Sa,
          ma,
          va,
          wa = function () {
        function e(e) {
          this._pipeline = void 0, this._device = void 0, this._lightPasses = [], this._shadowUBO = new Float32Array(me.COUNT), this._lightBufferCount = 16, this._lightBufferStride = void 0, this._lightBufferElementCount = void 0, this._lightBuffer = void 0, this._firstLightBufferView = void 0, this._lightBufferData = void 0, this._instancedQueue = void 0, this._batchedQueue = void 0, this._lightMeterScale = 1e4, this._pipeline = e, this._device = e.device, this._instancedQueue = new Jn(), this._batchedQueue = new Zn();
          var t = this._device.capabilities.uboOffsetAlignment;
          this._lightBufferStride = Math.ceil(Qe.SIZE / t) * t, this._lightBufferElementCount = this._lightBufferStride / Float32Array.BYTES_PER_ELEMENT, this._lightBuffer = this._device.createBuffer(new s(o.UNIFORM | o.TRANSFER_DST, h.HOST | h.DEVICE, this._lightBufferStride * this._lightBufferCount, this._lightBufferStride)), this._firstLightBufferView = this._device.createBuffer(new X(this._lightBuffer, 0, Qe.SIZE)), this._lightBufferData = new Float32Array(this._lightBufferElementCount * this._lightBufferCount);
        }

        var t = e.prototype;
        return t.clear = function () {
          this._instancedQueue.clear(), this._batchedQueue.clear();

          for (var e = 0; e < this._lightPasses.length; e++) {
            var t = this._lightPasses[e];
            t.dynamicOffsets.length = 0, t.lights.length = 0;
          }

          jn.freeArray(this._lightPasses), this._lightPasses.length = 0;
        }, t.destroy = function () {
          for (var e = this._pipeline.globalDSManager.descriptorSetMap, t = e.keys, i = 0; i < t.length; i++) {
            var r = t[i],
                n = e.get(r);
            n && (n.getBuffer(me.BINDING).destroy(), n.getTexture(Fe).destroy(), n.getTexture(De).destroy(), n.destroy()), e.delete(r);
          }
        }, t.gatherLightPasses = function (e, t) {
          this.clear();
          var i = this._pipeline.pipelineSceneData.validPunctualLights;

          if (i.length) {
            this._updateUBOs(e, t), this._updateLightDescriptorSet(e, t);

            for (var r = this._pipeline.pipelineSceneData.renderObjects, n = 0; n < r.length; n++) {
              var a = r[n].model,
                  s = a.subModels;
              if (ha(s, oa) && (ta.length = 0, this._lightCulling(a, i), ta.length)) for (var o = 0; o < s.length; o++) {
                var h = oa[o];

                if (!(h < 0)) {
                  var d = s[o],
                      u = d.passes[h];
                  d.passes[0].blendState.targets[0].blend || (d.descriptorSet.bindBuffer(Qe.BINDING, this._firstLightBufferView), d.descriptorSet.update(), this._addRenderQueue(u, d, a, h));
                }
              }
            }

            this._instancedQueue.uploadBuffers(t), this._batchedQueue.uploadBuffers(t);
          }
        }, t.recordCommandBuffer = function (e, t, i) {
          for (var r = this._pipeline.globalDSManager, n = 0; n < ta.length; n++) {
            var a = ta[n],
                s = r.getOrCreateDescriptorSet(a);
            this._instancedQueue.recordCommandBuffer(e, t, i, s), this._batchedQueue.recordCommandBuffer(e, t, i, s);
          }

          for (var o = 0; o < this._lightPasses.length; o++) {
            var h = this._lightPasses[o],
                d = h.subModel,
                u = h.passIdx,
                l = h.dynamicOffsets,
                c = h.lights,
                _ = d.passes[u],
                f = d.shaders[u],
                p = d.inputAssembler,
                g = Ee.getOrCreatePipelineState(e, _, f, t, p),
                S = _.descriptorSet,
                m = d.descriptorSet;
            i.bindPipelineState(g), i.bindDescriptorSet(Te.MATERIAL, S), i.bindInputAssembler(p);

            for (var v = 0; v < l.length; ++v) {
              var w = c[v],
                  A = r.getOrCreateDescriptorSet(w);
              ea[0] = l[v], i.bindDescriptorSet(Te.GLOBAL, A), i.bindDescriptorSet(Te.LOCAL, m, ea), i.draw(p);
            }
          }
        }, t._lightCulling = function (e, t) {
          for (var i = !1, r = !function (e) {
            for (var t = e.subModels, i = 0; i < t.length; ++i) {
              for (var r = t[i].passes, n = 0; n < r.length; ++n) {
                var a = r[n].batchingScheme;
                if (a === Ve.INSTANCING) return !0;
                if (a === Ve.VB_MERGING) return !0;
              }
            }

            return !1;
          }(e), n = 0; n < t.length; n++) {
            var a = t[n];

            switch (a.type) {
              case St.SPHERE:
                r && (i = na(a, e));
                break;

              case St.SPOT:
                r && (i = aa(a, e));
            }

            i || ta.push(n);
          }
        }, t._addRenderQueue = function (e, t, i, r) {
          var n = e.batchingScheme;
          if (n === Ve.INSTANCING) for (var a = 0; a < ta.length; a++) {
            var s = ta[a],
                o = e.getInstancedBuffer(s);
            o.merge(t, i.instancedAttributes, r), o.dynamicOffsets[0] = this._lightBufferStride * s, this._instancedQueue.queue.add(o);
          } else if (n === Ve.VB_MERGING) for (var h = 0; h < ta.length; h++) {
            var d = ta[h],
                u = e.getBatchedBuffer(d);
            u.merge(t, r, i), u.dynamicOffsets[0] = this._lightBufferStride * d, this._batchedQueue.queue.add(u);
          } else {
            var l = jn.alloc();
            l.subModel = t, l.passIdx = r;

            for (var c = 0; c < ta.length; c++) {
              var _ = ta[c];
              l.lights.push(_), l.dynamicOffsets.push(this._lightBufferStride * _);
            }

            this._lightPasses.push(l);
          }
        }, t._updateLightDescriptorSet = function (e, t) {
          for (var i = this._pipeline.device, r = this._pipeline.pipelineSceneData, n = r.shadows, a = r.shadowFrameBufferMap, s = e.scene.mainLight, o = Be(i) ? 0 : 1, h = this._pipeline.globalDSManager, d = r.validPunctualLights, u = 0; u < d.length; u++) {
            var l = d[u],
                c = h.getOrCreateDescriptorSet(u);

            if (c) {
              var _ = void 0,
                  f = void 0;

              switch (l.type) {
                case St.SPHERE:
                  s && (Yt(n, s, this._shadowUBO), Kt(n, this._shadowUBO)), this._shadowUBO[me.SHADOW_WIDTH_HEIGHT_PCF_BIAS_INFO_OFFSET + 0] = n.size.x, this._shadowUBO[me.SHADOW_WIDTH_HEIGHT_PCF_BIAS_INFO_OFFSET + 1] = n.size.y, this._shadowUBO[me.SHADOW_WIDTH_HEIGHT_PCF_BIAS_INFO_OFFSET + 2] = 1, this._shadowUBO[me.SHADOW_WIDTH_HEIGHT_PCF_BIAS_INFO_OFFSET + 3] = 0, this._shadowUBO[me.SHADOW_LIGHT_PACKING_NBIAS_NULL_INFO_OFFSET + 0] = 2, this._shadowUBO[me.SHADOW_LIGHT_PACKING_NBIAS_NULL_INFO_OFFSET + 1] = o, this._shadowUBO[me.SHADOW_LIGHT_PACKING_NBIAS_NULL_INFO_OFFSET + 2] = 0, this._shadowUBO[me.SHADOW_LIGHT_PACKING_NBIAS_NULL_INFO_OFFSET + 3] = 0, Oe.toArray(this._shadowUBO, n.shadowColor, me.SHADOW_COLOR_OFFSET);
                  break;

                case St.SPOT:
                  var p = l;

                  if (s && (Yt(n, s, this._shadowUBO), Kt(n, this._shadowUBO)), ce.invert(ia, l.node.getWorldMatrix()), ce.perspective(ra, l.angle, 1, .001, l.range), _ = ra.clone(), f = ra.clone().invert(), ce.multiply(ra, ra, ia), ce.toArray(this._shadowUBO, ia, me.MAT_LIGHT_VIEW_OFFSET), ce.toArray(this._shadowUBO, ra, me.MAT_LIGHT_VIEW_PROJ_OFFSET), this._shadowUBO[me.SHADOW_NEAR_FAR_LINEAR_SATURATION_INFO_OFFSET + 0] = .01, this._shadowUBO[me.SHADOW_NEAR_FAR_LINEAR_SATURATION_INFO_OFFSET + 1] = l.range, this._shadowUBO[me.SHADOW_NEAR_FAR_LINEAR_SATURATION_INFO_OFFSET + 2] = 0, this._shadowUBO[me.SHADOW_NEAR_FAR_LINEAR_SATURATION_INFO_OFFSET + 3] = 0, this._shadowUBO[me.SHADOW_WIDTH_HEIGHT_PCF_BIAS_INFO_OFFSET + 0] = n.size.x, this._shadowUBO[me.SHADOW_WIDTH_HEIGHT_PCF_BIAS_INFO_OFFSET + 1] = n.size.y, this._shadowUBO[me.SHADOW_WIDTH_HEIGHT_PCF_BIAS_INFO_OFFSET + 2] = p.shadowPcf, this._shadowUBO[me.SHADOW_WIDTH_HEIGHT_PCF_BIAS_INFO_OFFSET + 3] = p.shadowBias, this._shadowUBO[me.SHADOW_LIGHT_PACKING_NBIAS_NULL_INFO_OFFSET + 0] = 1, this._shadowUBO[me.SHADOW_LIGHT_PACKING_NBIAS_NULL_INFO_OFFSET + 1] = o, this._shadowUBO[me.SHADOW_LIGHT_PACKING_NBIAS_NULL_INFO_OFFSET + 2] = p.shadowNormalBias, this._shadowUBO[me.SHADOW_LIGHT_PACKING_NBIAS_NULL_INFO_OFFSET + 3] = 0, this._shadowUBO[me.SHADOW_PROJ_DEPTH_INFO_OFFSET + 0] = _.m10, this._shadowUBO[me.SHADOW_PROJ_DEPTH_INFO_OFFSET + 1] = _.m14, this._shadowUBO[me.SHADOW_PROJ_DEPTH_INFO_OFFSET + 2] = _.m11, this._shadowUBO[me.SHADOW_PROJ_DEPTH_INFO_OFFSET + 3] = _.m15, this._shadowUBO[me.SHADOW_INV_PROJ_DEPTH_INFO_OFFSET + 0] = f.m10, this._shadowUBO[me.SHADOW_INV_PROJ_DEPTH_INFO_OFFSET + 1] = f.m14, this._shadowUBO[me.SHADOW_INV_PROJ_DEPTH_INFO_OFFSET + 2] = f.m11, this._shadowUBO[me.SHADOW_INV_PROJ_DEPTH_INFO_OFFSET + 3] = f.m15, this._shadowUBO[me.SHADOW_PROJ_INFO_OFFSET + 0] = _.m00, this._shadowUBO[me.SHADOW_PROJ_INFO_OFFSET + 1] = _.m05, this._shadowUBO[me.SHADOW_PROJ_INFO_OFFSET + 2] = 1 / _.m00, this._shadowUBO[me.SHADOW_PROJ_INFO_OFFSET + 3] = 1 / _.m05, Oe.toArray(this._shadowUBO, n.shadowColor, me.SHADOW_COLOR_OFFSET), a.has(l)) {
                    var g,
                        S = null === (g = a.get(l)) || void 0 === g ? void 0 : g.colorTextures[0];
                    S && c.bindTexture(De, S);
                  }

              }

              c.update(), t.updateBuffer(c.getBuffer(me.BINDING), this._shadowUBO);
            }
          }
        }, t._updateUBOs = function (e, t) {
          var i = e.exposure,
              r = this._pipeline.pipelineSceneData,
              n = r.isHDR,
              a = r.shadows,
              s = r.validPunctualLights;
          s.length > this._lightBufferCount && (this._firstLightBufferView.destroy(), this._lightBufferCount = qe(s.length), this._lightBuffer.resize(this._lightBufferStride * this._lightBufferCount), this._lightBufferData = new Float32Array(this._lightBufferElementCount * this._lightBufferCount), this._firstLightBufferView.initialize(new X(this._lightBuffer, 0, Qe.SIZE)));

          for (var o = 0, h = 0; o < s.length; o++, h += this._lightBufferElementCount) {
            var d = s[o];

            switch (d.type) {
              case St.SPHERE:
                if (le.toArray($n, d.position), $n[3] = 0, this._lightBufferData.set($n, h + Qe.LIGHT_POS_OFFSET), $n[0] = d.size, $n[1] = d.range, $n[2] = 0, $n[3] = 0, this._lightBufferData.set($n, h + Qe.LIGHT_SIZE_RANGE_ANGLE_OFFSET), le.toArray($n, d.color), d.useColorTemperature) {
                  var u = d.colorTemperatureRGB;
                  $n[0] *= u.x, $n[1] *= u.y, $n[2] *= u.z;
                }

                $n[3] = n ? d.luminance * i * this._lightMeterScale : d.luminance, this._lightBufferData.set($n, h + Qe.LIGHT_COLOR_OFFSET);
                break;

              case St.SPOT:
                if (le.toArray($n, d.position), $n[3] = 1, this._lightBufferData.set($n, h + Qe.LIGHT_POS_OFFSET), $n[0] = d.size, $n[1] = d.range, $n[2] = d.spotAngle, $n[3] = a.enabled && d.shadowEnabled && a.type === ve.ShadowMap ? 1 : 0, this._lightBufferData.set($n, h + Qe.LIGHT_SIZE_RANGE_ANGLE_OFFSET), le.toArray($n, d.direction), this._lightBufferData.set($n, h + Qe.LIGHT_DIR_OFFSET), le.toArray($n, d.color), d.useColorTemperature) {
                  var l = d.colorTemperatureRGB;
                  $n[0] *= l.x, $n[1] *= l.y, $n[2] *= l.z;
                }

                $n[3] = n ? d.luminance * i * this._lightMeterScale : d.luminance, this._lightBufferData.set($n, h + Qe.LIGHT_COLOR_OFFSET);
            }
          }

          t.updateBuffer(this._lightBuffer, this._lightBufferData);
        }, e;
      }(),
          Aa = new _e(),
          Ea = function () {
        function e(e) {
          this._pendingModels = [], this._castModels = [], this._instancedQueue = new Jn(), this._pipeline = void 0, this._pipeline = e;
        }

        var t = e.prototype;
        return t.gatherShadowPasses = function (e, t) {
          var i = this._pipeline.pipelineSceneData,
              r = (this._pipeline.pipelineUBO, i.shadows);

          if (this._instancedQueue.clear(), this._pendingModels.length = 0, this._castModels.length = 0, r.enabled && r.type === ve.Planar && !(r.normal.length() < 1e-6)) {
            var n = e.scene,
                a = e.frustum,
                s = 0 != (e.visibility & ke.BitMask.DEFAULT);

            if (n.mainLight && s) {
              for (var o = n.models, h = 0; h < o.length; h++) {
                var d = o[h];
                d.enabled && d.node && d.castShadow && this._castModels.push(d);
              }

              var u = r.instancingMaterial.passes[0].getInstancedBuffer();

              this._instancedQueue.queue.add(u);

              for (var l = 0; l < this._castModels.length; l++) {
                var c = this._castModels[l];
                if (!c.worldBounds || (_e.transform(Aa, c.worldBounds, r.matLight), Se.aabbFrustum(Aa, a))) if (c.isInstancingEnabled) for (var _ = c.subModels, f = 0; f < _.length; f++) {
                  var p = _[f];
                  u.merge(p, c.instancedAttributes, 0, p.planarInstanceShader);
                } else this._pendingModels.push(c);
              }

              this._instancedQueue.uploadBuffers(t);
            }
          }
        }, t.recordCommandBuffer = function (e, t, i) {
          var r = this._pipeline.pipelineSceneData.shadows;

          if (r.enabled && r.type === ve.Planar && (this._instancedQueue.recordCommandBuffer(e, t, i), this._pendingModels.length)) {
            var n = r.material.passes[0],
                a = n.descriptorSet;
            i.bindDescriptorSet(Te.MATERIAL, a);

            for (var s = this._pendingModels.length, o = 0; o < s; o++) {
              for (var h = this._pendingModels[o], d = 0; d < h.subModels.length; d++) {
                var u = h.subModels[d],
                    l = u.planarShader,
                    c = u.inputAssembler,
                    _ = Ee.getOrCreatePipelineState(e, n, l, t, c);

                i.bindPipelineState(_), i.bindDescriptorSet(Te.LOCAL, u.descriptorSet), i.bindInputAssembler(c), i.draw(c);
              }
            }
          }
        }, e;
      }(),
          Ta = function () {
        function e() {
          this._phaseID = We("default");
        }

        var t = e.prototype;
        return t.activate = function (e) {
          this._pipeline = e;
        }, t.render = function (e, t) {
          for (var i = this._pipeline, r = i.device, n = i.commandBuffers[0], a = e.scene.batches, s = 0; s < a.length; s++) {
            var o = a[s],
                h = !1;
            if (e.visibility & o.visFlags && (h = !0), h) for (var d = o.shaders.length, u = 0; u < d; u++) {
              var l = o.passes[u];

              if (l.phase === this._phaseID) {
                var c = o.shaders[u],
                    _ = o.inputAssembler,
                    f = Ee.getOrCreatePipelineState(r, l, c, t, _);
                n.bindPipelineState(f), n.bindDescriptorSet(Te.MATERIAL, l.descriptorSet);
                var p = o.descriptorSet;
                n.bindDescriptorSet(Te.LOCAL, p), n.bindInputAssembler(_), n.draw(_);
              }
            }
          }
        }, e;
      }(),
          Oa = [new Y(0, 0, 0, 1)],
          ya = e("e", (da = Pe("ForwardStage"), ua = Me([Qn]), la = Ce(), da((ga = pa = function (e) {
        function t() {
          var t;
          return t = e.call(this) || this, v(t, "renderQueues", fa, W(t)), t._renderQueues = [], t._renderArea = new G(), t._batchedQueue = void 0, t._instancedQueue = void 0, t._phaseID = We("default"), t._clearFlag = 4294967295, t._batchedQueue = new Zn(), t._instancedQueue = new Jn(), t._uiPhase = new Ta(), t;
        }

        w(t, e);
        var i = t.prototype;
        return i.initialize = function (t) {
          return e.prototype.initialize.call(this, t), t.renderQueues && (this.renderQueues = t.renderQueues), !0;
        }, i.activate = function (t, i) {
          e.prototype.activate.call(this, t, i);

          for (var r = 0; r < this.renderQueues.length; r++) {
            this._renderQueues[r] = Xn(this.renderQueues[r]);
          }

          this._additiveLightQueue = new wa(this._pipeline), this._planarQueue = new Ea(this._pipeline), this._uiPhase.activate(t);
        }, i.destroy = function () {}, i.render = function (e) {
          this._instancedQueue.clear(), this._batchedQueue.clear();
          var t = this._pipeline,
              i = t.device;

          this._renderQueues.forEach(Yn);

          for (var r = t.pipelineSceneData.renderObjects, n = 0, a = 0, s = 0, o = 0; o < r.length; ++o) {
            var h = r[o],
                d = h.model.subModels;

            for (n = 0; n < d.length; ++n) {
              var u = d[n],
                  l = u.passes;

              for (a = 0; a < l.length; ++a) {
                var c = l[a];

                if (c.phase === this._phaseID) {
                  var _ = c.batchingScheme;

                  if (_ === Ve.INSTANCING) {
                    var f = c.getInstancedBuffer();
                    f.merge(u, h.model.instancedAttributes, a), this._instancedQueue.queue.add(f);
                  } else if (_ === Ve.VB_MERGING) {
                    var p = c.getBatchedBuffer();
                    p.merge(u, a, h.model), this._batchedQueue.queue.add(p);
                  } else for (s = 0; s < this._renderQueues.length; s++) {
                    this._renderQueues[s].insertRenderPass(h, n, a);
                  }
                }
              }
            }
          }

          this._renderQueues.forEach(Kn);

          var g = t.commandBuffers[0];
          t.pipelineUBO.updateShadowUBO(e), this._instancedQueue.uploadBuffers(g), this._batchedQueue.uploadBuffers(g), this._additiveLightQueue.gatherLightPasses(e, g), this._planarQueue.gatherShadowPasses(e, g), e.clearFlag & y.COLOR && (Oa[0].x = e.clearColor.x, Oa[0].y = e.clearColor.y, Oa[0].z = e.clearColor.z, Oa[0].w = e.clearColor.w), t.generateRenderArea(e, this._renderArea);
          var S = e.window.framebuffer,
              m = t.getRenderPass(e.clearFlag & this._clearFlag, S);
          g.beginRenderPass(m, S, this._renderArea, Oa, e.clearDepth, e.clearStencil), g.bindDescriptorSet(Te.GLOBAL, t.descriptorSet), this._renderQueues[0].recordCommandBuffer(i, m, g), this._instancedQueue.recordCommandBuffer(i, m, g), this._batchedQueue.recordCommandBuffer(i, m, g), this._additiveLightQueue.recordCommandBuffer(i, m, g), g.bindDescriptorSet(Te.GLOBAL, t.descriptorSet), this._planarQueue.recordCommandBuffer(i, m, g), this._renderQueues[1].recordCommandBuffer(i, m, g), this._pipeline.geometryRenderer.render(m, g), this._uiPhase.render(e, m), Xe(i, m, g, t.profiler, e), g.endRenderPass();
        }, t;
      }(Vi), pa.initInfo = {
        name: "ForwardStage",
        priority: rr.FORWARD,
        tag: 0,
        renderQueues: [{
          isTransparent: !1,
          sortMode: Hn.FRONT_TO_BACK,
          stages: ["default"]
        }, {
          isTransparent: !0,
          sortMode: Hn.BACK_TO_FRONT,
          stages: ["default", "planarShadow"]
        }]
      }, fa = m((_a = ga).prototype, "renderQueues", [ua, Le, la], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return [];
        }
      }), ca = _a)) || ca)),
          ba = e("d", Pe("ForwardFlow")((va = ma = function (e) {
        function t() {
          return e.apply(this, arguments) || this;
        }

        w(t, e);
        var i = t.prototype;
        return i.initialize = function (t) {
          if (e.prototype.initialize.call(this, t), 0 === this._stages.length) {
            var i = new ya();
            i.initialize(ya.initInfo), this._stages.push(i);
          }

          return !0;
        }, i.activate = function (t) {
          e.prototype.activate.call(this, t);
        }, i.render = function (t) {
          e.prototype.render.call(this, t);
        }, i.destroy = function () {
          e.prototype.destroy.call(this);
        }, t;
      }(ki), ma.initInfo = {
        name: Ye,
        priority: nr.FORWARD,
        stages: []
      }, Sa = va)) || Sa),
          Ra = new ce(),
          Ia = new ce(),
          Fa = new ce(),
          Na = new _e(),
          Da = We("shadow-caster"),
          Ba = [];

      function Pa(e, t) {
        t.length = 0;

        for (var i = !1, r = 0; r < e.length; r++) {
          for (var n = e[r].passes, a = -1, s = 0; s < n.length; s++) {
            if (n[s].phase === Da) {
              a = s, i = !0;
              break;
            }
          }

          t.push(a);
        }

        return i;
      }

      var La,
          Ca,
          Ma,
          xa,
          za,
          Ha,
          Ga,
          Ua,
          Wa,
          Qa,
          Va,
          qa,
          ka,
          Xa,
          Ya,
          Ka,
          Za,
          Ja,
          ja,
          $a,
          es,
          ts,
          is,
          rs,
          ns,
          as,
          ss,
          os,
          hs,
          ds,
          us,
          ls,
          cs,
          _s,
          fs,
          ps,
          gs,
          Ss,
          ms,
          vs,
          ws,
          As,
          Es,
          Ts,
          Os = function () {
        function e(e) {
          this._pipeline = void 0, this._subModelsArray = [], this._passArray = [], this._shaderArray = [], this._instancedQueue = void 0, this._batchedQueue = void 0, this._pipeline = e, this._instancedQueue = new Jn(), this._batchedQueue = new Zn();
        }

        var t = e.prototype;
        return t.gatherLightPasses = function (e, t, i, r) {
          this.clear();
          var n = this._pipeline.pipelineSceneData,
              a = n.shadows;

          if (i && a.enabled && a.type === ve.ShadowMap) {
            var s = n.dirShadowObjects,
                o = n.castShadowObjects;

            switch (i.type) {
              case St.DIRECTIONAL:
                for (var h = 0; h < s.length; h++) {
                  var d = s[h].model;
                  Pa(d.subModels, Ba) && this.add(d, Ba);
                }

                break;

              case St.SPOT:
                ce.invert(Ra, i.node.getWorldMatrix()), ce.perspective(Ia, i.angle, 1, .001, i.range), ce.multiply(Fa, Ia, Ra);

                for (var u = 0; u < o.length; u++) {
                  var l = o[u].model;
                  Pa(l.subModels, Ba) && (l.worldBounds && (_e.transform(Na, l.worldBounds, Fa), !Se.aabbFrustum(Na, t.frustum)) || this.add(l, Ba));
                }

            }

            this._instancedQueue.uploadBuffers(r), this._batchedQueue.uploadBuffers(r);
          }
        }, t.clear = function () {
          this._subModelsArray.length = 0, this._shaderArray.length = 0, this._passArray.length = 0, this._instancedQueue.clear(), this._batchedQueue.clear();
        }, t.add = function (e, t) {
          for (var i = e.subModels, r = 0; r < i.length; r++) {
            var n = i[r],
                a = t[r],
                s = n.passes[a];

            if (s.batchingScheme === Ve.INSTANCING) {
              var o = s.getInstancedBuffer();
              o.merge(n, e.instancedAttributes, a), this._instancedQueue.queue.add(o);
            } else if (s.batchingScheme === Ve.VB_MERGING) {
              var h = s.getBatchedBuffer();
              h.merge(n, a, e), this._batchedQueue.queue.add(h);
            } else {
              var d = n.shaders[a];
              this._subModelsArray.push(n), d && this._shaderArray.push(d), this._passArray.push(s);
            }
          }
        }, t.recordCommandBuffer = function (e, t, i) {
          this._instancedQueue.recordCommandBuffer(e, t, i), this._batchedQueue.recordCommandBuffer(e, t, i);

          for (var r = 0; r < this._subModelsArray.length; ++r) {
            var n = this._subModelsArray[r],
                a = this._shaderArray[r],
                s = this._passArray[r],
                o = n.inputAssembler,
                h = Ee.getOrCreatePipelineState(e, s, a, t, o),
                d = s.descriptorSet;
            i.bindPipelineState(h), i.bindDescriptorSet(Te.MATERIAL, d), i.bindDescriptorSet(Te.LOCAL, n.descriptorSet), i.bindInputAssembler(o), i.draw(o);
          }
        }, e;
      }(),
          ys = [new Y(1, 1, 1, 1)],
          bs = e("h", Pe("ShadowStage")((Ma = Ca = function (e) {
        function t() {
          for (var t, i = arguments.length, r = new Array(i), n = 0; n < i; n++) {
            r[n] = arguments[n];
          }

          return (t = e.call.apply(e, [this].concat(r)) || this)._shadowFrameBuffer = null, t._renderArea = new G(), t._light = null, t._globalDS = null, t;
        }

        w(t, e);
        var i = t.prototype;
        return i.setUsage = function (e, t, i) {
          this._globalDS = e, this._light = t, this._shadowFrameBuffer = i;
        }, i.destroy = function () {
          var e;
          this._shadowFrameBuffer = null, this._globalDS = null, this._light = null, null === (e = this._additiveShadowQueue) || void 0 === e || e.clear();
        }, i.clearFramebuffer = function (e) {
          if (this._light && this._shadowFrameBuffer) {
            ys[0].w = e.clearColor.w;
            var t = this._pipeline.commandBuffers[0],
                i = this._shadowFrameBuffer.renderPass;
            t.beginRenderPass(i, this._shadowFrameBuffer, this._renderArea, ys, e.clearDepth, e.clearStencil), t.endRenderPass();
          }
        }, i.render = function (e) {
          var t = this._pipeline,
              i = t.pipelineSceneData,
              r = i.shadows,
              n = i.shadingScale,
              a = this._globalDS,
              s = t.commandBuffers[0];

          if (this._light && this._shadowFrameBuffer) {
            this._pipeline.pipelineUBO.updateShadowUBOLight(a, this._light), this._additiveShadowQueue.gatherLightPasses(a, e, this._light, s);
            var o = e.viewport,
                h = r.size;
            this._renderArea.x = o.x * h.x, this._renderArea.y = o.y * h.y, this._renderArea.width = o.width * h.x * n, this._renderArea.height = o.height * h.y * n;
            var d = t.device,
                u = this._shadowFrameBuffer.renderPass;
            s.beginRenderPass(u, this._shadowFrameBuffer, this._renderArea, ys, e.clearDepth, e.clearStencil), s.bindDescriptorSet(Te.GLOBAL, a), this._additiveShadowQueue.recordCommandBuffer(d, u, s), s.endRenderPass();
          }
        }, i.activate = function (t, i) {
          e.prototype.activate.call(this, t, i), this._additiveShadowQueue = new Os(t);
        }, t;
      }(Vi), Ca.initInfo = {
        name: "ShadowStage",
        priority: rr.FORWARD,
        tag: 0
      }, La = Ma)) || La),
          Rs = [],
          Is = e("S", Pe("ShadowFlow")((Ha = za = function (e) {
        function t() {
          for (var t, i = arguments.length, r = new Array(i), n = 0; n < i; n++) {
            r[n] = arguments[n];
          }

          return (t = e.call.apply(e, [this].concat(r)) || this)._shadowRenderPass = null, t;
        }

        w(t, e);
        var i = t.prototype;
        return i.initialize = function (t) {
          if (e.prototype.initialize.call(this, t), 0 === this._stages.length) {
            var i = new bs();
            i.initialize(bs.initInfo), this._stages.push(i);
          }

          return !0;
        }, i.render = function (e) {
          var t = this._pipeline,
              i = t.pipelineSceneData.shadows,
              r = t.pipelineSceneData.shadowFrameBufferMap,
              n = t.pipelineSceneData.castShadowObjects,
              a = this._pipeline.pipelineSceneData.validPunctualLights;

          if (i.enabled && i.type === ve.ShadowMap) {
            for (var s = 0, o = 0; s < i.maxReceived && o < a.length;) {
              var h = a[o];
              h.type === St.SPOT && (Rs.push(h), s++), o++;
            }

            if (0 !== n.length) {
              i.shadowMapDirty && this.resizeShadowMap();
              var d = e.scene.mainLight;

              if (d) {
                var u = t.descriptorSet;
                r.has(d) || this._initShadowFrameBuffer(t, d, e.window.swapchain);

                for (var l = r.get(d), c = 0; c < this._stages.length; c++) {
                  var _ = this._stages[c];
                  _.setUsage(u, d, l), _.render(e);
                }
              }

              for (var f = 0; f < Rs.length; f++) {
                var p = Rs[f],
                    g = t.globalDSManager.getOrCreateDescriptorSet(f);
                r.has(p) || this._initShadowFrameBuffer(t, p, e.window.swapchain);

                for (var S = r.get(p), m = 0; m < this._stages.length; m++) {
                  var v = this._stages[m];
                  v.setUsage(g, p, S), v.render(e);
                }
              }

              Rs.length = 0;
            } else this.clearShadowMap(Rs, e);
          }
        }, i.destroy = function () {
          if (e.prototype.destroy.call(this), this._pipeline) {
            for (var t = this._pipeline.pipelineSceneData.shadowFrameBufferMap, i = Array.from(t.values()), r = 0; r < i.length; r++) {
              var n = i[r];

              if (n) {
                for (var a = n.colorTextures, s = 0; s < a.length; s++) {
                  var o = a[r];
                  o && o.destroy();
                }

                a.length = 0;
                var h = n.depthStencilTexture;
                h && h.destroy(), n.destroy();
              }
            }

            t.clear();
          }

          this._shadowRenderPass && this._shadowRenderPass.destroy();
        }, i._initShadowFrameBuffer = function (e, t) {
          var i = e.device,
              r = e.pipelineSceneData.shadows.size,
              n = e.pipelineSceneData.shadowFrameBufferMap,
              a = Be(i) ? _.R32F : _.RGBA8;

          if (!this._shadowRenderPass) {
            var s = new E();
            s.format = a, s.loadOp = b.CLEAR, s.storeOp = O.STORE, s.sampleCount = 1;
            var o = new T();
            o.format = _.DEPTH_STENCIL, o.depthLoadOp = b.CLEAR, o.depthStoreOp = O.DISCARD, o.stencilLoadOp = b.CLEAR, o.stencilStoreOp = O.DISCARD, o.sampleCount = 1;
            var h = new F([s], o);
            this._shadowRenderPass = i.createRenderPass(h);
          }

          var d = [];
          d.push(i.createTexture(new x(z.TEX2D, H.COLOR_ATTACHMENT | H.SAMPLED, a, r.x, r.y)));
          var u = i.createTexture(new x(z.TEX2D, H.DEPTH_STENCIL_ATTACHMENT, _.DEPTH_STENCIL, r.x, r.y)),
              l = i.createFramebuffer(new N(this._shadowRenderPass, d, u));
          n.set(t, l);
        }, i.clearShadowMap = function (e, t) {
          var i = this._pipeline,
              r = i.pipelineSceneData,
              n = t.scene.mainLight;

          if (n) {
            var a = this._pipeline.descriptorSet;
            r.shadowFrameBufferMap.has(n) || this._initShadowFrameBuffer(this._pipeline, n, t.window.swapchain);

            for (var s = r.shadowFrameBufferMap.get(n), o = 0; o < this._stages.length; o++) {
              var h = this._stages[o];
              h.setUsage(a, n, s), h.render(t);
            }
          }

          for (var d = 0; d < e.length; d++) {
            var u = e[d],
                l = r.shadowFrameBufferMap.get(u),
                c = i.globalDSManager.getOrCreateDescriptorSet(d);
            if (r.shadowFrameBufferMap.has(u)) for (var _ = 0; _ < this._stages.length; _++) {
              var f = this._stages[_];
              f.setUsage(c, u, l), f.clearFramebuffer(t);
            }
          }
        }, i.resizeShadowMap = function () {
          for (var e = this._pipeline.pipelineSceneData.shadows, t = e.size, i = this._pipeline, r = i.device, n = i.pipelineSceneData.shadowFrameBufferMap, a = Be(r) ? _.R32F : _.RGBA8, s = n.values(), o = s.next(); !o.done;) {
            var h = o.value;

            if (h) {
              var d = [];
              d.push(i.device.createTexture(new x(z.TEX2D, H.COLOR_ATTACHMENT | H.SAMPLED, a, t.x, t.y)));
              var u = h.depthStencilTexture;
              u && u.resize(t.x, t.y);
              var l = h.renderPass;
              h.destroy(), h.initialize(new N(l, d, u)), o = s.next();
            } else o = s.next();
          }

          e.shadowMapDirty = !1;
        }, t;
      }(ki), za.initInfo = {
        name: Ke,
        priority: nr.SHADOW,
        tag: Bn.SCENE,
        stages: []
      }, xa = Ha)) || xa),
          Fs = function () {
        var e = t.prototype;

        function t() {
          this.fog = new Ze(), this.ambient = new Je(), this.skybox = new je(), this.shadows = new $e(), this.octree = new mt(), this.validPunctualLights = [], this.renderObjects = [], this.castShadowObjects = [], this.dirShadowObjects = [], this.shadowFrameBufferMap = new Map(), this._geometryRendererMaterials = [], this._geometryRendererPasses = [], this._geometryRendererShaders = [], this._occlusionQueryVertexBuffer = null, this._occlusionQueryIndicesBuffer = null, this._occlusionQueryInputAssembler = null, this._occlusionQueryMaterial = null, this._occlusionQueryShader = null, this._isHDR = !0, this._shadingScale = 1, this._init(), this.shadingScale = 1;
        }

        return e._init = function () {}, e.activate = function (e, t) {
          return this._device = e, this._pipeline = t, this.initGeometryRendererMaterials(), this.initOcclusionQuery(), !0;
        }, e.initGeometryRendererMaterials = function () {
          for (var e = 0, t = 0; t < 6; t++) {
            this._geometryRendererMaterials[t] = new Ge(), this._geometryRendererMaterials[t]._uuid = "geometry-renderer-material-" + t, this._geometryRendererMaterials[t].initialize({
              effectName: "geometry-renderer",
              technique: t
            });

            for (var i = 0; i < this._geometryRendererMaterials[t].passes.length; ++i) {
              this._geometryRendererPasses[e] = this._geometryRendererMaterials[t].passes[i], this._geometryRendererShaders[e] = this._geometryRendererMaterials[t].passes[i].getShaderVariant(), e++;
            }
          }
        }, e.initOcclusionQuery = function () {
          if (this._occlusionQueryInputAssembler || (this._occlusionQueryInputAssembler = this._createOcclusionQueryIA()), !this._occlusionQueryMaterial) {
            var e = new Ge();
            e._uuid = "default-occlusion-query-material", e.initialize({
              effectName: "occlusion-query"
            }), this._occlusionQueryMaterial = e, this._occlusionQueryShader = e.passes[0].getShaderVariant();
          }
        }, e.getOcclusionQueryPass = function () {
          return this._occlusionQueryMaterial.passes[0];
        }, e.onGlobalPipelineStateChanged = function () {}, e.destroy = function () {
          var e, t, i;
          this.ambient.destroy(), this.skybox.destroy(), this.fog.destroy(), this.shadows.destroy(), this.octree.destroy(), this.validPunctualLights.length = 0, null === (e = this._occlusionQueryInputAssembler) || void 0 === e || e.destroy(), this._occlusionQueryInputAssembler = null, null === (t = this._occlusionQueryVertexBuffer) || void 0 === t || t.destroy(), this._occlusionQueryVertexBuffer = null, null === (i = this._occlusionQueryIndicesBuffer) || void 0 === i || i.destroy(), this._occlusionQueryIndicesBuffer = null;
        }, e._createOcclusionQueryIA = function () {
          var e = this._device,
              t = new Float32Array([-1, -1, -1, 1, -1, -1, -1, 1, -1, 1, 1, -1, -1, -1, 1, 1, -1, 1, -1, 1, 1, 1, 1, 1]),
              i = 3 * Float32Array.BYTES_PER_ELEMENT,
              r = 8 * i;
          this._occlusionQueryVertexBuffer = e.createBuffer(new s(o.VERTEX | o.TRANSFER_DST, h.DEVICE, r, i)), this._occlusionQueryVertexBuffer.update(t);
          var n = new Uint16Array([0, 2, 1, 1, 2, 3, 4, 5, 6, 5, 7, 6, 1, 3, 7, 1, 7, 5, 0, 4, 6, 0, 6, 2, 0, 1, 5, 0, 5, 4, 2, 6, 7, 2, 7, 3]),
              a = Uint16Array.BYTES_PER_ELEMENT,
              d = 36 * a;
          this._occlusionQueryIndicesBuffer = e.createBuffer(new s(o.INDEX | o.TRANSFER_DST, h.DEVICE, d, a)), this._occlusionQueryIndicesBuffer.update(n);
          var u = [new l("a_position", _.RGB32F)],
              c = new g(u, [this._occlusionQueryVertexBuffer], this._occlusionQueryIndicesBuffer);
          return e.createInputAssembler(c);
        }, d(t, [{
          key: "native",
          get: function get() {
            return this._nativeObj;
          }
        }, {
          key: "isHDR",
          get: function get() {
            return this._isHDR;
          },
          set: function set(e) {
            this._isHDR = e;
          }
        }, {
          key: "shadingScale",
          get: function get() {
            return this._shadingScale;
          },
          set: function set(e) {
            this._shadingScale !== e && (this._shadingScale = e, this._pipeline.emit(qi.ATTACHMENT_SCALE_CAHNGED, e));
          }
        }, {
          key: "geometryRendererPasses",
          get: function get() {
            return this._geometryRendererPasses;
          }
        }, {
          key: "geometryRendererShaders",
          get: function get() {
            return this._geometryRendererShaders;
          }
        }]), t;
      }(),
          Ns = (e("F", (Ga = Pe("ForwardPipeline"), Ua = Me([Gn]), Wa = Ce(), Ga((ka = function (e) {
        function t() {
          for (var t, i = arguments.length, r = new Array(i), n = 0; n < i; n++) {
            r[n] = arguments[n];
          }

          return t = e.call.apply(e, [this].concat(r)) || this, v(t, "renderTextures", qa, W(t)), t._postRenderPass = null, t;
        }

        w(t, e);
        var i = t.prototype;
        return i.initialize = function (t) {
          if (e.prototype.initialize.call(this, t), 0 === this._flows.length) {
            var i = new Is();
            i.initialize(Is.initInfo), this._flows.push(i);
            var r = new ba();
            r.initialize(ba.initInfo), this._flows.push(r);
          }

          return !0;
        }, i.activate = function (t) {
          return this._macros = {
            CC_PIPELINE_TYPE: 0
          }, this._pipelineSceneData = new Fs(), !(!e.prototype.activate.call(this, t) || !this._activeRenderer(t) && (K(2402), 1));
        }, i._ensureEnoughSize = function (e) {
          for (var t = this._width, i = this._height, r = 0; r < e.length; ++r) {
            var n = e[r].window;
            t = Math.max(n.width, t), i = Math.max(n.height, i);
          }

          t === this._width && i === this._height || (this._width = t, this._height = i);
        }, i.destroy = function () {
          this._destroyUBOs(), this._destroyQuadInputAssembler();

          for (var t = this._renderPasses.values(), i = t.next(); !i.done;) {
            i.value.destroy(), i = t.next();
          }

          return this._commandBuffers.length = 0, e.prototype.destroy.call(this);
        }, i._activeRenderer = function () {
          var e = this.device;

          this._commandBuffers.push(e.commandBuffer);

          var t = this.globalDSManager.pointSampler;
          return this._descriptorSet.bindSampler(Fe, t), this._descriptorSet.bindTexture(Fe, Ne.get("default-texture").getGFXTexture()), this._descriptorSet.bindSampler(De, t), this._descriptorSet.bindTexture(De, Ne.get("default-texture").getGFXTexture()), this._descriptorSet.update(), !0;
        }, i._destroyUBOs = function () {
          this._descriptorSet && (this._descriptorSet.getBuffer(Re.BINDING).destroy(), this._descriptorSet.getBuffer(me.BINDING).destroy(), this._descriptorSet.getBuffer(Ie.BINDING).destroy(), this._descriptorSet.getTexture(Fe).destroy(), this._descriptorSet.getTexture(De).destroy());
        }, d(t, [{
          key: "postRenderPass",
          get: function get() {
            return this._postRenderPass;
          }
        }]), t;
      }(zn), qa = m((Va = ka).prototype, "renderTextures", [Ua, Le, Wa], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return [];
        }
      }), Qa = Va)) || Qa)), [new Y(0, 0, 0, 0), new Y(0, 0, 0, 0), new Y(0, 0, 0, 0)]),
          Ds = e("f", (Xa = Pe("GbufferStage"), Ya = Me([Qn]), Ka = Ce(), Xa((es = $a = function (e) {
        function t() {
          var t;
          return t = e.call(this) || this, v(t, "renderQueues", ja, W(t)), t._renderQueues = [], t._renderArea = new G(), t._batchedQueue = void 0, t._instancedQueue = void 0, t._phaseID = We("default"), t._batchedQueue = new Zn(), t._instancedQueue = new Jn(), t;
        }

        w(t, e);
        var i = t.prototype;
        return i.initialize = function (t) {
          return e.prototype.initialize.call(this, t), t.renderQueues && (this.renderQueues = t.renderQueues), !0;
        }, i.activate = function (t, i) {
          e.prototype.activate.call(this, t, i);

          for (var r = 0; r < this.renderQueues.length; r++) {
            this._renderQueues[r] = Xn(this.renderQueues[r]);
          }
        }, i.destroy = function () {}, i.render = function (e) {
          this._instancedQueue.clear(), this._batchedQueue.clear();
          var t = this._pipeline,
              i = t.device;
          this._renderQueues.forEach(Yn), t.generateRenderArea(e, this._renderArea), t.updateQuadVertexData(this._renderArea, e.window);

          for (var r = t.pipelineSceneData.renderObjects, n = 0, a = 0, s = 0, o = 0; o < r.length; ++o) {
            var h = r[o],
                d = h.model.subModels;

            for (n = 0; n < d.length; ++n) {
              var u = d[n],
                  l = u.passes;

              for (a = 0; a < l.length; ++a) {
                var c = l[a];

                if (c.phase === this._phaseID) {
                  var _ = c.batchingScheme;

                  if (_ === Ve.INSTANCING) {
                    var f = c.getInstancedBuffer();
                    f.merge(u, h.model.instancedAttributes, a), this._instancedQueue.queue.add(f);
                  } else if (_ === Ve.VB_MERGING) {
                    var p = c.getBatchedBuffer();
                    p.merge(u, a, h.model), this._batchedQueue.queue.add(p);
                  } else for (s = 0; s < this._renderQueues.length; s++) {
                    this._renderQueues[s].insertRenderPass(h, n, a);
                  }
                }
              }
            }
          }

          this._renderQueues.forEach(Kn);

          var g = t.commandBuffers[0];
          this._instancedQueue.uploadBuffers(g), this._batchedQueue.uploadBuffers(g), e.clearFlag & y.COLOR && (t.pipelineSceneData.isHDR ? et(Ns[0], e.clearColor) : (Ns[0].x = e.clearColor.x, Ns[0].y = e.clearColor.y, Ns[0].z = e.clearColor.z)), Ns[0].w = e.clearColor.w;
          var S = t.getPipelineRenderData().gbufferFrameBuffer,
              m = S.renderPass;
          g.beginRenderPass(m, S, this._renderArea, Ns, e.clearDepth, e.clearStencil), g.setScissor(t.generateScissor(e)), g.setViewport(t.generateViewport(e)), g.bindDescriptorSet(Te.GLOBAL, t.descriptorSet);

          for (var v = 0; v < this.renderQueues.length; v++) {
            this._renderQueues[v].recordCommandBuffer(i, m, g);
          }

          this._instancedQueue.recordCommandBuffer(i, m, g), this._batchedQueue.recordCommandBuffer(i, m, g), g.endRenderPass();
        }, t;
      }(Vi), $a.initInfo = {
        name: "GbufferStage",
        priority: ar.GBUFFER,
        tag: 0,
        renderQueues: [{
          isTransparent: !1,
          sortMode: Hn.FRONT_TO_BACK,
          stages: ["default"]
        }, {
          isTransparent: !0,
          sortMode: Hn.BACK_TO_FRONT,
          stages: ["default"]
        }]
      }, ja = m((Ja = es).prototype, "renderQueues", [Ya, Le, Ka], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return [];
        }
      }), Za = Ja)) || Za)),
          Bs = [new Y(0, 0, 0, 1)],
          Ps = e("L", (ts = Pe("LightingStage"), is = Me(Ge), rs = Ce(), ns = Me([Qn]), as = Ce(), ts((ls = us = function (e) {
        function t() {
          var t;
          return (t = e.call(this) || this)._deferredLitsBufs = null, t._maxDeferredLights = it.LIGHTS_PER_PASS, t._lightMeterScale = 1e4, t._descriptorSet = null, t._renderArea = new G(), t._uiPhase = void 0, v(t, "_deferredMaterial", hs, W(t)), v(t, "renderQueues", ds, W(t)), t._phaseID = We("default"), t._renderQueues = [], t._uiPhase = new Ta(), t;
        }

        w(t, e);
        var i = t.prototype;
        return i.initialize = function (t) {
          return e.prototype.initialize.call(this, t), !0;
        }, i.gatherLights = function (e) {
          for (var t = this._pipeline, i = t.commandBuffers[0], r = e.scene.sphereLights, n = e.scene.spotLights, a = fe.create(0, 0, 0, 1), s = new Float32Array(4), o = e.exposure, h = 0, d = ye.length, u = d * this._maxDeferredLights, l = 0; l < r.length && h < this._maxDeferredLights; l++, ++h) {
            var c = r[l];

            if (fe.set(a, c.position.x, c.position.y, c.position.z, c.range), Se.sphereFrustum(a, e.frustum)) {
              if (le.toArray(s, c.position), s[3] = 0, this._lightBufferData.set(s, h * d), le.toArray(s, c.color), c.useColorTemperature) {
                var _ = c.colorTemperatureRGB;
                s[0] *= _.x, s[1] *= _.y, s[2] *= _.z;
              }

              t.pipelineSceneData.isHDR ? s[3] = c.luminance * o * this._lightMeterScale : s[3] = c.luminance, this._lightBufferData.set(s, h * d + 1 * u), s[0] = c.size, s[1] = c.range, s[2] = 0, this._lightBufferData.set(s, h * d + 2 * u);
            }
          }

          for (var f = 0; f < n.length && h < this._maxDeferredLights; f++, ++h) {
            var p = n[f];

            if (fe.set(a, p.position.x, p.position.y, p.position.z, p.range), Se.sphereFrustum(a, e.frustum)) {
              if (le.toArray(s, p.position), s[3] = 1, this._lightBufferData.set(s, h * d + 0 * u), le.toArray(s, p.color), p.useColorTemperature) {
                var g = p.colorTemperatureRGB;
                s[0] *= g.x, s[1] *= g.y, s[2] *= g.z;
              }

              t.pipelineSceneData.isHDR ? s[3] = p.luminance * o * this._lightMeterScale : s[3] = p.luminance, this._lightBufferData.set(s, h * d + 1 * u), s[0] = p.size, s[1] = p.range, s[2] = p.spotAngle, this._lightBufferData.set(s, h * d + 2 * u), le.toArray(s, p.direction), this._lightBufferData.set(s, h * d + 3 * u);
            }
          }

          var S = 3 * u + 3;
          this._lightBufferData.set([h], S), i.updateBuffer(this._deferredLitsBufs, this._lightBufferData);
        }, i._createStageDescriptor = function (e) {
          var t = this._pipeline.device,
              i = 16 * Float32Array.BYTES_PER_ELEMENT * this._maxDeferredLights;
          i = Math.ceil(i / t.capabilities.uboOffsetAlignment) * t.capabilities.uboOffsetAlignment, this._deferredLitsBufs = t.createBuffer(new s(o.UNIFORM | o.TRANSFER_DST, h.HOST | h.DEVICE, i, t.capabilities.uboOffsetAlignment));
          var r = t.createBuffer(new X(this._deferredLitsBufs, 0, i));
          this._lightBufferData = new Float32Array(i / Float32Array.BYTES_PER_ELEMENT), this._descriptorSet = t.createDescriptorSet(new a(e.localSetLayout)), this._descriptorSet.bindBuffer(Qe.BINDING, r);
          var n = t.createBuffer(new s(o.UNIFORM | o.TRANSFER_DST, h.DEVICE, tt.SIZE, tt.SIZE));

          this._descriptorSet.bindBuffer(tt.BINDING, n);
        }, i.activate = function (t, i) {
          e.prototype.activate.call(this, t, i), this._uiPhase.activate(t);

          for (var r = 0; r < this.renderQueues.length; r++) {
            this._renderQueues[r] = Xn(this.renderQueues[r]);
          }

          this._planarQueue = new Ea(this._pipeline), this._deferredMaterial && (t.pipelineSceneData.deferredLightingMaterial = this._deferredMaterial);
        }, i.destroy = function () {
          var e;
          null === (e = this._deferredLitsBufs) || void 0 === e || e.destroy(), this._deferredLitsBufs = null, this._descriptorSet = null;
        }, i.render = function (e) {
          var t = this._pipeline,
              i = t.device,
              r = t.commandBuffers[0],
              n = t.pipelineSceneData,
              a = n.renderObjects;
          this._planarQueue.gatherShadowPasses(e, r), t.generateRenderArea(e, this._renderArea);

          for (var s = t.getPipelineRenderData(), o = n.deferredLightingMaterial.passes[0], h = o.getShaderVariant(), d = 0; d < 3; ++d) {
            o.descriptorSet.bindTexture(d, s.gbufferRenderTargets[d]), o.descriptorSet.bindSampler(d, s.sampler);
          }

          o.descriptorSet.bindTexture(3, s.outputDepth), o.descriptorSet.bindSampler(3, s.sampler), o.descriptorSet.update(), this._descriptorSet || this._createStageDescriptor(o), this.gatherLights(e), e.clearFlag & y.COLOR && (Bs[0].x = e.clearColor.x, Bs[0].y = e.clearColor.y, Bs[0].z = e.clearColor.z), Bs[0].w = 0;
          var u = s.outputFrameBuffer,
              l = u.renderPass;
          t.pipelineUBO.updateShadowUBO(e), r.beginRenderPass(l, u, this._renderArea, Bs, e.clearDepth, e.clearStencil), r.setScissor(t.generateScissor(e)), r.setViewport(t.generateViewport(e)), r.bindDescriptorSet(Te.GLOBAL, t.descriptorSet);
          var c = t.quadIAOffscreen,
              _ = null;
          null != o && null != h && null != c && (_ = Ee.getOrCreatePipelineState(i, o, h, l, c)), null != _ && (this._descriptorSet.update(), r.bindPipelineState(_), r.bindDescriptorSet(Te.MATERIAL, o.descriptorSet), r.bindDescriptorSet(Te.LOCAL, this._descriptorSet), r.bindInputAssembler(c), r.draw(c)), this._renderQueues.forEach(Yn);

          for (var f = 0, p = 0, g = 0, S = 0; S < a.length; ++S) {
            var m = a[S],
                v = m.model.subModels;

            for (f = 0; f < v.length; ++f) {
              var w = v[f].passes;

              for (p = 0; p < w.length; ++p) {
                if (w[p].phase === this._phaseID) for (g = 0; g < this._renderQueues.length; g++) {
                  this._renderQueues[g].insertRenderPass(m, f, p);
                }
              }
            }
          }

          if (a.length > 0) {
            this._renderQueues.forEach(Kn);

            for (var A = 0; A < this._renderQueues.length; A++) {
              this._renderQueues[A].recordCommandBuffer(i, l, r);
            }

            this._planarQueue.recordCommandBuffer(i, l, r);
          }

          this._pipeline.geometryRenderer.render(l, r), this._uiPhase.render(e, l), r.endRenderPass();
        }, t;
      }(Vi), us.initInfo = {
        name: "LightingStage",
        priority: ar.LIGHTING,
        tag: 0
      }, hs = m((os = ls).prototype, "_deferredMaterial", [is, Le, rs], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return null;
        }
      }), ds = m(os.prototype, "renderQueues", [ns, Le, as], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return [];
        }
      }), ss = os)) || ss)),
          Ls = [new Y(0, 0, 0, 1)],
          Cs = e("P", (cs = Pe("PostProcessStage"), _s = Me(Ge), fs = Ce(), ps = Me([Qn]), gs = Ce(), cs((Es = As = function (e) {
        function t() {
          var t;
          return t = e.call(this) || this, v(t, "_postProcessMaterial", vs, W(t)), v(t, "renderQueues", ws, W(t)), t._renderArea = new G(), t._stageDesc = void 0, t._localUBO = void 0, t._uiPhase = new Ta(), t;
        }

        w(t, e);
        var i = t.prototype;
        return i.initialize = function (t) {
          return e.prototype.initialize.call(this, t), !0;
        }, i.activate = function (t, i) {
          e.prototype.activate.call(this, t, i), this._postProcessMaterial && (t.pipelineSceneData.postprocessMaterial = this._postProcessMaterial), this._uiPhase.activate(t);
        }, i.destroy = function () {}, i.render = function (e) {
          var t = this._pipeline,
              i = t.device,
              r = t.pipelineSceneData,
              n = t.commandBuffers[0];
          t.pipelineUBO.updateCameraUBO(e);
          var d = e.viewport;
          this._renderArea.x = d.x * e.window.width, this._renderArea.y = d.y * e.window.height, this._renderArea.width = d.width * e.window.width, this._renderArea.height = d.height * e.window.height;
          var u = t.getPipelineRenderData(),
              l = e.window.framebuffer,
              c = t.getRenderPass(e.clearFlag, l);
          e.clearFlag & y.COLOR && (Ls[0].x = e.clearColor.x, Ls[0].y = e.clearColor.y, Ls[0].z = e.clearColor.z), Ls[0].w = e.clearColor.w, n.beginRenderPass(c, l, this._renderArea, Ls, e.clearDepth, e.clearStencil), n.bindDescriptorSet(Te.GLOBAL, t.descriptorSet);

          var _ = r.postprocessMaterial.passes[0],
              f = _.getShaderVariant();

          t.bloomEnabled ? _.descriptorSet.bindTexture(0, u.bloom.combineTex) : _.descriptorSet.bindTexture(0, u.outputRenderTargets[0]), _.descriptorSet.bindSampler(0, u.sampler), _.descriptorSet.update();
          var p = e.window.swapchain ? t.quadIAOnscreen : t.quadIAOffscreen,
              g = null;
          null != _ && null != f && null != p && (g = Ee.getOrCreatePipelineState(i, _, f, c, p));
          var S = t.pipelineSceneData.renderObjects;
          null != g && S.length > 0 && (this._stageDesc || (this._stageDesc = i.createDescriptorSet(new a(_.localSetLayout)), this._localUBO = i.createBuffer(new s(o.UNIFORM | o.TRANSFER_DST, h.DEVICE, tt.SIZE, tt.SIZE)), this._stageDesc.bindBuffer(tt.BINDING, this._localUBO)), this._stageDesc.update(), n.bindPipelineState(g), n.bindDescriptorSet(Te.MATERIAL, _.descriptorSet), n.bindDescriptorSet(Te.LOCAL, this._stageDesc), n.bindInputAssembler(p), n.draw(p)), this._uiPhase.render(e, c), Xe(i, c, n, t.profiler, e), n.endRenderPass();
        }, t;
      }(Vi), As.initInfo = {
        name: "PostProcessStage",
        priority: ir.POST_PROCESS,
        tag: 0
      }, vs = m((ms = Es).prototype, "_postProcessMaterial", [_s, Le, fs], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return null;
        }
      }), ws = m(ms.prototype, "renderQueues", [ps, Le, gs], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return [];
        }
      }), Ss = ms)) || Ss));

      !function (e) {
        e[e.NONE = 0] = "NONE", e[e.FXAA = 1] = "FXAA";
      }(Ts || (Ts = {}));

      var Ms,
          xs,
          zs,
          Hs,
          Gs,
          Us,
          Ws,
          Qs,
          Vs = function (e) {
        function t() {
          for (var t, i = arguments.length, r = new Array(i), n = 0; n < i; n++) {
            r[n] = arguments[n];
          }

          return (t = e.call.apply(e, [this].concat(r)) || this)._antiAliasing = Ts.NONE, t;
        }

        w(t, e);
        var i = t.prototype;
        return i.onGlobalPipelineStateChanged = function () {
          this.updatePipelinePassInfo();
        }, i.updateBloomPass = function () {
          if (this._bloomMaterial) {
            var e = this._bloomMaterial.passes[0];
            e.beginChangeStatesSilently(), e.tryCompile(), e.endChangeStatesSilently();

            for (var t = [], i = [], r = 0; r < 6; ++r) {
              var n = this._bloomMaterial.passes[1 + r];
              n.beginChangeStatesSilently(), n.tryCompile(), n.endChangeStatesSilently();
              var a = this._bloomMaterial.passes[7 + r];
              a.beginChangeStatesSilently(), a.tryCompile(), a.endChangeStatesSilently(), t.push(n.native), i.push(a.native);
            }

            var s = this._bloomMaterial.passes[13];
            s.beginChangeStatesSilently(), s.tryCompile(), s.endChangeStatesSilently();
          }
        }, i.updatePostProcessPass = function () {
          if (this.postprocessMaterial) {
            var e = this.postprocessMaterial.passes[0];
            e.beginChangeStatesSilently(), e.tryCompile(), e.endChangeStatesSilently();
          }
        }, i.initPipelinePassInfo = function () {
          var e = new Ge();
          e._uuid = "builtin-deferred-material", e.initialize({
            effectName: "deferred-lighting"
          });

          for (var t = 0; t < e.passes.length; ++t) {
            e.passes[t].tryCompile();
          }

          this._deferredLightingMaterial = e;
          var i = new Ge();
          i._uuid = "builtin-bloom-material", i.initialize({
            effectName: "bloom"
          });

          for (var r = 0; r < i.passes.length; ++r) {
            i.passes[r].tryCompile();
          }

          this._bloomMaterial = i;
          var n = new Ge();
          n._uuid = "builtin-post-process-material", M.ENABLE_ANTIALIAS_FXAA && (this._antiAliasing = Ts.FXAA), n.initialize({
            effectName: "post-process",
            defines: {
              ANTIALIAS_TYPE: this._antiAliasing
            }
          });

          for (var a = 0; a < n.passes.length; ++a) {
            n.passes[a].tryCompile();
          }

          this._postprocessMaterial = n, this.updatePipelinePassInfo();
        }, i.updatePipelinePassInfo = function () {
          this.updateBloomPass(), this.updatePostProcessPass(), this.updateDeferredPassInfo();
        }, i.activate = function (t, i) {
          return e.prototype.activate.call(this, t, i), this.initPipelinePassInfo(), !0;
        }, i.updateDeferredPassInfo = function () {
          this.updateDeferredLightPass();
        }, i.updateDeferredLightPass = function () {
          if (this._deferredLightingMaterial) {
            this.shadows.enabled && (this._pipeline.macros.CC_RECEIVE_SHADOW = 1);
            var e = this._deferredLightingMaterial.passes[0];
            e.beginChangeStatesSilently(), e.tryCompile(), e.endChangeStatesSilently();
          }
        }, d(t, [{
          key: "antiAliasing",
          get: function get() {
            return this._antiAliasing;
          },
          set: function set(e) {
            if (this._antiAliasing = e, this._postprocessMaterial) {
              var t = this._postprocessMaterial.passes[0].defines;
              Object.assign(t, {
                ANTIALIAS_TYPE: e
              });
              var i = new Ge();
              i.initialize({
                effectAsset: this._postprocessMaterial.effectAsset,
                defines: t
              });

              for (var r = 0; r < i.passes.length; ++r) {
                i.passes[r].tryCompile();
              }

              this._postprocessMaterial = i;
            }
          }
        }, {
          key: "bloomMaterial",
          get: function get() {
            return this._bloomMaterial;
          },
          set: function set(e) {
            this._bloomMaterial !== e && e && (this._bloomMaterial = e, this.updatePipelinePassInfo());
          }
        }, {
          key: "postprocessMaterial",
          get: function get() {
            return this._postprocessMaterial;
          },
          set: function set(e) {
            this._postprocessMaterial !== e && e && (this._postprocessMaterial = e, this.updatePipelinePassInfo());
          }
        }, {
          key: "deferredLightingMaterial",
          get: function get() {
            return this._deferredLightingMaterial;
          },
          set: function set(e) {
            this._deferredLightingMaterial !== e && e && (this._deferredLightingMaterial = e, this.updatePipelinePassInfo());
          }
        }]), t;
      }(Fs),
          qs = [new Y(0, 0, 0, 1)],
          ks = function ks() {};

      ks.SIZE = 4 * (ks.COUNT = 4 + (ks.TEXTURE_SIZE_OFFSET = 0));

      var Xs,
          Ys,
          Ks,
          Zs,
          Js,
          js,
          $s,
          eo,
          to,
          io,
          ro = e("B", (Ms = Pe("BloomStage"), xs = Me(Ge), zs = Ce(), Ms((Qs = Ws = function (e) {
        function t() {
          var t;
          return (t = e.call(this) || this).threshold = 1, t.intensity = .8, t.iterations = 2, v(t, "_bloomMaterial", Us, W(t)), t._renderArea = new G(), t._bloomUBO = [], t;
        }

        w(t, e);
        var i = t.prototype;
        return i.initialize = function (t) {
          return e.prototype.initialize.call(this, t), !0;
        }, i.activate = function (t, i) {
          e.prototype.activate.call(this, t, i), this._bloomMaterial && (t.pipelineSceneData.bloomMaterial = this._bloomMaterial);
        }, i.destroy = function () {}, i.render = function (e) {
          var t,
              i = this._pipeline;

          if (i.generateBloomRenderData(), ((null === (t = e.window) || void 0 === t ? void 0 : t.swapchain) || i.macros.CC_PIPELINE_TYPE) && i.bloomEnabled && 0 !== i.pipelineSceneData.renderObjects.length) {
            if (0 === this._bloomUBO.length) for (var r = 0; r < 14; ++r) {
              this._bloomUBO[r] = i.device.createBuffer(new s(o.UNIFORM | o.TRANSFER_DST, h.HOST | h.DEVICE, ks.SIZE, ks.SIZE));
            }
            e.clearFlag & y.COLOR && (qs[0].x = e.clearColor.x, qs[0].y = e.clearColor.y, qs[0].z = e.clearColor.z), qs[0].w = e.clearColor.w, this._prefilterPass(e, i), this._downsamplePass(e, i), this._upsamplePass(e, i), this._combinePass(e, i);
          }
        }, i._prefilterPass = function (e, t) {
          t.generateRenderArea(e, this._renderArea), this._renderArea.width >>= 1, this._renderArea.height >>= 1;
          var i = t.commandBuffers[0],
              r = t.pipelineSceneData.bloomMaterial.passes[0],
              n = t.getPipelineRenderData(),
              a = n.bloom,
              s = new Float32Array(ks.COUNT);
          s[ks.TEXTURE_SIZE_OFFSET + 2] = this.threshold, i.updateBuffer(this._bloomUBO[0], s), i.beginRenderPass(a.renderPass, a.prefilterFramebuffer, this._renderArea, qs, 0, 0), i.bindDescriptorSet(Te.GLOBAL, t.descriptorSet), r.descriptorSet.bindBuffer(0, this._bloomUBO[0]), r.descriptorSet.bindTexture(1, n.outputRenderTargets[0]), r.descriptorSet.bindSampler(1, a.sampler), r.descriptorSet.update(), i.bindDescriptorSet(Te.MATERIAL, r.descriptorSet);
          var o = e.window.swapchain ? t.quadIAOffscreen : t.quadIAOnscreen,
              h = null,
              d = r.getShaderVariant();
          null != r && null != d && null != o && (h = Ee.getOrCreatePipelineState(t.device, r, d, a.renderPass, o)), null != h && (i.bindPipelineState(h), i.bindInputAssembler(o), i.draw(o)), i.endRenderPass();
        }, i._downsamplePass = function (e, t) {
          t.generateRenderArea(e, this._renderArea), this._renderArea.width >>= 1, this._renderArea.height >>= 1;

          for (var i = t.commandBuffers[0], r = t.pipelineSceneData.bloomMaterial, n = t.getPipelineRenderData().bloom, a = new Float32Array(ks.COUNT), s = 0; s < this.iterations; ++s) {
            a[ks.TEXTURE_SIZE_OFFSET + 0] = this._renderArea.width, a[ks.TEXTURE_SIZE_OFFSET + 1] = this._renderArea.height, i.updateBuffer(this._bloomUBO[s + 1], a), this._renderArea.width >>= 1, this._renderArea.height >>= 1, i.beginRenderPass(n.renderPass, n.downsampleFramebuffers[s], this._renderArea, qs, 0, 0);
            var o = r.passes[1 + s],
                h = o.getShaderVariant();
            o.descriptorSet.bindBuffer(0, this._bloomUBO[s + 1]), 0 === s ? o.descriptorSet.bindTexture(1, n.prefiterTex) : o.descriptorSet.bindTexture(1, n.downsampleTexs[s - 1]), o.descriptorSet.bindSampler(1, n.sampler), o.descriptorSet.update(), i.bindDescriptorSet(Te.MATERIAL, o.descriptorSet);
            var d = e.window.swapchain ? t.quadIAOffscreen : t.quadIAOnscreen,
                u = null;
            null != o && null != h && null != d && (u = Ee.getOrCreatePipelineState(t.device, o, h, n.renderPass, d)), null != u && (i.bindPipelineState(u), i.bindInputAssembler(d), i.draw(d)), i.endRenderPass();
          }
        }, i._upsamplePass = function (e, t) {
          var i = t.getPipelineRenderData().bloom;
          t.generateRenderArea(e, this._renderArea), this._renderArea.width >>= this.iterations + 1, this._renderArea.height >>= this.iterations + 1;

          for (var r = t.commandBuffers[0], n = t.pipelineSceneData.bloomMaterial, a = new Float32Array(ks.COUNT), s = 0; s < this.iterations; ++s) {
            var o = s + 6 + 1;
            a[ks.TEXTURE_SIZE_OFFSET + 0] = this._renderArea.width, a[ks.TEXTURE_SIZE_OFFSET + 1] = this._renderArea.height, r.updateBuffer(this._bloomUBO[o], a), this._renderArea.width <<= 1, this._renderArea.height <<= 1, r.beginRenderPass(i.renderPass, i.upsampleFramebuffers[this.iterations - 1 - s], this._renderArea, qs, 0, 0);
            var h = n.passes[7 + s],
                d = h.getShaderVariant();
            h.descriptorSet.bindBuffer(0, this._bloomUBO[o]), 0 === s ? h.descriptorSet.bindTexture(1, i.downsampleTexs[this.iterations - 1]) : h.descriptorSet.bindTexture(1, i.upsampleTexs[this.iterations - s]), h.descriptorSet.bindSampler(1, i.sampler), h.descriptorSet.update(), r.bindDescriptorSet(Te.MATERIAL, h.descriptorSet);
            var u = e.window.swapchain ? t.quadIAOffscreen : t.quadIAOnscreen,
                l = null;
            null != h && null != d && null != u && (l = Ee.getOrCreatePipelineState(t.device, h, d, i.renderPass, u)), null != l && (r.bindPipelineState(l), r.bindInputAssembler(u), r.draw(u)), r.endRenderPass();
          }
        }, i._combinePass = function (e, t) {
          t.generateRenderArea(e, this._renderArea);
          var i = t.commandBuffers[0],
              r = t.pipelineSceneData.bloomMaterial,
              n = t.getPipelineRenderData(),
              a = n.bloom,
              s = new Float32Array(ks.COUNT);
          s[ks.TEXTURE_SIZE_OFFSET + 3] = this.intensity, i.updateBuffer(this._bloomUBO[13], s), i.beginRenderPass(a.renderPass, a.combineFramebuffer, this._renderArea, qs, 0, 0), i.bindDescriptorSet(Te.GLOBAL, t.descriptorSet);
          var o = r.passes[13];
          o.descriptorSet.bindBuffer(0, this._bloomUBO[13]), o.descriptorSet.bindTexture(1, n.outputRenderTargets[0]), o.descriptorSet.bindTexture(2, a.upsampleTexs[0]), o.descriptorSet.bindSampler(1, a.sampler), o.descriptorSet.bindSampler(2, a.sampler), o.descriptorSet.update(), i.bindDescriptorSet(Te.MATERIAL, o.descriptorSet);
          var h = e.window.swapchain ? t.quadIAOffscreen : t.quadIAOnscreen,
              d = null,
              u = o.getShaderVariant();
          null != o && null != u && null != h && (d = Ee.getOrCreatePipelineState(t.device, o, u, a.renderPass, h)), null != d && (i.bindPipelineState(d), i.bindInputAssembler(h), i.draw(h)), i.endRenderPass();
        }, t;
      }(Vi), Ws.initInfo = {
        name: "BloomStage",
        priority: ir.BLOOM,
        tag: 0
      }, Us = m((Gs = Qs).prototype, "_bloomMaterial", [xs, Le, zs], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return null;
        }
      }), Hs = Gs)) || Hs)),
          no = e("M", Pe("MainFlow")((Ks = Ys = function (e) {
        function t() {
          return e.apply(this, arguments) || this;
        }

        w(t, e);
        var i = t.prototype;
        return i.initialize = function (t) {
          if (e.prototype.initialize.call(this, t), 0 === this._stages.length) {
            var i = new Ds();
            i.initialize(Ds.initInfo), this._stages.push(i);
            var r = new Ps();
            r.initialize(Ps.initInfo), this._stages.push(r);
            var n = new ro();
            n.initialize(ro.initInfo), this._stages.push(n);
            var a = new Cs();
            a.initialize(Cs.initInfo), this._stages.push(a);
          }

          return !0;
        }, i.activate = function (t) {
          e.prototype.activate.call(this, t);
        }, i.render = function (t) {
          e.prototype.render.call(this, t);
        }, i.destroy = function () {
          e.prototype.destroy.call(this);
        }, t;
      }(ki), Ys.initInfo = {
        name: rt,
        priority: sr.MAIN,
        stages: []
      }, Xs = Ks)) || Xs),
          ao = function (e) {
        function t() {
          for (var t, i = arguments.length, r = new Array(i), n = 0; n < i; n++) {
            r[n] = arguments[n];
          }

          return (t = e.call.apply(e, [this].concat(r)) || this).gbufferFrameBuffer = null, t.gbufferRenderTargets = [], t;
        }

        return w(t, e), t;
      }(function () {
        this.outputFrameBuffer = null, this.outputRenderTargets = [], this.outputDepth = null, this.sampler = null, this.bloom = null;
      }),
          so = (e("D", (Zs = Pe("DeferredPipeline"), Js = Me([Gn]), js = Ce(), Zs((io = function (e) {
        function t() {
          for (var t, i = arguments.length, r = new Array(i), n = 0; n < i; n++) {
            r[n] = arguments[n];
          }

          return (t = e.call.apply(e, [this].concat(r)) || this)._gbufferRenderPass = null, t._lightingRenderPass = null, v(t, "renderTextures", to, W(t)), t;
        }

        w(t, e);
        var i = t.prototype;
        return i.initialize = function (t) {
          if (e.prototype.initialize.call(this, t), 0 === this._flows.length) {
            var i = new Is();
            i.initialize(Is.initInfo), this._flows.push(i);
            var r = new no();
            r.initialize(no.initInfo), this._flows.push(r);
          }

          return !0;
        }, i.activate = function (t) {
          return this._macros = {
            CC_PIPELINE_TYPE: 1
          }, this._pipelineSceneData = new Vs(), !(!e.prototype.activate.call(this, t) || !this._activeRenderer(t) && (K(2402), 1));
        }, i.destroy = function () {
          this._destroyUBOs(), this._destroyQuadInputAssembler(), this._destroyDeferredData();

          for (var t = this._renderPasses.values(), i = t.next(); !i.done;) {
            i.value.destroy(), i = t.next();
          }

          return this._commandBuffers.length = 0, e.prototype.destroy.call(this);
        }, i.getPipelineRenderData = function () {
          return this._pipelineRenderData || this._generateDeferredRenderData(), this._pipelineRenderData;
        }, i._activeRenderer = function (e) {
          var t = this.device;

          this._commandBuffers.push(t.commandBuffer);

          var i = this.globalDSManager.pointSampler;
          this._descriptorSet.bindSampler(Fe, i), this._descriptorSet.bindTexture(Fe, Ne.get("default-texture").getGFXTexture()), this._descriptorSet.bindSampler(De, i), this._descriptorSet.bindTexture(De, Ne.get("default-texture").getGFXTexture()), this._descriptorSet.update();
          var r = new xn();
          if (!(r = this._createQuadInputAssembler()).quadIB || !r.quadVB || !r.quadIA) return !1;
          this._quadIB = r.quadIB, this._quadVBOffscreen = r.quadVB, this._quadIAOffscreen = r.quadIA;

          var n = this._createQuadInputAssembler();

          if (!n.quadIB || !n.quadVB || !n.quadIA) return !1;

          if (this._quadVBOnscreen = n.quadVB, this._quadIAOnscreen = n.quadIA, !this._gbufferRenderPass) {
            var a = new E();
            a.format = _.RGBA16F, a.loadOp = b.CLEAR, a.storeOp = O.STORE;
            var s = new E();
            s.format = _.RGBA16F, s.loadOp = b.CLEAR, s.storeOp = O.STORE;
            var o = new E();
            o.format = _.RGBA16F, o.loadOp = b.CLEAR, o.storeOp = O.STORE;
            var h = new T();
            h.format = _.DEPTH_STENCIL, h.depthLoadOp = b.CLEAR, h.depthStoreOp = O.STORE, h.stencilLoadOp = b.CLEAR, h.stencilStoreOp = O.STORE;
            var d = new F([a, s, o], h);
            this._gbufferRenderPass = t.createRenderPass(d);
          }

          if (!this._lightingRenderPass) {
            var u = new E();
            u.format = _.RGBA8, u.loadOp = b.CLEAR, u.storeOp = O.STORE, u.barrier = t.getGeneralBarrier(new R(I.NONE, I.COLOR_ATTACHMENT_WRITE));
            var l = new T();
            l.format = _.DEPTH_STENCIL, l.depthLoadOp = b.LOAD, l.depthStoreOp = O.DISCARD, l.stencilLoadOp = b.LOAD, l.stencilStoreOp = O.DISCARD, u.barrier = t.getGeneralBarrier(new R(I.DEPTH_STENCIL_ATTACHMENT_WRITE, I.DEPTH_STENCIL_ATTACHMENT_WRITE));
            var c = new F([u], l);
            this._lightingRenderPass = t.createRenderPass(c);
          }

          return this._width = e.width, this._height = e.height, this._generateDeferredRenderData(), !0;
        }, i._destroyUBOs = function () {
          this._descriptorSet && (this._descriptorSet.getBuffer(Re.BINDING).destroy(), this._descriptorSet.getBuffer(me.BINDING).destroy(), this._descriptorSet.getBuffer(Ie.BINDING).destroy(), this._descriptorSet.getTexture(Fe).destroy(), this._descriptorSet.getTexture(De).destroy());
        }, i._destroyDeferredData = function () {
          var e = this._pipelineRenderData;

          if (e) {
            e.gbufferFrameBuffer && e.gbufferFrameBuffer.destroy(), e.outputFrameBuffer && e.outputFrameBuffer.destroy(), e.outputDepth && e.outputDepth.destroy();

            for (var t = 0; t < e.gbufferRenderTargets.length; t++) {
              e.gbufferRenderTargets[t].destroy();
            }

            e.gbufferRenderTargets.length = 0;

            for (var i = 0; i < e.outputRenderTargets.length; i++) {
              e.outputRenderTargets[i].destroy();
            }

            e.outputRenderTargets.length = 0, this._destroyBloomData();
          }

          this._pipelineRenderData = null;
        }, i._ensureEnoughSize = function (e) {
          for (var t = this._width, i = this._height, r = 0; r < e.length; ++r) {
            var n = e[r].window;
            t = Math.max(n.width, t), i = Math.max(n.height, i);
          }

          t === this._width && i === this._height || (this._width = t, this._height = i, this._destroyDeferredData(), this._generateDeferredRenderData());
        }, i._generateDeferredRenderData = function () {
          for (var e = this, t = this.device, i = this._pipelineRenderData = new ao(), r = this.pipelineSceneData, n = 0; n < 3; ++n) {
            i.gbufferRenderTargets.push(t.createTexture(new x(z.TEX2D, H.COLOR_ATTACHMENT | H.SAMPLED, _.RGBA16F, this._width * r.shadingScale, this._height * r.shadingScale)));
          }

          i.outputDepth = t.createTexture(new x(z.TEX2D, H.DEPTH_STENCIL_ATTACHMENT | H.SAMPLED, _.DEPTH_STENCIL, this._width * r.shadingScale, this._height * r.shadingScale)), i.gbufferFrameBuffer = t.createFramebuffer(new N(this._gbufferRenderPass, i.gbufferRenderTargets, i.outputDepth)), i.outputRenderTargets.push(t.createTexture(new x(z.TEX2D, H.COLOR_ATTACHMENT | H.SAMPLED, _.RGBA16F, this._width * r.shadingScale, this._height * r.shadingScale))), i.outputFrameBuffer = t.createFramebuffer(new N(this._lightingRenderPass, i.outputRenderTargets, null)), i.sampler = this.globalDSManager.pointSampler, this.on(qi.ATTACHMENT_SCALE_CAHNGED, function (t) {
            i.sampler = t < 1 ? e.globalDSManager.pointSampler : e.globalDSManager.linearSampler, e.applyFramebufferRatio(i.gbufferFrameBuffer), e.applyFramebufferRatio(i.outputFrameBuffer);
          });
        }, t;
      }(zn), to = m((eo = io).prototype, "renderTextures", [Js, Le, js], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return [];
        }
      }), $s = eo)) || $s)), e("G", function (e) {
        function t() {
          for (var t, i = arguments.length, r = new Array(i), n = 0; n < i; n++) {
            r[n] = arguments[n];
          }

          return (t = e.call.apply(e, [this].concat(r)) || this).frame = null, t.container = null, t.canvas = null, t.renderType = -1, t.eventTargetOn = e.prototype.on, t.eventTargetOnce = e.prototype.once, t.config = {}, t.onStart = null, t.frameTime = 1e3 / 60, t.collisionMatrix = [], t.groupList = [], t._persistRootNodes = {}, t._gfxDevice = null, t._swapchain = null, t._configLoaded = !1, t._isCloning = !1, t._inited = !1, t._engineInited = !1, t._rendererInitialized = !1, t._paused = !0, t._frameRate = 60, t._intervalId = 0, t._initTime = 0, t._startTime = 0, t._deltaTime = 0, t._onEngineInitedCallback = [], t;
        }

        w(t, e);
        var i = t.prototype;
        return i.setFrameRate = function (e) {
          this.frameRate = e;
        }, i.getFrameRate = function () {
          return this.frameRate;
        }, i.step = function () {
          S.director.tick(this.frameTime / 1e3);
        }, i.pause = function () {
          this._paused || (this._paused = !0, this._intervalId && (window.cAF(this._intervalId), this._intervalId = 0));
        }, i.resume = function () {
          this._paused && (nt._clearEvents(), this._intervalId && (window.cAF(this._intervalId), this._intervalId = 0), this._paused = !1, this._updateCallback(), this._intervalId = window.rAF(this._frameCB));
        }, i.isPaused = function () {
          return this._paused;
        }, i.restart = function () {
          var e = this;
          return new Promise(function (e) {
            return S.director.once(S.Director.EVENT_END_FRAME, function () {
              return e();
            });
          }).then(function () {
            for (var i in e._persistRootNodes) {
              e.removePersistRootNode(e._persistRootNodes[i]);
            }

            return S.director.getScene().destroy(), S.Object._deferredDestroy(), S.director.reset(), S.profiler.reset(), e.pause(), e._setRenderPipelineNShowSplash().then(function () {
              e.resume(), e._safeEmit(t.EVENT_RESTART);
            });
          });
        }, i.end = function () {
          L.close();
        }, i.on = function (e, i, r, n) {
          return (this._engineInited && e === t.EVENT_ENGINE_INITED || this._inited && e === t.EVENT_GAME_INITED || this._rendererInitialized && e === t.EVENT_RENDERER_INITED) && i.call(r), this.eventTargetOn(e, i, r, n);
        }, i.once = function (e, i, r) {
          return this._engineInited && e === t.EVENT_ENGINE_INITED ? i.call(r) : this.eventTargetOnce(e, i, r);
        }, i.init = function (e) {
          var t = this;
          if (this._initConfig(e), this.config.assetOptions && S.assetManager.init(this.config.assetOptions), this.config.layers) for (var i = this.config.layers, r = 0; r < i.length; r++) {
            var n = i[r],
                a = Z(n.value);
            ke.addLayer(n.name, a);
          }
          return this._initEngine().then(function () {
            return t._initEvents(), S.director.root && S.director.root.dataPoolManager && S.director.root.dataPoolManager.jointTexturePool.registerCustomTextureLayouts(e.customJointTextureLayouts), t._engineInited;
          });
        }, i.run = function (e, t) {
          var i,
              r = this;
          return "function" != typeof e && e ? (i = this.init(e), this.onStart = null != t ? t : null) : this.onStart = null != e ? e : null, at.init(), Promise.resolve(i).then(function () {
            return r._setRenderPipelineNShowSplash();
          }).then(function () {
            st._init({
              configOrientation: "auto",
              exactFitScreen: !0
            });
          });
        }, i.addPersistRootNode = function (e) {
          if (S.Node.isNode(e) && e.uuid) {
            var t = e.uuid;

            if (!this._persistRootNodes[t]) {
              var i = S.director._scene;
              if (S.isValid(i)) if (e.parent) {
                if (!(e.parent instanceof S.Scene)) return void f(3801);
                if (e.parent !== i) return void f(3802);
                e._originalSceneId = i.uuid;
              } else e.parent = i;
              this._persistRootNodes[t] = e, e._persistNode = !0, S.assetManager._releaseManager._addPersistNodeRef(e);
            }
          } else f(3800);
        }, i.removePersistRootNode = function (e) {
          var t = e.uuid || "";
          e === this._persistRootNodes[t] && (delete this._persistRootNodes[t], e._persistNode = !1, e._originalSceneId = "", S.assetManager._releaseManager._removePersistNodeRef(e));
        }, i.isPersistRootNode = function (e) {
          return !!e._persistNode;
        }, i.onEngineInitedAsync = function (e) {
          this._onEngineInitedCallback.push(e);
        }, i._initEngine = function () {
          var e = this;

          this._initDevice();

          var i = S.director;
          return Promise.resolve(i._init()).then(function () {
            S.view.init(), J("Cocos Creator v" + j), e.emit(t.EVENT_ENGINE_INITED), e._engineInited = !0, S.internal.dynamicAtlasManager && (S.internal.dynamicAtlasManager.enabled = !M.CLEANUP_IMAGE_CACHE);
          }).then(function () {
            var t = e._onEngineInitedCallback.map(function (e) {
              return e();
            }).filter(Boolean);

            return e._onEngineInitedCallback.length = 0, Promise.all(t);
          });
        }, i._setAnimFrame = function () {
          var e = this._frameRate,
              t = window.requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame;
          60 !== e && 30 !== e ? (window.rAF = this._stTime.bind(this), window.cAF = this._ctTime) : (window.rAF = t || this._stTime.bind(this), window.cAF = window.cancelAnimationFrame || window.cancelRequestAnimationFrame || window.msCancelRequestAnimationFrame || window.mozCancelRequestAnimationFrame || window.oCancelRequestAnimationFrame || window.webkitCancelRequestAnimationFrame || window.msCancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.ocancelAnimationFrame || this._ctTime, this._updateCallback());
        }, i._stTime = function (e) {
          var t = performance.now(),
              i = Math.max(0, t - this._startTime),
              r = Math.max(0, this.frameTime - i);
          return window.setTimeout(e, r);
        }, i._ctTime = function (e) {
          window.clearTimeout(e);
        }, i._calculateDT = function (e) {
          return e || (e = performance.now()), this._deltaTime = e > this._startTime ? (e - this._startTime) / 1e3 : 0, this._deltaTime > t.DEBUG_DT_THRESHOLD && (this._deltaTime = this.frameTime / 1e3), this._startTime = e, this._deltaTime;
        }, i._updateCallback = function () {
          var e,
              t = this,
              i = S.director;

          if (30 === this._frameRate) {
            var r = !0;

            e = function e(_e2) {
              t._intervalId = window.rAF(t._frameCB), (r = !r) || i.tick(t._calculateDT(_e2));
            };
          } else e = function e(_e3) {
            i.tick(t._calculateDT(_e3)), t._intervalId = window.rAF(t._frameCB);
          };

          this._frameCB = e;
        }, i._runMainLoop = function () {
          if (this._inited && !$) {
            var e = this.config,
                t = S.director;
            ee(!!e.showFPS), t.startAnimation(), this.resume();
          }
        }, i._initConfig = function (e) {
          "number" != typeof e.debugMode && (e.debugMode = te.NONE), e.exposeClassName = !!e.exposeClassName, "number" != typeof e.frameRate && (e.frameRate = 60);
          var t = e.renderMode;
          ("number" != typeof t || t > 3 || t < 0) && (e.renderMode = 0), e.showFPS = !!e.showFPS, ie(e.debugMode), this.config = e, this._configLoaded = !0, this.frameRate = e.frameRate;
        }, i._determineRenderType = function () {
          var e = this.config,
              i = parseInt(e.renderMode, 10);
          this.renderType = t.RENDER_TYPE_CANVAS;
          var r = !1;
          if (1 === i ? (this.renderType = t.RENDER_TYPE_CANVAS, r = !0) : 0 === i || 2 === i ? (this.renderType = t.RENDER_TYPE_WEBGL, r = !0) : 3 === i && (this.renderType = t.RENDER_TYPE_HEADLESS, r = !0), !r) throw new Error(re(3820, i));
        }, i._initDevice = function () {
          if (!this._rendererInitialized) {
            var e = this.config.adapter;

            if (e && (this.canvas = e.canvas, this.frame = e.frame, this.container = e.container), this._determineRenderType(), this.renderType === t.RENDER_TYPE_WEBGL) {
              var i = new se(ht),
                  r = !!window.WebGL2RenderingContext,
                  n = window.navigator.userAgent.toLowerCase();
              (-1 !== n.indexOf("safari") && -1 === n.indexOf("chrome") || ot.browserType === ne.UC) && (r = !1);
              var a = [];
              r && S.WebGL2Device && a.push(S.WebGL2Device), S.WebGLDevice && a.push(S.WebGLDevice), S.EmptyDevice && a.push(S.EmptyDevice), ae.canvas = this.canvas;

              for (var s = 0; s < a.length && (this._gfxDevice = new a[s](), !this._gfxDevice.initialize(i)); s++) {
                ;
              }
            } else this.renderType === t.RENDER_TYPE_HEADLESS && S.EmptyDevice && (this._gfxDevice = new S.EmptyDevice(), this._gfxDevice.initialize(new se(ht)));

            if (!this._gfxDevice) return oe("can not support canvas rendering in 3D"), void (this.renderType = t.RENDER_TYPE_CANVAS);
            var o = new he(this.canvas),
                h = st.windowSize;
            o.width = h.width, o.height = h.height, this._swapchain = this._gfxDevice.createSwapchain(o), this.canvas.oncontextmenu = function () {
              return !1;
            };
          }
        }, i._initEvents = function () {
          L.on("show", this._onShow, this), L.on("hide", this._onHide, this);
        }, i._onHide = function () {
          this.emit(t.EVENT_HIDE), this.pause();
        }, i._onShow = function () {
          this.emit(t.EVENT_SHOW), this.resume();
        }, i._setRenderPipelineNShowSplash = function () {
          var e = this;
          return Promise.resolve(this._setupRenderPipeline()).then(function () {
            return Promise.resolve(e._showSplashScreen()).then(function () {
              e._inited = !0, e._initTime = performance.now(), e._runMainLoop(), e._safeEmit(t.EVENT_GAME_INITED), e.onStart && e.onStart();
            });
          });
        }, i._setupRenderPipeline = function () {
          var e = this,
              t = this.config.renderPipeline;
          return t ? new Promise(function (e, i) {
            S.assetManager.loadAny(t, function (t, r) {
              return !t && r instanceof zn ? e(r) : i(t);
            });
          }).then(function (t) {
            e._setRenderPipeline(t);
          }).catch(function (i) {
            de(i), de("Failed load render pipeline: " + t + ", engine failed to initialize, will fallback to default pipeline"), e._setRenderPipeline();
          }) : this._setRenderPipeline();
        }, i._showSplashScreen = function () {
          if (S.internal.SplashScreen) {
            var e = S.internal.SplashScreen.instance;
            return e.main(S.director.root), new Promise(function (t) {
              e.setOnFinish(function () {
                return t();
              }), e.loadFinish = !0;
            });
          }

          return null;
        }, i._setRenderPipeline = function (e) {
          S.director.root.setRenderPipeline(e) || this._setRenderPipeline(), this._rendererInitialized = !0, this._safeEmit(t.EVENT_RENDERER_INITED);
        }, i._safeEmit = function (e) {
          this.emit(e);
        }, d(t, [{
          key: "inited",
          get: function get() {
            return this._inited;
          }
        }, {
          key: "frameRate",
          get: function get() {
            return this._frameRate;
          },
          set: function set(e) {
            "number" != typeof e && (e = parseInt(e, 10), Number.isNaN(e) && (e = 60)), this._frameRate = e, this.frameTime = 1e3 / e, this._setAnimFrame();
          }
        }, {
          key: "deltaTime",
          get: function get() {
            return this._deltaTime;
          }
        }, {
          key: "totalTime",
          get: function get() {
            return performance.now() - this._initTime;
          }
        }, {
          key: "frameStartTime",
          get: function get() {
            return this._startTime;
          }
        }]), t;
      }(A)));

      so.EVENT_HIDE = "game_on_hide", so.EVENT_SHOW = "game_on_show", so.EVENT_LOW_MEMORY = "game_on_low_memory", so.EVENT_GAME_INITED = "game_inited", so.EVENT_ENGINE_INITED = "engine_inited", so.EVENT_RENDERER_INITED = "renderer_inited", so.EVENT_RESTART = "game_on_restart", so.RENDER_TYPE_CANVAS = 0, so.RENDER_TYPE_WEBGL = 1, so.RENDER_TYPE_OPENGL = 2, so.RENDER_TYPE_HEADLESS = 3, so.DEBUG_DT_THRESHOLD = 1, S.Game = so;
      var oo,
          ho = e("g", S.game = new so()),
          uo = e("k", {
        topLeft: S.v2(0, 0),
        topRight: S.v2(0, 0),
        top: S.v2(0, 0),
        bottomLeft: S.v2(0, 0),
        bottomRight: S.v2(0, 0),
        bottom: S.v2(0, 0),
        center: S.v2(0, 0),
        left: S.v2(0, 0),
        right: S.v2(0, 0),
        width: 0,
        height: 0,
        init: function init(e) {
          var t = this.width = e.width,
              i = this.height = e.height,
              r = e.x,
              n = e.y,
              a = n + i,
              s = r + t;
          this.topLeft.x = r, this.topLeft.y = a, this.topRight.x = s, this.topRight.y = a, this.top.x = r + t / 2, this.top.y = a, this.bottomLeft.x = r, this.bottomLeft.y = n, this.bottomRight.x = s, this.bottomRight.y = n, this.bottom.x = r + t / 2, this.bottom.y = n, this.center.x = r + t / 2, this.center.y = n + i / 2, this.left.x = r, this.left.y = n + i / 2, this.right.x = s, this.right.y = n + i / 2;
        }
      });
      S.visibleRect = uo;

      var lo = new dt(),
          co = ((oo = {})[M.ORIENTATION_AUTO] = ue.AUTO, oo[M.ORIENTATION_LANDSCAPE] = ue.LANDSCAPE, oo[M.ORIENTATION_PORTRAIT] = ue.PORTRAIT, oo),
          _o = e("V", function (e) {
        function t() {
          var t;
          (t = e.call(this) || this)._designResolutionSize = void 0, t._scaleX = void 0, t._scaleY = void 0, t._viewportRect = void 0, t._visibleRect = void 0, t._autoFullScreen = void 0, t._retinaEnabled = void 0, t._resizeCallback = void 0, t._resolutionPolicy = void 0, t._rpExactFit = void 0, t._rpShowAll = void 0, t._rpNoBorder = void 0, t._rpFixedHeight = void 0, t._rpFixedWidth = void 0;
          var i = fo,
              r = po;
          return t._designResolutionSize = new dt(0, 0), t._scaleX = 1, t._scaleY = 1, t._viewportRect = new lt(0, 0, 0, 0), t._visibleRect = new lt(0, 0, 0, 0), t._autoFullScreen = !1, t._retinaEnabled = !1, t._resizeCallback = null, t._rpExactFit = new go(i.EQUAL_TO_FRAME, r.EXACT_FIT), t._rpShowAll = new go(i.EQUAL_TO_FRAME, r.SHOW_ALL), t._rpNoBorder = new go(i.EQUAL_TO_FRAME, r.NO_BORDER), t._rpFixedHeight = new go(i.EQUAL_TO_FRAME, r.FIXED_HEIGHT), t._rpFixedWidth = new go(i.EQUAL_TO_FRAME, r.FIXED_WIDTH), t._resolutionPolicy = t._rpShowAll, t;
        }

        w(t, e);
        var i = t.prototype;
        return i.init = function () {
          var e = st.windowSize,
              t = e.width,
              i = e.height;
          this._designResolutionSize.width = t, this._designResolutionSize.height = i, this._viewportRect.width = t, this._viewportRect.height = i, this._visibleRect.width = t, this._visibleRect.height = i, lo.width = this._visibleRect.width, lo.height = this._visibleRect.height, uo && uo.init(this._visibleRect), ut.on("window-resize", this._updateAdaptResult, this), ut.on("orientation-change", this._updateAdaptResult, this), ut.on("fullscreen-change", this._updateAdaptResult, this);
        }, i.resizeWithBrowserSize = function (e) {
          ut.handleResizeEvent = e;
        }, i.setResizeCallback = function (e) {
          "function" != typeof e && null != e || (this._resizeCallback = e);
        }, i.setOrientation = function (e) {
          ut.orientation = co[e];
        }, i.adjustViewportMeta = function () {}, i.enableRetina = function (e) {
          this._retinaEnabled = !!e;
        }, i.isRetinaEnabled = function () {
          return this._retinaEnabled;
        }, i.enableAutoFullScreen = function (e) {
          e !== this._autoFullScreen && (this._autoFullScreen = e, e && st.requestFullScreen().catch(function () {}));
        }, i.isAutoFullScreenEnabled = function () {
          return this._autoFullScreen;
        }, i.setCanvasSize = function (e, t) {
          ut.resolutionScale = 1;
          var i = ut.devicePixelRatio,
              r = new dt(e * i, t * i);
          st.windowSize = r;
        }, i.getCanvasSize = function () {
          return st.windowSize;
        }, i.getFrameSize = function () {
          var e = ut.devicePixelRatio,
              t = st.windowSize;
          return t.width /= e, t.height /= e, t;
        }, i.setFrameSize = function (e, t) {
          var i = ut.devicePixelRatio;
          st.windowSize = new dt(e * i, t * i);
        }, i.getVisibleSize = function () {
          return new dt(this._visibleRect.width, this._visibleRect.height);
        }, i.getVisibleSizeInPixel = function () {
          return new dt(this._visibleRect.width * this._scaleX, this._visibleRect.height * this._scaleY);
        }, i.getVisibleOrigin = function () {
          return new ge(this._visibleRect.x, this._visibleRect.y);
        }, i.getVisibleOriginInPixel = function () {
          return new ge(this._visibleRect.x * this._scaleX, this._visibleRect.y * this._scaleY);
        }, i.getResolutionPolicy = function () {
          return this._resolutionPolicy;
        }, i._updateResolutionPolicy = function (e) {
          if (e instanceof go) this._resolutionPolicy = e;else {
            var t = go;
            e === t.EXACT_FIT && (this._resolutionPolicy = this._rpExactFit), e === t.SHOW_ALL && (this._resolutionPolicy = this._rpShowAll), e === t.NO_BORDER && (this._resolutionPolicy = this._rpNoBorder), e === t.FIXED_HEIGHT && (this._resolutionPolicy = this._rpFixedHeight), e === t.FIXED_WIDTH && (this._resolutionPolicy = this._rpFixedWidth);
          }
        }, i.setResolutionPolicy = function (e) {
          this._updateResolutionPolicy(e);

          var t = So.getDesignResolutionSize();
          So.setDesignResolutionSize(t.width, t.height, e);
        }, i.setDesignResolutionSize = function (e, t, i) {
          if (e > 0 && t > 0) {
            this._updateResolutionPolicy(i);

            var r = this._resolutionPolicy;
            r && r.preApply(this), this._designResolutionSize.width = e, this._designResolutionSize.height = t;
            var n = r.apply(this, this._designResolutionSize);

            if (n.scale && 2 === n.scale.length && (this._scaleX = n.scale[0], this._scaleY = n.scale[1]), n.viewport) {
              var a = this._viewportRect,
                  s = this._visibleRect,
                  o = n.viewport;
              a.x = o.x, a.y = o.y, a.width = o.width, a.height = o.height, s.x = 0, s.y = 0, s.width = o.width / this._scaleX, s.height = o.height / this._scaleY;
            }

            r.postApply(this), lo.width = this._visibleRect.width, lo.height = this._visibleRect.height, uo && uo.init(this._visibleRect), this.emit("design-resolution-changed");
          } else K(2200);
        }, i.getDesignResolutionSize = function () {
          return new dt(this._designResolutionSize.width, this._designResolutionSize.height);
        }, i.setRealPixelResolution = function (e, t, i) {
          this.setDesignResolutionSize(e, t, i);
        }, i.getViewportRect = function () {
          return this._viewportRect;
        }, i.getScaleX = function () {
          return this._scaleX;
        }, i.getScaleY = function () {
          return this._scaleY;
        }, i.getDevicePixelRatio = function () {
          return ut.devicePixelRatio;
        }, i.convertToLocationInView = function (e, t, i, r) {
          void 0 === r && (r = new ge());
          var n = ut.devicePixelRatio * (e - i.left),
              a = ut.devicePixelRatio * (i.top + i.height - t);
          return ut.isFrameRotated ? (r.x = st.windowSize.width - a, r.y = n) : (r.x = n, r.y = a), r;
        }, i._convertToUISpace = function (e) {
          var t = this._viewportRect;
          e.x = (e.x - t.x) / this._scaleX, e.y = (e.y - t.y) / this._scaleY;
        }, i._updateAdaptResult = function () {
          var e;
          S.director.root.resize(st.windowSize.width, st.windowSize.height);
          var t = this._designResolutionSize.width,
              i = this._designResolutionSize.height;
          t > 0 && this.setDesignResolutionSize(t, i, this._resolutionPolicy), this.emit("canvas-resize"), null === (e = this._resizeCallback) || void 0 === e || e.call(this);
        }, t;
      }(A));

      _o.instance = void 0;

      var fo = function () {
        function e() {
          this.name = "ContainerStrategy";
        }

        var t = e.prototype;
        return t.preApply = function () {}, t.apply = function () {}, t.postApply = function () {}, t._setupCanvas = function () {
          var e = ho.canvas;

          if (e) {
            var t = st.windowSize;
            e.width = t.width, e.height = t.height;
          }
        }, e;
      }();

      fo.EQUAL_TO_FRAME = void 0, fo.PROPORTION_TO_FRAME = void 0;

      var po = function () {
        function e() {
          this.name = "ContentStrategy", this._result = void 0, this._result = {
            scale: [1, 1],
            viewport: null
          };
        }

        var t = e.prototype;
        return t.preApply = function () {}, t.apply = function () {
          return {
            scale: [1, 1]
          };
        }, t.postApply = function () {}, t._buildResult = function (e, t, i, r, n, a) {
          Math.abs(e - i) < 2 && (i = e), Math.abs(t - r) < 2 && (r = t);
          var s = new lt(Math.round((e - i) / 2), Math.round((t - r) / 2), i, r);
          return this._result.scale = [n, a], this._result.viewport = s, this._result;
        }, e;
      }();

      po.EXACT_FIT = void 0, po.SHOW_ALL = void 0, po.NO_BORDER = void 0, po.FIXED_HEIGHT = void 0, po.FIXED_WIDTH = void 0, function () {
        var e = function (e) {
          function t() {
            for (var t, i = arguments.length, r = new Array(i), n = 0; n < i; n++) {
              r[n] = arguments[n];
            }

            return (t = e.call.apply(e, [this].concat(r)) || this).name = "EqualToFrame", t;
          }

          return w(t, e), t.prototype.apply = function () {
            ut.isProportionalToFrame = !1, this._setupCanvas();
          }, t;
        }(fo),
            t = function (e) {
          function t() {
            for (var t, i = arguments.length, r = new Array(i), n = 0; n < i; n++) {
              r[n] = arguments[n];
            }

            return (t = e.call.apply(e, [this].concat(r)) || this).name = "ProportionalToFrame", t;
          }

          return w(t, e), t.prototype.apply = function () {
            ut.isProportionalToFrame = !0, this._setupCanvas();
          }, t;
        }(fo);

        fo.EQUAL_TO_FRAME = new e(), fo.PROPORTION_TO_FRAME = new t();

        var i = function (e) {
          function t() {
            for (var t, i = arguments.length, r = new Array(i), n = 0; n < i; n++) {
              r[n] = arguments[n];
            }

            return (t = e.call.apply(e, [this].concat(r)) || this).name = "ExactFit", t;
          }

          return w(t, e), t.prototype.apply = function (e, t) {
            var i = st.windowSize,
                r = i.width,
                n = i.height,
                a = r / t.width,
                s = n / t.height;
            return this._buildResult(r, n, r, n, a, s);
          }, t;
        }(po),
            r = function (e) {
          function t() {
            for (var t, i = arguments.length, r = new Array(i), n = 0; n < i; n++) {
              r[n] = arguments[n];
            }

            return (t = e.call.apply(e, [this].concat(r)) || this).name = "ShowAll", t;
          }

          return w(t, e), t.prototype.apply = function (e, t) {
            var i,
                r,
                n = st.windowSize,
                a = n.width,
                s = n.height,
                o = t.width,
                h = t.height,
                d = a / o,
                u = s / h,
                l = 0;
            return d < u ? (i = a, r = h * (l = d)) : (i = o * (l = u), r = s), this._buildResult(a, s, i, r, l, l);
          }, t;
        }(po),
            n = function (e) {
          function t() {
            for (var t, i = arguments.length, r = new Array(i), n = 0; n < i; n++) {
              r[n] = arguments[n];
            }

            return (t = e.call.apply(e, [this].concat(r)) || this).name = "NoBorder", t;
          }

          return w(t, e), t.prototype.apply = function (e, t) {
            var i,
                r,
                n,
                a = st.windowSize,
                s = a.width,
                o = a.height,
                h = t.width,
                d = t.height,
                u = s / h,
                l = o / d;
            return u < l ? (r = h * (i = l), n = o) : (r = s, n = d * (i = u)), this._buildResult(s, o, r, n, i, i);
          }, t;
        }(po),
            a = function (e) {
          function t() {
            for (var t, i = arguments.length, r = new Array(i), n = 0; n < i; n++) {
              r[n] = arguments[n];
            }

            return (t = e.call.apply(e, [this].concat(r)) || this).name = "FixedHeight", t;
          }

          return w(t, e), t.prototype.apply = function (e, t) {
            var i = st.windowSize,
                r = i.width,
                n = i.height,
                a = n / t.height,
                s = r,
                o = n;
            return this._buildResult(r, n, s, o, a, a);
          }, t;
        }(po),
            s = function (e) {
          function t() {
            for (var t, i = arguments.length, r = new Array(i), n = 0; n < i; n++) {
              r[n] = arguments[n];
            }

            return (t = e.call.apply(e, [this].concat(r)) || this).name = "FixedWidth", t;
          }

          return w(t, e), t.prototype.apply = function (e, t) {
            var i = st.windowSize,
                r = i.width,
                n = i.height,
                a = r / t.width,
                s = r,
                o = n;
            return this._buildResult(r, n, s, o, a, a);
          }, t;
        }(po);

        po.EXACT_FIT = new i(), po.SHOW_ALL = new r(), po.NO_BORDER = new n(), po.FIXED_HEIGHT = new a(), po.FIXED_WIDTH = new s();
      }();
      var go = e("R", function () {
        function e(e, t) {
          this.name = "ResolutionPolicy", this._containerStrategy = void 0, this._contentStrategy = void 0, this._containerStrategy = null, this._contentStrategy = null, this.setContainerStrategy(e), this.setContentStrategy(t);
        }

        var t = e.prototype;
        return t.preApply = function (e) {
          this._contentStrategy.preApply(e);
        }, t.apply = function (e, t) {
          return this._containerStrategy.apply(e, t), this._contentStrategy.apply(e, t);
        }, t.postApply = function (e) {
          this._contentStrategy.postApply(e);
        }, t.setContainerStrategy = function (e) {
          e instanceof fo && (this._containerStrategy = e);
        }, t.setContentStrategy = function (e) {
          e instanceof po && (this._contentStrategy = e);
        }, d(e, [{
          key: "canvasSize",
          get: function get() {
            return st.windowSize;
          }
        }]), e;
      }());
      go.EXACT_FIT = 0, go.NO_BORDER = 1, go.SHOW_ALL = 2, go.FIXED_HEIGHT = 3, go.FIXED_WIDTH = 4, go.UNKNOWN = 5, go.ContainerStrategy = fo, go.ContentStrategy = po, S.ResolutionPolicy = go;
      var So = e("v", _o.instance = S.view = new _o());
      S.winSize = lo, ct(_o.prototype, "View.prototype", [{
        name: "isAntiAliasEnabled",
        suggest: "The API of Texture2d have been largely modified, no alternative"
      }, {
        name: "enableAntiAlias",
        suggest: "The API of Texture2d have been largely modified, no alternative"
      }]), _t(_o.prototype, "View.prototype", [{
        name: "adjustViewportMeta"
      }, {
        name: "enableAutoFullScreen",
        suggest: "use screen.requestFullScreen() instead."
      }, {
        name: "isAutoFullScreenEnabled"
      }, {
        name: "setCanvasSize",
        suggest: "setting size in CSS pixels is not recommended, please use screen.windowSize instead."
      }, {
        name: "getCanvasSize",
        suggest: "please use screen.windowSize instead."
      }, {
        name: "getFrameSize",
        suggest: "getting size in CSS pixels is not recommended, please use screen.windowSize instead."
      }, {
        name: "setFrameSize",
        suggest: "setting size in CSS pixels is not recommended, please use screen.windowSize instead."
      }, {
        name: "getDevicePixelRatio",
        suggest: "use screen.devicePixelRatio instead."
      }, {
        name: "convertToLocationInView"
      }, {
        name: "enableRetina"
      }, {
        name: "isRetinaEnabled"
      }]), _t(S, "cc", [{
        name: "winSize",
        suggest: "please use view.getVisibleSize() instead."
      }]), _t(ot, "sys", [{
        name: "capabilities",
        suggest: "please use sys.hasFeature() method instead."
      }]), ft(ot, "sys", ["UNKNOWN", "ENGLISH", "CHINESE", "FRENCH", "ITALIAN", "GERMAN", "SPANISH", "DUTCH", "RUSSIAN", "KOREAN", "JAPANESE", "HUNGARIAN", "PORTUGUESE", "ARABIC", "NORWEGIAN", "POLISH", "TURKISH", "UKRAINIAN", "ROMANIAN", "BULGARIAN"].map(function (e) {
        return {
          name: "LANGUAGE_" + e,
          newName: e,
          target: ot.Language,
          targetName: "sys.Language"
        };
      })), ft(ot, "sys", ["UNKNOWN", "IOS", "ANDROID", "WINDOWS", "LINUX", "OSX"].map(function (e) {
        return {
          name: "OS_" + e,
          newName: e,
          target: ot.OS,
          targetName: "sys.OS"
        };
      })), ft(ot, "sys", ["UNKNOWN", "WECHAT", "ANDROID", "IE", "EDGE", "QQ", "MOBILE_QQ", "UC", "UCBS", "BAIDU_APP", "BAIDU", "MAXTHON", "OPERA", "OUPENG", "MIUI", "FIREFOX", "SAFARI", "CHROME", "LIEBAO", "QZONE", "SOUGOU", "HUAWEI"].map(function (e) {
        return {
          name: "BROWSER_TYPE_" + e,
          newName: e,
          target: ot.BrowserType,
          targetName: "sys.BrowserType"
        };
      })), ft(ot, "sys", [{
        name: "BROWSER_TYPE_360",
        newName: "BROWSER_360",
        target: ot.BrowserType,
        targetName: "sys.BrowserType"
      }]), ft(ot, "sys", ["UNKNOWN", "EDITOR_PAGE", "EDITOR_CORE", "MOBILE_BROWSER", "DESKTOP_BROWSER", "WIN32", "MACOS", "IOS", "ANDROID", "OHOS", "WECHAT_GAME", "BAIDU_MINI_GAME", "XIAOMI_QUICK_GAME", "ALIPAY_MINI_GAME", "BYTEDANCE_MINI_GAME", "OPPO_MINI_GAME", "VIVO_MINI_GAME", "HUAWEI_QUICK_GAME", "COCOSPLAY", "LINKSURE_MINI_GAME", "QTT_MINI_GAME"].map(function (e) {
        return {
          name: e,
          target: ot.Platform,
          targetName: "sys.Platform"
        };
      })), ft(ot, "sys", [{
        name: "IPHONE",
        newName: "IOS",
        target: ot.Platform,
        targetName: "sys.Platform"
      }, {
        name: "IPAD",
        newName: "IOS",
        target: ot.Platform,
        targetName: "sys.Platform"
      }]), ct(ot, "sys", ["LINUX", "BLACKBERRY", "NACL", "EMSCRIPTEN", "TIZEN", "WINRT", "WP8", "QQ_PLAY", "FB_PLAYABLE_ADS"].map(function (e) {
        return {
          name: e
        };
      })), ft(ot, "sys", [{
        name: "windowPixelResolution",
        target: st,
        targetName: "screen",
        newName: "windowSize"
      }]), _t(st, "screen", [{
        name: "autoFullScreen",
        suggest: "please use screen.requestFullScreen() instead."
      }, {
        name: "disableAutoFullScreen"
      }]);
    }
  };
}); 
 			}); 
		define("__plugin__/wx0446ba2621dda60a/deprecated-5f7f37d5.js", function(require, module, exports){ 			
"use strict";

System.register(["./texture-barrier-60b5983b.js", "./json-asset-933a1d4c.js", "./index-f2b92470.js", "./deprecated-26630860.js", "./deprecated-ef6bb945.js", "./renderable-2d-e2838949.js"], function (e) {
  "use strict";

  var t, n, o, r, a, i, s, c, m, p, u, h, C, l, _, d, f, y, b, g, v, R, E, S, T, D, A, w, z, O, N, G;

  return {
    setters: [function (e) {
      t = e.bT, n = e.l, o = e.bv, r = e.bU, a = e.c0, i = e.c1, s = e.b$, c = e.bX;
    }, function (e) {
      m = e.bW, p = e.dP, u = e.cd, h = e.ds, C = e.ch, l = e.dQ, _ = e.bm, d = e.Q, f = e.bZ, y = e.dR, b = e.cg, g = e.cc, v = e.a$, R = e.bX, E = e.ay, S = e.ax, T = e.a5, D = e.az;
    }, function () {}, function (e) {
      A = e.k, w = e.v;
    }, function (e) {
      z = e.C;
    }, function (e) {
      O = e.U, N = e.b, G = e.R;
    }],
    execute: function execute() {
      var x,
          P,
          U,
          W,
          j,
          F,
          I,
          H,
          M,
          V,
          k,
          L,
          X,
          B,
          Y,
          Q = e("R", m("cc.RenderRoot2D")(x = h(100)(x = C()(x = l(O)(x = p(x = u(x = function (e) {
        function o() {
          return e.apply(this, arguments) || this;
        }

        t(o, e);
        var r = o.prototype;
        return r.onEnable = function () {
          n.director.root.batcher2D.addScreen(this);
        }, r.onDisable = function () {
          n.director.root.batcher2D.removeScreen(this);
        }, r.onDestroy = function () {
          n.director.root.batcher2D.removeScreen(this);
        }, o;
      }(_)) || x) || x) || x) || x) || x) || x),
          $ = new d(),
          K = o({
        OVERLAY: 0,
        INTERSPERSE: 1
      }),
          Z = e("C", (P = m("cc.Canvas"), U = b(), W = h(100), j = C(), F = f(z), I = g(), H = g(), M = f(z), P(V = U(V = W(V = j(V = u(V = p((B = function (e) {
        function n() {
          var t;
          return t = e.call(this) || this, i(t, "_cameraComponent", L, s(t)), i(t, "_alignCanvasWithScreen", X, s(t)), t._thisOnCameraResized = void 0, t._fitDesignResolution = void 0, t._pos = new d(), t._renderMode = K.OVERLAY, t._thisOnCameraResized = t._onResizeCamera.bind(s(t)), t;
        }

        t(n, e);
        var o = n.prototype;
        return o.__preload = function () {
          var e = this.getComponent("cc.Widget");
          e && e.updateAlignment(), this._cameraComponent && (this._cameraComponent._createCamera(), this._cameraComponent.node.on(z.TARGET_TEXTURE_CHANGE, this._thisOnCameraResized)), this._onResizeCamera(), this.node.on(y.TRANSFORM_CHANGED, this._thisOnCameraResized);
        }, o.onEnable = function () {
          e.prototype.onEnable.call(this), this._cameraComponent && this._cameraComponent.node.on(z.TARGET_TEXTURE_CHANGE, this._thisOnCameraResized);
        }, o.onDisable = function () {
          e.prototype.onDisable.call(this), this._cameraComponent && this._cameraComponent.node.off(z.TARGET_TEXTURE_CHANGE, this._thisOnCameraResized);
        }, o.onDestroy = function () {
          e.prototype.onDestroy.call(this), this.node.off(y.TRANSFORM_CHANGED, this._thisOnCameraResized);
        }, o._onResizeCamera = function () {
          if (this._cameraComponent && this._alignCanvasWithScreen) {
            if (this._cameraComponent.targetTexture) this._cameraComponent.orthoHeight = A.height / 2;else {
              var e = v.windowSize;
              this._cameraComponent.orthoHeight = e.height / w.getScaleY() / 2;
            }
            this.node.getWorldPosition($), this._cameraComponent.node.setWorldPosition($.x, $.y, 1e3);
          }
        }, o._getViewPriority = function () {
          if (this._cameraComponent) {
            var e,
                t = null === (e = this.cameraComponent) || void 0 === e ? void 0 : e.priority;
            return this._renderMode === K.OVERLAY ? t | 1 << 30 : t & ~(1 << 30);
          }

          return 0;
        }, r(n, [{
          key: "renderMode",
          get: function get() {
            return this._renderMode;
          },
          set: function set(e) {
            this._renderMode = e, this._cameraComponent && (this._cameraComponent.priority = this._getViewPriority());
          }
        }, {
          key: "cameraComponent",
          get: function get() {
            return this._cameraComponent;
          },
          set: function set(e) {
            this._cameraComponent !== e && (this._cameraComponent = e, this._onResizeCamera());
          }
        }, {
          key: "alignCanvasWithScreen",
          get: function get() {
            return this._alignCanvasWithScreen;
          },
          set: function set(e) {
            this._alignCanvasWithScreen = e, this._onResizeCamera();
          }
        }]), n;
      }(Q), a((k = B).prototype, "cameraComponent", [F, I], Object.getOwnPropertyDescriptor(k.prototype, "cameraComponent"), k.prototype), a(k.prototype, "alignCanvasWithScreen", [H], Object.getOwnPropertyDescriptor(k.prototype, "alignCanvasWithScreen"), k.prototype), L = a(k.prototype, "_cameraComponent", [M], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return null;
        }
      }), X = a(k.prototype, "_alignCanvasWithScreen", [R], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !0;
        }
      }), V = k)) || V) || V) || V) || V) || V) || V));
      n.Canvas = Z;
      var q = e("U", m("cc.UIComponent")(Y = l(O)(Y = h(110)(Y = p(Y = u(Y = function (e) {
        function n() {
          for (var t, n = arguments.length, o = new Array(n), r = 0; r < n; r++) {
            o[r] = arguments[r];
          }

          return (t = e.call.apply(e, [this].concat(o)) || this)._lastParent = null, t.stencilStage = N.DISABLED, t;
        }

        t(n, e);
        var o = n.prototype;
        return o.__preload = function () {
          this.node._uiProps.uiComp = this;
        }, o.onEnable = function () {}, o.onDisable = function () {}, o.onDestroy = function () {
          this.node._uiProps.uiComp === this && (this.node._uiProps.uiComp = null);
        }, o.updateAssembler = function () {}, o.postUpdateAssembler = function () {}, o.markForUpdateRenderData = function () {}, o.setNodeDirty = function () {}, o.setTextureDirty = function () {}, n;
      }(_)) || Y) || Y) || Y) || Y) || Y);
      E(q.prototype, "UIComponent", [{
        name: "_visibility"
      }, {
        name: "setVisibility"
      }]), E(G.prototype, "Renderable2D.prototype", [{
        name: "srcBlendFactor"
      }, {
        name: "dstBlendFactor"
      }]), S(Z.prototype, "Canvas.prototype", [{
        name: "camera",
        newName: "cameraComponent.camera",
        customGetter: function customGetter() {
          return this._cameraComponent.camera;
        }
      }, {
        name: "clearFlag",
        newName: "cameraComponent.clearFlags",
        customGetter: function customGetter() {
          return this._cameraComponent ? this._cameraComponent.clearFlags : 0;
        },
        customSetter: function customSetter(e) {
          this._cameraComponent && (this._cameraComponent.clearFlags = e);
        }
      }, {
        name: "color",
        newName: "cameraComponent.clearColor",
        customGetter: function customGetter() {
          return this._cameraComponent ? this._cameraComponent.clearColor : T.BLACK;
        },
        customSetter: function customSetter(e) {
          this._cameraComponent && (this._cameraComponent.clearColor = e);
        }
      }, {
        name: "priority",
        newName: "cameraComponent.priority",
        customGetter: function customGetter() {
          return this._cameraComponent ? this._cameraComponent.priority : 0;
        },
        customSetter: function customSetter(e) {
          this._cameraComponent && (this._cameraComponent.priority = e);
        }
      }, {
        name: "targetTexture",
        newName: "cameraComponent.targetTexture",
        customGetter: function customGetter() {
          return this._cameraComponent ? this._cameraComponent.targetTexture : null;
        },
        customSetter: function customSetter(e) {
          this._cameraComponent && (this._cameraComponent.targetTexture = e);
        }
      }, {
        name: "visibility",
        newName: "cameraComponent.visibility",
        customGetter: function customGetter() {
          return this._cameraComponent ? this._cameraComponent.visibility : 0;
        }
      }]), D(O.prototype, "UITransform.prototype", [{
        name: "priority",
        suggest: "Please use setSiblingIndex to change index of the current node in its parent's children array."
      }]), n.UITransformComponent = O, c.setClassAlias(O, "cc.UITransformComponent"), c.setClassAlias(G, "cc.RenderComponent"), n.CanvasComponent = Z, c.setClassAlias(Z, "cc.CanvasComponent");
    }
  };
}); 
 			}); 
		define("__plugin__/wx0446ba2621dda60a/deprecated-6c081405.js", function(require, module, exports){ 			
"use strict";

System.register(["./texture-barrier-60b5983b.js", "./json-asset-933a1d4c.js", "./mesh-f5415e9d.js"], function () {
  "use strict";

  var e, t, r;
  return {
    setters: [function () {}, function (r) {
      e = r.ax, t = r.ay;
    }, function (e) {
      r = e.M;
    }],
    execute: function execute() {
      e(r.prototype, "Mesh.prototype", [{
        name: "renderingMesh",
        newName: "renderingSubMeshes"
      }]), t(r.prototype, "Mesh.prototype", [{
        name: "hasFlatBuffers"
      }, {
        name: "destroyFlatBuffers"
      }]);
    }
  };
}); 
 			}); 
		define("__plugin__/wx0446ba2621dda60a/deprecated-e75308d4.js", function(require, module, exports){ 			
"use strict";

System.register(["./texture-barrier-60b5983b.js", "./json-asset-933a1d4c.js", "./renderable-component-7c6600ed.js", "./mesh-f5415e9d.js", "./mesh-renderer-fb3b7695.js", "./skeleton-b0039cea.js", "./skeletal-animation-utils-121f35a2.js"], function (t) {
  "use strict";

  var e, i, n, r, o, s, a, u, l, f, h, d, c, p, _, m, v, y, b, g, w, x, M, k, I, A, T, B, N, S, E, j, P, O, R, D, C, z, U, F, H, L, V, J, K, W, G, Z, Y, q, X, $, Q, tt, et, it, nt, rt, ot, st, at, ut, lt, ft, ht;

  return {
    setters: [function (t) {
      e = t.as, i = t.x, n = t.y, r = t.bU, o = t.a$, s = t.m, a = t.u, u = t.al, l = t.o, f = t.q, h = t.i, d = t.bT, c = t.d, p = t.l, _ = t.bW, m = t.c0, v = t.c1, y = t.b$, b = t.aC, g = t.a_, w = t.bH, x = t.af, M = t.T, k = t.bX;
    }, function (t) {
      I = t.W, A = t.Q, T = t.Z, B = t.bJ, N = t.dt, S = t.du, E = t.B, j = t.dv, P = t.dw, O = t.dx, R = t.bW, D = t.bZ, C = t.b6, z = t.cd, U = t.cg, F = t.ds, H = t.ch, L = t.cc, V = t.aW, J = t.b$, K = t.aT, W = t.dy, G = t.c_, Z = t.df, Y = t.dz, q = t.V, X = t.bX, $ = t.ci, Q = t.dg, tt = t.dh;
    }, function (t) {
      et = t.T, it = t.M;
    }, function (t) {
      nt = t.M;
    }, function (t) {
      rt = t.a, ot = t.M;
    }, function (t) {
      st = t.S;
    }, function (t) {
      at = t.g, ut = t.S, lt = t.d, ft = t.a, ht = t.b;
    }],
    execute: function execute() {
      var dt = new e(i.POINT, i.POINT, i.NONE, n.CLAMP, n.CLAMP, n.CLAMP),
          ct = function ct(t, e, i) {
        t[e + 0] = i.m00, t[e + 1] = i.m01, t[e + 2] = i.m02, t[e + 3] = i.m12, t[e + 4] = i.m04, t[e + 5] = i.m05, t[e + 6] = i.m06, t[e + 7] = i.m13, t[e + 8] = i.m08, t[e + 9] = i.m09, t[e + 10] = i.m10, t[e + 11] = i.m14;
      };

      function pt(t, e) {
        var i = 4 / Math.sqrt(e);
        return 12 * Math.ceil(Math.max(480 * i, t) / 12);
      }

      new I(), new I(), new A(), new I(), new A();

      var _t = new A(),
          mt = new A(),
          vt = new A(),
          yt = new A(),
          bt = new T(),
          gt = new T(),
          wt = new B(),
          xt = Number.MAX_SAFE_INTEGER,
          Mt = (t("J", function () {
        function t(t) {
          this._device = void 0, this._pool = void 0, this._textureBuffers = new Map(), this._formatSize = void 0, this._pixelsPerJoint = void 0, this._customPool = void 0, this._chunkIdxMap = new Map(), this._device = t;

          var e = function (t) {
            return t.getFormatFeatures(s.RGBA32F) & a.SAMPLED_TEXTURE ? s.RGBA32F : s.RGBA8;
          }(this._device);

          this._formatSize = o[e].size, this._pixelsPerJoint = 48 / this._formatSize, this._pool = new et(t), this._pool.initialize({
            format: e,
            roundUpFn: pt
          }), this._customPool = new et(t), this._customPool.initialize({
            format: e,
            roundUpFn: pt
          });
        }

        var e = t.prototype;
        return e.clear = function () {
          this._pool.destroy(), this._textureBuffers.clear();
        }, e.registerCustomTextureLayouts = function (t) {
          for (var e = 0; e < t.length; e++) {
            for (var i = t[e], n = this._customPool.createChunk(i.textureLength), r = 0; r < i.contents.length; r++) {
              var o = i.contents[r],
                  s = o.skeleton;

              this._chunkIdxMap.set(s, n);

              for (var a = 0; a < o.clips.length; a++) {
                var u = o.clips[a];

                this._chunkIdxMap.set(s ^ u, n);
              }
            }
          }
        }, e.getDefaultPoseTexture = function (t, e, i) {
          var n = 0 ^ t.hash,
              r = this._textureBuffers.get(n) || null;
          if (r && r.bounds.has(e.hash)) return r.refCount++, r;
          var o = t.joints,
              s = t.bindposes,
              a = null,
              u = !1,
              l = o.length;
          if (r) r.refCount++;else {
            var f = 12 * l,
                h = this._chunkIdxMap.get(n),
                d = void 0 !== h ? this._customPool.alloc(f * Float32Array.BYTES_PER_ELEMENT, h) : this._pool.alloc(f * Float32Array.BYTES_PER_ELEMENT);

            if (!d) return r;
            r = {
              pixelOffset: d.start / this._formatSize,
              refCount: 1,
              bounds: new Map(),
              skeletonHash: t.hash,
              clipHash: 0,
              readyToBeDeleted: !1,
              handle: d
            }, a = new Float32Array(f), u = !0;
          }
          A.set(vt, xt, xt, xt), A.set(yt, -xt, -xt, -xt);

          for (var c = e.getBoneSpaceBounds(t), p = 0, _ = 0; p < l; p++, _ += 12) {
            var m = i.getChildByPath(o[p]),
                v = m ? at(m, i, bt) : t.inverseBindposes[p],
                y = c[p];
            y && (B.transform(wt, y, v), wt.getBoundary(_t, mt), A.min(vt, vt, _t), A.max(yt, yt, mt)), u && (m && T.multiply(v, v, s[p]), ct(a, _, m ? v : T.IDENTITY));
          }

          var b = [new B()];
          return r.bounds.set(e.hash, b), B.fromPoints(b[0], vt, yt), u && (this._pool.update(r.handle, a.buffer), this._textureBuffers.set(n, r)), r;
        }, e.getSequencePoseTexture = function (t, e, i, n) {
          var r = t.hash ^ e.hash,
              o = this._textureBuffers.get(r) || null;
          if (o && o.bounds.has(i.hash)) return o.refCount++, o;
          var s = t.joints,
              a = t.bindposes,
              u = ut.getOrExtract(e).frames,
              l = null,
              f = !1,
              h = s.length;
          if (o) o.refCount++;else {
            var d = 12 * h * u,
                c = this._chunkIdxMap.get(r),
                p = void 0 !== c ? this._customPool.alloc(d * Float32Array.BYTES_PER_ELEMENT, c) : this._pool.alloc(d * Float32Array.BYTES_PER_ELEMENT);

            if (!p) return null;

            var _ = this._createAnimInfos(t, e, n);

            o = {
              pixelOffset: p.start / this._formatSize,
              refCount: 1,
              bounds: new Map(),
              skeletonHash: t.hash,
              clipHash: e.hash,
              readyToBeDeleted: !1,
              handle: p,
              animInfos: _
            }, l = new Float32Array(d), f = !0;
          }
          var m = i.getBoneSpaceBounds(t),
              v = [];
          o.bounds.set(i.hash, v);

          for (var y = 0; y < u; y++) {
            v.push(new B(xt, xt, xt, -xt, -xt, -xt));
          }

          for (var b = 0, g = 0; b < u; b++) {
            for (var w = v[b], x = 0; x < h; x++, g += 12) {
              var M = o.animInfos[x],
                  k = M.curveData,
                  I = M.downstream,
                  N = M.bindposeIdx,
                  S = M.bindposeCorrection,
                  E = void 0,
                  j = !0;
              k && I ? E = T.multiply(bt, k[b], I) : k ? E = k[b] : I ? E = I : (E = t.inverseBindposes[N], j = !1);
              var P = m[x];

              if (P) {
                var O = S ? T.multiply(gt, E, S) : E;
                B.transform(wt, P, O), wt.getBoundary(_t, mt), A.min(w.center, w.center, _t), A.max(w.halfExtents, w.halfExtents, mt);
              }

              f && (j && T.multiply(bt, E, a[N]), ct(l, g, j ? bt : T.IDENTITY));
            }

            B.fromPoints(w, w.center, w.halfExtents);
          }

          return f && (this._pool.update(o.handle, l.buffer), this._textureBuffers.set(r, o)), o;
        }, e.releaseHandle = function (t) {
          if (t.refCount > 0 && t.refCount--, !t.refCount && t.readyToBeDeleted) {
            var e = t.skeletonHash ^ t.clipHash;
            (void 0 !== this._chunkIdxMap.get(e) ? this._customPool : this._pool).free(t.handle), this._textureBuffers.get(e) === t && this._textureBuffers.delete(e);
          }
        }, e.releaseSkeleton = function (t) {
          for (var e = this._textureBuffers.values(), i = e.next(); !i.done;) {
            var n = i.value;
            n.skeletonHash === t.hash && (n.readyToBeDeleted = !0, n.refCount ? this._textureBuffers.delete(n.skeletonHash ^ n.clipHash) : this.releaseHandle(n)), i = e.next();
          }
        }, e.releaseAnimationClip = function (t) {
          for (var e = this._textureBuffers.values(), i = e.next(); !i.done;) {
            var n = i.value;
            n.clipHash === t.hash && (n.readyToBeDeleted = !0, n.refCount ? this._textureBuffers.delete(n.skeletonHash ^ n.clipHash) : this.releaseHandle(n)), i = e.next();
          }
        }, e._createAnimInfos = function (t, e, i) {
          for (var n = [], r = t.joints, o = t.bindposes, s = r.length, a = ut.getOrExtract(e), u = 0; u < s; u++) {
            for (var l = r[u], f = a.joints[l], h = i.getChildByPath(l), d = void 0, c = void 0; !f;) {
              var p = l.lastIndexOf("/");
              if (l = l.substring(0, p), f = a.joints[l], h ? (d || (d = new T()), T.fromRTS(bt, h.rotation, h.position, h.scale), T.multiply(d, bt, d), h = h.parent) : c = l, p < 0) break;
            }

            var _ = u,
                m = void 0;

            if (void 0 !== c && f) {
              _ = u - 1;

              for (var v = 0; v < s; v++) {
                if (r[v] === c) {
                  _ = v, m = new T(), T.multiply(m, o[v], t.inverseBindposes[u]);
                  break;
                }
              }
            }

            n.push({
              curveData: f && f.transforms,
              downstream: d,
              bindposeIdx: _,
              bindposeCorrection: m
            });
          }

          return n;
        }, r(t, [{
          key: "pixelsPerJoint",
          get: function get() {
            return this._pixelsPerJoint;
          }
        }]), t;
      }()), t("c", function () {
        function t(t) {
          this._pool = new Map(), this._device = void 0, this._device = t;
        }

        var e = t.prototype;
        return e.getData = function (t) {
          void 0 === t && (t = "-1");

          var e = this._pool.get(t);

          if (e) return e;

          var i = this._device.createBuffer(new u(l.UNIFORM | l.TRANSFER_DST, f.HOST | f.DEVICE, N.SIZE, N.SIZE)),
              n = new Float32Array([0, 0, 0, 0]);

          i.update(n);
          var r = {
            buffer: i,
            data: n,
            dirty: !1,
            currentClip: null
          };
          return this._setAnimInfoDirty(r, !1), this._pool.set(t, r), r;
        }, e.destroy = function (t) {
          var e = this._pool.get(t);

          e && (e.buffer.destroy(), this._pool.delete(t));
        }, e._setAnimInfoDirty = function (t, e) {
          t.dirty = e;
        }, e.switchClip = function (t, e) {
          return t.currentClip = e, t.data[0] = -1, t.buffer.update(t.data), this._setAnimInfoDirty(t, !1), t;
        }, e.clear = function () {
          for (var t, e = h(this._pool.values()); !(t = e()).done;) {
            t.value.buffer.destroy();
          }

          this._pool.clear();
        }, t;
      }()), [{
        name: "CC_USE_SKINNING",
        value: !0
      }]);

      function kt(t, e, i, n) {
        for (var r = 0; r < i.length; r++) {
          for (var o = i[r], s = -1, a = 0; a < o.length; a++) {
            if (o[a] === n) {
              s = a;
              break;
            }
          }

          s >= 0 && (e.push(r), t.push(s));
        }
      }

      var It,
          At,
          Tt,
          Bt,
          Nt,
          St,
          Et,
          jt,
          Pt,
          Ot,
          Rt,
          Dt,
          Ct,
          zt,
          Ut,
          Ft,
          Ht,
          Lt,
          Vt,
          Jt,
          Kt,
          Wt,
          Gt,
          Zt,
          Yt,
          qt,
          Xt,
          $t,
          Qt,
          te,
          ee,
          ie,
          ne,
          re,
          oe,
          se,
          ae,
          ue,
          le,
          fe,
          he,
          de,
          ce,
          pe,
          _e,
          me = new A(),
          ve = new A(),
          ye = new A(),
          be = new A(),
          ge = new T(),
          we = new B(),
          xe = function (t) {
        function e() {
          var e;
          return (e = t.call(this) || this)._buffers = [], e._dataArray = [], e._joints = [], e._bufferIndices = null, e.type = it.SKINNING, e;
        }

        d(e, t);
        var i = e.prototype;
        return i._init = function () {}, i.destroy = function () {
          if (this.bindSkeleton(), this._buffers.length) {
            for (var e = 0; e < this._buffers.length; e++) {
              this._buffers[e].destroy();
            }

            this._buffers.length = 0;
          }

          t.prototype.destroy.call(this);
        }, i.uploadAnimation = function () {}, i.bindSkeleton = function (t, e, i) {
          void 0 === t && (t = null), void 0 === e && (e = null), void 0 === i && (i = null);

          for (var n = 0; n < this._joints.length; n++) {
            lt(this._joints[n].target);
          }

          if (this._bufferIndices = null, this._joints.length = 0, t && e && i) {
            this.transform = e;
            var r = i.getBoneSpaceBounds(t),
                o = i.struct.jointMaps;
            this._ensureEnoughBuffers(o && o.length || 1), this._bufferIndices = i.jointBufferIndices;

            for (var s = 0; s < t.joints.length; s++) {
              var a = r[s],
                  u = e.getChildByPath(t.joints[s]);

              if (a && u) {
                var l = ft(u, e),
                    f = t.bindposes[s],
                    h = [],
                    d = [];
                o ? kt(h, d, o, s) : (h.push(s), d.push(0)), this._joints.push({
                  indices: h,
                  buffers: d,
                  bound: a,
                  target: u,
                  bindpose: f,
                  transform: l
                });
              }
            }
          }
        }, i.updateTransform = function (t) {
          var e = this.transform;
          (e.hasChangedFlags || e._dirtyFlags) && (e.updateWorldTransform(), this._localDataUpdated = !0), A.set(me, 1 / 0, 1 / 0, 1 / 0), A.set(ve, -1 / 0, -1 / 0, -1 / 0);

          for (var i = 0; i < this._joints.length; i++) {
            var n = this._joints[i],
                r = n.bound,
                o = n.transform,
                s = ht(o, t);
            B.transform(we, r, s), we.getBoundary(ye, be), A.min(me, me, ye), A.max(ve, ve, be);
          }

          var a = this._worldBounds;
          this._modelBounds && a && (B.fromPoints(this._modelBounds, me, ve), this._modelBounds.transform(e._mat, e._pos, e._rot, e._scale, this._worldBounds), this._updateNativeBounds());
        }, i.updateUBOs = function (e) {
          t.prototype.updateUBOs.call(this, e);

          for (var i = 0; i < this._joints.length; i++) {
            var n = this._joints[i],
                r = n.indices,
                o = n.buffers,
                s = n.transform,
                a = n.bindpose;
            T.multiply(ge, s.world, a);

            for (var u = 0; u < o.length; u++) {
              ct(this._dataArray[o[u]], 12 * r[u], ge);
            }
          }

          for (var l = 0; l < this._buffers.length; l++) {
            this._buffers[l].update(this._dataArray[l]);
          }

          return !0;
        }, i.initSubModel = function (e, i, n) {
          var r = i.vertexBuffers,
              o = i.iaInfo;
          o.vertexBuffers = i.jointMappedBuffers, t.prototype.initSubModel.call(this, e, i, n), o.vertexBuffers = r;
        }, i.getMacroPatches = function (e) {
          var i = t.prototype.getMacroPatches.call(this, e);
          return i ? Mt.concat(i) : Mt;
        }, i._updateLocalDescriptors = function (e, i) {
          t.prototype._updateLocalDescriptors.call(this, e, i);

          var n = this._buffers[this._bufferIndices[e]];
          n && i.bindBuffer(S.BINDING, n);
        }, i._updateInstancedAttributes = function (e, i) {
          i.batchingScheme !== E.NONE && c(3936, this.node.getPathInHierarchy()), t.prototype._updateInstancedAttributes.call(this, e, i);
        }, i._ensureEnoughBuffers = function (t) {
          for (var e = 0; e < t; e++) {
            this._buffers[e] || (this._buffers[e] = this._device.createBuffer(new u(l.UNIFORM | l.TRANSFER_DST, f.HOST | f.DEVICE, S.SIZE, S.SIZE))), this._dataArray[e] || (this._dataArray[e] = new Float32Array(S.COUNT));
          }
        }, e;
      }(rt),
          Me = [{
        name: "CC_USE_SKINNING",
        value: !0
      }, {
        name: "CC_USE_BAKED_ANIMATION",
        value: !0
      }],
          ke = function (t) {
        function e() {
          var e;
          (e = t.call(this) || this).uploadedAnim = void 0, e._jointsMedium = void 0, e._skeleton = null, e._mesh = null, e._dataPoolManager = void 0, e._instAnimInfoIdx = -1, e.type = it.BAKED_SKINNING, e._dataPoolManager = p.director.root.dataPoolManager;

          var i = new Float32Array(4),
              n = e._dataPoolManager.jointAnimationInfo.getData();

          return e._jointsMedium = {
            buffer: null,
            jointTextureInfo: i,
            animInfo: n,
            texture: null,
            boundsInfo: null
          }, e;
        }

        d(e, t);
        var i = e.prototype;
        return i._init = function () {}, i.destroy = function () {
          this.uploadedAnim = void 0, this._jointsMedium.boundsInfo = null, this._jointsMedium.buffer && (this._jointsMedium.buffer.destroy(), this._jointsMedium.buffer = null), this._applyJointTexture(), this._applyNativeJointMedium(), t.prototype.destroy.call(this);
        }, i.bindSkeleton = function (t, e, i) {
          if (void 0 === t && (t = null), void 0 === e && (e = null), void 0 === i && (i = null), this._skeleton = t, this._mesh = i, t && e && i) {
            this.transform = e;
            var n = this._dataPoolManager;
            this._jointsMedium.animInfo = n.jointAnimationInfo.getData(e.uuid), this._jointsMedium.buffer || (this._jointsMedium.buffer = this._device.createBuffer(new u(l.UNIFORM | l.TRANSFER_DST, f.DEVICE, j.SIZE, j.SIZE)));
          }
        }, i.updateTransform = function (e) {
          if (t.prototype.updateTransform.call(this, e), this.uploadedAnim) {
            var i = this._jointsMedium,
                n = i.animInfo,
                r = i.boundsInfo[n.data[0]],
                o = this._worldBounds;

            if (o && r) {
              var s = this.transform;
              r.transform(s._mat, s._pos, s._rot, s._scale, o);
            }
          }
        }, i.updateUBOs = function (e) {
          t.prototype.updateUBOs.call(this, e);
          var i = this._jointsMedium.animInfo,
              n = this._instAnimInfoIdx;
          return n >= 0 ? this.instancedAttributes.views[n][0] = i.data[0] : i.dirty && (i.buffer.update(i.data), i.dirty = !1), !0;
        }, i.getMacroPatches = function (e) {
          var i = t.prototype.getMacroPatches.call(this, e);
          return i ? i.concat(Me) : Me;
        }, i.uploadAnimation = function (t) {
          if (this._skeleton && this._mesh && this.uploadedAnim !== t) {
            this.uploadedAnim = t;
            var e = this._dataPoolManager,
                i = null;
            t ? (i = e.jointTexturePool.getSequencePoseTexture(this._skeleton, t, this._mesh, this.transform), this._jointsMedium.boundsInfo = i && i.bounds.get(this._mesh.hash), this._updateModelBounds(null)) : (i = e.jointTexturePool.getDefaultPoseTexture(this._skeleton, this._mesh, this.transform), this._jointsMedium.boundsInfo = null, this._updateModelBounds(i && i.bounds.get(this._mesh.hash)[0])), this._applyJointTexture(i), this._applyNativeJointMedium();
          }
        }, i._applyNativeJointMedium = function () {}, i._updateModelBounds = function (t) {
          this._modelBounds = t;
        }, i._applyJointTexture = function (t) {
          void 0 === t && (t = null);
          var e = this._jointsMedium.texture;

          if (e && e !== t && this._dataPoolManager.jointTexturePool.releaseHandle(e), this._jointsMedium.texture = t, t) {
            var i = this._jointsMedium,
                n = i.buffer,
                r = i.jointTextureInfo;
            r[0] = t.handle.texture.width, r[1] = this._skeleton.joints.length, r[2] = t.pixelOffset + .1, r[3] = 1 / r[0], this.updateInstancedJointTextureInfo(), n && n.update(r);

            for (var o = t.handle.texture, s = 0; s < this._subModels.length; ++s) {
              this._subModels[s].descriptorSet.bindTexture(P, o);
            }
          }
        }, i._updateLocalDescriptors = function (e, i) {
          t.prototype._updateLocalDescriptors.call(this, e, i);

          var n = this._jointsMedium,
              r = n.buffer,
              o = n.texture,
              s = n.animInfo;

          if (i.bindBuffer(j.BINDING, r), i.bindBuffer(N.BINDING, s.buffer), o) {
            var a = this._device.getSampler(dt);

            i.bindTexture(P, o.handle.texture), i.bindSampler(P, a);
          }
        }, i._updateInstancedAttributes = function (e, i) {
          t.prototype._updateInstancedAttributes.call(this, e, i), this._setInstAnimInfoIdx(this._getInstancedAttributeIndex(O)), this.updateInstancedJointTextureInfo();
        }, i._setInstAnimInfoIdx = function (t) {
          this._instAnimInfoIdx = t;
        }, i.updateInstancedJointTextureInfo = function () {
          var t = this._jointsMedium,
              e = t.jointTextureInfo,
              i = t.animInfo,
              n = this._instAnimInfoIdx;

          if (n >= 0) {
            var r = this.instancedAttributes.views[n];
            r[0] = i.data[0], r[1] = e[1], r[2] = e[2];
          }
        }, e;
      }(rt),
          Ie = t("S", (It = R("cc.SkinnedMeshRenderer"), At = U(), Tt = F(100), Bt = H(), Nt = D(st), St = D(C), Et = D(st), jt = D(C), Pt = L(), It(Ot = At(Ot = Tt(Ot = z(Ot = Bt((zt = function (t) {
        function e() {
          var e;
          return e = t.call(this) || this, v(e, "_skeleton", Dt, y(e)), v(e, "_skinningRoot", Ct, y(e)), e._clip = null, e.associatedAnimation = null, e._modelType = ke, e;
        }

        d(e, t);
        var i = e.prototype;
        return i.onLoad = function () {
          t.prototype.onLoad.call(this), this._tryBindAnimation();
        }, i.onDestroy = function () {
          this.associatedAnimation && (this.associatedAnimation.notifySkinnedMeshRemoved(this), _(null === this.associatedAnimation)), t.prototype.onDestroy.call(this);
        }, i.uploadAnimation = function (t) {
          this._clip = t, this.model && this.model.uploadAnimation && this.model.uploadAnimation(t);
        }, i.setUseBakedAnimation = function (t, e) {
          void 0 === t && (t = !0), void 0 === e && (e = !1);
          var i = t ? ke : xe;
          (e || this._modelType !== i) && (this._modelType = i, this._model && (p.director.root.destroyModel(this._model), this._model = null, this._models.length = 0, this._updateModels(), this._updateCastShadow(), this.enabledInHierarchy && this._attachToScene()));
        }, i.setMaterial = function (e, i) {
          t.prototype.setMaterial.call(this, e, i), this._modelType === xe && this.getMaterialInstance(i);
        }, i._updateModelParams = function () {
          this._update(), t.prototype._updateModelParams.call(this);
        }, i._tryBindAnimation = function () {
          var t = this._skinningRoot;

          if (t) {
            for (var e = !1, i = this.node; i; i = i.parent) {
              if (i === t) {
                e = !0;
                break;
              }
            }

            if (e) {
              var n = t.getComponent("cc.SkeletalAnimation");
              n ? n.notifySkinnedMeshAdded(this) : this.setUseBakedAnimation(!1);
            }
          }
        }, i._update = function () {
          this.model && (this.model.bindSkeleton(this._skeleton, this._skinningRoot, this._mesh), this.model.uploadAnimation && this.model.uploadAnimation(this._clip));
        }, r(e, [{
          key: "skeleton",
          get: function get() {
            return this._skeleton;
          },
          set: function set(t) {
            t !== this._skeleton && (this._skeleton = t, this._update());
          }
        }, {
          key: "skinningRoot",
          get: function get() {
            return this._skinningRoot;
          },
          set: function set(t) {
            this._skinningRoot = t, this._tryBindAnimation(), t !== this._skinningRoot && this._update();
          }
        }, {
          key: "model",
          get: function get() {
            return this._model;
          }
        }]), e;
      }(ot), Dt = m((Rt = zt).prototype, "_skeleton", [Nt], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return null;
        }
      }), Ct = m(Rt.prototype, "_skinningRoot", [St], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return null;
        }
      }), m(Rt.prototype, "skeleton", [Et], Object.getOwnPropertyDescriptor(Rt.prototype, "skeleton"), Rt.prototype), m(Rt.prototype, "skinningRoot", [jt, Pt], Object.getOwnPropertyDescriptor(Rt.prototype, "skinningRoot"), Rt.prototype), Ot = Rt)) || Ot) || Ot) || Ot) || Ot) || Ot)),
          Ae = new b(g.ATTR_BATCH_ID, s.R32F),
          Te = new b(g.ATTR_BATCH_UV, s.RG32F),
          Be = o[Ae.format].size + o[Te.format].size,
          Ne = t("b", (Ut = R("cc.SkinnedMeshUnit"), Ft = D(nt), Ht = D(st), Lt = D(V), Vt = D(Ie), Ut(($t = function () {
        function t() {
          v(this, "mesh", Wt, this), v(this, "skeleton", Gt, this), v(this, "material", Zt, this), v(this, "_localTransform", Yt, this), v(this, "_offset", qt, this), v(this, "_size", Xt, this);
        }

        return r(t, [{
          key: "offset",
          get: function get() {
            return this._offset;
          },
          set: function set(t) {
            q.copy(this._offset, t);
          }
        }, {
          key: "size",
          get: function get() {
            return this._size;
          },
          set: function set(t) {
            q.copy(this._size, t);
          }
        }, {
          key: "copyFrom",
          get: function get() {
            return null;
          },
          set: function set(t) {
            t && (this.mesh = t.mesh, this.skeleton = t.skeleton, this.material = t.getMaterial(0), t.skinningRoot && at(t.node, t.skinningRoot, this._localTransform));
          }
        }]), t;
      }(), Wt = m((Kt = $t).prototype, "mesh", [Ft], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return null;
        }
      }), Gt = m(Kt.prototype, "skeleton", [Ht], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return null;
        }
      }), Zt = m(Kt.prototype, "material", [Lt], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return null;
        }
      }), Yt = m(Kt.prototype, "_localTransform", [X], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return new T();
        }
      }), qt = m(Kt.prototype, "_offset", [X], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return new q(0, 0);
        }
      }), Xt = m(Kt.prototype, "_size", [X], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return new q(1, 1);
        }
      }), m(Kt.prototype, "offset", [J], Object.getOwnPropertyDescriptor(Kt.prototype, "offset"), Kt.prototype), m(Kt.prototype, "size", [J], Object.getOwnPropertyDescriptor(Kt.prototype, "size"), Kt.prototype), m(Kt.prototype, "copyFrom", [Vt], Object.getOwnPropertyDescriptor(Kt.prototype, "copyFrom"), Kt.prototype), Jt = Kt)) || Jt)),
          Se = new T(),
          Ee = (new T(), new A()),
          je = t("a", (Qt = R("cc.SkinnedMeshBatchRenderer"), te = U(), ee = F(100), ie = H(), ne = L(), re = D([w]), oe = L(), se = D([Ne]), ae = L(), ue = $(), le = $(), Qt(fe = te(fe = ee(fe = z(fe = ie((_e = function (t) {
        function e() {
          for (var e, i = arguments.length, n = new Array(i), r = 0; r < i; r++) {
            n[r] = arguments[r];
          }

          return e = t.call.apply(t, [this].concat(n)) || this, v(e, "atlasSize", de, y(e)), v(e, "batchableTextureNames", ce, y(e)), v(e, "units", pe, y(e)), e._textures = {}, e._batchMaterial = null, e;
        }

        d(e, t);
        var i = e.prototype;
        return i.onLoad = function () {
          t.prototype.onLoad.call(this), this.cook();
        }, i.onDestroy = function () {
          for (var e in this._textures) {
            this._textures[e].destroy();
          }

          this._textures = {}, this._mesh && (this._mesh.destroy(), this._mesh = null), t.prototype.onDestroy.call(this);
        }, i._onMaterialModified = function (e) {
          this.cookMaterials(), t.prototype._onMaterialModified.call(this, e, this.getMaterialInstance(e));
        }, i.cook = function () {
          this.cookMaterials(), this.cookSkeletons(), this.cookMeshes();
        }, i.cookMaterials = function () {
          var t = this;
          this._batchMaterial || (this._batchMaterial = this.getMaterial(0));
          var e = this.getMaterialInstance(0);

          if (e && this._batchMaterial && this._batchMaterial.effectAsset) {
            e.copy(this._batchMaterial), this.resizeAtlases();

            for (var i = e.effectAsset.techniques[e.technique], n = function n(_n) {
              var r = i.passes[_n];
              if (!r.properties) return "continue";

              var o = function o(i) {
                if (r.properties[i].type >= M.SAMPLER1D) {
                  var o = null;
                  t.batchableTextureNames.find(function (t) {
                    return t === i;
                  }) ? ((o = t._textures[i]) || (o = t.createTexture(i)), t.cookTextures(o, i, _n)) : t.units.some(function (t) {
                    return o = t.material && t.material.getProperty(i, _n);
                  }), o && e.setProperty(i, o, _n);
                } else {
                  for (var s = [], a = 0; a < t.units.length; a++) {
                    var u = t.units[a];
                    u.material && s.push(u.material.getProperty(i.slice(0, -3), _n));
                  }

                  e.setProperty(i, s, _n);
                }
              };

              for (var s in r.properties) {
                o(s);
              }
            }, r = 0; r < i.passes.length; r++) {
              n(r);
            }
          } else console.warn("incomplete batch material!");
        }, i.cookSkeletons = function () {
          if (this._skinningRoot) {
            for (var t = [], e = [], i = 0; i < this.units.length; i++) {
              var n = this.units[i];

              if (n && n.skeleton) {
                var r = n.skeleton;
                T.invert(Se, n._localTransform);

                for (var o = function o(i) {
                  var n = r.joints[i];
                  if (t.findIndex(function (t) {
                    return t === n;
                  }) >= 0) return "continue";
                  t.push(n), e.push(T.multiply(new T(), r.bindposes[i] || T.IDENTITY, Se));
                }, s = 0; s < r.joints.length; s++) {
                  o(s);
                }
              }
            }

            var a = Array.from(Array(t.length).keys()).sort(function (e, i) {
              return t[e] > t[i] ? 1 : t[e] < t[i] ? -1 : 0;
            }),
                u = new st();
            u.joints = t.map(function (t, e, i) {
              return i[a[e]];
            }), u.bindposes = e.map(function (t, e, i) {
              return i[a[e]];
            }), this._skeleton && this._skeleton.destroy(), this.skeleton = u;
          } else console.warn("no skinning root specified!");
        }, i.cookMeshes = function () {
          for (var t = this, e = !1, i = 0; i < this.units.length; i++) {
            if (this.units[i].mesh) {
              e = !0;
              break;
            }
          }

          if (e && this._skinningRoot) {
            this._mesh ? this._mesh.destroyRenderingMesh() : this._mesh = new nt();

            for (var n = 0, r = s.UNKNOWN, a = 0, u = s.UNKNOWN, l = 0, f = s.UNKNOWN, h = 0, d = s.UNKNOWN, c = 0, p = s.UNKNOWN, _ = new Array(this.units.length), m = this.units.length, v = 0; v < m; v++) {
              var y = this.units[v];
              y && y.skeleton && (_[v] = y.skeleton.joints.map(function (e) {
                return t._skeleton.joints.findIndex(function (t) {
                  return e === t;
                });
              }));
            }

            for (var b = function b(e) {
              var i = t.units[e];
              if (!i || !i.mesh || !i.mesh.data) return "continue";

              var m = t._createUnitMesh(e, i.mesh),
                  v = new DataView(m.data.buffer);

              T.inverseTranspose(Se, i._localTransform);

              for (var y = i.offset, b = i.size, w = function w(t) {
                var w = m.struct.vertexBundles[t];
                n = w.view.offset, r = s.UNKNOWN;

                for (var x = 0; x < w.attributes.length; x++) {
                  var M = w.attributes[x];

                  if (M.name === g.ATTR_POSITION) {
                    r = M.format;
                    break;
                  }

                  n += o[M.format].size;
                }

                if (r) {
                  for (var k = Z(v, r, n, w.view.length, w.view.stride), I = 0; I < k.length; I += 3) {
                    A.fromArray(Ee, k, I), A.transformMat4(Ee, Ee, i._localTransform), A.toArray(k, Ee, I);
                  }

                  Q(v, k, r, n, w.view.stride);
                }

                a = w.view.offset, u = s.UNKNOWN;

                for (var T = 0; T < w.attributes.length; T++) {
                  var B = w.attributes[T];

                  if (B.name === g.ATTR_NORMAL) {
                    u = B.format;
                    break;
                  }

                  a += o[B.format].size;
                }

                if (u) {
                  for (var N = Z(v, u, a, w.view.length, w.view.stride), S = 0; S < N.length; S += 3) {
                    A.fromArray(Ee, N, S), A.transformMat4Normal(Ee, Ee, Se), A.toArray(N, Ee, S);
                  }

                  Q(v, N, u, a, w.view.stride);
                }

                l = w.view.offset, f = s.UNKNOWN;

                for (var E = 0; E < w.attributes.length; E++) {
                  var j = w.attributes[E];

                  if (j.name === g.ATTR_TANGENT) {
                    f = j.format;
                    break;
                  }

                  l += o[j.format].size;
                }

                if (f) {
                  for (var P = Z(v, f, l, w.view.length, w.view.stride), O = 0; O < P.length; O += 3) {
                    A.fromArray(Ee, P, O), A.transformMat4Normal(Ee, Ee, Se), A.toArray(P, Ee, O);
                  }

                  Q(v, P, f, l, w.view.stride);
                }

                h = w.view.offset, d = s.UNKNOWN;

                for (var R = 0; R < w.attributes.length; R++) {
                  var D = w.attributes[R];

                  if (D.name === g.ATTR_BATCH_UV) {
                    d = D.format;
                    break;
                  }

                  h += o[D.format].size;
                }

                d && tt(v, function (t, e) {
                  var i,
                      n = 0 === e ? "x" : "y";
                  return (t = (i = t) - Math.floor(i)) * b[n] + y[n];
                }, d, h, w.view.length, w.view.stride, v);
                var C = _[e];
                if (!C) return "continue";
                c = w.view.offset, p = s.UNKNOWN;

                for (var z = 0; z < w.attributes.length; z++) {
                  var U = w.attributes[z];

                  if (U.name === g.ATTR_JOINTS) {
                    p = U.format;
                    break;
                  }

                  c += o[U.format].size;
                }

                p && tt(v, function (t) {
                  return C[t];
                }, p, c, w.view.length, w.view.stride, v);
              }, x = 0; x < m.struct.vertexBundles.length; x++) {
                w(x);
              }

              t._mesh.merge(m);
            }, w = 0; w < m; w++) {
              b(w);
            }

            this._onMeshChanged(this._mesh), this._updateModels();
          }
        }, i.cookTextures = function (t, e, i) {
          for (var n = [], r = [], o = [], s = [], a = 0; a < this.units.length; a++) {
            var u = this.units[a];

            if (u.material) {
              var l = u.material.getProperty(e, i);

              if (l && l.image && l.image.data) {
                var f = new x();
                f.texOffset.x = u.offset.x * this.atlasSize, f.texOffset.y = u.offset.y * this.atlasSize, f.texExtent.width = u.size.x * this.atlasSize, f.texExtent.height = u.size.y * this.atlasSize;
                var h = l.image.data;
                ArrayBuffer.isView(h) ? (o.push(h), s.push(f)) : (n.push(h), r.push(f));
              }
            }
          }

          var d = t.getGFXTexture(),
              c = p.director.root.device;
          o.length > 0 && c.copyBuffersToTexture(o, d, s), n.length > 0 && c.copyTexImagesToTexture(n, d, r);
        }, i.createTexture = function (t) {
          var e = new K();
          return e.setFilters(W.LINEAR, W.LINEAR), e.setMipFilter(W.NEAREST), e.reset({
            width: this.atlasSize,
            height: this.atlasSize,
            format: G.RGBA8888
          }), this._textures[t] = e, e;
        }, i.resizeAtlases = function () {
          for (var t in this._textures) {
            this._textures[t].reset({
              width: this.atlasSize,
              height: this.atlasSize,
              format: G.RGBA8888
            });
          }
        }, i._createUnitMesh = function (t, e) {
          for (var i = JSON.parse(JSON.stringify(e.struct)), n = {}, r = 0; r < e.struct.primitives.length; r++) {
            for (var a = e.struct.primitives[r], u = 0, l = s.UNKNOWN, f = 0; f < a.vertexBundelIndices.length; f++) {
              var h = e.struct.vertexBundles[a.vertexBundelIndices[f]];
              u = h.view.offset, l = s.UNKNOWN;

              for (var d = 0; d < h.attributes.length; d++) {
                var c = h.attributes[d];

                if (c.name === g.ATTR_TEX_COORD) {
                  l = c.format;
                  break;
                }

                u += o[c.format].size;
              }

              if (l) break;
            }

            if (void 0 === n[f]) {
              n[f] = [l, u];
              var _ = i.vertexBundles[f];
              _.attributes.push(Ae), _.attributes.push(Te), _.view.offset = 0, _.view.length += _.view.count * Be, _.view.stride += Be;
            }
          }

          for (var m = 0, v = 0; v < i.vertexBundles.length; v++) {
            m += i.vertexBundles[v].view.length;
          }

          for (var y = 0; y < i.primitives.length; y++) {
            var b = i.primitives[y];
            b.indexView && (b.indexView.offset = m, m += b.indexView.length);
          }

          var w = new Uint8Array(m),
              x = e.data,
              M = new DataView(w.buffer),
              k = new DataView(x.buffer),
              I = p.sys.isLittleEndian;

          for (var A in n) {
            for (var T = i.vertexBundles[A], B = e.struct.vertexBundles[A], N = n[A], S = N[0], E = N[1], j = Z(k, S, E, B.view.length, B.view.stride), P = B.view, O = T.view, R = P.stride, D = O.stride, C = P.offset, z = O.offset, U = 0; U < O.count; U++) {
              var F = x.subarray(C, C + R);
              w.set(F, z), M.setFloat32(z + R, t), M.setFloat32(z + R + 4, j[2 * U], I), M.setFloat32(z + R + 8, j[2 * U + 1], I), z += D, C += R;
            }
          }

          for (var H = 0; H < i.primitives.length; H++) {
            var L = e.struct.primitives[H],
                V = i.primitives[H];
            if (L.indexView && V.indexView) for (var J = L.indexView.stride, K = V.indexView.stride, W = L.indexView.offset, G = V.indexView.offset, Y = 0; Y < V.indexView.count; Y++) {
              var q = x.subarray(W, W + J);
              w.set(q, G), G += K, W += J;
            }
          }

          var X = new nt();
          return X.reset({
            struct: i,
            data: w
          }), X;
        }, r(e, [{
          key: "mesh",
          get: function get() {
            return t.prototype.mesh;
          },
          set: function set(t) {
            this.mesh = t;
          }
        }, {
          key: "skeleton",
          get: function get() {
            return t.prototype.skeleton;
          },
          set: function set(t) {
            this.skeleton = t;
          }
        }]), e;
      }(Ie), de = m((he = _e).prototype, "atlasSize", [X, ne], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 1024;
        }
      }), ce = m(he.prototype, "batchableTextureNames", [re, X, oe], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return [];
        }
      }), pe = m(he.prototype, "units", [se, X, ae], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return [];
        }
      }), m(he.prototype, "mesh", [Y, ue], Object.getOwnPropertyDescriptor(he.prototype, "mesh"), he.prototype), m(he.prototype, "skeleton", [Y, le], Object.getOwnPropertyDescriptor(he.prototype, "skeleton"), he.prototype), fe = he)) || fe) || fe) || fe) || fe) || fe));

      p.SkinningModelComponent = Ie, k.setClassAlias(Ie, "cc.SkinningModelComponent"), p.SkinningModelUnit = Ne, k.setClassAlias(Ne, "cc.SkinningModelUnit"), p.BatchedSkinningModelComponent = je, k.setClassAlias(je, "cc.BatchedSkinningModelComponent");
    }
  };
}); 
 			}); 
		define("__plugin__/wx0446ba2621dda60a/deprecated-e75f11b6.js", function(require, module, exports){ 			
"use strict";

System.register(["./texture-barrier-60b5983b.js", "./json-asset-933a1d4c.js", "./index-f2b92470.js", "./renderable-component-7c6600ed.js", "./deprecated-26630860.js", "./deprecated-ef6bb945.js", "./sprite-frame-1edab3eb.js", "./sprite-827770a8.js", "./renderable-2d-e2838949.js", "./graphics-f99ac3d9.js", "./deprecated-5f7f37d5.js"], function (t) {
  "use strict";

  var e, i, n, r, s, o, a, l, h, c, u, p, _, d, f, g, m, y, b, v, C, S, A, T, x, O, w, D, E, L, I, R, k, M, F, P, z, H, W, j, N, U, G, B, X, V, Y, Q, Z, $, q, J, K, tt, et, it, nt, rt, st, ot, at, lt, ht, ct, ut, pt, _t, dt, ft, gt, mt, yt;

  return {
    setters: [function (t) {
      e = t.bw, i = t.bT, n = t.bC, r = t.l, s = t.al, o = t.o, a = t.q, l = t.W, h = t.bU, c = t.c0, u = t.c1, p = t.b$, _ = t.i, d = t.cf, f = t.d, g = t.cN, m = t.bX;
    }, function (t) {
      y = t.Z, b = t.V, v = t.bW, C = t.bZ, S = t.a5, A = t.Q, T = t.bo, x = t.M, O = t.aO, w = t.di, D = t.dz, E = t.dS, L = t.cg, I = t.ds, R = t.ch, k = t.cc, M = t.bY, F = t.ci, P = t.dj, z = t.aa, H = t.bX, W = t.cd, j = t.dQ, N = t.bm, U = t.dR, G = t.b6, B = t.dO, X = t.d8, V = t.b8, Y = t.x, Q = t.dP, Z = t.b$;
    }, function () {}, function (t) {
      $ = t.f;
    }, function () {}, function (t) {
      q = t.d;
    }, function (t) {
      J = t.S;
    }, function (t) {
      K = t.c, tt = t.H, et = t.V, it = t.F, nt = t.b, rt = t.S, t.T, st = t.j, ot = t.k, at = t.a, lt = t.l, ht = t.d, ct = t.i, ut = t.e;
    }, function (t) {
      pt = t.g, _t = t.c, dt = t.b, ft = t.R, gt = t.I, mt = t.U;
    }, function (t) {
      yt = t.G;
    }, function () {}],
    execute: function execute() {
      var bt, vt, Ct, St, At, Tt, xt, Ot, wt, Dt, Et, Lt, It, Rt, kt, Mt, Ft, Pt, zt, Ht, Wt, jt, Nt, Ut;
      t("d", void 0);
      var Gt,
          Bt = new y(),
          Xt = new b(),
          Vt = new y(),
          Yt = [];
      !function (t) {
        t[t.RECT = 0] = "RECT", t[t.ELLIPSE = 1] = "ELLIPSE", t[t.GRAPHICS_STENCIL = 2] = "GRAPHICS_STENCIL", t[t.IMAGE_STENCIL = 3] = "IMAGE_STENCIL";
      }(Gt || (Gt = t("d", {}))), e(Gt);
      var Qt = t("M", (bt = v("cc.Mask"), vt = L(), Ct = I(110), St = R(), At = C(Gt), Tt = k(), xt = M(), Ot = k(), wt = F(), Dt = C(J), Et = F(), Lt = F(), It = P(), Rt = F(), kt = F(), bt(Mt = vt(Mt = Ct(Mt = St((Ut = Nt = function (t) {
        function e() {
          var e;
          return (e = t.call(this) || this)._clearStencilMtl = null, e._clearModel = null, u(e, "_type", Pt, p(e)), u(e, "_inverted", zt, p(e)), u(e, "_segments", Ht, p(e)), u(e, "_spriteFrame", Wt, p(e)), u(e, "_alphaThreshold", jt, p(e)), e._graphics = null, e._clearModelMesh = null, e._instanceMaterialType = gt.ADD_COLOR, e;
        }

        i(e, t);
        var c = e.prototype;
        return c.onLoad = function () {
          this._createClearModel(), this._createGraphics(), this._graphics && this._graphics.onLoad();
        }, c.onEnable = function () {
          t.prototype.onEnable.call(this), this._updateGraphics(), this._enableGraphics();
        }, c.onRestore = function () {
          this._createGraphics(), t.prototype.updateMaterial.call(this), this._updateGraphics(), this._renderFlag = this._canRender();
        }, c.onDisable = function () {
          t.prototype.onDisable.call(this), this._disableGraphics();
        }, c.onDestroy = function () {
          this._clearModel && this._clearModelMesh && (q.root.destroyModel(this._clearModel), this._clearModelMesh.destroy()), this._clearStencilMtl && this._clearStencilMtl.destroy(), this._removeGraphics(), t.prototype.onDestroy.call(this);
        }, c.isHit = function (t) {
          var e = this.node._uiProps.uiTransformComp,
              i = e.contentSize,
              n = i.width,
              r = i.height,
              s = Xt;
          this.node.getWorldMatrix(Bt), y.invert(Vt, Bt), b.transformMat4(s, t, Vt);
          var o = e.anchorPoint;
          s.x += o.x * n, s.y += o.y * r;
          var a = !1;
          if (this.type === Gt.RECT || this.type === Gt.GRAPHICS_STENCIL || this.type === Gt.IMAGE_STENCIL) a = s.x >= 0 && s.y >= 0 && s.x <= n && s.y <= r;else if (this.type === Gt.ELLIPSE) {
            var l = n / 2,
                h = r / 2,
                c = s.x - .5 * n,
                u = s.y - .5 * r;
            a = c * c / (l * l) + u * u / (h * h) < 1;
          }
          return this._inverted && (a = !a), a;
        }, c._render = function (t) {
          t.commitComp(this, this.renderData, null, this._assembler, null);
        }, c._postRender = function (t) {
          this._postAssembler && t.commitComp(this, null, null, this._postAssembler, null);
        }, c._nodeStateChange = function (e) {
          t.prototype._nodeStateChange.call(this, e), this._updateGraphics();
        }, c._canRender = function () {
          return !!t.prototype._canRender.call(this) && null !== this._graphics && (this._type !== Gt.IMAGE_STENCIL || null !== this._spriteFrame);
        }, c._flushAssembler = function () {
          var t = e.Assembler.getAssembler(this),
              i = e.PostAssembler.getAssembler(this);
          this._assembler !== t && (this.destroyRenderData(), this._assembler = t), this._postAssembler !== i && (this._postAssembler = i), this._useRenderData();
        }, c._createGraphics = function () {
          if (!this._graphics) {
            var t = this._graphics = new yt();
            t._objFlags |= n.Flags.IsOnLoadCalled, t.node = this.node, t.node.getWorldMatrix(), t.lineWidth = 0;
            var e = S.WHITE.clone();
            e.a = 0, t.fillColor = e;
          }

          this._updateMaterial();
        }, c._updateGraphics = function () {
          if (this._graphics && (this._type === Gt.RECT || this._type === Gt.ELLIPSE)) {
            var t = this.node._uiProps.uiTransformComp,
                e = this._graphics;
            e.clear();
            var i = t.contentSize,
                n = i.width,
                r = i.height,
                s = t.anchorPoint,
                o = -n * s.x,
                a = -r * s.y;
            if (this._type === Gt.RECT) e.rect(o, a, n, r);else if (this._type === Gt.ELLIPSE) {
              for (var l = function (t, e, i) {
                Yt.length = 0;

                for (var n = 2 * Math.PI / i, r = 0; r < i; ++r) {
                  Yt.push(new A(e.x * Math.cos(n * r) + t.x, e.y * Math.sin(n * r) + t.y, 0));
                }

                return Yt;
              }(new A(o + n / 2, a + r / 2, 0), new A(n / 2, r / 2, 0), this._segments), h = 0; h < l.length; ++h) {
                var c = l[h];
                0 === h ? e.moveTo(c.x, c.y) : e.lineTo(c.x, c.y);
              }

              e.close();
            }
            e.fill();
          }
        }, c._createClearModel = function () {
          if (!this._clearModel) {
            var t = T.get("default-clear-stencil");
            this._clearStencilMtl = new x({
              parent: t,
              owner: this,
              subModelIdx: 0
            }), this._clearModel = q.root.createModel($), this._clearModel.node = this._clearModel.transform = this.node;
            var e = pt(_t),
                i = r.director.root.device,
                n = i.createBuffer(new s(o.VERTEX | o.TRANSFER_DST, a.DEVICE, 4 * e, e)),
                h = new Float32Array([-1, -1, 0, 1, -1, 0, -1, 1, 0, 1, 1, 0]);
            n.update(h);
            var c = i.createBuffer(new s(o.INDEX | o.TRANSFER_DST, a.DEVICE, 6 * Uint16Array.BYTES_PER_ELEMENT, Uint16Array.BYTES_PER_ELEMENT)),
                u = new Uint16Array([0, 1, 2, 2, 1, 3]);
            c.update(u), this._clearModelMesh = new O([n], _t, l.TRIANGLE_LIST, c), this._clearModelMesh.subMeshIdx = 0, this._clearModel.initSubModel(0, this._clearModelMesh, this._clearStencilMtl);
          }
        }, c._updateMaterial = function () {
          if (this._graphics) {
            var t,
                e = this._graphics;
            e.stencilStage = dt.DISABLED, this._type === Gt.IMAGE_STENCIL ? (t = T.get("ui-alpha-test-material"), e.setMaterial(t, 0), (t = e.getMaterialInstance(0)).setProperty("alphaThreshold", this._alphaThreshold)) : (t = T.get("ui-graphics-material"), e.setMaterial(t, 0), e.getMaterialInstance(0));
          }
        }, c._enableGraphics = function () {
          this._graphics && (this._graphics._renderFlag = this._graphics._canRender());
        }, c._disableGraphics = function () {
          this._graphics && this._graphics.onDisable();
        }, c._removeGraphics = function () {
          this._graphics && (this._graphics.destroy(), this._graphics._destroyImmediate(), this._graphics = null);
        }, c._useRenderData = function () {
          this._type !== Gt.IMAGE_STENCIL || this._renderData || this._assembler && this._assembler.createData && (this._renderData = this._assembler.createData(this), this.markForUpdateRenderData());
        }, h(e, [{
          key: "type",
          get: function get() {
            return this._type;
          },
          set: function set(t) {
            this._type !== t && (this._type = t, this.markForUpdateRenderData(!1), this._updateMaterial(), this._type !== Gt.IMAGE_STENCIL ? (this._spriteFrame = null, this._updateGraphics(), this._renderData && (this.destroyRenderData(), this._renderData = null)) : (this._useRenderData(), this._graphics && this._graphics.clear()));
          }
        }, {
          key: "inverted",
          get: function get() {
            return this._inverted;
          },
          set: function set(t) {
            this._inverted = t, this.stencilStage = dt.DISABLED, this._graphics && (this._graphics.stencilStage = dt.DISABLED);
          }
        }, {
          key: "segments",
          get: function get() {
            return this._segments;
          },
          set: function set(t) {
            this._segments !== t && (this._segments = z(t, 3, 1e4), this._updateGraphics());
          }
        }, {
          key: "spriteFrame",
          get: function get() {
            return this._spriteFrame;
          },
          set: function set(t) {
            if (this._spriteFrame !== t) {
              var e = this._spriteFrame;
              this._spriteFrame = t, this._type === Gt.IMAGE_STENCIL && !e && t && this.markForUpdateRenderData();
            }
          }
        }, {
          key: "alphaThreshold",
          get: function get() {
            return this._alphaThreshold;
          },
          set: function set(t) {
            this._alphaThreshold !== t && (this._alphaThreshold = t, this.type === Gt.IMAGE_STENCIL && this._graphics && this._graphics.getMaterialInstance(0).setProperty("alphaThreshold", this._alphaThreshold));
          }
        }, {
          key: "graphics",
          get: function get() {
            return this._graphics;
          }
        }, {
          key: "dstBlendFactor",
          get: function get() {
            return this._dstBlendFactor;
          },
          set: function set(t) {
            this._dstBlendFactor !== t && (this._dstBlendFactor = t, this._updateBlendFunc());
          }
        }, {
          key: "srcBlendFactor",
          get: function get() {
            return this._srcBlendFactor;
          },
          set: function set(t) {
            this._srcBlendFactor !== t && (this._srcBlendFactor = t, this._updateBlendFunc());
          }
        }, {
          key: "color",
          get: function get() {
            return this._color;
          },
          set: function set(t) {
            this._color !== t && (this._color.set(t), this.markForUpdateRenderData());
          }
        }, {
          key: "customMaterial",
          get: function get() {
            return this._customMaterial;
          },
          set: function set() {}
        }]), e;
      }(ft), Nt.Type = Gt, c((Ft = Ut).prototype, "type", [At, Tt], Object.getOwnPropertyDescriptor(Ft.prototype, "type"), Ft.prototype), c(Ft.prototype, "inverted", [xt, Ot], Object.getOwnPropertyDescriptor(Ft.prototype, "inverted"), Ft.prototype), c(Ft.prototype, "segments", [wt], Object.getOwnPropertyDescriptor(Ft.prototype, "segments"), Ft.prototype), c(Ft.prototype, "spriteFrame", [Dt, Et], Object.getOwnPropertyDescriptor(Ft.prototype, "spriteFrame"), Ft.prototype), c(Ft.prototype, "alphaThreshold", [Lt, It, w], Object.getOwnPropertyDescriptor(Ft.prototype, "alphaThreshold"), Ft.prototype), c(Ft.prototype, "color", [D, Rt], Object.getOwnPropertyDescriptor(Ft.prototype, "color"), Ft.prototype), c(Ft.prototype, "customMaterial", [D, kt], Object.getOwnPropertyDescriptor(Ft.prototype, "customMaterial"), Ft.prototype), Pt = c(Ft.prototype, "_type", [H], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return Gt.RECT;
        }
      }), zt = c(Ft.prototype, "_inverted", [H], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !1;
        }
      }), Ht = c(Ft.prototype, "_segments", [H], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 64;
        }
      }), Wt = c(Ft.prototype, "_spriteFrame", [H], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return null;
        }
      }), jt = c(Ft.prototype, "_alphaThreshold", [H], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return .1;
        }
      }), Mt = Ft)) || Mt) || Mt) || Mt) || Mt));
      E._maskComp = Qt, r.Mask = Qt;

      var Zt,
          $t,
          qt,
          Jt,
          Kt,
          te,
          ee,
          ie,
          ne,
          re,
          se,
          oe,
          ae,
          le,
          he,
          ce,
          ue,
          pe,
          _e,
          de,
          fe,
          ge,
          me,
          ye,
          be,
          ve,
          Ce,
          Se,
          Ae,
          Te,
          xe,
          Oe,
          we,
          De,
          Ee,
          Le,
          Ie,
          Re,
          ke,
          Me,
          Fe,
          Pe,
          ze,
          He,
          We,
          je,
          Ne,
          Ue,
          Ge,
          Be,
          Xe,
          Ve = /^(click)(\s)*=|(param)(\s)*=/,
          Ye = /(\s)*src(\s)*=|(\s)*height(\s)*=|(\s)*width(\s)*=|(\s)*align(\s)*=|(\s)*offset(\s)*=|(\s)*click(\s)*=|(\s)*param(\s)*=/,
          Qe = t("H", function () {
        function t() {
          this._specialSymbolArray = [], this._stack = [], this._resultObjectArray = [], this._specialSymbolArray.push([/&lt;/g, "<"]), this._specialSymbolArray.push([/&gt;/g, ">"]), this._specialSymbolArray.push([/&amp;/g, "&"]), this._specialSymbolArray.push([/&quot;/g, '"']), this._specialSymbolArray.push([/&apos;/g, "'"]);
        }

        var e = t.prototype;
        return e.parse = function (t) {
          this._resultObjectArray.length = 0, this._stack.length = 0;

          for (var e = 0, i = t.length; e < i;) {
            var n = t.indexOf(">", e),
                r = -1;
            if (n >= 0 && (r = t.lastIndexOf("<", n)) < e - 1 && (r = t.indexOf("<", n + 1), n = t.indexOf(">", r + 1)), r < 0) this._stack.pop(), this._processResult(t.substring(e)), e = i;else {
              var s = t.substring(e, r),
                  o = t.substring(r + 1, n);
              "" === o && (s = t.substring(e, n + 1)), this._processResult(s), -1 === n ? n = r : "/" === t.charAt(r + 1) ? this._stack.pop() : this._addToStack(o), e = n + 1;
            }
          }

          return this._resultObjectArray;
        }, e._attributeToObject = function (t) {
          t = t.trim();
          var e = {},
              i = /^(color|size)(\s)*=/.exec(t),
              n = "",
              r = 0,
              s = "";

          if (i) {
            if (n = i[0], "" === (t = t.substring(n.length).trim())) return e;

            switch (r = t.indexOf(" "), n[0]) {
              case "c":
                e.color = r > -1 ? t.substring(0, r).trim() : t;
                break;

              case "s":
                e.size = parseInt(t);
            }

            return r > -1 && (s = t.substring(r + 1).trim(), e.event = this._processEventHandler(s)), e;
          }

          if ((i = /^(br(\s)*\/)/.exec(t)) && i[0].length > 0 && (n = i[0].trim()).startsWith("br") && "/" === n[n.length - 1]) return e.isNewLine = !0, this._resultObjectArray.push({
            text: "",
            style: {
              isNewLine: !0
            }
          }), e;
          var o = "",
              a = -1;

          if ((i = /^(img(\s)*src(\s)*=[^>]+\/)/.exec(t)) && i[0].length > 0 && (n = i[0].trim()).startsWith("img") && "/" === n[n.length - 1]) {
            var l;
            i = Ye.exec(t);

            for (var h = !1; i;) {
              var c = (n = (t = t.substring(t.indexOf(i[0]))).substr(0, i[0].length)).length;

              if (n = (n = n.replace(/[^a-zA-Z]/g, "").trim()).toLowerCase(), o = t.substring(c).trim(), a = "src" === n ? this.getRightQuotationIndex(o) : -1, l = (r = o.indexOf(" ", a + 1 >= o.length ? -1 : a + 1)) > -1 ? o.substr(0, r) : o, t = o.substring(r).trim(), l.endsWith("/") && (l = l.slice(0, -1)), "src" === n) {
                switch (l.charCodeAt(0)) {
                  case 34:
                  case 39:
                    h = !0, l = l.slice(1, -1);
                }

                e.isImage = !0, e.src = l;
              } else if ("height" === n) e.imageHeight = parseInt(l);else if ("width" === n) e.imageWidth = parseInt(l);else if ("align" === n) {
                switch (l.charCodeAt(0)) {
                  case 34:
                  case 39:
                    l = l.slice(1, -1);
                }

                e.imageAlign = l.toLowerCase();
              } else "offset" === n ? e.imageOffset = l : "click" === n && (e.event = this._processEventHandler(n + "=" + l));

              e.event && "param" === n && (e.event[n] = l.replace(/^"|"$/g, "")), i = Ye.exec(t);
            }

            return h && e.isImage && this._resultObjectArray.push({
              text: "",
              style: e
            }), {};
          }

          if (i = /^(outline(\s)*[^>]*)/.exec(t)) {
            var u = {
              color: "#ffffff",
              width: 1
            };

            if (t = i[0].substring("outline".length).trim()) {
              var p,
                  _ = /(\s)*color(\s)*=|(\s)*width(\s)*=|(\s)*click(\s)*=|(\s)*param(\s)*=/;

              for (i = _.exec(t); i;) {
                n = (t = t.substring(t.indexOf(i[0]))).substr(0, i[0].length), p = (r = (o = t.substring(n.length).trim()).indexOf(" ")) > -1 ? o.substr(0, r) : o, n = (n = n.replace(/[^a-zA-Z]/g, "").trim()).toLowerCase(), t = o.substring(r).trim(), "click" === n ? e.event = this._processEventHandler(n + "=" + p) : "color" === n ? u.color = p : "width" === n && (u.width = parseInt(p)), e.event && "param" === n && (e.event[n] = p.replace(/^"|"$/g, "")), i = _.exec(t);
              }
            }

            e.outline = u;
          }

          if ((i = /^(on|u|b|i)(\s)*/.exec(t)) && i[0].length > 0) {
            switch (n = i[0], t = t.substring(n.length).trim(), n[0]) {
              case "u":
                e.underline = !0;
                break;

              case "i":
                e.italic = !0;
                break;

              case "b":
                e.bold = !0;
            }

            if ("" === t) return e;
            e.event = this._processEventHandler(t);
          }

          return e;
        }, e.getRightQuotationIndex = function (t) {
          var e = -1,
              i = -1,
              n = t.indexOf("'"),
              r = t.indexOf('"'),
              s = r > -1 && (r < n || -1 === n);
          return n > -1 && (n < r || -1 === r) ? (e = n, i = t.indexOf("'", e + 1 >= t.length ? -1 : e + 1)) : s && (e = r, i = t.indexOf('"', e + 1 >= t.length ? -1 : e + 1)), i;
        }, e._processEventHandler = function (t) {
          for (var e = {}, i = 0, n = !1, r = Ve.exec(t); r;) {
            var s = r[0],
                o = "";
            if (n = !1, '"' === (t = t.substring(s.length).trim()).charAt(0)) (i = t.indexOf('"', 1)) > -1 && (o = t.substring(1, i).trim(), n = !0), i++;else if ("'" === t.charAt(0)) (i = t.indexOf("'", 1)) > -1 && (o = t.substring(1, i).trim(), n = !0), i++;else {
              var a = /(\S)+/.exec(t);
              i = (o = a ? a[0] : "").length;
            }
            n && (e[s = s.substring(0, s.length - 1).trim()] = o), t = t.substring(i).trim(), r = Ve.exec(t);
          }

          return e;
        }, e._addToStack = function (t) {
          var e = this._attributeToObject(t);

          if (0 === this._stack.length) this._stack.push(e);else {
            if (e.isNewLine || e.isImage) return;
            var i = this._stack[this._stack.length - 1];

            for (var n in i) {
              e[n] || (e[n] = i[n]);
            }

            this._stack.push(e);
          }
        }, e._processResult = function (t) {
          0 !== t.length && (t = this._escapeSpecialSymbol(t), this._stack.length > 0 ? this._resultObjectArray.push({
            text: t,
            style: this._stack[this._stack.length - 1]
          }) : this._resultObjectArray.push({
            text: t
          }));
        }, e._escapeSpecialSymbol = function (t) {
          for (var e, i = _(this._specialSymbolArray); !(e = i()).done;) {
            var n = e.value,
                r = n[0],
                s = n[1];
            t = t.replace(r, s);
          }

          return t;
        }, t;
      }()),
          Ze = t("L", (Zt = v("cc.LabelOutline"), $t = L(), qt = I(110), Jt = R(), Kt = j(K), te = k(), ee = k(), Zt(ie = $t(ie = qt(ie = Jt(ie = Kt(ie = W((oe = function (t) {
        function e() {
          for (var e, i = arguments.length, n = new Array(i), r = 0; r < i; r++) {
            n[r] = arguments[r];
          }

          return e = t.call.apply(t, [this].concat(n)) || this, u(e, "_color", re, p(e)), u(e, "_width", se, p(e)), e;
        }

        i(e, t);
        var n = e.prototype;
        return n.onEnable = function () {
          this._updateRenderData();
        }, n.onDisable = function () {
          this._updateRenderData();
        }, n._updateRenderData = function () {
          var t = this.node.getComponent(K);
          t && t.updateRenderData(!0);
        }, h(e, [{
          key: "color",
          get: function get() {
            return this._color;
          },
          set: function set(t) {
            this._color !== t && (this._color.set(t), this._updateRenderData());
          }
        }, {
          key: "width",
          get: function get() {
            return this._width;
          },
          set: function set(t) {
            this._width !== t && (this._width = t, this._updateRenderData());
          }
        }]), e;
      }(N), re = c((ne = oe).prototype, "_color", [H], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return new S(0, 0, 0, 255);
        }
      }), se = c(ne.prototype, "_width", [H], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 2;
        }
      }), c(ne.prototype, "color", [te], Object.getOwnPropertyDescriptor(ne.prototype, "color"), ne.prototype), c(ne.prototype, "width", [ee], Object.getOwnPropertyDescriptor(ne.prototype, "width"), ne.prototype), ie = ne)) || ie) || ie) || ie) || ie) || ie) || ie));

      r.LabelOutline = Ze;
      var $e = new Qe(),
          qe = "RICHTEXT_CHILD",
          Je = "RICHTEXT_Image_CHILD",
          Ke = new d(function (t) {
        if (!r.isValid(t.node)) return !1;
        var e = t.node.getComponent(Ze);
        return e && (e.width = 0), !0;
      }, 20),
          ti = new d(function (t) {
        return r.isValid(t.node);
      }, 10);

      function ei(t) {
        return {
          node: new G(t),
          comp: null,
          lineCount: 0,
          styleIndex: 0,
          imageOffset: "",
          clickParam: "",
          clickHandler: "",
          type: t
        };
      }

      function ii(t, e) {
        var i;
        t === qe ? i = Ke._get() : t === Je && (i = ti._get());
        var r = (i = i || ei(t)).node;
        return r || (r = new G(t)), r.hideFlags |= n.Flags.DontSave | n.Flags.HideInHierarchy, t === Je ? (i.comp = r.getComponent(at) || r.addComponent(at), i.comp.spriteFrame = e, i.comp.type = at.Type.SLICED, i.comp.sizeMode = at.SizeMode.CUSTOM) : (i.comp = r.getComponent(K) || r.addComponent(K), i.comp.string = e, i.comp.horizontalAlign = tt.LEFT, i.comp.verticalAlign = et.TOP, i.comp.underlineHeight = 2), r.setPosition(0, 0, 0), r._uiProps.uiTransformComp.setAnchorPoint(.5, .5), i.node = r, i.lineCount = 0, i.styleIndex = 0, i.imageOffset = "", i.clickParam = "", i.clickHandler = "", i;
      }

      var ni,
          ri = t("R", (ae = v("cc.RichText"), le = L(), he = I(110), ce = R(), ue = k(), pe = C(tt), _e = k(), de = C(et), fe = k(), ge = k(), me = k(), ye = C(it), be = k(), ve = k(), Ce = M(), Se = C(nt), Ae = k(), Te = k(), xe = k(), Oe = C(rt), we = k(), De = k(), ae(Ee = le(Ee = he(Ee = ce(Ee = W((Xe = Be = function (t) {
        function e() {
          var e;
          return e = t.call(this) || this, u(e, "_lineHeight", Ie, p(e)), u(e, "_string", Re, p(e)), u(e, "_horizontalAlign", ke, p(e)), u(e, "_verticalAlign", Me, p(e)), u(e, "_fontSize", Fe, p(e)), u(e, "_maxWidth", Pe, p(e)), u(e, "_fontFamily", ze, p(e)), u(e, "_font", He, p(e)), u(e, "_isSystemFontUsed", We, p(e)), u(e, "_userDefinedFont", je, p(e)), u(e, "_cacheMode", Ne, p(e)), u(e, "_imageAtlas", Ue, p(e)), u(e, "_handleTouchEvent", Ge, p(e)), e._textArray = [], e._segments = [], e._labelSegmentsCache = [], e._linesWidth = [], e._lineCount = 1, e._labelWidth = 0, e._labelHeight = 0, e._layoutDirty = !0, e._lineOffsetX = 0, e._updateRichTextStatus = void 0, e._labelChildrenNum = 0, e._updateRichTextStatus = e._updateRichText, e;
        }

        i(e, t);
        var n = e.prototype;
        return n.onLoad = function () {
          this.node.on(U.LAYER_CHANGED, this._applyLayer, this);
        }, n.onEnable = function () {
          this.handleTouchEvent && this._addEventListeners(), this._updateRichText(), this._activateChildren(!0);
        }, n.onDisable = function () {
          this.handleTouchEvent && this._removeEventListeners(), this._activateChildren(!1);
        }, n.start = function () {
          this._onTTFLoaded(), this.node.on(U.ANCHOR_CHANGED, this._updateRichTextPosition, this);
        }, n.onRestore = function () {}, n.onDestroy = function () {
          for (var t, e = _(this._segments); !(t = e()).done;) {
            var i = t.value;
            i.node.removeFromParent(), i.type === qe ? Ke.put(i) : i.type === Je && ti.put(i);
          }

          this.node.off(U.ANCHOR_CHANGED, this._updateRichTextPosition, this), this.node.off(U.LAYER_CHANGED, this._applyLayer, this);
        }, n._addEventListeners = function () {
          this.node.on(U.TOUCH_END, this._onTouchEnded, this);
        }, n._removeEventListeners = function () {
          this.node.off(U.TOUCH_END, this._onTouchEnded, this);
        }, n._updateLabelSegmentTextAttributes = function () {
          var t = this;

          this._segments.forEach(function (e) {
            t._applyTextAttribute(e);
          });
        }, n._createFontLabel = function (t) {
          return ii(qe, t);
        }, n._createImage = function (t) {
          return ii(Je, t);
        }, n._onTTFLoaded = function () {
          this._font, this._layoutDirty = !0, this._updateRichText();
        }, n.SplitLongStringApproximatelyIn2048 = function (t, e) {
          var i = [];
          if (this._calculateSize(e, t).x < 2048) i.push(t);else for (var n = t.split("\n"), r = 0; r < n.length; r++) {
            if (this._calculateSize(e, n[r]).x < 2048) i.push(n[r]);else {
              var s = this.splitLongStringOver2048(n[r], e);
              i.push.apply(i, s);
            }
          }
          return i;
        }, n.splitLongStringOver2048 = function (t, e) {
          for (var i = [], n = t, r = 0, s = n.length / 2, o = n.substring(r, s), a = n.substring(s), l = this._calculateSize(e, o), h = (this._calculateSize(e, a), 1 * this.maxWidth); l.x > h;) {
            if ((s /= 2) < 1) {
              s *= 2;
              break;
            }

            o = o.substring(r, s), a = n.substring(s), l = this._calculateSize(e, o);
          }

          for (var c = 1e3, u = 1; c && r < t.length;) {
            for (; c && l.x < h;) {
              var p = st(a);
              p && p.length > 0 && (u = p[0].length), s += u, o = n.substring(r, s), a = n.substring(s), l = this._calculateSize(e, o), c--;
            }

            for (; c && o.length >= 2 && l.x > h;) {
              s -= u, o = n.substring(r, s), l = this._calculateSize(e, o), u = 1, c--;
            }

            if (o.length >= 2) {
              var _ = ot(o);

              _ && _.length > 0 && o !== _[0] && (s -= _[0].length, o = n.substring(r, s));
            }

            if (i.push(o), r = s, s += o.length, o = n.substring(r, s), a = n.substring(s), c--, this._calculateSize(e, a).x < 2048) {
              r = t.length, s = t.length, o = a, i.push(o);
              break;
            }

            l = this._calculateSize(e, o);
          }

          return i;
        }, n._measureText = function (t, e) {
          var i = this,
              n = function n(e) {
            return i._calculateSize(t, e).width;
          };

          return e ? n(e) : n;
        }, n._calculateSize = function (t, e) {
          var i;
          return 0 === this._labelSegmentsCache.length ? (i = this._createFontLabel(e), this._labelSegmentsCache.push(i)) : (i = this._labelSegmentsCache[0]).node.getComponent(K).string = e, i.styleIndex = t, this._applyTextAttribute(i), i.node._uiProps.uiTransformComp.contentSize;
        }, n._onTouchEnded = function (t) {
          for (var e, i = this, n = this.node.getComponents(N), r = function r() {
            var r = e.value,
                s = r.clickHandler,
                o = r.clickParam;
            s && i._containsTouchLocation(r, t.touch.getUILocation()) && (n.forEach(function (e) {
              var i = e[s];
              e.enabledInHierarchy && i && i.call(e, t, o);
            }), t.propagationStopped = !0);
          }, s = _(this._segments); !(e = s()).done;) {
            r();
          }
        }, n._containsTouchLocation = function (t, e) {
          var i = t.node.getComponent(mt);
          return !!i && i.getBoundingBoxToWorld().contains(e);
        }, n._resetState = function () {
          for (var t = this.node.children, e = t.length - 1; e >= 0; e--) {
            var i = t[e];

            if (i.name === qe || i.name === Je) {
              i.parent === this.node ? i.parent = null : t.splice(e, 1);
              var n = ei(i.name);
              n.node = i, i.name === qe ? (n.comp = i.getComponent(K), Ke.put(n)) : (n.comp = i.getComponent(at), ti.put(n)), this._labelChildrenNum--;
            }
          }

          this._segments.length = 0, this._labelSegmentsCache.length = 0, this._linesWidth.length = 0, this._lineOffsetX = 0, this._lineCount = 1, this._labelWidth = 0, this._labelHeight = 0, this._layoutDirty = !0;
        }, n._activateChildren = function (t) {
          for (var e = this.node.children.length - 1; e >= 0; e--) {
            var i = this.node.children[e];
            i.name !== qe && i.name !== Je || (i.active = t);
          }
        }, n._addLabelSegment = function (t, e) {
          var i;
          if (0 === this._labelSegmentsCache.length) i = this._createFontLabel(t);else {
            var n = (i = this._labelSegmentsCache.pop()).node.getComponent(K);

            n && (n.string = t);
          }
          var r = i.comp;
          return r.verticalAlign !== this._verticalAlign && (r.verticalAlign = this._verticalAlign), i.styleIndex = e, i.lineCount = this._lineCount, i.node._uiProps.uiTransformComp.setAnchorPoint(0, 0), i.node.layer = this.node.layer, this.node.insertChild(i.node, this._labelChildrenNum++), this._applyTextAttribute(i), this._segments.push(i), i;
        }, n._updateRichTextWithMaxWidth = function (t, e, i) {
          var n = e;
          if (this._lineOffsetX > 0 && n + this._lineOffsetX > this._maxWidth) for (var r = 0; this._lineOffsetX <= this._maxWidth;) {
            var s = this._getFirstWordLen(t, r, t.length),
                o = t.substr(r, s),
                a = this._measureText(i, o);

            if (!(this._lineOffsetX + a <= this._maxWidth)) {
              if (r > 0) {
                var l = t.substr(0, r);
                this._addLabelSegment(l, i), t = t.substr(r, t.length), n = this._measureText(i, t);
              }

              this._updateLineInfo();

              break;
            }

            this._lineOffsetX += a, r += s;
          }
          if (n > this._maxWidth) for (var h = lt(t, n, this._maxWidth, this._measureText(i)), c = 0; c < h.length; ++c) {
            var u = h[c],
                p = this._addLabelSegment(u, i).node._uiProps.uiTransformComp.contentSize;

            this._lineOffsetX += p.width, h.length > 1 && c < h.length - 1 && this._updateLineInfo();
          } else this._lineOffsetX += n, this._addLabelSegment(t, i);
        }, n._isLastComponentCR = function (t) {
          return t.length - 1 === t.lastIndexOf("\n");
        }, n._updateLineInfo = function () {
          this._linesWidth.push(this._lineOffsetX), this._lineOffsetX = 0, this._lineCount++;
        }, n._needsUpdateTextLayout = function (t) {
          if (this._layoutDirty || !this._textArray || !t) return !0;
          if (this._textArray.length !== t.length) return !0;

          for (var e = 0; e < this._textArray.length; e++) {
            var i = this._textArray[e],
                n = t[e];
            if (i.text !== n.text) return !0;
            var r = i.style,
                s = n.style;

            if (r) {
              if (s) {
                if (!!s.outline != !!r.outline) return !0;
                if (r.size !== s.size || r.italic !== s.italic || r.isImage !== s.isImage) return !0;
                if (r.src !== s.src || r.imageAlign !== s.imageAlign || r.imageHeight !== s.imageHeight || r.imageWidth !== s.imageWidth || r.imageOffset !== s.imageOffset) return !0;
              } else if (r.size || r.italic || r.isImage || r.outline) return !0;
            } else if (s && (s.size || s.italic || s.isImage || s.outline)) return !0;
          }

          return !1;
        }, n._addRichTextImageElement = function (t) {
          if (t.style) {
            var e = t.style,
                i = e.src,
                n = this._imageAtlas && i && this._imageAtlas.getSpriteFrame(i);

            if (n) {
              var r = this._createImage(n);

              switch (r.comp, e.imageAlign) {
                case "top":
                  r.node._uiProps.uiTransformComp.setAnchorPoint(0, 1);

                  break;

                case "center":
                  r.node._uiProps.uiTransformComp.setAnchorPoint(0, .5);

                  break;

                default:
                  r.node._uiProps.uiTransformComp.setAnchorPoint(0, 0);

              }

              e.imageOffset && (r.imageOffset = e.imageOffset), r.node.layer = this.node.layer, this.node.insertChild(r.node, this._labelChildrenNum++), this._segments.push(r);
              var s = n.rect.clone(),
                  o = 1,
                  a = s.width,
                  l = s.height,
                  h = e.imageWidth || 0,
                  c = e.imageHeight || 0;
              c > 0 ? (a *= o = c / l, l *= o) : (a *= o = this._lineHeight / l, l *= o), h > 0 && (a = h), this._maxWidth > 0 ? (this._lineOffsetX + a > this._maxWidth && this._updateLineInfo(), this._lineOffsetX += a) : (this._lineOffsetX += a, this._lineOffsetX > this._labelWidth && (this._labelWidth = this._lineOffsetX)), r.node._uiProps.uiTransformComp.setContentSize(a, l), r.lineCount = this._lineCount, r.clickHandler = "", r.clickParam = "";
              var u = e.event;
              u && (r.clickHandler = u.click, r.clickParam = u.param);
            } else f(4400);
          }
        }, n._updateRichText = function () {
          if (this.enabledInHierarchy) {
            var t = $e.parse(this._string);
            if (!this._needsUpdateTextLayout(t)) return this._textArray = t.slice(), void this._updateLabelSegmentTextAttributes();
            this._textArray = t.slice(), this._resetState();

            for (var e, i = !1, n = 0; n < this._textArray.length; ++n) {
              var r = this._textArray[n],
                  s = r.text;

              if (void 0 !== s) {
                if ("" === s) {
                  if (r.style && r.style.isNewLine) {
                    this._updateLineInfo();

                    continue;
                  }

                  if (r.style && r.style.isImage && this._imageAtlas) {
                    this._addRichTextImageElement(r);

                    continue;
                  }
                }

                for (var o = (s = this.SplitLongStringApproximatelyIn2048(s, n).join("\n")).split("\n"), a = 0; a < o.length; ++a) {
                  var l = o[a];
                  if ("" !== l) {
                    if (i = !1, this._maxWidth > 0) {
                      var h = this._measureText(n, l);

                      this._updateRichTextWithMaxWidth(l, h, n), o.length > 1 && a < o.length - 1 && this._updateLineInfo();
                    } else e = this._addLabelSegment(l, n), this._lineOffsetX += e.node._uiProps.uiTransformComp.width, this._lineOffsetX > this._labelWidth && (this._labelWidth = this._lineOffsetX), o.length > 1 && a < o.length - 1 && this._updateLineInfo();
                  } else {
                    if (this._isLastComponentCR(s) && a === o.length - 1) continue;
                    this._updateLineInfo(), i = !0;
                  }
                }
              }
            }

            i || this._linesWidth.push(this._lineOffsetX), this._maxWidth > 0 && (this._labelWidth = this._maxWidth), this._labelHeight = (this._lineCount + ht) * this._lineHeight, this.node._uiProps.uiTransformComp.setContentSize(this._labelWidth, this._labelHeight), this._updateRichTextPosition(), this._layoutDirty = !1;
          }
        }, n._getFirstWordLen = function (t, e, i) {
          var n = t.charAt(e);
          if (ct(n) || ut(n)) return 1;

          for (var r = 1, s = e + 1; s < i && (n = t.charAt(s), !ut(n) && !ct(n)); ++s) {
            r++;
          }

          return r;
        }, n._updateRichTextPosition = function () {
          for (var t = 0, e = 1, i = this._lineCount, n = this.node._uiProps.uiTransformComp, r = n.anchorX, s = n.anchorY, o = 0; o < this._segments.length; ++o) {
            var a = this._segments[o],
                l = a.lineCount;
            l > e && (t = 0, e = l);
            var h = this._labelWidth * (.5 * this._horizontalAlign - r);

            switch (this._horizontalAlign) {
              case tt.LEFT:
                break;

              case tt.CENTER:
                h -= this._linesWidth[l - 1] / 2;
                break;

              case tt.RIGHT:
                h -= this._linesWidth[l - 1];
            }

            var c = a.node.position;

            if (a.node.setPosition(t + h, this._lineHeight * (i - l) - this._labelHeight * s, c.z), l === e && (t += a.node._uiProps.uiTransformComp.width), a.node.getComponent(at)) {
              var u = a.node.position.clone(),
                  p = this._lineHeight,
                  _ = this._lineHeight * (1 + ht);

              switch (a.node._uiProps.uiTransformComp.anchorY) {
                case 1:
                  u.y += p + (_ - p) / 2;
                  break;

                case .5:
                  u.y += _ / 2;
                  break;

                default:
                  u.y += (_ - p) / 2;
              }

              if (a.imageOffset) {
                var d = a.imageOffset.split(",");

                if (1 === d.length && d[0]) {
                  var f = parseFloat(d[0]);
                  Number.isInteger(f) && (u.y += f);
                } else if (2 === d.length) {
                  var g = parseFloat(d[0]),
                      m = parseFloat(d[1]);
                  Number.isInteger(g) && (u.x += g), Number.isInteger(m) && (u.y += m);
                }
              }

              a.node.position = u;
            }

            var y = a.node.getComponent(Ze);

            if (y) {
              var b = a.node.position.clone();
              b.y -= y.width, a.node.position = b;
            }
          }
        }, n._convertLiteralColorValue = function (t) {
          var e = t.toUpperCase();
          return S[e] ? S[e] : new S().fromHEX(t);
        }, n._applyTextAttribute = function (t) {
          var e = t.node.getComponent(K);

          if (e) {
            this._resetLabelState(e);

            var i,
                n = t.styleIndex;

            if (this._textArray[n] && (i = this._textArray[n].style), i) {
              if (e.color = this._convertLiteralColorValue(i.color || "white"), e.isBold = !!i.bold, e.isItalic = !!i.italic, e.isUnderline = !!i.underline, i.outline) {
                var r = t.node.getComponent(Ze);
                r || (r = t.node.addComponent(Ze)), r.color = this._convertLiteralColorValue(i.outline.color), r.width = i.outline.width;
              }

              e.fontSize = i.size || this._fontSize, t.clickHandler = "", t.clickParam = "";
              var s = i.event;
              s && (t.clickHandler = s.click || "", t.clickParam = s.param || "");
            }

            e.cacheMode = this._cacheMode, this._font instanceof it && !this._isSystemFontUsed ? e.font = this._font : e.fontFamily = this._fontFamily, e.useSystemFont = this._isSystemFontUsed, e.lineHeight = this._lineHeight, e.updateRenderData(!0);
            var o = e._assembler;
            o && o.updateRenderData(e);
          }
        }, n._applyLayer = function () {
          for (var t, e = _(this._segments); !(t = e()).done;) {
            t.value.node.layer = this.node.layer;
          }
        }, n._resetLabelState = function (t) {
          t.fontSize = this._fontSize, t.color = S.WHITE, t.isBold = !1, t.isItalic = !1, t.isUnderline = !1;
        }, h(e, [{
          key: "string",
          get: function get() {
            return this._string;
          },
          set: function set(t) {
            this._string !== t && (this._string = t, this._updateRichTextStatus());
          }
        }, {
          key: "horizontalAlign",
          get: function get() {
            return this._horizontalAlign;
          },
          set: function set(t) {
            this.horizontalAlign !== t && (this._horizontalAlign = t, this._layoutDirty = !0, this._updateRichTextStatus());
          }
        }, {
          key: "verticalAlign",
          get: function get() {
            return this._verticalAlign;
          },
          set: function set(t) {
            this._verticalAlign !== t && (this._verticalAlign = t, this._layoutDirty = !0, this._updateRichTextStatus());
          }
        }, {
          key: "fontSize",
          get: function get() {
            return this._fontSize;
          },
          set: function set(t) {
            this._fontSize !== t && (this._fontSize = t, this._layoutDirty = !0, this._updateRichTextStatus());
          }
        }, {
          key: "fontFamily",
          get: function get() {
            return this._fontFamily;
          },
          set: function set(t) {
            this._fontFamily !== t && (this._fontFamily = t, this._layoutDirty = !0, this._updateRichTextStatus());
          }
        }, {
          key: "font",
          get: function get() {
            return this._font;
          },
          set: function set(t) {
            this._font !== t && (this._font = t, this._layoutDirty = !0, this._font ? (this.useSystemFont = !1, this._onTTFLoaded()) : this.useSystemFont = !0, this._updateRichTextStatus());
          }
        }, {
          key: "useSystemFont",
          get: function get() {
            return this._isSystemFontUsed;
          },
          set: function set(t) {
            this._isSystemFontUsed !== t && (this._isSystemFontUsed = t, this._layoutDirty = !0, this._updateRichTextStatus());
          }
        }, {
          key: "cacheMode",
          get: function get() {
            return this._cacheMode;
          },
          set: function set(t) {
            this._cacheMode !== t && (this._cacheMode = t, this._updateRichTextStatus());
          }
        }, {
          key: "maxWidth",
          get: function get() {
            return this._maxWidth;
          },
          set: function set(t) {
            this._maxWidth !== t && (this._maxWidth = t, this._layoutDirty = !0, this._updateRichTextStatus());
          }
        }, {
          key: "lineHeight",
          get: function get() {
            return this._lineHeight;
          },
          set: function set(t) {
            this._lineHeight !== t && (this._lineHeight = t, this._layoutDirty = !0, this._updateRichTextStatus());
          }
        }, {
          key: "imageAtlas",
          get: function get() {
            return this._imageAtlas;
          },
          set: function set(t) {
            this._imageAtlas !== t && (this._imageAtlas = t, this._layoutDirty = !0, this._updateRichTextStatus());
          }
        }, {
          key: "handleTouchEvent",
          get: function get() {
            return this._handleTouchEvent;
          },
          set: function set(t) {
            this._handleTouchEvent !== t && (this._handleTouchEvent = t, this.enabledInHierarchy && (this.handleTouchEvent ? this._addEventListeners() : this._removeEventListeners()));
          }
        }]), e;
      }(N), Be.HorizontalAlign = tt, Be.VerticalAlign = et, c((Le = Xe).prototype, "string", [B, ue], Object.getOwnPropertyDescriptor(Le.prototype, "string"), Le.prototype), c(Le.prototype, "horizontalAlign", [pe, _e], Object.getOwnPropertyDescriptor(Le.prototype, "horizontalAlign"), Le.prototype), c(Le.prototype, "verticalAlign", [de, fe], Object.getOwnPropertyDescriptor(Le.prototype, "verticalAlign"), Le.prototype), c(Le.prototype, "fontSize", [ge], Object.getOwnPropertyDescriptor(Le.prototype, "fontSize"), Le.prototype), c(Le.prototype, "fontFamily", [me], Object.getOwnPropertyDescriptor(Le.prototype, "fontFamily"), Le.prototype), c(Le.prototype, "font", [ye, be], Object.getOwnPropertyDescriptor(Le.prototype, "font"), Le.prototype), c(Le.prototype, "useSystemFont", [ve, Ce], Object.getOwnPropertyDescriptor(Le.prototype, "useSystemFont"), Le.prototype), c(Le.prototype, "cacheMode", [Se, Ae], Object.getOwnPropertyDescriptor(Le.prototype, "cacheMode"), Le.prototype), c(Le.prototype, "maxWidth", [Te], Object.getOwnPropertyDescriptor(Le.prototype, "maxWidth"), Le.prototype), c(Le.prototype, "lineHeight", [xe], Object.getOwnPropertyDescriptor(Le.prototype, "lineHeight"), Le.prototype), c(Le.prototype, "imageAtlas", [Oe, we], Object.getOwnPropertyDescriptor(Le.prototype, "imageAtlas"), Le.prototype), c(Le.prototype, "handleTouchEvent", [De], Object.getOwnPropertyDescriptor(Le.prototype, "handleTouchEvent"), Le.prototype), Ie = c(Le.prototype, "_lineHeight", [H], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 40;
        }
      }), Re = c(Le.prototype, "_string", [H], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return "<color=#00ff00>Rich</color><color=#0fffff>Text</color>";
        }
      }), ke = c(Le.prototype, "_horizontalAlign", [H], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return tt.LEFT;
        }
      }), Me = c(Le.prototype, "_verticalAlign", [H], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return et.TOP;
        }
      }), Fe = c(Le.prototype, "_fontSize", [H], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 40;
        }
      }), Pe = c(Le.prototype, "_maxWidth", [H], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 0;
        }
      }), ze = c(Le.prototype, "_fontFamily", [H], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return "Arial";
        }
      }), He = c(Le.prototype, "_font", [H], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return null;
        }
      }), We = c(Le.prototype, "_isSystemFontUsed", [H], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !0;
        }
      }), je = c(Le.prototype, "_userDefinedFont", [H], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return null;
        }
      }), Ne = c(Le.prototype, "_cacheMode", [H], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return nt.NONE;
        }
      }), Ue = c(Le.prototype, "_imageAtlas", [H], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return null;
        }
      }), Ge = c(Le.prototype, "_handleTouchEvent", [H], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !0;
        }
      }), Ee = Le)) || Ee) || Ee) || Ee) || Ee) || Ee));
      r.RichText = ri;
      var si = t("U", v("cc.UIMeshRenderer")(ni = L()(ni = I(110)(ni = R()(ni = W(ni = function (t) {
        function e() {
          for (var e, i = arguments.length, n = new Array(i), r = 0; r < i; r++) {
            n[r] = arguments[r];
          }

          return (e = t.call.apply(t, [this].concat(n)) || this)._modelComponent = null, e.stencilStage = dt.DISABLED, e;
        }

        i(e, t);
        var n = e.prototype;
        return n.__preload = function () {
          this.node._uiProps.uiComp = this;
        }, n.onLoad = function () {
          this.node._uiProps.uiTransformComp || this.node.addComponent("cc.UITransform"), this._modelComponent = this.getComponent("cc.RenderableComponent"), this._modelComponent || console.warn("node '" + (this.node && this.node.name) + "' doesn't have any renderable component");
        }, n.onDestroy = function () {
          this.node._uiProps.uiComp === this && (this.node._uiProps.uiComp = null), this._modelComponent = this.getComponent("cc.RenderableComponent"), this._modelComponent && (this._modelComponent._sceneGetter = null);
        }, n.updateAssembler = function (t) {
          if (this._modelComponent) {
            var e = this._modelComponent._collectModels();

            this._modelComponent._detachFromScene();

            for (var i = 0; i < e.length; i++) {
              e[i].enabled && t.commitModel(this, e[i], this._modelComponent.material);
            }

            return !0;
          }

          return !1;
        }, n.postUpdateAssembler = function () {}, n.update = function () {
          this._fitUIRenderQueue();
        }, n._fitUIRenderQueue = function () {
          if (this._modelComponent) for (var t = this._modelComponent.sharedMaterials.length, e = 0; e < t; e++) {
            var i = this._modelComponent.getMaterialInstance(e);

            if (null != i) for (var n = i.passes, r = n.length, s = 0; s < r; s++) {
              n[s]._priority = X.MAX - 11, i.recompileShaders({
                CC_FORCE_FORWARD_SHADING: !0
              }, s);
            }
          }
        }, n.markForUpdateRenderData = function () {}, n.setNodeDirty = function () {}, n.setTextureDirty = function () {}, h(e, [{
          key: "modelComponent",
          get: function get() {
            return this._modelComponent;
          }
        }]), e;
      }(N)) || ni) || ni) || ni) || ni) || ni);
      r.UIMeshRenderer = si;

      var oi,
          ai,
          li,
          hi,
          ci,
          ui,
          pi,
          _i,
          di,
          fi,
          gi,
          mi,
          yi,
          bi,
          vi,
          Ci,
          Si,
          Ai,
          Ti,
          xi,
          Oi,
          wi,
          Di,
          Ei,
          Li,
          Ii,
          Ri,
          ki,
          Mi,
          Fi,
          Pi,
          zi = V.Enum.NONE | V.Enum.UI_3D,
          Hi = t("D", function () {
        function t() {
          this.bufferBatch = null, this.camera = null, this.renderScene = null, this.model = null, this.texture = null, this.sampler = null, this.useLocalData = null, this.isStatic = !1, this.textureHash = 0, this.samplerHash = 0, this._passes = [], this._shaders = [], this._visFlags = zi, this._inputAssembler = null, this._descriptorSet = null;
        }

        var e = t.prototype;
        return e.destroy = function () {
          this._passes = [];
        }, e.clear = function () {
          this.bufferBatch = null, this.inputAssembler = null, this.descriptorSet = null, this.camera = null, this.texture = null, this.sampler = null, this.textureHash = 0, this.samplerHash = 0, this.model = null, this.isStatic = !1, this.useLocalData = null, this.visFlags = zi, this.renderScene = null;
        }, e.fillPasses = function (t, e, i, n, s, o) {
          if (t) {
            var a = t.passes;
            if (!a) return;
            var l = 0;
            this._shaders.length = a.length;

            for (var h = 0; h < a.length; h++) {
              this._passes[h] || (this._passes[h] = new Y(r.director.root));
              var c = a[h],
                  u = this._passes[h];
              c.update(), e || (e = c.depthStencilState, i = 0), n || (n = c.blendState, s = 0), -1 === s && (s = 0), l = i << 16 | s, u._initPassFromTarget(c, e, n, l), this._shaders[h] = u.getShaderVariant(o);
            }
          }
        }, h(t, [{
          key: "native",
          get: function get() {
            return this._nativeObj;
          }
        }, {
          key: "inputAssembler",
          get: function get() {
            return this._inputAssembler;
          },
          set: function set(t) {
            this._inputAssembler = t;
          }
        }, {
          key: "descriptorSet",
          get: function get() {
            return this._descriptorSet;
          },
          set: function set(t) {
            this._descriptorSet = t;
          }
        }, {
          key: "visFlags",
          get: function get() {
            return this._visFlags;
          },
          set: function set(t) {
            this._visFlags = t;
          }
        }, {
          key: "passes",
          get: function get() {
            return this._passes;
          }
        }, {
          key: "shaders",
          get: function get() {
            return this._shaders;
          }
        }]), t;
      }()),
          Wi = t("a", (oi = v("cc.UIStaticBatch"), ai = L(), li = R(), hi = I(110), ci = F(), oi(ui = ai(ui = li(ui = hi((_i = function (t) {
        function e() {
          for (var e, i = arguments.length, n = new Array(i), r = 0; r < i; r++) {
            n[r] = arguments[r];
          }

          return (e = t.call.apply(t, [this].concat(n)) || this)._init = !1, e._bufferAccessor = null, e._dirty = !0, e._uiDrawBatchList = [], e;
        }

        i(e, t);
        var n = e.prototype;
        return n.onLoad = function () {}, n.onDestroy = function () {}, n.updateAssembler = function () {}, n.postUpdateAssembler = function () {}, n.markAsDirty = function () {}, n._requireDrawBatch = function () {
          var t = new Hi();
          return t.isStatic = !0, this._uiDrawBatchList.push(t), t;
        }, n._clearData = function () {
          if (this._bufferAccessor) {
            this._bufferAccessor.reset();

            for (var t = this._getBatcher(), e = 0; e < this._uiDrawBatchList.length; e++) {
              this._uiDrawBatchList[e].destroy(t);
            }
          }

          this._uiDrawBatchList.length = 0, this._init = !1;
        }, n._getBatcher = function () {
          return q.root && q.root.batcher2D ? q.root.batcher2D : (f(9301), null);
        }, h(e, [{
          key: "color",
          get: function get() {
            return this._color;
          },
          set: function set(t) {
            this._color !== t && this._color.set(t);
          }
        }, {
          key: "drawBatchList",
          get: function get() {
            return this._uiDrawBatchList;
          }
        }]), e;
      }(ft), c((pi = _i).prototype, "color", [D, ci], Object.getOwnPropertyDescriptor(pi.prototype, "color"), pi.prototype), ui = pi)) || ui) || ui) || ui) || ui)),
          ji = (t("b", (di = v("cc.LabelShadow"), fi = L(), gi = I(110), mi = R(), yi = j(K), bi = k(), vi = k(), Ci = k(), di(Si = fi(Si = gi(Si = mi(Si = yi(Si = W((wi = function (t) {
        function e() {
          for (var e, i = arguments.length, n = new Array(i), r = 0; r < i; r++) {
            n[r] = arguments[r];
          }

          return e = t.call.apply(t, [this].concat(n)) || this, u(e, "_color", Ti, p(e)), u(e, "_offset", xi, p(e)), u(e, "_blur", Oi, p(e)), e;
        }

        i(e, t);
        var n = e.prototype;
        return n.onEnable = function () {
          this._updateRenderData();
        }, n.onDisable = function () {
          this._updateRenderData();
        }, n._updateRenderData = function () {
          var t = this.node.getComponent(K);
          t && t.updateRenderData(!0);
        }, h(e, [{
          key: "color",
          get: function get() {
            return this._color;
          },
          set: function set(t) {
            this._color !== t && (this._color.set(t), this._updateRenderData());
          }
        }, {
          key: "offset",
          get: function get() {
            return this._offset;
          },
          set: function set(t) {
            this._offset = t, this._updateRenderData();
          }
        }, {
          key: "blur",
          get: function get() {
            return this._blur;
          },
          set: function set(t) {
            this._blur = t, this._updateRenderData();
          }
        }]), e;
      }(N), Ti = c((Ai = wi).prototype, "_color", [H], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return new S(0, 0, 0, 255);
        }
      }), xi = c(Ai.prototype, "_offset", [H], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return new b(2, 2);
        }
      }), Oi = c(Ai.prototype, "_blur", [H], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 2;
        }
      }), c(Ai.prototype, "color", [bi], Object.getOwnPropertyDescriptor(Ai.prototype, "color"), Ai.prototype), c(Ai.prototype, "offset", [vi], Object.getOwnPropertyDescriptor(Ai.prototype, "offset"), Ai.prototype), c(Ai.prototype, "blur", [Ci], Object.getOwnPropertyDescriptor(Ai.prototype, "blur"), Ai.prototype), Si = Ai)) || Si) || Si) || Si) || Si) || Si) || Si)), t("c", (Di = v("cc.UIOpacity"), Ei = L(), Li = I(110), Ii = R(), Ri = k(), Di(ki = Ei(ki = Li(ki = Ii(ki = W(ki = Q((Pi = function (t) {
        function e() {
          for (var e, i = arguments.length, n = new Array(i), r = 0; r < i; r++) {
            n[r] = arguments[r];
          }

          return e = t.call.apply(t, [this].concat(n)) || this, u(e, "_opacity", Fi, p(e)), e;
        }

        i(e, t);
        var n = e.prototype;
        return n.onEnable = function () {
          this.node._uiProps.localOpacity = this._opacity / 255;
        }, n.onDisable = function () {
          this.node._uiProps.localOpacity = 1;
        }, h(e, [{
          key: "opacity",
          get: function get() {
            return this._opacity;
          },
          set: function set(t) {
            this._opacity !== t && (t = g(t, 0, 255), this._opacity = t, this.node._uiProps.localOpacity = t / 255);
          }
        }]), e;
      }(N), c((Mi = Pi).prototype, "opacity", [Z, Ri], Object.getOwnPropertyDescriptor(Mi.prototype, "opacity"), Mi.prototype), Fi = c(Mi.prototype, "_opacity", [H], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 255;
        }
      }), ki = Mi)) || ki) || ki) || ki) || ki) || ki) || ki)));

      r.MaskComponent = Qt, m.setClassAlias(Qt, "cc.MaskComponent"), r.LabelComponent = K, m.setClassAlias(K, "cc.LabelComponent"), r.LabelOutlineComponent = Ze, m.setClassAlias(Ze, "cc.LabelOutlineComponent"), r.RichTextComponent = ri, m.setClassAlias(ri, "cc.RichTextComponent"), r.SpriteComponent = at, m.setClassAlias(at, "cc.SpriteComponent"), r.UIModelComponent = si, m.setClassAlias(si, "cc.UIModelComponent"), r.GraphicsComponent = yt, m.setClassAlias(yt, "cc.GraphicsComponent"), m.setClassAlias(Wi, "cc.UIStaticBatchComponent"), m.setClassAlias(ji, "cc.UIOpacityComponent");
    }
  };
}); 
 			}); 
		define("__plugin__/wx0446ba2621dda60a/deprecated-ef6bb945.js", function(require, module, exports){ 			
"use strict";

System.register(["./texture-barrier-60b5983b.js", "./json-asset-933a1d4c.js", "./renderable-component-7c6600ed.js", "./deprecated-26630860.js"], function (e) {
  "use strict";

  var t, i, r, n, s, a, o, h, c, u, _, l, d, p, f, m, g, v, y, T, E, b, w, S, F, D, P, C, N, A, k, I, x, O, R, L, W, M, z, H, U, j, V, B, G, X, Y, K, q, J, $, Q, Z, ee, te, ie, re, ne, se, ae, oe, he, ce, ue, _e, le, de, pe, fe, me, ge, ve, ye, Te, Ee, be, we;

  return {
    setters: [function (e) {
      t = e.bU, i = e.bv, r = e.l, n = e.bT, s = e.g, a = e.f, o = e.d, h = e.c, c = e.cs, u = e.c4, _ = e.c8, l = e.k, d = e.aq, p = e.r, f = e.s, m = e.m, g = e.aM, v = e.i, y = e.aF, T = e.aG, E = e.K, b = e.aJ, w = e.F, S = e.P, F = e.bC, D = e.e, P = e.cA, C = e.cD, N = e.b$, A = e.bJ, k = e.c0, I = e.c1, x = e.a5, O = e.bX;
    }, function (e) {
      R = e.ca, L = e.bo, W = e.aP, M = e.b7, z = e.bF, H = e.b6, U = e.cb, j = e.ba, V = e.bW, B = e.bZ, G = e.bX, X = e.b$, Y = e.cc, K = e.Q, q = e.b8, J = e.aX, $ = e.cd, Q = e.ce, Z = e.cf, ee = e.ad, te = e.cg, ie = e.ch, re = e.bY, ne = e.ci, se = e.bm, ae = e.a5, oe = e.a3, he = e.cj, ce = e.ax;
    }, function (e) {
      ue = e.L, _e = e.R, le = e.e, de = e.a, pe = e.C, fe = e.b, me = e.d, ge = e.c, ve = e.S;
    }, function (e) {
      ye = e.F, Te = e.D, Ee = e.g, be = e.G, we = e.v;
    }],
    execute: function execute() {
      function Se() {
        var e = new ye();
        return e.initialize({
          flows: []
        }), e;
      }

      e("c", Se);
      var Fe = e("a", function () {
        function e() {
          this._id = "", this._priority = 0, this._executeInEditMode = !1;
        }

        e.sortByPriority = function (e, t) {
          return e._priority < t._priority ? 1 : e._priority > t.priority ? -1 : 0;
        };

        var i = e.prototype;
        return i.init = function () {}, i.update = function () {}, i.postUpdate = function () {}, t(e, [{
          key: "priority",
          get: function get() {
            return this._priority;
          },
          set: function set(e) {
            this._priority = e;
          }
        }, {
          key: "id",
          get: function get() {
            return this._id;
          },
          set: function set(e) {
            this._id = e;
          }
        }]), e;
      }());
      Fe.Priority = i({
        LOW: 0,
        MEDIUM: 100,
        HIGH: 200,
        SCHEDULER: 1 << 31 >>> 0
      });

      var De = new u("Scheduler"),
          Pe = function Pe(e, t, i, r) {
        this.target = void 0, this.priority = void 0, this.paused = void 0, this.markedForDeletion = void 0, this.target = e, this.priority = t, this.paused = i, this.markedForDeletion = r;
      };

      Pe.get = function (e, t, i, r) {
        var n = Pe._listEntries.pop();

        return n ? (n.target = e, n.priority = t, n.paused = i, n.markedForDeletion = r) : n = new Pe(e, t, i, r), n;
      }, Pe.put = function (e) {
        Pe._listEntries.length < 20 && (e.target = null, Pe._listEntries.push(e));
      }, Pe._listEntries = [];

      var Ce = function Ce(e, t, i, r) {
        this.list = void 0, this.entry = void 0, this.target = void 0, this.callback = void 0, this.list = e, this.entry = t, this.target = i, this.callback = r;
      };

      Ce.get = function (e, t, i, r) {
        var n = Ce._hashUpdateEntries.pop();

        return n ? (n.list = e, n.entry = t, n.target = i, n.callback = r) : n = new Ce(e, t, i, r), n;
      }, Ce.put = function (e) {
        Ce._hashUpdateEntries.length < 20 && (e.list = e.entry = e.target = e.callback = null, Ce._hashUpdateEntries.push(e));
      }, Ce._hashUpdateEntries = [];

      var Ne = function Ne(e, t, i, r, n, s) {
        this.timers = void 0, this.target = void 0, this.timerIndex = void 0, this.currentTimer = void 0, this.currentTimerSalvaged = void 0, this.paused = void 0, this.timers = e, this.target = t, this.timerIndex = i, this.currentTimer = r, this.currentTimerSalvaged = n, this.paused = s;
      };

      Ne.get = function (e, t, i, r, n, s) {
        var a = Ne._hashTimerEntries.pop();

        return a ? (a.timers = e, a.target = t, a.timerIndex = i, a.currentTimer = r, a.currentTimerSalvaged = n, a.paused = s) : a = new Ne(e, t, i, r, n, s), a;
      }, Ne.put = function (e) {
        Ne._hashTimerEntries.length < 20 && (e.timers = e.target = e.currentTimer = null, Ne._hashTimerEntries.push(e));
      }, Ne._hashTimerEntries = [];

      var Ae = function () {
        function e() {
          this._lock = void 0, this._scheduler = void 0, this._elapsed = void 0, this._runForever = void 0, this._useDelay = void 0, this._timesExecuted = void 0, this._repeat = void 0, this._delay = void 0, this._interval = void 0, this._target = void 0, this._callback = void 0, this._lock = !1, this._scheduler = null, this._elapsed = -1, this._runForever = !1, this._useDelay = !1, this._timesExecuted = 0, this._repeat = 0, this._delay = 0, this._interval = 0, this._target = null, this._callback = null;
        }

        var t = e.prototype;
        return t.initWithCallback = function (e, t, i, n, s, a) {
          return this._lock = !1, this._scheduler = e, this._target = i, this._callback = t, this._elapsed = -1, this._interval = n, this._delay = a, this._useDelay = this._delay > 0, this._repeat = s, this._runForever = this._repeat === r.macro.REPEAT_FOREVER, !0;
        }, t.getInterval = function () {
          return this._interval;
        }, t.setInterval = function (e) {
          this._interval = e;
        }, t.update = function (e) {
          -1 === this._elapsed ? (this._elapsed = 0, this._timesExecuted = 0) : (this._elapsed += e, this._runForever && !this._useDelay ? this._elapsed >= this._interval && (this.trigger(), this._elapsed = 0) : (this._useDelay ? this._elapsed >= this._delay && (this.trigger(), this._elapsed -= this._delay, this._timesExecuted += 1, this._useDelay = !1) : this._elapsed >= this._interval && (this.trigger(), this._elapsed = 0, this._timesExecuted += 1), this._callback && !this._runForever && this._timesExecuted > this._repeat && this.cancel()));
        }, t.getCallback = function () {
          return this._callback;
        }, t.trigger = function () {
          this._target && this._callback && (this._lock = !0, this._callback.call(this._target, this._elapsed), this._lock = !1);
        }, t.cancel = function () {
          this._scheduler.unschedule(this._callback, this._target);
        }, e;
      }();

      Ae._timers = [], Ae.get = function () {
        return Ae._timers.pop() || new Ae();
      }, Ae.put = function (e) {
        Ae._timers.length < 20 && !e._lock && (e._scheduler = e._target = e._callback = null, Ae._timers.push(e));
      };
      var ke,
          Ie = e("S", function (e) {
        function t() {
          var t;
          return (t = e.call(this) || this)._timeScale = void 0, t._updatesNegList = void 0, t._updates0List = void 0, t._updatesPosList = void 0, t._hashForUpdates = void 0, t._hashForTimers = void 0, t._currentTarget = void 0, t._currentTargetSalvaged = void 0, t._updateHashLocked = void 0, t._arrayForTimers = void 0, t._timeScale = 1, t._updatesNegList = [], t._updates0List = [], t._updatesPosList = [], t._hashForUpdates = c(!0), t._hashForTimers = c(!0), t._currentTarget = null, t._currentTargetSalvaged = !1, t._updateHashLocked = !1, t._arrayForTimers = [], t;
        }

        n(t, e), t.enableForTarget = function (e) {
          var t = !1;
          (e.uuid || e.id) && (t = !0), t || (e.__instanceId ? o(1513) : e.id = De.getNewId());
        };
        var i = t.prototype;
        return i.setTimeScale = function (e) {
          this._timeScale = e;
        }, i.getTimeScale = function () {
          return this._timeScale;
        }, i.update = function (e) {
          var t, i, r, n, s;

          for (this._updateHashLocked = !0, 1 !== this._timeScale && (e *= this._timeScale), t = 0, r = (i = this._updatesNegList).length; t < r; t++) {
            (n = i[t]).paused || n.markedForDeletion || n.target.update(e);
          }

          for (t = 0, r = (i = this._updates0List).length; t < r; t++) {
            (n = i[t]).paused || n.markedForDeletion || n.target.update(e);
          }

          for (t = 0, r = (i = this._updatesPosList).length; t < r; t++) {
            (n = i[t]).paused || n.markedForDeletion || n.target.update(e);
          }

          var a = this._arrayForTimers;

          for (t = 0; t < a.length; t++) {
            if (s = a[t], this._currentTarget = s, this._currentTargetSalvaged = !1, !s.paused) for (s.timerIndex = 0; s.timerIndex < s.timers.length; ++s.timerIndex) {
              s.currentTimer = s.timers[s.timerIndex], s.currentTimerSalvaged = !1, s.currentTimer.update(e), s.currentTimer = null;
            }
            this._currentTargetSalvaged && 0 === this._currentTarget.timers.length && (this._removeHashElement(this._currentTarget), --t);
          }

          for (t = 0, i = this._updatesNegList; t < i.length;) {
            (n = i[t]).markedForDeletion ? this._removeUpdateFromHash(n) : t++;
          }

          for (t = 0, i = this._updates0List; t < i.length;) {
            (n = i[t]).markedForDeletion ? this._removeUpdateFromHash(n) : t++;
          }

          for (t = 0, i = this._updatesPosList; t < i.length;) {
            (n = i[t]).markedForDeletion ? this._removeUpdateFromHash(n) : t++;
          }

          this._updateHashLocked = !1, this._currentTarget = null;
        }, i.schedule = function (e, t, i, n, c, u) {
          if ("function" != typeof e) {
            var _ = e;
            e = t, t = _;
          }

          3 !== arguments.length && 4 !== arguments.length && 5 !== arguments.length || (u = !!n, n = r.macro.REPEAT_FOREVER, c = 0), s(t, 1502);
          var l = t.uuid || t.id;

          if (l) {
            var d,
                p,
                f = this._hashForTimers[l];
            if (f ? f.paused !== u && o(1511) : (f = Ne.get(null, t, 0, null, null, u), this._arrayForTimers.push(f), this._hashForTimers[l] = f), null == f.timers) f.timers = [];else for (p = 0; p < f.timers.length; ++p) {
              if ((d = f.timers[p]) && e === d._callback) return h(1507, d.getInterval(), i), void (d._interval = i);
            }
            (d = Ae.get()).initWithCallback(this, e, t, i, n, c), f.timers.push(d), this._currentTarget === f && this._currentTargetSalvaged && (this._currentTargetSalvaged = !1);
          } else a(1510);
        }, i.scheduleUpdate = function (e, t, i) {
          var r = e.uuid || e.id;

          if (r) {
            var n = this._hashForUpdates[r];

            if (n && n.entry) {
              if (n.entry.priority === t) return n.entry.markedForDeletion = !1, void (n.entry.paused = i);
              if (this._updateHashLocked) return h(1506), n.entry.markedForDeletion = !1, void (n.entry.paused = i);
              this.unscheduleUpdate(e);
            }

            var s,
                o = Pe.get(e, t, i, !1);
            0 === t ? (s = this._updates0List, this._appendIn(s, o)) : (s = t < 0 ? this._updatesNegList : this._updatesPosList, this._priorityIn(s, o, t)), this._hashForUpdates[r] = Ce.get(s, o, e, null);
          } else a(1510);
        }, i.unschedule = function (e, t) {
          if (t && e) {
            var i = t.uuid || t.id;

            if (i) {
              var r = this._hashForTimers[i];
              if (r) for (var n = r.timers, s = 0, o = n.length; s < o; s++) {
                var h = n[s];
                if (e === h._callback) return h !== r.currentTimer || r.currentTimerSalvaged || (r.currentTimerSalvaged = !0), n.splice(s, 1), Ae.put(h), r.timerIndex >= s && r.timerIndex--, void (0 === n.length && (this._currentTarget === r ? this._currentTargetSalvaged = !0 : this._removeHashElement(r)));
              }
            } else a(1510);
          }
        }, i.unscheduleUpdate = function (e) {
          if (e) {
            var t = e.uuid || e.id;

            if (t) {
              var i = this._hashForUpdates[t];
              i && (this._updateHashLocked ? i.entry.markedForDeletion = !0 : this._removeUpdateFromHash(i.entry));
            } else a(1510);
          }
        }, i.unscheduleAllForTarget = function (e) {
          if (e) {
            var t = e.uuid || e.id;

            if (t) {
              var i = this._hashForTimers[t];

              if (i) {
                var r = i.timers;
                r.indexOf(i.currentTimer) > -1 && !i.currentTimerSalvaged && (i.currentTimerSalvaged = !0);

                for (var n = 0, s = r.length; n < s; n++) {
                  Ae.put(r[n]);
                }

                r.length = 0, this._currentTarget === i ? this._currentTargetSalvaged = !0 : this._removeHashElement(i);
              }

              this.unscheduleUpdate(e);
            } else a(1510);
          }
        }, i.unscheduleAll = function () {
          this.unscheduleAllWithMinPriority(Fe.Priority.SCHEDULER);
        }, i.unscheduleAllWithMinPriority = function (e) {
          var t,
              i,
              r,
              n = this._arrayForTimers;

          for (t = n.length - 1; t >= 0; t--) {
            i = n[t], this.unscheduleAllForTarget(i.target);
          }

          var s = 0;
          if (e < 0) for (t = 0; t < this._updatesNegList.length;) {
            s = this._updatesNegList.length, (r = this._updatesNegList[t]) && r.priority >= e && this.unscheduleUpdate(r.target), s === this._updatesNegList.length && t++;
          }
          if (e <= 0) for (t = 0; t < this._updates0List.length;) {
            s = this._updates0List.length, (r = this._updates0List[t]) && this.unscheduleUpdate(r.target), s === this._updates0List.length && t++;
          }

          for (t = 0; t < this._updatesPosList.length;) {
            s = this._updatesPosList.length, (r = this._updatesPosList[t]) && r.priority >= e && this.unscheduleUpdate(r.target), s === this._updatesPosList.length && t++;
          }
        }, i.isScheduled = function (e, t) {
          s(e, 1508), s(t, 1509);
          var i = t.uuid || t.id;
          if (!i) return a(1510), !1;
          var r = this._hashForTimers[i];
          if (!r) return !1;
          if (null == r.timers) return !1;

          for (var n = r.timers, o = 0; o < n.length; ++o) {
            if (e === n[o]._callback) return !0;
          }

          return !1;
        }, i.pauseAllTargets = function () {
          return this.pauseAllTargetsWithMinPriority(Fe.Priority.SCHEDULER);
        }, i.pauseAllTargetsWithMinPriority = function (e) {
          var t,
              i,
              r,
              n,
              s = [],
              a = this._arrayForTimers;

          for (i = 0, r = a.length; i < r; i++) {
            (t = a[i]) && (t.paused = !0, s.push(t.target));
          }

          if (e < 0) for (i = 0; i < this._updatesNegList.length; i++) {
            (n = this._updatesNegList[i]) && n.priority >= e && (n.paused = !0, s.push(n.target));
          }
          if (e <= 0) for (i = 0; i < this._updates0List.length; i++) {
            (n = this._updates0List[i]) && (n.paused = !0, s.push(n.target));
          }

          for (i = 0; i < this._updatesPosList.length; i++) {
            (n = this._updatesPosList[i]) && n.priority >= e && (n.paused = !0, s.push(n.target));
          }

          return s;
        }, i.resumeTargets = function (e) {
          if (e) for (var t = 0; t < e.length; t++) {
            this.resumeTarget(e[t]);
          }
        }, i.pauseTarget = function (e) {
          s(e, 1503);
          var t = e.uuid || e.id;

          if (t) {
            var i = this._hashForTimers[t];
            i && (i.paused = !0);
            var r = this._hashForUpdates[t];
            r && (r.entry.paused = !0);
          } else a(1510);
        }, i.resumeTarget = function (e) {
          s(e, 1504);
          var t = e.uuid || e.id;

          if (t) {
            var i = this._hashForTimers[t];
            i && (i.paused = !1);
            var r = this._hashForUpdates[t];
            r && (r.entry.paused = !1);
          } else a(1510);
        }, i.isTargetPaused = function (e) {
          s(e, 1505);
          var t = e.uuid || e.id;
          if (!t) return a(1510), !1;
          var i = this._hashForTimers[t];
          if (i) return i.paused;
          var r = this._hashForUpdates[t];
          return !!r && r.entry.paused;
        }, i._removeHashElement = function (e) {
          var t = e.target.uuid || e.target.id;
          delete this._hashForTimers[t];

          for (var i = this._arrayForTimers, r = 0, n = i.length; r < n; r++) {
            if (i[r] === e) {
              i.splice(r, 1);
              break;
            }
          }

          Ne.put(e);
        }, i._removeUpdateFromHash = function (e) {
          var t = e.target.uuid || e.target.id,
              i = this._hashForUpdates[t];

          if (i) {
            for (var r = i.list, n = i.entry, s = 0, a = r.length; s < a; s++) {
              if (r[s] === n) {
                r.splice(s, 1);
                break;
              }
            }

            delete this._hashForUpdates[t], Pe.put(n), Ce.put(i);
          }
        }, i._priorityIn = function (e, t, i) {
          for (var r = 0; r < e.length; r++) {
            if (i < e[r].priority) return void e.splice(r, 0, t);
          }

          e.push(t);
        }, i._appendIn = function (e, t) {
          e.push(t);
        }, t;
      }(Fe));
      Ie.ID = "scheduler", r.Scheduler = Ie;

      var xe = ((ke = {})[_.PORTRAIT] = l.IDENTITY, ke[_.LANDSCAPE_RIGHT] = l.ROTATE_90, ke[_.PORTRAIT_UPSIDE_DOWN] = l.ROTATE_180, ke[_.LANDSCAPE_LEFT] = l.ROTATE_270, ke),
          Oe = function () {
        function e() {
          this._title = "", this._width = 1, this._height = 1, this._swapchain = null, this._renderPass = null, this._colorTextures = [], this._depthStencilTexture = null, this._cameras = [], this._hasOnScreenAttachments = !1, this._hasOffScreenAttachments = !1, this._framebuffer = null;
        }

        e.registerCreateFunc = function (t) {
          t._createWindowFun = function (t) {
            return new e(t);
          };
        };

        var i = e.prototype;
        return i.initialize = function (e, t) {
          if (this._init(), void 0 !== t.title && (this._title = t.title), void 0 !== t.swapchain && (this._swapchain = t.swapchain), this._width = t.width, this._height = t.height, this._renderPass = e.createRenderPass(t.renderPassInfo), t.swapchain) this._setSwapchain(t.swapchain), this._colorTextures.push(t.swapchain.colorTexture), this._depthStencilTexture = t.swapchain.depthStencilTexture;else {
            for (var i = 0; i < t.renderPassInfo.colorAttachments.length; i++) {
              this._colorTextures.push(e.createTexture(new d(p.TEX2D, f.COLOR_ATTACHMENT | f.SAMPLED | f.TRANSFER_SRC, t.renderPassInfo.colorAttachments[i].format, this._width, this._height)));
            }

            t.renderPassInfo.depthStencilAttachment.format !== m.UNKNOWN && (this._depthStencilTexture = e.createTexture(new d(p.TEX2D, f.DEPTH_STENCIL_ATTACHMENT | f.SAMPLED, t.renderPassInfo.depthStencilAttachment.format, this._width, this._height)));
          }
          return this._setFrameBuffer(e.createFramebuffer(new g(this._renderPass, this._colorTextures, this._depthStencilTexture))), !0;
        }, i.destroy = function () {
          this.clearCameras(), this._framebuffer && (this._framebuffer.destroy(), this._framebuffer = null), this._depthStencilTexture && (this._depthStencilTexture.destroy(), this._depthStencilTexture = null);

          for (var e = 0; e < this._colorTextures.length; e++) {
            var t = this._colorTextures[e];
            t && t.destroy();
          }

          this._colorTextures.length = 0, this._destroy();
        }, i.resize = function (e, t) {
          if (this._swapchain) this._swapchain.resize(e, t, xe[R.orientation]), this._width = this._swapchain.width, this._height = this._swapchain.height;else {
            for (var i = 0; i < this._colorTextures.length; i++) {
              this._colorTextures[i].resize(e, t);
            }

            this._depthStencilTexture && this._depthStencilTexture.resize(e, t), this._width = e, this._height = t;
          }
          this.framebuffer && (this.framebuffer.destroy(), this.framebuffer.initialize(new g(this._renderPass, this._colorTextures, this._depthStencilTexture)));

          for (var r, n = v(this._cameras); !(r = n()).done;) {
            r.value.resize(e, t);
          }
        }, i.extractRenderCameras = function (e) {
          for (var t = 0; t < this._cameras.length; t++) {
            var i = this._cameras[t];
            i.enabled && (i.update(), e.push(i));
          }
        }, i.attachCamera = function (e) {
          for (var t = 0; t < this._cameras.length; t++) {
            if (this._cameras[t] === e) return;
          }

          this._cameras.push(e), this.sortCameras();
        }, i.detachCamera = function (e) {
          for (var t = 0; t < this._cameras.length; ++t) {
            if (this._cameras[t] === e) return void this._cameras.splice(t, 1);
          }
        }, i.clearCameras = function () {
          this._cameras.length = 0;
        }, i.sortCameras = function () {
          this._cameras.sort(function (e, t) {
            return e.priority - t.priority;
          });
        }, i._init = function () {}, i._destroy = function () {}, i._setSwapchain = function (e) {
          this._swapchain = e;
        }, i._setFrameBuffer = function (e) {
          this._framebuffer = e;
        }, t(e, [{
          key: "width",
          get: function get() {
            return this._width;
          }
        }, {
          key: "height",
          get: function get() {
            return this._height;
          }
        }, {
          key: "swapchain",
          get: function get() {
            return this._swapchain;
          }
        }, {
          key: "framebuffer",
          get: function get() {
            return this._framebuffer;
          }
        }, {
          key: "cameras",
          get: function get() {
            return this._cameras;
          }
        }, {
          key: "native",
          get: function get() {
            return this._nativeObj;
          }
        }]), e;
      }(),
          Re = e("R", function () {
        var e = i.prototype;

        function i(e) {
          var t = this;
          this._createSceneFun = null, this._createWindowFun = null, this._device = void 0, this._windows = [], this._mainWindow = null, this._curWindow = null, this._tempWindow = null, this._pipeline = null, this._batcher = null, this._dataPoolMgr = void 0, this._scenes = [], this._modelPools = new Map(), this._cameraPool = null, this._lightPools = new Map(), this._fpsTime = 0, this._frameCount = 0, this._fps = 0, this._fixedFPS = 0, this._useDeferredPipeline = !1, this._fixedFPSFrameTime = 0, this._cumulativeTime = 0, this._frameTime = 0, this._device = e, this._dataPoolMgr = r.internal.DataPoolManager && new r.internal.DataPoolManager(e), _e.registerCreateFunc(this), Oe.registerCreateFunc(this), this._cameraPool = new S(function () {
            return new le(t._device);
          }, 4, function (e) {
            return e.destroy();
          });
        }

        return e._init = function () {}, e._destroy = function () {}, e._setCumulativeTime = function (e) {
          this._cumulativeTime += e;
        }, e._setFrameTime = function (e) {
          this._frameTime = e;
        }, e.initialize = function () {
          this._init();

          var e = r.game._swapchain,
              t = new y();
          t.format = e.colorTexture.format;
          var i = new T();
          i.format = e.depthStencilTexture.format, i.depthStoreOp = E.DISCARD, i.stencilStoreOp = E.DISCARD;
          var n = new b([t], i);
          return this._mainWindow = this.createWindow({
            title: "rootMainWindow",
            width: e.width,
            height: e.height,
            renderPassInfo: n,
            swapchain: e
          }), this._curWindow = this._mainWindow, Promise.resolve(L.initBuiltinRes(this._device));
        }, e.destroy = function () {
          this.destroyScenes(), this._pipeline && (this._pipeline.destroy(), this._pipeline = null), this._batcher && (this._batcher.destroy(), this._batcher = null), this._curWindow = null, this._mainWindow = null, this.dataPoolManager.clear(), this._destroy();
        }, e.resize = function (e, t) {
          for (var i, r = v(this._windows); !(i = r()).done;) {
            var n = i.value;
            n.swapchain && n.resize(e, t);
          }
        }, e.setRenderPipeline = function (e) {
          e instanceof Te && (this._useDeferredPipeline = !0);
          var t = !1;
          if (e || (e = Se(), t = !0), this._pipeline = e, this._useDeferredPipeline && this.device.hasFeature(w.COMPUTE_SHADER) || (this._pipeline.clusterEnabled = !1), this._pipeline.bloomEnabled = !1, !this._pipeline.activate(this._mainWindow.swapchain)) return t && this._pipeline.destroy(), this._pipeline = null, !1;
          var i = r.director.getScene();
          return i && i.globals.activate(), this.onGlobalPipelineStateChanged(), !(!this._batcher && r.internal.Batcher2D && (this._batcher = new r.internal.Batcher2D(this), !this._batcher.initialize()) && (this.destroy(), 1));
        }, e.onGlobalPipelineStateChanged = function () {
          for (var e = 0; e < this._scenes.length; e++) {
            this._scenes[e].onGlobalPipelineStateChanged();
          }

          this._pipeline.pipelineSceneData.onGlobalPipelineStateChanged();
        }, e.activeWindow = function (e) {
          this._curWindow = e;
        }, e.resetCumulativeTime = function () {
          this._setCumulativeTime(0);
        }, e.frameMove = function (e) {
          this._setFrameTime(e), ++this._frameCount, this._setCumulativeTime(e), this._fpsTime += e, this._fpsTime > 1 && (this._fps = this._frameCount, this._frameCount = 0, this._fpsTime = 0);

          for (var t = 0; t < this._scenes.length; ++t) {
            this._scenes[t].removeBatches();
          }

          for (var i = this._windows, n = [], s = 0; s < i.length; s++) {
            i[s].extractRenderCameras(n);
          }

          if (this._pipeline && n.length > 0) {
            this._device.acquire([r.game._swapchain]);

            var a = this._scenes,
                o = r.director.getTotalFrames();
            this._batcher && (this._batcher.update(), this._batcher.uploadBuffers());

            for (var h = 0; h < a.length; h++) {
              a[h].update(o);
            }

            r.director.emit(r.Director.EVENT_BEFORE_COMMIT), n.sort(function (e, t) {
              return e.priority - t.priority;
            }), this._pipeline.render(n), this._device.present();
          }

          this._batcher && this._batcher.reset();
        }, e.createWindow = function (e) {
          var t = this._createWindowFun(this);

          return t.initialize(this.device, e), this._windows.push(t), t;
        }, e.destroyWindow = function (e) {
          for (var t = 0; t < this._windows.length; ++t) {
            if (this._windows[t] === e) return e.destroy(), void this._windows.splice(t, 1);
          }
        }, e.destroyWindows = function () {
          for (var e, t = v(this._windows); !(e = t()).done;) {
            e.value.destroy();
          }

          this._windows.length = 0;
        }, e.createScene = function (e) {
          var t = this._createSceneFun(this);

          return t.initialize(e), this._scenes.push(t), t;
        }, e.destroyScene = function (e) {
          for (var t = 0; t < this._scenes.length; ++t) {
            if (this._scenes[t] === e) return e.destroy(), void this._scenes.splice(t, 1);
          }
        }, e.destroyScenes = function () {
          for (var e, t = v(this._scenes); !(e = t()).done;) {
            e.value.destroy();
          }

          this._scenes.length = 0;
        }, e.createModel = function (e) {
          var t = this._modelPools.get(e);

          t || (this._modelPools.set(e, new S(function () {
            return new e();
          }, 10, function (e) {
            return e.destroy();
          })), t = this._modelPools.get(e));
          var i = t.alloc();
          return i.initialize(), i;
        }, e.destroyModel = function (e) {
          var t = this._modelPools.get(e.constructor);

          t ? (t.free(e), e.scene && e.scene.removeModel(e)) : o(1300, e.constructor.name), e.destroy();
        }, e.createCamera = function () {
          return this._cameraPool.alloc();
        }, e.createLight = function (e) {
          var t = this._lightPools.get(e);

          t || (this._lightPools.set(e, new S(function () {
            return new e();
          }, 4, function (e) {
            return e.destroy();
          })), t = this._lightPools.get(e));
          var i = t.alloc();
          return i.initialize(), i;
        }, e.destroyLight = function (e) {
          var t = this._lightPools.get(e.constructor);

          if (t && (t.free(e), e.scene)) switch (e.type) {
            case ue.SPHERE:
              e.scene.removeSphereLight(e);
              break;

            case ue.SPOT:
              e.scene.removeSpotLight(e);
          }
          e.destroy();
        }, t(i, [{
          key: "device",
          get: function get() {
            return this._device;
          }
        }, {
          key: "mainWindow",
          get: function get() {
            return this._mainWindow;
          }
        }, {
          key: "curWindow",
          get: function get() {
            return this._curWindow;
          },
          set: function set(e) {
            this._curWindow = e;
          }
        }, {
          key: "tempWindow",
          get: function get() {
            return this._tempWindow;
          },
          set: function set(e) {
            this._tempWindow = e;
          }
        }, {
          key: "windows",
          get: function get() {
            return this._windows;
          }
        }, {
          key: "pipeline",
          get: function get() {
            return this._pipeline;
          }
        }, {
          key: "batcher2D",
          get: function get() {
            return this._batcher;
          }
        }, {
          key: "scenes",
          get: function get() {
            return this._scenes;
          }
        }, {
          key: "cumulativeTime",
          get: function get() {
            return this._cumulativeTime;
          }
        }, {
          key: "frameTime",
          get: function get() {
            return this._frameTime;
          }
        }, {
          key: "frameCount",
          get: function get() {
            return this._frameCount;
          }
        }, {
          key: "fps",
          get: function get() {
            return this._fps;
          }
        }, {
          key: "fixedFPS",
          get: function get() {
            return this._fixedFPS;
          },
          set: function set(e) {
            e > 0 ? (this._fixedFPS = e, this._fixedFPSFrameTime = 1e3 / e) : this._fixedFPSFrameTime = 0;
          }
        }, {
          key: "dataPoolManager",
          get: function get() {
            return this._dataPoolMgr;
          }
        }, {
          key: "useDeferredPipeline",
          get: function get() {
            return this._useDeferredPipeline;
          }
        }]), i;
      }());

      r.Root = Re;
      var Le = e("D", function (e) {
        function i() {
          var t;
          return (t = e.call(this) || this)._compScheduler = void 0, t._nodeActivator = void 0, t._invalid = void 0, t._paused = void 0, t._root = void 0, t._loadingScene = void 0, t._scene = void 0, t._totalFrames = void 0, t._scheduler = void 0, t._systems = void 0, t._invalid = !1, t._paused = !1, t._root = null, t._loadingScene = "", t._scene = null, t._totalFrames = 0, t._scheduler = new Ie(), t._compScheduler = new U(), t._nodeActivator = new j(), t._systems = [], Ee.once(be.EVENT_RENDERER_INITED, t._initOnRendererInitialized, N(t)), t;
        }

        n(i, e);
        var h = i.prototype;
        return h.calculateDeltaTime = function () {}, h.end = function () {
          var e = this;
          this.once(i.EVENT_END_FRAME, function () {
            e.purgeDirector();
          });
        }, h.pause = function () {
          this._paused || (this._paused = !0);
        }, h.purgeDirector = function () {
          this._scheduler.unscheduleAll(), this._compScheduler.unscheduleAll(), this._nodeActivator.reset(), r.isValid(this._scene) && this._scene.destroy(), this._scene = null, this.stopAnimation(), r.assetManager.releaseAll();
        }, h.reset = function () {
          this.purgeDirector(), this.emit(i.EVENT_RESET), this.startAnimation();
        }, h.runSceneImmediate = function (e, t, i) {
          e instanceof W && (e = e.scene), s(e instanceof M, 1216), e._load();

          for (var n = Object.keys(Ee._persistRootNodes).map(function (e) {
            return Ee._persistRootNodes[e];
          }), a = 0; a < n.length; a++) {
            var o = n[a];
            o.emit(r.Node.SCENE_CHANGED_FOR_PERSISTS, e.renderScene);
            var h = e.uuid === o._originalSceneId && e.getChildByUuid(o.uuid);

            if (h) {
              var c = h.getSiblingIndex();
              h._destroyImmediate(), e.insertChild(o, c);
            } else o.parent = e;
          }

          var u = this._scene;
          r.isValid(u) && u.destroy(), r.assetManager._releaseManager._autoRelease(u, e, Ee._persistRootNodes), this._scene = null, F._deferredDestroy(), t && t(), this.emit(r.Director.EVENT_BEFORE_SCENE_LAUNCH, e), this._scene = e, e._activate(), this._root && this._root.resetCumulativeTime(), this.startAnimation(), i && i(null, e), this.emit(r.Director.EVENT_AFTER_SCENE_LAUNCH, e);
        }, h.runScene = function (e, t, i) {
          var n = this;
          e instanceof W && (e = e.scene), s(e, 1205), s(e instanceof M, 1216), e._load(), this.once(r.Director.EVENT_END_FRAME, function () {
            n.runSceneImmediate(e, t, i);
          });
        }, h.loadScene = function (e, t, i) {
          var n = this;
          if (this._loadingScene) return o(1208, e, this._loadingScene), !1;
          var s = r.assetManager.bundles.find(function (t) {
            return !!t.getSceneInfo(e);
          });
          return s ? (this.emit(r.Director.EVENT_BEFORE_SCENE_LOADING, e), this._loadingScene = e, console.time("LoadScene " + e), s.loadScene(e, function (r, s) {
            console.timeEnd("LoadScene " + e), n._loadingScene = "", r ? (D(r), t && t(r)) : n.runSceneImmediate(s, i, t);
          }), !0) : (a(1209, e), !1);
        }, h.preloadScene = function (e, t, i) {
          var n = r.assetManager.bundles.find(function (t) {
            return !!t.getSceneInfo(e);
          });
          if (n) n.preloadScene(e, null, t, i);else {
            var s = 'Can not preload the scene "' + e + '" because it is not in the build settings.';
            i && i(new Error(s)), D("preloadScene: " + s);
          }
        }, h.resume = function () {
          this._paused && (this._paused = !1);
        }, h.getScene = function () {
          return this._scene;
        }, h.getDeltaTime = function () {
          return Ee.deltaTime;
        }, h.getTotalTime = function () {
          return Ee.totalTime;
        }, h.getCurrentTime = function () {
          return Ee.frameStartTime;
        }, h.getTotalFrames = function () {
          return this._totalFrames;
        }, h.isPaused = function () {
          return this._paused;
        }, h.getScheduler = function () {
          return this._scheduler;
        }, h.setScheduler = function (e) {
          this._scheduler !== e && (this.unregisterSystem(this._scheduler), this._scheduler = e, this.registerSystem(Ie.ID, e, 200));
        }, h.registerSystem = function (e, t, i) {
          t.id = e, t.priority = i, t.init(), this._systems.push(t), this._systems.sort(Fe.sortByPriority);
        }, h.unregisterSystem = function (e) {
          P.fastRemove(this._systems, e), this._systems.sort(Fe.sortByPriority);
        }, h.getSystem = function (e) {
          return this._systems.find(function (t) {
            return t.id === e;
          });
        }, h.getAnimationManager = function () {
          return this.getSystem(r.AnimationManager.ID);
        }, h.startAnimation = function () {
          this._invalid = !1;
        }, h.stopAnimation = function () {
          this._invalid = !0;
        }, h.mainLoop = function (e) {
          var t;
          t = Ee._calculateDT(e), this.tick(t);
        }, h.tick = function (e) {
          if (!this._invalid) {
            if (this.emit(i.EVENT_BEGIN_FRAME), z._frameDispatchEvents(), !this._paused) {
              this.emit(i.EVENT_BEFORE_UPDATE), this._compScheduler.startPhase(), this._compScheduler.updatePhase(e);

              for (var t = 0; t < this._systems.length; ++t) {
                this._systems[t].update(e);
              }

              this._compScheduler.lateUpdatePhase(e), this.emit(i.EVENT_AFTER_UPDATE), F._deferredDestroy();

              for (var r = 0; r < this._systems.length; ++r) {
                this._systems[r].postUpdate(e);
              }
            }

            this.emit(i.EVENT_BEFORE_DRAW), this._root.frameMove(e), this.emit(i.EVENT_AFTER_DRAW), H.resetHasChangedFlags(), H.clearNodeArray(), C.update(e), this.emit(i.EVENT_END_FRAME), this._totalFrames++;
          }
        }, h._initOnRendererInitialized = function () {
          this._totalFrames = 0, this._paused = !1, this.registerSystem(Ie.ID, this._scheduler, 200), this.emit(i.EVENT_INIT);
        }, h._init = function () {
          return this._root = new Re(Ee._gfxDevice), this._root.initialize({}).catch(function (e) {
            return a(1217), Promise.reject(e);
          });
        }, t(i, [{
          key: "root",
          get: function get() {
            return this._root;
          }
        }]), i;
      }(A));
      Le.EVENT_INIT = "director_init", Le.EVENT_RESET = "director_reset", Le.EVENT_BEFORE_SCENE_LOADING = "director_before_scene_loading", Le.EVENT_BEFORE_SCENE_LAUNCH = "director_before_scene_launch", Le.EVENT_AFTER_SCENE_LAUNCH = "director_after_scene_launch", Le.EVENT_BEFORE_UPDATE = "director_before_update", Le.EVENT_AFTER_UPDATE = "director_after_update", Le.EVENT_BEFORE_DRAW = "director_before_draw", Le.EVENT_AFTER_DRAW = "director_after_draw", Le.EVENT_BEFORE_COMMIT = "director_before_commit", Le.EVENT_BEFORE_PHYSICS = "director_before_physics", Le.EVENT_AFTER_PHYSICS = "director_after_physics", Le.EVENT_BEGIN_FRAME = "director_begin_frame", Le.EVENT_END_FRAME = "director_end_frame", Le.instance = void 0, r.Director = Le, e("d", Le.instance = r.director = new Le());

      var We,
          Me,
          ze,
          He,
          Ue,
          je,
          Ve,
          Be,
          Ge,
          Xe,
          Ye,
          Ke,
          qe,
          Je,
          $e,
          Qe,
          Ze,
          et,
          tt,
          it,
          rt,
          nt,
          st,
          at,
          ot,
          ht,
          ct,
          ut,
          _t,
          lt,
          dt,
          pt,
          ft,
          mt,
          gt,
          vt,
          yt,
          Tt,
          Et,
          bt,
          wt,
          St,
          Ft,
          Dt,
          Pt,
          Ct,
          Nt,
          At,
          kt,
          It,
          xt,
          Ot,
          Rt,
          Lt,
          Wt,
          Mt,
          zt,
          Ht,
          Ut,
          jt,
          Vt,
          Bt,
          Gt,
          Xt,
          Yt,
          Kt,
          qt,
          Jt,
          $t,
          Qt,
          Zt,
          ei,
          ti,
          ii,
          ri,
          ni,
          si,
          ai,
          oi,
          hi,
          ci,
          ui,
          _i,
          li,
          di = e("E", (We = V("cc.ClickEvent"), Me = B(r.Node), ze = Y(), He = Y(), Ue = Y(), je = Y(), We((Je = function () {
        function e() {
          I(this, "target", Ge, this), I(this, "component", Xe, this), I(this, "_componentId", Ye, this), I(this, "handler", Ke, this), I(this, "customEventData", qe, this);
        }

        e.emitEvents = function (t) {
          for (var i = arguments.length, r = new Array(i > 1 ? i - 1 : 0), n = 1; n < i; n++) {
            r[n - 1] = arguments[n];
          }

          for (var s = 0, a = t.length; s < a; s++) {
            var o = t[s];
            o instanceof e && o.emit(r);
          }
        };

        var i = e.prototype;
        return i.emit = function (e) {
          var t = this.target;

          if (r.isValid(t)) {
            this._genCompIdIfNeeded();

            var i = r.js._getClassById(this._componentId),
                n = t.getComponent(i);

            if (r.isValid(n)) {
              var s = n[this.handler];
              "function" == typeof s && (null != this.customEventData && "" !== this.customEventData && (e = e.slice()).push(this.customEventData), s.apply(n, e));
            }
          }
        }, i._compName2Id = function (e) {
          var t = r.js.getClassByName(e);
          return r.js._getClassId(t);
        }, i._compId2Name = function (e) {
          var t = r.js._getClassById(e);

          return r.js.getClassName(t);
        }, i._genCompIdIfNeeded = function () {
          this._componentId || (this._componentName = this.component, this.component = "");
        }, t(e, [{
          key: "_componentName",
          get: function get() {
            return this._genCompIdIfNeeded(), this._compId2Name(this._componentId);
          },
          set: function set(e) {
            this._componentId = this._compName2Id(e);
          }
        }]), e;
      }(), Ge = k((Be = Je).prototype, "target", [G, Me, G, ze], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return null;
        }
      }), Xe = k(Be.prototype, "component", [G, X, He], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return "";
        }
      }), Ye = k(Be.prototype, "_componentId", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return "";
        }
      }), Ke = k(Be.prototype, "handler", [G, X, Ue], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return "";
        }
      }), qe = k(Be.prototype, "customEventData", [G, X, je], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return "";
        }
      }), Ve = Be)) || Ve));

      r.Component.EventHandler = di;
      var pi = new K(),
          fi = i(de),
          mi = i(pe),
          gi = i(fe),
          vi = i(me),
          yi = i(ge),
          Ti = i({
        SKYBOX: ve | x.DEPTH_STENCIL,
        SOLID_COLOR: x.ALL,
        DEPTH_ONLY: x.DEPTH_STENCIL,
        DONT_CLEAR: x.NONE
      }),
          Ei = e("C", ($e = V("cc.Camera"), Qe = te(), Ze = ie(), et = re(), tt = Y(), it = B(q.BitMask), rt = re(), nt = Y(), st = B(Ti), at = re(), ot = Y(), ht = re(), ct = Y(), ut = re(), _t = Y(), lt = re(), dt = Y(), pt = B(fi), ft = re(), mt = Y(), gt = B(mi), vt = re(), yt = ne(), Tt = Y(), Et = re(), bt = ne(), wt = Y(), St = re(), Ft = ne(), Dt = Y(), Pt = re(), Ct = Y(), Nt = re(), At = Y(), kt = B(gi), It = re(), xt = Y(), Ot = B(vi), Rt = re(), Lt = Y(), Wt = B(yi), Mt = re(), zt = Y(), Ht = re(), Ut = Y(), jt = B(J), Vt = re(), Bt = Y(), $e(Gt = Qe(Gt = Ze(Gt = $((li = _i = function (e) {
        function i() {
          for (var t, i = arguments.length, r = new Array(i), n = 0; n < i; n++) {
            r[n] = arguments[n];
          }

          return t = e.call.apply(e, [this].concat(r)) || this, I(t, "_projection", Yt, N(t)), I(t, "_priority", Kt, N(t)), I(t, "_fov", qt, N(t)), I(t, "_fovAxis", Jt, N(t)), I(t, "_orthoHeight", $t, N(t)), I(t, "_near", Qt, N(t)), I(t, "_far", Zt, N(t)), I(t, "_color", ei, N(t)), I(t, "_depth", ti, N(t)), I(t, "_stencil", ii, N(t)), I(t, "_clearFlags", ri, N(t)), I(t, "_rect", ni, N(t)), I(t, "_aperture", si, N(t)), I(t, "_shutter", ai, N(t)), I(t, "_iso", oi, N(t)), I(t, "_screenScale", hi, N(t)), I(t, "_visibility", ci, N(t)), I(t, "_targetTexture", ui, N(t)), t._camera = null, t._inEditorMode = !1, t._flows = void 0, t;
        }

        n(i, e);
        var s = i.prototype;
        return s.onLoad = function () {
          this._createCamera();
        }, s.onEnable = function () {
          this.node.hasChangedFlags |= Q.POSITION, this._camera && this._attachToScene();
        }, s.onDisable = function () {
          this._camera && this._detachFromScene();
        }, s.onDestroy = function () {
          this._camera && (this._camera.destroy(), this._camera = null), this._targetTexture && this._targetTexture.off("resize");
        }, s.screenPointToRay = function (e, t, i) {
          return i || (i = Z.create()), this._camera && this._camera.screenPointToRay(i, e, t), i;
        }, s.worldToScreen = function (e, t) {
          return t || (t = new K()), this._camera && this._camera.worldToScreen(t, e), t;
        }, s.screenToWorld = function (e, t) {
          return t || (t = this.node.getWorldPosition()), this._camera && this._camera.screenToWorld(t, e), t;
        }, s.convertToUINode = function (e, t, i) {
          if (i || (i = new K()), !this._camera) return i;
          this.worldToScreen(e, pi);
          var n = t.getComponent("cc.UITransform"),
              s = we.getVisibleSize(),
              a = pi.x - .5 * this._camera.width,
              o = pi.y - .5 * this._camera.height;
          return pi.x = a / r.view.getScaleX() + .5 * s.width, pi.y = o / r.view.getScaleY() + .5 * s.height, n && n.convertToNodeSpaceAR(pi, i), i;
        }, s._createCamera = function () {
          this._camera || (this._camera = r.director.root.createCamera(), this._camera.initialize({
            name: this.node.name,
            node: this.node,
            projection: this._projection,
            window: this._inEditorMode ? r.director.root && r.director.root.mainWindow : r.director.root && r.director.root.tempWindow,
            priority: this._priority
          }), this._camera.setViewportInOrientedSpace(this._rect), this._camera.fovAxis = this._fovAxis, this._camera.fov = ee(this._fov), this._camera.orthoHeight = this._orthoHeight, this._camera.nearClip = this._near, this._camera.farClip = this._far, this._camera.clearColor = this._color, this._camera.clearDepth = this._depth, this._camera.clearStencil = this._stencil, this._camera.clearFlag = this._clearFlags, this._camera.visibility = this._visibility, this._camera.aperture = this._aperture, this._camera.shutter = this._shutter, this._camera.iso = this._iso), this._updateTargetTexture();
        }, s._attachToScene = function () {
          this.node.scene && this._camera && (this._camera && this._camera.scene && this._camera.scene.removeCamera(this._camera), this._getRenderScene().addCamera(this._camera));
        }, s._detachFromScene = function () {
          this._camera && this._camera.scene && this._camera.scene.removeCamera(this._camera);
        }, s._checkTargetTextureEvent = function (e) {
          var t = this;
          e && e.off("resize"), this._targetTexture && this._targetTexture.on("resize", function (e) {
            t._camera && t._camera.setFixedSize(e.width, e.height);
          }, this);
        }, s._updateTargetTexture = function () {
          if (this._camera && this._targetTexture) {
            var e = this._targetTexture.window;
            this._camera.changeTargetWindow(e), this._camera.setFixedSize(e.width, e.height);
          }
        }, t(i, [{
          key: "camera",
          get: function get() {
            return this._camera;
          }
        }, {
          key: "priority",
          get: function get() {
            return this._priority;
          },
          set: function set(e) {
            this._priority = e, this._camera && (this._camera.priority = e);
          }
        }, {
          key: "visibility",
          get: function get() {
            return this._visibility;
          },
          set: function set(e) {
            this._visibility = e, this._camera && (this._camera.visibility = e);
          }
        }, {
          key: "clearFlags",
          get: function get() {
            return this._clearFlags;
          },
          set: function set(e) {
            this._clearFlags = e, this._camera && (this._camera.clearFlag = e);
          }
        }, {
          key: "clearColor",
          get: function get() {
            return this._color;
          },
          set: function set(e) {
            this._color.set(e), this._camera && (this._camera.clearColor = this._color);
          }
        }, {
          key: "clearDepth",
          get: function get() {
            return this._depth;
          },
          set: function set(e) {
            this._depth = e, this._camera && (this._camera.clearDepth = e);
          }
        }, {
          key: "clearStencil",
          get: function get() {
            return this._stencil;
          },
          set: function set(e) {
            this._stencil = e, this._camera && (this._camera.clearStencil = e);
          }
        }, {
          key: "projection",
          get: function get() {
            return this._projection;
          },
          set: function set(e) {
            this._projection = e, this._camera && (this._camera.projectionType = e);
          }
        }, {
          key: "fovAxis",
          get: function get() {
            return this._fovAxis;
          },
          set: function set(e) {
            e !== this._fovAxis && (this._fovAxis = e, this._camera && (this._camera.fovAxis = e, e === pe.VERTICAL ? this.fov = this._fov * this._camera.aspect : this.fov = this._fov / this._camera.aspect));
          }
        }, {
          key: "fov",
          get: function get() {
            return this._fov;
          },
          set: function set(e) {
            this._fov = e, this._camera && (this._camera.fov = ee(e));
          }
        }, {
          key: "orthoHeight",
          get: function get() {
            return this._orthoHeight;
          },
          set: function set(e) {
            this._orthoHeight = e, this._camera && (this._camera.orthoHeight = e);
          }
        }, {
          key: "near",
          get: function get() {
            return this._near;
          },
          set: function set(e) {
            this._near = e, this._camera && (this._camera.nearClip = e);
          }
        }, {
          key: "far",
          get: function get() {
            return this._far;
          },
          set: function set(e) {
            this._far = e, this._camera && (this._camera.farClip = e);
          }
        }, {
          key: "aperture",
          get: function get() {
            return this._aperture;
          },
          set: function set(e) {
            this._aperture = e, this._camera && (this._camera.aperture = e);
          }
        }, {
          key: "shutter",
          get: function get() {
            return this._shutter;
          },
          set: function set(e) {
            this._shutter = e, this._camera && (this._camera.shutter = e);
          }
        }, {
          key: "iso",
          get: function get() {
            return this._iso;
          },
          set: function set(e) {
            this._iso = e, this._camera && (this._camera.iso = e);
          }
        }, {
          key: "rect",
          get: function get() {
            return this._rect;
          },
          set: function set(e) {
            this._rect = e, this._camera && this._camera.setViewportInOrientedSpace(e);
          }
        }, {
          key: "targetTexture",
          get: function get() {
            return this._targetTexture;
          },
          set: function set(e) {
            if (this._targetTexture !== e) {
              var t = this._targetTexture;
              this._targetTexture = e, this._checkTargetTextureEvent(t), this._updateTargetTexture(), !e && this._camera && (this._camera.changeTargetWindow(null), this._camera.isWindowSize = !0), this.node.emit(i.TARGET_TEXTURE_CHANGE, this);
            }
          }
        }, {
          key: "screenScale",
          get: function get() {
            return this._screenScale;
          },
          set: function set(e) {
            this._screenScale = e, this._camera && (this._camera.screenScale = e);
          }
        }, {
          key: "inEditorMode",
          get: function get() {
            return this._inEditorMode;
          },
          set: function set(e) {
            this._inEditorMode = e, this._camera && this._camera.changeTargetWindow(e ? r.director.root && r.director.root.mainWindow : r.director.root && r.director.root.tempWindow);
          }
        }]), i;
      }(se), _i.ProjectionType = fi, _i.FOVAxis = mi, _i.ClearFlag = Ti, _i.Aperture = gi, _i.Shutter = vi, _i.ISO = yi, _i.TARGET_TEXTURE_CHANGE = "tex-change", Yt = k((Xt = li).prototype, "_projection", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return fi.PERSPECTIVE;
        }
      }), Kt = k(Xt.prototype, "_priority", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 0;
        }
      }), qt = k(Xt.prototype, "_fov", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 45;
        }
      }), Jt = k(Xt.prototype, "_fovAxis", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return mi.VERTICAL;
        }
      }), $t = k(Xt.prototype, "_orthoHeight", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 10;
        }
      }), Qt = k(Xt.prototype, "_near", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 1;
        }
      }), Zt = k(Xt.prototype, "_far", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 1e3;
        }
      }), ei = k(Xt.prototype, "_color", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return new ae("#333333");
        }
      }), ti = k(Xt.prototype, "_depth", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 1;
        }
      }), ii = k(Xt.prototype, "_stencil", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 0;
        }
      }), ri = k(Xt.prototype, "_clearFlags", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return Ti.SOLID_COLOR;
        }
      }), ni = k(Xt.prototype, "_rect", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return new oe(0, 0, 1, 1);
        }
      }), si = k(Xt.prototype, "_aperture", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return gi.F16_0;
        }
      }), ai = k(Xt.prototype, "_shutter", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return vi.D125;
        }
      }), oi = k(Xt.prototype, "_iso", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return yi.ISO100;
        }
      }), hi = k(Xt.prototype, "_screenScale", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 1;
        }
      }), ci = k(Xt.prototype, "_visibility", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return he;
        }
      }), ui = k(Xt.prototype, "_targetTexture", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return null;
        }
      }), k(Xt.prototype, "priority", [et, tt], Object.getOwnPropertyDescriptor(Xt.prototype, "priority"), Xt.prototype), k(Xt.prototype, "visibility", [it, rt, nt], Object.getOwnPropertyDescriptor(Xt.prototype, "visibility"), Xt.prototype), k(Xt.prototype, "clearFlags", [st, at, ot], Object.getOwnPropertyDescriptor(Xt.prototype, "clearFlags"), Xt.prototype), k(Xt.prototype, "clearColor", [ht, ct], Object.getOwnPropertyDescriptor(Xt.prototype, "clearColor"), Xt.prototype), k(Xt.prototype, "clearDepth", [ut, _t], Object.getOwnPropertyDescriptor(Xt.prototype, "clearDepth"), Xt.prototype), k(Xt.prototype, "clearStencil", [lt, dt], Object.getOwnPropertyDescriptor(Xt.prototype, "clearStencil"), Xt.prototype), k(Xt.prototype, "projection", [pt, ft, mt], Object.getOwnPropertyDescriptor(Xt.prototype, "projection"), Xt.prototype), k(Xt.prototype, "fovAxis", [gt, vt, yt, Tt], Object.getOwnPropertyDescriptor(Xt.prototype, "fovAxis"), Xt.prototype), k(Xt.prototype, "fov", [Et, bt, wt], Object.getOwnPropertyDescriptor(Xt.prototype, "fov"), Xt.prototype), k(Xt.prototype, "orthoHeight", [St, Ft, Dt], Object.getOwnPropertyDescriptor(Xt.prototype, "orthoHeight"), Xt.prototype), k(Xt.prototype, "near", [Pt, Ct], Object.getOwnPropertyDescriptor(Xt.prototype, "near"), Xt.prototype), k(Xt.prototype, "far", [Nt, At], Object.getOwnPropertyDescriptor(Xt.prototype, "far"), Xt.prototype), k(Xt.prototype, "aperture", [kt, It, xt], Object.getOwnPropertyDescriptor(Xt.prototype, "aperture"), Xt.prototype), k(Xt.prototype, "shutter", [Ot, Rt, Lt], Object.getOwnPropertyDescriptor(Xt.prototype, "shutter"), Xt.prototype), k(Xt.prototype, "iso", [Wt, Mt, zt], Object.getOwnPropertyDescriptor(Xt.prototype, "iso"), Xt.prototype), k(Xt.prototype, "rect", [Ht, Ut], Object.getOwnPropertyDescriptor(Xt.prototype, "rect"), Xt.prototype), k(Xt.prototype, "targetTexture", [jt, Vt, Bt], Object.getOwnPropertyDescriptor(Xt.prototype, "targetTexture"), Xt.prototype), Gt = Xt)) || Gt) || Gt) || Gt) || Gt));
      r.Camera = Ei, ce(Ei, "Camera", [{
        name: "CameraClearFlag",
        newName: "ClearFlag"
      }]), ce(Ei.prototype, "Camera.prototype", [{
        name: "color",
        newName: "clearColor"
      }, {
        name: "depth",
        newName: "clearDepth"
      }, {
        name: "stencil",
        newName: "clearStencil"
      }]), r.CameraComponent = Ei, O.setClassAlias(Ei, "cc.CameraComponent");
    }
  };
}); 
 			}); 
		define("__plugin__/wx0446ba2621dda60a/dragon-bones.js", function(require, module, exports){ 			
"use strict";

var _typeof2 = require("@babel/runtime/helpers/typeof");

System.register(["./texture-barrier-60b5983b.js", "./json-asset-933a1d4c.js", "./index-f2b92470.js", "./renderable-component-7c6600ed.js", "./deprecated-26630860.js", "./deprecated-ef6bb945.js", "./index-07804d0e.js", "./sprite-frame-1edab3eb.js", "./sprite-827770a8.js", "./renderable-2d-e2838949.js", "./graphics-f99ac3d9.js", "./deprecated-e75f11b6.js", "./deprecated-5f7f37d5.js", "./static-vb-accessor-3aa47319.js"], function (t) {
  "use strict";

  var e, a, i, r, n, s, o, l, h, u, _, f, c, m, p, d, y, g, v, D, b, A, T, S, x, P, O, C, M, B, I, E, w, F, N, R, k, j, L, U, V, Y, X, G, H, z;

  return {
    setters: [function (t) {
      e = t.bT, a = t.bU, i = t.bJ, r = t.b$, n = t.bv, s = t.c0, o = t.l, l = t.c1, h = t.bw, u = t.cX, _ = t.bC, f = t.i, c = t.bB, m = t.R, p = t.f, d = t.G;
    }, function (t) {
      y = t.bW, g = t.a3, v = t.Z, D = t.a5, b = t.Q, A = t.b6, T = t.aL, S = t.bX, x = t.bZ, P = t.aT, O = t.cd, C = t.M, M = t.b$, B = t.cg, I = t.ch, E = t.cc, w = t.ci, F = t.de, N = t.ay;
    }, function () {}, function () {}, function (t) {
      R = t.g, k = t.G;
    }, function (t) {
      j = t.S, L = t.d, U = t.a;
    }, function () {}, function (t) {
      V = t.S;
    }, function () {}, function (t) {
      Y = t.R, X = t.a, G = t.f;
    }, function (t) {
      H = t.G;
    }, function () {}, function () {}, function (t) {
      z = t.S;
    }],
    execute: function execute() {
      var W = Object.setPrototypeOf,
          K = {};
      K || (K = {}), function (t) {
        var e = function () {
          function e(a) {
            this._clock = new t.WorldClock(), this._events = [], this._objects = [], this._eventManager = null, this._eventManager = a, console.info("DragonBones: " + e.VERSION + "\nWebsite: http://dragonbones.com/\nSource and Demo: https://github.com/DragonBones/");
          }

          return e.prototype.advanceTime = function (e) {
            if (this._objects.length > 0) {
              for (var a = 0, i = this._objects; a < i.length; a++) {
                i[a].returnToPool();
              }

              this._objects.length = 0;
            }

            if (this._clock.advanceTime(e), this._events.length > 0) {
              for (var r = 0; r < this._events.length; ++r) {
                var n = this._events[r],
                    s = n.armature;
                null !== s._armatureData && (s.eventDispatcher.dispatchDBEvent(n.type, n), n.type === t.EventObject.SOUND_EVENT && this._eventManager.dispatchDBEvent(n.type, n)), this.bufferObject(n);
              }

              this._events.length = 0;
            }
          }, e.prototype.bufferEvent = function (t) {
            this._events.indexOf(t) < 0 && this._events.push(t);
          }, e.prototype.bufferObject = function (t) {
            this._objects.indexOf(t) < 0 && this._objects.push(t);
          }, Object.defineProperty(e.prototype, "clock", {
            get: function get() {
              return this._clock;
            },
            enumerable: !0,
            configurable: !0
          }), Object.defineProperty(e.prototype, "eventManager", {
            get: function get() {
              return this._eventManager;
            },
            enumerable: !0,
            configurable: !0
          }), e.VERSION = "5.6.300", e.yDown = !1, e.debug = !1, e.debugDraw = !1, e.webAssembly = !1, e;
        }();

        t.DragonBones = e;
      }(K || (K = {})), console.warn || (console.warn = function () {}), console.assert || (console.assert = function () {}), Date.now || (Date.now = function () {
        return new Date().getTime();
      }), W = function W(t, e) {
        function a() {
          this.constructor = t;
        }

        for (var i in e) {
          e.hasOwnProperty(i) && (t[i] = e[i]);
        }

        a.prototype = e.prototype, t.prototype = new a();
      }, function (t) {
        var e = function () {
          function t() {
            this.hashCode = t._hashCode++, this._isInPool = !1;
          }

          return t._returnObject = function (e) {
            var a = String(e.constructor),
                i = a in t._maxCountMap ? t._maxCountMap[a] : t._defaultMaxCount,
                r = t._poolsMap[a] = t._poolsMap[a] || [];
            r.length < i && (e._isInPool ? console.warn("The object is already in the pool.") : (e._isInPool = !0, r.push(e)));
          }, t.toString = function () {
            throw new Error();
          }, t.setMaxCount = function (e, a) {
            if ((a < 0 || a != a) && (a = 0), null !== e) null !== (r = (i = String(e)) in t._poolsMap ? t._poolsMap[i] : null) && r.length > a && (r.length = a), t._maxCountMap[i] = a;else for (var i in t._defaultMaxCount = a, t._poolsMap) {
              var r;
              (r = t._poolsMap[i]).length > a && (r.length = a), i in t._maxCountMap && (t._maxCountMap[i] = a);
            }
          }, t.clearPool = function (e) {
            if (void 0 === e && (e = null), null !== e) {
              var a = String(e);
              null !== (r = a in t._poolsMap ? t._poolsMap[a] : null) && r.length > 0 && (r.length = 0);
            } else for (var i in t._poolsMap) {
              var r;
              (r = t._poolsMap[i]).length = 0;
            }
          }, t.borrowObject = function (e) {
            var a = String(e),
                i = a in t._poolsMap ? t._poolsMap[a] : null;

            if (null !== i && i.length > 0) {
              var r = i.pop();
              return r._isInPool = !1, r;
            }

            var n = new e();
            return n._onClear(), n;
          }, t.prototype.returnToPool = function () {
            this._onClear(), t._returnObject(this);
          }, t._hashCode = 0, t._defaultMaxCount = 3e3, t._maxCountMap = {}, t._poolsMap = {}, t;
        }();

        t.BaseObject = e;
      }(K || (K = {})), function (t) {
        var e = function () {
          function t(t, e, a, i, r, n) {
            void 0 === t && (t = 1), void 0 === e && (e = 0), void 0 === a && (a = 0), void 0 === i && (i = 1), void 0 === r && (r = 0), void 0 === n && (n = 0), this.a = t, this.b = e, this.c = a, this.d = i, this.tx = r, this.ty = n;
          }

          return t.prototype.toString = function () {
            return "[object dragonBones.Matrix] a:" + this.a + " b:" + this.b + " c:" + this.c + " d:" + this.d + " tx:" + this.tx + " ty:" + this.ty;
          }, t.prototype.copyFrom = function (t) {
            return this.a = t.a, this.b = t.b, this.c = t.c, this.d = t.d, this.tx = t.tx, this.ty = t.ty, this;
          }, t.prototype.copyFromArray = function (t, e) {
            return void 0 === e && (e = 0), this.a = t[e], this.b = t[e + 1], this.c = t[e + 2], this.d = t[e + 3], this.tx = t[e + 4], this.ty = t[e + 5], this;
          }, t.prototype.identity = function () {
            return this.a = this.d = 1, this.b = this.c = 0, this.tx = this.ty = 0, this;
          }, t.prototype.concat = function (t) {
            var e = this.a * t.a,
                a = 0,
                i = 0,
                r = this.d * t.d,
                n = this.tx * t.a + t.tx,
                s = this.ty * t.d + t.ty;
            return 0 === this.b && 0 === this.c || (e += this.b * t.c, a += this.b * t.d, i += this.c * t.a, r += this.c * t.b), 0 === t.b && 0 === t.c || (a += this.a * t.b, i += this.d * t.c, n += this.ty * t.c, s += this.tx * t.b), this.a = e, this.b = a, this.c = i, this.d = r, this.tx = n, this.ty = s, this;
          }, t.prototype.invert = function () {
            var t = this.a,
                e = this.b,
                a = this.c,
                i = this.d,
                r = this.tx,
                n = this.ty;
            if (0 === e && 0 === a) return this.b = this.c = 0, 0 === t || 0 === i ? this.a = this.b = this.tx = this.ty = 0 : (t = this.a = 1 / t, i = this.d = 1 / i, this.tx = -t * r, this.ty = -i * n), this;
            var s = t * i - e * a;
            if (0 === s) return this.a = this.d = 1, this.b = this.c = 0, this.tx = this.ty = 0, this;
            s = 1 / s;
            var o = this.a = i * s;
            return e = this.b = -e * s, a = this.c = -a * s, i = this.d = t * s, this.tx = -(o * r + a * n), this.ty = -(e * r + i * n), this;
          }, t.prototype.transformPoint = function (t, e, a, i) {
            void 0 === i && (i = !1), a.x = this.a * t + this.c * e, a.y = this.b * t + this.d * e, i || (a.x += this.tx, a.y += this.ty);
          }, t.prototype.transformRectangle = function (t, e) {
            void 0 === e && (e = !1);

            var a = this.a,
                i = this.b,
                r = this.c,
                n = this.d,
                s = e ? 0 : this.tx,
                o = e ? 0 : this.ty,
                l = t.x,
                h = t.y,
                u = l + t.width,
                _ = h + t.height,
                f = a * l + r * h + s,
                c = i * l + n * h + o,
                m = a * u + r * h + s,
                p = i * u + n * h + o,
                d = a * u + r * _ + s,
                y = i * u + n * _ + o,
                g = a * l + r * _ + s,
                v = i * l + n * _ + o,
                D = 0;

            f > m && (D = f, f = m, m = D), d > g && (D = d, d = g, g = D), t.x = Math.floor(f < d ? f : d), t.width = Math.ceil((m > g ? m : g) - t.x), c > p && (D = c, c = p, p = D), y > v && (D = y, y = v, v = D), t.y = Math.floor(c < y ? c : y), t.height = Math.ceil((p > v ? p : v) - t.y);
          }, t;
        }();

        t.Matrix = e;
      }(K || (K = {})), function (t) {
        var e = function () {
          function t(t, e, a, i, r, n) {
            void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === a && (a = 0), void 0 === i && (i = 0), void 0 === r && (r = 1), void 0 === n && (n = 1), this.x = t, this.y = e, this.skew = a, this.rotation = i, this.scaleX = r, this.scaleY = n;
          }

          return t.normalizeRadian = function (t) {
            return (t = (t + Math.PI) % (2 * Math.PI)) + (t > 0 ? -Math.PI : Math.PI);
          }, t.prototype.toString = function () {
            return "[object dragonBones.Transform] x:" + this.x + " y:" + this.y + " skewX:" + 180 * this.skew / Math.PI + " skewY:" + 180 * this.rotation / Math.PI + " scaleX:" + this.scaleX + " scaleY:" + this.scaleY;
          }, t.prototype.copyFrom = function (t) {
            return this.x = t.x, this.y = t.y, this.skew = t.skew, this.rotation = t.rotation, this.scaleX = t.scaleX, this.scaleY = t.scaleY, this;
          }, t.prototype.identity = function () {
            return this.x = this.y = 0, this.skew = this.rotation = 0, this.scaleX = this.scaleY = 1, this;
          }, t.prototype.add = function (t) {
            return this.x += t.x, this.y += t.y, this.skew += t.skew, this.rotation += t.rotation, this.scaleX *= t.scaleX, this.scaleY *= t.scaleY, this;
          }, t.prototype.minus = function (t) {
            return this.x -= t.x, this.y -= t.y, this.skew -= t.skew, this.rotation -= t.rotation, this.scaleX /= t.scaleX, this.scaleY /= t.scaleY, this;
          }, t.prototype.fromMatrix = function (e) {
            var a = this.scaleX,
                i = this.scaleY,
                r = t.PI_Q;
            this.x = e.tx, this.y = e.ty, this.rotation = Math.atan(e.b / e.a);
            var n = Math.atan(-e.c / e.d);
            return this.scaleX = this.rotation > -r && this.rotation < r ? e.a / Math.cos(this.rotation) : e.b / Math.sin(this.rotation), this.scaleY = n > -r && n < r ? e.d / Math.cos(n) : -e.c / Math.sin(n), a >= 0 && this.scaleX < 0 && (this.scaleX = -this.scaleX, this.rotation = this.rotation - Math.PI), i >= 0 && this.scaleY < 0 && (this.scaleY = -this.scaleY, n -= Math.PI), this.skew = n - this.rotation, this;
          }, t.prototype.toMatrix = function (t) {
            return 0 === this.rotation ? (t.a = 1, t.b = 0) : (t.a = Math.cos(this.rotation), t.b = Math.sin(this.rotation)), 0 === this.skew ? (t.c = -t.b, t.d = t.a) : (t.c = -Math.sin(this.skew + this.rotation), t.d = Math.cos(this.skew + this.rotation)), 1 !== this.scaleX && (t.a *= this.scaleX, t.b *= this.scaleX), 1 !== this.scaleY && (t.c *= this.scaleY, t.d *= this.scaleY), t.tx = this.x, t.ty = this.y, this;
          }, t.PI = Math.PI, t.PI_D = 2 * Math.PI, t.PI_H = Math.PI / 2, t.PI_Q = Math.PI / 4, t.RAD_DEG = 180 / Math.PI, t.DEG_RAD = Math.PI / 180, t;
        }();

        t.Transform = e;
      }(K || (K = {})), function (t) {
        var e = function () {
          function t(t, e, a, i, r, n, s, o) {
            void 0 === t && (t = 1), void 0 === e && (e = 1), void 0 === a && (a = 1), void 0 === i && (i = 1), void 0 === r && (r = 0), void 0 === n && (n = 0), void 0 === s && (s = 0), void 0 === o && (o = 0), this.alphaMultiplier = t, this.redMultiplier = e, this.greenMultiplier = a, this.blueMultiplier = i, this.alphaOffset = r, this.redOffset = n, this.greenOffset = s, this.blueOffset = o;
          }

          return t.prototype.copyFrom = function (t) {
            this.alphaMultiplier = t.alphaMultiplier, this.redMultiplier = t.redMultiplier, this.greenMultiplier = t.greenMultiplier, this.blueMultiplier = t.blueMultiplier, this.alphaOffset = t.alphaOffset, this.redOffset = t.redOffset, this.greenOffset = t.greenOffset, this.blueOffset = t.blueOffset;
          }, t.prototype.identity = function () {
            this.alphaMultiplier = this.redMultiplier = this.greenMultiplier = this.blueMultiplier = 1, this.alphaOffset = this.redOffset = this.greenOffset = this.blueOffset = 0;
          }, t;
        }();

        t.ColorTransform = e;
      }(K || (K = {})), function (t) {
        var e = function () {
          function t(t, e) {
            void 0 === t && (t = 0), void 0 === e && (e = 0), this.x = t, this.y = e;
          }

          return t.prototype.copyFrom = function (t) {
            this.x = t.x, this.y = t.y;
          }, t.prototype.clear = function () {
            this.x = this.y = 0;
          }, t;
        }();

        t.Point = e;
      }(K || (K = {})), function (t) {
        var e = function () {
          function t(t, e, a, i) {
            void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === a && (a = 0), void 0 === i && (i = 0), this.x = t, this.y = e, this.width = a, this.height = i;
          }

          return t.prototype.copyFrom = function (t) {
            this.x = t.x, this.y = t.y, this.width = t.width, this.height = t.height;
          }, t.prototype.clear = function () {
            this.x = this.y = 0, this.width = this.height = 0;
          }, t;
        }();

        t.Rectangle = e;
      }(K || (K = {})), function (t) {
        var e = function (t) {
          function e() {
            var e = null !== t && t.apply(this, arguments) || this;
            return e.ints = [], e.floats = [], e.strings = [], e;
          }

          return W(e, t), e.toString = function () {
            return "[class dragonBones.UserData]";
          }, e.prototype._onClear = function () {
            this.ints.length = 0, this.floats.length = 0, this.strings.length = 0;
          }, e.prototype.addInt = function (t) {
            this.ints.push(t);
          }, e.prototype.addFloat = function (t) {
            this.floats.push(t);
          }, e.prototype.addString = function (t) {
            this.strings.push(t);
          }, e.prototype.getInt = function (t) {
            return void 0 === t && (t = 0), t >= 0 && t < this.ints.length ? this.ints[t] : 0;
          }, e.prototype.getFloat = function (t) {
            return void 0 === t && (t = 0), t >= 0 && t < this.floats.length ? this.floats[t] : 0;
          }, e.prototype.getString = function (t) {
            return void 0 === t && (t = 0), t >= 0 && t < this.strings.length ? this.strings[t] : "";
          }, e;
        }(t.BaseObject);

        t.UserData = e;

        var a = function (t) {
          function e() {
            var e = null !== t && t.apply(this, arguments) || this;
            return e.data = null, e;
          }

          return W(e, t), e.toString = function () {
            return "[class dragonBones.ActionData]";
          }, e.prototype._onClear = function () {
            null !== this.data && this.data.returnToPool(), this.type = 0, this.name = "", this.bone = null, this.slot = null, this.data = null;
          }, e;
        }(t.BaseObject);

        t.ActionData = a;
      }(K || (K = {})), function (t) {
        var e = function (t) {
          function e() {
            var e = null !== t && t.apply(this, arguments) || this;
            return e.frameIndices = [], e.cachedFrames = [], e.armatureNames = [], e.armatures = {}, e.userData = null, e;
          }

          return W(e, t), e.toString = function () {
            return "[class dragonBones.DragonBonesData]";
          }, e.prototype._onClear = function () {
            for (var t in this.armatures) {
              this.armatures[t].returnToPool(), delete this.armatures[t];
            }

            null !== this.userData && this.userData.returnToPool(), this.autoSearch = !1, this.frameRate = 0, this.version = "", this.name = "", this.stage = null, this.frameIndices.length = 0, this.cachedFrames.length = 0, this.armatureNames.length = 0, this.binary = null, this.intArray = null, this.floatArray = null, this.frameIntArray = null, this.frameFloatArray = null, this.frameArray = null, this.timelineArray = null, this.userData = null;
          }, e.prototype.addArmature = function (t) {
            t.name in this.armatures ? console.warn("Same armature: " + t.name) : (t.parent = this, this.armatures[t.name] = t, this.armatureNames.push(t.name));
          }, e.prototype.getArmature = function (t) {
            return t in this.armatures ? this.armatures[t] : null;
          }, e.prototype.dispose = function () {
            console.warn(""), this.returnToPool();
          }, e;
        }(t.BaseObject);

        t.DragonBonesData = e;
      }(K || (K = {})), function (t) {
        var e = function (e) {
          function a() {
            var a = null !== e && e.apply(this, arguments) || this;
            return a.aabb = new t.Rectangle(), a.animationNames = [], a.sortedBones = [], a.sortedSlots = [], a.defaultActions = [], a.actions = [], a.bones = {}, a.slots = {}, a.constraints = {}, a.skins = {}, a.animations = {}, a.canvas = null, a.userData = null, a;
          }

          return W(a, e), a.toString = function () {
            return "[class dragonBones.ArmatureData]";
          }, a.prototype._onClear = function () {
            for (var t = 0, e = this.defaultActions; t < e.length; t++) {
              e[t].returnToPool();
            }

            for (var a = 0, i = this.actions; a < i.length; a++) {
              i[a].returnToPool();
            }

            for (var r in this.bones) {
              this.bones[r].returnToPool(), delete this.bones[r];
            }

            for (var r in this.slots) {
              this.slots[r].returnToPool(), delete this.slots[r];
            }

            for (var r in this.constraints) {
              this.constraints[r].returnToPool(), delete this.constraints[r];
            }

            for (var r in this.skins) {
              this.skins[r].returnToPool(), delete this.skins[r];
            }

            for (var r in this.animations) {
              this.animations[r].returnToPool(), delete this.animations[r];
            }

            null !== this.canvas && this.canvas.returnToPool(), null !== this.userData && this.userData.returnToPool(), this.type = 0, this.frameRate = 0, this.cacheFrameRate = 0, this.scale = 1, this.name = "", this.aabb.clear(), this.animationNames.length = 0, this.sortedBones.length = 0, this.sortedSlots.length = 0, this.defaultActions.length = 0, this.actions.length = 0, this.defaultSkin = null, this.defaultAnimation = null, this.canvas = null, this.userData = null, this.parent = null;
          }, a.prototype.sortBones = function () {
            var t = this.sortedBones.length;

            if (!(t <= 0)) {
              var e = this.sortedBones.concat(),
                  a = 0,
                  i = 0;

              for (this.sortedBones.length = 0; i < t;) {
                var r = e[a++];

                if (a >= t && (a = 0), !(this.sortedBones.indexOf(r) >= 0)) {
                  var n = !1;

                  for (var s in this.constraints) {
                    var o = this.constraints[s];

                    if (o.root === r && this.sortedBones.indexOf(o.target) < 0) {
                      n = !0;
                      break;
                    }
                  }

                  n || null !== r.parent && this.sortedBones.indexOf(r.parent) < 0 || (this.sortedBones.push(r), i++);
                }
              }
            }
          }, a.prototype.cacheFrames = function (t) {
            if (!(this.cacheFrameRate > 0)) for (var e in this.cacheFrameRate = t, this.animations) {
              this.animations[e].cacheFrames(this.cacheFrameRate);
            }
          }, a.prototype.setCacheFrame = function (t, e) {
            var a = this.parent.cachedFrames,
                i = a.length;
            return a.length += 10, a[i] = t.a, a[i + 1] = t.b, a[i + 2] = t.c, a[i + 3] = t.d, a[i + 4] = t.tx, a[i + 5] = t.ty, a[i + 6] = e.rotation, a[i + 7] = e.skew, a[i + 8] = e.scaleX, a[i + 9] = e.scaleY, i;
          }, a.prototype.getCacheFrame = function (t, e, a) {
            var i = this.parent.cachedFrames;
            t.a = i[a], t.b = i[a + 1], t.c = i[a + 2], t.d = i[a + 3], t.tx = i[a + 4], t.ty = i[a + 5], e.rotation = i[a + 6], e.skew = i[a + 7], e.scaleX = i[a + 8], e.scaleY = i[a + 9], e.x = t.tx, e.y = t.ty;
          }, a.prototype.addBone = function (t) {
            t.name in this.bones ? console.warn("Same bone: " + t.name) : (this.bones[t.name] = t, this.sortedBones.push(t));
          }, a.prototype.addSlot = function (t) {
            t.name in this.slots ? console.warn("Same slot: " + t.name) : (this.slots[t.name] = t, this.sortedSlots.push(t));
          }, a.prototype.addConstraint = function (t) {
            t.name in this.constraints ? console.warn("Same constraint: " + t.name) : this.constraints[t.name] = t;
          }, a.prototype.addSkin = function (t) {
            t.name in this.skins ? console.warn("Same skin: " + t.name) : (t.parent = this, this.skins[t.name] = t, null === this.defaultSkin && (this.defaultSkin = t), "default" === t.name && (this.defaultSkin = t));
          }, a.prototype.addAnimation = function (t) {
            t.name in this.animations ? console.warn("Same animation: " + t.name) : (t.parent = this, this.animations[t.name] = t, this.animationNames.push(t.name), null === this.defaultAnimation && (this.defaultAnimation = t));
          }, a.prototype.addAction = function (t, e) {
            e ? this.defaultActions.push(t) : this.actions.push(t);
          }, a.prototype.getBone = function (t) {
            return t in this.bones ? this.bones[t] : null;
          }, a.prototype.getSlot = function (t) {
            return t in this.slots ? this.slots[t] : null;
          }, a.prototype.getConstraint = function (t) {
            return t in this.constraints ? this.constraints[t] : null;
          }, a.prototype.getSkin = function (t) {
            return t in this.skins ? this.skins[t] : null;
          }, a.prototype.getMesh = function (t, e, a) {
            var i = this.getSkin(t);
            return null === i ? null : i.getDisplay(e, a);
          }, a.prototype.getAnimation = function (t) {
            return t in this.animations ? this.animations[t] : null;
          }, a;
        }(t.BaseObject);

        t.ArmatureData = e;

        var a = function (e) {
          function a() {
            var a = null !== e && e.apply(this, arguments) || this;
            return a.transform = new t.Transform(), a.userData = null, a;
          }

          return W(a, e), a.toString = function () {
            return "[class dragonBones.BoneData]";
          }, a.prototype._onClear = function () {
            null !== this.userData && this.userData.returnToPool(), this.inheritTranslation = !1, this.inheritRotation = !1, this.inheritScale = !1, this.inheritReflection = !1, this.type = 0, this.length = 0, this.name = "", this.transform.identity(), this.userData = null, this.parent = null;
          }, a;
        }(t.BaseObject);

        t.BoneData = a;

        var i = function (t) {
          function e() {
            var e = null !== t && t.apply(this, arguments) || this;
            return e.vertices = [], e;
          }

          return W(e, t), e.toString = function () {
            return "[class dragonBones.SurfaceData]";
          }, e.prototype._onClear = function () {
            t.prototype._onClear.call(this), this.type = 1, this.segmentX = 0, this.segmentY = 0, this.vertices.length = 0;
          }, e;
        }(a);

        t.SurfaceData = i;

        var r = function (e) {
          function a() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.color = null, t.userData = null, t;
          }

          return W(a, e), a.createColor = function () {
            return new t.ColorTransform();
          }, a.toString = function () {
            return "[class dragonBones.SlotData]";
          }, a.prototype._onClear = function () {
            null !== this.userData && this.userData.returnToPool(), this.blendMode = 0, this.displayIndex = 0, this.zOrder = 0, this.name = "", this.color = null, this.userData = null, this.parent = null;
          }, a.DEFAULT_COLOR = new t.ColorTransform(), a;
        }(t.BaseObject);

        t.SlotData = r;
      }(K || (K = {})), function (t) {
        var e = function (t) {
          function e() {
            return null !== t && t.apply(this, arguments) || this;
          }

          return W(e, t), e.prototype._onClear = function () {
            this.order = 0, this.name = "", this.type = 0, this.target = null, this.root = null, this.bone = null;
          }, e;
        }(t.BaseObject);

        t.ConstraintData = e;

        var a = function (t) {
          function e() {
            return null !== t && t.apply(this, arguments) || this;
          }

          return W(e, t), e.toString = function () {
            return "[class dragonBones.IKConstraintData]";
          }, e.prototype._onClear = function () {
            t.prototype._onClear.call(this), this.scaleEnabled = !1, this.bendPositive = !1, this.weight = 1;
          }, e;
        }(e);

        t.IKConstraintData = a;

        var i = function (t) {
          function e() {
            var e = null !== t && t.apply(this, arguments) || this;
            return e.bones = [], e;
          }

          return W(e, t), e.toString = function () {
            return "[class dragonBones.PathConstraintData]";
          }, e.prototype._onClear = function () {
            t.prototype._onClear.call(this), this.pathSlot = null, this.pathDisplayData = null, this.bones.length = 0, this.positionMode = 0, this.spacingMode = 1, this.rotateMode = 1, this.position = 0, this.spacing = 0, this.rotateOffset = 0, this.rotateMix = 0, this.translateMix = 0;
          }, e.prototype.AddBone = function (t) {
            this.bones.push(t);
          }, e;
        }(e);

        t.PathConstraintData = i;
      }(K || (K = {})), function (t) {
        var e = function (t) {
          function e() {
            return null !== t && t.apply(this, arguments) || this;
          }

          return W(e, t), e.toString = function () {
            return "[class dragonBones.CanvasData]";
          }, e.prototype._onClear = function () {
            this.hasBackground = !1, this.color = 0, this.x = 0, this.y = 0, this.width = 0, this.height = 0;
          }, e;
        }(t.BaseObject);

        t.CanvasData = e;
      }(K || (K = {})), function (t) {
        var e = function (t) {
          function e() {
            var e = null !== t && t.apply(this, arguments) || this;
            return e.displays = {}, e;
          }

          return W(e, t), e.toString = function () {
            return "[class dragonBones.SkinData]";
          }, e.prototype._onClear = function () {
            for (var t in this.displays) {
              for (var e = 0, a = this.displays[t]; e < a.length; e++) {
                var i = a[e];
                null !== i && i.returnToPool();
              }

              delete this.displays[t];
            }

            this.name = "", this.parent = null;
          }, e.prototype.addDisplay = function (t, e) {
            t in this.displays || (this.displays[t] = []), null !== e && (e.parent = this), this.displays[t].push(e);
          }, e.prototype.getDisplay = function (t, e) {
            var a = this.getDisplays(t);
            if (null !== a) for (var i = 0, r = a; i < r.length; i++) {
              var n = r[i];
              if (null !== n && n.name === e) return n;
            }
            return null;
          }, e.prototype.getDisplays = function (t) {
            return t in this.displays ? this.displays[t] : null;
          }, e;
        }(t.BaseObject);

        t.SkinData = e;
      }(K || (K = {})), function (t) {
        var e = function () {
          function t() {
            this.weight = null;
          }

          return t.prototype.clear = function () {
            this.isShared || null === this.weight || this.weight.returnToPool(), this.isShared = !1, this.inheritDeform = !1, this.offset = 0, this.data = null, this.weight = null;
          }, t.prototype.shareFrom = function (t) {
            this.isShared = !0, this.offset = t.offset, this.weight = t.weight;
          }, t;
        }();

        t.VerticesData = e;

        var a = function (e) {
          function a() {
            var a = null !== e && e.apply(this, arguments) || this;
            return a.transform = new t.Transform(), a;
          }

          return W(a, e), a.prototype._onClear = function () {
            this.name = "", this.path = "", this.transform.identity(), this.parent = null;
          }, a;
        }(t.BaseObject);

        t.DisplayData = a;

        var i = function (e) {
          function a() {
            var a = null !== e && e.apply(this, arguments) || this;
            return a.pivot = new t.Point(), a;
          }

          return W(a, e), a.toString = function () {
            return "[class dragonBones.ImageDisplayData]";
          }, a.prototype._onClear = function () {
            e.prototype._onClear.call(this), this.type = 0, this.pivot.clear(), this.texture = null;
          }, a;
        }(a);

        t.ImageDisplayData = i;

        var r = function (t) {
          function e() {
            var e = null !== t && t.apply(this, arguments) || this;
            return e.actions = [], e;
          }

          return W(e, t), e.toString = function () {
            return "[class dragonBones.ArmatureDisplayData]";
          }, e.prototype._onClear = function () {
            t.prototype._onClear.call(this);

            for (var e = 0, a = this.actions; e < a.length; e++) {
              a[e].returnToPool();
            }

            this.type = 1, this.inheritAnimation = !1, this.actions.length = 0, this.armature = null;
          }, e.prototype.addAction = function (t) {
            this.actions.push(t);
          }, e;
        }(a);

        t.ArmatureDisplayData = r;

        var n = function (t) {
          function a() {
            var a = null !== t && t.apply(this, arguments) || this;
            return a.vertices = new e(), a;
          }

          return W(a, t), a.toString = function () {
            return "[class dragonBones.MeshDisplayData]";
          }, a.prototype._onClear = function () {
            t.prototype._onClear.call(this), this.type = 2, this.vertices.clear(), this.texture = null;
          }, a;
        }(a);

        t.MeshDisplayData = n;

        var s = function (t) {
          function e() {
            var e = null !== t && t.apply(this, arguments) || this;
            return e.boundingBox = null, e;
          }

          return W(e, t), e.toString = function () {
            return "[class dragonBones.BoundingBoxDisplayData]";
          }, e.prototype._onClear = function () {
            t.prototype._onClear.call(this), null !== this.boundingBox && this.boundingBox.returnToPool(), this.type = 3, this.boundingBox = null;
          }, e;
        }(a);

        t.BoundingBoxDisplayData = s;

        var o = function (t) {
          function a() {
            var a = null !== t && t.apply(this, arguments) || this;
            return a.vertices = new e(), a.curveLengths = [], a;
          }

          return W(a, t), a.toString = function () {
            return "[class dragonBones.PathDisplayData]";
          }, a.prototype._onClear = function () {
            t.prototype._onClear.call(this), this.type = 4, this.closed = !1, this.constantSpeed = !1, this.vertices.clear(), this.curveLengths.length = 0;
          }, a;
        }(a);

        t.PathDisplayData = o;

        var l = function (t) {
          function e() {
            var e = null !== t && t.apply(this, arguments) || this;
            return e.bones = [], e;
          }

          return W(e, t), e.toString = function () {
            return "[class dragonBones.WeightData]";
          }, e.prototype._onClear = function () {
            this.count = 0, this.offset = 0, this.bones.length = 0;
          }, e.prototype.addBone = function (t) {
            this.bones.push(t);
          }, e;
        }(t.BaseObject);

        t.WeightData = l;
      }(K || (K = {})), function (t) {
        var e = function (t) {
          function e() {
            return null !== t && t.apply(this, arguments) || this;
          }

          return W(e, t), e.prototype._onClear = function () {
            this.color = 0, this.width = 0, this.height = 0;
          }, e;
        }(t.BaseObject);

        t.BoundingBoxData = e;

        var a = function (t) {
          function e() {
            return null !== t && t.apply(this, arguments) || this;
          }

          return W(e, t), e.toString = function () {
            return "[class dragonBones.RectangleBoundingBoxData]";
          }, e._computeOutCode = function (t, e, a, i, r, n) {
            var s = 0;
            return t < a ? s |= 1 : t > r && (s |= 2), e < i ? s |= 4 : e > n && (s |= 8), s;
          }, e.rectangleIntersectsSegment = function (t, a, i, r, n, s, o, l, h, u, _) {
            void 0 === h && (h = null), void 0 === u && (u = null), void 0 === _ && (_ = null);
            var f = t > n && t < o && a > s && a < l,
                c = i > n && i < o && r > s && r < l;
            if (f && c) return -1;

            for (var m = 0, p = e._computeOutCode(t, a, n, s, o, l), d = e._computeOutCode(i, r, n, s, o, l);;) {
              if (0 == (p | d)) {
                m = 2;
                break;
              }

              if (0 != (p & d)) break;
              var y = 0,
                  g = 0,
                  v = 0,
                  D = 0 !== p ? p : d;
              0 != (4 & D) ? (y = t + (i - t) * (s - a) / (r - a), g = s, null !== _ && (v = .5 * -Math.PI)) : 0 != (8 & D) ? (y = t + (i - t) * (l - a) / (r - a), g = l, null !== _ && (v = .5 * Math.PI)) : 0 != (2 & D) ? (g = a + (r - a) * (o - t) / (i - t), y = o, null !== _ && (v = 0)) : 0 != (1 & D) && (g = a + (r - a) * (n - t) / (i - t), y = n, null !== _ && (v = Math.PI)), D === p ? (t = y, a = g, p = e._computeOutCode(t, a, n, s, o, l), null !== _ && (_.x = v)) : (i = y, r = g, d = e._computeOutCode(i, r, n, s, o, l), null !== _ && (_.y = v));
            }

            return m && (f ? (m = 2, null !== h && (h.x = i, h.y = r), null !== u && (u.x = i, u.y = i), null !== _ && (_.x = _.y + Math.PI)) : c ? (m = 1, null !== h && (h.x = t, h.y = a), null !== u && (u.x = t, u.y = a), null !== _ && (_.y = _.x + Math.PI)) : (m = 3, null !== h && (h.x = t, h.y = a), null !== u && (u.x = i, u.y = r))), m;
          }, e.prototype._onClear = function () {
            t.prototype._onClear.call(this), this.type = 0;
          }, e.prototype.containsPoint = function (t, e) {
            var a = .5 * this.width;

            if (t >= -a && t <= a) {
              var i = .5 * this.height;
              if (e >= -i && e <= i) return !0;
            }

            return !1;
          }, e.prototype.intersectsSegment = function (t, a, i, r, n, s, o) {
            void 0 === n && (n = null), void 0 === s && (s = null), void 0 === o && (o = null);
            var l = .5 * this.width,
                h = .5 * this.height;
            return e.rectangleIntersectsSegment(t, a, i, r, -l, -h, l, h, n, s, o);
          }, e;
        }(e);

        t.RectangleBoundingBoxData = a;

        var i = function (t) {
          function e() {
            return null !== t && t.apply(this, arguments) || this;
          }

          return W(e, t), e.toString = function () {
            return "[class dragonBones.EllipseData]";
          }, e.ellipseIntersectsSegment = function (t, e, a, i, r, n, s, o, l, h, u) {
            void 0 === l && (l = null), void 0 === h && (h = null), void 0 === u && (u = null);

            var _ = s / o,
                f = _ * _,
                c = a - t,
                m = (i *= _) - (e *= _),
                p = Math.sqrt(c * c + m * m),
                d = c / p,
                y = m / p,
                g = (r - t) * d + (n - e) * y,
                v = s * s,
                D = v - (t * t + e * e) + g * g,
                b = 0;

            if (D >= 0) {
              var A = Math.sqrt(D),
                  T = g - A,
                  S = g + A,
                  x = T < 0 ? -1 : T <= p ? 0 : 1,
                  P = S < 0 ? -1 : S <= p ? 0 : 1,
                  O = x * P;
              if (O < 0) return -1;
              0 === O && (-1 === x ? (b = 2, a = t + S * d, i = (e + S * y) / _, null !== l && (l.x = a, l.y = i), null !== h && (h.x = a, h.y = i), null !== u && (u.x = Math.atan2(i / v * f, a / v), u.y = u.x + Math.PI)) : 1 === P ? (b = 1, t += T * d, e = (e + T * y) / _, null !== l && (l.x = t, l.y = e), null !== h && (h.x = t, h.y = e), null !== u && (u.x = Math.atan2(e / v * f, t / v), u.y = u.x + Math.PI)) : (b = 3, null !== l && (l.x = t + T * d, l.y = (e + T * y) / _, null !== u && (u.x = Math.atan2(l.y / v * f, l.x / v))), null !== h && (h.x = t + S * d, h.y = (e + S * y) / _, null !== u && (u.y = Math.atan2(h.y / v * f, h.x / v)))));
            }

            return b;
          }, e.prototype._onClear = function () {
            t.prototype._onClear.call(this), this.type = 1;
          }, e.prototype.containsPoint = function (t, e) {
            var a = .5 * this.width;

            if (t >= -a && t <= a) {
              var i = .5 * this.height;
              if (e >= -i && e <= i) return e *= a / i, Math.sqrt(t * t + e * e) <= a;
            }

            return !1;
          }, e.prototype.intersectsSegment = function (t, a, i, r, n, s, o) {
            return void 0 === n && (n = null), void 0 === s && (s = null), void 0 === o && (o = null), e.ellipseIntersectsSegment(t, a, i, r, 0, 0, .5 * this.width, .5 * this.height, n, s, o);
          }, e;
        }(e);

        t.EllipseBoundingBoxData = i;

        var r = function (t) {
          function e() {
            var e = null !== t && t.apply(this, arguments) || this;
            return e.vertices = [], e;
          }

          return W(e, t), e.toString = function () {
            return "[class dragonBones.PolygonBoundingBoxData]";
          }, e.polygonIntersectsSegment = function (t, e, a, i, r, n, s, o) {
            void 0 === n && (n = null), void 0 === s && (s = null), void 0 === o && (o = null), t === a && (t = a + 1e-6), e === i && (e = i + 1e-6);

            for (var l = r.length, h = t - a, u = e - i, _ = t * i - e * a, f = 0, c = r[l - 2], m = r[l - 1], p = 0, d = 0, y = 0, g = 0, v = 0, D = 0, b = 0; b < l; b += 2) {
              var A = r[b],
                  T = r[b + 1];
              c === A && (c = A + 1e-4), m === T && (m = T + 1e-4);
              var S = c - A,
                  x = m - T,
                  P = c * T - m * A,
                  O = h * x - u * S,
                  C = (_ * S - h * P) / O;

              if ((C >= c && C <= A || C >= A && C <= c) && (0 === h || C >= t && C <= a || C >= a && C <= t)) {
                var M = (_ * x - u * P) / O;

                if ((M >= m && M <= T || M >= T && M <= m) && (0 === u || M >= e && M <= i || M >= i && M <= e)) {
                  if (null === s) {
                    y = C, g = M, v = C, D = M, f++, null !== o && (o.x = Math.atan2(T - m, A - c) - .5 * Math.PI, o.y = o.x);
                    break;
                  }

                  var B = C - t;
                  B < 0 && (B = -B), 0 === f ? (p = B, d = B, y = C, g = M, v = C, D = M, null !== o && (o.x = Math.atan2(T - m, A - c) - .5 * Math.PI, o.y = o.x)) : (B < p && (p = B, y = C, g = M, null !== o && (o.x = Math.atan2(T - m, A - c) - .5 * Math.PI)), B > d && (d = B, v = C, D = M, null !== o && (o.y = Math.atan2(T - m, A - c) - .5 * Math.PI))), f++;
                }
              }

              c = A, m = T;
            }

            return 1 === f ? (null !== n && (n.x = y, n.y = g), null !== s && (s.x = y, s.y = g), null !== o && (o.y = o.x + Math.PI)) : f > 1 && (f++, null !== n && (n.x = y, n.y = g), null !== s && (s.x = v, s.y = D)), f;
          }, e.prototype._onClear = function () {
            t.prototype._onClear.call(this), this.type = 2, this.x = 0, this.y = 0, this.vertices.length = 0;
          }, e.prototype.containsPoint = function (t, e) {
            var a = !1;
            if (t >= this.x && t <= this.width && e >= this.y && e <= this.height) for (var i = 0, r = this.vertices.length, n = r - 2; i < r; i += 2) {
              var s = this.vertices[n + 1],
                  o = this.vertices[i + 1];

              if (o < e && s >= e || s < e && o >= e) {
                var l = this.vertices[n],
                    h = this.vertices[i];
                (e - o) * (l - h) / (s - o) + h < t && (a = !a);
              }

              n = i;
            }
            return a;
          }, e.prototype.intersectsSegment = function (t, i, r, n, s, o, l) {
            void 0 === s && (s = null), void 0 === o && (o = null), void 0 === l && (l = null);
            var h = 0;
            return 0 !== a.rectangleIntersectsSegment(t, i, r, n, this.x, this.y, this.x + this.width, this.y + this.height, null, null, null) && (h = e.polygonIntersectsSegment(t, i, r, n, this.vertices, s, o, l)), h;
          }, e;
        }(e);

        t.PolygonBoundingBoxData = r;
      }(K || (K = {})), function (t) {
        var e = function (t) {
          function e() {
            var e = null !== t && t.apply(this, arguments) || this;
            return e.cachedFrames = [], e.boneTimelines = {}, e.surfaceTimelines = {}, e.slotTimelines = {}, e.constraintTimelines = {}, e.animationTimelines = {}, e.boneCachedFrameIndices = {}, e.slotCachedFrameIndices = {}, e.actionTimeline = null, e.zOrderTimeline = null, e;
          }

          return W(e, t), e.toString = function () {
            return "[class dragonBones.AnimationData]";
          }, e.prototype._onClear = function () {
            for (var t in this.boneTimelines) {
              for (var e = 0, a = this.boneTimelines[t]; e < a.length; e++) {
                a[e].returnToPool();
              }

              delete this.boneTimelines[t];
            }

            for (var t in this.surfaceTimelines) {
              for (var i = 0, r = this.surfaceTimelines[t]; i < r.length; i++) {
                r[i].returnToPool();
              }

              delete this.surfaceTimelines[t];
            }

            for (var t in this.slotTimelines) {
              for (var n = 0, s = this.slotTimelines[t]; n < s.length; n++) {
                s[n].returnToPool();
              }

              delete this.slotTimelines[t];
            }

            for (var t in this.constraintTimelines) {
              for (var o = 0, l = this.constraintTimelines[t]; o < l.length; o++) {
                l[o].returnToPool();
              }

              delete this.constraintTimelines[t];
            }

            for (var t in this.animationTimelines) {
              for (var h = 0, u = this.animationTimelines[t]; h < u.length; h++) {
                u[h].returnToPool();
              }

              delete this.animationTimelines[t];
            }

            for (var t in this.boneCachedFrameIndices) {
              delete this.boneCachedFrameIndices[t];
            }

            for (var t in this.slotCachedFrameIndices) {
              delete this.slotCachedFrameIndices[t];
            }

            null !== this.actionTimeline && this.actionTimeline.returnToPool(), null !== this.zOrderTimeline && this.zOrderTimeline.returnToPool(), this.frameIntOffset = 0, this.frameFloatOffset = 0, this.frameOffset = 0, this.frameCount = 0, this.playTimes = 0, this.duration = 0, this.scale = 1, this.fadeInTime = 0, this.cacheFrameRate = 0, this.name = "", this.cachedFrames.length = 0, this.actionTimeline = null, this.zOrderTimeline = null, this.parent = null;
          }, e.prototype.cacheFrames = function (t) {
            if (!(this.cacheFrameRate > 0)) {
              this.cacheFrameRate = Math.max(Math.ceil(t * this.scale), 1);
              var e = Math.ceil(this.cacheFrameRate * this.duration) + 1;
              this.cachedFrames.length = e;

              for (var a = 0, i = this.cacheFrames.length; a < i; ++a) {
                this.cachedFrames[a] = !1;
              }

              for (var r = 0, n = this.parent.sortedBones; r < n.length; r++) {
                var s = n[r];

                for (a = 0, i = (h = new Array(e)).length; a < i; ++a) {
                  h[a] = -1;
                }

                this.boneCachedFrameIndices[s.name] = h;
              }

              for (var o = 0, l = this.parent.sortedSlots; o < l.length; o++) {
                var h,
                    u = l[o];

                for (a = 0, i = (h = new Array(e)).length; a < i; ++a) {
                  h[a] = -1;
                }

                this.slotCachedFrameIndices[u.name] = h;
              }
            }
          }, e.prototype.addBoneTimeline = function (t, e) {
            var a = t.name in this.boneTimelines ? this.boneTimelines[t.name] : this.boneTimelines[t.name] = [];
            a.indexOf(e) < 0 && a.push(e);
          }, e.prototype.addSurfaceTimeline = function (t, e) {
            var a = t.name in this.surfaceTimelines ? this.surfaceTimelines[t.name] : this.surfaceTimelines[t.name] = [];
            a.indexOf(e) < 0 && a.push(e);
          }, e.prototype.addSlotTimeline = function (t, e) {
            var a = t.name in this.slotTimelines ? this.slotTimelines[t.name] : this.slotTimelines[t.name] = [];
            a.indexOf(e) < 0 && a.push(e);
          }, e.prototype.addConstraintTimeline = function (t, e) {
            var a = t.name in this.constraintTimelines ? this.constraintTimelines[t.name] : this.constraintTimelines[t.name] = [];
            a.indexOf(e) < 0 && a.push(e);
          }, e.prototype.addAnimationTimeline = function (t, e) {
            var a = t in this.animationTimelines ? this.animationTimelines[t] : this.animationTimelines[t] = [];
            a.indexOf(e) < 0 && a.push(e);
          }, e.prototype.getBoneTimelines = function (t) {
            return t in this.boneTimelines ? this.boneTimelines[t] : null;
          }, e.prototype.getSurfaceTimelines = function (t) {
            return t in this.surfaceTimelines ? this.surfaceTimelines[t] : null;
          }, e.prototype.getSlotTimelines = function (t) {
            return t in this.slotTimelines ? this.slotTimelines[t] : null;
          }, e.prototype.getConstraintTimelines = function (t) {
            return t in this.constraintTimelines ? this.constraintTimelines[t] : null;
          }, e.prototype.getAnimationTimelines = function (t) {
            return t in this.animationTimelines ? this.animationTimelines[t] : null;
          }, e.prototype.getBoneCachedFrameIndices = function (t) {
            return t in this.boneCachedFrameIndices ? this.boneCachedFrameIndices[t] : null;
          }, e.prototype.getSlotCachedFrameIndices = function (t) {
            return t in this.slotCachedFrameIndices ? this.slotCachedFrameIndices[t] : null;
          }, e;
        }(t.BaseObject);

        t.AnimationData = e;

        var a = function (t) {
          function e() {
            return null !== t && t.apply(this, arguments) || this;
          }

          return W(e, t), e.toString = function () {
            return "[class dragonBones.TimelineData]";
          }, e.prototype._onClear = function () {
            this.type = 10, this.offset = 0, this.frameIndicesOffset = -1;
          }, e;
        }(t.BaseObject);

        t.TimelineData = a;
      }(K || (K = {})), function (t) {
        var e = function (t) {
          function e() {
            var e = null !== t && t.apply(this, arguments) || this;
            return e.boneMask = [], e;
          }

          return W(e, t), e.toString = function () {
            return "[class dragonBones.AnimationConfig]";
          }, e.prototype._onClear = function () {
            this.pauseFadeOut = !0, this.fadeOutMode = 4, this.fadeOutTweenType = 1, this.fadeOutTime = -1, this.actionEnabled = !0, this.additiveBlending = !1, this.displayControl = !0, this.pauseFadeIn = !0, this.resetToPose = !0, this.fadeInTweenType = 1, this.playTimes = -1, this.layer = 0, this.position = 0, this.duration = -1, this.timeScale = -100, this.weight = 1, this.fadeInTime = -1, this.autoFadeOutTime = -1, this.name = "", this.animation = "", this.group = "", this.boneMask.length = 0;
          }, e.prototype.clear = function () {
            this._onClear();
          }, e.prototype.copyFrom = function (t) {
            this.pauseFadeOut = t.pauseFadeOut, this.fadeOutMode = t.fadeOutMode, this.autoFadeOutTime = t.autoFadeOutTime, this.fadeOutTweenType = t.fadeOutTweenType, this.actionEnabled = t.actionEnabled, this.additiveBlending = t.additiveBlending, this.displayControl = t.displayControl, this.pauseFadeIn = t.pauseFadeIn, this.resetToPose = t.resetToPose, this.playTimes = t.playTimes, this.layer = t.layer, this.position = t.position, this.duration = t.duration, this.timeScale = t.timeScale, this.fadeInTime = t.fadeInTime, this.fadeOutTime = t.fadeOutTime, this.fadeInTweenType = t.fadeInTweenType, this.weight = t.weight, this.name = t.name, this.animation = t.animation, this.group = t.group, this.boneMask.length = t.boneMask.length;

            for (var e = 0, a = this.boneMask.length; e < a; ++e) {
              this.boneMask[e] = t.boneMask[e];
            }
          }, e.prototype.containsBoneMask = function (t) {
            return 0 === this.boneMask.length || this.boneMask.indexOf(t) >= 0;
          }, e.prototype.addBoneMask = function (t, e, a) {
            void 0 === a && (a = !0);
            var i = t.getBone(e);
            if (null !== i && (this.boneMask.indexOf(e) < 0 && this.boneMask.push(e), a)) for (var r = 0, n = t.getBones(); r < n.length; r++) {
              var s = n[r];
              this.boneMask.indexOf(s.name) < 0 && i.contains(s) && this.boneMask.push(s.name);
            }
          }, e.prototype.removeBoneMask = function (t, e, a) {
            void 0 === a && (a = !0);
            var i = this.boneMask.indexOf(e);

            if (i >= 0 && this.boneMask.splice(i, 1), a) {
              var r = t.getBone(e);
              if (null !== r) if (this.boneMask.length > 0) for (var n = 0, s = t.getBones(); n < s.length; n++) {
                var o = s[n],
                    l = this.boneMask.indexOf(o.name);
                l >= 0 && r.contains(o) && this.boneMask.splice(l, 1);
              } else for (var h = 0, u = t.getBones(); h < u.length; h++) {
                (o = u[h]) !== r && (r.contains(o) || this.boneMask.push(o.name));
              }
            }
          }, e;
        }(t.BaseObject);

        t.AnimationConfig = e;
      }(K || (K = {})), function (t) {
        var e = function (t) {
          function e() {
            var e = null !== t && t.apply(this, arguments) || this;
            return e.textures = {}, e;
          }

          return W(e, t), e.prototype._onClear = function () {
            for (var t in this.textures) {
              this.textures[t].returnToPool(), delete this.textures[t];
            }

            this.autoSearch = !1, this.width = 0, this.height = 0, this.scale = 1, this.name = "", this.imagePath = "";
          }, e.prototype.copyFrom = function (t) {
            for (var e in this.autoSearch = t.autoSearch, this.scale = t.scale, this.width = t.width, this.height = t.height, this.name = t.name, this.imagePath = t.imagePath, this.textures) {
              this.textures[e].returnToPool(), delete this.textures[e];
            }

            for (var e in t.textures) {
              var a = this.createTexture();
              a.copyFrom(t.textures[e]), this.textures[e] = a;
            }
          }, e.prototype.addTexture = function (t) {
            t.name in this.textures ? console.warn("Same texture: " + t.name) : (t.parent = this, this.textures[t.name] = t);
          }, e.prototype.getTexture = function (t) {
            return t in this.textures ? this.textures[t] : null;
          }, e;
        }(t.BaseObject);

        t.TextureAtlasData = e;

        var a = function (e) {
          function a() {
            var a = null !== e && e.apply(this, arguments) || this;
            return a.region = new t.Rectangle(), a.frame = null, a;
          }

          return W(a, e), a.createRectangle = function () {
            return new t.Rectangle();
          }, a.prototype._onClear = function () {
            this.rotated = !1, this.name = "", this.region.clear(), this.parent = null, this.frame = null;
          }, a.prototype.copyFrom = function (t) {
            this.rotated = t.rotated, this.name = t.name, this.region.copyFrom(t.region), this.parent = t.parent, null === this.frame && null !== t.frame ? this.frame = a.createRectangle() : null !== this.frame && null === t.frame && (this.frame = null), null !== this.frame && null !== t.frame && this.frame.copyFrom(t.frame);
          }, a;
        }(t.BaseObject);

        t.TextureData = a;
      }(K || (K = {})), function (t) {
        var e = function (t) {
          function e() {
            var e = null !== t && t.apply(this, arguments) || this;
            return e.vertices = [], e.bones = [], e;
          }

          return W(e, t), e.toString = function () {
            return "[class dragonBones.DeformVertices]";
          }, e.prototype._onClear = function () {
            this.verticesDirty = !1, this.vertices.length = 0, this.bones.length = 0, this.verticesData = null;
          }, e.prototype.init = function (t, e) {
            if (this.verticesData = t, null !== this.verticesData) {
              var a;
              a = null !== this.verticesData.weight ? 2 * this.verticesData.weight.count : 2 * this.verticesData.data.intArray[this.verticesData.offset + 0], this.verticesDirty = !0, this.vertices.length = a, this.bones.length = 0;

              for (var i = 0, r = this.vertices.length; i < r; ++i) {
                this.vertices[i] = 0;
              }

              if (null !== this.verticesData.weight) for (i = 0, r = this.verticesData.weight.bones.length; i < r; ++i) {
                var n = e.getBone(this.verticesData.weight.bones[i].name);
                this.bones.push(n);
              }
            } else this.verticesDirty = !1, this.vertices.length = 0, this.bones.length = 0, this.verticesData = null;
          }, e.prototype.isBonesUpdate = function () {
            for (var t = 0, e = this.bones; t < e.length; t++) {
              var a = e[t];
              if (null !== a && a._childrenTransformDirty) return !0;
            }

            return !1;
          }, e;
        }(t.BaseObject);

        t.DeformVertices = e;
      }(K || (K = {})), function (t) {
        var e = function (e) {
          function a() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t._bones = [], t._slots = [], t._constraints = [], t._actions = [], t._animation = null, t._proxy = null, t._replaceTextureAtlasData = null, t._clock = null, t;
          }

          return W(a, e), a.toString = function () {
            return "[class dragonBones.Armature]";
          }, a._onSortSlots = function (t, e) {
            return t._zOrder > e._zOrder ? 1 : -1;
          }, a.prototype._onClear = function () {
            null !== this._clock && this._clock.remove(this);

            for (var t = 0, e = this._bones; t < e.length; t++) {
              e[t].returnToPool();
            }

            for (var a = 0, i = this._slots; a < i.length; a++) {
              i[a].returnToPool();
            }

            for (var r = 0, n = this._constraints; r < n.length; r++) {
              n[r].returnToPool();
            }

            for (var s = 0, o = this._actions; s < o.length; s++) {
              o[s].returnToPool();
            }

            null !== this._animation && this._animation.returnToPool(), null !== this._proxy && this._proxy.dbClear(), null !== this._replaceTextureAtlasData && this._replaceTextureAtlasData.returnToPool(), this.inheritAnimation = !0, this.userData = null, this._lockUpdate = !1, this._slotsDirty = !0, this._zOrderDirty = !1, this._flipX = !1, this._flipY = !1, this._cacheFrameIndex = -1, this._bones.length = 0, this._slots.length = 0, this._constraints.length = 0, this._actions.length = 0, this._armatureData = null, this._animation = null, this._proxy = null, this._display = null, this._replaceTextureAtlasData = null, this._replacedTexture = null, this._dragonBones = null, this._clock = null, this._parent = null;
          }, a.prototype._sortZOrder = function (t, e) {
            var a = this._armatureData.sortedSlots,
                i = null === t;

            if (this._zOrderDirty || !i) {
              for (var r = 0, n = a.length; r < n; ++r) {
                var s = i ? r : t[e + r];

                if (!(s < 0 || s >= n)) {
                  var o = a[s],
                      l = this.getSlot(o.name);
                  null !== l && l._setZorder(r);
                }
              }

              this._slotsDirty = !0, this._zOrderDirty = !i;
            }
          }, a.prototype._addBone = function (t) {
            this._bones.indexOf(t) < 0 && this._bones.push(t);
          }, a.prototype._addSlot = function (t) {
            this._slots.indexOf(t) < 0 && this._slots.push(t);
          }, a.prototype._addConstraint = function (t) {
            this._constraints.indexOf(t) < 0 && this._constraints.push(t);
          }, a.prototype._bufferAction = function (t, e) {
            this._actions.indexOf(t) < 0 && (e ? this._actions.push(t) : this._actions.unshift(t));
          }, a.prototype.dispose = function () {
            null !== this._armatureData && (this._lockUpdate = !0, this._dragonBones.bufferObject(this));
          }, a.prototype.init = function (e, a, i, r) {
            null === this._armatureData && (this._armatureData = e, this._animation = t.BaseObject.borrowObject(t.Animation), this._proxy = a, this._display = i, this._dragonBones = r, this._proxy.dbInit(this), this._animation.init(this), this._animation.animations = this._armatureData.animations);
          }, a.prototype.advanceTime = function (t) {
            if (!this._lockUpdate) if (null !== this._armatureData) {
              if (null !== this._armatureData.parent) {
                var e = this._cacheFrameIndex;

                if (this._animation.advanceTime(t), this._slotsDirty && (this._slotsDirty = !1, this._slots.sort(a._onSortSlots)), this._cacheFrameIndex < 0 || this._cacheFrameIndex !== e) {
                  var i = 0,
                      r = 0;

                  for (i = 0, r = this._bones.length; i < r; ++i) {
                    this._bones[i].update(this._cacheFrameIndex);
                  }

                  for (i = 0, r = this._slots.length; i < r; ++i) {
                    this._slots[i].update(this._cacheFrameIndex);
                  }
                }

                if (this._actions.length > 0) {
                  this._lockUpdate = !0;

                  for (var n = 0, s = this._actions; n < s.length; n++) {
                    var o = s[n],
                        l = o.actionData;
                    if (null !== l && 0 === l.type) if (null !== o.slot) null !== (_ = o.slot.childArmature) && _.animation.fadeIn(l.name);else if (null !== o.bone) for (var h = 0, u = this.getSlots(); h < u.length; h++) {
                      var _,
                          f = u[h];

                      f.parent === o.bone && null !== (_ = f.childArmature) && _.animation.fadeIn(l.name);
                    } else this._animation.fadeIn(l.name);
                    o.returnToPool();
                  }

                  this._actions.length = 0, this._lockUpdate = !1;
                }

                this._proxy.dbUpdate();
              } else console.warn("The armature data has been disposed.\nPlease make sure dispose armature before call factory.clear().");
            } else console.warn("The armature has been disposed.");
          }, a.prototype.invalidUpdate = function (t, e) {
            if (void 0 === t && (t = null), void 0 === e && (e = !1), null !== t && t.length > 0) {
              if (null !== (s = this.getBone(t)) && (s.invalidUpdate(), e)) for (var a = 0, i = this._slots; a < i.length; a++) {
                (h = i[a]).parent === s && h.invalidUpdate();
              }
            } else {
              for (var r = 0, n = this._bones; r < n.length; r++) {
                var s;
                (s = n[r]).invalidUpdate();
              }

              if (e) for (var o = 0, l = this._slots; o < l.length; o++) {
                var h;
                (h = l[o]).invalidUpdate();
              }
            }
          }, a.prototype.containsPoint = function (t, e) {
            for (var a = 0, i = this._slots; a < i.length; a++) {
              var r = i[a];
              if (r.containsPoint(t, e)) return r;
            }

            return null;
          }, a.prototype.intersectsSegment = function (t, e, a, i, r, n, s) {
            void 0 === r && (r = null), void 0 === n && (n = null), void 0 === s && (s = null);

            for (var o = t === a, l = 0, h = 0, u = 0, _ = 0, f = 0, c = 0, m = 0, p = 0, d = null, y = null, g = 0, v = this._slots; g < v.length; g++) {
              var D = v[g];

              if (D.intersectsSegment(t, e, a, i, r, n, s) > 0) {
                if (null === r && null === n) {
                  d = D;
                  break;
                }

                var b;
                null !== r && ((b = o ? r.y - e : r.x - t) < 0 && (b = -b), (null === d || b < l) && (l = b, u = r.x, _ = r.y, d = D, s && (m = s.x))), null !== n && ((b = n.x - t) < 0 && (b = -b), (null === y || b > h) && (h = b, f = n.x, c = n.y, y = D, null !== s && (p = s.y)));
              }
            }

            return null !== d && null !== r && (r.x = u, r.y = _, null !== s && (s.x = m)), null !== y && null !== n && (n.x = f, n.y = c, null !== s && (s.y = p)), d;
          }, a.prototype.getBone = function (t) {
            for (var e = 0, a = this._bones; e < a.length; e++) {
              var i = a[e];
              if (i.name === t) return i;
            }

            return null;
          }, a.prototype.getBoneByDisplay = function (t) {
            var e = this.getSlotByDisplay(t);
            return null !== e ? e.parent : null;
          }, a.prototype.getSlot = function (t) {
            for (var e = 0, a = this._slots; e < a.length; e++) {
              var i = a[e];
              if (i.name === t) return i;
            }

            return null;
          }, a.prototype.getSlotByDisplay = function (t) {
            if (null !== t) for (var e = 0, a = this._slots; e < a.length; e++) {
              var i = a[e];
              if (i.display === t) return i;
            }
            return null;
          }, a.prototype.getBones = function () {
            return this._bones;
          }, a.prototype.getSlots = function () {
            return this._slots;
          }, Object.defineProperty(a.prototype, "flipX", {
            get: function get() {
              return this._flipX;
            },
            set: function set(t) {
              this._flipX !== t && (this._flipX = t, this.invalidUpdate());
            },
            enumerable: !0,
            configurable: !0
          }), Object.defineProperty(a.prototype, "flipY", {
            get: function get() {
              return this._flipY;
            },
            set: function set(t) {
              this._flipY !== t && (this._flipY = t, this.invalidUpdate());
            },
            enumerable: !0,
            configurable: !0
          }), Object.defineProperty(a.prototype, "cacheFrameRate", {
            get: function get() {
              return this._armatureData.cacheFrameRate;
            },
            set: function set(t) {
              if (this._armatureData.cacheFrameRate !== t) {
                this._armatureData.cacheFrames(t);

                for (var e = 0, a = this._slots; e < a.length; e++) {
                  var i = a[e].childArmature;
                  null !== i && (i.cacheFrameRate = t);
                }
              }
            },
            enumerable: !0,
            configurable: !0
          }), Object.defineProperty(a.prototype, "name", {
            get: function get() {
              return this._armatureData.name;
            },
            enumerable: !0,
            configurable: !0
          }), Object.defineProperty(a.prototype, "armatureData", {
            get: function get() {
              return this._armatureData;
            },
            enumerable: !0,
            configurable: !0
          }), Object.defineProperty(a.prototype, "animation", {
            get: function get() {
              return this._animation;
            },
            enumerable: !0,
            configurable: !0
          }), Object.defineProperty(a.prototype, "proxy", {
            get: function get() {
              return this._proxy;
            },
            enumerable: !0,
            configurable: !0
          }), Object.defineProperty(a.prototype, "eventDispatcher", {
            get: function get() {
              return this._proxy;
            },
            enumerable: !0,
            configurable: !0
          }), Object.defineProperty(a.prototype, "display", {
            get: function get() {
              return this._display;
            },
            enumerable: !0,
            configurable: !0
          }), Object.defineProperty(a.prototype, "replacedTexture", {
            get: function get() {
              return this._replacedTexture;
            },
            set: function set(t) {
              if (this._replacedTexture !== t) {
                null !== this._replaceTextureAtlasData && (this._replaceTextureAtlasData.returnToPool(), this._replaceTextureAtlasData = null), this._replacedTexture = t;

                for (var e = 0, a = this._slots; e < a.length; e++) {
                  var i = a[e];
                  i.invalidUpdate(), i.update(-1);
                }
              }
            },
            enumerable: !0,
            configurable: !0
          }), Object.defineProperty(a.prototype, "clock", {
            get: function get() {
              return this._clock;
            },
            set: function set(t) {
              if (this._clock !== t) {
                null !== this._clock && this._clock.remove(this), this._clock = t, this._clock && this._clock.add(this);

                for (var e = 0, a = this._slots; e < a.length; e++) {
                  var i = a[e].childArmature;
                  null !== i && (i.clock = this._clock);
                }
              }
            },
            enumerable: !0,
            configurable: !0
          }), Object.defineProperty(a.prototype, "parent", {
            get: function get() {
              return this._parent;
            },
            enumerable: !0,
            configurable: !0
          }), a.prototype.replaceTexture = function (t) {
            this.replacedTexture = t;
          }, a.prototype.hasEventListener = function (t) {
            return this._proxy.hasDBEventListener(t);
          }, a.prototype.addEventListener = function (t, e, a) {
            this._proxy.addDBEventListener(t, e, a);
          }, a.prototype.removeEventListener = function (t, e, a) {
            this._proxy.removeDBEventListener(t, e, a);
          }, a.prototype.enableAnimationCache = function (t) {
            console.warn("Deprecated."), this.cacheFrameRate = t;
          }, a.prototype.getDisplay = function () {
            return this._display;
          }, a;
        }(t.BaseObject);

        t.Armature = e;
      }(K || (K = {})), function (t) {
        var e = function (e) {
          function a() {
            var a = null !== e && e.apply(this, arguments) || this;
            return a.globalTransformMatrix = new t.Matrix(), a.global = new t.Transform(), a.offset = new t.Transform(), a;
          }

          return W(a, e), a.prototype._onClear = function () {
            this.globalTransformMatrix.identity(), this.global.identity(), this.offset.identity(), this.origin = null, this.userData = null, this._globalDirty = !1, this._armature = null;
          }, a.prototype.updateGlobalTransform = function () {
            this._globalDirty && (this._globalDirty = !1, this.global.fromMatrix(this.globalTransformMatrix));
          }, Object.defineProperty(a.prototype, "armature", {
            get: function get() {
              return this._armature;
            },
            enumerable: !0,
            configurable: !0
          }), a._helpMatrix = new t.Matrix(), a._helpTransform = new t.Transform(), a._helpPoint = new t.Point(), a;
        }(t.BaseObject);

        t.TransformObject = e;
      }(K || (K = {})), function (t) {
        var e = function (e) {
          function a() {
            var a = null !== e && e.apply(this, arguments) || this;
            return a.animationPose = new t.Transform(), a._blendState = new t.BlendState(), a;
          }

          return W(a, e), a.toString = function () {
            return "[class dragonBones.Bone]";
          }, a.prototype._onClear = function () {
            e.prototype._onClear.call(this), this.offsetMode = 1, this.animationPose.identity(), this._transformDirty = !1, this._childrenTransformDirty = !1, this._localDirty = !0, this._hasConstraint = !1, this._visible = !0, this._cachedFrameIndex = -1, this._blendState.clear(), this._boneData = null, this._parent = null, this._cachedFrameIndices = null;
          }, a.prototype._updateGlobalTransformMatrix = function (e) {
            var a = this._boneData,
                i = this.global,
                r = this.globalTransformMatrix,
                n = this.origin,
                s = this.offset,
                o = this.animationPose,
                l = this._parent,
                h = this._armature.flipX,
                u = this._armature.flipY === t.DragonBones.yDown,
                _ = null !== l,
                f = 0;

            if (1 === this.offsetMode ? null !== n ? (i.x = n.x + s.x + o.x, i.scaleX = n.scaleX * s.scaleX * o.scaleX, i.scaleY = n.scaleY * s.scaleY * o.scaleY, t.DragonBones.yDown ? (i.y = n.y + s.y + o.y, i.skew = n.skew + s.skew + o.skew, i.rotation = n.rotation + s.rotation + o.rotation) : (i.y = n.y - s.y + o.y, i.skew = n.skew - s.skew + o.skew, i.rotation = n.rotation - s.rotation + o.rotation)) : (i.copyFrom(s), t.DragonBones.yDown || (i.y = -i.y, i.skew = -i.skew, i.rotation = -i.rotation), i.add(o)) : 0 === this.offsetMode ? null !== n ? i.copyFrom(n).add(o) : i.copyFrom(o) : (_ = !1, i.copyFrom(s), t.DragonBones.yDown || (i.y = -i.y, i.skew = -i.skew, i.rotation = -i.rotation)), _) {
              var c = 0 === l._boneData.type ? l.globalTransformMatrix : l._getGlobalTransformMatrix(i.x, i.y);
              if (a.inheritScale) a.inheritRotation || (l.updateGlobalTransform(), f = h && u ? i.rotation - (l.global.rotation + Math.PI) : h ? i.rotation + l.global.rotation + Math.PI : u ? i.rotation + l.global.rotation : i.rotation - l.global.rotation, i.rotation = f), i.toMatrix(r), r.concat(c), a.inheritTranslation ? (i.x = r.tx, i.y = r.ty) : (r.tx = i.x, r.ty = i.y), e ? i.fromMatrix(r) : this._globalDirty = !0;else {
                if (a.inheritTranslation) {
                  var m = i.x,
                      p = i.y;
                  i.x = c.a * m + c.c * p + c.tx, i.y = c.b * m + c.d * p + c.ty;
                } else h && (i.x = -i.x), u && (i.y = -i.y);

                a.inheritRotation ? (l.updateGlobalTransform(), f = l.global.scaleX < 0 ? i.rotation + l.global.rotation + Math.PI : i.rotation + l.global.rotation, c.a * c.d - c.b * c.c < 0 && (f -= 2 * i.rotation, (h !== u || a.inheritReflection) && (i.skew += Math.PI), t.DragonBones.yDown || (i.skew = -i.skew)), i.rotation = f) : (h || u) && (h && u ? f = i.rotation + Math.PI : (f = h ? Math.PI - i.rotation : -i.rotation, i.skew += Math.PI), i.rotation = f), i.toMatrix(r);
              }
            } else (h || u) && (h && (i.x = -i.x), u && (i.y = -i.y), h && u ? f = i.rotation + Math.PI : (f = h ? Math.PI - i.rotation : -i.rotation, i.skew += Math.PI), i.rotation = f), i.toMatrix(r);
          }, a.prototype.init = function (t, e) {
            null === this._boneData && (this._boneData = t, this._armature = e, null !== this._boneData.parent && (this._parent = this._armature.getBone(this._boneData.parent.name)), this._armature._addBone(this), this.origin = this._boneData.transform);
          }, a.prototype.update = function (t) {
            if (this._blendState.dirty = !1, t >= 0 && null !== this._cachedFrameIndices) {
              var e = this._cachedFrameIndices[t];
              if (e >= 0 && this._cachedFrameIndex === e) this._transformDirty = !1;else if (e >= 0) this._transformDirty = !0, this._cachedFrameIndex = e;else {
                if (this._hasConstraint) for (var a = 0, i = this._armature._constraints; a < i.length; a++) {
                  (s = i[a])._root === this && s.update();
                }
                this._transformDirty || null !== this._parent && this._parent._childrenTransformDirty ? (this._transformDirty = !0, this._cachedFrameIndex = -1) : this._cachedFrameIndex >= 0 ? (this._transformDirty = !1, this._cachedFrameIndices[t] = this._cachedFrameIndex) : (this._transformDirty = !0, this._cachedFrameIndex = -1);
              }
            } else {
              if (this._hasConstraint) for (var r = 0, n = this._armature._constraints; r < n.length; r++) {
                var s;
                (s = n[r])._root === this && s.update();
              }
              (this._transformDirty || null !== this._parent && this._parent._childrenTransformDirty) && (t = -1, this._transformDirty = !0, this._cachedFrameIndex = -1);
            }

            if (this._transformDirty) {
              if (this._transformDirty = !1, this._childrenTransformDirty = !0, this._cachedFrameIndex < 0) {
                var o = t >= 0;
                this._localDirty && this._updateGlobalTransformMatrix(o), o && null !== this._cachedFrameIndices && (this._cachedFrameIndex = this._cachedFrameIndices[t] = this._armature._armatureData.setCacheFrame(this.globalTransformMatrix, this.global));
              } else this._armature._armatureData.getCacheFrame(this.globalTransformMatrix, this.global, this._cachedFrameIndex);
            } else this._childrenTransformDirty && (this._childrenTransformDirty = !1);
            this._localDirty = !0;
          }, a.prototype.updateByConstraint = function () {
            this._localDirty && (this._localDirty = !1, (this._transformDirty || null !== this._parent && this._parent._childrenTransformDirty) && this._updateGlobalTransformMatrix(!0), this._transformDirty = !0);
          }, a.prototype.invalidUpdate = function () {
            this._transformDirty = !0;
          }, a.prototype.contains = function (t) {
            if (t === this) return !1;

            for (var e = t; e !== this && null !== e;) {
              e = e.parent;
            }

            return e === this;
          }, Object.defineProperty(a.prototype, "boneData", {
            get: function get() {
              return this._boneData;
            },
            enumerable: !0,
            configurable: !0
          }), Object.defineProperty(a.prototype, "visible", {
            get: function get() {
              return this._visible;
            },
            set: function set(t) {
              if (this._visible !== t) {
                this._visible = t;

                for (var e = 0, a = this._armature.getSlots(); e < a.length; e++) {
                  var i = a[e];
                  i.parent === this && i._updateVisible();
                }
              }
            },
            enumerable: !0,
            configurable: !0
          }), Object.defineProperty(a.prototype, "name", {
            get: function get() {
              return this._boneData.name;
            },
            enumerable: !0,
            configurable: !0
          }), Object.defineProperty(a.prototype, "parent", {
            get: function get() {
              return this._parent;
            },
            enumerable: !0,
            configurable: !0
          }), a.prototype.getBones = function () {
            console.warn("Deprecated.");

            for (var t = new Array(), e = 0, a = this._armature.getBones(); e < a.length; e++) {
              var i = a[e];
              i.parent === this && t.push(i);
            }

            return t;
          }, a.prototype.getSlots = function () {
            console.warn("Deprecated.");

            for (var t = new Array(), e = 0, a = this._armature.getSlots(); e < a.length; e++) {
              var i = a[e];
              i.parent === this && t.push(i);
            }

            return t;
          }, Object.defineProperty(a.prototype, "slot", {
            get: function get() {
              console.warn("Deprecated.");

              for (var t = 0, e = this._armature.getSlots(); t < e.length; t++) {
                var a = e[t];
                if (a.parent === this) return a;
              }

              return null;
            },
            enumerable: !0,
            configurable: !0
          }), a;
        }(t.TransformObject);

        t.Bone = e;
      }(K || (K = {})), function (t) {
        var e = function (t) {
          function e() {
            var e = null !== t && t.apply(this, arguments) || this;
            return e._vertices = [], e._deformVertices = [], e._hullCache = [], e._matrixCahce = [], e;
          }

          return W(e, t), e.toString = function () {
            return "[class dragonBones.Surface]";
          }, e.prototype._onClear = function () {
            t.prototype._onClear.call(this), this._dX = 0, this._dY = 0, this._k = 0, this._kX = 0, this._kY = 0, this._vertices.length = 0, this._deformVertices.length = 0, this._matrixCahce.length = 0, this._hullCache.length = 0;
          }, e.prototype._getAffineTransform = function (t, e, a, i, r, n, s, o, l, h, u, _, f) {
            var c = s - r,
                m = o - n,
                p = l - r,
                d = h - n;
            u.rotation = Math.atan2(m, c), u.skew = Math.atan2(d, p) - .5 * Math.PI - u.rotation, f && (u.rotation += Math.PI), u.scaleX = Math.sqrt(c * c + m * m) / a, u.scaleY = Math.sqrt(p * p + d * d) / i, u.toMatrix(_), u.x = _.tx = r - (_.a * t + _.c * e), u.y = _.ty = n - (_.b * t + _.d * e);
          }, e.prototype._updateVertices = function () {
            var t = this._boneData.vertices,
                e = this._vertices,
                a = this._deformVertices;
            if (null !== this._parent) {
              if (1 === this._parent._boneData.type) for (var i = 0, r = t.length; i < r; i += 2) {
                var n = t[i] + a[i],
                    s = t[i + 1] + a[i],
                    o = this._parent._getGlobalTransformMatrix(n, s);

                e[i] = o.a * n + o.c * s + o.tx, e[i + 1] = o.b * n + o.d * s + o.ty;
              } else {
                var l = this._parent.globalTransformMatrix;

                for (i = 0, r = t.length; i < r; i += 2) {
                  n = t[i] + a[i], s = t[i + 1] + a[i + 1], e[i] = l.a * n + l.c * s + l.tx, e[i + 1] = l.b * n + l.d * s + l.ty;
                }
              }
            } else for (i = 0, r = t.length; i < r; i += 2) {
              e[i] = t[i] + a[i], e[i + 1] = t[i + 1] + a[i + 1];
            }
          }, e.prototype._updateGlobalTransformMatrix = function () {
            var t = 2 * this._boneData.segmentX,
                e = this._vertices.length - 2,
                a = this._vertices[0],
                i = this._vertices[1],
                r = this._vertices[t],
                n = this._vertices[t + 1],
                s = this._vertices[e],
                o = this._vertices[e + 1],
                l = this._vertices[e - t],
                h = this._vertices[e - t + 1],
                u = a + .5 * (s - a),
                _ = i + .5 * (o - i),
                f = u + .5 * (r + .5 * (l - r) - u),
                c = _ + .5 * (n + .5 * (h - n) - _),
                m = r + .5 * (s - r),
                p = n + .5 * (o - n),
                d = l + .5 * (s - l),
                y = h + .5 * (o - h);

            this._globalDirty = !1, this._getAffineTransform(0, 0, 200, 200, f, c, m, p, d, y, this.global, this.globalTransformMatrix, !1);
          }, e.prototype._getGlobalTransformMatrix = function (t, a) {
            var i = 1e3;
            if (t < -i || i < t || a < -i || i < a) return this.globalTransformMatrix;
            var r = !1,
                n = 200,
                s = this._boneData,
                o = s.segmentX,
                l = s.segmentY,
                h = 2 * s.segmentX,
                u = this._dX,
                _ = this._dY,
                f = Math.floor((t + n) / u),
                c = Math.floor((a + n) / _),
                m = 0,
                p = f * u - n,
                d = c * _ - n,
                y = this._matrixCahce,
                g = e._helpMatrix;

            if (t < -n) {
              if (a < -n || a >= n) return this.globalTransformMatrix;
              if (m = 7 * (2 * (o * (l + 1) + 2 * o + l + c) + ((r = a > this._kX * (t + n) + d) ? 1 : 0)), this._matrixCahce[m] > 0) g.copyFromArray(y, m + 1);else {
                var v = c * (h + 2),
                    D = this._hullCache[4],
                    b = this._hullCache[5],
                    A = this._hullCache[2] - (l - c) * D,
                    T = this._hullCache[3] - (l - c) * b,
                    S = this._vertices;
                r ? this._getAffineTransform(-n, d + _, 800, _, S[v + h + 2], S[v + h + 3], A + D, T + b, S[v], S[v + 1], e._helpTransform, g, !0) : this._getAffineTransform(-i, d, 800, _, A, T, S[v], S[v + 1], A + D, T + b, e._helpTransform, g, !1), y[m] = 1, y[m + 1] = g.a, y[m + 2] = g.b, y[m + 3] = g.c, y[m + 4] = g.d, y[m + 5] = g.tx, y[m + 6] = g.ty;
              }
            } else if (t >= n) {
              if (a < -n || a >= n) return this.globalTransformMatrix;
              m = 7 * (2 * (o * (l + 1) + o + c) + ((r = a > this._kX * (t - i) + d) ? 1 : 0)), this._matrixCahce[m] > 0 ? g.copyFromArray(y, m + 1) : (v = (c + 1) * (h + 2) - 2, D = this._hullCache[4], b = this._hullCache[5], A = this._hullCache[0] + c * D, T = this._hullCache[1] + c * b, S = this._vertices, r ? this._getAffineTransform(i, d + _, 800, _, A + D, T + b, S[v + h + 2], S[v + h + 3], A, T, e._helpTransform, g, !0) : this._getAffineTransform(n, d, 800, _, S[v], S[v + 1], A, T, S[v + h + 2], S[v + h + 3], e._helpTransform, g, !1), y[m] = 1, y[m + 1] = g.a, y[m + 2] = g.b, y[m + 3] = g.c, y[m + 4] = g.d, y[m + 5] = g.tx, y[m + 6] = g.ty);
            } else if (a < -n) {
              if (t < -n || t >= n) return this.globalTransformMatrix;
              m = 7 * (o * (l + 1) + 2 * f + ((r = a > this._kY * (t - p - u) - i) ? 1 : 0)), this._matrixCahce[m] > 0 ? g.copyFromArray(y, m + 1) : (v = 2 * f, D = this._hullCache[10], b = this._hullCache[11], A = this._hullCache[8] + f * D, T = this._hullCache[9] + f * b, S = this._vertices, r ? this._getAffineTransform(p + u, -n, u, 800, S[v + 2], S[v + 3], S[v], S[v + 1], A + D, T + b, e._helpTransform, g, !0) : this._getAffineTransform(p, -i, u, 800, A, T, A + D, T + b, S[v], S[v + 1], e._helpTransform, g, !1), y[m] = 1, y[m + 1] = g.a, y[m + 2] = g.b, y[m + 3] = g.c, y[m + 4] = g.d, y[m + 5] = g.tx, y[m + 6] = g.ty);
            } else if (a >= n) {
              if (t < -n || t >= n) return this.globalTransformMatrix;
              m = 7 * (2 * (o * (l + 1) + o + l + c) + ((r = a > this._kY * (t - p - u) + n) ? 1 : 0)), this._matrixCahce[m] > 0 ? g.copyFromArray(y, m + 1) : (v = l * (h + 2) + 2 * f, D = this._hullCache[10], b = this._hullCache[11], A = this._hullCache[6] - (o - f) * D, T = this._hullCache[7] - (o - f) * b, S = this._vertices, r ? this._getAffineTransform(p + u, i, u, 800, A + D, T + b, A, T, S[v + 2], S[v + 3], e._helpTransform, g, !0) : this._getAffineTransform(p, n, u, 800, S[v], S[v + 1], S[v + 2], S[v + 3], A, T, e._helpTransform, g, !1), y[m] = 1, y[m + 1] = g.a, y[m + 2] = g.b, y[m + 3] = g.c, y[m + 4] = g.d, y[m + 5] = g.tx, y[m + 6] = g.ty);
            } else m = 7 * (2 * (o * c + f) + ((r = a > this._k * (t - p - u) + d) ? 1 : 0)), this._matrixCahce[m] > 0 ? g.copyFromArray(y, m + 1) : (v = 2 * f + c * (h + 2), S = this._vertices, r ? this._getAffineTransform(p + u, d + _, u, _, S[v + h + 4], S[v + h + 5], S[v + h + 2], S[v + h + 3], S[v + 2], S[v + 3], e._helpTransform, g, !0) : this._getAffineTransform(p, d, u, _, S[v], S[v + 1], S[v + 2], S[v + 3], S[v + h + 2], S[v + h + 3], e._helpTransform, g, !1), y[m] = 1, y[m + 1] = g.a, y[m + 2] = g.b, y[m + 3] = g.c, y[m + 4] = g.d, y[m + 5] = g.tx, y[m + 6] = g.ty);

            return g;
          }, e.prototype.init = function (e, a) {
            if (null === this._boneData) {
              t.prototype.init.call(this, e, a);
              var i = e.segmentX,
                  r = e.segmentY,
                  n = e.vertices.length;
              this._dX = 400 / i, this._dY = 400 / r, this._k = -this._dY / this._dX, this._kX = -this._dY / 800, this._kY = -800 / this._dX, this._vertices.length = n, this._deformVertices.length = n, this._matrixCahce.length = 14 * (i * r + 2 * i + 2 * r), this._hullCache.length = 10;

              for (var s = 0; s < n; ++s) {
                this._deformVertices[s] = 0;
              }
            }
          }, e.prototype.update = function (t) {
            if (this._blendState.dirty = !1, t >= 0 && null !== this._cachedFrameIndices) {
              var a = this._cachedFrameIndices[t];
              if (a >= 0 && this._cachedFrameIndex === a) this._transformDirty = !1;else if (a >= 0) this._transformDirty = !0, this._cachedFrameIndex = a;else {
                if (this._hasConstraint) for (var i = 0, r = this._armature._constraints; i < r.length; i++) {
                  (o = r[i])._root === this && o.update();
                }
                this._transformDirty || null !== this._parent && this._parent._childrenTransformDirty ? (this._transformDirty = !0, this._cachedFrameIndex = -1) : this._cachedFrameIndex >= 0 ? (this._transformDirty = !1, this._cachedFrameIndices[t] = this._cachedFrameIndex) : (this._transformDirty = !0, this._cachedFrameIndex = -1);
              }
            } else {
              if (this._hasConstraint) for (var n = 0, s = this._armature._constraints; n < s.length; n++) {
                var o;
                (o = s[n])._root === this && o.update();
              }
              (this._transformDirty || null !== this._parent && this._parent._childrenTransformDirty) && (t = -1, this._transformDirty = !0, this._cachedFrameIndex = -1);
            }

            if (this._transformDirty) {
              this._transformDirty = !1, this._childrenTransformDirty = !0;

              for (var l = 0, h = this._matrixCahce.length; l < h; l += 7) {
                this._matrixCahce[l] = -1;
              }

              if (this._updateVertices(), this._cachedFrameIndex < 0) {
                var u = t >= 0;
                this._localDirty && this._updateGlobalTransformMatrix(u), u && null !== this._cachedFrameIndices && (this._cachedFrameIndex = this._cachedFrameIndices[t] = this._armature._armatureData.setCacheFrame(this.globalTransformMatrix, this.global));
              } else this._armature._armatureData.getCacheFrame(this.globalTransformMatrix, this.global, this._cachedFrameIndex);

              var _ = 2 * this.global.x,
                  f = 2 * this.global.y,
                  c = e._helpPoint;

              this.globalTransformMatrix.transformPoint(1e3, -200, c), this._hullCache[0] = c.x, this._hullCache[1] = c.y, this._hullCache[2] = _ - c.x, this._hullCache[3] = f - c.y, this.globalTransformMatrix.transformPoint(0, this._dY, c, !0), this._hullCache[4] = c.x, this._hullCache[5] = c.y, this.globalTransformMatrix.transformPoint(200, 1e3, c), this._hullCache[6] = c.x, this._hullCache[7] = c.y, this._hullCache[8] = _ - c.x, this._hullCache[9] = f - c.y, this.globalTransformMatrix.transformPoint(this._dX, 0, c, !0), this._hullCache[10] = c.x, this._hullCache[11] = c.y;
            } else this._childrenTransformDirty && (this._childrenTransformDirty = !1);

            this._localDirty = !0;
          }, e;
        }(t.Bone);

        t.Surface = e;
      }(K || (K = {})), function (t) {
        var e = function (e) {
          function a() {
            var a = null !== e && e.apply(this, arguments) || this;
            return a._localMatrix = new t.Matrix(), a._colorTransform = new t.ColorTransform(), a._displayDatas = [], a._displayList = [], a._deformVertices = null, a._rawDisplay = null, a._meshDisplay = null, a;
          }

          return W(a, e), a.prototype._onClear = function () {
            e.prototype._onClear.call(this);

            for (var a = [], i = 0, r = this._displayList; i < r.length; i++) {
              null !== (o = r[i]) && o !== this._rawDisplay && o !== this._meshDisplay && a.indexOf(o) < 0 && a.push(o);
            }

            for (var n = 0, s = a; n < s.length; n++) {
              var o;
              (o = s[n]) instanceof t.Armature ? o.dispose() : this._disposeDisplay(o, !0);
            }

            null !== this._deformVertices && this._deformVertices.returnToPool(), null !== this._meshDisplay && this._meshDisplay !== this._rawDisplay && this._disposeDisplay(this._meshDisplay, !1), null !== this._rawDisplay && this._disposeDisplay(this._rawDisplay, !1), this.displayController = null, this._displayDirty = !1, this._zOrderDirty = !1, this._blendModeDirty = !1, this._colorDirty = !1, this._transformDirty = !1, this._visible = !0, this._blendMode = 0, this._displayIndex = -1, this._animationDisplayIndex = -1, this._zOrder = 0, this._cachedFrameIndex = -1, this._pivotX = 0, this._pivotY = 0, this._localMatrix.identity(), this._colorTransform.identity(), this._displayList.length = 0, this._displayDatas.length = 0, this._slotData = null, this._rawDisplayDatas = null, this._displayData = null, this._boundingBoxData = null, this._textureData = null, this._deformVertices = null, this._rawDisplay = null, this._meshDisplay = null, this._display = null, this._childArmature = null, this._parent = null, this._cachedFrameIndices = null;
          }, a.prototype._getDefaultRawDisplayData = function (t) {
            var e = this._armature._armatureData.defaultSkin;

            if (null !== e) {
              var a = e.getDisplays(this._slotData.name);
              if (null !== a) return t < a.length ? a[t] : null;
            }

            return null;
          }, a.prototype._updateDisplayData = function () {
            var e = this._displayData,
                i = null !== this._deformVertices ? this._deformVertices.verticesData : null,
                r = this._textureData,
                n = null,
                s = null;

            if (this._displayData = null, this._boundingBoxData = null, this._textureData = null, this._displayIndex >= 0 && (null !== this._rawDisplayDatas && (n = this._displayIndex < this._rawDisplayDatas.length ? this._rawDisplayDatas[this._displayIndex] : null), null === n && (n = this._getDefaultRawDisplayData(this._displayIndex)), this._displayIndex < this._displayDatas.length && (this._displayData = this._displayDatas[this._displayIndex])), null !== this._displayData && (2 === this._displayData.type || 4 === this._displayData.type ? s = this._displayData.vertices : null !== n && (2 === n.type || 4 === n.type) && (s = n.vertices), 3 === this._displayData.type ? this._boundingBoxData = this._displayData.boundingBox : null !== n && 3 === n.type && (this._boundingBoxData = n.boundingBox), (0 === this._displayData.type || 2 === this._displayData.type) && (this._textureData = this._displayData.texture)), this._displayData !== e || s !== i || this._textureData !== r) {
              if (null === s && null !== this._textureData) {
                var o = this._displayData,
                    l = this._textureData.parent.scale * this._armature._armatureData.scale,
                    h = this._textureData.frame;
                this._pivotX = o.pivot.x, this._pivotY = o.pivot.y;
                var u = null !== h ? h : this._textureData.region,
                    _ = u.width,
                    f = u.height;
                this._textureData.rotated && null === h && (_ = u.height, f = u.width), this._pivotX *= _ * l, this._pivotY *= f * l, null !== h && (this._pivotX += h.x * l, this._pivotY += h.y * l), null !== this._displayData && null !== n && this._displayData !== n && (n.transform.toMatrix(a._helpMatrix), a._helpMatrix.invert(), a._helpMatrix.transformPoint(0, 0, a._helpPoint), this._pivotX -= a._helpPoint.x, this._pivotY -= a._helpPoint.y, this._displayData.transform.toMatrix(a._helpMatrix), a._helpMatrix.invert(), a._helpMatrix.transformPoint(0, 0, a._helpPoint), this._pivotX += a._helpPoint.x, this._pivotY += a._helpPoint.y), t.DragonBones.yDown || (this._pivotY = (this._textureData.rotated ? this._textureData.region.width : this._textureData.region.height) * l - this._pivotY);
              } else this._pivotX = 0, this._pivotY = 0;

              null !== n ? this.origin = n.transform : null !== this._displayData ? this.origin = this._displayData.transform : this.origin = null, s !== i ? (null === this._deformVertices && (this._deformVertices = t.BaseObject.borrowObject(t.DeformVertices)), this._deformVertices.init(s, this._armature)) : null !== this._deformVertices && this._textureData !== r && (this._deformVertices.verticesDirty = !0), this._displayDirty = !0, this._transformDirty = !0;
            }
          }, a.prototype._updateDisplay = function () {
            var e = null !== this._display ? this._display : this._rawDisplay,
                a = this._childArmature;
            this._displayIndex >= 0 && this._displayIndex < this._displayList.length ? (this._display = this._displayList[this._displayIndex], null !== this._display && this._display instanceof t.Armature ? (this._childArmature = this._display, this._display = this._childArmature.display) : this._childArmature = null) : (this._display = null, this._childArmature = null);
            var i = null !== this._display ? this._display : this._rawDisplay;

            if (i !== e && (this._onUpdateDisplay(), this._replaceDisplay(e), this._transformDirty = !0, this._visibleDirty = !0, this._blendModeDirty = !0, this._colorDirty = !0), i !== this._rawDisplay && i !== this._meshDisplay || this._updateFrame(), this._childArmature !== a && (null !== a && (a._parent = null, a.clock = null, a.inheritAnimation && a.animation.reset()), null !== this._childArmature && (this._childArmature._parent = this, this._childArmature.clock = this._armature.clock, this._childArmature.inheritAnimation))) {
              if (0 === this._childArmature.cacheFrameRate) {
                var r = this._armature.cacheFrameRate;
                0 !== r && (this._childArmature.cacheFrameRate = r);
              }

              var n = null;
              if (null !== this._displayData && 1 === this._displayData.type) n = this._displayData.actions;else if (this._displayIndex >= 0 && null !== this._rawDisplayDatas) {
                var s = this._displayIndex < this._rawDisplayDatas.length ? this._rawDisplayDatas[this._displayIndex] : null;
                null === s && (s = this._getDefaultRawDisplayData(this._displayIndex)), null !== s && 1 === s.type && (n = s.actions);
              }
              if (null !== n && n.length > 0) for (var o = 0, l = n; o < l.length; o++) {
                var h = l[o],
                    u = t.BaseObject.borrowObject(t.EventObject);
                t.EventObject.actionDataToInstance(h, u, this._armature), u.slot = this, this._armature._bufferAction(u, !1);
              } else this._childArmature.animation.play();
            }
          }, a.prototype._updateGlobalTransformMatrix = function (t) {
            var e = 0 === this._parent._boneData.type ? this._parent.globalTransformMatrix : this._parent._getGlobalTransformMatrix(this.global.x, this.global.y);
            this.globalTransformMatrix.copyFrom(this._localMatrix), this.globalTransformMatrix.concat(e), t ? this.global.fromMatrix(this.globalTransformMatrix) : this._globalDirty = !0;
          }, a.prototype._setDisplayIndex = function (t, e) {
            if (void 0 === e && (e = !1), e) {
              if (this._animationDisplayIndex === t) return !1;
              this._animationDisplayIndex = t;
            }

            return this._displayIndex !== t && (this._displayIndex = t, this._displayDirty = !0, this._updateDisplayData(), this._displayDirty);
          }, a.prototype._setZorder = function (t) {
            return this._zOrder, this._zOrder = t, this._zOrderDirty = !0, this._zOrderDirty;
          }, a.prototype._setColor = function (t) {
            return this._colorTransform.copyFrom(t), this._colorDirty = !0, this._colorDirty;
          }, a.prototype._setDisplayList = function (e) {
            if (null !== e && e.length > 0) {
              this._displayList.length !== e.length && (this._displayList.length = e.length);

              for (var a = 0, i = e.length; a < i; ++a) {
                var r = e[a];
                null !== r && r !== this._rawDisplay && r !== this._meshDisplay && !(r instanceof t.Armature) && this._displayList.indexOf(r) < 0 && this._initDisplay(r, !0), this._displayList[a] = r;
              }
            } else this._displayList.length > 0 && (this._displayList.length = 0);

            return this._displayIndex >= 0 && this._displayIndex < this._displayList.length ? this._displayDirty = this._display !== this._displayList[this._displayIndex] : this._displayDirty = null !== this._display, this._updateDisplayData(), this._displayDirty;
          }, a.prototype.init = function (t, e, a, i) {
            if (null === this._slotData) {
              this._slotData = t, this._isFromCache = !1, this._visibleDirty = !0, this._blendModeDirty = !0, this._colorDirty = !0, this._blendMode = this._slotData.blendMode, this._zOrder = this._slotData.zOrder, this._colorTransform.copyFrom(this._slotData.color), this._rawDisplay = a, this._meshDisplay = i, this._armature = e;

              var r = this._armature.getBone(this._slotData.parent.name);

              null !== r && (this._parent = r), this._armature._addSlot(this), this._initDisplay(this._rawDisplay, !1), this._rawDisplay !== this._meshDisplay && this._initDisplay(this._meshDisplay, !1), this._onUpdateDisplay(), this._addDisplay();
            }
          }, a.prototype.update = function (t) {
            if (this._isFromCache = !1, this._displayDirty && (this._displayDirty = !1, this._updateDisplay(), this._transformDirty && (null !== this.origin ? this.global.copyFrom(this.origin).add(this.offset).toMatrix(this._localMatrix) : this.global.copyFrom(this.offset).toMatrix(this._localMatrix))), this._zOrderDirty && (this._zOrderDirty = !1, this._updateZOrder()), t >= 0 && null !== this._cachedFrameIndices) {
              var e = this._cachedFrameIndices[t];
              e >= 0 && this._cachedFrameIndex === e ? this._transformDirty = !1 : e >= 0 ? (this._transformDirty = !0, this._cachedFrameIndex = e) : this._transformDirty || this._parent._childrenTransformDirty ? (this._transformDirty = !0, this._cachedFrameIndex = -1) : this._cachedFrameIndex >= 0 ? (this._transformDirty = !1, this._cachedFrameIndices[t] = this._cachedFrameIndex) : (this._transformDirty = !0, this._cachedFrameIndex = -1);
            } else (this._transformDirty || this._parent._childrenTransformDirty) && (t = -1, this._transformDirty = !0, this._cachedFrameIndex = -1);

            if (null !== this._display) {
              if (this._visibleDirty && (this._visibleDirty = !1, this._updateVisible()), this._blendModeDirty && (this._blendModeDirty = !1, this._updateBlendMode()), this._colorDirty && (this._colorDirty = !1, this._updateColor()), null !== this._deformVertices && null !== this._deformVertices.verticesData && this._display === this._meshDisplay) {
                var a = null !== this._deformVertices.verticesData.weight,
                    i = 0 !== this._parent._boneData.type;
                if ((this._deformVertices.verticesDirty || a && this._deformVertices.isBonesUpdate() || i && this._parent._childrenTransformDirty) && (this._deformVertices.verticesDirty = !1, this._updateMesh()), a || i) return;
              }

              if (this._transformDirty) {
                if (this._transformDirty = !1, this._cachedFrameIndex < 0) {
                  var r = t >= 0;
                  this._updateGlobalTransformMatrix(r), r && null !== this._cachedFrameIndices && (this._cachedFrameIndex = this._cachedFrameIndices[t] = this._armature._armatureData.setCacheFrame(this.globalTransformMatrix, this.global));
                } else this._isFromCache = !0, this._armature._armatureData.getCacheFrame(this.globalTransformMatrix, this.global, this._cachedFrameIndex);

                this._updateTransform();
              }
            }
          }, a.prototype.updateTransformAndMatrix = function () {
            this._transformDirty && (this._transformDirty = !1, this._updateGlobalTransformMatrix(!1));
          }, a.prototype.replaceDisplayData = function (t, e) {
            if (void 0 === e && (e = -1), e < 0 && (e = this._displayIndex < 0 ? 0 : this._displayIndex), this._displayDatas.length <= e) {
              this._displayDatas.length = e + 1;

              for (var a = 0, i = this._displayDatas.length; a < i; ++a) {
                this._displayDatas[a] || (this._displayDatas[a] = null);
              }
            }

            this._displayDatas[e] = t;
          }, a.prototype.containsPoint = function (t, e) {
            return null !== this._boundingBoxData && (this.updateTransformAndMatrix(), a._helpMatrix.copyFrom(this.globalTransformMatrix), a._helpMatrix.invert(), a._helpMatrix.transformPoint(t, e, a._helpPoint), this._boundingBoxData.containsPoint(a._helpPoint.x, a._helpPoint.y));
          }, a.prototype.intersectsSegment = function (t, e, i, r, n, s, o) {
            if (void 0 === n && (n = null), void 0 === s && (s = null), void 0 === o && (o = null), null === this._boundingBoxData) return 0;
            this.updateTransformAndMatrix(), a._helpMatrix.copyFrom(this.globalTransformMatrix), a._helpMatrix.invert(), a._helpMatrix.transformPoint(t, e, a._helpPoint), t = a._helpPoint.x, e = a._helpPoint.y, a._helpMatrix.transformPoint(i, r, a._helpPoint), i = a._helpPoint.x, r = a._helpPoint.y;

            var l = this._boundingBoxData.intersectsSegment(t, e, i, r, n, s, o);

            return l > 0 && (1 === l || 2 === l ? null !== n ? (this.globalTransformMatrix.transformPoint(n.x, n.y, n), null !== s && (s.x = n.x, s.y = n.y)) : null !== s && this.globalTransformMatrix.transformPoint(s.x, s.y, s) : (null !== n && this.globalTransformMatrix.transformPoint(n.x, n.y, n), null !== s && this.globalTransformMatrix.transformPoint(s.x, s.y, s)), null !== o && (this.globalTransformMatrix.transformPoint(Math.cos(o.x), Math.sin(o.x), a._helpPoint, !0), o.x = Math.atan2(a._helpPoint.y, a._helpPoint.x), this.globalTransformMatrix.transformPoint(Math.cos(o.y), Math.sin(o.y), a._helpPoint, !0), o.y = Math.atan2(a._helpPoint.y, a._helpPoint.x))), l;
          }, a.prototype.invalidUpdate = function () {
            this._displayDirty = !0, this._transformDirty = !0;
          }, Object.defineProperty(a.prototype, "visible", {
            get: function get() {
              return this._visible;
            },
            set: function set(t) {
              this._visible !== t && (this._visible = t, this._updateVisible());
            },
            enumerable: !0,
            configurable: !0
          }), Object.defineProperty(a.prototype, "displayIndex", {
            get: function get() {
              return this._displayIndex;
            },
            set: function set(t) {
              this._setDisplayIndex(t) && this.update(-1);
            },
            enumerable: !0,
            configurable: !0
          }), Object.defineProperty(a.prototype, "name", {
            get: function get() {
              return this._slotData.name;
            },
            enumerable: !0,
            configurable: !0
          }), Object.defineProperty(a.prototype, "displayList", {
            get: function get() {
              return this._displayList.concat();
            },
            set: function set(e) {
              var a = this._displayList.concat(),
                  i = new Array();

              this._setDisplayList(e) && this.update(-1);

              for (var r = 0, n = a; r < n.length; r++) {
                null !== (l = n[r]) && l !== this._rawDisplay && l !== this._meshDisplay && this._displayList.indexOf(l) < 0 && i.indexOf(l) < 0 && i.push(l);
              }

              for (var s = 0, o = i; s < o.length; s++) {
                var l;
                (l = o[s]) instanceof t.Armature || this._disposeDisplay(l, !0);
              }
            },
            enumerable: !0,
            configurable: !0
          }), Object.defineProperty(a.prototype, "slotData", {
            get: function get() {
              return this._slotData;
            },
            enumerable: !0,
            configurable: !0
          }), Object.defineProperty(a.prototype, "rawDisplayDatas", {
            get: function get() {
              return this._rawDisplayDatas;
            },
            set: function set(t) {
              if (this._rawDisplayDatas !== t) if (this._displayDirty = !0, this._rawDisplayDatas = t, null !== this._rawDisplayDatas) {
                this._displayDatas.length = this._rawDisplayDatas.length;

                for (var e = 0, a = this._displayDatas.length; e < a; ++e) {
                  var i = this._rawDisplayDatas[e];
                  null === i && (i = this._getDefaultRawDisplayData(e)), this._displayDatas[e] = i;
                }
              } else this._displayDatas.length = 0;
            },
            enumerable: !0,
            configurable: !0
          }), Object.defineProperty(a.prototype, "displayData", {
            get: function get() {
              return this._displayData;
            },
            enumerable: !0,
            configurable: !0
          }), Object.defineProperty(a.prototype, "boundingBoxData", {
            get: function get() {
              return this._boundingBoxData;
            },
            enumerable: !0,
            configurable: !0
          }), Object.defineProperty(a.prototype, "rawDisplay", {
            get: function get() {
              return this._rawDisplay;
            },
            enumerable: !0,
            configurable: !0
          }), Object.defineProperty(a.prototype, "meshDisplay", {
            get: function get() {
              return this._meshDisplay;
            },
            enumerable: !0,
            configurable: !0
          }), Object.defineProperty(a.prototype, "display", {
            get: function get() {
              return this._display;
            },
            set: function set(t) {
              if (this._display !== t) {
                var e = this._displayList.length;

                if (this._displayIndex < 0 && 0 === e && (this._displayIndex = 0), !(this._displayIndex < 0)) {
                  var a = this.displayList;
                  e <= this._displayIndex && (a.length = this._displayIndex + 1), a[this._displayIndex] = t, this.displayList = a;
                }
              }
            },
            enumerable: !0,
            configurable: !0
          }), Object.defineProperty(a.prototype, "childArmature", {
            get: function get() {
              return this._childArmature;
            },
            set: function set(t) {
              this._childArmature !== t && (this.display = t);
            },
            enumerable: !0,
            configurable: !0
          }), Object.defineProperty(a.prototype, "parent", {
            get: function get() {
              return this._parent;
            },
            enumerable: !0,
            configurable: !0
          }), a.prototype.getDisplay = function () {
            return this._display;
          }, a.prototype.setDisplay = function (t) {
            this.display = t;
          }, a;
        }(t.TransformObject);

        t.Slot = e;
      }(K || (K = {})), function (t) {
        var e = function (e) {
          function a() {
            return null !== e && e.apply(this, arguments) || this;
          }

          return W(a, e), a.prototype._onClear = function () {
            this._armature = null, this._target = null, this._root = null, this._bone = null;
          }, Object.defineProperty(a.prototype, "name", {
            get: function get() {
              return this._constraintData.name;
            },
            enumerable: !0,
            configurable: !0
          }), a._helpMatrix = new t.Matrix(), a._helpTransform = new t.Transform(), a._helpPoint = new t.Point(), a;
        }(t.BaseObject);

        t.Constraint = e;

        var a = function (e) {
          function a() {
            return null !== e && e.apply(this, arguments) || this;
          }

          return W(a, e), a.toString = function () {
            return "[class dragonBones.IKConstraint]";
          }, a.prototype._onClear = function () {
            e.prototype._onClear.call(this), this._scaleEnabled = !1, this._bendPositive = !1, this._weight = 1, this._constraintData = null;
          }, a.prototype._computeA = function () {
            var e = this._target.global,
                a = this._root.global,
                i = this._root.globalTransformMatrix,
                r = Math.atan2(e.y - a.y, e.x - a.x);
            a.scaleX < 0 && (r += Math.PI), a.rotation += t.Transform.normalizeRadian(r - a.rotation) * this._weight, a.toMatrix(i);
          }, a.prototype._computeB = function () {
            var e = this._bone._boneData.length,
                a = this._root,
                i = this._target.global,
                r = a.global,
                n = this._bone.global,
                s = this._bone.globalTransformMatrix,
                o = s.a * e,
                l = s.b * e,
                h = o * o + l * l,
                u = Math.sqrt(h),
                _ = n.x - r.x,
                f = n.y - r.y,
                c = _ * _ + f * f,
                m = Math.sqrt(c),
                p = n.rotation,
                d = r.rotation,
                y = Math.atan2(f, _),
                g = (_ = i.x - r.x) * _ + (f = i.y - r.y) * f,
                v = Math.sqrt(g),
                D = 0;

            if (u + m <= v || v + u <= m || v + m <= u) D = Math.atan2(i.y - r.y, i.x - r.x), u + m <= v || m < u && (D += Math.PI);else {
              var b = (c - h + g) / (2 * g),
                  A = Math.sqrt(c - b * b * g) / v,
                  T = r.x + _ * b,
                  S = r.y + f * b,
                  x = -f * A,
                  P = _ * A,
                  O = !1,
                  C = a.parent;

              if (null !== C) {
                var M = C.globalTransformMatrix;
                O = M.a * M.d - M.b * M.c < 0;
              }

              O !== this._bendPositive ? (n.x = T - x, n.y = S - P) : (n.x = T + x, n.y = S + P), D = Math.atan2(n.y - r.y, n.x - r.x);
            }
            var B = t.Transform.normalizeRadian(D - y);
            r.rotation = d + B * this._weight, r.toMatrix(a.globalTransformMatrix);
            var I = y + B * this._weight;
            n.x = r.x + Math.cos(I) * m, n.y = r.y + Math.sin(I) * m;
            var E = Math.atan2(i.y - n.y, i.x - n.x);
            n.scaleX < 0 && (E += Math.PI), n.rotation = r.rotation + p - d + t.Transform.normalizeRadian(E - B - p) * this._weight, n.toMatrix(s);
          }, a.prototype.init = function (t, e) {
            if (null === this._constraintData) {
              this._constraintData = t, this._armature = e, this._target = this._armature.getBone(this._constraintData.target.name), this._root = this._armature.getBone(this._constraintData.root.name), this._bone = null !== this._constraintData.bone ? this._armature.getBone(this._constraintData.bone.name) : null;
              var a = this._constraintData;
              this._scaleEnabled = a.scaleEnabled, this._bendPositive = a.bendPositive, this._weight = a.weight, this._root._hasConstraint = !0;
            }
          }, a.prototype.update = function () {
            this._root.updateByConstraint(), null !== this._bone ? (this._bone.updateByConstraint(), this._computeB()) : this._computeA();
          }, a.prototype.invalidUpdate = function () {
            this._root.invalidUpdate(), null !== this._bone && this._bone.invalidUpdate();
          }, a;
        }(e);

        t.IKConstraint = a;

        var i = function (e) {
          function a() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t._bones = [], t._spaces = [], t._positions = [], t._curves = [], t._boneLengths = [], t._pathGlobalVertices = [], t._segments = [10], t;
          }

          return W(a, e), a.toString = function () {
            return "[class dragonBones.PathConstraint]";
          }, a.prototype._onClear = function () {
            e.prototype._onClear.call(this), this.dirty = !1, this.pathOffset = 0, this.position = 0, this.spacing = 0, this.rotateOffset = 0, this.rotateMix = 1, this.translateMix = 1, this._pathSlot = null, this._bones.length = 0, this._spaces.length = 0, this._positions.length = 0, this._curves.length = 0, this._boneLengths.length = 0, this._pathGlobalVertices.length = 0;
          }, a.prototype._updatePathVertices = function (t) {
            var e = this._armature,
                a = e.armatureData.parent,
                i = e.armatureData.scale,
                r = a.intArray,
                n = a.floatArray,
                s = t.offset,
                o = r[s + 0],
                l = r[s + 2];
            this._pathGlobalVertices.length = 2 * o;
            var h = t.weight;
            if (null !== h) for (var u = this._pathSlot._deformVertices.bones, _ = h.bones.length, f = h.offset, c = r[f + 1], m = f + 2 + _, p = (S = 0, 0); S < o; S++) {
              for (var d = 0, y = 0, g = 0, v = r[m++]; g < v; g++) {
                var D = u[r[m++]];

                if (null !== D) {
                  D.updateByConstraint(), T = D.globalTransformMatrix;
                  var b = n[c++];
                  P = n[c++] * i, O = n[c++] * i, d += (T.a * P + T.c * O + T.tx) * b, y += (T.b * P + T.d * O + T.ty) * b;
                }
              }

              this._pathGlobalVertices[p++] = d, this._pathGlobalVertices[p++] = y;
            } else {
              var A = this._pathSlot.parent;
              A.updateByConstraint();

              for (var T = A.globalTransformMatrix, S = 0, x = l; S < o; S += 2) {
                var P = n[x++] * i,
                    O = n[x++] * i,
                    C = T.a * P + T.c * O + T.tx,
                    M = T.b * P + T.d * O + T.ty;
                this._pathGlobalVertices[S] = C, this._pathGlobalVertices[S + 1] = M;
              }
            }
          }, a.prototype._computeVertices = function (t, e, a, i) {
            for (var r = a, n = t; r < e; r += 2) {
              i[r] = this._pathGlobalVertices[n++], i[r + 1] = this._pathGlobalVertices[n++];
            }
          }, a.prototype._computeBezierCurve = function (t, e, a, i, r) {
            var n = this._armature.armatureData.parent.intArray[t.vertices.offset + 0],
                s = this._positions,
                o = this._spaces,
                l = t.closed,
                h = Array(),
                u = 2 * n,
                _ = u / 6,
                f = -1,
                c = this.position;

            s.length = 3 * e + 2;
            var m = 0;

            if (t.constantSpeed) {
              l ? (u += 2, h.length = n, this._computeVertices(2, u - 4, 0, h), this._computeVertices(0, 2, u - 4, h), h[u - 2] = h[0], h[u - 1] = h[1]) : (_--, u -= 4, h.length = u, this._computeVertices(2, u, 0, h));
              var p = new Array(_);
              m = 0;

              for (var d, y, g, v, D, b, A, T, S = h[0], x = h[1], P = 0, O = 0, C = 0, M = 0, B = 0, I = 0, E = (Y = 0, 2); Y < _; Y++, E += 6) {
                P = h[E], O = h[E + 1], C = h[E + 2], M = h[E + 3], D = 2 * (d = .1875 * (S - 2 * P + C)) + (g = .09375 * (3 * (P - C) - S + (B = h[E + 4]))), b = 2 * (y = .1875 * (x - 2 * O + M)) + (v = .09375 * (3 * (O - M) - x + (I = h[E + 5]))), A = .75 * (P - S) + d + .16666667 * g, T = .75 * (O - x) + y + .16666667 * v, m += Math.sqrt(A * A + T * T), A += D, T += b, D += g, b += v, m += Math.sqrt(A * A + T * T), A += D, T += b, m += Math.sqrt(A * A + T * T), A += D + g, T += b + v, m += Math.sqrt(A * A + T * T), p[Y] = m, S = B, x = I;
              }

              if (i && (c *= m), r) for (Y = 0; Y < e; Y++) {
                o[Y] *= m;
              }

              for (var w = this._segments, F = 0, N = (Y = 0, X = 0, G = 0, 0); Y < e; Y++, X += 3) {
                var R = c += o[Y];
                if (l) (R %= m) < 0 && (R += m), G = 0;else {
                  if (R < 0) continue;
                  if (R > m) continue;
                }

                for (;; G++) {
                  var k = p[G];

                  if (!(R > k)) {
                    0 === G ? R /= k : R = (R - (U = p[G - 1])) / (k - U);
                    break;
                  }
                }

                if (G !== f) {
                  f = G;
                  var j = 6 * G;

                  for (S = h[j], x = h[j + 1], P = h[j + 2], O = h[j + 3], C = h[j + 4], M = h[j + 5], D = 2 * (d = .03 * (S - 2 * P + C)) + (g = .006 * (3 * (P - C) - S + (B = h[j + 6]))), b = 2 * (y = .03 * (x - 2 * O + M)) + (v = .006 * (3 * (O - M) - x + (I = h[j + 7]))), A = .3 * (P - S) + d + .16666667 * g, T = .3 * (O - x) + y + .16666667 * v, F = Math.sqrt(A * A + T * T), w[0] = F, j = 1; j < 8; j++) {
                    A += D, T += b, D += g, b += v, F += Math.sqrt(A * A + T * T), w[j] = F;
                  }

                  A += D, T += b, F += Math.sqrt(A * A + T * T), w[8] = F, A += D + g, T += b + v, F += Math.sqrt(A * A + T * T), w[9] = F, N = 0;
                }

                for (R *= F;; N++) {
                  var L = w[N];

                  if (!(R > L)) {
                    var U;
                    0 === N ? R /= L : R = N + (R - (U = w[N - 1])) / (L - U);
                    break;
                  }
                }

                this.addCurvePosition(.1 * R, S, x, P, O, C, M, B, I, s, X, a);
              }
            } else {
              var V = t.curveLengths;
              if (m = V[_ -= l ? 1 : 2], i && (c *= m), r) for (var Y = 0; Y < e; Y++) {
                o[Y] *= m;
              }
              h.length = 8;
              Y = 0;

              for (var X = 0, G = 0; Y < e; Y++, X += 3) {
                if (c += o[Y], l) (c %= m) < 0 && (c += m), G = 0;else {
                  if (c < 0) continue;
                  if (c > m) continue;
                }

                for (var H = 0;; G++) {
                  var z = V[G];

                  if (!(c > z)) {
                    if (0 === G) H = c / z;else {
                      var W = V[G - 1];
                      H = (c - W) / (z - W);
                    }
                    break;
                  }
                }

                G !== f && (f = G, l && G === _ ? (this._computeVertices(u - 4, 4, 0, h), this._computeVertices(0, 4, 4, h)) : this._computeVertices(6 * G + 2, 8, 0, h)), this.addCurvePosition(H, h[0], h[1], h[2], h[3], h[4], h[5], h[6], h[7], s, X, a);
              }
            }
          }, a.prototype.addCurvePosition = function (t, e, a, i, r, n, s, o, l, h, u, _) {
            if (0 === t) return h[u] = e, h[u + 1] = a, void (h[u + 2] = 0);
            if (1 === t) return h[u] = o, h[u + 1] = l, void (h[u + 2] = 0);
            var f = 1 - t,
                c = f * f,
                m = t * t,
                p = c * f,
                d = c * t * 3,
                y = f * m * 3,
                g = t * m,
                v = p * e + d * i + y * n + g * o,
                D = p * a + d * r + y * s + g * l;
            h[u] = v, h[u + 1] = D, h[u + 2] = _ ? Math.atan2(D - (p * a + d * r + y * s), v - (p * e + d * i + y * n)) : 0;
          }, a.prototype.init = function (t, e) {
            this._constraintData = t, this._armature = e;
            var a = t;
            this.pathOffset = a.pathDisplayData.vertices.offset, this.position = a.position, this.spacing = a.spacing, this.rotateOffset = a.rotateOffset, this.rotateMix = a.rotateMix, this.translateMix = a.translateMix, this._root = this._armature.getBone(a.root.name), this._target = this._armature.getBone(a.target.name), this._pathSlot = this._armature.getSlot(a.pathSlot.name);

            for (var i = 0, r = a.bones.length; i < r; i++) {
              var n = this._armature.getBone(a.bones[i].name);

              null !== n && this._bones.push(n);
            }

            2 === a.rotateMode && (this._boneLengths.length = this._bones.length), this._root._hasConstraint = !0;
          }, a.prototype.update = function () {
            var e = this._pathSlot;

            if (null !== e._deformVertices && null !== e._deformVertices.verticesData && e._deformVertices.verticesData.offset === this.pathOffset) {
              var a = this._constraintData,
                  i = e._displayData,
                  r = !1,
                  n = e._deformVertices;

              if (this._root._childrenTransformDirty ? (this._updatePathVertices(i.vertices), r = !0) : null !== n && (n.verticesDirty || n.isBonesUpdate()) && (this._updatePathVertices(i.vertices), n.verticesDirty = !1, r = !0), r || this.dirty) {
                var s = a.positionMode,
                    o = a.spacingMode,
                    l = a.rotateMode,
                    h = this._bones,
                    u = 0 === o,
                    _ = 2 === l,
                    f = 0 === l,
                    c = h.length,
                    m = f ? c : c + 1,
                    p = this.spacing,
                    d = this._spaces;

                if (d.length = m, _ || u) {
                  d[0] = 0;

                  for (var y = 0, g = m - 1; y < g; y++) {
                    (I = h[y]).updateByConstraint();
                    var v = I._boneData.length,
                        D = v * (E = I.globalTransformMatrix).a,
                        b = v * E.b,
                        A = Math.sqrt(D * D + b * b);
                    _ && (this._boneLengths[y] = A), d[y + 1] = (v + p) * A / v;
                  }
                } else for (y = 0; y < m; y++) {
                  d[y] = p;
                }

                this._computeBezierCurve(i, m, f, 1 === s, 2 === o);

                var T,
                    S = this._positions,
                    x = this.rotateOffset,
                    P = S[0],
                    O = S[1];
                0 === x ? T = 1 === l : (T = !1, null !== (I = e.parent) && (x *= (E = I.globalTransformMatrix).a * E.d - E.b * E.c > 0 ? t.Transform.DEG_RAD : -t.Transform.DEG_RAD));

                for (var C = this.rotateMix, M = this.translateMix, B = (y = 0, 3); y < c; y++, B += 3) {
                  var I, E;
                  (I = h[y]).updateByConstraint(), (E = I.globalTransformMatrix).tx += (P - E.tx) * M, E.ty += (O - E.ty) * M;
                  var w = (D = S[B]) - P,
                      F = (b = S[B + 1]) - O;

                  if (_) {
                    var N = this._boneLengths[y],
                        R = (Math.sqrt(w * w + F * F) / N - 1) * C + 1;
                    E.a *= R, E.b *= R;
                  }

                  if (P = D, O = b, C > 0) {
                    var k = E.a,
                        j = E.b,
                        L = E.c,
                        U = E.d,
                        V = void 0,
                        Y = void 0,
                        X = void 0;

                    if (V = f ? S[B - 1] : Math.atan2(F, w), V -= Math.atan2(j, k), T) {
                      Y = Math.cos(V), X = Math.sin(V);
                      var G = I._boneData.length;
                      P += (G * (Y * k - X * j) - w) * C, O += (G * (X * k + Y * j) - F) * C;
                    } else V += x;

                    V > t.Transform.PI ? V -= t.Transform.PI_D : V < -t.Transform.PI && (V += t.Transform.PI_D), V *= C, Y = Math.cos(V), X = Math.sin(V), E.a = Y * k - X * j, E.b = X * k + Y * j, E.c = Y * L - X * U, E.d = X * L + Y * U;
                  }

                  I.global.fromMatrix(E);
                }

                this.dirty = !1;
              }
            }
          }, a.prototype.invalidUpdate = function () {}, a;
        }(e);

        t.PathConstraint = i;
      }(K || (K = {})), function (t) {
        var e = function () {
          function t(t) {
            void 0 === t && (t = 0), this.time = 0, this.timeScale = 1, this._systemTime = 0, this._animatebles = [], this._clock = null, this.time = t, this._systemTime = .001 * new Date().getTime();
          }

          return t.prototype.advanceTime = function (t) {
            t != t && (t = 0);
            var e = .001 * Date.now();

            if (t < 0 && (t = e - this._systemTime), this._systemTime = e, 1 !== this.timeScale && (t *= this.timeScale), 0 !== t) {
              t < 0 ? this.time -= t : this.time += t;

              for (var a = 0, i = 0, r = this._animatebles.length; a < r; ++a) {
                var n = this._animatebles[a];
                null !== n ? (i > 0 && (this._animatebles[a - i] = n, this._animatebles[a] = null), n.advanceTime(t)) : i++;
              }

              if (i > 0) {
                for (r = this._animatebles.length; a < r; ++a) {
                  var s = this._animatebles[a];
                  null !== s ? this._animatebles[a - i] = s : i++;
                }

                this._animatebles.length -= i;
              }
            }
          }, t.prototype.contains = function (t) {
            if (t === this) return !1;

            for (var e = t; e !== this && null !== e;) {
              e = e.clock;
            }

            return e === this;
          }, t.prototype.add = function (t) {
            this._animatebles.indexOf(t) < 0 && (this._animatebles.push(t), t.clock = this);
          }, t.prototype.remove = function (t) {
            var e = this._animatebles.indexOf(t);

            e >= 0 && (this._animatebles[e] = null, t.clock = null);
          }, t.prototype.clear = function () {
            for (var t = 0, e = this._animatebles; t < e.length; t++) {
              var a = e[t];
              null !== a && (a.clock = null);
            }
          }, Object.defineProperty(t.prototype, "clock", {
            get: function get() {
              return this._clock;
            },
            set: function set(t) {
              this._clock !== t && (null !== this._clock && this._clock.remove(this), this._clock = t, null !== this._clock && this._clock.add(this));
            },
            enumerable: !0,
            configurable: !0
          }), t.clock = new t(), t;
        }();

        t.WorldClock = e;
      }(K || (K = {})), function (t) {
        var e = function (e) {
          function a() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t._animationNames = [], t._animationStates = [], t._animations = {}, t._animationConfig = null, t;
          }

          return W(a, e), a.toString = function () {
            return "[class dragonBones.Animation]";
          }, a.prototype._onClear = function () {
            for (var t = 0, e = this._animationStates; t < e.length; t++) {
              e[t].returnToPool();
            }

            for (var a in this._animations) {
              delete this._animations[a];
            }

            null !== this._animationConfig && this._animationConfig.returnToPool(), this.timeScale = 1, this._lockUpdate = !1, this._animationDirty = !1, this._inheritTimeScale = 1, this._animationNames.length = 0, this._animationStates.length = 0, this._armature = null, this._animationConfig = null, this._lastAnimationState = null;
          }, a.prototype._fadeOut = function (t) {
            switch (t.fadeOutMode) {
              case 1:
                for (var e = 0, a = this._animationStates; e < a.length; e++) {
                  null === (h = a[e])._parent && h.layer === t.layer && h.fadeOut(t.fadeOutTime, t.pauseFadeOut);
                }

                break;

              case 2:
                for (var i = 0, r = this._animationStates; i < r.length; i++) {
                  null === (h = r[i])._parent && h.group === t.group && h.fadeOut(t.fadeOutTime, t.pauseFadeOut);
                }

                break;

              case 3:
                for (var n = 0, s = this._animationStates; n < s.length; n++) {
                  null === (h = s[n])._parent && h.layer === t.layer && h.group === t.group && h.fadeOut(t.fadeOutTime, t.pauseFadeOut);
                }

                break;

              case 4:
                for (var o = 0, l = this._animationStates; o < l.length; o++) {
                  var h;
                  null === (h = l[o])._parent && h.fadeOut(t.fadeOutTime, t.pauseFadeOut);
                }

            }
          }, a.prototype.init = function (e) {
            null === this._armature && (this._armature = e, this._animationConfig = t.BaseObject.borrowObject(t.AnimationConfig));
          }, a.prototype.advanceTime = function (t) {
            t < 0 && (t = -t), this._armature.inheritAnimation && null !== this._armature._parent ? this._inheritTimeScale = this._armature._parent._armature.animation._inheritTimeScale * this.timeScale : this._inheritTimeScale = this.timeScale, 1 !== this._inheritTimeScale && (t *= this._inheritTimeScale);
            var e = this._animationStates.length;
            if (1 === e) {
              if ((m = this._animationStates[0])._fadeState > 0 && m._subFadeState > 0) this._armature._dragonBones.bufferObject(m), this._animationStates.length = 0, this._lastAnimationState = null;else {
                var a = m._animationData,
                    i = a.cacheFrameRate;

                if (this._animationDirty && i > 0) {
                  this._animationDirty = !1;

                  for (var r = 0, n = this._armature.getBones(); r < n.length; r++) {
                    var s = n[r];
                    s._cachedFrameIndices = a.getBoneCachedFrameIndices(s.name);
                  }

                  for (var o = 0, l = this._armature.getSlots(); o < l.length; o++) {
                    var h = l[o],
                        u = h.rawDisplayDatas;

                    if (null !== u && u.length > 0) {
                      var _ = u[0];

                      if (null !== _ && _.parent === this._armature.armatureData.defaultSkin) {
                        h._cachedFrameIndices = a.getSlotCachedFrameIndices(h.name);
                        continue;
                      }
                    }

                    h._cachedFrameIndices = null;
                  }
                }

                m.advanceTime(t, i);
              }
            } else if (e > 1) {
              for (var f = 0, c = 0; f < e; ++f) {
                var m;
                (m = this._animationStates[f])._fadeState > 0 && m._subFadeState > 0 ? (c++, this._armature._dragonBones.bufferObject(m), this._animationDirty = !0, this._lastAnimationState === m && (this._lastAnimationState = null)) : (c > 0 && (this._animationStates[f - c] = m), m.advanceTime(t, 0)), f === e - 1 && c > 0 && (this._animationStates.length -= c, null === this._lastAnimationState && this._animationStates.length > 0 && (this._lastAnimationState = this._animationStates[this._animationStates.length - 1]));
              }

              this._armature._cacheFrameIndex = -1;
            } else this._armature._cacheFrameIndex = -1;
          }, a.prototype.reset = function () {
            for (var t = 0, e = this._animationStates; t < e.length; t++) {
              e[t].returnToPool();
            }

            this._animationDirty = !1, this._animationConfig.clear(), this._animationStates.length = 0, this._lastAnimationState = null;
          }, a.prototype.stop = function (t) {
            if (void 0 === t && (t = null), null !== t) null !== (i = this.getState(t)) && i.stop();else for (var e = 0, a = this._animationStates; e < a.length; e++) {
              var i;
              (i = a[e]).stop();
            }
          }, a.prototype.playConfig = function (e) {
            var a = e.animation;
            if (!(a in this._animations)) return console.warn("Non-existent animation.\n", "DragonBones name: " + this._armature.armatureData.parent.name, "Armature name: " + this._armature.name, "Animation name: " + a), null;
            var i = this._animations[a];
            if (5 === e.fadeOutMode) for (var r = 0, n = this._animationStates; r < n.length; r++) {
              var s = n[r];
              if (s._animationData === i) return s;
            }
            0 === this._animationStates.length ? e.fadeInTime = 0 : e.fadeInTime < 0 && (e.fadeInTime = i.fadeInTime), e.fadeOutTime < 0 && (e.fadeOutTime = e.fadeInTime), e.timeScale <= -100 && (e.timeScale = 1 / i.scale), i.frameCount > 1 ? (e.position < 0 ? (e.position %= i.duration, e.position = i.duration - e.position) : e.position === i.duration ? e.position -= 1e-6 : e.position > i.duration && (e.position %= i.duration), e.duration > 0 && e.position + e.duration > i.duration && (e.duration = i.duration - e.position), e.playTimes < 0 && (e.playTimes = i.playTimes)) : (e.playTimes = 1, e.position = 0, e.duration > 0 && (e.duration = 0)), 0 === e.duration && (e.duration = -1), this._fadeOut(e);
            var o = t.BaseObject.borrowObject(t.AnimationState);

            if (o.init(this._armature, i, e), this._animationDirty = !0, this._armature._cacheFrameIndex = -1, this._animationStates.length > 0) {
              for (var l = !1, h = 0, u = this._animationStates.length; h < u; ++h) {
                if (o.layer > this._animationStates[h].layer) {
                  l = !0, this._animationStates.splice(h, 0, o);
                  break;
                }

                if (h !== u - 1 && o.layer > this._animationStates[h + 1].layer) {
                  l = !0, this._animationStates.splice(h + 1, 0, o);
                  break;
                }
              }

              l || this._animationStates.push(o);
            } else this._animationStates.push(o);

            for (var _ = 0, f = this._armature.getSlots(); _ < f.length; _++) {
              var c = f[_].childArmature;
              null !== c && c.inheritAnimation && c.animation.hasAnimation(a) && null === c.animation.getState(a) && c.animation.fadeIn(a);
            }

            var m = !1;

            for (var p in i.animationTimelines) {
              this._lockUpdate || (m = !0, this._lockUpdate = !0);
              var d = this.fadeIn(p, e.fadeInTime, 1, o.layer, null, 0);
              null !== d && (d.resetToPose = !1, d._parent = o, d.stop());
            }

            return m && (this._lockUpdate = !1), this._lockUpdate || (e.fadeInTime <= 0 && this._armature.advanceTime(0), this._lastAnimationState = o), o;
          }, a.prototype.play = function (t, e) {
            if (void 0 === t && (t = null), void 0 === e && (e = -1), this._animationConfig.clear(), this._animationConfig.resetToPose = !0, this._animationConfig.playTimes = e, this._animationConfig.fadeInTime = 0, this._animationConfig.animation = null !== t ? t : "", null !== t && t.length > 0) this.playConfig(this._animationConfig);else if (null === this._lastAnimationState) {
              var a = this._armature.armatureData.defaultAnimation;
              null !== a && (this._animationConfig.animation = a.name, this.playConfig(this._animationConfig));
            } else this._lastAnimationState.isPlaying || this._lastAnimationState.isCompleted ? (this._animationConfig.animation = this._lastAnimationState.name, this.playConfig(this._animationConfig)) : this._lastAnimationState.play();
            return this._lastAnimationState;
          }, a.prototype.fadeIn = function (t, e, a, i, r, n) {
            return void 0 === e && (e = -1), void 0 === a && (a = -1), void 0 === i && (i = 0), void 0 === r && (r = null), void 0 === n && (n = 3), this._animationConfig.clear(), this._animationConfig.fadeOutMode = n, this._animationConfig.playTimes = a, this._animationConfig.layer = i, this._animationConfig.fadeInTime = e, this._animationConfig.animation = t, this._animationConfig.group = null !== r ? r : "", this.playConfig(this._animationConfig);
          }, a.prototype.gotoAndPlayByTime = function (t, e, a) {
            return void 0 === e && (e = 0), void 0 === a && (a = -1), this._animationConfig.clear(), this._animationConfig.resetToPose = !0, this._animationConfig.playTimes = a, this._animationConfig.position = e, this._animationConfig.fadeInTime = 0, this._animationConfig.animation = t, this.playConfig(this._animationConfig);
          }, a.prototype.gotoAndPlayByFrame = function (t, e, a) {
            void 0 === e && (e = 0), void 0 === a && (a = -1), this._animationConfig.clear(), this._animationConfig.resetToPose = !0, this._animationConfig.playTimes = a, this._animationConfig.fadeInTime = 0, this._animationConfig.animation = t;
            var i = t in this._animations ? this._animations[t] : null;
            return null !== i && (this._animationConfig.position = i.duration * e / i.frameCount), this.playConfig(this._animationConfig);
          }, a.prototype.gotoAndPlayByProgress = function (t, e, a) {
            void 0 === e && (e = 0), void 0 === a && (a = -1), this._animationConfig.clear(), this._animationConfig.resetToPose = !0, this._animationConfig.playTimes = a, this._animationConfig.fadeInTime = 0, this._animationConfig.animation = t;
            var i = t in this._animations ? this._animations[t] : null;
            return null !== i && (this._animationConfig.position = i.duration * (e > 0 ? e : 0)), this.playConfig(this._animationConfig);
          }, a.prototype.gotoAndStopByTime = function (t, e) {
            void 0 === e && (e = 0);
            var a = this.gotoAndPlayByTime(t, e, 1);
            return null !== a && a.stop(), a;
          }, a.prototype.gotoAndStopByFrame = function (t, e) {
            void 0 === e && (e = 0);
            var a = this.gotoAndPlayByFrame(t, e, 1);
            return null !== a && a.stop(), a;
          }, a.prototype.gotoAndStopByProgress = function (t, e) {
            void 0 === e && (e = 0);
            var a = this.gotoAndPlayByProgress(t, e, 1);
            return null !== a && a.stop(), a;
          }, a.prototype.getState = function (t) {
            for (var e = this._animationStates.length; e--;) {
              var a = this._animationStates[e];
              if (a.name === t) return a;
            }

            return null;
          }, a.prototype.hasAnimation = function (t) {
            return t in this._animations;
          }, a.prototype.getStates = function () {
            return this._animationStates;
          }, Object.defineProperty(a.prototype, "isPlaying", {
            get: function get() {
              for (var t = 0, e = this._animationStates; t < e.length; t++) {
                if (e[t].isPlaying) return !0;
              }

              return !1;
            },
            enumerable: !0,
            configurable: !0
          }), Object.defineProperty(a.prototype, "isCompleted", {
            get: function get() {
              for (var t = 0, e = this._animationStates; t < e.length; t++) {
                if (!e[t].isCompleted) return !1;
              }

              return this._animationStates.length > 0;
            },
            enumerable: !0,
            configurable: !0
          }), Object.defineProperty(a.prototype, "lastAnimationName", {
            get: function get() {
              return null !== this._lastAnimationState ? this._lastAnimationState.name : "";
            },
            enumerable: !0,
            configurable: !0
          }), Object.defineProperty(a.prototype, "animationNames", {
            get: function get() {
              return this._animationNames;
            },
            enumerable: !0,
            configurable: !0
          }), Object.defineProperty(a.prototype, "animations", {
            get: function get() {
              return this._animations;
            },
            set: function set(t) {
              if (this._animations !== t) {
                for (var e in this._animationNames.length = 0, this._animations) {
                  delete this._animations[e];
                }

                for (var e in t) {
                  this._animationNames.push(e), this._animations[e] = t[e];
                }
              }
            },
            enumerable: !0,
            configurable: !0
          }), Object.defineProperty(a.prototype, "animationConfig", {
            get: function get() {
              return this._animationConfig.clear(), this._animationConfig;
            },
            enumerable: !0,
            configurable: !0
          }), Object.defineProperty(a.prototype, "lastAnimationState", {
            get: function get() {
              return this._lastAnimationState;
            },
            enumerable: !0,
            configurable: !0
          }), a.prototype.gotoAndPlay = function (t, e, a, i, r, n, s) {
            void 0 === e && (e = -1), void 0 === a && (a = -1), void 0 === i && (i = -1), void 0 === r && (r = 0), void 0 === n && (n = null), void 0 === s && (s = 3), console.warn("Deprecated."), this._animationConfig.clear(), this._animationConfig.resetToPose = !0, this._animationConfig.fadeOutMode = s, this._animationConfig.playTimes = i, this._animationConfig.layer = r, this._animationConfig.fadeInTime = e, this._animationConfig.animation = t, this._animationConfig.group = null !== n ? n : "";
            var o = this._animations[t];
            return o && a > 0 && (this._animationConfig.timeScale = o.duration / a), this.playConfig(this._animationConfig);
          }, a.prototype.gotoAndStop = function (t, e) {
            return void 0 === e && (e = 0), console.warn("Deprecated."), this.gotoAndStopByTime(t, e);
          }, Object.defineProperty(a.prototype, "animationList", {
            get: function get() {
              return console.warn("Deprecated."), this._animationNames;
            },
            enumerable: !0,
            configurable: !0
          }), Object.defineProperty(a.prototype, "animationDataList", {
            get: function get() {
              console.warn("Deprecated.");

              for (var t = [], e = 0, a = this._animationNames.length; e < a; ++e) {
                t.push(this._animations[this._animationNames[e]]);
              }

              return t;
            },
            enumerable: !0,
            configurable: !0
          }), a;
        }(t.BaseObject);

        t.Animation = e;
      }(K || (K = {})), function (t) {
        var e = function (e) {
          function r() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t._blendState = new i(), t._boneMask = [], t._boneTimelines = [], t._surfaceTimelines = [], t._slotTimelines = [], t._constraintTimelines = [], t._animationTimelines = [], t._poseTimelines = [], t._bonePoses = {}, t._actionTimeline = null, t._zOrderTimeline = null, t._parent = null, t;
          }

          return W(r, e), r.toString = function () {
            return "[class dragonBones.AnimationState]";
          }, r.prototype._onClear = function () {
            for (var t = 0, e = this._boneTimelines; t < e.length; t++) {
              e[t].returnToPool();
            }

            for (var a = 0, i = this._surfaceTimelines; a < i.length; a++) {
              i[a].returnToPool();
            }

            for (var r = 0, n = this._slotTimelines; r < n.length; r++) {
              n[r].returnToPool();
            }

            for (var s = 0, o = this._constraintTimelines; s < o.length; s++) {
              o[s].returnToPool();
            }

            for (var l = 0, h = this._animationTimelines; l < h.length; l++) {
              h[l].returnToPool();
            }

            for (var u in this._bonePoses) {
              this._bonePoses[u].returnToPool(), delete this._bonePoses[u];
            }

            null !== this._actionTimeline && this._actionTimeline.returnToPool(), null !== this._zOrderTimeline && this._zOrderTimeline.returnToPool(), this.actionEnabled = !1, this.additiveBlending = !1, this.displayControl = !1, this.resetToPose = !1, this.playTimes = 1, this.layer = 0, this.timeScale = 1, this.weight = 1, this.autoFadeOutTime = 0, this.fadeTotalTime = 0, this.name = "", this.group = "", this._timelineDirty = 2, this._playheadState = 0, this._fadeState = -1, this._subFadeState = -1, this._position = 0, this._duration = 0, this._fadeTime = 0, this._time = 0, this._fadeProgress = 0, this._weightResult = 0, this._blendState.clear(), this._boneMask.length = 0, this._boneTimelines.length = 0, this._surfaceTimelines.length = 0, this._slotTimelines.length = 0, this._constraintTimelines.length = 0, this._animationTimelines.length = 0, this._poseTimelines.length = 0, this._animationData = null, this._armature = null, this._actionTimeline = null, this._zOrderTimeline = null, this._parent = null;
          }, r.prototype._updateTimelines = function () {
            for (var e = 0, a = this._armature._constraints; e < a.length; e++) {
              var i = a[e];
              if (null !== (l = this._animationData.getConstraintTimelines(i.name))) for (var r = 0, n = l; r < n.length; r++) {
                switch ((f = n[r]).type) {
                  case 30:
                    (c = t.BaseObject.borrowObject(t.IKConstraintTimelineState)).constraint = i, c.init(this._armature, this, f), this._constraintTimelines.push(c);
                }
              } else this.resetToPose && ((c = t.BaseObject.borrowObject(t.IKConstraintTimelineState)).constraint = i, c.init(this._armature, this, null), this._constraintTimelines.push(c), this._poseTimelines.push(c));
            }

            for (var s = 0, o = this._armature.animation.getStates(); s < o.length; s++) {
              var l,
                  h = o[s];
              if (h._parent === this && null !== (l = this._animationData.getAnimationTimelines(h.name))) for (var u = 0, _ = l; u < _.length; u++) {
                var f;

                switch ((f = _[u]).type) {
                  case 40:
                    var c;
                    (c = t.BaseObject.borrowObject(t.AnimationTimelineState)).animationState = h, c.init(this._armature, this, f), this._animationTimelines.push(c);
                }
              }
            }
          }, r.prototype._updateBoneAndSlotTimelines = function () {
            for (var e = {}, i = 0, r = this._boneTimelines; i < r.length; i++) {
              (l = (g = r[i]).bone.name) in e || (e[l] = []), e[l].push(g);
            }

            for (var n = 0, s = this._armature.getBones(); n < s.length; n++) {
              var o = s[n],
                  l = o.name;
              if (this.containsBoneMask(l)) if (l in e) delete e[l];else if (0 === o._boneData.type) {
                var h = this._animationData.getBoneTimelines(l),
                    u = l in this._bonePoses ? this._bonePoses[l] : this._bonePoses[l] = t.BaseObject.borrowObject(a);

                if (null !== h) for (var _ = 0, f = h; _ < f.length; _++) {
                  switch ((I = f[_]).type) {
                    case 10:
                      (g = t.BaseObject.borrowObject(t.BoneAllTimelineState)).bone = o, g.bonePose = u, g.init(this._armature, this, I), this._boneTimelines.push(g);
                      break;

                    case 11:
                      (g = t.BaseObject.borrowObject(t.BoneTranslateTimelineState)).bone = o, g.bonePose = u, g.init(this._armature, this, I), this._boneTimelines.push(g);
                      break;

                    case 12:
                      (g = t.BaseObject.borrowObject(t.BoneRotateTimelineState)).bone = o, g.bonePose = u, g.init(this._armature, this, I), this._boneTimelines.push(g);
                      break;

                    case 13:
                      (g = t.BaseObject.borrowObject(t.BoneScaleTimelineState)).bone = o, g.bonePose = u, g.init(this._armature, this, I), this._boneTimelines.push(g);
                  }
                } else this.resetToPose && ((g = t.BaseObject.borrowObject(t.BoneAllTimelineState)).bone = o, g.bonePose = u, g.init(this._armature, this, null), this._boneTimelines.push(g), this._poseTimelines.push(g));
              } else if (1 === o._boneData.type) if (null !== (h = this._animationData.getSurfaceTimelines(l))) for (var c = 0, m = h; c < m.length; c++) {
                switch ((I = m[c]).type) {
                  case 50:
                    (g = t.BaseObject.borrowObject(t.SurfaceTimelineState)).surface = o, g.init(this._armature, this, I), this._surfaceTimelines.push(g);
                }
              } else this.resetToPose && ((g = t.BaseObject.borrowObject(t.SurfaceTimelineState)).surface = o, g.init(this._armature, this, null), this._surfaceTimelines.push(g), this._poseTimelines.push(g));
            }

            for (var p in e) {
              for (var d = 0, y = e[p]; d < y.length; d++) {
                var g = y[d];
                this._boneTimelines.splice(this._boneTimelines.indexOf(g), 1), g.returnToPool();
              }
            }

            for (var v = {}, D = [], b = 0, A = this._slotTimelines; b < A.length; b++) {
              (l = (g = A[b]).slot.name) in v || (v[l] = []), v[l].push(g);
            }

            for (var T = 0, S = this._armature.getSlots(); T < S.length; T++) {
              var x = S[T],
                  P = x.parent.name;
              if (this.containsBoneMask(P)) if (l = x.name, h = this._animationData.getSlotTimelines(l), l in v) delete v[l];else {
                var O = !1,
                    C = !1;
                if (D.length = 0, null !== h) for (var M = 0, B = h; M < B.length; M++) {
                  var I;

                  switch ((I = B[M]).type) {
                    case 20:
                      (g = t.BaseObject.borrowObject(t.SlotDislayTimelineState)).slot = x, g.init(this._armature, this, I), this._slotTimelines.push(g), O = !0;
                      break;

                    case 21:
                      (g = t.BaseObject.borrowObject(t.SlotColorTimelineState)).slot = x, g.init(this._armature, this, I), this._slotTimelines.push(g), C = !0;
                      break;

                    case 22:
                      (g = t.BaseObject.borrowObject(t.DeformTimelineState)).slot = x, g.init(this._armature, this, I), this._slotTimelines.push(g), D.push(g.vertexOffset);
                  }
                }
                if (this.resetToPose && (O || ((g = t.BaseObject.borrowObject(t.SlotDislayTimelineState)).slot = x, g.init(this._armature, this, null), this._slotTimelines.push(g), this._poseTimelines.push(g)), C || ((g = t.BaseObject.borrowObject(t.SlotColorTimelineState)).slot = x, g.init(this._armature, this, null), this._slotTimelines.push(g), this._poseTimelines.push(g)), null !== x.rawDisplayDatas)) for (var E = 0, w = x.rawDisplayDatas; E < w.length; E++) {
                  var F = w[E];

                  if (null !== F && 2 === F.type) {
                    var N = F.vertices.offset;
                    D.indexOf(N) < 0 && ((g = t.BaseObject.borrowObject(t.DeformTimelineState)).vertexOffset = N, g.slot = x, g.init(this._armature, this, null), this._slotTimelines.push(g), this._poseTimelines.push(g));
                  }
                }
              }
            }

            for (var p in v) {
              for (var R = 0, k = v[p]; R < k.length; R++) {
                g = k[R], this._slotTimelines.splice(this._slotTimelines.indexOf(g), 1), g.returnToPool();
              }
            }
          }, r.prototype._advanceFadeTime = function (e) {
            var a,
                i = this._fadeState > 0;

            if (this._subFadeState < 0) {
              this._subFadeState = 0;
              var r = i ? t.EventObject.FADE_OUT : t.EventObject.FADE_IN;
              this._armature.eventDispatcher.hasDBEventListener(r) && ((a = t.BaseObject.borrowObject(t.EventObject)).type = r, a.armature = this._armature, a.animationState = this, this._armature._dragonBones.bufferEvent(a));
            }

            (e < 0 && (e = -e), this._fadeTime += e, this._fadeTime >= this.fadeTotalTime ? (this._subFadeState = 1, this._fadeProgress = i ? 0 : 1) : this._fadeTime > 0 ? this._fadeProgress = i ? 1 - this._fadeTime / this.fadeTotalTime : this._fadeTime / this.fadeTotalTime : this._fadeProgress = i ? 1 : 0, this._subFadeState > 0) && (i || (this._playheadState |= 1, this._fadeState = 0), r = i ? t.EventObject.FADE_OUT_COMPLETE : t.EventObject.FADE_IN_COMPLETE, this._armature.eventDispatcher.hasDBEventListener(r) && ((a = t.BaseObject.borrowObject(t.EventObject)).type = r, a.armature = this._armature, a.animationState = this, this._armature._dragonBones.bufferEvent(a)));
          }, r.prototype.init = function (e, a, i) {
            if (null === this._armature) {
              if (this._armature = e, this._animationData = a, this.resetToPose = i.resetToPose, this.additiveBlending = i.additiveBlending, this.displayControl = i.displayControl, this.actionEnabled = i.actionEnabled, this.layer = i.layer, this.playTimes = i.playTimes, this.timeScale = i.timeScale, this.fadeTotalTime = i.fadeInTime, this.autoFadeOutTime = i.autoFadeOutTime, this.weight = i.weight, this.name = i.name.length > 0 ? i.name : i.animation, this.group = i.group, i.pauseFadeIn ? this._playheadState = 2 : this._playheadState = 3, i.duration < 0 ? (this._position = 0, this._duration = this._animationData.duration, 0 !== i.position ? this.timeScale >= 0 ? this._time = i.position : this._time = i.position - this._duration : this._time = 0) : (this._position = i.position, this._duration = i.duration, this._time = 0), this.timeScale < 0 && 0 === this._time && (this._time = -1e-6), this.fadeTotalTime <= 0 && (this._fadeProgress = .999999), i.boneMask.length > 0) {
                this._boneMask.length = i.boneMask.length;

                for (var r = 0, n = this._boneMask.length; r < n; ++r) {
                  this._boneMask[r] = i.boneMask[r];
                }
              }

              this._actionTimeline = t.BaseObject.borrowObject(t.ActionTimelineState), this._actionTimeline.init(this._armature, this, this._animationData.actionTimeline), this._actionTimeline.currentTime = this._time, this._actionTimeline.currentTime < 0 && (this._actionTimeline.currentTime = this._duration - this._actionTimeline.currentTime), null !== this._animationData.zOrderTimeline && (this._zOrderTimeline = t.BaseObject.borrowObject(t.ZOrderTimelineState), this._zOrderTimeline.init(this._armature, this, this._animationData.zOrderTimeline));
            }
          }, r.prototype.advanceTime = function (e, a) {
            if (this._blendState.dirty = !1, 0 === this._fadeState && 0 === this._subFadeState || this._advanceFadeTime(e), 3 === this._playheadState && (1 !== this.timeScale && (e *= this.timeScale), this._time += e), 0 !== this._timelineDirty && (2 === this._timelineDirty && this._updateTimelines(), this._timelineDirty = 0, this._updateBoneAndSlotTimelines()), 0 !== this.weight) {
              var i = 0 === this._fadeState && a > 0,
                  r = !0,
                  n = !0,
                  s = this._time;

              if (this._weightResult = this.weight * this._fadeProgress, null !== this._parent && (this._weightResult *= this._parent._weightResult / this._parent._fadeProgress), this._actionTimeline.playState <= 0 && this._actionTimeline.update(s), i) {
                var o = 2 * a;
                this._actionTimeline.currentTime = Math.floor(this._actionTimeline.currentTime * o) / o;
              }

              if (null !== this._zOrderTimeline && this._zOrderTimeline.playState <= 0 && this._zOrderTimeline.update(s), i) {
                var l = Math.floor(this._actionTimeline.currentTime * a);
                this._armature._cacheFrameIndex === l ? (r = !1, n = !1) : (this._armature._cacheFrameIndex = l, this._animationData.cachedFrames[l] ? n = !1 : this._animationData.cachedFrames[l] = !0);
              }

              if (r) {
                if (n) for (var h = 0, u = this._boneTimelines.length; h < u; ++h) {
                  (p = this._boneTimelines[h]).playState <= 0 && p.update(s), (h === u - 1 || p.bone !== this._boneTimelines[h + 1].bone) && 0 !== (_ = p.bone._blendState.update(this._weightResult, this.layer)) && p.blend(_);
                }

                for (h = 0, u = this._surfaceTimelines.length; h < u; ++h) {
                  var _ = (p = this._surfaceTimelines[h]).surface._blendState.update(this._weightResult, this.layer);

                  p.playState <= 0 && p.update(s), 0 !== _ && p.blend(_);
                }

                if (this.displayControl) for (h = 0, u = this._slotTimelines.length; h < u; ++h) {
                  var f = (p = this._slotTimelines[h]).slot.displayController;
                  null !== f && f !== this.name && f !== this.group || p.playState <= 0 && p.update(s);
                }

                for (h = 0, u = this._constraintTimelines.length; h < u; ++h) {
                  (p = this._constraintTimelines[h]).playState <= 0 && p.update(s);
                }

                for (h = 0, u = this._animationTimelines.length; h < u; ++h) {
                  _ = (p = this._animationTimelines[h]).animationState._blendState.update(this._weightResult, this.layer), p.playState <= 0 && p.update(s), 0 !== _ && p.blend(_);
                }
              }

              if (0 === this._fadeState) {
                if (this._subFadeState > 0 && (this._subFadeState = 0, this._poseTimelines.length > 0)) {
                  for (var c = 0, m = this._poseTimelines; c < m.length; c++) {
                    var p;
                    (p = m[c]) instanceof t.BoneTimelineState ? this._boneTimelines.splice(this._boneTimelines.indexOf(p), 1) : p instanceof t.SurfaceTimelineState ? this._surfaceTimelines.splice(this._surfaceTimelines.indexOf(p), 1) : p instanceof t.SlotTimelineState ? this._slotTimelines.splice(this._slotTimelines.indexOf(p), 1) : p instanceof t.ConstraintTimelineState && this._constraintTimelines.splice(this._constraintTimelines.indexOf(p), 1), p.returnToPool();
                  }

                  this._poseTimelines.length = 0;
                }

                this._actionTimeline.playState > 0 && this.autoFadeOutTime >= 0 && this.fadeOut(this.autoFadeOutTime);
              }
            }
          }, r.prototype.play = function () {
            this._playheadState = 3;
          }, r.prototype.stop = function () {
            this._playheadState &= 1;
          }, r.prototype.fadeOut = function (t, e) {
            if (void 0 === e && (e = !0), t < 0 && (t = 0), e && (this._playheadState &= 2), this._fadeState > 0) {
              if (t > this.fadeTotalTime - this._fadeTime) return;
            } else {
              this._fadeState = 1, this._subFadeState = -1, (t <= 0 || this._fadeProgress <= 0) && (this._fadeProgress = 1e-6);

              for (var a = 0, i = this._boneTimelines; a < i.length; a++) {
                (f = i[a]).fadeOut();
              }

              for (var r = 0, n = this._surfaceTimelines; r < n.length; r++) {
                (f = n[r]).fadeOut();
              }

              for (var s = 0, o = this._slotTimelines; s < o.length; s++) {
                (f = o[s]).fadeOut();
              }

              for (var l = 0, h = this._constraintTimelines; l < h.length; l++) {
                (f = h[l]).fadeOut();
              }

              for (var u = 0, _ = this._animationTimelines; u < _.length; u++) {
                var f;
                (f = _[u]).animationState.fadeOut(t, e), f.fadeOut();
              }
            }

            this.displayControl = !1, this.fadeTotalTime = this._fadeProgress > 1e-6 ? t / this._fadeProgress : 0, this._fadeTime = this.fadeTotalTime * (1 - this._fadeProgress);
          }, r.prototype.containsBoneMask = function (t) {
            return 0 === this._boneMask.length || this._boneMask.indexOf(t) >= 0;
          }, r.prototype.addBoneMask = function (t, e) {
            void 0 === e && (e = !0);

            var a = this._armature.getBone(t);

            if (null !== a) {
              if (this._boneMask.indexOf(t) < 0 && this._boneMask.push(t), e) for (var i = 0, r = this._armature.getBones(); i < r.length; i++) {
                var n = r[i];
                this._boneMask.indexOf(n.name) < 0 && a.contains(n) && this._boneMask.push(n.name);
              }
              this._timelineDirty = 1;
            }
          }, r.prototype.removeBoneMask = function (t, e) {
            void 0 === e && (e = !0);

            var a = this._boneMask.indexOf(t);

            if (a >= 0 && this._boneMask.splice(a, 1), e) {
              var i = this._armature.getBone(t);

              if (null !== i) {
                var r = this._armature.getBones();

                if (this._boneMask.length > 0) for (var n = 0, s = r; n < s.length; n++) {
                  var o = s[n],
                      l = this._boneMask.indexOf(o.name);

                  l >= 0 && i.contains(o) && this._boneMask.splice(l, 1);
                } else for (var h = 0, u = r; h < u.length; h++) {
                  (o = u[h]) !== i && (i.contains(o) || this._boneMask.push(o.name));
                }
              }
            }

            this._timelineDirty = 1;
          }, r.prototype.removeAllBoneMask = function () {
            this._boneMask.length = 0, this._timelineDirty = 1;
          }, Object.defineProperty(r.prototype, "isFadeIn", {
            get: function get() {
              return this._fadeState < 0;
            },
            enumerable: !0,
            configurable: !0
          }), Object.defineProperty(r.prototype, "isFadeOut", {
            get: function get() {
              return this._fadeState > 0;
            },
            enumerable: !0,
            configurable: !0
          }), Object.defineProperty(r.prototype, "isFadeComplete", {
            get: function get() {
              return 0 === this._fadeState;
            },
            enumerable: !0,
            configurable: !0
          }), Object.defineProperty(r.prototype, "isPlaying", {
            get: function get() {
              return 0 != (2 & this._playheadState) && this._actionTimeline.playState <= 0;
            },
            enumerable: !0,
            configurable: !0
          }), Object.defineProperty(r.prototype, "isCompleted", {
            get: function get() {
              return this._actionTimeline.playState > 0;
            },
            enumerable: !0,
            configurable: !0
          }), Object.defineProperty(r.prototype, "currentPlayTimes", {
            get: function get() {
              return this._actionTimeline.currentPlayTimes;
            },
            enumerable: !0,
            configurable: !0
          }), Object.defineProperty(r.prototype, "totalTime", {
            get: function get() {
              return this._duration;
            },
            enumerable: !0,
            configurable: !0
          }), Object.defineProperty(r.prototype, "currentTime", {
            get: function get() {
              return this._actionTimeline.currentTime;
            },
            set: function set(t) {
              var e = this._actionTimeline.currentPlayTimes - (this._actionTimeline.playState > 0 ? 1 : 0);

              if ((t < 0 || this._duration < t) && (t = t % this._duration + e * this._duration) < 0 && (t += this._duration), this.playTimes > 0 && e === this.playTimes - 1 && t === this._duration && (t = this._duration - 1e-6), this._time !== t) {
                this._time = t, this._actionTimeline.setCurrentTime(this._time), null !== this._zOrderTimeline && (this._zOrderTimeline.playState = -1);

                for (var a = 0, i = this._boneTimelines; a < i.length; a++) {
                  i[a].playState = -1;
                }

                for (var r = 0, n = this._slotTimelines; r < n.length; r++) {
                  n[r].playState = -1;
                }
              }
            },
            enumerable: !0,
            configurable: !0
          }), Object.defineProperty(r.prototype, "animationData", {
            get: function get() {
              return this._animationData;
            },
            enumerable: !0,
            configurable: !0
          }), r;
        }(t.BaseObject);

        t.AnimationState = e;

        var a = function (e) {
          function a() {
            var a = null !== e && e.apply(this, arguments) || this;
            return a.current = new t.Transform(), a.delta = new t.Transform(), a.result = new t.Transform(), a;
          }

          return W(a, e), a.toString = function () {
            return "[class dragonBones.BonePose]";
          }, a.prototype._onClear = function () {
            this.current.identity(), this.delta.identity(), this.result.identity();
          }, a;
        }(t.BaseObject);

        t.BonePose = a;

        var i = function () {
          function t() {}

          return t.prototype.update = function (t, e) {
            if (this.dirty) {
              if (!(this.leftWeight > 0)) return 0;

              if (this.layer !== e) {
                if (this.layerWeight >= this.leftWeight) return this.leftWeight = 0, 0;
                this.layer = e, this.leftWeight -= this.layerWeight, this.layerWeight = 0;
              }

              return t *= this.leftWeight, this.layerWeight += t, this.blendWeight = t, 2;
            }

            return this.dirty = !0, this.layer = e, this.layerWeight = t, this.leftWeight = 1, this.blendWeight = t, 1;
          }, t.prototype.clear = function () {
            this.dirty = !1, this.layer = 0, this.leftWeight = 0, this.layerWeight = 0, this.blendWeight = 0;
          }, t;
        }();

        t.BlendState = i;
      }(K || (K = {})), function (t) {
        var e = function (t) {
          function e() {
            return null !== t && t.apply(this, arguments) || this;
          }

          return W(e, t), e.prototype._onClear = function () {
            this.playState = -1, this.currentPlayTimes = -1, this.currentTime = -1, this._tweenState = 0, this._frameRate = 0, this._frameValueOffset = 0, this._frameCount = 0, this._frameOffset = 0, this._frameIndex = -1, this._frameRateR = 0, this._position = 0, this._duration = 0, this._timeScale = 1, this._timeOffset = 0, this._dragonBonesData = null, this._animationData = null, this._timelineData = null, this._armature = null, this._animationState = null, this._actionTimeline = null, this._frameArray = null, this._frameIntArray = null, this._frameFloatArray = null, this._timelineArray = null, this._frameIndices = null;
          }, e.prototype._setCurrentTime = function (t) {
            var e = this.playState,
                a = this.currentPlayTimes,
                i = this.currentTime;
            if (null !== this._actionTimeline && this._frameCount <= 1) this.playState = this._actionTimeline.playState >= 0 ? 1 : -1, this.currentPlayTimes = 1, this.currentTime = this._actionTimeline.currentTime;else if (null === this._actionTimeline || 1 !== this._timeScale || 0 !== this._timeOffset) {
              var r = this._animationState.playTimes,
                  n = r * this._duration;
              t *= this._timeScale, 0 !== this._timeOffset && (t += this._timeOffset * this._animationData.duration), r > 0 && (t >= n || t <= -n) ? (this.playState <= 0 && 3 === this._animationState._playheadState && (this.playState = 1), this.currentPlayTimes = r, this.currentTime = t < 0 ? 0 : this._duration + 1e-6) : (0 !== this.playState && 3 === this._animationState._playheadState && (this.playState = 0), t < 0 ? (t = -t, this.currentPlayTimes = Math.floor(t / this._duration), this.currentTime = this._duration - t % this._duration) : (this.currentPlayTimes = Math.floor(t / this._duration), this.currentTime = t % this._duration)), this.currentTime += this._position;
            } else this.playState = this._actionTimeline.playState, this.currentPlayTimes = this._actionTimeline.currentPlayTimes, this.currentTime = this._actionTimeline.currentTime;
            return (this.currentPlayTimes !== a || this.currentTime !== i) && ((e < 0 && this.playState !== e || this.playState <= 0 && this.currentPlayTimes !== a) && (this._frameIndex = -1), !0);
          }, e.prototype.init = function (t, e, a) {
            this._armature = t, this._animationState = e, this._timelineData = a, this._actionTimeline = this._animationState._actionTimeline, this === this._actionTimeline && (this._actionTimeline = null), this._animationData = this._animationState._animationData, this._frameRate = this._animationData.parent.frameRate, this._frameRateR = 1 / this._frameRate, this._position = this._animationState._position, this._duration = this._animationState._duration, this._dragonBonesData = this._animationData.parent.parent, null !== this._timelineData && (this._frameIntArray = this._dragonBonesData.frameIntArray, this._frameFloatArray = this._dragonBonesData.frameFloatArray, this._frameArray = this._dragonBonesData.frameArray, this._timelineArray = this._dragonBonesData.timelineArray, this._frameIndices = this._dragonBonesData.frameIndices, this._frameCount = this._timelineArray[this._timelineData.offset + 2], this._frameValueOffset = this._timelineArray[this._timelineData.offset + 4], this._timeScale = 100 / this._timelineArray[this._timelineData.offset + 0], this._timeOffset = .01 * this._timelineArray[this._timelineData.offset + 1]);
          }, e.prototype.fadeOut = function () {}, e.prototype.update = function (t) {
            if (this._setCurrentTime(t)) {
              if (this._frameCount > 1) {
                var e = Math.floor(this.currentTime * this._frameRate),
                    a = this._frameIndices[this._timelineData.frameIndicesOffset + e];
                this._frameIndex !== a && (this._frameIndex = a, this._frameOffset = this._animationData.frameOffset + this._timelineArray[this._timelineData.offset + 5 + this._frameIndex], this._onArriveAtFrame());
              } else this._frameIndex < 0 && (this._frameIndex = 0, null !== this._timelineData && (this._frameOffset = this._animationData.frameOffset + this._timelineArray[this._timelineData.offset + 5]), this._onArriveAtFrame());

              0 !== this._tweenState && this._onUpdateFrame();
            }
          }, e;
        }(t.BaseObject);

        t.TimelineState = e;

        var a = function (t) {
          function e() {
            return null !== t && t.apply(this, arguments) || this;
          }

          return W(e, t), e._getEasingValue = function (t, e, a) {
            var i = e;

            switch (t) {
              case 3:
                i = Math.pow(e, 2);
                break;

              case 4:
                i = 1 - Math.pow(1 - e, 2);
                break;

              case 5:
                i = .5 * (1 - Math.cos(e * Math.PI));
            }

            return (i - e) * a + e;
          }, e._getEasingCurveValue = function (t, e, a, i) {
            if (t <= 0) return 0;
            if (t >= 1) return 1;
            var r = a + 1,
                n = Math.floor(t * r),
                s = 0 === n ? 0 : e[i + n - 1];
            return 1e-4 * (s + ((n === r - 1 ? 1e4 : e[i + n]) - s) * (t * r - n));
          }, e.prototype._onClear = function () {
            t.prototype._onClear.call(this), this._tweenType = 0, this._curveCount = 0, this._framePosition = 0, this._frameDurationR = 0, this._tweenProgress = 0, this._tweenEasing = 0;
          }, e.prototype._onArriveAtFrame = function () {
            if (this._frameCount > 1 && (this._frameIndex !== this._frameCount - 1 || 0 === this._animationState.playTimes || this._animationState.currentPlayTimes < this._animationState.playTimes - 1)) {
              if (this._tweenType = this._frameArray[this._frameOffset + 1], this._tweenState = 0 === this._tweenType ? 1 : 2, 2 === this._tweenType ? this._curveCount = this._frameArray[this._frameOffset + 2] : 0 !== this._tweenType && 1 !== this._tweenType && (this._tweenEasing = .01 * this._frameArray[this._frameOffset + 2]), this._framePosition = this._frameArray[this._frameOffset] * this._frameRateR, this._frameIndex === this._frameCount - 1) this._frameDurationR = 1 / (this._animationData.duration - this._framePosition);else {
                var t = this._animationData.frameOffset + this._timelineArray[this._timelineData.offset + 5 + this._frameIndex + 1],
                    e = this._frameArray[t] * this._frameRateR - this._framePosition;
                this._frameDurationR = e > 0 ? 1 / e : 0;
              }
            } else this._tweenState = 1;
          }, e.prototype._onUpdateFrame = function () {
            2 === this._tweenState ? (this._tweenProgress = (this.currentTime - this._framePosition) * this._frameDurationR, 2 === this._tweenType ? this._tweenProgress = e._getEasingCurveValue(this._tweenProgress, this._frameArray, this._curveCount, this._frameOffset + 3) : 1 !== this._tweenType && (this._tweenProgress = e._getEasingValue(this._tweenType, this._tweenProgress, this._tweenEasing))) : this._tweenProgress = 0;
          }, e;
        }(e);

        t.TweenTimelineState = a;

        var i = function (t) {
          function e() {
            return null !== t && t.apply(this, arguments) || this;
          }

          return W(e, t), e.prototype._onClear = function () {
            t.prototype._onClear.call(this), this.bone = null, this.bonePose = null;
          }, e.prototype.blend = function (t) {
            var e = this.bone._blendState.blendWeight,
                a = this.bone.animationPose,
                i = this.bonePose.result;
            2 === t ? (a.x += i.x * e, a.y += i.y * e, a.rotation += i.rotation * e, a.skew += i.skew * e, a.scaleX += (i.scaleX - 1) * e, a.scaleY += (i.scaleY - 1) * e) : 1 !== e ? (a.x = i.x * e, a.y = i.y * e, a.rotation = i.rotation * e, a.skew = i.skew * e, a.scaleX = (i.scaleX - 1) * e + 1, a.scaleY = (i.scaleY - 1) * e + 1) : (a.x = i.x, a.y = i.y, a.rotation = i.rotation, a.skew = i.skew, a.scaleX = i.scaleX, a.scaleY = i.scaleY), 0 === this._animationState._fadeState && 0 === this._animationState._subFadeState || (this.bone._transformDirty = !0);
          }, e;
        }(a);

        t.BoneTimelineState = i;

        var r = function (t) {
          function e() {
            return null !== t && t.apply(this, arguments) || this;
          }

          return W(e, t), e.prototype._onClear = function () {
            t.prototype._onClear.call(this), this.slot = null;
          }, e;
        }(a);

        t.SlotTimelineState = r;

        var n = function (t) {
          function e() {
            return null !== t && t.apply(this, arguments) || this;
          }

          return W(e, t), e.prototype._onClear = function () {
            t.prototype._onClear.call(this), this.constraint = null;
          }, e;
        }(a);

        t.ConstraintTimelineState = n;
      }(K || (K = {})), function (t) {
        var e = function (e) {
          function a() {
            return null !== e && e.apply(this, arguments) || this;
          }

          return W(a, e), a.toString = function () {
            return "[class dragonBones.ActionTimelineState]";
          }, a.prototype._onCrossFrame = function (e) {
            var a = this._armature.eventDispatcher;
            if (this._animationState.actionEnabled) for (var i = this._animationData.frameOffset + this._timelineArray[this._timelineData.offset + 5 + e], r = this._frameArray[i + 1], n = this._animationData.parent.actions, s = 0; s < r; ++s) {
              var o = n[this._frameArray[i + 2 + s]];
              if (0 === o.type) (l = t.BaseObject.borrowObject(t.EventObject)).time = this._frameArray[i] / this._frameRate, l.animationState = this._animationState, t.EventObject.actionDataToInstance(o, l, this._armature), this._armature._bufferAction(l, !0);else {
                var l,
                    h = 10 === o.type ? t.EventObject.FRAME_EVENT : t.EventObject.SOUND_EVENT;
                (11 === o.type || a.hasDBEventListener(h)) && ((l = t.BaseObject.borrowObject(t.EventObject)).time = this._frameArray[i] / this._frameRate, l.animationState = this._animationState, t.EventObject.actionDataToInstance(o, l, this._armature), this._armature._dragonBones.bufferEvent(l));
              }
            }
          }, a.prototype._onArriveAtFrame = function () {}, a.prototype._onUpdateFrame = function () {}, a.prototype.update = function (e) {
            var a = this.playState,
                i = this.currentPlayTimes,
                r = this.currentTime;

            if (this._setCurrentTime(e)) {
              var n = this._armature.eventDispatcher;

              if (a < 0) {
                if (this.playState === a) return;

                if (this._animationState.displayControl && this._animationState.resetToPose && this._armature._sortZOrder(null, 0), i = this.currentPlayTimes, n.hasDBEventListener(t.EventObject.START)) {
                  var s = t.BaseObject.borrowObject(t.EventObject);
                  s.type = t.EventObject.START, s.armature = this._armature, s.animationState = this._animationState, this._armature._dragonBones.bufferEvent(s);
                }
              }

              var o = this._animationState.timeScale < 0,
                  l = null,
                  h = null;

              if (this.currentPlayTimes !== i && (n.hasDBEventListener(t.EventObject.LOOP_COMPLETE) && ((l = t.BaseObject.borrowObject(t.EventObject)).type = t.EventObject.LOOP_COMPLETE, l.armature = this._armature, l.animationState = this._animationState), this.playState > 0 && n.hasDBEventListener(t.EventObject.COMPLETE) && ((h = t.BaseObject.borrowObject(t.EventObject)).type = t.EventObject.COMPLETE, h.armature = this._armature, h.animationState = this._animationState)), this._frameCount > 1) {
                var u = this._timelineData,
                    _ = Math.floor(this.currentTime * this._frameRate),
                    f = this._frameIndices[u.frameIndicesOffset + _];

                if (this._frameIndex !== f) {
                  var c = this._frameIndex;
                  if (this._frameIndex = f, null !== this._timelineArray) if (this._frameOffset = this._animationData.frameOffset + this._timelineArray[u.offset + 5 + this._frameIndex], o) {
                    if (c < 0) {
                      var m = Math.floor(r * this._frameRate);
                      c = this._frameIndices[u.frameIndicesOffset + m], this.currentPlayTimes === i && c === f && (c = -1);
                    }

                    for (; c >= 0;) {
                      var p = this._animationData.frameOffset + this._timelineArray[u.offset + 5 + c],
                          d = this._frameArray[p] / this._frameRate;
                      if (this._position <= d && d <= this._position + this._duration && this._onCrossFrame(c), null !== l && 0 === c && (this._armature._dragonBones.bufferEvent(l), l = null), c > 0 ? c-- : c = this._frameCount - 1, c === f) break;
                    }
                  } else for (c < 0 && (m = Math.floor(r * this._frameRate), c = this._frameIndices[u.frameIndicesOffset + m], p = this._animationData.frameOffset + this._timelineArray[u.offset + 5 + c], d = this._frameArray[p] / this._frameRate, this.currentPlayTimes === i && (r <= d ? c > 0 ? c-- : c = this._frameCount - 1 : c === f && (c = -1))); c >= 0 && (c < this._frameCount - 1 ? c++ : c = 0, p = this._animationData.frameOffset + this._timelineArray[u.offset + 5 + c], d = this._frameArray[p] / this._frameRate, this._position <= d && d <= this._position + this._duration && this._onCrossFrame(c), null !== l && 0 === c && (this._armature._dragonBones.bufferEvent(l), l = null), c !== f);) {
                    ;
                  }
                }
              } else this._frameIndex < 0 && (this._frameIndex = 0, null !== this._timelineData) && (this._frameOffset = this._animationData.frameOffset + this._timelineArray[this._timelineData.offset + 5], d = this._frameArray[this._frameOffset] / this._frameRate, this.currentPlayTimes === i ? r <= d && this._onCrossFrame(this._frameIndex) : this._position <= d && (o || null === l || (this._armature._dragonBones.bufferEvent(l), l = null), this._onCrossFrame(this._frameIndex)));

              null !== l && this._armature._dragonBones.bufferEvent(l), null !== h && this._armature._dragonBones.bufferEvent(h);
            }
          }, a.prototype.setCurrentTime = function (t) {
            this._setCurrentTime(t), this._frameIndex = -1;
          }, a;
        }(t.TimelineState);

        t.ActionTimelineState = e;

        var a = function (t) {
          function e() {
            return null !== t && t.apply(this, arguments) || this;
          }

          return W(e, t), e.toString = function () {
            return "[class dragonBones.ZOrderTimelineState]";
          }, e.prototype._onArriveAtFrame = function () {
            this.playState >= 0 && (this._frameArray[this._frameOffset + 1] > 0 ? this._armature._sortZOrder(this._frameArray, this._frameOffset + 2) : this._armature._sortZOrder(null, 0));
          }, e.prototype._onUpdateFrame = function () {}, e;
        }(t.TimelineState);

        t.ZOrderTimelineState = a;

        var i = function (e) {
          function a() {
            return null !== e && e.apply(this, arguments) || this;
          }

          return W(a, e), a.toString = function () {
            return "[class dragonBones.BoneAllTimelineState]";
          }, a.prototype._onArriveAtFrame = function () {
            if (e.prototype._onArriveAtFrame.call(this), null !== this._timelineData) {
              var t = this._animationData.frameFloatOffset + this._frameValueOffset + 6 * this._frameIndex,
                  a = this._armature._armatureData.scale,
                  i = this._frameFloatArray,
                  r = this.bonePose.current,
                  n = this.bonePose.delta;
              r.x = i[t++] * a, r.y = i[t++] * a, r.rotation = i[t++], r.skew = i[t++], r.scaleX = i[t++], r.scaleY = i[t++], 2 === this._tweenState ? (this._frameIndex === this._frameCount - 1 && (t = this._animationData.frameFloatOffset + this._frameValueOffset), n.x = i[t++] * a - r.x, n.y = i[t++] * a - r.y, n.rotation = i[t++] - r.rotation, n.skew = i[t++] - r.skew, n.scaleX = i[t++] - r.scaleX, n.scaleY = i[t++] - r.scaleY) : (n.x = 0, n.y = 0, n.rotation = 0, n.skew = 0, n.scaleX = 0, n.scaleY = 0);
            } else r = this.bonePose.current, n = this.bonePose.delta, r.x = 0, r.y = 0, r.rotation = 0, r.skew = 0, r.scaleX = 1, r.scaleY = 1, n.x = 0, n.y = 0, n.rotation = 0, n.skew = 0, n.scaleX = 0, n.scaleY = 0;
          }, a.prototype._onUpdateFrame = function () {
            e.prototype._onUpdateFrame.call(this);

            var t = this.bonePose.current,
                a = this.bonePose.delta,
                i = this.bonePose.result;
            this.bone._transformDirty = !0, 2 !== this._tweenState && (this._tweenState = 0), i.x = t.x + a.x * this._tweenProgress, i.y = t.y + a.y * this._tweenProgress, i.rotation = t.rotation + a.rotation * this._tweenProgress, i.skew = t.skew + a.skew * this._tweenProgress, i.scaleX = t.scaleX + a.scaleX * this._tweenProgress, i.scaleY = t.scaleY + a.scaleY * this._tweenProgress;
          }, a.prototype.fadeOut = function () {
            var e = this.bonePose.result;
            e.rotation = t.Transform.normalizeRadian(e.rotation), e.skew = t.Transform.normalizeRadian(e.skew);
          }, a;
        }(t.BoneTimelineState);

        t.BoneAllTimelineState = i;

        var r = function (t) {
          function e() {
            return null !== t && t.apply(this, arguments) || this;
          }

          return W(e, t), e.toString = function () {
            return "[class dragonBones.BoneTranslateTimelineState]";
          }, e.prototype._onArriveAtFrame = function () {
            if (t.prototype._onArriveAtFrame.call(this), null !== this._timelineData) {
              var e = this._animationData.frameFloatOffset + this._frameValueOffset + 2 * this._frameIndex,
                  a = this._armature._armatureData.scale,
                  i = this._frameFloatArray,
                  r = this.bonePose.current,
                  n = this.bonePose.delta;
              r.x = i[e++] * a, r.y = i[e++] * a, 2 === this._tweenState ? (this._frameIndex === this._frameCount - 1 && (e = this._animationData.frameFloatOffset + this._frameValueOffset), n.x = i[e++] * a - r.x, n.y = i[e++] * a - r.y) : (n.x = 0, n.y = 0);
            } else r = this.bonePose.current, n = this.bonePose.delta, r.x = 0, r.y = 0, n.x = 0, n.y = 0;
          }, e.prototype._onUpdateFrame = function () {
            t.prototype._onUpdateFrame.call(this);

            var e = this.bonePose.current,
                a = this.bonePose.delta,
                i = this.bonePose.result;
            this.bone._transformDirty = !0, 2 !== this._tweenState && (this._tweenState = 0), i.x = e.x + a.x * this._tweenProgress, i.y = e.y + a.y * this._tweenProgress;
          }, e;
        }(t.BoneTimelineState);

        t.BoneTranslateTimelineState = r;

        var n = function (e) {
          function a() {
            return null !== e && e.apply(this, arguments) || this;
          }

          return W(a, e), a.toString = function () {
            return "[class dragonBones.BoneRotateTimelineState]";
          }, a.prototype._onArriveAtFrame = function () {
            if (e.prototype._onArriveAtFrame.call(this), null !== this._timelineData) {
              var a = this._animationData.frameFloatOffset + this._frameValueOffset + 2 * this._frameIndex,
                  i = this._frameFloatArray,
                  r = this.bonePose.current,
                  n = this.bonePose.delta;
              r.rotation = i[a++], r.skew = i[a++], 2 === this._tweenState ? (this._frameIndex === this._frameCount - 1 ? (a = this._animationData.frameFloatOffset + this._frameValueOffset, n.rotation = t.Transform.normalizeRadian(i[a++] - r.rotation)) : n.rotation = i[a++] - r.rotation, n.skew = i[a++] - r.skew) : (n.rotation = 0, n.skew = 0);
            } else r = this.bonePose.current, n = this.bonePose.delta, r.rotation = 0, r.skew = 0, n.rotation = 0, n.skew = 0;
          }, a.prototype._onUpdateFrame = function () {
            e.prototype._onUpdateFrame.call(this);

            var t = this.bonePose.current,
                a = this.bonePose.delta,
                i = this.bonePose.result;
            this.bone._transformDirty = !0, 2 !== this._tweenState && (this._tweenState = 0), i.rotation = t.rotation + a.rotation * this._tweenProgress, i.skew = t.skew + a.skew * this._tweenProgress;
          }, a.prototype.fadeOut = function () {
            var e = this.bonePose.result;
            e.rotation = t.Transform.normalizeRadian(e.rotation), e.skew = t.Transform.normalizeRadian(e.skew);
          }, a;
        }(t.BoneTimelineState);

        t.BoneRotateTimelineState = n;

        var s = function (t) {
          function e() {
            return null !== t && t.apply(this, arguments) || this;
          }

          return W(e, t), e.toString = function () {
            return "[class dragonBones.BoneScaleTimelineState]";
          }, e.prototype._onArriveAtFrame = function () {
            if (t.prototype._onArriveAtFrame.call(this), null !== this._timelineData) {
              var e = this._animationData.frameFloatOffset + this._frameValueOffset + 2 * this._frameIndex,
                  a = this._frameFloatArray,
                  i = this.bonePose.current,
                  r = this.bonePose.delta;
              i.scaleX = a[e++], i.scaleY = a[e++], 2 === this._tweenState ? (this._frameIndex === this._frameCount - 1 && (e = this._animationData.frameFloatOffset + this._frameValueOffset), r.scaleX = a[e++] - i.scaleX, r.scaleY = a[e++] - i.scaleY) : (r.scaleX = 0, r.scaleY = 0);
            } else i = this.bonePose.current, r = this.bonePose.delta, i.scaleX = 1, i.scaleY = 1, r.scaleX = 0, r.scaleY = 0;
          }, e.prototype._onUpdateFrame = function () {
            t.prototype._onUpdateFrame.call(this);

            var e = this.bonePose.current,
                a = this.bonePose.delta,
                i = this.bonePose.result;
            this.bone._transformDirty = !0, 2 !== this._tweenState && (this._tweenState = 0), i.scaleX = e.scaleX + a.scaleX * this._tweenProgress, i.scaleY = e.scaleY + a.scaleY * this._tweenProgress;
          }, e;
        }(t.BoneTimelineState);

        t.BoneScaleTimelineState = s;

        var o = function (t) {
          function e() {
            var e = null !== t && t.apply(this, arguments) || this;
            return e._current = [], e._delta = [], e._result = [], e;
          }

          return W(e, t), e.toString = function () {
            return "[class dragonBones.SurfaceTimelineState]";
          }, e.prototype._onClear = function () {
            t.prototype._onClear.call(this), this.surface = null, this._frameFloatOffset = 0, this._valueCount = 0, this._deformCount = 0, this._valueOffset = 0, this._current.length = 0, this._delta.length = 0, this._result.length = 0;
          }, e.prototype._onArriveAtFrame = function () {
            if (t.prototype._onArriveAtFrame.call(this), null !== this._timelineData) {
              var e = this._animationData.frameFloatOffset + this._frameValueOffset + this._frameIndex * this._valueCount,
                  a = this._armature._armatureData.scale,
                  i = this._frameFloatArray;

              if (2 === this._tweenState) {
                var r = e + this._valueCount;
                this._frameIndex === this._frameCount - 1 && (r = this._animationData.frameFloatOffset + this._frameValueOffset);

                for (var n = 0; n < this._valueCount; ++n) {
                  this._delta[n] = i[r + n] * a - (this._current[n] = i[e + n] * a);
                }
              } else for (n = 0; n < this._valueCount; ++n) {
                this._current[n] = i[e + n] * a;
              }
            } else for (n = 0; n < this._valueCount; ++n) {
              this._current[n] = 0;
            }
          }, e.prototype._onUpdateFrame = function () {
            t.prototype._onUpdateFrame.call(this), this.surface._transformDirty = !0, 2 !== this._tweenState && (this._tweenState = 0);

            for (var e = 0; e < this._valueCount; ++e) {
              this._result[e] = this._current[e] + this._delta[e] * this._tweenProgress;
            }
          }, e.prototype.init = function (e, a, i) {
            if (t.prototype.init.call(this, e, a, i), null !== this._timelineData) {
              var r = this._animationData.frameIntOffset + this._timelineArray[this._timelineData.offset + 3];
              this._deformCount = this._frameIntArray[r + 1], this._valueCount = this._frameIntArray[r + 2], this._valueOffset = this._frameIntArray[r + 3], this._frameFloatOffset = this._frameIntArray[r + 4] + this._animationData.frameFloatOffset;
            } else this._deformCount = this.surface._deformVertices.length, this._valueCount = this._deformCount, this._valueOffset = 0, this._frameFloatOffset = 0;

            this._current.length = this._valueCount, this._delta.length = this._valueCount, this._result.length = this._valueCount;

            for (var n = 0; n < this._valueCount; ++n) {
              this._delta[n] = 0;
            }
          }, e.prototype.blend = function (t) {
            for (var e = this.surface._blendState.blendWeight, a = this.surface._deformVertices, i = 0; i < this._deformCount; ++i) {
              var r;
              r = i < this._valueOffset ? this._frameFloatArray[this._frameFloatOffset + i] : i < this._valueOffset + this._valueCount ? this._result[i - this._valueOffset] : this._frameFloatArray[this._frameFloatOffset + i - this._valueCount], 2 === t ? a[i] += r * e : a[i] = 1 !== e ? r * e : r;
            }

            0 === this._animationState._fadeState && 0 === this._animationState._subFadeState || (this.surface._transformDirty = !0);
          }, e;
        }(t.TweenTimelineState);

        t.SurfaceTimelineState = o;

        var l = function (t) {
          function e() {
            return null !== t && t.apply(this, arguments) || this;
          }

          return W(e, t), e.toString = function () {
            return "[class dragonBones.SlotDislayTimelineState]";
          }, e.prototype._onArriveAtFrame = function () {
            if (this.playState >= 0) {
              var t = null !== this._timelineData ? this._frameArray[this._frameOffset + 1] : this.slot._slotData.displayIndex;
              this.slot.displayIndex !== t && this.slot._setDisplayIndex(t, !0);
            }
          }, e;
        }(t.SlotTimelineState);

        t.SlotDislayTimelineState = l;

        var h = function (t) {
          function e() {
            var e = null !== t && t.apply(this, arguments) || this;
            return e._current = [0, 0, 0, 0, 0, 0, 0, 0], e._delta = [0, 0, 0, 0, 0, 0, 0, 0], e._result = [0, 0, 0, 0, 0, 0, 0, 0], e;
          }

          return W(e, t), e.toString = function () {
            return "[class dragonBones.SlotColorTimelineState]";
          }, e.prototype._onClear = function () {
            t.prototype._onClear.call(this), this._dirty = !1;
          }, e.prototype._onArriveAtFrame = function () {
            if (t.prototype._onArriveAtFrame.call(this), null !== this._timelineData) {
              var e = this._dragonBonesData.intArray,
                  a = this._frameIntArray,
                  i = this._animationData.frameIntOffset + this._frameValueOffset + 1 * this._frameIndex,
                  r = a[i];
              r < 0 && (r += 65536), this._current[0] = e[r++], this._current[1] = e[r++], this._current[2] = e[r++], this._current[3] = e[r++], this._current[4] = e[r++], this._current[5] = e[r++], this._current[6] = e[r++], this._current[7] = e[r++], 2 === this._tweenState && ((r = this._frameIndex === this._frameCount - 1 ? a[this._animationData.frameIntOffset + this._frameValueOffset] : a[i + 1]) < 0 && (r += 65536), this._delta[0] = e[r++] - this._current[0], this._delta[1] = e[r++] - this._current[1], this._delta[2] = e[r++] - this._current[2], this._delta[3] = e[r++] - this._current[3], this._delta[4] = e[r++] - this._current[4], this._delta[5] = e[r++] - this._current[5], this._delta[6] = e[r++] - this._current[6], this._delta[7] = e[r++] - this._current[7]);
            } else {
              var n = this.slot._slotData.color;
              this._current[0] = 100 * n.alphaMultiplier, this._current[1] = 100 * n.redMultiplier, this._current[2] = 100 * n.greenMultiplier, this._current[3] = 100 * n.blueMultiplier, this._current[4] = n.alphaOffset, this._current[5] = n.redOffset, this._current[6] = n.greenOffset, this._current[7] = n.blueOffset;
            }
          }, e.prototype._onUpdateFrame = function () {
            t.prototype._onUpdateFrame.call(this), this._dirty = !0, 2 !== this._tweenState && (this._tweenState = 0), this._result[0] = .01 * (this._current[0] + this._delta[0] * this._tweenProgress), this._result[1] = .01 * (this._current[1] + this._delta[1] * this._tweenProgress), this._result[2] = .01 * (this._current[2] + this._delta[2] * this._tweenProgress), this._result[3] = .01 * (this._current[3] + this._delta[3] * this._tweenProgress), this._result[4] = this._current[4] + this._delta[4] * this._tweenProgress, this._result[5] = this._current[5] + this._delta[5] * this._tweenProgress, this._result[6] = this._current[6] + this._delta[6] * this._tweenProgress, this._result[7] = this._current[7] + this._delta[7] * this._tweenProgress;
          }, e.prototype.fadeOut = function () {
            this._tweenState = 0, this._dirty = !1;
          }, e.prototype.update = function (e) {
            if (t.prototype.update.call(this, e), 0 !== this._tweenState || this._dirty) {
              var a = this.slot._colorTransform;

              if (0 !== this._animationState._fadeState || 0 !== this._animationState._subFadeState) {
                if (a.alphaMultiplier !== this._result[0] || a.redMultiplier !== this._result[1] || a.greenMultiplier !== this._result[2] || a.blueMultiplier !== this._result[3] || a.alphaOffset !== this._result[4] || a.redOffset !== this._result[5] || a.greenOffset !== this._result[6] || a.blueOffset !== this._result[7]) {
                  var i = Math.pow(this._animationState._fadeProgress, 4);
                  a.alphaMultiplier += (this._result[0] - a.alphaMultiplier) * i, a.redMultiplier += (this._result[1] - a.redMultiplier) * i, a.greenMultiplier += (this._result[2] - a.greenMultiplier) * i, a.blueMultiplier += (this._result[3] - a.blueMultiplier) * i, a.alphaOffset += (this._result[4] - a.alphaOffset) * i, a.redOffset += (this._result[5] - a.redOffset) * i, a.greenOffset += (this._result[6] - a.greenOffset) * i, a.blueOffset += (this._result[7] - a.blueOffset) * i, this.slot._colorDirty = !0;
                }
              } else this._dirty && (this._dirty = !1, a.alphaMultiplier === this._result[0] && a.redMultiplier === this._result[1] && a.greenMultiplier === this._result[2] && a.blueMultiplier === this._result[3] && a.alphaOffset === this._result[4] && a.redOffset === this._result[5] && a.greenOffset === this._result[6] && a.blueOffset === this._result[7] || (a.alphaMultiplier = this._result[0], a.redMultiplier = this._result[1], a.greenMultiplier = this._result[2], a.blueMultiplier = this._result[3], a.alphaOffset = this._result[4], a.redOffset = this._result[5], a.greenOffset = this._result[6], a.blueOffset = this._result[7], this.slot._colorDirty = !0));
            }
          }, e;
        }(t.SlotTimelineState);

        t.SlotColorTimelineState = h;

        var u = function (t) {
          function e() {
            var e = null !== t && t.apply(this, arguments) || this;
            return e._current = [], e._delta = [], e._result = [], e;
          }

          return W(e, t), e.toString = function () {
            return "[class dragonBones.DeformTimelineState]";
          }, e.prototype._onClear = function () {
            t.prototype._onClear.call(this), this.vertexOffset = 0, this._dirty = !1, this._frameFloatOffset = 0, this._valueCount = 0, this._deformCount = 0, this._valueOffset = 0, this._current.length = 0, this._delta.length = 0, this._result.length = 0;
          }, e.prototype._onArriveAtFrame = function () {
            if (t.prototype._onArriveAtFrame.call(this), null !== this._timelineData) {
              var e = this._animationData.frameFloatOffset + this._frameValueOffset + this._frameIndex * this._valueCount,
                  a = this._armature._armatureData.scale,
                  i = this._frameFloatArray;

              if (2 === this._tweenState) {
                var r = e + this._valueCount;
                this._frameIndex === this._frameCount - 1 && (r = this._animationData.frameFloatOffset + this._frameValueOffset);

                for (var n = 0; n < this._valueCount; ++n) {
                  this._delta[n] = i[r + n] * a - (this._current[n] = i[e + n] * a);
                }
              } else for (n = 0; n < this._valueCount; ++n) {
                this._current[n] = i[e + n] * a;
              }
            } else for (n = 0; n < this._valueCount; ++n) {
              this._current[n] = 0;
            }
          }, e.prototype._onUpdateFrame = function () {
            t.prototype._onUpdateFrame.call(this), this._dirty = !0, 2 !== this._tweenState && (this._tweenState = 0);

            for (var e = 0; e < this._valueCount; ++e) {
              this._result[e] = this._current[e] + this._delta[e] * this._tweenProgress;
            }
          }, e.prototype.init = function (e, a, i) {
            if (t.prototype.init.call(this, e, a, i), null !== this._timelineData) {
              var r = this._animationData.frameIntOffset + this._timelineArray[this._timelineData.offset + 3];
              this.vertexOffset = this._frameIntArray[r + 0], this.vertexOffset < 0 && (this.vertexOffset += 65536), this._deformCount = this._frameIntArray[r + 1], this._valueCount = this._frameIntArray[r + 2], this._valueOffset = this._frameIntArray[r + 3], this._frameFloatOffset = this._frameIntArray[r + 4] + this._animationData.frameFloatOffset;
            } else {
              var n = this.slot._deformVertices;
              this._deformCount = null !== n ? n.vertices.length : 0, this._valueCount = this._deformCount, this._valueOffset = 0, this._frameFloatOffset = 0;
            }

            this._current.length = this._valueCount, this._delta.length = this._valueCount, this._result.length = this._valueCount;

            for (var s = 0; s < this._valueCount; ++s) {
              this._delta[s] = 0;
            }
          }, e.prototype.fadeOut = function () {
            this._tweenState = 0, this._dirty = !1;
          }, e.prototype.update = function (e) {
            var a = this.slot._deformVertices;

            if (null !== a && null !== a.verticesData && a.verticesData.offset === this.vertexOffset && (t.prototype.update.call(this, e), 0 !== this._tweenState || this._dirty)) {
              var i = a.vertices;

              if (0 !== this._animationState._fadeState || 0 !== this._animationState._subFadeState) {
                for (var r = Math.pow(this._animationState._fadeProgress, 2), n = 0; n < this._deformCount; ++n) {
                  n < this._valueOffset ? i[n] += (this._frameFloatArray[this._frameFloatOffset + n] - i[n]) * r : n < this._valueOffset + this._valueCount ? i[n] += (this._result[n - this._valueOffset] - i[n]) * r : i[n] += (this._frameFloatArray[this._frameFloatOffset + n - this._valueCount] - i[n]) * r;
                }

                a.verticesDirty = !0;
              } else if (this._dirty) {
                for (this._dirty = !1, n = 0; n < this._deformCount; ++n) {
                  n < this._valueOffset ? i[n] = this._frameFloatArray[this._frameFloatOffset + n] : n < this._valueOffset + this._valueCount ? i[n] = this._result[n - this._valueOffset] : i[n] = this._frameFloatArray[this._frameFloatOffset + n - this._valueCount];
                }

                a.verticesDirty = !0;
              }
            }
          }, e;
        }(t.SlotTimelineState);

        t.DeformTimelineState = u;

        var _ = function (t) {
          function e() {
            return null !== t && t.apply(this, arguments) || this;
          }

          return W(e, t), e.toString = function () {
            return "[class dragonBones.IKConstraintTimelineState]";
          }, e.prototype._onClear = function () {
            t.prototype._onClear.call(this), this._current = 0, this._delta = 0;
          }, e.prototype._onArriveAtFrame = function () {
            t.prototype._onArriveAtFrame.call(this);

            var e = this.constraint;

            if (null !== this._timelineData) {
              var a = this._animationData.frameIntOffset + this._frameValueOffset + 2 * this._frameIndex,
                  i = this._frameIntArray,
                  r = 0 !== i[a++];
              this._current = .01 * i[a++], 2 === this._tweenState ? (this._frameIndex === this._frameCount - 1 && (a = this._animationData.frameIntOffset + this._frameValueOffset), this._delta = .01 * i[a + 1] - this._current) : this._delta = 0, e._bendPositive = r;
            } else {
              var n = e._constraintData;
              this._current = n.weight, this._delta = 0, e._bendPositive = n.bendPositive;
            }

            e.invalidUpdate();
          }, e.prototype._onUpdateFrame = function () {
            t.prototype._onUpdateFrame.call(this), 2 !== this._tweenState && (this._tweenState = 0);
            var e = this.constraint;
            e._weight = this._current + this._delta * this._tweenProgress, e.invalidUpdate();
          }, e;
        }(t.ConstraintTimelineState);

        t.IKConstraintTimelineState = _;

        var f = function (t) {
          function e() {
            var e = null !== t && t.apply(this, arguments) || this;
            return e._floats = [0, 0, 0, 0, 0, 0], e;
          }

          return W(e, t), e.toString = function () {
            return "[class dragonBones.AnimationTimelineState]";
          }, e.prototype._onClear = function () {
            t.prototype._onClear.call(this), this.animationState = null;
          }, e.prototype._onArriveAtFrame = function () {
            if (t.prototype._onArriveAtFrame.call(this), null !== this._timelineData) {
              var e = this._animationData.frameIntOffset + this._frameValueOffset + 2 * this._frameIndex,
                  a = 1 / this.animationState._animationData.parent.frameRate,
                  i = this._frameIntArray;
              this._floats[0] = i[e++] * a, this._floats[3] = .01 * i[e++], 2 === this._tweenState ? (this._frameIndex === this._frameCount - 1 && (e = this._animationData.frameIntOffset + this._frameValueOffset), this._floats[1] = i[e++] * a - this._floats[0], this._floats[4] = .01 * i[e++] - this._floats[3]) : (this._floats[1] = 0, this._floats[4] = 0);
            }
          }, e.prototype._onUpdateFrame = function () {
            t.prototype._onUpdateFrame.call(this), 2 !== this._tweenState && (this._tweenState = 0), this._floats[0] >= 0 && (this._floats[2] = this._floats[0] + this._floats[1] * this._tweenProgress), this._floats[5] = this._floats[3] + this._floats[4] * this._tweenProgress;
          }, e.prototype.blend = function (t) {
            var e = this.animationState,
                a = e._blendState.blendWeight;
            2 === t ? (e.weight += this._floats[5] * a, e.currentTime += this._floats[2] * a) : (e.weight = this._floats[5] * a, e.currentTime = this._floats[2] * a);
          }, e;
        }(t.TweenTimelineState);

        t.AnimationTimelineState = f;
      }(K || (K = {})), function (t) {
        var e = function (t) {
          function e() {
            return null !== t && t.apply(this, arguments) || this;
          }

          return W(e, t), e.actionDataToInstance = function (t, a, i) {
            0 === t.type ? a.type = e.FRAME_EVENT : a.type = 10 === t.type ? e.FRAME_EVENT : e.SOUND_EVENT, a.name = t.name, a.armature = i, a.actionData = t, a.data = t.data, null !== t.bone && (a.bone = i.getBone(t.bone.name)), null !== t.slot && (a.slot = i.getSlot(t.slot.name));
          }, e.toString = function () {
            return "[class dragonBones.EventObject]";
          }, e.prototype._onClear = function () {
            this.time = 0, this.type = "", this.name = "", this.armature = null, this.bone = null, this.slot = null, this.animationState = null, this.actionData = null, this.data = null;
          }, e.START = "start", e.LOOP_COMPLETE = "loopComplete", e.COMPLETE = "complete", e.FADE_IN = "fadeIn", e.FADE_IN_COMPLETE = "fadeInComplete", e.FADE_OUT = "fadeOut", e.FADE_OUT_COMPLETE = "fadeOutComplete", e.FRAME_EVENT = "frameEvent", e.SOUND_EVENT = "soundEvent", e;
        }(t.BaseObject);

        t.EventObject = e;
      }(K || (K = {})), function (t) {
        var e = function () {
          function e() {}

          return e._getArmatureType = function (t) {
            switch (t.toLowerCase()) {
              case "stage":
                return 2;

              case "armature":
                return 0;

              case "movieclip":
                return 1;

              default:
                return 0;
            }
          }, e._getBoneType = function (t) {
            switch (t.toLowerCase()) {
              case "bone":
                return 0;

              case "surface":
                return 1;

              default:
                return 0;
            }
          }, e._getDisplayType = function (t) {
            switch (t.toLowerCase()) {
              case "image":
                return 0;

              case "mesh":
                return 2;

              case "armature":
                return 1;

              case "boundingbox":
                return 3;

              case "path":
                return 4;

              default:
                return 0;
            }
          }, e._getBoundingBoxType = function (t) {
            switch (t.toLowerCase()) {
              case "rectangle":
                return 0;

              case "ellipse":
                return 1;

              case "polygon":
                return 2;

              default:
                return 0;
            }
          }, e._getActionType = function (t) {
            switch (t.toLowerCase()) {
              case "play":
                return 0;

              case "frame":
                return 10;

              case "sound":
                return 11;

              default:
                return 0;
            }
          }, e._getBlendMode = function (t) {
            switch (t.toLowerCase()) {
              case "normal":
                return 0;

              case "add":
                return 1;

              case "alpha":
                return 2;

              case "darken":
                return 3;

              case "difference":
                return 4;

              case "erase":
                return 5;

              case "hardlight":
                return 6;

              case "invert":
                return 7;

              case "layer":
                return 8;

              case "lighten":
                return 9;

              case "multiply":
                return 10;

              case "overlay":
                return 11;

              case "screen":
                return 12;

              case "subtract":
                return 13;

              default:
                return 0;
            }
          }, e._getPositionMode = function (t) {
            switch (t.toLocaleLowerCase()) {
              case "percent":
                return 1;

              case "fixed":
                return 0;

              default:
                return 1;
            }
          }, e._getSpacingMode = function (t) {
            switch (t.toLocaleLowerCase()) {
              case "length":
                return 0;

              case "percent":
                return 2;

              case "fixed":
                return 1;

              default:
                return 0;
            }
          }, e._getRotateMode = function (t) {
            switch (t.toLocaleLowerCase()) {
              case "tangent":
                return 0;

              case "chain":
                return 1;

              case "chainscale":
                return 2;

              default:
                return 0;
            }
          }, e.parseDragonBonesData = function (e) {
            return console.warn("Deprecated."), e instanceof ArrayBuffer ? t.BinaryDataParser.getInstance().parseDragonBonesData(e) : t.ObjectDataParser.getInstance().parseDragonBonesData(e);
          }, e.parseTextureAtlasData = function (a, i) {
            void 0 === i && (i = 1), console.warn("");

            for (var r = {}, n = a[e.SUB_TEXTURE], s = 0, o = n.length; s < o; s++) {
              var l = n[s],
                  h = l[e.NAME],
                  u = new t.Rectangle(),
                  _ = null;
              u.x = l[e.X] / i, u.y = l[e.Y] / i, u.width = l[e.WIDTH] / i, u.height = l[e.HEIGHT] / i, e.FRAME_WIDTH in l && ((_ = new t.Rectangle()).x = l[e.FRAME_X] / i, _.y = l[e.FRAME_Y] / i, _.width = l[e.FRAME_WIDTH] / i, _.height = l[e.FRAME_HEIGHT] / i), r[h] = {
                region: u,
                frame: _,
                rotated: !1
              };
            }

            return r;
          }, e.DATA_VERSION_2_3 = "2.3", e.DATA_VERSION_3_0 = "3.0", e.DATA_VERSION_4_0 = "4.0", e.DATA_VERSION_4_5 = "4.5", e.DATA_VERSION_5_0 = "5.0", e.DATA_VERSION_5_5 = "5.5", e.DATA_VERSION = e.DATA_VERSION_5_5, e.DATA_VERSIONS = [e.DATA_VERSION_4_0, e.DATA_VERSION_4_5, e.DATA_VERSION_5_0, e.DATA_VERSION_5_5], e.TEXTURE_ATLAS = "textureAtlas", e.SUB_TEXTURE = "SubTexture", e.FORMAT = "format", e.IMAGE_PATH = "imagePath", e.WIDTH = "width", e.HEIGHT = "height", e.ROTATED = "rotated", e.FRAME_X = "frameX", e.FRAME_Y = "frameY", e.FRAME_WIDTH = "frameWidth", e.FRAME_HEIGHT = "frameHeight", e.DRADON_BONES = "dragonBones", e.USER_DATA = "userData", e.ARMATURE = "armature", e.BONE = "bone", e.SURFACE = "surface", e.SLOT = "slot", e.CONSTRAINT = "constraint", e.IK = "ik", e.PATH_CONSTRAINT = "path", e.SKIN = "skin", e.DISPLAY = "display", e.ANIMATION = "animation", e.Z_ORDER = "zOrder", e.FFD = "ffd", e.FRAME = "frame", e.TRANSLATE_FRAME = "translateFrame", e.ROTATE_FRAME = "rotateFrame", e.SCALE_FRAME = "scaleFrame", e.DISPLAY_FRAME = "displayFrame", e.COLOR_FRAME = "colorFrame", e.DEFAULT_ACTIONS = "defaultActions", e.ACTIONS = "actions", e.EVENTS = "events", e.INTS = "ints", e.FLOATS = "floats", e.STRINGS = "strings", e.CANVAS = "canvas", e.TRANSFORM = "transform", e.PIVOT = "pivot", e.AABB = "aabb", e.COLOR = "color", e.VERSION = "version", e.COMPATIBLE_VERSION = "compatibleVersion", e.FRAME_RATE = "frameRate", e.TYPE = "type", e.SUB_TYPE = "subType", e.NAME = "name", e.PARENT = "parent", e.TARGET = "target", e.STAGE = "stage", e.SHARE = "share", e.PATH = "path", e.LENGTH = "length", e.DISPLAY_INDEX = "displayIndex", e.BLEND_MODE = "blendMode", e.INHERIT_TRANSLATION = "inheritTranslation", e.INHERIT_ROTATION = "inheritRotation", e.INHERIT_SCALE = "inheritScale", e.INHERIT_REFLECTION = "inheritReflection", e.INHERIT_ANIMATION = "inheritAnimation", e.INHERIT_DEFORM = "inheritDeform", e.SEGMENT_X = "segmentX", e.SEGMENT_Y = "segmentY", e.BEND_POSITIVE = "bendPositive", e.CHAIN = "chain", e.WEIGHT = "weight", e.FADE_IN_TIME = "fadeInTime", e.PLAY_TIMES = "playTimes", e.SCALE = "scale", e.OFFSET = "offset", e.POSITION = "position", e.DURATION = "duration", e.TWEEN_EASING = "tweenEasing", e.TWEEN_ROTATE = "tweenRotate", e.TWEEN_SCALE = "tweenScale", e.CLOCK_WISE = "clockwise", e.CURVE = "curve", e.SOUND = "sound", e.EVENT = "event", e.ACTION = "action", e.X = "x", e.Y = "y", e.SKEW_X = "skX", e.SKEW_Y = "skY", e.SCALE_X = "scX", e.SCALE_Y = "scY", e.VALUE = "value", e.ROTATE = "rotate", e.SKEW = "skew", e.ALPHA_OFFSET = "aO", e.RED_OFFSET = "rO", e.GREEN_OFFSET = "gO", e.BLUE_OFFSET = "bO", e.ALPHA_MULTIPLIER = "aM", e.RED_MULTIPLIER = "rM", e.GREEN_MULTIPLIER = "gM", e.BLUE_MULTIPLIER = "bM", e.UVS = "uvs", e.VERTICES = "vertices", e.TRIANGLES = "triangles", e.WEIGHTS = "weights", e.SLOT_POSE = "slotPose", e.BONE_POSE = "bonePose", e.GLUE_WEIGHTS = "glueWeights", e.GLUE_MESHES = "glueMeshes", e.BONES = "bones", e.POSITION_MODE = "positionMode", e.SPACING_MODE = "spacingMode", e.ROTATE_MODE = "rotateMode", e.SPACING = "spacing", e.ROTATE_OFFSET = "rotateOffset", e.ROTATE_MIX = "rotateMix", e.TRANSLATE_MIX = "translateMix", e.TARGET_DISPLAY = "targetDisplay", e.CLOSED = "closed", e.CONSTANT_SPEED = "constantSpeed", e.VERTEX_COUNT = "vertexCount", e.LENGTHS = "lengths", e.GOTO_AND_PLAY = "gotoAndPlay", e.DEFAULT_NAME = "default", e;
        }();

        t.DataParser = e;
      }(K || (K = {})), function (t) {
        var e = function (e) {
          function i() {
            var a = null !== e && e.apply(this, arguments) || this;
            return a._rawTextureAtlasIndex = 0, a._rawBones = [], a._data = null, a._armature = null, a._bone = null, a._surface = null, a._slot = null, a._skin = null, a._mesh = null, a._animation = null, a._timeline = null, a._rawTextureAtlases = null, a._defaultColorOffset = -1, a._prevClockwise = 0, a._prevRotation = 0, a._helpMatrixA = new t.Matrix(), a._helpMatrixB = new t.Matrix(), a._helpTransform = new t.Transform(), a._helpColorTransform = new t.ColorTransform(), a._helpPoint = new t.Point(), a._helpArray = [], a._intArray = [], a._floatArray = [], a._frameIntArray = [], a._frameFloatArray = [], a._frameArray = [], a._timelineArray = [], a._cacheRawMeshes = [], a._cacheMeshes = [], a._actionFrames = [], a._weightSlotPose = {}, a._weightBonePoses = {}, a._cacheBones = {}, a._slotChildActions = {}, a;
          }

          return W(i, e), i._getBoolean = function (t, e, a) {
            if (e in t) {
              var i = t[e],
                  r = _typeof2(i);

              if ("boolean" === r) return i;
              if ("string" !== r) return !!i;

              switch (i) {
                case "0":
                case "NaN":
                case "":
                case "false":
                case "null":
                case "undefined":
                  return !1;

                default:
                  return !0;
              }
            }

            return a;
          }, i._getNumber = function (t, e, a) {
            if (e in t) {
              var i = t[e];
              return null === i || "NaN" === i ? a : +i || 0;
            }

            return a;
          }, i._getString = function (e, a, i) {
            if (a in e) {
              var r = e[a];

              if ("string" == typeof r) {
                if (t.DragonBones.webAssembly) for (var n = 0, s = r.length; n < s; ++n) {
                  if (r.charCodeAt(n) > 255) return encodeURI(r);
                }
                return r;
              }

              return String(r);
            }

            return i;
          }, i.prototype._getCurvePoint = function (t, e, a, i, r, n, s, o, l, h) {
            var u = 1 - l,
                _ = u * u,
                f = l * l,
                c = u * _,
                m = 3 * l * _,
                p = 3 * u * f,
                d = l * f;

            h.x = c * t + m * a + p * r + d * s, h.y = c * e + m * i + p * n + d * o;
          }, i.prototype._samplingEasingCurve = function (t, e) {
            for (var a = t.length, i = -2, r = 0, n = e.length; r < n; ++r) {
              for (var s = (r + 1) / (n + 1); (i + 6 < a ? t[i + 6] : 1) < s;) {
                i += 6;
              }

              for (var o = i >= 0 && i + 6 < a, l = o ? t[i] : 0, h = o ? t[i + 1] : 0, u = t[i + 2], _ = t[i + 3], f = t[i + 4], c = t[i + 5], m = o ? t[i + 6] : 1, p = o ? t[i + 7] : 1, d = 0, y = 1; y - d > 1e-4;) {
                var g = .5 * (y + d);
                this._getCurvePoint(l, h, u, _, f, c, m, p, g, this._helpPoint), s - this._helpPoint.x > 0 ? d = g : y = g;
              }

              e[r] = this._helpPoint.y;
            }
          }, i.prototype._parseActionDataInFrame = function (e, a, i, r) {
            t.DataParser.EVENT in e && this._mergeActionFrame(e[t.DataParser.EVENT], a, 10, i, r), t.DataParser.SOUND in e && this._mergeActionFrame(e[t.DataParser.SOUND], a, 11, i, r), t.DataParser.ACTION in e && this._mergeActionFrame(e[t.DataParser.ACTION], a, 0, i, r), t.DataParser.EVENTS in e && this._mergeActionFrame(e[t.DataParser.EVENTS], a, 10, i, r), t.DataParser.ACTIONS in e && this._mergeActionFrame(e[t.DataParser.ACTIONS], a, 0, i, r);
          }, i.prototype._mergeActionFrame = function (e, i, r, n, s) {
            for (var o = t.DragonBones.webAssembly ? this._armature.actions.size() : this._armature.actions.length, l = this._parseActionData(e, r, n, s), h = 0, u = null, _ = 0, f = l; _ < f.length; _++) {
              var c = f[_];

              this._armature.addAction(c, !1);
            }

            0 === this._actionFrames.length && ((u = new a()).frameStart = 0, this._actionFrames.push(u), u = null);

            for (var m = 0, p = this._actionFrames; m < p.length; m++) {
              var d = p[m];

              if (d.frameStart === i) {
                u = d;
                break;
              }

              if (d.frameStart > i) break;
              h++;
            }

            null === u && ((u = new a()).frameStart = i, this._actionFrames.splice(h + 1, 0, u));

            for (var y = 0; y < l.length; ++y) {
              u.actions.push(o + y);
            }
          }, i.prototype._parseArmature = function (e, a) {
            var r = t.BaseObject.borrowObject(t.ArmatureData);

            if (r.name = i._getString(e, t.DataParser.NAME, ""), r.frameRate = i._getNumber(e, t.DataParser.FRAME_RATE, this._data.frameRate), r.scale = a, t.DataParser.TYPE in e && "string" == typeof e[t.DataParser.TYPE] ? r.type = t.DataParser._getArmatureType(e[t.DataParser.TYPE]) : r.type = i._getNumber(e, t.DataParser.TYPE, 0), 0 === r.frameRate && (r.frameRate = 24), this._armature = r, t.DataParser.CANVAS in e) {
              var n = e[t.DataParser.CANVAS],
                  s = t.BaseObject.borrowObject(t.CanvasData);
              t.DataParser.COLOR in n ? s.hasBackground = !0 : s.hasBackground = !1, s.color = i._getNumber(n, t.DataParser.COLOR, 0), s.x = i._getNumber(n, t.DataParser.X, 0) * r.scale, s.y = i._getNumber(n, t.DataParser.Y, 0) * r.scale, s.width = i._getNumber(n, t.DataParser.WIDTH, 0) * r.scale, s.height = i._getNumber(n, t.DataParser.HEIGHT, 0) * r.scale, r.canvas = s;
            }

            if (t.DataParser.AABB in e) {
              var o = e[t.DataParser.AABB];
              r.aabb.x = i._getNumber(o, t.DataParser.X, 0) * r.scale, r.aabb.y = i._getNumber(o, t.DataParser.Y, 0) * r.scale, r.aabb.width = i._getNumber(o, t.DataParser.WIDTH, 0) * r.scale, r.aabb.height = i._getNumber(o, t.DataParser.HEIGHT, 0) * r.scale;
            }

            if (t.DataParser.BONE in e) for (var l = 0, h = e[t.DataParser.BONE]; l < h.length; l++) {
              var u = h[l],
                  _ = i._getString(u, t.DataParser.PARENT, ""),
                  f = this._parseBone(u);

              if (_.length > 0) {
                var c = r.getBone(_);
                null !== c ? f.parent = c : (_ in this._cacheBones || (this._cacheBones[_] = []), this._cacheBones[_].push(f));
              }

              if (f.name in this._cacheBones) {
                for (var m = 0, p = this._cacheBones[f.name]; m < p.length; m++) {
                  p[m].parent = f;
                }

                delete this._cacheBones[f.name];
              }

              r.addBone(f), this._rawBones.push(f);
            }
            if (t.DataParser.IK in e) for (var d = 0, y = e[t.DataParser.IK]; d < y.length; d++) {
              var g = y[d];
              (C = this._parseIKConstraint(g)) && r.addConstraint(C);
            }
            if (r.sortBones(), t.DataParser.SLOT in e) for (var v = 0, D = 0, b = e[t.DataParser.SLOT]; D < b.length; D++) {
              var A = b[D];
              r.addSlot(this._parseSlot(A, v++));
            }
            if (t.DataParser.SKIN in e) for (var T = 0, S = e[t.DataParser.SKIN]; T < S.length; T++) {
              var x = S[T];
              r.addSkin(this._parseSkin(x));
            }
            if (t.DataParser.PATH_CONSTRAINT in e) for (var P = 0, O = e[t.DataParser.PATH_CONSTRAINT]; P < O.length; P++) {
              var C,
                  M = O[P];
              (C = this._parsePathConstraint(M)) && r.addConstraint(C);
            }

            for (var B = 0, I = this._cacheRawMeshes.length; B < I; ++B) {
              var E = this._cacheRawMeshes[B];
              t.DataParser.GLUE_WEIGHTS in E && t.DataParser.GLUE_MESHES in E && this._parseMeshGlue(E, this._cacheMeshes[B]);
            }

            for (B = 0, I = this._cacheRawMeshes.length; B < I; ++B) {
              var w = this._cacheRawMeshes[B],
                  F = i._getString(w, t.DataParser.SHARE, "");

              if (0 !== F.length) {
                var N = i._getString(w, t.DataParser.SKIN, t.DataParser.DEFAULT_NAME);

                0 === N.length && (N = t.DataParser.DEFAULT_NAME);
                var R = r.getMesh(N, "", F);
                null !== R && this._cacheMeshes[B].vertices.shareFrom(R.vertices);
              }
            }

            if (t.DataParser.ANIMATION in e) for (var k = 0, j = e[t.DataParser.ANIMATION]; k < j.length; k++) {
              var L = j[k],
                  U = this._parseAnimation(L);

              r.addAnimation(U);
            }
            if (t.DataParser.DEFAULT_ACTIONS in e) for (var V = 0, Y = this._parseActionData(e[t.DataParser.DEFAULT_ACTIONS], 0, null, null); V < Y.length; V++) {
              var X = Y[V];
              r.addAction(X, !0), 0 === X.type && null !== (U = r.getAnimation(X.name)) && (r.defaultAnimation = U);
            }
            if (t.DataParser.ACTIONS in e) for (var G = 0, H = this._parseActionData(e[t.DataParser.ACTIONS], 0, null, null); G < H.length; G++) {
              X = H[G], r.addAction(X, !1);
            }

            for (var z in this._rawBones.length = 0, this._cacheRawMeshes.length = 0, this._cacheMeshes.length = 0, this._armature = null, this._weightSlotPose) {
              delete this._weightSlotPose[z];
            }

            for (var z in this._weightBonePoses) {
              delete this._weightBonePoses[z];
            }

            for (var z in this._cacheBones) {
              delete this._cacheBones[z];
            }

            for (var z in this._slotChildActions) {
              delete this._slotChildActions[z];
            }

            return r;
          }, i.prototype._parseBone = function (e) {
            var a = this._armature.scale;

            if (0 === (t.DataParser.TYPE in e && "string" == typeof e[t.DataParser.TYPE] ? t.DataParser._getBoneType(e[t.DataParser.TYPE]) : i._getNumber(e, t.DataParser.TYPE, 0))) {
              var r = t.BaseObject.borrowObject(t.BoneData);
              return r.inheritTranslation = i._getBoolean(e, t.DataParser.INHERIT_TRANSLATION, !0), r.inheritRotation = i._getBoolean(e, t.DataParser.INHERIT_ROTATION, !0), r.inheritScale = i._getBoolean(e, t.DataParser.INHERIT_SCALE, !0), r.inheritReflection = i._getBoolean(e, t.DataParser.INHERIT_REFLECTION, !0), r.length = i._getNumber(e, t.DataParser.LENGTH, 0) * a, r.name = i._getString(e, t.DataParser.NAME, ""), t.DataParser.TRANSFORM in e && this._parseTransform(e[t.DataParser.TRANSFORM], r.transform, a), r;
            }

            var n = t.BaseObject.borrowObject(t.SurfaceData);
            if (n.name = i._getString(e, t.DataParser.NAME, ""), n.segmentX = i._getNumber(e, t.DataParser.SEGMENT_X, 0), n.segmentY = i._getNumber(e, t.DataParser.SEGMENT_Y, 0), n.vertices.length = (n.segmentX + 1) * (n.segmentY + 1) * 2, t.DataParser.VERTICES in e) for (var s = e[t.DataParser.VERTICES], o = 0, l = n.vertices.length; o < l; ++o) {
              o < s.length ? n.vertices[o] = s[o] * a : n.vertices[o] = 0;
            }
            return n;
          }, i.prototype._parseIKConstraint = function (e) {
            var a = this._armature.getBone(i._getString(e, t.DataParser.BONE, ""));

            if (null === a) return null;

            var r = this._armature.getBone(i._getString(e, t.DataParser.TARGET, ""));

            if (null === r) return null;
            var n = t.BaseObject.borrowObject(t.IKConstraintData);
            return n.scaleEnabled = i._getBoolean(e, t.DataParser.SCALE, !1), n.bendPositive = i._getBoolean(e, t.DataParser.BEND_POSITIVE, !0), n.weight = i._getNumber(e, t.DataParser.WEIGHT, 1), n.name = i._getString(e, t.DataParser.NAME, ""), n.type = 0, n.target = r, i._getNumber(e, t.DataParser.CHAIN, 0) > 0 && null !== a.parent ? (n.root = a.parent, n.bone = a) : (n.root = a, n.bone = null), n;
          }, i.prototype._parsePathConstraint = function (e) {
            var a = this._armature.getSlot(i._getString(e, t.DataParser.TARGET, ""));

            if (null === a) return null;
            var r = this._armature.defaultSkin;
            if (null === r) return null;
            var n = r.getDisplay(a.name, i._getString(e, t.DataParser.TARGET_DISPLAY, a.name));
            if (null === n || !(n instanceof t.PathDisplayData)) return null;
            var s = e[t.DataParser.BONES];
            if (null === s || 0 === s.length) return null;
            var o = t.BaseObject.borrowObject(t.PathConstraintData);
            o.name = i._getString(e, t.DataParser.NAME, ""), o.type = 1, o.pathSlot = a, o.pathDisplayData = n, o.target = a.parent, o.positionMode = t.DataParser._getPositionMode(i._getString(e, t.DataParser.POSITION_MODE, "")), o.spacingMode = t.DataParser._getSpacingMode(i._getString(e, t.DataParser.SPACING_MODE, "")), o.rotateMode = t.DataParser._getRotateMode(i._getString(e, t.DataParser.ROTATE_MODE, "")), o.position = i._getNumber(e, t.DataParser.POSITION, 0), o.spacing = i._getNumber(e, t.DataParser.SPACING, 0), o.rotateOffset = i._getNumber(e, t.DataParser.ROTATE_OFFSET, 0), o.rotateMix = i._getNumber(e, t.DataParser.ROTATE_MIX, 1), o.translateMix = i._getNumber(e, t.DataParser.TRANSLATE_MIX, 1);

            for (var l = 0, h = s; l < h.length; l++) {
              var u = h[l],
                  _ = this._armature.getBone(u);

              null !== _ && (o.AddBone(_), null === o.root && (o.root = _));
            }

            return o;
          }, i.prototype._parseSlot = function (e, a) {
            var r = t.BaseObject.borrowObject(t.SlotData);
            return r.displayIndex = i._getNumber(e, t.DataParser.DISPLAY_INDEX, 0), r.zOrder = a, r.name = i._getString(e, t.DataParser.NAME, ""), r.parent = this._armature.getBone(i._getString(e, t.DataParser.PARENT, "")), t.DataParser.BLEND_MODE in e && "string" == typeof e[t.DataParser.BLEND_MODE] ? r.blendMode = t.DataParser._getBlendMode(e[t.DataParser.BLEND_MODE]) : r.blendMode = i._getNumber(e, t.DataParser.BLEND_MODE, 0), t.DataParser.COLOR in e ? (r.color = t.SlotData.createColor(), this._parseColorTransform(e[t.DataParser.COLOR], r.color)) : r.color = t.SlotData.DEFAULT_COLOR, t.DataParser.ACTIONS in e && (this._slotChildActions[r.name] = this._parseActionData(e[t.DataParser.ACTIONS], 0, null, null)), r;
          }, i.prototype._parseSkin = function (e) {
            var a = t.BaseObject.borrowObject(t.SkinData);

            if (a.name = i._getString(e, t.DataParser.NAME, t.DataParser.DEFAULT_NAME), 0 === a.name.length && (a.name = t.DataParser.DEFAULT_NAME), t.DataParser.SLOT in e) {
              var r = e[t.DataParser.SLOT];
              this._skin = a;

              for (var n = 0, s = r; n < s.length; n++) {
                var o = s[n],
                    l = i._getString(o, t.DataParser.NAME, ""),
                    h = this._armature.getSlot(l);

                if (null !== h) {
                  if (this._slot = h, t.DataParser.DISPLAY in o) for (var u = 0, _ = o[t.DataParser.DISPLAY]; u < _.length; u++) {
                    var f = _[u];
                    f ? a.addDisplay(l, this._parseDisplay(f)) : a.addDisplay(l, null);
                  }
                  this._slot = null;
                }
              }

              this._skin = null;
            }

            return a;
          }, i.prototype._parseDisplay = function (e) {
            var a = i._getString(e, t.DataParser.NAME, ""),
                r = i._getString(e, t.DataParser.PATH, ""),
                n = 0,
                s = null;

            switch (n = t.DataParser.TYPE in e && "string" == typeof e[t.DataParser.TYPE] ? t.DataParser._getDisplayType(e[t.DataParser.TYPE]) : i._getNumber(e, t.DataParser.TYPE, n)) {
              case 0:
                var o = s = t.BaseObject.borrowObject(t.ImageDisplayData);
                o.name = a, o.path = r.length > 0 ? r : a, this._parsePivot(e, o);
                break;

              case 1:
                var l = s = t.BaseObject.borrowObject(t.ArmatureDisplayData);
                if (l.name = a, l.path = r.length > 0 ? r : a, l.inheritAnimation = !0, t.DataParser.ACTIONS in e) for (var h = 0, u = this._parseActionData(e[t.DataParser.ACTIONS], 0, null, null); h < u.length; h++) {
                  var _ = u[h];
                  l.addAction(_);
                } else if (this._slot.name in this._slotChildActions) {
                  var f = this._skin.getDisplays(this._slot.name);

                  if (null === f ? 0 === this._slot.displayIndex : this._slot.displayIndex === f.length) {
                    for (var c = 0, m = this._slotChildActions[this._slot.name]; c < m.length; c++) {
                      _ = m[c], l.addAction(_);
                    }

                    delete this._slotChildActions[this._slot.name];
                  }
                }
                break;

              case 2:
                var p = s = t.BaseObject.borrowObject(t.MeshDisplayData);
                p.vertices.inheritDeform = i._getBoolean(e, t.DataParser.INHERIT_DEFORM, !0), p.name = a, p.path = r.length > 0 ? r : a, p.vertices.data = this._data, t.DataParser.SHARE in e ? (this._cacheRawMeshes.push(e), this._cacheMeshes.push(p)) : this._parseMesh(e, p), t.DataParser.GLUE_WEIGHTS in e && t.DataParser.GLUE_MESHES in e && (this._cacheRawMeshes.push(e), this._cacheMeshes.push(p));
                break;

              case 3:
                var d = this._parseBoundingBox(e);

                if (null !== d) {
                  var y = s = t.BaseObject.borrowObject(t.BoundingBoxDisplayData);
                  y.name = a, y.path = r.length > 0 ? r : a, y.boundingBox = d;
                }

                break;

              case 4:
                var g = e[t.DataParser.LENGTHS],
                    v = s = t.BaseObject.borrowObject(t.PathDisplayData);
                v.closed = i._getBoolean(e, t.DataParser.CLOSED, !1), v.constantSpeed = i._getBoolean(e, t.DataParser.CONSTANT_SPEED, !1), v.name = a, v.path = r.length > 0 ? r : a, v.vertices.data = this._data, v.curveLengths.length = g.length;

                for (var D = 0, b = g.length; D < b; ++D) {
                  v.curveLengths[D] = g[D];
                }

                this._parsePath(e, v);

            }

            return null !== s && t.DataParser.TRANSFORM in e && this._parseTransform(e[t.DataParser.TRANSFORM], s.transform, this._armature.scale), s;
          }, i.prototype._parsePath = function (e, a) {
            var r = e[t.DataParser.VERTICES],
                n = i._getNumber(e, t.DataParser.VERTEX_COUNT, 0),
                s = this._floatArray.length,
                o = this._intArray.length;

            if (a.vertices.offset = o, this._intArray.length += 2, this._intArray[o + 0] = n, this._intArray[o + 2] = s, t.DataParser.WEIGHTS in e) {
              var l = e[t.DataParser.WEIGHTS],
                  h = e[t.DataParser.BONES],
                  u = h.length,
                  _ = Math.floor(l.length - n) / 2,
                  f = this._intArray.length,
                  c = this._floatArray.length,
                  m = this._armature.sortedBones,
                  p = t.BaseObject.borrowObject(t.WeightData);

              for (p.count = _, p.offset = f, this._intArray.length += 2 + u + n + _, this._intArray[f + 0] = u, this._intArray[f + 1] = c, C = 0; C < u; C++) {
                var d = h[C],
                    y = this._rawBones[d];
                p.addBone(y), this._intArray[f + 2 + C] = m.indexOf(y);
              }

              this._floatArray.length += 3 * _, C = 0;

              for (var g = 0, v = 0, D = f + 2 + u, b = c; C < _; C++) {
                var A = l[g++];
                this._intArray[D++] = A;

                for (var T = 0; T < A; T++) {
                  var S = l[g++],
                      x = l[g++],
                      P = r[v++],
                      O = r[v++];
                  this._intArray[D++] = h.indexOf(S), this._floatArray[b++] = x, this._floatArray[b++] = P, this._floatArray[b++] = O;
                }
              }

              a.vertices.weight = p;
            } else {
              this._floatArray.length += r.length;

              for (var C = 0, M = r.length; C < M; ++C) {
                this._floatArray[s + C] = r[C];
              }
            }
          }, i.prototype._parsePivot = function (e, a) {
            if (t.DataParser.PIVOT in e) {
              var r = e[t.DataParser.PIVOT];
              a.pivot.x = i._getNumber(r, t.DataParser.X, 0), a.pivot.y = i._getNumber(r, t.DataParser.Y, 0);
            } else a.pivot.x = .5, a.pivot.y = .5;
          }, i.prototype._parseMesh = function (e, a) {
            var i = e[t.DataParser.VERTICES],
                r = e[t.DataParser.UVS],
                n = e[t.DataParser.TRIANGLES],
                s = Math.floor(i.length / 2),
                o = Math.floor(n.length / 3),
                l = this._floatArray.length,
                h = l + 2 * s,
                u = this._intArray.length,
                _ = this._skin.name + "_" + this._slot.name + "_" + a.name;

            a.vertices.offset = u, this._intArray.length += 4 + 3 * o, this._intArray[u + 0] = s, this._intArray[u + 1] = o, this._intArray[u + 2] = l;

            for (var f = 0, c = 3 * o; f < c; ++f) {
              this._intArray[u + 4 + f] = n[f];
            }

            for (this._floatArray.length += 2 * s + 2 * s, f = 0, c = 2 * s; f < c; ++f) {
              this._floatArray[l + f] = i[f], this._floatArray[h + f] = r[f];
            }

            if (t.DataParser.WEIGHTS in e) {
              var m = e[t.DataParser.WEIGHTS],
                  p = e[t.DataParser.SLOT_POSE],
                  d = e[t.DataParser.BONE_POSE],
                  y = this._armature.sortedBones,
                  g = new Array(),
                  v = Math.floor(d.length / 7),
                  D = this._floatArray.length,
                  b = Math.floor(m.length - s) / 2,
                  A = this._intArray.length,
                  T = t.BaseObject.borrowObject(t.WeightData);

              for (T.count = b, T.offset = A, g.length = v, this._intArray.length += 2 + v + s + b, this._intArray[A + 1] = D, f = 0; f < v; ++f) {
                var S = d[7 * f],
                    x = this._rawBones[S];
                T.addBone(x), g[f] = S, this._intArray[A + 2 + f] = y.indexOf(x);
              }

              this._floatArray.length += 3 * b, this._helpMatrixA.copyFromArray(p, 0), f = 0;

              for (var P = 0, O = A + 2 + v, C = D; f < s; ++f) {
                var M = 2 * f,
                    B = this._intArray[O++] = m[P++],
                    I = this._floatArray[l + M],
                    E = this._floatArray[l + M + 1];
                this._helpMatrixA.transformPoint(I, E, this._helpPoint), I = this._helpPoint.x, E = this._helpPoint.y;

                for (var w = 0; w < B; ++w) {
                  S = m[P++];
                  var F = g.indexOf(S);
                  this._helpMatrixB.copyFromArray(d, 7 * F + 1), this._helpMatrixB.invert(), this._helpMatrixB.transformPoint(I, E, this._helpPoint), this._intArray[O++] = F, this._floatArray[C++] = m[P++], this._floatArray[C++] = this._helpPoint.x, this._floatArray[C++] = this._helpPoint.y;
                }
              }

              a.vertices.weight = T, this._weightSlotPose[_] = p, this._weightBonePoses[_] = d;
            }
          }, i.prototype._parseMeshGlue = function () {}, i.prototype._parseBoundingBox = function (e) {
            var a = null,
                r = 0;

            switch (r = t.DataParser.SUB_TYPE in e && "string" == typeof e[t.DataParser.SUB_TYPE] ? t.DataParser._getBoundingBoxType(e[t.DataParser.SUB_TYPE]) : i._getNumber(e, t.DataParser.SUB_TYPE, r)) {
              case 0:
                a = t.BaseObject.borrowObject(t.RectangleBoundingBoxData);
                break;

              case 1:
                a = t.BaseObject.borrowObject(t.EllipseBoundingBoxData);
                break;

              case 2:
                a = this._parsePolygonBoundingBox(e);
            }

            return null !== a && (a.color = i._getNumber(e, t.DataParser.COLOR, 0), 0 !== a.type && 1 !== a.type || (a.width = i._getNumber(e, t.DataParser.WIDTH, 0), a.height = i._getNumber(e, t.DataParser.HEIGHT, 0))), a;
          }, i.prototype._parsePolygonBoundingBox = function (e) {
            var a = t.BaseObject.borrowObject(t.PolygonBoundingBoxData);

            if (t.DataParser.VERTICES in e) {
              var i = this._armature.scale,
                  r = e[t.DataParser.VERTICES],
                  n = a.vertices;
              t.DragonBones.webAssembly ? n.resize(r.length, 0) : n.length = r.length;

              for (var s = 0, o = r.length; s < o; s += 2) {
                var l = r[s] * i,
                    h = r[s + 1] * i;
                t.DragonBones.webAssembly ? (n.set(s, l), n.set(s + 1, h)) : (n[s] = l, n[s + 1] = h), 0 === s ? (a.x = l, a.y = h, a.width = l, a.height = h) : (l < a.x ? a.x = l : l > a.width && (a.width = l), h < a.y ? a.y = h : h > a.height && (a.height = h));
              }

              a.width -= a.x, a.height -= a.y;
            } else console.warn("Data error.\n Please reexport DragonBones Data to fixed the bug.");

            return a;
          }, i.prototype._parseAnimation = function (e) {
            var a = t.BaseObject.borrowObject(t.AnimationData);

            if (a.frameCount = Math.max(i._getNumber(e, t.DataParser.DURATION, 1), 1), a.playTimes = i._getNumber(e, t.DataParser.PLAY_TIMES, 1), a.duration = a.frameCount / this._armature.frameRate, a.fadeInTime = i._getNumber(e, t.DataParser.FADE_IN_TIME, 0), a.scale = i._getNumber(e, t.DataParser.SCALE, 1), a.name = i._getString(e, t.DataParser.NAME, t.DataParser.DEFAULT_NAME), 0 === a.name.length && (a.name = t.DataParser.DEFAULT_NAME), a.frameIntOffset = this._frameIntArray.length, a.frameFloatOffset = this._frameFloatArray.length, a.frameOffset = this._frameArray.length, this._animation = a, t.DataParser.FRAME in e) {
              var r = e[t.DataParser.FRAME],
                  n = r.length;
              if (n > 0) for (var s = 0, o = 0; s < n; ++s) {
                var l = r[s];
                this._parseActionDataInFrame(l, o, null, null), o += i._getNumber(l, t.DataParser.DURATION, 1);
              }
            }

            if (t.DataParser.Z_ORDER in e && (this._animation.zOrderTimeline = this._parseTimeline(e[t.DataParser.Z_ORDER], null, t.DataParser.FRAME, 1, !1, !1, 0, this._parseZOrderFrame)), t.DataParser.BONE in e) for (var h = 0, u = e[t.DataParser.BONE]; h < u.length; h++) {
              var _ = u[h];

              this._parseBoneTimeline(_);
            }
            if (t.DataParser.SURFACE in e) for (var f = 0, c = e[t.DataParser.SURFACE]; f < c.length; f++) {
              _ = c[f];

              var m = i._getString(_, t.DataParser.NAME, "");

              this._surface = this._armature.getBone(m), null !== this._surface && (null !== (C = this._parseTimeline(_, null, t.DataParser.FRAME, 50, !1, !0, 0, this._parseSurfaceFrame)) && this._animation.addSurfaceTimeline(this._surface, C), this._surface = null);
            }
            if (t.DataParser.SLOT in e) for (var p = 0, d = e[t.DataParser.SLOT]; p < d.length; p++) {
              _ = d[p], this._parseSlotTimeline(_);
            }
            if (t.DataParser.FFD in e) for (var y = 0, g = e[t.DataParser.FFD]; y < g.length; y++) {
              _ = g[y];

              var v = i._getString(_, t.DataParser.SKIN, t.DataParser.DEFAULT_NAME),
                  D = i._getString(_, t.DataParser.SLOT, ""),
                  b = i._getString(_, t.DataParser.NAME, "");

              0 === v.length && (v = t.DataParser.DEFAULT_NAME), this._slot = this._armature.getSlot(D), this._mesh = this._armature.getMesh(v, D, b), null !== this._slot && null !== this._mesh && (null !== (C = this._parseTimeline(_, null, t.DataParser.FRAME, 22, !1, !0, 0, this._parseSlotFFDFrame)) && this._animation.addSlotTimeline(this._slot, C), this._slot = null, this._mesh = null);
            }
            if (t.DataParser.IK in e) for (var A = 0, T = e[t.DataParser.IK]; A < T.length; A++) {
              _ = T[A];

              var S = i._getString(_, t.DataParser.NAME, ""),
                  x = this._armature.getConstraint(S);

              null !== x && null !== (C = this._parseTimeline(_, null, t.DataParser.FRAME, 30, !0, !1, 2, this._parseIKConstraintFrame)) && this._animation.addConstraintTimeline(x, C);
            }
            if (t.DataParser.ANIMATION in e) for (var P = 0, O = e[t.DataParser.ANIMATION]; P < O.length; P++) {
              _ = O[P];

              var C,
                  M = i._getString(_, t.DataParser.NAME, "");

              null !== (C = this._parseTimeline(_, null, t.DataParser.FRAME, 40, !0, !1, 2, this._parseAnimationFrame)) && this._animation.addAnimationTimeline(M, C);
            }
            return this._actionFrames.length > 0 && (this._animation.actionTimeline = this._parseTimeline(null, this._actionFrames, "", 0, !1, !1, 0, this._parseActionFrame), this._actionFrames.length = 0), this._animation = null, a;
          }, i.prototype._parseTimeline = function (e, r, n, s, o, l, h, u) {
            if (null !== e && n.length > 0 && n in e && (r = e[n]), null === r) return null;
            var _ = r.length;
            if (0 === _) return null;
            var f = this._frameIntArray.length,
                c = this._frameFloatArray.length,
                m = t.BaseObject.borrowObject(t.TimelineData),
                p = this._timelineArray.length;
            if (this._timelineArray.length += 5 + _, null !== e ? (this._timelineArray[p + 0] = Math.round(100 * i._getNumber(e, t.DataParser.SCALE, 1)), this._timelineArray[p + 1] = Math.round(100 * i._getNumber(e, t.DataParser.OFFSET, 0))) : (this._timelineArray[p + 0] = 100, this._timelineArray[p + 1] = 0), this._timelineArray[p + 2] = _, this._timelineArray[p + 3] = h, this._timelineArray[p + 4] = o ? f - this._animation.frameIntOffset : l ? c - this._animation.frameFloatOffset : 0, this._timeline = m, m.type = s, m.offset = p, 1 === _) m.frameIndicesOffset = -1, this._timelineArray[p + 5 + 0] = u.call(this, r[0], 0, 0) - this._animation.frameOffset;else {
              var d = this._animation.frameCount + 1,
                  y = this._data.frameIndices,
                  g = 0;
              t.DragonBones.webAssembly ? (g = y.size(), y.resize(g + d, 0)) : (g = y.length, y.length += d), m.frameIndicesOffset = g;

              for (var v = 0, D = 0, b = 0, A = 0; v < d; ++v) {
                if (b + A <= v && D < _) {
                  var T = r[D];
                  b = v, A = D === _ - 1 ? this._animation.frameCount - b : T instanceof a ? this._actionFrames[D + 1].frameStart - b : i._getNumber(T, t.DataParser.DURATION, 1), this._timelineArray[p + 5 + D] = u.call(this, T, b, A) - this._animation.frameOffset, D++;
                }

                t.DragonBones.webAssembly ? y.set(g + v, D - 1) : y[g + v] = D - 1;
              }
            }
            return this._timeline = null, m;
          }, i.prototype._parseBoneTimeline = function (e) {
            var a,
                r = this._armature.getBone(i._getString(e, t.DataParser.NAME, ""));

            null !== r && (this._bone = r, this._slot = this._armature.getSlot(this._bone.name), t.DataParser.TRANSLATE_FRAME in e && null !== (a = this._parseTimeline(e, null, t.DataParser.TRANSLATE_FRAME, 11, !1, !0, 2, this._parseBoneTranslateFrame)) && this._animation.addBoneTimeline(r, a), t.DataParser.ROTATE_FRAME in e && null !== (a = this._parseTimeline(e, null, t.DataParser.ROTATE_FRAME, 12, !1, !0, 2, this._parseBoneRotateFrame)) && this._animation.addBoneTimeline(r, a), t.DataParser.SCALE_FRAME in e && null !== (a = this._parseTimeline(e, null, t.DataParser.SCALE_FRAME, 13, !1, !0, 2, this._parseBoneScaleFrame)) && this._animation.addBoneTimeline(r, a), t.DataParser.FRAME in e && null !== (a = this._parseTimeline(e, null, t.DataParser.FRAME, 10, !1, !0, 6, this._parseBoneAllFrame)) && this._animation.addBoneTimeline(r, a), this._bone = null, this._slot = null);
          }, i.prototype._parseSlotTimeline = function (e) {
            var a = this._armature.getSlot(i._getString(e, t.DataParser.NAME, ""));

            if (null !== a) {
              this._slot = a;
              var r;
              null !== (r = t.DataParser.DISPLAY_FRAME in e ? this._parseTimeline(e, null, t.DataParser.DISPLAY_FRAME, 20, !1, !1, 0, this._parseSlotDisplayFrame) : this._parseTimeline(e, null, t.DataParser.FRAME, 20, !1, !1, 0, this._parseSlotDisplayFrame)) && this._animation.addSlotTimeline(a, r);
              var n;
              null !== (n = t.DataParser.COLOR_FRAME in e ? this._parseTimeline(e, null, t.DataParser.COLOR_FRAME, 21, !0, !1, 1, this._parseSlotColorFrame) : this._parseTimeline(e, null, t.DataParser.FRAME, 21, !0, !1, 1, this._parseSlotColorFrame)) && this._animation.addSlotTimeline(a, n), this._slot = null;
            }
          }, i.prototype._parseFrame = function (t, e) {
            var a = this._frameArray.length;
            return this._frameArray.length += 1, this._frameArray[a + 0] = e, a;
          }, i.prototype._parseTweenFrame = function (e, a, r) {
            var n = this._parseFrame(e, a, r);

            if (r > 0) {
              if (t.DataParser.CURVE in e) {
                var s = r + 1;
                this._helpArray.length = s, this._samplingEasingCurve(e[t.DataParser.CURVE], this._helpArray), this._frameArray.length += 2 + this._helpArray.length, this._frameArray[n + 1] = 2, this._frameArray[n + 2] = s;

                for (var o = 0; o < s; ++o) {
                  this._frameArray[n + 3 + o] = Math.round(1e4 * this._helpArray[o]);
                }
              } else {
                var l = -2;
                t.DataParser.TWEEN_EASING in e && (l = i._getNumber(e, t.DataParser.TWEEN_EASING, -2)), -2 === l ? (this._frameArray.length += 1, this._frameArray[n + 1] = 0) : 0 === l ? (this._frameArray.length += 1, this._frameArray[n + 1] = 1) : l < 0 ? (this._frameArray.length += 2, this._frameArray[n + 1] = 3, this._frameArray[n + 2] = Math.round(100 * -l)) : l <= 1 ? (this._frameArray.length += 2, this._frameArray[n + 1] = 4, this._frameArray[n + 2] = Math.round(100 * l)) : (this._frameArray.length += 2, this._frameArray[n + 1] = 5, this._frameArray[n + 2] = Math.round(100 * l - 100));
              }
            } else this._frameArray.length += 1, this._frameArray[n + 1] = 0;
            return n;
          }, i.prototype._parseActionFrame = function (t, e) {
            var a = this._frameArray.length,
                i = t.actions.length;
            this._frameArray.length += 2 + i, this._frameArray[a + 0] = e, this._frameArray[a + 0 + 1] = i;

            for (var r = 0; r < i; ++r) {
              this._frameArray[a + 0 + 2 + r] = t.actions[r];
            }

            return a;
          }, i.prototype._parseZOrderFrame = function (e, a, i) {
            var r = this._parseFrame(e, a, i);

            if (t.DataParser.Z_ORDER in e) {
              var n = e[t.DataParser.Z_ORDER];

              if (n.length > 0) {
                for (var s = this._armature.sortedSlots.length, o = new Array(s - n.length / 2), l = new Array(s), h = 0; h < o.length; ++h) {
                  o[h] = 0;
                }

                for (var u = 0; u < s; ++u) {
                  l[u] = -1;
                }

                for (var _ = 0, f = 0, c = 0, m = n.length; c < m; c += 2) {
                  for (var p = n[c], d = n[c + 1]; _ !== p;) {
                    o[f++] = _++;
                  }

                  l[_ + d] = _++;
                }

                for (; _ < s;) {
                  o[f++] = _++;
                }

                this._frameArray.length += 1 + s, this._frameArray[r + 1] = s;

                for (var y = s; y--;) {
                  -1 === l[y] ? this._frameArray[r + 2 + y] = o[--f] || 0 : this._frameArray[r + 2 + y] = l[y] || 0;
                }

                return r;
              }
            }

            return this._frameArray.length += 1, this._frameArray[r + 1] = 0, r;
          }, i.prototype._parseBoneAllFrame = function (e, a, r) {
            this._helpTransform.identity(), t.DataParser.TRANSFORM in e && this._parseTransform(e[t.DataParser.TRANSFORM], this._helpTransform, 1);
            var n = this._helpTransform.rotation;
            0 !== a && (0 === this._prevClockwise ? n = this._prevRotation + t.Transform.normalizeRadian(n - this._prevRotation) : ((this._prevClockwise > 0 ? n >= this._prevRotation : n <= this._prevRotation) && (this._prevClockwise = this._prevClockwise > 0 ? this._prevClockwise - 1 : this._prevClockwise + 1), n = this._prevRotation + n - this._prevRotation + t.Transform.PI_D * this._prevClockwise)), this._prevClockwise = i._getNumber(e, t.DataParser.TWEEN_ROTATE, 0), this._prevRotation = n;

            var s = this._parseTweenFrame(e, a, r),
                o = this._frameFloatArray.length;

            return this._frameFloatArray.length += 6, this._frameFloatArray[o++] = this._helpTransform.x, this._frameFloatArray[o++] = this._helpTransform.y, this._frameFloatArray[o++] = n, this._frameFloatArray[o++] = this._helpTransform.skew, this._frameFloatArray[o++] = this._helpTransform.scaleX, this._frameFloatArray[o++] = this._helpTransform.scaleY, this._parseActionDataInFrame(e, a, this._bone, this._slot), s;
          }, i.prototype._parseBoneTranslateFrame = function (e, a, r) {
            var n = this._parseTweenFrame(e, a, r),
                s = this._frameFloatArray.length;

            return this._frameFloatArray.length += 2, this._frameFloatArray[s++] = i._getNumber(e, t.DataParser.X, 0), this._frameFloatArray[s++] = i._getNumber(e, t.DataParser.Y, 0), n;
          }, i.prototype._parseBoneRotateFrame = function (e, a, r) {
            var n = i._getNumber(e, t.DataParser.ROTATE, 0) * t.Transform.DEG_RAD;
            0 !== a && (0 === this._prevClockwise ? n = this._prevRotation + t.Transform.normalizeRadian(n - this._prevRotation) : ((this._prevClockwise > 0 ? n >= this._prevRotation : n <= this._prevRotation) && (this._prevClockwise = this._prevClockwise > 0 ? this._prevClockwise - 1 : this._prevClockwise + 1), n = this._prevRotation + n - this._prevRotation + t.Transform.PI_D * this._prevClockwise)), this._prevClockwise = i._getNumber(e, t.DataParser.CLOCK_WISE, 0), this._prevRotation = n;

            var s = this._parseTweenFrame(e, a, r),
                o = this._frameFloatArray.length;

            return this._frameFloatArray.length += 2, this._frameFloatArray[o++] = n, this._frameFloatArray[o++] = i._getNumber(e, t.DataParser.SKEW, 0) * t.Transform.DEG_RAD, s;
          }, i.prototype._parseBoneScaleFrame = function (e, a, r) {
            var n = this._parseTweenFrame(e, a, r),
                s = this._frameFloatArray.length;

            return this._frameFloatArray.length += 2, this._frameFloatArray[s++] = i._getNumber(e, t.DataParser.X, 1), this._frameFloatArray[s++] = i._getNumber(e, t.DataParser.Y, 1), n;
          }, i.prototype._parseSurfaceFrame = function (e, a, r) {
            var n = this._frameFloatArray.length,
                s = this._parseTweenFrame(e, a, r),
                o = e[t.DataParser.VERTICES],
                l = i._getNumber(e, t.DataParser.OFFSET, 0),
                h = this._surface.vertices.length / 2,
                u = 0,
                _ = 0;

            this._frameFloatArray.length += 2 * h;

            for (var f = 0; f < 2 * h; f += 2) {
              u = f < l || f - l >= o.length ? 0 : o[f - l], _ = f + 1 < l || f + 1 - l >= o.length ? 0 : o[f + 1 - l], this._frameFloatArray[n + f] = u, this._frameFloatArray[n + f + 1] = _;
            }

            if (0 === a) {
              var c = this._frameIntArray.length;
              this._frameIntArray.length += 5, this._frameIntArray[c + 0] = 0, this._frameIntArray[c + 1] = this._frameFloatArray.length - n, this._frameIntArray[c + 2] = this._frameFloatArray.length - n, this._frameIntArray[c + 3] = 0, this._frameIntArray[c + 4] = n - this._animation.frameFloatOffset, this._timelineArray[this._timeline.offset + 3] = c - this._animation.frameIntOffset;
            }

            return s;
          }, i.prototype._parseSlotDisplayFrame = function (e, a, r) {
            var n = this._parseFrame(e, a, r);

            return this._frameArray.length += 1, t.DataParser.VALUE in e ? this._frameArray[n + 1] = i._getNumber(e, t.DataParser.VALUE, 0) : this._frameArray[n + 1] = i._getNumber(e, t.DataParser.DISPLAY_INDEX, 0), this._parseActionDataInFrame(e, a, this._slot.parent, this._slot), n;
          }, i.prototype._parseSlotColorFrame = function (e, a, i) {
            var r = this._parseTweenFrame(e, a, i),
                n = -1;

            if (t.DataParser.VALUE in e || t.DataParser.COLOR in e) {
              var s = t.DataParser.VALUE in e ? e[t.DataParser.VALUE] : e[t.DataParser.COLOR];

              for (var o in s) {
                this._parseColorTransform(s, this._helpColorTransform), n = this._intArray.length, this._intArray.length += 8, this._intArray[n++] = Math.round(100 * this._helpColorTransform.alphaMultiplier), this._intArray[n++] = Math.round(100 * this._helpColorTransform.redMultiplier), this._intArray[n++] = Math.round(100 * this._helpColorTransform.greenMultiplier), this._intArray[n++] = Math.round(100 * this._helpColorTransform.blueMultiplier), this._intArray[n++] = Math.round(this._helpColorTransform.alphaOffset), this._intArray[n++] = Math.round(this._helpColorTransform.redOffset), this._intArray[n++] = Math.round(this._helpColorTransform.greenOffset), this._intArray[n++] = Math.round(this._helpColorTransform.blueOffset), n -= 8;
                break;
              }
            }

            n < 0 && (this._defaultColorOffset < 0 && (this._defaultColorOffset = n = this._intArray.length, this._intArray.length += 8, this._intArray[n++] = 100, this._intArray[n++] = 100, this._intArray[n++] = 100, this._intArray[n++] = 100, this._intArray[n++] = 0, this._intArray[n++] = 0, this._intArray[n++] = 0, this._intArray[n++] = 0), n = this._defaultColorOffset);
            var l = this._frameIntArray.length;
            return this._frameIntArray.length += 1, this._frameIntArray[l] = n, r;
          }, i.prototype._parseSlotFFDFrame = function (e, a, r) {
            var n = this._frameFloatArray.length,
                s = this._parseTweenFrame(e, a, r),
                o = t.DataParser.VERTICES in e ? e[t.DataParser.VERTICES] : null,
                l = i._getNumber(e, t.DataParser.OFFSET, 0),
                h = this._intArray[this._mesh.vertices.offset + 0],
                u = this._mesh.parent.name + "_" + this._slot.name + "_" + this._mesh.name,
                _ = this._mesh.vertices.weight,
                f = 0,
                c = 0,
                m = 0,
                p = 0;

            if (null !== _) {
              var d = this._weightSlotPose[u];
              this._helpMatrixA.copyFromArray(d, 0), this._frameFloatArray.length += 2 * _.count, m = _.offset + 2 + _.bones.length;
            } else this._frameFloatArray.length += 2 * h;

            for (var y = 0; y < 2 * h; y += 2) {
              if (null === o ? (f = 0, c = 0) : (f = y < l || y - l >= o.length ? 0 : o[y - l], c = y + 1 < l || y + 1 - l >= o.length ? 0 : o[y + 1 - l]), null !== _) {
                var g = this._weightBonePoses[u],
                    v = this._intArray[m++];
                this._helpMatrixA.transformPoint(f, c, this._helpPoint, !0), f = this._helpPoint.x, c = this._helpPoint.y;

                for (var D = 0; D < v; ++D) {
                  var b = this._intArray[m++];
                  this._helpMatrixB.copyFromArray(g, 7 * b + 1), this._helpMatrixB.invert(), this._helpMatrixB.transformPoint(f, c, this._helpPoint, !0), this._frameFloatArray[n + p++] = this._helpPoint.x, this._frameFloatArray[n + p++] = this._helpPoint.y;
                }
              } else this._frameFloatArray[n + y] = f, this._frameFloatArray[n + y + 1] = c;
            }

            if (0 === a) {
              var A = this._frameIntArray.length;
              this._frameIntArray.length += 5, this._frameIntArray[A + 0] = this._mesh.vertices.offset, this._frameIntArray[A + 1] = this._frameFloatArray.length - n, this._frameIntArray[A + 2] = this._frameFloatArray.length - n, this._frameIntArray[A + 3] = 0, this._frameIntArray[A + 4] = n - this._animation.frameFloatOffset, this._timelineArray[this._timeline.offset + 3] = A - this._animation.frameIntOffset;
            }

            return s;
          }, i.prototype._parseIKConstraintFrame = function (e, a, r) {
            var n = this._parseTweenFrame(e, a, r),
                s = this._frameIntArray.length;

            return this._frameIntArray.length += 2, this._frameIntArray[s++] = i._getBoolean(e, t.DataParser.BEND_POSITIVE, !0) ? 1 : 0, this._frameIntArray[s++] = Math.round(100 * i._getNumber(e, t.DataParser.WEIGHT, 1)), n;
          }, i.prototype._parseAnimationFrame = function (e, a, r) {
            var n = this._parseTweenFrame(e, a, r),
                s = this._frameIntArray.length;

            return this._frameIntArray.length += 2, this._frameIntArray[s++] = i._getNumber(e, t.DataParser.VALUE, 0), this._frameIntArray[s++] = Math.round(100 * i._getNumber(e, t.DataParser.WEIGHT, 1)), n;
          }, i.prototype._parseActionData = function (e, a, r, n) {
            var s = new Array();
            if ("string" == typeof e) (u = t.BaseObject.borrowObject(t.ActionData)).type = a, u.name = e, u.bone = r, u.slot = n, s.push(u);else if (e instanceof Array) for (var o = 0, l = e; o < l.length; o++) {
              var h = l[o],
                  u = t.BaseObject.borrowObject(t.ActionData);

              if (t.DataParser.GOTO_AND_PLAY in h ? (u.type = 0, u.name = i._getString(h, t.DataParser.GOTO_AND_PLAY, "")) : (t.DataParser.TYPE in h && "string" == typeof h[t.DataParser.TYPE] ? u.type = t.DataParser._getActionType(h[t.DataParser.TYPE]) : u.type = i._getNumber(h, t.DataParser.TYPE, a), u.name = i._getString(h, t.DataParser.NAME, "")), t.DataParser.BONE in h) {
                var _ = i._getString(h, t.DataParser.BONE, "");

                u.bone = this._armature.getBone(_);
              } else u.bone = r;

              if (t.DataParser.SLOT in h) {
                var f = i._getString(h, t.DataParser.SLOT, "");

                u.slot = this._armature.getSlot(f);
              } else u.slot = n;

              var c = null;

              if (t.DataParser.INTS in h) {
                null === c && (c = t.BaseObject.borrowObject(t.UserData));

                for (var m = 0, p = h[t.DataParser.INTS]; m < p.length; m++) {
                  var d = p[m];
                  c.addInt(d);
                }
              }

              if (t.DataParser.FLOATS in h) {
                null === c && (c = t.BaseObject.borrowObject(t.UserData));

                for (var y = 0, g = h[t.DataParser.FLOATS]; y < g.length; y++) {
                  d = g[y], c.addFloat(d);
                }
              }

              if (t.DataParser.STRINGS in h) {
                null === c && (c = t.BaseObject.borrowObject(t.UserData));

                for (var v = 0, D = h[t.DataParser.STRINGS]; v < D.length; v++) {
                  d = D[v], c.addString(d);
                }
              }

              u.data = c, s.push(u);
            }
            return s;
          }, i.prototype._parseTransform = function (e, a, r) {
            a.x = i._getNumber(e, t.DataParser.X, 0) * r, a.y = i._getNumber(e, t.DataParser.Y, 0) * r, t.DataParser.ROTATE in e || t.DataParser.SKEW in e ? (a.rotation = t.Transform.normalizeRadian(i._getNumber(e, t.DataParser.ROTATE, 0) * t.Transform.DEG_RAD), a.skew = t.Transform.normalizeRadian(i._getNumber(e, t.DataParser.SKEW, 0) * t.Transform.DEG_RAD)) : (t.DataParser.SKEW_X in e || t.DataParser.SKEW_Y in e) && (a.rotation = t.Transform.normalizeRadian(i._getNumber(e, t.DataParser.SKEW_Y, 0) * t.Transform.DEG_RAD), a.skew = t.Transform.normalizeRadian(i._getNumber(e, t.DataParser.SKEW_X, 0) * t.Transform.DEG_RAD) - a.rotation), a.scaleX = i._getNumber(e, t.DataParser.SCALE_X, 1), a.scaleY = i._getNumber(e, t.DataParser.SCALE_Y, 1);
          }, i.prototype._parseColorTransform = function (e, a) {
            a.alphaMultiplier = .01 * i._getNumber(e, t.DataParser.ALPHA_MULTIPLIER, 100), a.redMultiplier = .01 * i._getNumber(e, t.DataParser.RED_MULTIPLIER, 100), a.greenMultiplier = .01 * i._getNumber(e, t.DataParser.GREEN_MULTIPLIER, 100), a.blueMultiplier = .01 * i._getNumber(e, t.DataParser.BLUE_MULTIPLIER, 100), a.alphaOffset = i._getNumber(e, t.DataParser.ALPHA_OFFSET, 0), a.redOffset = i._getNumber(e, t.DataParser.RED_OFFSET, 0), a.greenOffset = i._getNumber(e, t.DataParser.GREEN_OFFSET, 0), a.blueOffset = i._getNumber(e, t.DataParser.BLUE_OFFSET, 0);
          }, i.prototype._parseArray = function () {
            this._intArray.length = 0, this._floatArray.length = 0, this._frameIntArray.length = 0, this._frameFloatArray.length = 0, this._frameArray.length = 0, this._timelineArray.length = 0;
          }, i.prototype._modifyArray = function () {
            this._intArray.length % Int16Array.BYTES_PER_ELEMENT != 0 && this._intArray.push(0), this._frameIntArray.length % Int16Array.BYTES_PER_ELEMENT != 0 && this._frameIntArray.push(0), this._frameArray.length % Int16Array.BYTES_PER_ELEMENT != 0 && this._frameArray.push(0), this._timelineArray.length % Uint16Array.BYTES_PER_ELEMENT != 0 && this._timelineArray.push(0);
            var e = this._intArray.length * Int16Array.BYTES_PER_ELEMENT,
                a = this._floatArray.length * Float32Array.BYTES_PER_ELEMENT,
                i = this._frameIntArray.length * Int16Array.BYTES_PER_ELEMENT,
                r = this._frameFloatArray.length * Float32Array.BYTES_PER_ELEMENT,
                n = this._frameArray.length * Int16Array.BYTES_PER_ELEMENT,
                s = this._timelineArray.length * Uint16Array.BYTES_PER_ELEMENT,
                o = e + a + i + r + n + s;

            if (t.DragonBones.webAssembly) {
              for (var l = t.webAssemblyModule.HEAP16.buffer, h = t.webAssemblyModule._malloc(o), u = new Int16Array(l, h, this._intArray.length), _ = new Float32Array(l, h + e, this._floatArray.length), f = new Int16Array(l, h + e + a, this._frameIntArray.length), c = new Float32Array(l, h + e + a + i, this._frameFloatArray.length), m = new Int16Array(l, h + e + a + i + r, this._frameArray.length), p = new Uint16Array(l, h + e + a + i + r + n, this._timelineArray.length), d = 0, y = this._intArray.length; d < y; ++d) {
                u[d] = this._intArray[d];
              }

              for (d = 0, y = this._floatArray.length; d < y; ++d) {
                _[d] = this._floatArray[d];
              }

              for (d = 0, y = this._frameIntArray.length; d < y; ++d) {
                f[d] = this._frameIntArray[d];
              }

              for (d = 0, y = this._frameFloatArray.length; d < y; ++d) {
                c[d] = this._frameFloatArray[d];
              }

              for (d = 0, y = this._frameArray.length; d < y; ++d) {
                m[d] = this._frameArray[d];
              }

              for (d = 0, y = this._timelineArray.length; d < y; ++d) {
                p[d] = this._timelineArray[d];
              }

              t.webAssemblyModule.setDataBinary(this._data, h, e, a, i, r, n, s);
            } else {
              var g = new ArrayBuffer(o);

              for (u = new Int16Array(g, 0, this._intArray.length), _ = new Float32Array(g, e, this._floatArray.length), f = new Int16Array(g, e + a, this._frameIntArray.length), c = new Float32Array(g, e + a + i, this._frameFloatArray.length), m = new Int16Array(g, e + a + i + r, this._frameArray.length), p = new Uint16Array(g, e + a + i + r + n, this._timelineArray.length), d = 0, y = this._intArray.length; d < y; ++d) {
                u[d] = this._intArray[d];
              }

              for (d = 0, y = this._floatArray.length; d < y; ++d) {
                _[d] = this._floatArray[d];
              }

              for (d = 0, y = this._frameIntArray.length; d < y; ++d) {
                f[d] = this._frameIntArray[d];
              }

              for (d = 0, y = this._frameFloatArray.length; d < y; ++d) {
                c[d] = this._frameFloatArray[d];
              }

              for (d = 0, y = this._frameArray.length; d < y; ++d) {
                m[d] = this._frameArray[d];
              }

              for (d = 0, y = this._timelineArray.length; d < y; ++d) {
                p[d] = this._timelineArray[d];
              }

              this._data.binary = g, this._data.intArray = u, this._data.floatArray = _, this._data.frameIntArray = f, this._data.frameFloatArray = c, this._data.frameArray = m, this._data.timelineArray = p;
            }

            this._defaultColorOffset = -1;
          }, i.prototype.parseDragonBonesData = function (e, a) {
            void 0 === a && (a = 1), console.assert(null != e, "Data error.");

            var r = i._getString(e, t.DataParser.VERSION, ""),
                n = i._getString(e, t.DataParser.COMPATIBLE_VERSION, "");

            if (t.DataParser.DATA_VERSIONS.indexOf(r) >= 0 || t.DataParser.DATA_VERSIONS.indexOf(n) >= 0) {
              var s = t.BaseObject.borrowObject(t.DragonBonesData);

              if (s.version = r, s.name = i._getString(e, t.DataParser.NAME, ""), s.frameRate = i._getNumber(e, t.DataParser.FRAME_RATE, 24), 0 === s.frameRate && (s.frameRate = 24), t.DataParser.ARMATURE in e) {
                this._data = s, this._parseArray(e);

                for (var o = 0, l = e[t.DataParser.ARMATURE]; o < l.length; o++) {
                  var h = l[o];
                  s.addArmature(this._parseArmature(h, a));
                }

                this._data.binary || this._modifyArray(), t.DataParser.STAGE in e ? s.stage = s.getArmature(i._getString(e, t.DataParser.STAGE, "")) : s.armatureNames.length > 0 && (s.stage = s.getArmature(s.armatureNames[0])), this._data = null;
              }

              return t.DataParser.TEXTURE_ATLAS in e && (this._rawTextureAtlases = e[t.DataParser.TEXTURE_ATLAS]), s;
            }

            return console.assert(!1, "Nonsupport data version: " + r + "\nPlease convert DragonBones data to support version.\nRead more: https://github.com/DragonBones/Tools/"), null;
          }, i.prototype.parseTextureAtlasData = function (e, a, r) {
            if (void 0 === r && (r = 1), console.assert(void 0 !== e), null === e) {
              if (null === this._rawTextureAtlases || 0 === this._rawTextureAtlases.length) return !1;
              var n = this._rawTextureAtlases[this._rawTextureAtlasIndex++];
              return this.parseTextureAtlasData(n, a, r), this._rawTextureAtlasIndex >= this._rawTextureAtlases.length && (this._rawTextureAtlasIndex = 0, this._rawTextureAtlases = null), !0;
            }

            if (a.width = i._getNumber(e, t.DataParser.WIDTH, 0), a.height = i._getNumber(e, t.DataParser.HEIGHT, 0), a.scale = 1 === r ? 1 / i._getNumber(e, t.DataParser.SCALE, 1) : r, a.name = i._getString(e, t.DataParser.NAME, ""), a.imagePath = i._getString(e, t.DataParser.IMAGE_PATH, ""), t.DataParser.SUB_TEXTURE in e) for (var s = e[t.DataParser.SUB_TEXTURE], o = 0, l = s.length; o < l; ++o) {
              var h = s[o],
                  u = a.createTexture();
              u.rotated = i._getBoolean(h, t.DataParser.ROTATED, !1), u.name = i._getString(h, t.DataParser.NAME, ""), u.region.x = i._getNumber(h, t.DataParser.X, 0), u.region.y = i._getNumber(h, t.DataParser.Y, 0), u.region.width = i._getNumber(h, t.DataParser.WIDTH, 0), u.region.height = i._getNumber(h, t.DataParser.HEIGHT, 0);

              var _ = i._getNumber(h, t.DataParser.FRAME_WIDTH, -1),
                  f = i._getNumber(h, t.DataParser.FRAME_HEIGHT, -1);

              _ > 0 && f > 0 && (u.frame = t.TextureData.createRectangle(), u.frame.x = i._getNumber(h, t.DataParser.FRAME_X, 0), u.frame.y = i._getNumber(h, t.DataParser.FRAME_Y, 0), u.frame.width = _, u.frame.height = f), a.addTexture(u);
            }
            return !0;
          }, i.getInstance = function () {
            return null === i._objectDataParserInstance && (i._objectDataParserInstance = new i()), i._objectDataParserInstance;
          }, i._objectDataParserInstance = null, i;
        }(t.DataParser);

        t.ObjectDataParser = e;

        var a = function a() {
          this.frameStart = 0, this.actions = [];
        };

        t.ActionFrame = a;
      }(K || (K = {})), function (t) {
        var e = function (e) {
          function a() {
            return null !== e && e.apply(this, arguments) || this;
          }

          return W(a, e), a.prototype._inRange = function (t, e, a) {
            return e <= t && t <= a;
          }, a.prototype._decodeUTF8 = function (t) {
            for (var e, a = 0, i = "", r = 0, n = 0, s = 0, o = 0; t.length > a;) {
              var l = t[a++];
              if (-1 === l) e = 0 !== n ? 65533 : -1;else if (0 === n) this._inRange(l, 0, 127) ? e = l : (this._inRange(l, 194, 223) ? (n = 1, o = 128, r = l - 192) : this._inRange(l, 224, 239) ? (n = 2, o = 2048, r = l - 224) : this._inRange(l, 240, 244) && (n = 3, o = 65536, r = l - 240), r *= Math.pow(64, n), e = null);else if (this._inRange(l, 128, 191)) {
                if (s += 1, r += (l - 128) * Math.pow(64, n - s), s !== n) e = null;else {
                  var h = r,
                      u = o;
                  r = 0, n = 0, s = 0, o = 0, e = this._inRange(h, u, 1114111) && !this._inRange(h, 55296, 57343) ? h : l;
                }
              } else r = 0, n = 0, s = 0, o = 0, a--, e = l;
              null !== e && -1 !== e && (e <= 65535 ? e > 0 && (i += String.fromCharCode(e)) : (e -= 65536, i += String.fromCharCode(55296 + (e >> 10 & 1023)), i += String.fromCharCode(56320 + (1023 & e))));
            }

            return i;
          }, a.prototype._getUTF16Key = function (t) {
            for (var e = 0, a = t.length; e < a; ++e) {
              if (t.charCodeAt(e) > 255) return encodeURI(t);
            }

            return t;
          }, a.prototype._parseBinaryTimeline = function (e, a, i) {
            void 0 === i && (i = null);
            var r = null !== i ? i : t.BaseObject.borrowObject(t.TimelineData);
            r.type = e, r.offset = a, this._timeline = r;
            var n = this._timelineArrayBuffer[r.offset + 2];
            if (1 === n) r.frameIndicesOffset = -1;else {
              var s = 0,
                  o = this._animation.frameCount + 1,
                  l = this._data.frameIndices;
              t.DragonBones.webAssembly ? (s = l.size(), l.resize(s + o, 0)) : (s = l.length, l.length += o), r.frameIndicesOffset = s;

              for (var h = 0, u = 0, _ = 0, f = 0; h < o; ++h) {
                _ + f <= h && u < n && (_ = this._frameArrayBuffer[this._animation.frameOffset + this._timelineArrayBuffer[r.offset + 5 + u]], f = u === n - 1 ? this._animation.frameCount - _ : this._frameArrayBuffer[this._animation.frameOffset + this._timelineArrayBuffer[r.offset + 5 + u + 1]] - _, u++), t.DragonBones.webAssembly ? l.set(s + h, u - 1) : l[s + h] = u - 1;
              }
            }
            return this._timeline = null, r;
          }, a.prototype._parseVertices = function (e, a) {
            a.offset = e[t.DataParser.OFFSET];
            var i = this._intArrayBuffer[a.offset + 3];

            if (i >= 0) {
              var r = t.BaseObject.borrowObject(t.WeightData),
                  n = this._intArrayBuffer[a.offset + 0],
                  s = this._intArrayBuffer[i + 0];
              r.offset = i;

              for (var o = 0; o < s; ++o) {
                var l = this._intArrayBuffer[i + 2 + o];
                r.addBone(this._rawBones[l]);
              }

              for (var h = i + 2 + s, u = 0, _ = (o = 0, n); o < _; ++o) {
                var f = this._intArrayBuffer[h++];
                u += f, h += f;
              }

              r.count = u, a.weight = r;
            }
          }, a.prototype._parseMesh = function (t, e) {
            this._parseVertices(t, e.vertices);
          }, a.prototype._parsePath = function (t, e) {
            this._parseVertices(t, e.vertices);
          }, a.prototype._parseAnimation = function (e) {
            var a = t.BaseObject.borrowObject(t.AnimationData);
            a.frameCount = Math.max(t.ObjectDataParser._getNumber(e, t.DataParser.DURATION, 1), 1), a.playTimes = t.ObjectDataParser._getNumber(e, t.DataParser.PLAY_TIMES, 1), a.duration = a.frameCount / this._armature.frameRate, a.fadeInTime = t.ObjectDataParser._getNumber(e, t.DataParser.FADE_IN_TIME, 0), a.scale = t.ObjectDataParser._getNumber(e, t.DataParser.SCALE, 1), a.name = t.ObjectDataParser._getString(e, t.DataParser.NAME, t.DataParser.DEFAULT_NAME), 0 === a.name.length && (a.name = t.DataParser.DEFAULT_NAME);
            var i = e[t.DataParser.OFFSET];

            if (a.frameIntOffset = i[0], a.frameFloatOffset = i[1], a.frameOffset = i[2], this._animation = a, t.DataParser.ACTION in e && (a.actionTimeline = this._parseBinaryTimeline(0, e[t.DataParser.ACTION])), t.DataParser.Z_ORDER in e && (a.zOrderTimeline = this._parseBinaryTimeline(1, e[t.DataParser.Z_ORDER])), t.DataParser.BONE in e) {
              var r = e[t.DataParser.BONE];

              for (var n in r) {
                var s = r[n];
                t.DragonBones.webAssembly && (n = this._getUTF16Key(n));

                var o = this._armature.getBone(n);

                if (null !== o) for (var l = 0, h = s.length; l < h; l += 2) {
                  var u = s[l],
                      _ = s[l + 1],
                      f = this._parseBinaryTimeline(u, _);

                  this._animation.addBoneTimeline(o, f);
                }
              }
            }

            if (t.DataParser.SURFACE in e) for (var n in r = e[t.DataParser.SURFACE]) {
              s = r[n], t.DragonBones.webAssembly && (n = this._getUTF16Key(n));

              var c = this._armature.getBone(n);

              if (null !== c) for (l = 0, h = s.length; l < h; l += 2) {
                u = s[l], _ = s[l + 1], f = this._parseBinaryTimeline(u, _), this._animation.addSurfaceTimeline(c, f);
              }
            }
            if (t.DataParser.SLOT in e) for (var n in r = e[t.DataParser.SLOT]) {
              s = r[n], t.DragonBones.webAssembly && (n = this._getUTF16Key(n));

              var m = this._armature.getSlot(n);

              if (null !== m) for (l = 0, h = s.length; l < h; l += 2) {
                u = s[l], _ = s[l + 1], f = this._parseBinaryTimeline(u, _), this._animation.addSlotTimeline(m, f);
              }
            }
            if (t.DataParser.CONSTRAINT in e) for (var n in r = e[t.DataParser.CONSTRAINT]) {
              s = r[n], t.DragonBones.webAssembly && (n = this._getUTF16Key(n));

              var p = this._armature.getConstraint(n);

              if (null !== p) for (l = 0, h = s.length; l < h; l += 2) {
                u = s[l], _ = s[l + 1], f = this._parseBinaryTimeline(u, _), this._animation.addConstraintTimeline(p, f);
              }
            }
            if (t.DataParser.ANIMATION in e) for (var n in r = e[t.DataParser.ANIMATION]) {
              for (s = r[n], t.DragonBones.webAssembly && (n = this._getUTF16Key(n)), l = 0, h = s.length; l < h; l += 2) {
                u = s[l], _ = s[l + 1], f = this._parseBinaryTimeline(u, _), this._animation.addAnimationTimeline(n, f);
              }
            }
            return this._animation = null, a;
          }, a.prototype._parseArray = function (e) {
            var a = e[t.DataParser.OFFSET],
                i = a[1],
                r = a[3],
                n = a[5],
                s = a[7],
                o = a[9],
                l = a[11],
                h = new Int16Array(this._binary, this._binaryOffset + a[0], i / Int16Array.BYTES_PER_ELEMENT),
                u = new Float32Array(this._binary, this._binaryOffset + a[2], r / Float32Array.BYTES_PER_ELEMENT),
                _ = new Int16Array(this._binary, this._binaryOffset + a[4], n / Int16Array.BYTES_PER_ELEMENT),
                f = new Float32Array(this._binary, this._binaryOffset + a[6], s / Float32Array.BYTES_PER_ELEMENT),
                c = new Int16Array(this._binary, this._binaryOffset + a[8], o / Int16Array.BYTES_PER_ELEMENT),
                m = new Uint16Array(this._binary, this._binaryOffset + a[10], l / Uint16Array.BYTES_PER_ELEMENT);

            if (t.DragonBones.webAssembly) {
              for (var p = i + r + n + s + o + l, d = t.webAssemblyModule._malloc(p), y = new Uint8Array(this._binary, this._binaryOffset, p / Uint8Array.BYTES_PER_ELEMENT), g = new Uint8Array(t.webAssemblyModule.HEAP16.buffer, d, y.length), v = 0, D = y.length; v < D; ++v) {
                g[v] = y[v];
              }

              t.webAssemblyModule.setDataBinary(this._data, d, i, r, n, s, o, l), this._intArrayBuffer = h, this._floatArrayBuffer = u, this._frameIntArrayBuffer = _, this._frameFloatArrayBuffer = f, this._frameArrayBuffer = c, this._timelineArrayBuffer = m;
            } else this._data.binary = this._binary, this._data.intArray = this._intArrayBuffer = h, this._data.floatArray = this._floatArrayBuffer = u, this._data.frameIntArray = this._frameIntArrayBuffer = _, this._data.frameFloatArray = this._frameFloatArrayBuffer = f, this._data.frameArray = this._frameArrayBuffer = c, this._data.timelineArray = this._timelineArrayBuffer = m;
          }, a.prototype.parseDragonBonesData = function (t, a) {
            void 0 === a && (a = 1), console.assert(null != t && t instanceof ArrayBuffer, "Data error.");
            var i = new Uint8Array(t, 0, 8);
            if (i[0] !== "D".charCodeAt(0) || i[1] !== "B".charCodeAt(0) || i[2] !== "D".charCodeAt(0) || i[3] !== "T".charCodeAt(0)) return console.assert(!1, "Nonsupport data."), null;

            var r = new Uint32Array(t, 8, 1)[0],
                n = new Uint8Array(t, 12, r),
                s = this._decodeUTF8(n),
                o = JSON.parse(s);

            return this._binaryOffset = 12 + r, this._binary = t, e.prototype.parseDragonBonesData.call(this, o, a);
          }, a.getInstance = function () {
            return null === a._binaryDataParserInstance && (a._binaryDataParserInstance = new a()), a._binaryDataParserInstance;
          }, a._binaryDataParserInstance = null, a;
        }(t.ObjectDataParser);

        t.BinaryDataParser = e;
      }(K || (K = {})), function (t) {
        var e = function () {
          function e(a) {
            void 0 === a && (a = null), this.autoSearch = !1, this._dragonBonesDataMap = {}, this._textureAtlasDataMap = {}, this._dragonBones = null, this._dataParser = null, null === e._objectParser && (e._objectParser = new t.ObjectDataParser()), null === e._binaryParser && (e._binaryParser = new t.BinaryDataParser()), this._dataParser = null !== a ? a : e._objectParser;
          }

          return e.prototype._isSupportMesh = function () {
            return !0;
          }, e.prototype._getTextureData = function (t, e) {
            if (t in this._textureAtlasDataMap) for (var a = 0, i = this._textureAtlasDataMap[t]; a < i.length; a++) {
              if (null !== (l = (o = i[a]).getTexture(e))) return l;
            }
            if (this.autoSearch) for (var r in this._textureAtlasDataMap) {
              for (var n = 0, s = this._textureAtlasDataMap[r]; n < s.length; n++) {
                var o, l;
                if ((o = s[n]).autoSearch && null !== (l = o.getTexture(e))) return l;
              }
            }
            return null;
          }, e.prototype._fillBuildArmaturePackage = function (t, e, a, i, r) {
            var n = null,
                s = null;
            if (e.length > 0 && e in this._dragonBonesDataMap && (s = (n = this._dragonBonesDataMap[e]).getArmature(a)), null === s && (0 === e.length || this.autoSearch)) for (var o in this._dragonBonesDataMap) {
              if (n = this._dragonBonesDataMap[o], (0 === e.length || n.autoSearch) && null !== (s = n.getArmature(a))) {
                e = o;
                break;
              }
            }

            if (null !== s) {
              if (t.dataName = e, t.textureAtlasName = r, t.data = n, t.armature = s, t.skin = null, i.length > 0 && (t.skin = s.getSkin(i), null === t.skin && this.autoSearch)) for (var o in this._dragonBonesDataMap) {
                var l = this._dragonBonesDataMap[o].getArmature(i);

                if (null !== l) {
                  t.skin = l.defaultSkin;
                  break;
                }
              }
              return null === t.skin && (t.skin = s.defaultSkin), !0;
            }

            return !1;
          }, e.prototype._buildBones = function (e, a) {
            for (var i = 0, r = e.armature.sortedBones; i < r.length; i++) {
              var n = r[i];
              t.BaseObject.borrowObject(0 === n.type ? t.Bone : t.Surface).init(n, a);
            }
          }, e.prototype._buildSlots = function (e, a) {
            var i = e.skin,
                r = e.armature.defaultSkin;

            if (null !== i && null !== r) {
              var n = {};

              for (var s in r.displays) {
                var o = r.getDisplays(s);
                n[s] = o;
              }

              if (i !== r) for (var s in i.displays) {
                o = i.getDisplays(s), n[s] = o;
              }

              for (var l = 0, h = e.armature.sortedSlots; l < h.length; l++) {
                var u = h[l],
                    _ = u.name in n ? n[u.name] : null,
                    f = this._buildSlot(e, u, a);

                if (f.rawDisplayDatas = _, null !== _) {
                  for (var c = new Array(), m = 0, p = t.DragonBones.webAssembly ? _.size() : _.length; m < p; ++m) {
                    var d = t.DragonBones.webAssembly ? _.get(m) : _[m];
                    null !== d ? c.push(this._getSlotDisplay(e, d, null, f)) : c.push(null);
                  }

                  f._setDisplayList(c);
                }

                f._setDisplayIndex(u.displayIndex, !0);
              }
            }
          }, e.prototype._buildConstraints = function (e, a) {
            var i = e.armature.constraints;

            for (var r in i) {
              var n = i[r];

              switch (n.type) {
                case 0:
                  var s = t.BaseObject.borrowObject(t.IKConstraint);
                  s.init(n, a), a._addConstraint(s);
                  break;

                case 1:
                  var o = t.BaseObject.borrowObject(t.PathConstraint);
                  o.init(n, a), a._addConstraint(o);
                  break;

                default:
                  var l = t.BaseObject.borrowObject(t.IKConstraint);
                  l.init(n, a), a._addConstraint(l);
              }
            }
          }, e.prototype._buildChildArmature = function (t, e, a) {
            return this.buildArmature(a.path, null !== t ? t.dataName : "", "", null !== t ? t.textureAtlasName : "");
          }, e.prototype._getSlotDisplay = function (e, a, i, r) {
            var n = null !== e ? e.dataName : a.parent.parent.parent.name,
                s = null;

            switch (a.type) {
              case 0:
                var o = a;
                null !== e && e.textureAtlasName.length > 0 && (o.texture = this._getTextureData(e.textureAtlasName, a.path)), null === o.texture && (o.texture = this._getTextureData(n, a.path)), s = null !== i && 2 === i.type && this._isSupportMesh() ? r.meshDisplay : r.rawDisplay;
                break;

              case 2:
                var l = a;
                null !== e && e.textureAtlasName.length > 0 && (l.texture = this._getTextureData(e.textureAtlasName, l.path)), null === l.texture && (l.texture = this._getTextureData(n, l.path)), s = this._isSupportMesh() ? r.meshDisplay : r.rawDisplay;
                break;

              case 1:
                var h = a,
                    u = this._buildChildArmature(e, r, a);

                if (null !== u) {
                  if (u.inheritAnimation = h.inheritAnimation, !u.inheritAnimation) {
                    var _ = h.actions.length > 0 ? h.actions : u.armatureData.defaultActions;

                    if (_.length > 0) for (var f = 0, c = _; f < c.length; f++) {
                      var m = c[f],
                          p = t.BaseObject.borrowObject(t.EventObject);
                      t.EventObject.actionDataToInstance(m, p, r.armature), p.slot = r, r.armature._bufferAction(p, !1);
                    } else u.animation.play();
                  }

                  h.armature = u.armatureData;
                }

                s = u;
            }

            return s;
          }, e.prototype.parseDragonBonesData = function (t, a, i) {
            void 0 === a && (a = null), void 0 === i && (i = 1);

            for (var r = t instanceof ArrayBuffer ? e._binaryParser : this._dataParser, n = r.parseDragonBonesData(t, i);;) {
              var s = this._buildTextureAtlasData(null, null);

              if (!r.parseTextureAtlasData(null, s, i)) {
                s.returnToPool();
                break;
              }

              this.addTextureAtlasData(s, a);
            }

            return null !== n && this.addDragonBonesData(n, a), n;
          }, e.prototype.parseTextureAtlasData = function (t, e, a, i) {
            void 0 === a && (a = null), void 0 === i && (i = 1);

            var r = this._buildTextureAtlasData(null, null);

            return this._dataParser.parseTextureAtlasData(t, r, i), this._buildTextureAtlasData(r, e || null), this.addTextureAtlasData(r, a), r;
          }, e.prototype.updateTextureAtlasData = function (t, e) {
            var a = this.getTextureAtlasData(t);
            if (null !== a) for (var i = 0, r = a.length; i < r; ++i) {
              i < e.length && this._buildTextureAtlasData(a[i], e[i]);
            }
          }, e.prototype.getDragonBonesData = function (t) {
            return t in this._dragonBonesDataMap ? this._dragonBonesDataMap[t] : null;
          }, e.prototype.addDragonBonesData = function (t, e) {
            if (void 0 === e && (e = null), (e = null !== e ? e : t.name) in this._dragonBonesDataMap) {
              if (this._dragonBonesDataMap[e] === t) return;
              console.warn("Can not add same name data: " + e);
            } else this._dragonBonesDataMap[e] = t;
          }, e.prototype.removeDragonBonesData = function (t, e) {
            void 0 === e && (e = !0), t in this._dragonBonesDataMap && (e && this._dragonBones.bufferObject(this._dragonBonesDataMap[t]), delete this._dragonBonesDataMap[t]);
          }, e.prototype.getTextureAtlasData = function (t) {
            return t in this._textureAtlasDataMap ? this._textureAtlasDataMap[t] : null;
          }, e.prototype.addTextureAtlasData = function (t, e) {
            void 0 === e && (e = null);
            var a = (e = null !== e ? e : t.name) in this._textureAtlasDataMap ? this._textureAtlasDataMap[e] : this._textureAtlasDataMap[e] = [];
            a.indexOf(t) < 0 && a.push(t);
          }, e.prototype.removeTextureAtlasData = function (t, e) {
            if (void 0 === e && (e = !0), t in this._textureAtlasDataMap) {
              var a = this._textureAtlasDataMap[t];
              if (e) for (var i = 0, r = a; i < r.length; i++) {
                var n = r[i];

                this._dragonBones.bufferObject(n);
              }
              delete this._textureAtlasDataMap[t];
            }
          }, e.prototype.getArmatureData = function (t, e) {
            void 0 === e && (e = "");
            var i = new a();
            return this._fillBuildArmaturePackage(i, e, t, "", "") ? i.armature : null;
          }, e.prototype.clear = function (t) {
            for (var e in void 0 === t && (t = !0), this._dragonBonesDataMap) {
              t && this._dragonBones.bufferObject(this._dragonBonesDataMap[e]), delete this._dragonBonesDataMap[e];
            }

            for (var e in this._textureAtlasDataMap) {
              if (t) for (var a = 0, i = this._textureAtlasDataMap[e]; a < i.length; a++) {
                var r = i[a];

                this._dragonBones.bufferObject(r);
              }
              delete this._textureAtlasDataMap[e];
            }
          }, e.prototype.buildArmature = function (t, e, i, r) {
            void 0 === e && (e = ""), void 0 === i && (i = ""), void 0 === r && (r = "");
            var n = new a();
            if (!this._fillBuildArmaturePackage(n, e || "", t, i || "", r || "")) return console.warn("No armature data: " + t + ", " + (null !== e ? e : "")), null;

            var s = this._buildArmature(n);

            return this._buildBones(n, s), this._buildSlots(n, s), this._buildConstraints(n, s), s.invalidUpdate(null, !0), s.advanceTime(0), s;
          }, e.prototype.replaceDisplay = function (e, a, i) {
            void 0 === i && (i = -1), i < 0 && (i = e.displayIndex), i < 0 && (i = 0), e.replaceDisplayData(a, i);
            var r = e.displayList;

            if (r.length <= i) {
              r.length = i + 1;

              for (var n = 0, s = r.length; n < s; ++n) {
                r[n] || (r[n] = null);
              }
            }

            if (null !== a) {
              var o = e.rawDisplayDatas,
                  l = null;
              o && (t.DragonBones.webAssembly ? i < o.size() && (l = o.get(i)) : i < o.length && (l = o[i])), r[i] = this._getSlotDisplay(null, a, l, e);
            } else r[i] = null;

            e.displayList = r;
          }, e.prototype.replaceSlotDisplay = function (t, e, a, i, r, n) {
            void 0 === n && (n = -1);
            var s = this.getArmatureData(e, t || "");
            if (!s || !s.defaultSkin) return !1;
            var o = s.defaultSkin.getDisplay(a, i);
            return !!o && (this.replaceDisplay(r, o, n), !0);
          }, e.prototype.replaceSlotDisplayList = function (e, a, i, r) {
            var n = this.getArmatureData(a, e || "");
            if (!n || !n.defaultSkin) return !1;
            var s = n.defaultSkin.getDisplays(i);
            if (!s) return !1;

            for (var o = 0, l = 0, h = t.DragonBones.webAssembly ? s.size() : s.length; l < h; ++l) {
              var u = t.DragonBones.webAssembly ? s.get(l) : s[l];
              this.replaceDisplay(r, u, o++);
            }

            return !0;
          }, e.prototype.replaceSkin = function (e, a, i, r) {
            void 0 === i && (i = !1), void 0 === r && (r = null);

            for (var n = !1, s = a.parent.defaultSkin, o = 0, l = e.getSlots(); o < l.length; o++) {
              var h = l[o];

              if (!(null !== r && r.indexOf(h.name) >= 0)) {
                var u = a.getDisplays(h.name);

                if (u || (null !== s && a !== s && (u = s.getDisplays(h.name)), u)) {
                  var _ = t.DragonBones.webAssembly ? u.size() : u.length,
                      f = h.displayList;

                  f.length = _;

                  for (var c = 0, m = _; c < m; ++c) {
                    var p = t.DragonBones.webAssembly ? u.get(c) : u[c];
                    f[c] = null !== p ? this._getSlotDisplay(null, p, null, h) : null;
                  }

                  n = !0, h.rawDisplayDatas = u, h.displayList = f;
                } else i && (h.rawDisplayDatas = null, h.displayList = []);
              }
            }

            return n;
          }, e.prototype.replaceAnimation = function (e, a, i) {
            void 0 === i && (i = !0);
            var r = a.defaultSkin;
            if (null === r) return !1;
            if (i) e.animation.animations = a.animations;else {
              var n = e.animation.animations,
                  s = {};

              for (var o in n) {
                s[o] = n[o];
              }

              for (var o in a.animations) {
                s[o] = a.animations[o];
              }

              e.animation.animations = s;
            }

            for (var l = 0, h = e.getSlots(); l < h.length; l++) {
              for (var u = h[l], _ = 0, f = 0, c = u.displayList; f < c.length; f++) {
                var m = c[f];

                if (m instanceof t.Armature) {
                  var p = r.getDisplays(u.name);

                  if (null !== p && _ < (t.DragonBones.webAssembly ? p.size() : p.length)) {
                    var d = t.DragonBones.webAssembly ? p.get(_) : p[_];

                    if (null !== d && 1 === d.type) {
                      var y = this.getArmatureData(d.path, d.parent.parent.parent.name);
                      y && this.replaceAnimation(m, y, i);
                    }
                  }
                }

                _++;
              }
            }

            return !0;
          }, e.prototype.getAllDragonBonesData = function () {
            return this._dragonBonesDataMap;
          }, e.prototype.getAllTextureAtlasData = function () {
            return this._textureAtlasDataMap;
          }, Object.defineProperty(e.prototype, "clock", {
            get: function get() {
              return this._dragonBones.clock;
            },
            enumerable: !0,
            configurable: !0
          }), Object.defineProperty(e.prototype, "dragonBones", {
            get: function get() {
              return this._dragonBones;
            },
            enumerable: !0,
            configurable: !0
          }), e.prototype.changeSkin = function (t, e, a) {
            return void 0 === a && (a = null), this.replaceSkin(t, e, !1, a);
          }, e.prototype.copyAnimationsToArmature = function (t, e, a, i, r) {
            void 0 === i && (i = ""), void 0 === r && (r = !0);
            var n = this.getArmatureData(e, i);
            return !!n && this.replaceAnimation(t, n, r);
          }, e._objectParser = null, e._binaryParser = null, e;
        }();

        t.BaseFactory = e;

        var a = function a() {
          this.dataName = "", this.textureAtlasName = "", this.skin = null;
        };

        t.BuildArmaturePackage = a;
      }(K || (K = {})), function (t) {
        t.BinaryOffset = {
          WeigthBoneCount: 0,
          WeigthFloatOffset: 1,
          WeigthBoneIndices: 2,
          MeshVertexCount: 0,
          MeshTriangleCount: 1,
          MeshFloatOffset: 2,
          MeshWeightOffset: 3,
          MeshVertexIndices: 4,
          TimelineScale: 0,
          TimelineOffset: 1,
          TimelineKeyFrameCount: 2,
          TimelineFrameValueCount: 3,
          TimelineFrameValueOffset: 4,
          TimelineFrameOffset: 5,
          FramePosition: 0,
          FrameTweenType: 1,
          FrameTweenEasingOrCurveSampleCount: 2,
          FrameCurveSamples: 3,
          DeformMeshOffset: 0,
          DeformCount: 1,
          DeformValueCount: 2,
          DeformValueOffset: 3,
          DeformFloatOffset: 4
        }, t.ArmatureType = {
          Armature: 0,
          MovieClip: 1,
          Stage: 2
        }, t.BoneType = {
          Bone: 0,
          Surface: 1
        }, t.DisplayType = {
          Image: 0,
          Armature: 1,
          Mesh: 2,
          BoundingBox: 3
        }, t.BoundingBoxType = {
          Rectangle: 0,
          Ellipse: 1,
          Polygon: 2
        }, t.ActionType = {
          Play: 0,
          Stop: 1,
          GotoAndPlay: 2,
          GotoAndStop: 3,
          FadeIn: 4,
          FadeOut: 5,
          Frame: 10,
          Sound: 11
        }, t.BlendMode = {
          Normal: 0,
          Add: 1,
          Alpha: 2,
          Darken: 3,
          Difference: 4,
          Erase: 5,
          HardLight: 6,
          Invert: 7,
          Layer: 8,
          Lighten: 9,
          Multiply: 10,
          Overlay: 11,
          Screen: 12,
          Subtract: 13
        }, t.TweenType = {
          None: 0,
          Line: 1,
          Curve: 2,
          QuadIn: 3,
          QuadOut: 4,
          QuadInOut: 5
        }, t.TimelineType = {
          Action: 0,
          ZOrder: 1,
          BoneAll: 10,
          BoneTranslate: 11,
          BoneRotate: 12,
          BoneScale: 13,
          Surface: 50,
          SlotDisplay: 20,
          SlotColor: 21,
          SlotFFD: 22,
          IKConstraint: 30,
          AnimationTime: 40,
          AnimationWeight: 41
        };
      }(K || (K = {}));

      var J,
          q,
          Z,
          Q,
          $,
          tt,
          et,
          at,
          it,
          rt,
          nt,
          st,
          ot,
          lt = K.DragonBones,
          ht = K.BaseObject,
          ut = K.Matrix,
          _t = K.Transform,
          ft = K.ColorTransform,
          ct = K.Point,
          mt = K.Rectangle,
          pt = K.UserData,
          dt = K.ActionData,
          yt = K.DragonBonesData,
          gt = K.ArmatureData,
          vt = K.BoneData,
          Dt = K.SurfaceData,
          bt = K.SlotData,
          At = K.ConstraintData,
          Tt = K.IKConstraintData,
          St = K.PathConstraintData,
          xt = K.CanvasData,
          Pt = K.SkinData,
          Ot = K.VerticesData,
          Ct = K.DisplayData,
          Mt = K.ImageDisplayData,
          Bt = K.ArmatureDisplayData,
          It = K.MeshDisplayData,
          Et = K.BoundingBoxDisplayData,
          wt = K.PathDisplayData,
          Ft = K.WeightData,
          Nt = K.BoundingBoxData,
          Rt = K.RectangleBoundingBoxData,
          kt = K.EllipseBoundingBoxData,
          jt = K.PolygonBoundingBoxData,
          Lt = K.AnimationData,
          Ut = K.TimelineData,
          Vt = K.AnimationConfig,
          Yt = K.TextureAtlasData,
          Xt = K.TextureData,
          Gt = K.DeformVertices,
          Ht = K.Armature,
          zt = K.TransformObject,
          Wt = K.Bone,
          Kt = K.Surface,
          Jt = K.Slot,
          qt = K.Constraint,
          Zt = K.IKConstraint,
          Qt = K.PathConstraint,
          $t = K.WorldClock,
          te = K.Animation,
          ee = K.AnimationState,
          ae = K.BonePose,
          ie = K.BlendState,
          re = K.TimelineState,
          ne = K.TweenTimelineState,
          se = K.BoneTimelineState,
          oe = K.SlotTimelineState,
          le = K.ConstraintTimelineState,
          he = K.ActionTimelineState,
          ue = K.ZOrderTimelineState,
          _e = K.BoneAllTimelineState,
          fe = K.BoneTranslateTimelineState,
          ce = K.BoneRotateTimelineState,
          me = K.BoneScaleTimelineState,
          pe = K.SurfaceTimelineState,
          de = K.SlotDislayTimelineState,
          ye = K.SlotColorTimelineState,
          ge = K.DeformTimelineState,
          ve = K.IKConstraintTimelineState,
          De = K.AnimationTimelineState,
          be = K.EventObject,
          Ae = K.DataParser,
          Te = K.ObjectDataParser,
          Se = K.ActionFrame,
          xe = K.BinaryDataParser,
          Pe = K.BaseFactory,
          Oe = K.BuildArmaturePackage,
          Ce = K.BinaryOffset,
          Me = K.ArmatureType,
          Be = K.BoneType,
          Ie = K.DisplayType,
          Ee = K.BoundingBoxType,
          we = K.ActionType,
          Fe = K.BlendMode,
          Ne = K.TweenType,
          Re = K.TimelineType,
          ke = y("dragonBones.CCTextureAtlasData")(J = function (t) {
        function i() {
          for (var e, a = arguments.length, i = new Array(a), r = 0; r < a; r++) {
            i[r] = arguments[r];
          }

          return (e = t.call.apply(t, [this].concat(i)) || this)._renderTexture = null, e;
        }

        e(i, t), i.toString = function () {
          return "[class dragonBones.CCTextureAtlasData]";
        };
        var r = i.prototype;
        return r.createTexture = function () {
          return ht.borrowObject(je);
        }, r._onClear = function () {
          t.prototype._onClear.call(this), this.renderTexture = null;
        }, a(i, [{
          key: "renderTexture",
          get: function get() {
            return this._renderTexture;
          },
          set: function set(t) {
            if (this._renderTexture = t, t) for (var e in this.textures) {
              var a = this.textures[e];

              if (!a.spriteFrame) {
                var i = null;
                a.rotated ? i = new g(a.region.x, a.region.y, a.region.height, a.region.width) : (i = new g(a.region.x, a.region.y, a.region.width, a.region.height), a.spriteFrame = new V(), a.spriteFrame.texture = t, a.spriteFrame.rect = i);
              }
            } else for (var r in this.textures) {
              this.textures[r].spriteFrame = null;
            }
          }
        }]), i;
      }(Yt)) || J,
          je = y("dragonBones.CCTextureData")(q = function (t) {
        function a() {
          for (var e, a = arguments.length, i = new Array(a), r = 0; r < a; r++) {
            i[r] = arguments[r];
          }

          return (e = t.call.apply(t, [this].concat(i)) || this).spriteFrame = null, e;
        }

        return e(a, t), a.toString = function () {
          return "[class dragonBones.CCTextureData]";
        }, a.prototype._onClear = function () {
          t.prototype._onClear.call(this), this.spriteFrame = null;
        }, a;
      }(Xt)) || q,
          Le = y("dragonBones.CCSlot")(Z = function (t) {
        function a() {
          var e;
          return (e = t.call(this) || this)._localVertices = void 0, e._indices = void 0, e._matrix = void 0, e._worldMatrix = void 0, e._worldMatrixDirty = void 0, e._color = void 0, e._localVertices = [], e._indices = [], e._matrix = new v(), e._worldMatrix = new v(), e._worldMatrixDirty = !0, e._visible = !1, e._color = new D(), e;
        }

        e(a, t), a.toString = function () {
          return "[class dragonBones.CCSlot]";
        };
        var i = a.prototype;
        return i.getTexture = function () {
          return this._textureData ? this._textureData.spriteFrame.texture : null;
        }, i.calculWorldMatrix = function () {
          var t = this._armature._parent;
          t ? this._mulMat(this._worldMatrix, t._worldMatrix, this._matrix) : v.copy(this._worldMatrix, this._matrix), this._worldMatrixDirty = !1;
        }, i._onClear = function () {
          t.prototype._onClear.call(this), this._localVertices.length = 0, this._indices.length = 0, v.identity(this._matrix), v.identity(this._worldMatrix), this._worldMatrixDirty = !0, this._color = new D(), this._visible = !1;
        }, i._onUpdateDisplay = function () {}, i._initDisplay = function () {}, i._addDisplay = function () {
          this._visible = !0;
        }, i._replaceDisplay = function () {}, i._removeDisplay = function () {
          this._visible = !1;
        }, i._disposeDisplay = function () {}, i._updateVisible = function () {
          this._visible = this.parent.visible;
        }, i._updateGlueMesh = function () {}, i._updateZOrder = function () {}, i._updateBlendMode = function () {
          if (this._childArmature) for (var t = this._childArmature.getSlots(), e = 0, a = t.length; e < a; e++) {
            var i = t[e];
            i._blendMode = this._blendMode, i._updateBlendMode();
          }
        }, i._updateColor = function () {
          var t = this._color;
          t.r = 255 * this._colorTransform.redMultiplier, t.g = 255 * this._colorTransform.greenMultiplier, t.b = 255 * this._colorTransform.blueMultiplier, t.a = 255 * this._colorTransform.alphaMultiplier;
        }, i._updateFrame = function () {
          this._indices.length = 0;
          var t = this._indices,
              e = this._localVertices,
              a = 0,
              i = 0,
              r = this._textureData;

          if (this._display && !(this._displayIndex < 0) && r && r.spriteFrame) {
            var n = r.spriteFrame.texture,
                s = n.width,
                o = n.height,
                l = r.region;

            if (0 !== s && 0 !== o) {
              var h = null !== this._deformVertices && this._display === this._meshDisplay ? this._deformVertices.verticesData : null;

              if (h) {
                var u = h.data,
                    _ = u.intArray,
                    f = u.floatArray,
                    c = _[h.offset + Ce.MeshVertexCount],
                    m = _[h.offset + Ce.MeshTriangleCount],
                    p = _[h.offset + Ce.MeshFloatOffset];
                p < 0 && (p += 65536);

                for (var d = p + 2 * c, y = this._armature._armatureData.scale, g = 0, v = 2 * c; g < v; g += 2) {
                  e[i++] = f[p + g] * y, e[i++] = -f[p + g + 1] * y, h.rotated ? (e[i++] = (l.x + (1 - f[d + g]) * l.width) / s, e[i++] = (l.y + f[d + g + 1] * l.height) / o) : (e[i++] = (l.x + f[d + g] * l.width) / s, e[i++] = (l.y + f[d + g + 1] * l.height) / o);
                }

                for (var D = 0; D < 3 * m; ++D) {
                  t[a++] = _[h.offset + Ce.MeshVertexIndices + D];
                }

                e.length = i, t.length = a, h.weight && this._identityTransform();
              } else {
                var b = l.x / s,
                    A = (l.y + l.height) / o,
                    T = (l.x + l.width) / s,
                    S = l.y / o;
                e[i++] = 0, e[i++] = 0, e[i++] = b, e[i++] = A, e[i++] = l.width, e[i++] = 0, e[i++] = T, e[i++] = A, e[i++] = 0, e[i++] = l.height, e[i++] = b, e[i++] = S, e[i++] = l.width, e[i++] = l.height, e[i++] = T, e[i++] = S, t[0] = 0, t[1] = 1, t[2] = 2, t[3] = 1, t[4] = 3, t[5] = 2, e.length = i, t.length = 6;
              }

              this._visibleDirty = !0, this._blendModeDirty = !0, this._colorDirty = !0;
            } else console.error("SpriteFrame " + r.spriteFrame.name + " incorrect size " + s + " x " + o);
          }
        }, i._updateMesh = function () {
          var t = this._armature._armatureData.scale,
              e = this._deformVertices.vertices,
              a = this._deformVertices.bones,
              i = this._deformVertices.verticesData,
              r = i.weight,
              n = e.length > 0 && i.inheritDeform,
              s = this._localVertices;

          if (r) {
            var o = i.data,
                l = o.intArray,
                h = o.floatArray,
                u = l[i.offset + Ce.MeshVertexCount],
                _ = l[r.offset + Ce.WeigthFloatOffset];
            _ < 0 && (_ += 65536);

            for (var f = 0, c = r.offset + Ce.WeigthBoneIndices + a.length, m = _, p = 0, d = 0; f < u; f++, d += 4) {
              for (var y = l[c++], g = 0, v = 0, D = 0; D < y; ++D) {
                var b = a[l[c++]];

                if (null !== b) {
                  var A = b.globalTransformMatrix,
                      T = h[m++],
                      S = h[m++] * t,
                      x = h[m++] * t;
                  n && (S += e[p++], x += e[p++]), g += (A.a * S + A.c * x + A.tx) * T, v += (A.b * S + A.d * x + A.ty) * T;
                }
              }

              s[d] = g, s[d + 1] = -v;
            }
          } else if (n) {
            var P = this._parent._boneData.type !== Be.Bone,
                O = i.data,
                C = O.intArray,
                M = O.floatArray,
                B = C[i.offset + Ce.MeshVertexCount],
                I = C[i.offset + Ce.MeshFloatOffset];
            I < 0 && (I += 65536);

            for (var E = 0, w = B, F = 0; E < w; E++, F += 4) {
              var N = M[I + 2 * E] * t + e[2 * E],
                  R = M[I + 2 * E + 1] * t + e[2 * E + 1];

              if (P) {
                var k = this._parent._getGlobalTransformMatrix(N, R);

                s[F] = k.a * N + k.c * R + k.tx, s[F + 1] = -k.b * N + k.d * R + k.ty;
              } else s[F] = N, s[F + 1] = -R;
            }
          }

          r && this._identityTransform();
        }, i._identityTransform = function () {
          var t = this._matrix;
          t.m00 = 1, t.m01 = 0, t.m04 = -0, t.m05 = -1, t.m12 = 0, t.m13 = 0, this._worldMatrixDirty = !0;
        }, i._updateTransform = function () {
          var t = this._matrix;
          t.m00 = this.globalTransformMatrix.a, t.m01 = this.globalTransformMatrix.b, t.m04 = -this.globalTransformMatrix.c, t.m05 = -this.globalTransformMatrix.d, this._childArmature ? (t.m12 = this.globalTransformMatrix.tx, t.m13 = this.globalTransformMatrix.ty) : (t.m12 = this.globalTransformMatrix.tx - (this.globalTransformMatrix.a * this._pivotX - this.globalTransformMatrix.c * this._pivotY), t.m13 = this.globalTransformMatrix.ty - (this.globalTransformMatrix.b * this._pivotX - this.globalTransformMatrix.d * this._pivotY)), this._worldMatrixDirty = !0;
        }, i.updateWorldMatrix = function () {
          if (this._armature) {
            var t = this._armature._parent;

            if (t && t.updateWorldMatrix(), this._worldMatrixDirty) {
              this.calculWorldMatrix();
              var e = this.childArmature;
              if (!e) return;

              for (var a = e.getSlots(), i = 0, r = a.length; i < r; i++) {
                var n = a[i];
                n && (n._worldMatrixDirty = !0);
              }
            }
          }
        }, i._mulMat = function (t, e, a) {
          var i = e.m00,
              r = e.m01,
              n = e.m04,
              s = e.m05,
              o = e.m12,
              l = e.m13,
              h = a.m00,
              u = a.m01,
              _ = a.m04,
              f = a.m05,
              c = a.m12,
              m = a.m13;
          0 !== r || 0 !== n ? (t.m00 = h * i + u * n, t.m01 = h * r + u * s, t.m04 = _ * i + f * n, t.m05 = _ * r + f * s, t.m12 = i * c + n * m + o, t.m13 = r * c + s * m + l) : (t.m00 = h * i, t.m01 = u * s, t.m04 = _ * i, t.m05 = f * s, t.m12 = i * c + o, t.m13 = s * m + l);
        }, a;
      }(Jt)) || Z,
          Ue = y("dragonBones.CCArmatureDisplay")(Q = function (t) {
        function r() {
          var e;
          return (e = t.call(this) || this).shouldAdvanced = !1, e._ccNode = null, e._ccComponent = null, e._eventTarget = void 0, e._armature = null, e._eventTarget = new i(), e;
        }

        e(r, t);
        var n = r.prototype;
        return n.hasEvent = function () {
          return console.warn("Method not implemented."), !1;
        }, n.addEvent = function () {
          console.warn("Method not implemented.");
        }, n.removeEvent = function () {
          console.warn("Method not implemented.");
        }, n.setEventTarget = function (t) {
          this._eventTarget = t;
        }, n.getRootDisplay = function () {
          var t,
              e = this._armature._parent;
          if (!e) return this;

          for (; e;) {
            t = e, e = e._armature._parent;
          }

          return t._armature.display;
        }, n.convertToRootSpace = function (t) {
          var e = this._armature._parent;
          if (!e) return t;
          e.updateWorldMatrix();
          var a = e._worldMatrix,
              i = new b(0, 0);
          return i.x = t.x * a.m00 + t.y * a.m04 + a.m12, i.y = t.x * a.m01 + t.y * a.m05 + a.m13, i;
        }, n.convertToWorldSpace = function (t) {
          var e,
              a = this.convertToRootSpace(t),
              i = this.getRootNode();
          return null == i || null === (e = i._uiProps.uiTransformComp) || void 0 === e ? void 0 : e.convertToWorldSpaceAR(a);
        }, n.getRootNode = function () {
          var t = this.getRootDisplay();
          return t && t._ccNode;
        }, n.dbInit = function (t) {
          this._armature = t;
        }, n.dbClear = function () {
          this._armature = null;
        }, n.dbUpdate = function () {
          this._ccComponent && this._ccComponent.markForUpdateRenderData();
        }, n.advanceTimeBySelf = function (t) {
          this.shouldAdvanced = !!t;
        }, n.hasDBEventListener = function (t) {
          return this._eventTarget.hasEventListener(t);
        }, n.addDBEventListener = function (t, e, a) {
          this._eventTarget.on(t, e, a);
        }, n.removeDBEventListener = function (t, e, a) {
          this._eventTarget.off(t, e, a);
        }, n.dispatchDBEvent = function (t, e) {
          this._eventTarget.emit(t, e);
        }, a(r, [{
          key: "node",
          get: function get() {
            return this;
          }
        }]), r;
      }(Ct)) || Q,
          Ve = y("CCFactory")((et = tt = function (t) {
        function a() {
          var e;
          (e = t.call(this) || this).id = void 0, e.uuid = void 0, e._slots = void 0;
          var a = new Ue();
          return e._dragonBones = new lt(a), L.getScheduler() && (R.on(k.EVENT_RESTART, e.onRestart, r(e)), e.initUpdate()), e.id = e.uuid = "CCFactory", e;
        }

        e(a, t), a.getInstance = function () {
          return a._factory || (a._factory = new a()), a._factory;
        };
        var i = a.prototype;
        return i.onRestart = function () {
          a._factory = null;
        }, i.initUpdate = function () {
          j.enableForTarget(this), L.getScheduler().scheduleUpdate(this, U.Priority.HIGH, !1);
        }, i.update = function (t) {
          this._dragonBones.advanceTime(t);
        }, i.getDragonBonesDataByRawData = function (t) {
          return (t instanceof ArrayBuffer ? Pe._binaryParser : this._dataParser).parseDragonBonesData(t, 1);
        }, i.buildArmatureDisplay = function (t, e, a, i) {
          var r = this.buildArmature(t, e, a, i);
          return r ? r._display : null;
        }, i.createArmatureNode = function (t, e, a) {
          var i = (a = a || new A()).getComponent("dragonBones.ArmatureDisplay");
          return i || (i = a.addComponent("dragonBones.ArmatureDisplay")), a.name = e, i._armatureName = e, i._dragonAsset = t.dragonAsset, i._dragonAtlasAsset = t.dragonAtlasAsset, i._init(), i;
        }, i._buildTextureAtlasData = function (t, e) {
          return t ? t.renderTexture = e : t = ht.borrowObject(ke), t;
        }, i._sortSlots = function () {
          for (var t = this._slots, e = [], a = 0, i = t.length; a < i; a++) {
            for (var r = t[a], n = r._zOrder, s = !1, o = e.length - 1; o >= 0; o--) {
              if (n >= e[o]._zOrder) {
                e.splice(o + 1, 0, r), s = !0;
                break;
              }
            }

            s || e.unshift(r);
          }

          this._slots = e;
        }, i._buildArmature = function (t) {
          var e = ht.borrowObject(Ht);
          e._skinData = t.skin, e._animation = ht.borrowObject(te), e._animation._armature = e, e._animation.animations = t.armature.animations, e._isChildArmature = !1;
          var a = new Ue();
          return e.init(t.armature, a, a, this._dragonBones), e;
        }, i._buildSlot = function (t, e, a) {
          var i = ht.borrowObject(Le),
              r = i;
          return i.init(e, a, r, r), i;
        }, i.getDragonBonesDataByUUID = function (t) {
          for (var e in this._dragonBonesDataMap) {
            if (-1 !== e.indexOf(t)) return this._dragonBonesDataMap[e];
          }

          return null;
        }, i.removeDragonBonesDataByUUID = function (t, e) {
          for (var a in void 0 === e && (e = !0), this._dragonBonesDataMap) {
            -1 !== a.indexOf(t) && (e && this._dragonBones.bufferObject(this._dragonBonesDataMap[a]), delete this._dragonBonesDataMap[a]);
          }
        }, a;
      }(Pe), tt._factory = null, $ = et)) || $,
          Ye = 1 / 60,
          Xe = [],
          Ge = [],
          He = 0,
          ze = 0,
          We = 0,
          Ke = null,
          Je = null,
          qe = 0,
          Ze = 0,
          Qe = 0,
          $e = 0,
          ta = 0,
          ea = function () {
        function t() {
          this.maxVertexCount = 0, this.maxIndexCount = 0, this._privateMode = !1, this._inited = !1, this._invalid = !0, this._enableCacheAttachedInfo = !1, this.frames = [], this.totalTime = 0, this.isCompleted = !1, this._frameIdx = -1, this._armatureInfo = null, this._animationName = null, this._tempSegments = null, this._tempColors = null, this._tempBoneInfos = null;
        }

        var e = t.prototype;
        return e.init = function (t, e) {
          this._inited = !0, this._armatureInfo = t, this._animationName = e;
        }, e.clear = function () {
          this._inited = !1;

          for (var t = 0, e = this.frames.length; t < e; t++) {
            this.frames[t].segments.length = 0;
          }

          this.invalidAllFrame();
        }, e.begin = function () {
          if (this._invalid) {
            var t = this._armatureInfo,
                e = t.curAnimationCache;
            e && e !== this && (this._privateMode ? e.invalidAllFrame() : e.updateToFrame()), t.armature.animation.play(this._animationName, 1), t.curAnimationCache = this, this._invalid = !1, this._frameIdx = -1, this.totalTime = 0, this.isCompleted = !1;
          }
        }, e.end = function () {
          this._needToUpdate() || (this._armatureInfo.curAnimationCache = null, this.frames.length = this._frameIdx + 1, this.isCompleted = !0);
        }, e._needToUpdate = function (t) {
          return !this._armatureInfo.armature.animation.isCompleted && this.totalTime < 30 && (void 0 === t || this._frameIdx < t);
        }, e.updateToFrame = function (t) {
          if (this._inited && (this.begin(), this._needToUpdate(t))) {
            var e = this._armatureInfo.armature;

            do {
              e.advanceTime(Ye), this._frameIdx++, this.updateFrame(e, this._frameIdx), this.totalTime += Ye;
            } while (this._needToUpdate(t));

            this.end();
          }
        }, e.isInited = function () {
          return this._inited;
        }, e.isInvalid = function () {
          return this._invalid;
        }, e.invalidAllFrame = function () {
          this.isCompleted = !1, this._invalid = !0;
        }, e.updateAllFrame = function () {
          this.invalidAllFrame(), this.updateToFrame();
        }, e.enableCacheAttachedInfo = function () {
          this._enableCacheAttachedInfo || (this._enableCacheAttachedInfo = !0, this.invalidAllFrame());
        }, e.updateFrame = function (t, e) {
          We = 0, He = 0, ze = 0, Ke = null, Je = null, qe = 0, Ze = 0, Qe = 0, $e = 0, ta = 0, this.frames[e] = this.frames[e] || {
            segments: [],
            colors: [],
            boneInfos: [],
            vertices: null,
            uintVert: null,
            indices: null
          };
          var a = this.frames[e],
              i = this._tempSegments = a.segments,
              r = this._tempColors = a.colors,
              n = this._tempBoneInfos = a.boneInfos;
          this._traverseArmature(t, 1), $e > 0 && (r[$e - 1].vfOffset = We), r.length = $e, n.length = He;
          var s = Qe - 1;
          if (s >= 0) if (Ze > 0) {
            var o = i[s];
            o.indexCount = Ze, o.vfCount = 9 * qe, o.vertexCount = qe, i.length = Qe;
          } else i.length = Qe - 1;

          if (0 !== i.length) {
            var l,
                h = a.vertices,
                u = We / 5,
                _ = 9 * u;

            (!h || h.length < We) && (h = a.vertices = new Float32Array(_));

            for (var f = 0, c = 0; f < _;) {
              h[f] = Xe[c++], h[f + 1] = Xe[c++], h[f + 3] = Xe[c++], h[f + 4] = Xe[c++], l = Xe[c++], h[f + 5] = (255 & l) / 255, h[f + 6] = (l >> 8 & 255) / 255, h[f + 7] = (l >> 16 & 255) / 255, h[f + 8] = (l >> 24 & 255) / 255, f += 9;
            }

            var m = a.indices;
            (!m || m.length < ze) && (m = a.indices = new Uint16Array(ze));

            for (var p = 0; p < ze; p++) {
              m[p] = Ge[p];
            }

            a.vertices = h, a.indices = m, this.maxVertexCount = u > this.maxVertexCount ? u : this.maxVertexCount, this.maxIndexCount = m.length > this.maxIndexCount ? m.length : this.maxIndexCount;
          }
        }, e._traverseArmature = function (t, e) {
          var a,
              i,
              r,
              n,
              s,
              o,
              l,
              h,
              u,
              _ = this._tempColors,
              f = this._tempSegments,
              c = this._tempBoneInfos,
              m = t._slots,
              p = t._bones;
          if (this._enableCacheAttachedInfo) for (var d = 0, y = p.length; d < y; d++, He++) {
            var g = p[d],
                v = c[He];
            v || (v = c[He] = {
              globalTransformMatrix: new ut()
            });
            var D = g.globalTransformMatrix;
            v.globalTransformMatrix.copyFrom(D);
          }

          for (var b = 0, A = m.length; b < A; b++) {
            if ((r = m[b])._visible && r._displayData) if (r.updateWorldMatrix(), s = r._color, r.childArmature) this._traverseArmature(r.childArmature, e * s.a / 255);else if (l = r.getTexture()) {
              Ke === l.nativeUrl && Je === r._blendMode || (Ke = l.nativeUrl, Je = r._blendMode, (h = Qe - 1) >= 0 && (Ze > 0 ? ((u = f[h]).indexCount = Ze, u.vertexCount = qe, u.vfCount = 9 * qe) : Qe--), f[Qe] = {
                tex: l,
                blendMode: r._blendMode,
                indexCount: 0,
                vertexCount: 0,
                vfCount: 0
              }, Qe++, Ze = 0, qe = 0), o = (s.a * e << 24 >>> 0) + (s.b << 16) + (s.g << 8) + s.r, ta !== o && (ta = o, $e > 0 && (_[$e - 1].vfOffset = We), _[$e++] = {
                r: s.r,
                g: s.g,
                b: s.b,
                a: s.a * e,
                vfOffset: 0
              }), a = r._localVertices, i = r._indices, n = r._worldMatrix;

              for (var T = 0, S = a.length; T < S;) {
                at = a[T++], it = a[T++], Xe[We++] = at * n.m00 + it * n.m04 + n.m12, Xe[We++] = at * n.m01 + it * n.m05 + n.m13, Xe[We++] = a[T++], Xe[We++] = a[T++], Xe[We++] = o;
              }

              for (var x = 0, P = i.length; x < P; x++) {
                Ge[ze++] = qe + i[x];
              }

              Ze += i.length, qe += a.length / 4;
            }
          }
        }, t;
      }(),
          aa = function () {
        function t() {
          this._privateMode = !1, this._animationPool = {}, this._armatureCache = {};
        }

        var e = t.prototype;
        return e.enablePrivateMode = function () {
          this._privateMode = !0;
        }, e.dispose = function () {
          for (var t in this._armatureCache) {
            var e = this._armatureCache[t];

            if (e) {
              var a = e.armature;
              a && a.dispose();
            }
          }

          this._armatureCache = {}, this._animationPool = {};
        }, e._removeArmature = function (t) {
          var e = this._armatureCache[t],
              a = e.animationsCache;

          for (var i in a) {
            var r = a[i];
            r && (this._animationPool[t + "#" + i] = r, r.clear());
          }

          var n = e.armature;
          n && n.dispose(), delete this._armatureCache[t];
        }, e.resetArmature = function (t) {
          for (var e in this._armatureCache) {
            -1 !== e.indexOf(t) && this._removeArmature(e);
          }
        }, e.getArmatureCache = function (e, a, i) {
          var r,
              n = this._armatureCache[a];
          if (n) r = n.armature;else {
            var s = Ve.getInstance().buildArmatureDisplay(e, a, "", i);
            if (!s || !s._armature) return null;
            if (r = s._armature, !t.canCache(r)) return r.dispose(), null;
            this._armatureCache[a] = {
              armature: r,
              animationsCache: {},
              curAnimationCache: null
            };
          }
          return r;
        }, e.getAnimationCache = function (t, e) {
          var a = this._armatureCache[t];
          return a ? a.animationsCache[e] : null;
        }, e.initAnimationCache = function (t, e) {
          if (!e) return null;
          var a = this._armatureCache[t],
              i = a && a.armature;
          if (!i) return null;
          if (!i.animation.hasAnimation(e)) return null;
          var r = a.animationsCache,
              n = r[e];

          if (!n) {
            var s = t + "#" + e;
            (n = this._animationPool[s]) ? delete this._animationPool[s] : (n = new ea())._privateMode = this._privateMode, n.init(a, e), r[e] = n;
          }

          return n;
        }, e.invalidAnimationCache = function (t) {
          var e = this._armatureCache[t];

          if (e && e.armature) {
            var a = e.animationsCache;

            for (var i in a) {
              a[i].invalidAllFrame();
            }
          }
        }, e.updateAnimationCache = function (t, e) {
          if (e) {
            var a = this.initAnimationCache(t, e);
            if (!a) return;
            a.updateAllFrame();
          } else {
            var i = this._armatureCache[t];
            if (!i || !i.armature) return;
            var r = i.animationsCache;

            for (var n in r) {
              r[n].updateAllFrame();
            }
          }
        }, t.canCache = function (t) {
          for (var e = t._slots, a = 0, i = e.length; a < i; a++) {
            if (e[a].childArmature) return !1;
          }

          return !0;
        }, t;
      }();

      aa.FrameTime = Ye, aa.sharedCache = new aa();

      var ia,
          ra,
          na,
          sa,
          oa,
          la,
          ha,
          ua,
          _a,
          fa = y("dragonBones.DragonBonesAsset")((ot = function (t) {
        function i() {
          for (var e, a = arguments.length, i = new Array(a), n = 0; n < a; n++) {
            i[n] = arguments[n];
          }

          return e = t.call.apply(t, [this].concat(i)) || this, l(e, "_dragonBonesJson", st, r(e)), e._factory = null, e._dragonBonesJsonData = void 0, e._armaturesEnum = null, e;
        }

        e(i, t);
        var s = i.prototype;
        return s.constructctor = function () {
          this.reset();
        }, s.createNode = function (t) {
          var e = new A(this.name);
          return e.addComponent("dragonBones.ArmatureDisplay").dragonAsset = this, t(null, e);
        }, s.reset = function () {
          this._clear();
        }, s.init = function (t, e) {
          this._factory = t, !this._dragonBonesJsonData && this.dragonBonesJson && (this._dragonBonesJsonData = JSON.parse(this.dragonBonesJson));
          var a;

          if (a = this._dragonBonesJsonData ? this._dragonBonesJsonData : this._nativeAsset, !this._uuid) {
            var i = this._factory.getDragonBonesDataByRawData(a);

            i ? this._uuid = i.name : console.warn("dragonbones name is empty");
          }

          var r = this._uuid + "#" + e;
          return this._factory.getDragonBonesData(r) || this._factory.parseDragonBonesData(a instanceof ArrayBuffer ? a : a.buffer instanceof ArrayBuffer ? a.buffer : a, r), r;
        }, s.getArmatureEnum = function () {
          if (this._armaturesEnum) return this._armaturesEnum;
          this.init();

          var t = this._factory.getDragonBonesDataByUUID(this._uuid);

          if (t) {
            for (var e = t.armatureNames, a = {}, i = 0; i < e.length; i++) {
              a[e[i]] = i;
            }

            return this._armaturesEnum = n(a);
          }

          return null;
        }, s.getAnimsEnum = function (t) {
          this.init();

          var e = this._factory.getDragonBonesDataByUUID(this._uuid);

          if (e) {
            var a = e.getArmature(t);
            if (!a) return null;
            var i = {
              "<None>": 0
            },
                r = a.animations,
                s = 0;

            for (var o in r) {
              r.hasOwnProperty(o) && (i[o] = s + 1, s++);
            }

            return n(i);
          }

          return null;
        }, s.destroy = function () {
          return this._clear(), t.prototype.destroy.call(this);
        }, s._clear = function () {
          this._factory && (aa.sharedCache.resetArmature(this._uuid), this._factory.removeDragonBonesDataByUUID(this._uuid, !0));
        }, a(i, [{
          key: "dragonBonesJson",
          get: function get() {
            return this._dragonBonesJson;
          },
          set: function set(t) {
            this._dragonBonesJson = t, this._dragonBonesJsonData = JSON.parse(t), this.reset();
          }
        }]), i;
      }(T), st = s((nt = ot).prototype, "_dragonBonesJson", [S], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return "";
        }
      }), rt = nt)) || rt;

      o.internal.DragonBonesAsset = fa;
      var ca,
          ma = (ia = y("dragonBones.DragonBonesAtlasAsset"), ra = x(P), ia((_a = function (t) {
        function i() {
          var e;
          return e = t.call(this) || this, l(e, "_atlasJson", oa, r(e)), l(e, "_texture", la, r(e)), l(e, "_atlasJsonData", ha, r(e)), e._factory = null, l(e, "_textureAtlasData", ua, r(e)), e._clear(), e;
        }

        e(i, t);
        var n = i.prototype;
        return n.createNode = function (t) {
          var e = new A(this.name);
          return e.addComponent("dragonBones.ArmatureDisplay").dragonAtlasAsset = this, t(null, e);
        }, n.init = function (t) {
          this._factory = t, this._atlasJsonData || (this._atlasJsonData = JSON.parse(this.atlasJson));
          var e = this._atlasJsonData;
          this._uuid = this._uuid || e.name, this._textureAtlasData ? t.addTextureAtlasData(this._textureAtlasData, this._uuid) : this._textureAtlasData = t.parseTextureAtlasData(e, this.texture, this._uuid);
        }, n.destroy = function () {
          return this._clear(), t.prototype.destroy.call(this);
        }, n._clear = function () {
          this._factory && (aa.sharedCache.resetArmature(this._uuid), this._factory.removeTextureAtlasData(this._uuid, !0), this._factory.removeDragonBonesDataByUUID(this._uuid, !0)), this._textureAtlasData = null;
        }, a(i, [{
          key: "atlasJson",
          get: function get() {
            return this._atlasJson;
          },
          set: function set(t) {
            this._atlasJson = t, this._atlasJsonData = JSON.parse(this.atlasJson), this._clear();
          }
        }, {
          key: "texture",
          get: function get() {
            return this._texture;
          },
          set: function set(t) {
            this._texture = t, this._clear();
          }
        }]), i;
      }(T), oa = s((sa = _a).prototype, "_atlasJson", [S], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return "";
        }
      }), la = s(sa.prototype, "_texture", [S, ra], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return null;
        }
      }), ha = s(sa.prototype, "_atlasJsonData", [S], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return {};
        }
      }), ua = s(sa.prototype, "_textureAtlasData", [S], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return null;
        }
      }), na = sa)) || na);
      o.internal.DragonBonesAtlasAsset = ma;

      var pa,
          da,
          ya,
          ga,
          va,
          Da,
          ba,
          Aa,
          Ta,
          Sa,
          xa,
          Pa,
          Oa,
          Ca,
          Ma,
          Ba,
          Ia,
          Ea,
          wa,
          Fa,
          Na,
          Ra,
          ka,
          ja,
          La,
          Ua,
          Va,
          Ya,
          Xa,
          Ga,
          Ha,
          za,
          Wa,
          Ka,
          Ja,
          qa,
          Za,
          Qa,
          $a,
          ti,
          ei,
          ai,
          ii,
          ri,
          ni,
          si,
          oi,
          li,
          hi,
          ui,
          _i = new v(),
          fi = y("dragonBones.AttachUtil")(ca = function () {
        function t() {
          this._inited = !1, this._armature = null, this._armatureNode = null, this._armatureDisplay = null;
        }

        var e = t.prototype;
        return e.init = function (t) {
          this._inited = !0, this._armature = t._armature, this._armatureNode = t.node, this._armatureDisplay = t;
        }, e.reset = function () {
          this._inited = !1, this._armature = null, this._armatureNode = null, this._armatureDisplay = null;
        }, e._syncAttachedNode = function () {
          if (this._inited) {
            this._armatureNode.worldMatrix;

            var t = null,
                e = this._armatureDisplay.isAnimationCached();

            if (!e || !this._armatureDisplay || (t = this._armatureDisplay._curFrame && this._armatureDisplay._curFrame.boneInfos)) for (var a, i, r, n = this._armatureDisplay.sockets, s = this._armatureDisplay.socketNodes, o = this._armature.getBones(), l = n.length - 1; l >= 0; l--) {
              var h = n[l],
                  u = h.target;
              if (u) if (u.isValid) {
                var _ = e ? t[h.boneIndex] : o[h.boneIndex];

                _ && (a = u, i = _.globalTransformMatrix, r = void 0, (r = _i).m00 = i.a, r.m01 = i.b, r.m04 = -i.c, r.m05 = -i.d, r.m12 = i.tx, r.m13 = i.ty, a.matrix = _i);
              } else s.delete(h.path), n.splice(l, 1);
            }
          }
        }, t;
      }()) || ca,
          ci = function (t) {
        function a() {
          var e;
          return (e = t.call(this) || this)._armatures = new Set(), e;
        }

        e(a, t), a.getInstance = function () {
          return a._instance || (a._instance = new a(), L.registerSystem(a.ID, a._instance, U.Priority.HIGH)), a._instance;
        };
        var i = a.prototype;
        return i.add = function (t) {
          t && (this._armatures.has(t) || this._armatures.add(t));
        }, i.remove = function (t) {
          t && this._armatures.has(t) && this._armatures.delete(t);
        }, i.postUpdate = function (t) {
          this._armatures && this._armatures.forEach(function (e) {
            e.updateAnimation(t);
          });
        }, a;
      }(U);

      function mi(t, e, a) {
        c.Attr.setClassAttr(t, e, "type", "Enum"), c.Attr.setClassAttr(t, e, "enumList", n.getList(a));
      }

      ci.ID = "ARMATURE", ci._instance = void 0, o.internal.ArmatureSystem = ci, function (t) {
        t[t.default = -1] = "default";
      }(oi || (oi = {})), h(oi), function (t) {
        t[t["<None>"] = 0] = "<None>";
      }(li || (li = {})), h(li), function (t) {
        t[t.REALTIME = 0] = "REALTIME";
      }(hi || (hi = {})), h(li), function (t) {
        t[t.REALTIME = 0] = "REALTIME", t[t.SHARED_CACHE = 1] = "SHARED_CACHE", t[t.PRIVATE_CACHE = 2] = "PRIVATE_CACHE";
      }(ui || (ui = {})), h(ui);
      var pi = (pa = y("dragonBones.ArmatureDisplay.DragonBoneSocket"), da = x(A), pa((va = s((ga = function ga(t, e) {
        void 0 === t && (t = ""), void 0 === e && (e = null), l(this, "path", va, this), l(this, "target", Da, this), this.boneIndex = null, this.path = t, this.target = e;
      }).prototype, "path", [S, M], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return "";
        }
      }), Da = s(ga.prototype, "target", [da, M, S], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return null;
        }
      }), ya = ga)) || ya);
      u(pi, "dragonBones.ArmatureDisplay.DragonBoneSocket");
      var di = (ba = y("dragonBones.ArmatureDisplay"), Aa = B(), Ta = I(), Sa = x(fa), xa = E(), Pa = x(ma), Oa = E(), Ca = w(), Ma = w(), Ba = F(), Ia = x(oi), Ea = E(), wa = x(li), Fa = F(), Na = E(), Ra = F(), ka = E(), ja = E(), La = E(), Ua = E(), Va = E(), Ya = x([pi]), Xa = E(), ba(Ga = Aa(Ga = Ta(Ga = O((si = ni = function (t) {
        function s() {
          var e;
          return e = t.call(this) || this, l(e, "playTimes", za, r(e)), l(e, "premultipliedAlpha", Wa, r(e)), e._armature = null, e.attachUtil = void 0, l(e, "_defaultArmatureIndexValue", Ka, r(e)), l(e, "_dragonAsset", Ja, r(e)), l(e, "_dragonAtlasAsset", qa, r(e)), l(e, "_armatureName", Za, r(e)), l(e, "_animationName", Qa, r(e)), l(e, "_animationIndexValue", $a, r(e)), e._preCacheMode = -1, e._cacheMode = ui.REALTIME, l(e, "_defaultCacheModeValue", ti, r(e)), l(e, "_timeScale", ei, r(e)), l(e, "_playTimes", ai, r(e)), l(e, "_debugBones", ii, r(e)), e._debugDraw = null, e._armatureKey = "", e._accTime = 0, e._playCount = 0, e._frameCache = null, e._curFrame = null, e._playing = !1, e._armatureCache = null, e._eventTarget = void 0, e._factory = null, e._displayProxy = null, e._drawIdx = 0, e._drawList = new m(function () {
            return {
              material: null,
              texture: null,
              indexOffset: 0,
              indexCount: 0
            };
          }, 1), e.maxVertexCount = 0, e.maxIndexCount = 0, e._materialCache = {}, e._enumArmatures = n({}), e._enumAnimations = n({}), e._socketNodes = new Map(), e._cachedSockets = new Map(), l(e, "_sockets", ri, r(e)), e._inited = void 0, e._cacheModeEnum = void 0, e._eventTarget = new i(), e._inited = !1, e.attachUtil = new fi(), e.initFactory(), mi(r(e), "_animationIndex", e._enumAnimations), mi(r(e), "_defaultArmatureIndex", e._enumArmatures), e._useVertexOpacity = !0, e;
        }

        e(s, t);
        var o = s.prototype;
        return o.initFactory = function () {
          this._factory = Ve.getInstance();
        }, o.onLoad = function () {
          for (var t = this.node.children, e = 0, a = t.length; e < a; e++) {
            var i = t[e];
            0 === (i.name && i.name.search("CHILD_ARMATURE-")) && i.destroy();
          }
        }, o._requestDrawData = function (t, e, a, i) {
          var r = this._drawList.add();

          return r.material = t, r.texture = e, r.indexOffset = a, r.indexCount = i, r;
        }, o.destroyRenderData = function () {
          this._drawList.reset(), t.prototype.destroyRenderData.call(this);
        }, o.getMaterialForBlend = function (t, e) {
          var a = t + "/" + e,
              i = this._materialCache[a];
          if (i) return i;
          var r = this.getMaterial(0);
          return (i = new C({
            parent: r,
            subModelIdx: 0,
            owner: this
          })).recompileShaders({
            USE_LOCAL: !0
          }, 0), this._materialCache[a] = i, i.overridePipelineStates({
            blendState: {
              targets: [{
                blendSrc: t,
                blendDst: e
              }]
            }
          }), i;
        }, o._render = function (t) {
          if (this._renderData && this._drawList) {
            var e = this._renderData,
                a = e.chunk,
                i = a.vertexAccessor,
                r = e.getMeshBuffer(),
                n = r.indexOffset;
            i.appendIndices(a.bufferId, e.indices);

            for (var s = 0; s < this._drawList.length; s++) {
              this._drawIdx = s;
              var o = this._drawList.data[s];

              if (o.texture) {
                var l = r.requireFreeIA(t.device);
                l.firstIndex = n + o.indexOffset, l.indexCount = o.indexCount, t.commitIA(this, l, o.texture, o.material, this.node);
              }
            }
          }
        }, o.__preload = function () {
          t.prototype.__preload.call(this), this._init();
        }, o._init = function () {
          if (this._cacheMode = this._defaultCacheMode, !this._inited) {
            this._inited = !0, this._parseDragonAtlasAsset(), this._refresh();

            for (var t = this.node.children, e = 0, a = t.length; e < a; e++) {
              var i = t[e];
              i && "DEBUG_DRAW_NODE" === i.name && i.destroy();
            }

            this._updateDebugDraw(), this._indexBoneSockets(), this._updateSocketBindings();
          }
        }, o.getArmatureKey = function () {
          return this._armatureKey;
        }, o.setAnimationCacheMode = function (t) {
          this._preCacheMode !== t && (this._cacheMode = t, this._buildArmature(), this._armature && !this.isAnimationCached() && this._factory._dragonBones.clock.add(this._armature), this._updateSocketBindings(), this.markForUpdateRenderData());
        }, o.isAnimationCached = function () {
          return this._cacheMode !== ui.REALTIME;
        }, o.onEnable = function () {
          t.prototype.onEnable.call(this), this._armature && !this.isAnimationCached() && this._factory._dragonBones.clock.add(this._armature), this._flushAssembler(), ci.getInstance().add(this);
        }, o.onDisable = function () {
          t.prototype.onDisable.call(this), this._armature && !this.isAnimationCached() && this._factory._dragonBones.clock.remove(this._armature), ci.getInstance().remove(this);
        }, o._emitCacheCompleteEvent = function () {
          this._eventTarget.emit(be.LOOP_COMPLETE), this._eventTarget.emit(be.COMPLETE);
        }, o.updateAnimation = function (t) {
          if (this.isAnimationCached() && this._frameCache) {
            this.markForUpdateRenderData();
            var e = this._frameCache;

            if (e.isInited()) {
              var a = e.frames;

              if (this._playing) {
                var i = aa.FrameTime;
                0 === this._accTime && 0 === this._playCount && this._eventTarget.emit(be.START), this._accTime += t * this.timeScale * 1;
                var r = Math.floor(this._accTime / i);

                if (e.isCompleted || (e.updateToFrame(r), this._renderData && (this._renderData.vertexCount < e.maxVertexCount || this._renderData.indexCount < e.maxIndexCount) && (this.maxVertexCount = e.maxVertexCount > this.maxVertexCount ? e.maxVertexCount : this.maxVertexCount, this.maxIndexCount = e.maxIndexCount > this.maxIndexCount ? e.maxIndexCount : this.maxIndexCount, this._renderData.resize(this.maxVertexCount, this.maxIndexCount), (!this._renderData.indices || this.maxIndexCount > this._renderData.indices.length) && (this._renderData.indices = new Uint16Array(this.maxIndexCount)))), e.isCompleted && r >= a.length) {
                  if (this._playCount++, this.playTimes > 0 && this._playCount >= this.playTimes) return this._curFrame = a[a.length - 1], this._accTime = 0, this._playing = !1, this._playCount = 0, this._emitCacheCompleteEvent(), void this.attachUtil._syncAttachedNode();
                  this._accTime = 0, r = 0, this._emitCacheCompleteEvent();
                }

                this._curFrame = a[r], this.attachUtil._syncAttachedNode();
              } else e.isInvalid() && (e.updateToFrame(), this._curFrame = a[a.length - 1], this._renderData && (this._renderData.vertexCount < e.maxVertexCount || this._renderData.indexCount < e.maxIndexCount) && (this.maxVertexCount = e.maxVertexCount > this.maxVertexCount ? e.maxVertexCount : this.maxVertexCount, this.maxIndexCount = e.maxIndexCount > this.maxIndexCount ? e.maxIndexCount : this.maxIndexCount, this._renderData.resize(this.maxVertexCount, this.maxIndexCount), (!this._renderData.indices || this.maxIndexCount > this._renderData.indices.length) && (this._renderData.indices = new Uint16Array(this.maxIndexCount))));
            }
          }
        }, o.onDestroy = function () {
          this._materialInstances = this._materialInstances.filter(function (t) {
            return !!t;
          }), this._inited = !1, this._cacheMode === ui.PRIVATE_CACHE ? (this._armatureCache.dispose(), this._armatureCache = null, this._armature = null) : this._cacheMode === ui.SHARED_CACHE ? (this._armatureCache = null, this._armature = null) : this._armature && (this._armature.dispose(), this._armature = null), this._drawList.destroy(), t.prototype.onDestroy.call(this);
        }, o._updateDebugDraw = function () {
          if (this.debugBones) {
            if (!this._debugDraw) {
              var t = new A("DEBUG_DRAW_NODE");
              t.hideFlags |= _.Flags.DontSave | _.Flags.HideInHierarchy;
              var e = t.addComponent(H);
              e.lineWidth = 1, e.strokeColor = new D(255, 0, 0, 255), this._debugDraw = e;
            }

            this._debugDraw.node.parent = this.node;
          } else this._debugDraw && (this._debugDraw.node.parent = null);

          this.markForUpdateRenderData();
        }, o._buildArmature = function () {
          if (this.dragonAsset && this.dragonAtlasAsset && this.armatureName) {
            this._armature && (this._preCacheMode === ui.PRIVATE_CACHE ? this._armatureCache.dispose() : this._preCacheMode === ui.REALTIME && this._armature.dispose(), this._armatureCache = null, this._armature = null, this._displayProxy = null, this._frameCache = null, this._curFrame = null, this._playing = !1, this._preCacheMode = -1), this._cacheMode === ui.SHARED_CACHE ? this._armatureCache = aa.sharedCache : this._cacheMode === ui.PRIVATE_CACHE && (this._armatureCache = new aa(), this._armatureCache.enablePrivateMode());
            var t = this.dragonAtlasAsset._uuid;

            if (this._armatureKey = this.dragonAsset.init(this._factory, t), this.isAnimationCached() && (this._armature = this._armatureCache.getArmatureCache(this.armatureName, this._armatureKey, t), this._armature || (this._cacheMode = ui.REALTIME)), this._preCacheMode = this._cacheMode, this._cacheMode === ui.REALTIME) {
              if (this._displayProxy = this._factory.buildArmatureDisplay(this.armatureName, this._armatureKey, "", t), !this._displayProxy) return;
              this._displayProxy._ccNode = this.node, this._displayProxy._ccComponent = this, this._displayProxy.setEventTarget(this._eventTarget), this._armature = this._displayProxy._armature, this._armature.animation.timeScale = this.timeScale;
            }

            if (this._cacheMode !== ui.REALTIME && this.debugBones && console.warn("Debug bones is invalid in cached mode"), this._armature) {
              var e = this._armature.armatureData.aabb;

              this.node._uiProps.uiTransformComp.setContentSize(e.width, e.height);
            }

            this.attachUtil.init(this), this.animationName && this.playAnimation(this.animationName, this.playTimes), this._flushAssembler();
          }
        }, o.querySockets = function () {
          return this._armature ? (0 === this._cachedSockets.size && this._indexBoneSockets(), Array.from(this._cachedSockets.keys()).sort()) : [];
        }, o.setBlendHash = function () {
          -1 !== this._blendHash && (this._blendHash = -1);
        }, o.querySocketPathByName = function (t) {
          for (var e, a = [], i = f(this._cachedSockets.keys()); !(e = i()).done;) {
            var r = e.value;
            r.endsWith(t) && a.push(r);
          }

          return a;
        }, o._parseDragonAtlasAsset = function () {
          this.dragonAtlasAsset && this.dragonAtlasAsset.init(this._factory);
        }, o._refresh = function () {
          this._buildArmature(), this._indexBoneSockets(), this.markForUpdateRenderData();
        }, o._updateCacheModeEnum = function () {
          this._cacheModeEnum = n({}), this._armature ? Object.assign(this._cacheModeEnum, ui) : Object.assign(this._cacheModeEnum, hi), mi(this, "_defaultCacheMode", this._cacheModeEnum);
        }, o._updateAnimEnum = function () {
          var t;
          t = this.dragonAsset ? this.dragonAsset.getAnimsEnum(this.armatureName) : li, this._enumAnimations = n({}), Object.assign(this._enumAnimations, t || li), n.update(this._enumAnimations), mi(this, "_animationIndex", this._enumAnimations);
        }, o._updateArmatureEnum = function () {
          var t;
          t = this.dragonAsset ? this.dragonAsset.getArmatureEnum() : oi, this._enumArmatures = n({}), Object.assign(this._enumArmatures, t || oi), n.update(this._enumArmatures), mi(this, "_defaultArmatureIndex", this._enumArmatures);
        }, o._indexBoneSockets = function () {
          if (this._armature) {
            this._cachedSockets.clear();

            var t = this._cachedSockets,
                e = function t(e, a, i) {
              if (i.has(e)) return i.get(e);
              var r = a[e];
              if (!r.parent) return i.set(e, r.name), r.path = r.name, r.name;
              var n = t(r.parent._boneIndex, a, i) + "/" + r.name;
              return i.set(e, n), r.path = n, n;
            };

            !function a(i, r) {
              for (var n = r.getBones(), s = new Map(), o = 0; o < n.length; o++) {
                n[o]._boneIndex = o;
              }

              for (var l = 0; l < n.length; l++) {
                e(l, n, s);
              }

              for (var h, u = f(s.keys()); !(h = u()).done;) {
                var _ = h.value;
                t.set("" + i + s.get(_), _);
              }

              for (var c = r.getSlots(), m = 0; m < c.length; m++) {
                c[m].childArmature && a(c[m].name, c[m].childArmature);
              }
            }("", this._armature);
          }
        }, o.playAnimation = function (t, e) {
          if (this.playTimes = void 0 === e ? -1 : e, this.animationName = t, this.isAnimationCached()) {
            var a = this._armatureCache.getAnimationCache(this._armatureKey, t);

            a || (a = this._armatureCache.initAnimationCache(this._armatureKey, t)), a && (this._accTime = 0, this._playCount = 0, this._frameCache = a, this._sockets.length > 0 && this._frameCache.enableCacheAttachedInfo(), this._frameCache.updateToFrame(0), this._playing = !0, this._curFrame = this._frameCache.frames[0]);
          } else if (this._armature) return this._armature.animation.play(t, this.playTimes);

          return this.markForUpdateRenderData(), null;
        }, o.updateAnimationCache = function (t) {
          this.isAnimationCached() && this._armatureCache.updateAnimationCache(this._armatureKey, t);
        }, o.invalidAnimationCache = function () {
          this.isAnimationCached() && this._armatureCache.invalidAnimationCache(this._armatureKey);
        }, o.getArmatureNames = function () {
          var t = this._factory.getDragonBonesData(this._armatureKey);

          return t && t.armatureNames || [];
        }, o.getAnimationNames = function (t) {
          var e = [],
              a = this._factory.getDragonBonesData(this._armatureKey);

          if (a) {
            var i = a.getArmature(t);
            if (i) for (var r in i.animations) {
              i.animations.hasOwnProperty(r) && e.push(r);
            }
          }

          return e;
        }, o.on = function (t, e, a) {
          this.addEventListener(t, e, a);
        }, o.off = function (t, e, a) {
          this.removeEventListener(t, e, a);
        }, o.once = function (t, e, a) {
          this._eventTarget.once(t, e, a);
        }, o.addEventListener = function (t, e, a) {
          this._eventTarget.on(t, e, a);
        }, o.removeEventListener = function (t, e, a) {
          this._eventTarget.off(t, e, a);
        }, o.buildArmature = function (t, e) {
          return this._factory.createArmatureNode(this, t, e);
        }, o.armature = function () {
          return this._armature;
        }, o._flushAssembler = function () {
          var t = s.Assembler.getAssembler(this);
          this._assembler !== t && (this._assembler = t), this._armature && this._assembler && (this._renderData = this._assembler.createData(this), this._renderData && (this.maxVertexCount = this._renderData.vertexCount, this.maxIndexCount = this._renderData.indexCount), this.markForUpdateRenderData(), this._updateColor());
        }, o._updateSocketBindings = function () {
          if (this._armature) {
            this._socketNodes.clear();

            for (var t = 0, e = this._sockets.length; t < e; t++) {
              var a = this._sockets[t];

              if (a.path && a.target) {
                var i = this._cachedSockets.get(a.path);

                if (!i) {
                  console.error("Skeleton data does not contain path " + a.path);
                  continue;
                }

                a.boneIndex = i, this._socketNodes.set(a.path, a.target);
              }
            }
          }
        }, o._verifySockets = function (t) {
          for (var e = 0, a = t.length; e < a; e++) {
            var i = t[e].target;
            !i || i.parent && i.parent === this.node || console.error("Target node " + i.name + " is expected to be a direct child of " + this.node.name);
          }
        }, a(s, [{
          key: "dragonAsset",
          get: function get() {
            return this._dragonAsset;
          },
          set: function set(t) {
            this._dragonAsset = t, this.destroyRenderData(), this._refresh();
          }
        }, {
          key: "dragonAtlasAsset",
          get: function get() {
            return this._dragonAtlasAsset;
          },
          set: function set(t) {
            this._dragonAtlasAsset = t, this._parseDragonAtlasAsset(), this._refresh();
          }
        }, {
          key: "armatureName",
          get: function get() {
            return this._armatureName;
          },
          set: function set(t) {
            this._armatureName = t;
            var e = this.getAnimationNames(this._armatureName);
            (!this.animationName || e.indexOf(this.animationName) < 0) && (this.animationName = ""), this._armature && !this.isAnimationCached() && this._factory._dragonBones.clock.remove(this._armature), this._refresh(), this._armature && !this.isAnimationCached() && this._factory._dragonBones.clock.add(this._armature);
          }
        }, {
          key: "animationName",
          get: function get() {
            return this._animationName;
          },
          set: function set(t) {
            this._animationName = t;
          }
        }, {
          key: "_defaultArmatureIndex",
          get: function get() {
            return this._defaultArmatureIndexValue;
          },
          set: function set(t) {
            this._defaultArmatureIndexValue = t;
            var e = "";

            if (this.dragonAsset) {
              var a;
              if (this.dragonAsset && (a = this.dragonAsset.getArmatureEnum()), !a) return void p(7400, this.name);
              e = a[this._defaultArmatureIndex];
            }

            void 0 !== e ? this.armatureName = e : p(7401, this.name), this.markForUpdateRenderData();
          }
        }, {
          key: "_animationIndex",
          get: function get() {
            return this._animationIndexValue;
          },
          set: function set(t) {
            var e;

            if (this._animationIndexValue = t, 0 !== this._animationIndex) {
              if (this.dragonAsset && (e = this.dragonAsset.getAnimsEnum(this.armatureName)), e) {
                var a = e[this._animationIndex];
                void 0 !== a ? this.playAnimation(a, this.playTimes) : p(7402, this.name);
              }
            } else this.animationName = "";
          }
        }, {
          key: "_defaultCacheMode",
          get: function get() {
            return this._defaultCacheModeValue;
          },
          set: function set(t) {
            if (this._defaultCacheModeValue = t, this._defaultCacheMode !== ui.REALTIME && this._armature && !aa.canCache(this._armature)) return this._defaultCacheMode = ui.REALTIME, void console.warn("Animation cache mode doesn't support skeletal nesting");
            this.setAnimationCacheMode(this._defaultCacheMode);
          }
        }, {
          key: "timeScale",
          get: function get() {
            return this._timeScale;
          },
          set: function set(t) {
            this._timeScale = t, this._armature && !this.isAnimationCached() && (this._armature.animation.timeScale = this.timeScale);
          }
        }, {
          key: "debugBones",
          get: function get() {
            return this._debugBones;
          },
          set: function set(t) {
            this._debugBones = t, this._updateDebugDraw();
          }
        }, {
          key: "sockets",
          get: function get() {
            return this._sockets;
          },
          set: function set(t) {
            this._verifySockets(t), this._sockets = t, this._updateSocketBindings(), t.length > 0 && this._frameCache && this._frameCache.enableCacheAttachedInfo();
          }
        }, {
          key: "socketNodes",
          get: function get() {
            return this._socketNodes;
          }
        }, {
          key: "drawList",
          get: function get() {
            return this._drawList;
          }
        }]), s;
      }(Y), ni.AnimationCacheMode = ui, s((Ha = si).prototype, "dragonAsset", [M, Sa, xa], Object.getOwnPropertyDescriptor(Ha.prototype, "dragonAsset"), Ha.prototype), s(Ha.prototype, "dragonAtlasAsset", [M, Pa, Oa], Object.getOwnPropertyDescriptor(Ha.prototype, "dragonAtlasAsset"), Ha.prototype), s(Ha.prototype, "armatureName", [Ca], Object.getOwnPropertyDescriptor(Ha.prototype, "armatureName"), Ha.prototype), s(Ha.prototype, "animationName", [Ma], Object.getOwnPropertyDescriptor(Ha.prototype, "animationName"), Ha.prototype), s(Ha.prototype, "_defaultArmatureIndex", [Ba, M, Ia, Ea], Object.getOwnPropertyDescriptor(Ha.prototype, "_defaultArmatureIndex"), Ha.prototype), s(Ha.prototype, "_animationIndex", [M, wa, Fa, Na], Object.getOwnPropertyDescriptor(Ha.prototype, "_animationIndex"), Ha.prototype), s(Ha.prototype, "_defaultCacheMode", [M, Ra, ka], Object.getOwnPropertyDescriptor(Ha.prototype, "_defaultCacheMode"), Ha.prototype), s(Ha.prototype, "timeScale", [M, ja, S], Object.getOwnPropertyDescriptor(Ha.prototype, "timeScale"), Ha.prototype), za = s(Ha.prototype, "playTimes", [La, M, S], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return -1;
        }
      }), Wa = s(Ha.prototype, "premultipliedAlpha", [S, M, Ua], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !1;
        }
      }), s(Ha.prototype, "debugBones", [Va, M], Object.getOwnPropertyDescriptor(Ha.prototype, "debugBones"), Ha.prototype), s(Ha.prototype, "sockets", [Ya, Xa], Object.getOwnPropertyDescriptor(Ha.prototype, "sockets"), Ha.prototype), Ka = s(Ha.prototype, "_defaultArmatureIndexValue", [S], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return oi.default;
        }
      }), Ja = s(Ha.prototype, "_dragonAsset", [S], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return null;
        }
      }), qa = s(Ha.prototype, "_dragonAtlasAsset", [S], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return null;
        }
      }), Za = s(Ha.prototype, "_armatureName", [S], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return "";
        }
      }), Qa = s(Ha.prototype, "_animationName", [S], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return "";
        }
      }), $a = s(Ha.prototype, "_animationIndexValue", [S], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 0;
        }
      }), ti = s(Ha.prototype, "_defaultCacheModeValue", [S], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return ui.REALTIME;
        }
      }), ei = s(Ha.prototype, "_timeScale", [S], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 1;
        }
      }), ai = s(Ha.prototype, "_playTimes", [S], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return -1;
        }
      }), ii = s(Ha.prototype, "_debugBones", [S], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !1;
        }
      }), ri = s(Ha.prototype, "_sockets", [S], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return [];
        }
      }), Ga = Ha)) || Ga) || Ga) || Ga) || Ga);
      o.internal.ArmatureDisplay = di;
      var yi,
          gi,
          vi,
          Di,
          bi,
          Ai,
          Ti,
          Si,
          xi,
          Pi,
          Oi,
          Ci,
          Mi,
          Bi,
          Ii,
          Ei,
          wi,
          Fi,
          Ni,
          Ri = new D(255, 0, 0, 255),
          ki = new D(0, 0, 255, 255),
          ji = new D(0, 255, 0, 255),
          Li = 0,
          Ui = 0,
          Vi = 0,
          Yi = 0,
          Xi = 0,
          Gi = 0,
          Hi = 0,
          zi = 0,
          Wi = 0,
          Ki = new Float32Array(4),
          Ji = new v(),
          qi = null,
          Zi = null;

      function Qi(t, e) {
        if (!t) return null;
        var a, i;

        switch (e) {
          case 1:
            a = bi ? d.ONE : d.SRC_ALPHA, i = d.ONE;
            break;

          case 10:
            a = d.DST_COLOR, i = d.ONE_MINUS_SRC_ALPHA;
            break;

          case 12:
            a = d.ONE, i = d.ONE_MINUS_SRC_COLOR;
            break;

          case 0:
          default:
            a = bi ? d.ONE : d.SRC_ALPHA, i = d.ONE_MINUS_SRC_ALPHA;
        }

        return Pi.setBlendHash(), Pi.getMaterialForBlend(a, i);
      }

      function $i(t, e) {
        var a = t.a * e * Di,
            i = bi ? a / 255 : 1,
            r = t.r * yi * i / 255,
            n = t.g * gi * i / 255,
            s = t.b * vi * i / 255;
        Ki[0] = r, Ki[1] = n, Ki[2] = s, Ki[3] = bi ? 1 : a / 255;
      }

      var tr = null,
          er = {
        accessor: tr,
        vCount: 32767,
        ensureAccessor: function ensureAccessor() {
          if (!tr) {
            var t = L.root.device,
                e = L.root.batcher2D,
                a = G;
            this.accessor = tr = new z(t, a, this.vCount), e.registerBufferAccessor(Number.parseInt("DRAGONBONES", 36), tr);
          }

          return this.accessor;
        },
        createData: function createData(t) {
          var e = t.renderData;

          if (!e) {
            this.ensureAccessor();

            for (var a = t._armature._slots, i = 0, r = 0, n = 0; n < a.length; ++n) {
              var s = a[n];
              i += s._localVertices.length / 4, r += s._indices.length;
            }

            (e = X.add(G, this.accessor)).resize(i, r), e.indices && r === e.indices.length || (e.indices = new Uint16Array(r));
          }

          return e;
        },
        updateRenderData: function updateRenderData(t) {
          Pi = t, t._armature && function (t) {
            var e = t._armature;

            if (e) {
              Ai = !0, bi = t.premultipliedAlpha, t.drawList.reset(), Pi = t, t.node, Ti = t.renderData, Pi = t, Mi = 0, qi = null;
              var a,
                  i = t.color;
              if (yi = i.r / 255, gi = i.g / 255, vi = i.b / 255, Di = t.node._uiProps.opacity, 4294967295 !== i._val && (Mi |= 1), Li = 0, Vi = 0, Yi = 0, Xi = 0, Gi = 0, Wi = 0, Hi = Pi.maxVertexCount, zi = Pi.maxIndexCount, t.isAnimationCached()) !function (t) {
                if (t) {
                  var e = t.segments;

                  if (0 !== e.length) {
                    var a = null,
                        i = t.vertices,
                        r = t.indices,
                        n = 0,
                        s = 0,
                        o = 0,
                        l = 0,
                        h = 0,
                        u = t.colors,
                        _ = u[h++],
                        f = _.vfOffset;
                    $i(_, 1);

                    for (var c = Ti, m = c.chunk.vb, p = c.indices, d = 0, y = e.length; d < y; d++) {
                      var g = e[d];

                      if (a = Qi(g.tex, g.blendMode)) {
                        if (qi || (qi = a), Ai || a.hash !== qi.hash || g.tex && g.tex !== Zi) {
                          Ai = !1;
                          var v = Gi - Wi;
                          v > 0 && (Pi._requestDrawData(qi, Zi, Wi, v), Wi = Gi), qi = a, Zi = g.tex;
                        }

                        Ui = g.vertexCount, Xi = g.indexCount, n = c.chunk.vertexOffset;

                        for (var D = Gi, b = Gi + Xi; D < b; D++) {
                          p[D] = n + Vi + r[o++];
                        }

                        l = g.vfCount;
                        var A = i.subarray(s, l);
                        m.set(A, s);
                        if (1 & Mi) for (var T = s / 9 * 5, S = s, x = s + l; S < x; S += 9, T += 5) {
                          T >= f && ($i(_ = u[h++], 1), f = _.vfOffset), m.set(Ki, S + 5);
                        }
                        s += l, Vi += Ui, Gi += Xi, Ui = 0, Xi = 0;
                      }
                    }

                    var P = Gi - Wi;
                    Zi && P > 0 && Pi._requestDrawData(qi, Zi, Wi, P);
                  }
                }
              }(t._curFrame);else {
                ar(e, 1, a);
                var r = t._debugDraw;

                if (t.debugBones && r) {
                  r.clear(), r.lineWidth = 5, r.strokeColor = Ri, r.fillColor = ki;

                  for (var n = e.getBones(), s = 0, o = n.length; s < o; s++) {
                    var l = n[s],
                        h = Math.max(l.boneData.length, 5),
                        u = l.globalTransformMatrix.tx,
                        _ = l.globalTransformMatrix.ty,
                        f = u + l.globalTransformMatrix.a * h,
                        c = _ + l.globalTransformMatrix.b * h;
                    r.moveTo(u, _), r.lineTo(f, c), r.stroke(), r.circle(u, _, 2 * Math.PI), r.fill(), 0 === s && (r.fillColor = ji);
                  }
                }
              }
              tr.getMeshBuffer(Ti.chunk.bufferId).setDirty(), t.attachUtil._syncAttachedNode(), Pi = void 0;
            }
          }(t);
        },
        updateColor: function updateColor(t) {
          t && (Pi = t).markForUpdateRenderData();
        }
      };

      function ar(t, e, a) {
        var i = Ti;
        xi = i.chunk.vb, Si = i.indices;

        for (var r, n, s, o, l, h, u = t._slots, _ = 0, f = u.length; _ < f; _++) {
          if (o = (l = u[_])._color, l._visible && l._displayData) if (a ? l._mulMat(l._worldMatrix, a, l._matrix) : v.copy(l._worldMatrix, l._matrix), l.childArmature) ar(l.childArmature, o.a / 255, l._worldMatrix);else if (r = Qi(l.getTexture(), l._blendMode)) {
            qi || (qi = r);
            var c = l.getTexture();

            if (Ai || r.hash !== qi.hash || c && Zi !== c) {
              Ai = !1;
              var m = Gi - Wi;
              m > 0 && (Pi._requestDrawData(qi, Zi, Wi, m), Wi = Gi), Zi = c, qi = r;
            }

            $i(o, e), Ji.set(l._worldMatrix), n = l._localVertices, Ui = n.length / 4, Li = 9 * Ui, s = l._indices, Xi = s.length;
            var p = !1;

            if (Vi + Ui > Hi && (Hi = Vi + Ui, p = !0), Gi + Xi > zi && (zi = Gi + Xi, p = !0), p) {
              var d = Si,
                  y = i.chunk.vertexOffset;
              i.resizeAndCopy(Hi, zi > i.indexCount ? zi : i.indexCount), xi = i.chunk.vb, zi > Si.length && (Si = i.indices = new Uint16Array(zi));

              for (var g = i.chunk.vertexOffset - y, D = 0; D < Gi; ++D) {
                Si[D] = d[D] + g;
              }
            }

            Bi = Ji.m00, Ii = Ji.m04, Ei = Ji.m12, wi = Ji.m01, Fi = Ji.m05, Ni = Ji.m13;

            for (var b = 0, A = n.length, T = Yi; b < A; T += 9) {
              Oi = n[b++], Ci = n[b++], xi[T] = Oi * Bi + Ci * Ii + Ei, xi[T + 1] = Oi * wi + Ci * Fi + Ni, xi[T + 3] = n[b++], xi[T + 4] = n[b++], xi.set(Ki, T + 5);
            }

            for (var S = i.chunk.vertexOffset, x = 0, P = s.length, O = Gi; x < P; x++, O++) {
              Si[O] = Vi + s[x] + S;
            }

            Yi += Li, Vi += Ui, Gi += Xi, Ui = 0, Xi = 0;
          }
        }

        h = Gi - Wi, Zi && h > 0 && (Pi._requestDrawData(qi, Zi, Wi, h), Wi = Gi), Pi.maxIndexCount < zi && (Pi.maxIndexCount = zi), Pi.maxVertexCount < Hi && (Pi.maxVertexCount = Hi);
      }

      o.internal.DragonBonesAssembler = er;
      var ir,
          rr,
          nr,
          sr = {
        getAssembler: function getAssembler() {
          return er;
        }
      };
      di.Assembler = sr, N(di.prototype, "ArmatureDisplay", [{
        name: "_enableBatch",
        suggest: "Not support batch render mode"
      }]), function (t) {
        t[t.FFD = 0] = "FFD", t[t.AdjustColor = 10] = "AdjustColor", t[t.BevelFilter = 11] = "BevelFilter", t[t.BlurFilter = 12] = "BlurFilter", t[t.DropShadowFilter = 13] = "DropShadowFilter", t[t.GlowFilter = 14] = "GlowFilter", t[t.GradientBevelFilter = 15] = "GradientBevelFilter", t[t.GradientGlowFilter = 16] = "GradientGlowFilter";
      }(ir || (ir = {})), function (t) {
        t[t.Frame = 0] = "Frame", t[t.Sound = 1] = "Sound";
      }(rr || (rr = {})), function (t) {
        t[t.None = 0] = "None", t[t.SameLayer = 1] = "SameLayer", t[t.SameGroup = 2] = "SameGroup", t[t.SameLayerAndGroup = 3] = "SameLayerAndGroup", t[t.All = 4] = "All";
      }(nr || (nr = {})), t("dragonBones", Object.freeze({
        __proto__: null,

        get ExtensionType() {
          return ir;
        },

        get EventType() {
          return rr;
        },

        get AnimationFadeOutMode() {
          return nr;
        },

        CCFactory: Ve,
        CCSlot: Le,
        CCTextureAtlasData: ke,
        CCTextureData: je,
        CCArmatureDisplay: Ue,
        AnimationCache: ea,
        ArmatureCache: aa,
        DragonBonesAsset: fa,
        DragonBonesAtlasAsset: ma,
        timeScale: 1,

        get AnimationCacheMode() {
          return ui;
        },

        DragonBoneSocket: pi,
        ArmatureDisplay: di,
        AttachUtil: fi,
        simpleDragonBoneAssembler: sr,
        DragonBones: lt,
        BaseObject: ht,
        Matrix: ut,
        Transform: _t,
        ColorTransform: ft,
        Point: ct,
        Rectangle: mt,
        UserData: pt,
        ActionData: dt,
        DragonBonesData: yt,
        ArmatureData: gt,
        BoneData: vt,
        SurfaceData: Dt,
        SlotData: bt,
        ConstraintData: At,
        IKConstraintData: Tt,
        PathConstraintData: St,
        CanvasData: xt,
        SkinData: Pt,
        VerticesData: Ot,
        DisplayData: Ct,
        ImageDisplayData: Mt,
        ArmatureDisplayData: Bt,
        MeshDisplayData: It,
        BoundingBoxDisplayData: Et,
        PathDisplayData: wt,
        WeightData: Ft,
        BoundingBoxData: Nt,
        RectangleBoundingBoxData: Rt,
        EllipseBoundingBoxData: kt,
        PolygonBoundingBoxData: jt,
        AnimationData: Lt,
        TimelineData: Ut,
        AnimationConfig: Vt,
        TextureAtlasData: Yt,
        TextureData: Xt,
        DeformVertices: Gt,
        Armature: Ht,
        TransformObject: zt,
        Bone: Wt,
        Surface: Kt,
        Slot: Jt,
        Constraint: qt,
        IKConstraint: Zt,
        PathConstraint: Qt,
        WorldClock: $t,
        Animation: te,
        AnimationState: ee,
        BonePose: ae,
        BlendState: ie,
        TimelineState: re,
        TweenTimelineState: ne,
        BoneTimelineState: se,
        SlotTimelineState: oe,
        ConstraintTimelineState: le,
        ActionTimelineState: he,
        ZOrderTimelineState: ue,
        BoneAllTimelineState: _e,
        BoneTranslateTimelineState: fe,
        BoneRotateTimelineState: ce,
        BoneScaleTimelineState: me,
        SurfaceTimelineState: pe,
        SlotDislayTimelineState: de,
        SlotColorTimelineState: ye,
        DeformTimelineState: ge,
        IKConstraintTimelineState: ve,
        AnimationTimelineState: De,
        EventObject: be,
        DataParser: Ae,
        ObjectDataParser: Te,
        ActionFrame: Se,
        BinaryDataParser: xe,
        BaseFactory: Pe,
        BuildArmaturePackage: Oe,
        BinaryOffset: Ce,
        ArmatureType: Me,
        BoneType: Be,
        DisplayType: Ie,
        BoundingBoxType: Ee,
        ActionType: we,
        BlendMode: Fe,
        TweenType: Ne,
        TimelineType: Re
      }));
    }
  };
}); 
 			}); 
		define("__plugin__/wx0446ba2621dda60a/gfx-webgl.js", function(require, module, exports){ 			
"use strict";

var _typeof2 = require("@babel/runtime/helpers/typeof");

System.register(["./texture-barrier-60b5983b.js"], function (e) {
  "use strict";

  var t, r, s, a, n, i, u, l, _, o, c, f, E, h, T, R, g, d, A, S, p, C, B, m, x, b, P, F, v, G, O, I, y, L, D, M, N, U, w, k, X, H, V, W, z, K, Y, q, j, Z, Q, $, J, ee, te, re, se, ae, ne, ie, ue, le, _e, oe, ce, fe, Ee, he, Te, Re, ge, de;

  return {
    setters: [function (e) {
      t = e.bT, r = e.b0, s = e.b1, a = e.bU, n = e.D, i = e.a9, u = e.a5, l = e.aY, _ = e.an, o = e.q, c = e.o, f = e.r, E = e.f, h = e.a$, T = e.b5, R = e.bL, g = e.av, d = e.T, A = e.m, S = e.L, p = e.I, C = e.Z, B = e.e, m = e.$, x = e.t, b = e.J, P = e.C, F = e.cH, v = e.B, G = e.a0, O = e.a4, I = e.j, y = e.bb, L = e.bc, D = e.b2, M = e.bd, N = e.be, U = e.bk, w = e.bl, k = e.bm, X = e.x, H = e.bn, V = e.bo, W = e.ag, z = e.bf, K = e.bg, Y = e.bi, q = e.b4, j = e.b6, Z = e.aq, Q = e.s, $ = e.bp, J = e.d, ee = e.w, te = e.bR, re = e.bS, se = e.cd, ae = e.bQ, ne = e.cw, ie = e.af, ue = e.ba, le = e.A, _e = e.aT, oe = e.a2, ce = e.aS, fe = e.i, Ee = e.F, he = e.u, Te = e.bq, Re = e.br, ge = e.b9, de = e.l;
    }],
    execute: function execute() {
      var Ae,
          Se = function (e) {
        function n() {
          for (var t, r = arguments.length, s = new Array(r), a = 0; a < r; a++) {
            s[a] = arguments[a];
          }

          return (t = e.call.apply(e, [this].concat(s)) || this)._gpuDescriptorSet = null, t;
        }

        t(n, e);
        var i = n.prototype;
        return i.initialize = function (e) {
          this._layout = e.layout;
          var t = e.layout.gpuDescriptorSetLayout,
              r = t.bindings,
              s = t.descriptorIndices,
              a = t.descriptorCount;
          this._buffers = Array(a).fill(null), this._textures = Array(a).fill(null), this._samplers = Array(a).fill(null);
          var n = [];
          this._gpuDescriptorSet = {
            gpuDescriptors: n,
            descriptorIndices: s
          };

          for (var i = 0; i < r.length; ++i) {
            for (var u = r[i], l = 0; l < u.count; l++) {
              n.push({
                type: u.descriptorType,
                gpuBuffer: null,
                gpuTexture: null,
                gpuSampler: null
              });
            }
          }
        }, i.destroy = function () {
          this._layout = null, this._gpuDescriptorSet = null;
        }, i.update = function () {
          if (this._isDirty && this._gpuDescriptorSet) {
            for (var e = this._gpuDescriptorSet.gpuDescriptors, t = 0; t < e.length; ++t) {
              if (e[t].type & r) {
                var a = this._buffers[t];
                a && (e[t].gpuBuffer = a.gpuBuffer || a.gpuBufferView);
              } else e[t].type & s && (this._textures[t] && (e[t].gpuTexture = this._textures[t].gpuTexture), this._samplers[t] && (e[t].gpuSampler = this._samplers[t].gpuSampler));
            }

            this._isDirty = !1;
          }
        }, a(n, [{
          key: "gpuDescriptorSet",
          get: function get() {
            return this._gpuDescriptorSet;
          }
        }]), n;
      }(n);

      !function (e) {
        e[e.RGBA16F_EXT = 34842] = "RGBA16F_EXT", e[e.RGB16F_EXT = 34843] = "RGB16F_EXT", e[e.RGBA32F_EXT = 34836] = "RGBA32F_EXT", e[e.FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT = 33297] = "FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT", e[e.UNSIGNED_NORMALIZED_EXT = 35863] = "UNSIGNED_NORMALIZED_EXT", e[e.UNSIGNED_INT_24_8_WEBGL = 34042] = "UNSIGNED_INT_24_8_WEBGL", e[e.HALF_FLOAT_OES = 36193] = "HALF_FLOAT_OES", e[e.SRGB_EXT = 35904] = "SRGB_EXT", e[e.SRGB_ALPHA_EXT = 35906] = "SRGB_ALPHA_EXT", e[e.SRGB8_ALPHA8_EXT = 35907] = "SRGB8_ALPHA8_EXT", e[e.COMPRESSED_RGB_S3TC_DXT1_EXT = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT", e[e.COMPRESSED_RGBA_S3TC_DXT1_EXT = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT", e[e.COMPRESSED_RGBA_S3TC_DXT3_EXT = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT", e[e.COMPRESSED_RGBA_S3TC_DXT5_EXT = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT", e[e.COMPRESSED_SRGB_S3TC_DXT1_EXT = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT", e[e.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT", e[e.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT", e[e.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT", e[e.COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG", e[e.COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG", e[e.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG", e[e.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG", e[e.COMPRESSED_RGB_ETC1_WEBGL = 36196] = "COMPRESSED_RGB_ETC1_WEBGL", e[e.COMPRESSED_R11_EAC = 37488] = "COMPRESSED_R11_EAC", e[e.COMPRESSED_SIGNED_R11_EAC = 37489] = "COMPRESSED_SIGNED_R11_EAC", e[e.COMPRESSED_RG11_EAC = 37490] = "COMPRESSED_RG11_EAC", e[e.COMPRESSED_SIGNED_RG11_EAC = 37491] = "COMPRESSED_SIGNED_RG11_EAC", e[e.COMPRESSED_RGB8_ETC2 = 37492] = "COMPRESSED_RGB8_ETC2", e[e.COMPRESSED_SRGB8_ETC2 = 37493] = "COMPRESSED_SRGB8_ETC2", e[e.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37494] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2", e[e.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37495] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2", e[e.COMPRESSED_RGBA8_ETC2_EAC = 37496] = "COMPRESSED_RGBA8_ETC2_EAC", e[e.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 37497] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC", e[e.COMPRESSED_RGBA_ASTC_4x4_KHR = 37808] = "COMPRESSED_RGBA_ASTC_4x4_KHR", e[e.COMPRESSED_RGBA_ASTC_5x4_KHR = 37809] = "COMPRESSED_RGBA_ASTC_5x4_KHR", e[e.COMPRESSED_RGBA_ASTC_5x5_KHR = 37810] = "COMPRESSED_RGBA_ASTC_5x5_KHR", e[e.COMPRESSED_RGBA_ASTC_6x5_KHR = 37811] = "COMPRESSED_RGBA_ASTC_6x5_KHR", e[e.COMPRESSED_RGBA_ASTC_6x6_KHR = 37812] = "COMPRESSED_RGBA_ASTC_6x6_KHR", e[e.COMPRESSED_RGBA_ASTC_8x5_KHR = 37813] = "COMPRESSED_RGBA_ASTC_8x5_KHR", e[e.COMPRESSED_RGBA_ASTC_8x6_KHR = 37814] = "COMPRESSED_RGBA_ASTC_8x6_KHR", e[e.COMPRESSED_RGBA_ASTC_8x8_KHR = 37815] = "COMPRESSED_RGBA_ASTC_8x8_KHR", e[e.COMPRESSED_RGBA_ASTC_10x5_KHR = 37816] = "COMPRESSED_RGBA_ASTC_10x5_KHR", e[e.COMPRESSED_RGBA_ASTC_10x6_KHR = 37817] = "COMPRESSED_RGBA_ASTC_10x6_KHR", e[e.COMPRESSED_RGBA_ASTC_10x8_KHR = 37818] = "COMPRESSED_RGBA_ASTC_10x8_KHR", e[e.COMPRESSED_RGBA_ASTC_10x10_KHR = 37819] = "COMPRESSED_RGBA_ASTC_10x10_KHR", e[e.COMPRESSED_RGBA_ASTC_12x10_KHR = 37820] = "COMPRESSED_RGBA_ASTC_12x10_KHR", e[e.COMPRESSED_RGBA_ASTC_12x12_KHR = 37821] = "COMPRESSED_RGBA_ASTC_12x12_KHR", e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR = 37840] = "COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR", e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR = 37841] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR", e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR = 37842] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR", e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR = 37843] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR", e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR = 37844] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR", e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR = 37845] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR", e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR = 37846] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR", e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR = 37847] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR", e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR = 37848] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR", e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR = 37849] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR", e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR = 37850] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR", e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR = 37851] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR", e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR = 37852] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR", e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR = 37853] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR";
      }(Ae || (Ae = {}));

      var pe = function () {
        function e() {}

        return e.setInstance = function (t) {
          e._instance = t;
        }, a(e, null, [{
          key: "instance",
          get: function get() {
            return e._instance;
          }
        }]), e;
      }();

      function Ce(e, t) {
        switch (e) {
          case A.R8:
            return t.UNSIGNED_BYTE;

          case A.R8SN:
            return t.BYTE;

          case A.R8UI:
            return t.UNSIGNED_BYTE;

          case A.R8I:
            return t.BYTE;

          case A.R16F:
            return Ae.HALF_FLOAT_OES;

          case A.R16UI:
            return t.UNSIGNED_SHORT;

          case A.R16I:
            return t.SHORT;

          case A.R32F:
            return t.FLOAT;

          case A.R32UI:
            return t.UNSIGNED_INT;

          case A.R32I:
            return t.INT;

          case A.RG8:
            return t.UNSIGNED_BYTE;

          case A.RG8SN:
            return t.BYTE;

          case A.RG8UI:
            return t.UNSIGNED_BYTE;

          case A.RG8I:
            return t.BYTE;

          case A.RG16F:
            return Ae.HALF_FLOAT_OES;

          case A.RG16UI:
            return t.UNSIGNED_SHORT;

          case A.RG16I:
            return t.SHORT;

          case A.RG32F:
            return t.FLOAT;

          case A.RG32UI:
            return t.UNSIGNED_INT;

          case A.RG32I:
            return t.INT;

          case A.RGB8:
          case A.SRGB8:
            return t.UNSIGNED_BYTE;

          case A.RGB8SN:
            return t.BYTE;

          case A.RGB8UI:
            return t.UNSIGNED_BYTE;

          case A.RGB8I:
            return t.BYTE;

          case A.RGB16F:
            return Ae.HALF_FLOAT_OES;

          case A.RGB16UI:
            return t.UNSIGNED_SHORT;

          case A.RGB16I:
            return t.SHORT;

          case A.RGB32F:
            return t.FLOAT;

          case A.RGB32UI:
            return t.UNSIGNED_INT;

          case A.RGB32I:
            return t.INT;

          case A.BGRA8:
          case A.RGBA8:
          case A.SRGB8_A8:
            return t.UNSIGNED_BYTE;

          case A.RGBA8SN:
            return t.BYTE;

          case A.RGBA8UI:
            return t.UNSIGNED_BYTE;

          case A.RGBA8I:
            return t.BYTE;

          case A.RGBA16F:
            return Ae.HALF_FLOAT_OES;

          case A.RGBA16UI:
            return t.UNSIGNED_SHORT;

          case A.RGBA16I:
            return t.SHORT;

          case A.RGBA32F:
            return t.FLOAT;

          case A.RGBA32UI:
            return t.UNSIGNED_INT;

          case A.RGBA32I:
            return t.INT;

          case A.R5G6B5:
            return t.UNSIGNED_SHORT_5_6_5;

          case A.R11G11B10F:
            return t.FLOAT;

          case A.RGB5A1:
            return t.UNSIGNED_SHORT_5_5_5_1;

          case A.RGBA4:
            return t.UNSIGNED_SHORT_4_4_4_4;

          case A.RGB10A2:
            return t.UNSIGNED_BYTE;

          case A.RGB10A2UI:
            return t.UNSIGNED_INT;

          case A.RGB9E5:
            return t.UNSIGNED_BYTE;

          case A.DEPTH:
            return t.UNSIGNED_INT;

          case A.DEPTH_STENCIL:
            return Ae.UNSIGNED_INT_24_8_WEBGL;

          case A.BC1:
          case A.BC1_SRGB:
          case A.BC2:
          case A.BC2_SRGB:
          case A.BC3:
          case A.BC3_SRGB:
          case A.BC4:
            return t.UNSIGNED_BYTE;

          case A.BC4_SNORM:
            return t.BYTE;

          case A.BC5:
            return t.UNSIGNED_BYTE;

          case A.BC5_SNORM:
            return t.BYTE;

          case A.BC6H_SF16:
          case A.BC6H_UF16:
            return t.FLOAT;

          case A.BC7:
          case A.BC7_SRGB:
          case A.ETC_RGB8:
          case A.ETC2_RGB8:
          case A.ETC2_SRGB8:
          case A.ETC2_RGB8_A1:
          case A.ETC2_SRGB8_A1:
          case A.EAC_R11:
            return t.UNSIGNED_BYTE;

          case A.EAC_R11SN:
            return t.BYTE;

          case A.EAC_RG11:
            return t.UNSIGNED_BYTE;

          case A.EAC_RG11SN:
            return t.BYTE;

          case A.PVRTC_RGB2:
          case A.PVRTC_RGBA2:
          case A.PVRTC_RGB4:
          case A.PVRTC_RGBA4:
          case A.PVRTC2_2BPP:
          case A.PVRTC2_4BPP:
            return t.UNSIGNED_BYTE;

          case A.ASTC_RGBA_4X4:
          case A.ASTC_RGBA_5X4:
          case A.ASTC_RGBA_5X5:
          case A.ASTC_RGBA_6X5:
          case A.ASTC_RGBA_6X6:
          case A.ASTC_RGBA_8X5:
          case A.ASTC_RGBA_8X6:
          case A.ASTC_RGBA_8X8:
          case A.ASTC_RGBA_10X5:
          case A.ASTC_RGBA_10X6:
          case A.ASTC_RGBA_10X8:
          case A.ASTC_RGBA_10X10:
          case A.ASTC_RGBA_12X10:
          case A.ASTC_RGBA_12X12:
          case A.ASTC_SRGBA_4X4:
          case A.ASTC_SRGBA_5X4:
          case A.ASTC_SRGBA_5X5:
          case A.ASTC_SRGBA_6X5:
          case A.ASTC_SRGBA_6X6:
          case A.ASTC_SRGBA_8X5:
          case A.ASTC_SRGBA_8X6:
          case A.ASTC_SRGBA_8X8:
          case A.ASTC_SRGBA_10X5:
          case A.ASTC_SRGBA_10X6:
          case A.ASTC_SRGBA_10X8:
          case A.ASTC_SRGBA_10X10:
          case A.ASTC_SRGBA_12X10:
          case A.ASTC_SRGBA_12X12:
          default:
            return t.UNSIGNED_BYTE;
        }
      }

      function Be(e, t) {
        switch (e) {
          case d.BOOL:
            return t.BOOL;

          case d.BOOL2:
            return t.BOOL_VEC2;

          case d.BOOL3:
            return t.BOOL_VEC3;

          case d.BOOL4:
            return t.BOOL_VEC4;

          case d.INT:
            return t.INT;

          case d.INT2:
            return t.INT_VEC2;

          case d.INT3:
            return t.INT_VEC3;

          case d.INT4:
            return t.INT_VEC4;

          case d.UINT:
            return t.UNSIGNED_INT;

          case d.FLOAT:
            return t.FLOAT;

          case d.FLOAT2:
            return t.FLOAT_VEC2;

          case d.FLOAT3:
            return t.FLOAT_VEC3;

          case d.FLOAT4:
            return t.FLOAT_VEC4;

          case d.MAT2:
            return t.FLOAT_MAT2;

          case d.MAT3:
            return t.FLOAT_MAT3;

          case d.MAT4:
            return t.FLOAT_MAT4;

          case d.SAMPLER2D:
            return t.SAMPLER_2D;

          case d.SAMPLER_CUBE:
            return t.SAMPLER_CUBE;

          default:
            return console.error("Unsupported GLType, convert to GL type failed."), d.UNKNOWN;
        }
      }

      function me(e) {
        switch (e) {
          case d.BOOL:
          case d.BOOL2:
          case d.BOOL3:
          case d.BOOL4:
          case d.INT:
          case d.INT2:
          case d.INT3:
          case d.INT4:
          case d.UINT:
            return Int32Array;

          case d.FLOAT:
          case d.FLOAT2:
          case d.FLOAT3:
          case d.FLOAT4:
          case d.MAT2:
          case d.MAT3:
          case d.MAT4:
            return Float32Array;

          default:
            return console.error("Unsupported GLType, convert to TypedArrayConstructor failed."), Float32Array;
        }
      }

      function xe(e, t) {
        switch (e) {
          case t.BOOL:
            return d.BOOL;

          case t.BOOL_VEC2:
            return d.BOOL2;

          case t.BOOL_VEC3:
            return d.BOOL3;

          case t.BOOL_VEC4:
            return d.BOOL4;

          case t.INT:
            return d.INT;

          case t.INT_VEC2:
            return d.INT2;

          case t.INT_VEC3:
            return d.INT3;

          case t.INT_VEC4:
            return d.INT4;

          case t.UNSIGNED_INT:
            return d.UINT;

          case t.FLOAT:
            return d.FLOAT;

          case t.FLOAT_VEC2:
            return d.FLOAT2;

          case t.FLOAT_VEC3:
            return d.FLOAT3;

          case t.FLOAT_VEC4:
            return d.FLOAT4;

          case t.FLOAT_MAT2:
            return d.MAT2;

          case t.FLOAT_MAT3:
            return d.MAT3;

          case t.FLOAT_MAT4:
            return d.MAT4;

          case t.SAMPLER_2D:
            return d.SAMPLER2D;

          case t.SAMPLER_CUBE:
            return d.SAMPLER_CUBE;

          default:
            return console.error("Unsupported GLType, convert to Type failed."), d.UNKNOWN;
        }
      }

      function be(e, t) {
        switch (e) {
          case t.BOOL:
            return 4;

          case t.BOOL_VEC2:
            return 8;

          case t.BOOL_VEC3:
            return 12;

          case t.BOOL_VEC4:
            return 16;

          case t.INT:
            return 4;

          case t.INT_VEC2:
            return 8;

          case t.INT_VEC3:
            return 12;

          case t.INT_VEC4:
            return 16;

          case t.UNSIGNED_INT:
          case t.FLOAT:
            return 4;

          case t.FLOAT_VEC2:
            return 8;

          case t.FLOAT_VEC3:
            return 12;

          case t.FLOAT_VEC4:
          case t.FLOAT_MAT2:
            return 16;

          case t.FLOAT_MAT3:
            return 36;

          case t.FLOAT_MAT4:
            return 64;

          case t.SAMPLER_2D:
          case t.SAMPLER_CUBE:
            return 4;

          default:
            return console.error("Unsupported GLType, get type failed."), 0;
        }
      }

      function Pe(e, t) {
        switch (e) {
          case t.FLOAT_MAT2:
            return 2;

          case t.FLOAT_MAT3:
            return 3;

          case t.FLOAT_MAT4:
            return 4;

          default:
            return 1;
        }
      }

      pe._instance = null;
      var Fe,
          ve = [512, 513, 514, 515, 516, 517, 518, 519],
          Ge = [0, 7680, 7681, 7682, 7683, 5386, 34055, 34056],
          Oe = [32774, 32778, 32779, 32775, 32776],
          Ie = [0, 1, 770, 772, 771, 773, 768, 774, 769, 775, 776, 32769, 32770, 32771, 32772];
      !function (e) {
        e[e.BEGIN_RENDER_PASS = 0] = "BEGIN_RENDER_PASS", e[e.END_RENDER_PASS = 1] = "END_RENDER_PASS", e[e.BIND_STATES = 2] = "BIND_STATES", e[e.DRAW = 3] = "DRAW", e[e.UPDATE_BUFFER = 4] = "UPDATE_BUFFER", e[e.COPY_BUFFER_TO_TEXTURE = 5] = "COPY_BUFFER_TO_TEXTURE", e[e.COUNT = 6] = "COUNT";
      }(Fe || (Fe = {}));

      var ye = function ye(e) {
        this.cmdType = void 0, this.refCount = 0, this.cmdType = e;
      },
          Le = function (e) {
        function r() {
          var t;
          return (t = e.call(this, Fe.BEGIN_RENDER_PASS) || this).gpuRenderPass = null, t.gpuFramebuffer = null, t.renderArea = new i(), t.clearFlag = u.NONE, t.clearColors = [], t.clearDepth = 1, t.clearStencil = 0, t;
        }

        return t(r, e), r.prototype.clear = function () {
          this.gpuFramebuffer = null, this.clearColors.length = 0;
        }, r;
      }(ye),
          De = function (e) {
        function r() {
          var t;
          return (t = e.call(this, Fe.BIND_STATES) || this).gpuPipelineState = null, t.gpuInputAssembler = null, t.gpuDescriptorSets = [], t.dynamicOffsets = [], t.dynamicStates = new l(), t;
        }

        return t(r, e), r.prototype.clear = function () {
          this.gpuPipelineState = null, this.gpuDescriptorSets.length = 0, this.gpuInputAssembler = null, this.dynamicOffsets.length = 0;
        }, r;
      }(ye),
          Me = function (e) {
        function r() {
          var t;
          return (t = e.call(this, Fe.DRAW) || this).drawInfo = new _(), t;
        }

        return t(r, e), r.prototype.clear = function () {}, r;
      }(ye),
          Ne = function (e) {
        function r() {
          var t;
          return (t = e.call(this, Fe.UPDATE_BUFFER) || this).gpuBuffer = null, t.buffer = null, t.offset = 0, t.size = 0, t;
        }

        return t(r, e), r.prototype.clear = function () {
          this.gpuBuffer = null, this.buffer = null;
        }, r;
      }(ye),
          Ue = function (e) {
        function r() {
          var t;
          return (t = e.call(this, Fe.COPY_BUFFER_TO_TEXTURE) || this).gpuTexture = null, t.buffers = [], t.regions = [], t;
        }

        return t(r, e), r.prototype.clear = function () {
          this.gpuTexture = null, this.buffers.length = 0, this.regions.length = 0;
        }, r;
      }(ye),
          we = function () {
        function e() {
          this.cmds = new P(1), this.beginRenderPassCmds = new P(1), this.bindStatesCmds = new P(1), this.drawCmds = new P(1), this.updateBufferCmds = new P(1), this.copyBufferToTextureCmds = new P(1);
        }

        return e.prototype.clearCmds = function (e) {
          this.beginRenderPassCmds.length && (e.beginRenderPassCmdPool.freeCmds(this.beginRenderPassCmds), this.beginRenderPassCmds.clear()), this.bindStatesCmds.length && (e.bindStatesCmdPool.freeCmds(this.bindStatesCmds), this.bindStatesCmds.clear()), this.drawCmds.length && (e.drawCmdPool.freeCmds(this.drawCmds), this.drawCmds.clear()), this.updateBufferCmds.length && (e.updateBufferCmdPool.freeCmds(this.updateBufferCmds), this.updateBufferCmds.clear()), this.copyBufferToTextureCmds.length && (e.copyBufferToTextureCmdPool.freeCmds(this.copyBufferToTextureCmds), this.copyBufferToTextureCmds.clear()), this.cmds.clear();
        }, e;
      }();

      function ke(e, t, r, s, a) {
        if (t.usage & c.UNIFORM) ArrayBuffer.isView(r) ? t.vf32.set(r, s / Float32Array.BYTES_PER_ELEMENT) : t.vf32.set(new Float32Array(r), s / Float32Array.BYTES_PER_ELEMENT);else if (t.usage & c.INDIRECT) {
          t.indirects.clearDraws();

          for (var n = r.drawInfos, i = 0; i < n.length; ++i) {
            t.indirects.setDrawInfo(s + i, n[i]);
          }
        } else {
          var u = r,
              l = e.gl,
              _ = e.stateCache;

          switch (t.glTarget) {
            case l.ARRAY_BUFFER:
              e.extensions.useVAO && _.glVAO && (e.extensions.OES_vertex_array_object.bindVertexArrayOES(null), _.glVAO = null), Xe.gpuInputAssembler = null, e.stateCache.glArrayBuffer !== t.glBuffer && (l.bindBuffer(l.ARRAY_BUFFER, t.glBuffer), e.stateCache.glArrayBuffer = t.glBuffer);
              break;

            case l.ELEMENT_ARRAY_BUFFER:
              e.extensions.useVAO && _.glVAO && (e.extensions.OES_vertex_array_object.bindVertexArrayOES(null), _.glVAO = null), Xe.gpuInputAssembler = null, e.stateCache.glElementArrayBuffer !== t.glBuffer && (l.bindBuffer(l.ELEMENT_ARRAY_BUFFER, t.glBuffer), e.stateCache.glElementArrayBuffer = t.glBuffer);
              break;

            default:
              return void console.error("Unsupported BufferType, update buffer failed.");
          }

          a === u.byteLength ? l.bufferSubData(t.glTarget, s, u) : l.bufferSubData(t.glTarget, s, u.slice(0, a));
        }
      }

      var Xe = {
        gpuPipelineState: null,
        gpuInputAssembler: null,
        glPrimitive: 0
      },
          He = new i();

      function Ve(e, t, r, s, a, n, i) {
        var u = e.gl,
            l = e.stateCache,
            _ = 0;

        if (r && (He.x = s.x << r.lodLevel, He.y = s.y << r.lodLevel, He.width = s.width << r.lodLevel, He.height = s.height << r.lodLevel), r && t) {
          l.glFramebuffer !== r.glFramebuffer && (u.bindFramebuffer(u.FRAMEBUFFER, r.glFramebuffer), l.glFramebuffer = r.glFramebuffer), l.viewport.left === He.x && l.viewport.top === He.y && l.viewport.width === He.width && l.viewport.height === He.height || (u.viewport(He.x, He.y, He.width, He.height), l.viewport.left = He.x, l.viewport.top = He.y, l.viewport.width = He.width, l.viewport.height = He.height), l.scissorRect.x === He.x && l.scissorRect.y === He.y && l.scissorRect.width === He.width && l.scissorRect.height === He.height || (u.scissor(He.x, He.y, He.width, He.height), l.scissorRect.x = He.x, l.scissorRect.y = He.y, l.scissorRect.width = He.width, l.scissorRect.height = He.height);
          var o = a.length;
          e.extensions.WEBGL_draw_buffers || (o = 1);

          for (var c = 0; c < o; ++c) {
            var f = t.colorAttachments[c];
            if (f.format !== A.UNKNOWN) switch (f.loadOp) {
              case S.LOAD:
                break;

              case S.CLEAR:
                l.bs.targets[0].blendColorMask !== p.ALL && u.colorMask(!0, !0, !0, !0);
                var E = a[0];
                u.clearColor(E.x, E.y, E.z, E.w), _ |= u.COLOR_BUFFER_BIT;
                break;

              case S.DISCARD:
            }
          }

          if (t.depthStencilAttachment && t.depthStencilAttachment.format !== A.UNKNOWN) {
            switch (t.depthStencilAttachment.depthLoadOp) {
              case S.LOAD:
                break;

              case S.CLEAR:
                l.dss.depthWrite || u.depthMask(!0), u.clearDepth(n), _ |= u.DEPTH_BUFFER_BIT;
                break;

              case S.DISCARD:
            }

            if (h[t.depthStencilAttachment.format].hasStencil) switch (t.depthStencilAttachment.stencilLoadOp) {
              case S.LOAD:
                break;

              case S.CLEAR:
                l.dss.stencilWriteMaskFront || u.stencilMaskSeparate(u.FRONT, 65535), l.dss.stencilWriteMaskBack || u.stencilMaskSeparate(u.BACK, 65535), u.clearStencil(i), _ |= u.STENCIL_BUFFER_BIT;
                break;

              case S.DISCARD:
            }
          }

          if (_ && u.clear(_), _ & u.COLOR_BUFFER_BIT) {
            var T = l.bs.targets[0].blendColorMask;

            if (T !== p.ALL) {
              var R = (T & p.R) !== p.NONE,
                  g = (T & p.G) !== p.NONE,
                  d = (T & p.B) !== p.NONE,
                  C = (T & p.A) !== p.NONE;
              u.colorMask(R, g, d, C);
            }
          }

          _ & u.DEPTH_BUFFER_BIT && !l.dss.depthWrite && u.depthMask(!1), _ & u.STENCIL_BUFFER_BIT && (l.dss.stencilWriteMaskFront || u.stencilMaskSeparate(u.FRONT, 0), l.dss.stencilWriteMaskBack || u.stencilMaskSeparate(u.BACK, 0));
        }
      }

      function We(e, t, r, s, a, n) {
        var i,
            u,
            l,
            _ = e.gl,
            o = e.stateCache,
            c = t && t.gpuShader,
            f = !1;

        if (t && Xe.gpuPipelineState !== t) {
          if (Xe.gpuPipelineState = t, Xe.glPrimitive = t.glPrimitive, t.gpuShader) {
            var E = t.gpuShader.glProgram;
            o.glProgram !== E && (_.useProgram(E), o.glProgram = E, f = !0);
          }

          var h = t.rs;

          if (h) {
            if (o.rs.cullMode !== h.cullMode) {
              switch (h.cullMode) {
                case C.NONE:
                  _.disable(_.CULL_FACE);

                  break;

                case C.FRONT:
                  _.enable(_.CULL_FACE), _.cullFace(_.FRONT);
                  break;

                case C.BACK:
                  _.enable(_.CULL_FACE), _.cullFace(_.BACK);
              }

              o.rs.cullMode = h.cullMode;
            }

            var T = h.isFrontFaceCCW;
            o.rs.isFrontFaceCCW !== T && (_.frontFace(T ? _.CCW : _.CW), o.rs.isFrontFaceCCW = T), o.rs.depthBias === h.depthBias && o.rs.depthBiasSlop === h.depthBiasSlop || (_.polygonOffset(h.depthBias, h.depthBiasSlop), o.rs.depthBias = h.depthBias, o.rs.depthBiasSlop = h.depthBiasSlop), o.rs.lineWidth !== h.lineWidth && (_.lineWidth(h.lineWidth), o.rs.lineWidth = h.lineWidth);
          }

          var R = t.dss;
          R && (o.dss.depthTest !== R.depthTest && (R.depthTest ? _.enable(_.DEPTH_TEST) : _.disable(_.DEPTH_TEST), o.dss.depthTest = R.depthTest), o.dss.depthWrite !== R.depthWrite && (_.depthMask(R.depthWrite), o.dss.depthWrite = R.depthWrite), o.dss.depthFunc !== R.depthFunc && (_.depthFunc(ve[R.depthFunc]), o.dss.depthFunc = R.depthFunc), o.dss.stencilTestFront === R.stencilTestFront && o.dss.stencilTestBack === R.stencilTestBack || (R.stencilTestFront || R.stencilTestBack ? _.enable(_.STENCIL_TEST) : _.disable(_.STENCIL_TEST), o.dss.stencilTestFront = R.stencilTestFront, o.dss.stencilTestBack = R.stencilTestBack), o.dss.stencilFuncFront === R.stencilFuncFront && o.dss.stencilRefFront === R.stencilRefFront && o.dss.stencilReadMaskFront === R.stencilReadMaskFront || (_.stencilFuncSeparate(_.FRONT, ve[R.stencilFuncFront], R.stencilRefFront, R.stencilReadMaskFront), o.dss.stencilFuncFront = R.stencilFuncFront, o.dss.stencilRefFront = R.stencilRefFront, o.dss.stencilReadMaskFront = R.stencilReadMaskFront), o.dss.stencilFailOpFront === R.stencilFailOpFront && o.dss.stencilZFailOpFront === R.stencilZFailOpFront && o.dss.stencilPassOpFront === R.stencilPassOpFront || (_.stencilOpSeparate(_.FRONT, Ge[R.stencilFailOpFront], Ge[R.stencilZFailOpFront], Ge[R.stencilPassOpFront]), o.dss.stencilFailOpFront = R.stencilFailOpFront, o.dss.stencilZFailOpFront = R.stencilZFailOpFront, o.dss.stencilPassOpFront = R.stencilPassOpFront), o.dss.stencilWriteMaskFront !== R.stencilWriteMaskFront && (_.stencilMaskSeparate(_.FRONT, R.stencilWriteMaskFront), o.dss.stencilWriteMaskFront = R.stencilWriteMaskFront), o.dss.stencilFuncBack === R.stencilFuncBack && o.dss.stencilRefBack === R.stencilRefBack && o.dss.stencilReadMaskBack === R.stencilReadMaskBack || (_.stencilFuncSeparate(_.BACK, ve[R.stencilFuncBack], R.stencilRefBack, R.stencilReadMaskBack), o.dss.stencilFuncBack = R.stencilFuncBack, o.dss.stencilRefBack = R.stencilRefBack, o.dss.stencilReadMaskBack = R.stencilReadMaskBack), o.dss.stencilFailOpBack === R.stencilFailOpBack && o.dss.stencilZFailOpBack === R.stencilZFailOpBack && o.dss.stencilPassOpBack === R.stencilPassOpBack || (_.stencilOpSeparate(_.BACK, Ge[R.stencilFailOpBack], Ge[R.stencilZFailOpBack], Ge[R.stencilPassOpBack]), o.dss.stencilFailOpBack = R.stencilFailOpBack, o.dss.stencilZFailOpBack = R.stencilZFailOpBack, o.dss.stencilPassOpBack = R.stencilPassOpBack), o.dss.stencilWriteMaskBack !== R.stencilWriteMaskBack && (_.stencilMaskSeparate(_.BACK, R.stencilWriteMaskBack), o.dss.stencilWriteMaskBack = R.stencilWriteMaskBack));
          var g = t.bs;

          if (g) {
            o.bs.isA2C !== g.isA2C && (g.isA2C ? _.enable(_.SAMPLE_ALPHA_TO_COVERAGE) : _.disable(_.SAMPLE_ALPHA_TO_COVERAGE), o.bs.isA2C = g.isA2C), o.bs.blendColor.x === g.blendColor.x && o.bs.blendColor.y === g.blendColor.y && o.bs.blendColor.z === g.blendColor.z && o.bs.blendColor.w === g.blendColor.w || (_.blendColor(g.blendColor.x, g.blendColor.y, g.blendColor.z, g.blendColor.w), o.bs.blendColor.x = g.blendColor.x, o.bs.blendColor.y = g.blendColor.y, o.bs.blendColor.z = g.blendColor.z, o.bs.blendColor.w = g.blendColor.w);
            var d = g.targets[0],
                A = o.bs.targets[0];
            A.blend !== d.blend && (d.blend ? _.enable(_.BLEND) : _.disable(_.BLEND), A.blend = d.blend), A.blendEq === d.blendEq && A.blendAlphaEq === d.blendAlphaEq || (_.blendEquationSeparate(Oe[d.blendEq], Oe[d.blendAlphaEq]), A.blendEq = d.blendEq, A.blendAlphaEq = d.blendAlphaEq), A.blendSrc === d.blendSrc && A.blendDst === d.blendDst && A.blendSrcAlpha === d.blendSrcAlpha && A.blendDstAlpha === d.blendDstAlpha || (_.blendFuncSeparate(Ie[d.blendSrc], Ie[d.blendDst], Ie[d.blendSrcAlpha], Ie[d.blendDstAlpha]), A.blendSrc = d.blendSrc, A.blendDst = d.blendDst, A.blendSrcAlpha = d.blendSrcAlpha, A.blendDstAlpha = d.blendDstAlpha), A.blendColorMask !== d.blendColorMask && (_.colorMask((d.blendColorMask & p.R) !== p.NONE, (d.blendColorMask & p.G) !== p.NONE, (d.blendColorMask & p.B) !== p.NONE, (d.blendColorMask & p.A) !== p.NONE), A.blendColorMask = d.blendColorMask);
          }
        }

        if (t && t.gpuPipelineLayout && c) {
          for (var S = c.glBlocks.length, x = t.gpuPipelineLayout.dynamicOffsetIndices, b = 0; b < S; b++) {
            var P = c.glBlocks[b],
                F = s[P.set],
                v = F && F.descriptorIndices[P.binding],
                G = v >= 0 && F.gpuDescriptors[v],
                O = null,
                I = 0;

            if (G && G.gpuBuffer) {
              var y = G.gpuBuffer,
                  L = x[P.set],
                  D = L && L[P.binding];
              D >= 0 && (I = a[D]), "vf32" in y ? O = y.vf32 : (I += y.offset, O = y.gpuBuffer.vf32), I >>= 2;
            }

            if (O) for (var M = P.glActiveUniforms.length, N = 0; N < M; N++) {
              var U = P.glActiveUniforms[N];

              switch (U.glType) {
                case _.BOOL:
                case _.INT:
                  for (var w = 0; w < U.array.length; ++w) {
                    var k = U.offset + I + w;

                    if (O[k] !== U.array[w]) {
                      for (var X = w, H = k; X < U.array.length; ++X, ++H) {
                        U.array[X] = O[H];
                      }

                      _.uniform1iv(U.glLoc, U.array);

                      break;
                    }
                  }

                  break;

                case _.BOOL_VEC2:
                case _.INT_VEC2:
                  for (var V = 0; V < U.array.length; ++V) {
                    var W = U.offset + I + V;

                    if (O[W] !== U.array[V]) {
                      for (var z = V, K = W; z < U.array.length; ++z, ++K) {
                        U.array[z] = O[K];
                      }

                      _.uniform2iv(U.glLoc, U.array);

                      break;
                    }
                  }

                  break;

                case _.BOOL_VEC3:
                case _.INT_VEC3:
                  for (var Y = 0; Y < U.array.length; ++Y) {
                    var q = U.offset + I + Y;

                    if (O[q] !== U.array[Y]) {
                      for (var j = Y, Z = q; j < U.array.length; ++j, ++Z) {
                        U.array[j] = O[Z];
                      }

                      _.uniform3iv(U.glLoc, U.array);

                      break;
                    }
                  }

                  break;

                case _.BOOL_VEC4:
                case _.INT_VEC4:
                  for (var Q = 0; Q < U.array.length; ++Q) {
                    var $ = U.offset + I + Q;

                    if (O[$] !== U.array[Q]) {
                      for (var J = Q, ee = $; J < U.array.length; ++J, ++ee) {
                        U.array[J] = O[ee];
                      }

                      _.uniform4iv(U.glLoc, U.array);

                      break;
                    }
                  }

                  break;

                case _.FLOAT:
                  for (var te = 0; te < U.array.length; ++te) {
                    var re = U.offset + I + te;

                    if (O[re] !== U.array[te]) {
                      for (var se = te, ae = re; se < U.array.length; ++se, ++ae) {
                        U.array[se] = O[ae];
                      }

                      _.uniform1fv(U.glLoc, U.array);

                      break;
                    }
                  }

                  break;

                case _.FLOAT_VEC2:
                  for (var ne = 0; ne < U.array.length; ++ne) {
                    var ie = U.offset + I + ne;

                    if (O[ie] !== U.array[ne]) {
                      for (var ue = ne, le = ie; ue < U.array.length; ++ue, ++le) {
                        U.array[ue] = O[le];
                      }

                      _.uniform2fv(U.glLoc, U.array);

                      break;
                    }
                  }

                  break;

                case _.FLOAT_VEC3:
                  for (var _e = 0; _e < U.array.length; ++_e) {
                    var oe = U.offset + I + _e;

                    if (O[oe] !== U.array[_e]) {
                      for (var ce = _e, fe = oe; ce < U.array.length; ++ce, ++fe) {
                        U.array[ce] = O[fe];
                      }

                      _.uniform3fv(U.glLoc, U.array);

                      break;
                    }
                  }

                  break;

                case _.FLOAT_VEC4:
                  for (var Ee = 0; Ee < U.array.length; ++Ee) {
                    var he = U.offset + I + Ee;

                    if (O[he] !== U.array[Ee]) {
                      for (var Te = Ee, Re = he; Te < U.array.length; ++Te, ++Re) {
                        U.array[Te] = O[Re];
                      }

                      _.uniform4fv(U.glLoc, U.array);

                      break;
                    }
                  }

                  break;

                case _.FLOAT_MAT2:
                  for (var ge = 0; ge < U.array.length; ++ge) {
                    var de = U.offset + I + ge;

                    if (O[de] !== U.array[ge]) {
                      for (var Ae = ge, Se = de; Ae < U.array.length; ++Ae, ++Se) {
                        U.array[Ae] = O[Se];
                      }

                      _.uniformMatrix2fv(U.glLoc, !1, U.array);

                      break;
                    }
                  }

                  break;

                case _.FLOAT_MAT3:
                  for (var pe = 0; pe < U.array.length; ++pe) {
                    var Ce = U.offset + I + pe;

                    if (O[Ce] !== U.array[pe]) {
                      for (var Be = pe, me = Ce; Be < U.array.length; ++Be, ++me) {
                        U.array[Be] = O[me];
                      }

                      _.uniformMatrix3fv(U.glLoc, !1, U.array);

                      break;
                    }
                  }

                  break;

                case _.FLOAT_MAT4:
                  for (var xe = 0; xe < U.array.length; ++xe) {
                    var be = U.offset + I + xe;

                    if (O[be] !== U.array[xe]) {
                      for (var Pe = xe, Fe = be; Pe < U.array.length; ++Pe, ++Fe) {
                        U.array[Pe] = O[Fe];
                      }

                      _.uniformMatrix4fv(U.glLoc, !1, U.array);

                      break;
                    }
                  }

              }
            } else B("Buffer binding '" + P.name + "' at set " + P.set + " binding " + P.binding + " is not bounded");
          }

          for (var ye = c.glSamplerTextures.length, Le = 0; Le < ye; Le++) {
            for (var De = c.glSamplerTextures[Le], Me = s[De.set], Ne = Me && Me.descriptorIndices[De.binding], Ue = Ne >= 0 && Me.gpuDescriptors[Ne], we = De.units.length, ke = 0; ke < we; ke++) {
              var He = De.units[ke];

              if (Ue && Ue.gpuSampler) {
                if (Ue.gpuTexture && Ue.gpuTexture.size > 0) {
                  var Ve = Ue.gpuTexture,
                      We = o.glTexUnits[He];
                  We.glTexture !== Ve.glTexture && (o.texUnit !== He && (_.activeTexture(_.TEXTURE0 + He), o.texUnit = He), Ve.glTexture ? _.bindTexture(Ve.glTarget, Ve.glTexture) : _.bindTexture(Ve.glTarget, e.nullTex2D.gpuTexture.glTexture), We.glTexture = Ve.glTexture);
                  var ze = Ue.gpuSampler;
                  Ve.isPowerOf2 ? (i = ze.glWrapS, u = ze.glWrapT) : (i = _.CLAMP_TO_EDGE, u = _.CLAMP_TO_EDGE), l = Ve.isPowerOf2 ? Ve.mipLevel <= 1 && (ze.glMinFilter === _.LINEAR_MIPMAP_NEAREST || ze.glMinFilter === _.LINEAR_MIPMAP_LINEAR) ? _.LINEAR : ze.glMinFilter : ze.glMinFilter === _.LINEAR || ze.glMinFilter === _.LINEAR_MIPMAP_NEAREST || ze.glMinFilter === _.LINEAR_MIPMAP_LINEAR ? _.LINEAR : _.NEAREST, Ve.glWrapS !== i && (o.texUnit !== He && (_.activeTexture(_.TEXTURE0 + He), o.texUnit = He), _.texParameteri(Ve.glTarget, _.TEXTURE_WRAP_S, i), Ve.glWrapS = i), Ve.glWrapT !== u && (o.texUnit !== He && (_.activeTexture(_.TEXTURE0 + He), o.texUnit = He), _.texParameteri(Ve.glTarget, _.TEXTURE_WRAP_T, u), Ve.glWrapT = u), Ve.glMinFilter !== l && (o.texUnit !== He && (_.activeTexture(_.TEXTURE0 + He), o.texUnit = He), _.texParameteri(Ve.glTarget, _.TEXTURE_MIN_FILTER, l), Ve.glMinFilter = l), Ve.glMagFilter !== ze.glMagFilter && (o.texUnit !== He && (_.activeTexture(_.TEXTURE0 + He), o.texUnit = He), _.texParameteri(Ve.glTarget, _.TEXTURE_MAG_FILTER, ze.glMagFilter), Ve.glMagFilter = ze.glMagFilter);
                }

                Ue = Me.gpuDescriptors[++Ne];
              } else B("Sampler binding '" + De.name + "' at set " + De.set + " binding " + De.binding + " index " + ke + " is not bounded");
            }
          }
        }

        if (r && c && (f || Xe.gpuInputAssembler !== r)) {
          Xe.gpuInputAssembler = r;
          var Ke = e.extensions.ANGLE_instanced_arrays;

          if (e.extensions.useVAO) {
            var Ye = e.extensions.OES_vertex_array_object,
                qe = r.glVAOs.get(c.glProgram);

            if (!qe) {
              var je;
              qe = Ye.createVertexArrayOES(), r.glVAOs.set(c.glProgram, qe), Ye.bindVertexArrayOES(qe), _.bindBuffer(_.ARRAY_BUFFER, null), _.bindBuffer(_.ELEMENT_ARRAY_BUFFER, null), o.glArrayBuffer = null, o.glElementArrayBuffer = null;

              for (var Ze = c.glInputs.length, Qe = 0; Qe < Ze; Qe++) {
                var $e = c.glInputs[Qe];
                je = null;

                for (var Je = r.glAttribs.length, et = 0; et < Je; et++) {
                  var tt = r.glAttribs[et];

                  if (tt.name === $e.name) {
                    je = tt;
                    break;
                  }
                }

                if (je) {
                  o.glArrayBuffer !== je.glBuffer && (_.bindBuffer(_.ARRAY_BUFFER, je.glBuffer), o.glArrayBuffer = je.glBuffer);

                  for (var rt = 0; rt < je.componentCount; ++rt) {
                    var st = $e.glLoc + rt,
                        at = je.offset + je.size * rt;
                    _.enableVertexAttribArray(st), o.glCurrentAttribLocs[st] = !0, _.vertexAttribPointer(st, je.count, je.glType, je.isNormalized, je.stride, at), Ke && Ke.vertexAttribDivisorANGLE(st, je.isInstanced ? 1 : 0);
                  }
                }
              }

              var nt = r.gpuIndexBuffer;
              nt && _.bindBuffer(_.ELEMENT_ARRAY_BUFFER, nt.glBuffer), Ye.bindVertexArrayOES(null), _.bindBuffer(_.ARRAY_BUFFER, null), _.bindBuffer(_.ELEMENT_ARRAY_BUFFER, null), o.glArrayBuffer = null, o.glElementArrayBuffer = null;
            }

            o.glVAO !== qe && (Ye.bindVertexArrayOES(qe), o.glVAO = qe);
          } else {
            for (var it = 0; it < e.capabilities.maxVertexAttributes; ++it) {
              o.glCurrentAttribLocs[it] = !1;
            }

            for (var ut = c.glInputs.length, lt = 0; lt < ut; lt++) {
              for (var _t = c.glInputs[lt], ot = null, ct = r.glAttribs.length, ft = 0; ft < ct; ft++) {
                var Et = r.glAttribs[ft];

                if (Et.name === _t.name) {
                  ot = Et;
                  break;
                }
              }

              if (ot) {
                o.glArrayBuffer !== ot.glBuffer && (_.bindBuffer(_.ARRAY_BUFFER, ot.glBuffer), o.glArrayBuffer = ot.glBuffer);

                for (var ht = 0; ht < ot.componentCount; ++ht) {
                  var Tt = _t.glLoc + ht,
                      Rt = ot.offset + ot.size * ht;
                  !o.glEnabledAttribLocs[Tt] && Tt >= 0 && (_.enableVertexAttribArray(Tt), o.glEnabledAttribLocs[Tt] = !0), o.glCurrentAttribLocs[Tt] = !0, _.vertexAttribPointer(Tt, ot.count, ot.glType, ot.isNormalized, ot.stride, Rt), Ke && Ke.vertexAttribDivisorANGLE(Tt, ot.isInstanced ? 1 : 0);
                }
              }
            }

            var gt = r.gpuIndexBuffer;
            gt && o.glElementArrayBuffer !== gt.glBuffer && (_.bindBuffer(_.ELEMENT_ARRAY_BUFFER, gt.glBuffer), o.glElementArrayBuffer = gt.glBuffer);

            for (var dt = 0; dt < e.capabilities.maxVertexAttributes; ++dt) {
              o.glEnabledAttribLocs[dt] !== o.glCurrentAttribLocs[dt] && (_.disableVertexAttribArray(dt), o.glEnabledAttribLocs[dt] = !1);
            }
          }
        }

        if (t && t.dynamicStates.length) for (var At = t.dynamicStates.length, St = 0; St < At; St++) {
          switch (t.dynamicStates[St]) {
            case m.LINE_WIDTH:
              o.rs.lineWidth !== n.lineWidth && (_.lineWidth(n.lineWidth), o.rs.lineWidth = n.lineWidth);
              break;

            case m.DEPTH_BIAS:
              o.rs.depthBias === n.depthBiasConstant && o.rs.depthBiasSlop === n.depthBiasSlope || (_.polygonOffset(n.depthBiasConstant, n.depthBiasSlope), o.rs.depthBias = n.depthBiasConstant, o.rs.depthBiasSlop = n.depthBiasSlope);
              break;

            case m.BLEND_CONSTANTS:
              var pt = n.blendConstant;
              o.bs.blendColor.x === pt.x && o.bs.blendColor.y === pt.y && o.bs.blendColor.z === pt.z && o.bs.blendColor.w === pt.w || (_.blendColor(pt.x, pt.y, pt.z, pt.w), o.bs.blendColor.copy(pt));
              break;

            case m.STENCIL_WRITE_MASK:
              var Ct = n.stencilStatesFront,
                  Bt = n.stencilStatesBack;
              o.dss.stencilWriteMaskFront !== Ct.writeMask && (_.stencilMaskSeparate(_.FRONT, Ct.writeMask), o.dss.stencilWriteMaskFront = Ct.writeMask), o.dss.stencilWriteMaskBack !== Bt.writeMask && (_.stencilMaskSeparate(_.BACK, Bt.writeMask), o.dss.stencilWriteMaskBack = Bt.writeMask);
              break;

            case m.STENCIL_COMPARE_MASK:
              var mt = n.stencilStatesFront,
                  xt = n.stencilStatesBack;
              o.dss.stencilRefFront === mt.reference && o.dss.stencilReadMaskFront === mt.compareMask || (_.stencilFuncSeparate(_.FRONT, ve[o.dss.stencilFuncFront], mt.reference, mt.compareMask), o.dss.stencilRefFront = mt.reference, o.dss.stencilReadMaskFront = mt.compareMask), o.dss.stencilRefBack === xt.reference && o.dss.stencilReadMaskBack === xt.compareMask || (_.stencilFuncSeparate(_.BACK, ve[o.dss.stencilFuncBack], xt.reference, xt.compareMask), o.dss.stencilRefBack = xt.reference, o.dss.stencilReadMaskBack = xt.compareMask);
          }
        }
      }

      function ze(e, t) {
        var r = e.gl,
            s = e.extensions,
            a = s.ANGLE_instanced_arrays,
            n = s.WEBGL_multi_draw,
            i = Xe.gpuInputAssembler,
            u = Xe.glPrimitive;

        if (i) {
          var l = i.gpuIndexBuffer;

          if (i.gpuIndirectBuffer) {
            var _ = i.gpuIndirectBuffer.indirects;

            if (_.drawByIndex) {
              for (var o = 0; o < _.drawCount; o++) {
                _.byteOffsets[o] = _.offsets[o] * l.stride;
              }

              if (n) _.instancedDraw ? n.multiDrawElementsInstancedWEBGL(u, _.counts, 0, i.glIndexType, _.byteOffsets, 0, _.instances, 0, _.drawCount) : n.multiDrawElementsWEBGL(u, _.counts, 0, i.glIndexType, _.byteOffsets, 0, _.drawCount);else for (var c = 0; c < _.drawCount; c++) {
                _.instances[c] && a ? a.drawElementsInstancedANGLE(u, _.counts[c], i.glIndexType, _.byteOffsets[c], _.instances[c]) : r.drawElements(u, _.counts[c], i.glIndexType, _.byteOffsets[c]);
              }
            } else if (n) _.instancedDraw ? n.multiDrawArraysInstancedWEBGL(u, _.offsets, 0, _.counts, 0, _.instances, 0, _.drawCount) : n.multiDrawArraysWEBGL(u, _.offsets, 0, _.counts, 0, _.drawCount);else for (var f = 0; f < _.drawCount; f++) {
              _.instances[f] && a ? a.drawArraysInstancedANGLE(u, _.offsets[f], _.counts[f], _.instances[f]) : r.drawArrays(u, _.offsets[f], _.counts[f]);
            }
          } else if (t.instanceCount && a) {
            if (l) {
              if (t.indexCount > 0) {
                var E = t.firstIndex * l.stride;
                a.drawElementsInstancedANGLE(u, t.indexCount, i.glIndexType, E, t.instanceCount);
              }
            } else t.vertexCount > 0 && a.drawArraysInstancedANGLE(u, t.firstVertex, t.vertexCount, t.instanceCount);
          } else if (l) {
            if (t.indexCount > 0) {
              var h = t.firstIndex * l.stride;
              r.drawElements(u, t.indexCount, i.glIndexType, h);
            }
          } else t.vertexCount > 0 && r.drawArrays(u, t.firstVertex, t.vertexCount);
        }
      }

      var Ke = new Array(Fe.COUNT);

      function Ye(e, t) {
        Ke.fill(0);

        for (var r = 0; r < t.cmds.length; ++r) {
          var s = t.cmds.array[r],
              a = Ke[s]++;

          switch (s) {
            case Fe.BEGIN_RENDER_PASS:
              var n = t.beginRenderPassCmds.array[a];
              Ve(e, n.gpuRenderPass, n.gpuFramebuffer, n.renderArea, n.clearColors, n.clearDepth, n.clearStencil);
              break;

            case Fe.BIND_STATES:
              var i = t.bindStatesCmds.array[a];
              We(e, i.gpuPipelineState, i.gpuInputAssembler, i.gpuDescriptorSets, i.dynamicOffsets, i.dynamicStates);
              break;

            case Fe.DRAW:
              ze(e, t.drawCmds.array[a].drawInfo);
              break;

            case Fe.UPDATE_BUFFER:
              var u = t.updateBufferCmds.array[a];
              ke(e, u.gpuBuffer, u.buffer, u.offset, u.size);
              break;

            case Fe.COPY_BUFFER_TO_TEXTURE:
              var l = t.copyBufferToTextureCmds.array[a];
              qe(e, l.buffers, l.gpuTexture, l.regions);
          }
        }
      }

      function qe(e, t, r, s) {
        var a = e.gl,
            n = e.stateCache.glTexUnits[e.stateCache.texUnit];
        n.glTexture !== r.glTexture && (a.bindTexture(r.glTarget, r.glTexture), n.glTexture = r.glTexture);
        var i = 0,
            u = 1,
            l = 1,
            _ = 0,
            o = h[r.format].isCompressed;

        switch (r.glTarget) {
          case a.TEXTURE_2D:
            for (var c = 0; c < s.length; c++) {
              var f = s[c];
              u = f.texExtent.width, l = f.texExtent.height;
              var E = t[i++];
              o ? r.glInternalFmt === Ae.COMPRESSED_RGB_ETC1_WEBGL || e.extensions.noCompressedTexSubImage2D ? a.compressedTexImage2D(a.TEXTURE_2D, f.texSubres.mipLevel, r.glInternalFmt, u, l, 0, E) : a.compressedTexSubImage2D(a.TEXTURE_2D, f.texSubres.mipLevel, f.texOffset.x, f.texOffset.y, u, l, r.glFormat, E) : a.texSubImage2D(a.TEXTURE_2D, f.texSubres.mipLevel, f.texOffset.x, f.texOffset.y, u, l, r.glFormat, r.glType, E);
            }

            break;

          case a.TEXTURE_CUBE_MAP:
            for (var T = 0; T < s.length; T++) {
              var R = s[T],
                  g = R.texSubres.baseArrayLayer + R.texSubres.layerCount;

              for (_ = R.texSubres.baseArrayLayer; _ < g; ++_) {
                u = R.texExtent.width, l = R.texExtent.height;
                var d = t[i++];
                o ? r.glInternalFmt === Ae.COMPRESSED_RGB_ETC1_WEBGL || e.extensions.noCompressedTexSubImage2D ? a.compressedTexImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X + _, R.texSubres.mipLevel, r.glInternalFmt, u, l, 0, d) : a.compressedTexSubImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X + _, R.texSubres.mipLevel, R.texOffset.x, R.texOffset.y, u, l, r.glFormat, d) : a.texSubImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X + _, R.texSubres.mipLevel, R.texOffset.x, R.texOffset.y, u, l, r.glFormat, r.glType, d);
              }
            }

            break;

          default:
            console.error("Unsupported GL texture type, copy buffer to texture failed.");
        }

        r.flags & x.GEN_MIPMAP && a.generateMipmap(r.glTarget);
      }

      var je = function () {
        function e() {
          this.counts = void 0, this.offsets = void 0, this.instances = void 0, this.drawCount = 0, this.drawByIndex = !1, this.instancedDraw = !1, this.byteOffsets = void 0, this._capacity = 4, this.counts = new Int32Array(this._capacity), this.offsets = new Int32Array(this._capacity), this.instances = new Int32Array(this._capacity), this.byteOffsets = new Int32Array(this._capacity);
        }

        var t = e.prototype;
        return t.clearDraws = function () {
          this.drawCount = 0, this.drawByIndex = !1, this.instancedDraw = !1;
        }, t.setDrawInfo = function (e, t) {
          this._ensureCapacity(e), this.drawByIndex = t.indexCount > 0, this.instancedDraw = !!t.instanceCount, this.drawCount = Math.max(e + 1, this.drawCount), this.drawByIndex ? (this.counts[e] = t.indexCount, this.offsets[e] = t.firstIndex) : (this.counts[e] = t.vertexCount, this.offsets[e] = t.firstVertex), this.instances[e] = Math.max(1, t.instanceCount);
        }, t._ensureCapacity = function (e) {
          if (!(this._capacity > e)) {
            this._capacity = F(e);
            var t = new Int32Array(this._capacity),
                r = new Int32Array(this._capacity),
                s = new Int32Array(this._capacity);
            this.byteOffsets = new Int32Array(this._capacity), t.set(this.counts), r.set(this.offsets), s.set(this.instances), this.counts = t, this.offsets = r, this.instances = s;
          }
        }, e;
      }(),
          Ze = function (e) {
        function r() {
          for (var t, r = arguments.length, s = new Array(r), a = 0; a < r; a++) {
            s[a] = arguments[a];
          }

          return (t = e.call.apply(e, [this].concat(s)) || this)._gpuBuffer = null, t._gpuBufferView = null, t._uniformBuffer = null, t;
        }

        t(r, e);
        var s = r.prototype;
        return s.initialize = function (e) {
          if ("buffer" in e) {
            this._isBufferView = !0;
            var t = e.buffer;
            this._usage = t.usage, this._memUsage = t.memUsage, this._size = this._stride = e.range, this._count = 1, this._flags = t.flags, this._gpuBufferView = {
              gpuBuffer: t.gpuBuffer,
              offset: e.offset,
              range: e.range
            };
          } else this._usage = e.usage, this._memUsage = e.memUsage, this._size = e.size, this._stride = Math.max(e.stride || this._size, 1), this._count = this._size / this._stride, this._flags = e.flags, this._usage & c.UNIFORM && this._size > 0 && (this._uniformBuffer = new Uint8Array(this._size)), this._gpuBuffer = {
            usage: this._usage,
            memUsage: this._memUsage,
            size: this._size,
            stride: this._stride,
            buffer: null,
            vf32: null,
            indirects: new je(),
            glTarget: 0,
            glBuffer: null
          }, this._usage & c.UNIFORM && (this._gpuBuffer.buffer = this._uniformBuffer), function (e, t) {
            var r = e.gl,
                s = e.stateCache,
                a = t.memUsage & o.HOST ? r.DYNAMIC_DRAW : r.STATIC_DRAW;

            if (t.usage & c.VERTEX) {
              t.glTarget = r.ARRAY_BUFFER;
              var n = r.createBuffer();
              n && (t.glBuffer = n, t.size > 0 && (e.extensions.useVAO && s.glVAO && (e.extensions.OES_vertex_array_object.bindVertexArrayOES(null), s.glVAO = null), Xe.gpuInputAssembler = null, e.stateCache.glArrayBuffer !== t.glBuffer && (r.bindBuffer(r.ARRAY_BUFFER, t.glBuffer), e.stateCache.glArrayBuffer = t.glBuffer), r.bufferData(r.ARRAY_BUFFER, t.size, a), r.bindBuffer(r.ARRAY_BUFFER, null), e.stateCache.glArrayBuffer = null));
            } else if (t.usage & c.INDEX) {
              t.glTarget = r.ELEMENT_ARRAY_BUFFER;
              var i = r.createBuffer();
              i && (t.glBuffer = i, t.size > 0 && (e.extensions.useVAO && s.glVAO && (e.extensions.OES_vertex_array_object.bindVertexArrayOES(null), s.glVAO = null), Xe.gpuInputAssembler = null, e.stateCache.glElementArrayBuffer !== t.glBuffer && (r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, t.glBuffer), e.stateCache.glElementArrayBuffer = t.glBuffer), r.bufferData(r.ELEMENT_ARRAY_BUFFER, t.size, a), r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, null), e.stateCache.glElementArrayBuffer = null));
            } else t.usage & c.UNIFORM ? (t.glTarget = r.NONE, t.buffer && (t.vf32 = new Float32Array(t.buffer.buffer))) : (t.usage & c.INDIRECT || t.usage & c.TRANSFER_DST || t.usage & c.TRANSFER_SRC || console.error("Unsupported BufferType, create buffer failed."), t.glTarget = r.NONE);
          }(pe.instance, this._gpuBuffer), pe.instance.memoryStatus.bufferSize += this._size;
        }, s.destroy = function () {
          this._gpuBuffer && (function (e, t) {
            var r = e.gl,
                s = e.stateCache;

            if (t.glBuffer) {
              switch (t.glTarget) {
                case r.ARRAY_BUFFER:
                  e.extensions.useVAO && s.glVAO && (e.extensions.OES_vertex_array_object.bindVertexArrayOES(null), e.stateCache.glVAO = null), Xe.gpuInputAssembler = null, r.bindBuffer(r.ARRAY_BUFFER, null), e.stateCache.glArrayBuffer = null;
                  break;

                case r.ELEMENT_ARRAY_BUFFER:
                  e.extensions.useVAO && s.glVAO && (e.extensions.OES_vertex_array_object.bindVertexArrayOES(null), e.stateCache.glVAO = null), Xe.gpuInputAssembler = null, r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, null), e.stateCache.glElementArrayBuffer = null;
              }

              r.deleteBuffer(t.glBuffer), t.glBuffer = null;
            }
          }(pe.instance, this._gpuBuffer), pe.instance.memoryStatus.bufferSize -= this._size, this._gpuBuffer = null), this._gpuBufferView && (this._gpuBufferView = null);
        }, s.resize = function (e) {
          if (this._isBufferView) console.warn("cannot resize buffer views!");else {
            var t,
                r,
                s,
                a,
                n,
                i = this._size;
            i !== e && (this._size = e, this._count = this._size / this._stride, this._uniformBuffer && (this._uniformBuffer = new Uint8Array(e)), this._gpuBuffer && (this._uniformBuffer && (this._gpuBuffer.buffer = this._uniformBuffer), this._gpuBuffer.size = e, e > 0 && (t = pe.instance, r = this._gpuBuffer, s = t.gl, a = t.stateCache, n = r.memUsage & o.HOST ? s.DYNAMIC_DRAW : s.STATIC_DRAW, r.usage & c.VERTEX ? (t.extensions.useVAO && a.glVAO && (t.extensions.OES_vertex_array_object.bindVertexArrayOES(null), a.glVAO = null), Xe.gpuInputAssembler = null, t.stateCache.glArrayBuffer !== r.glBuffer && s.bindBuffer(s.ARRAY_BUFFER, r.glBuffer), r.buffer ? s.bufferData(s.ARRAY_BUFFER, r.buffer, n) : s.bufferData(s.ARRAY_BUFFER, r.size, n), s.bindBuffer(s.ARRAY_BUFFER, null), t.stateCache.glArrayBuffer = null) : r.usage & c.INDEX ? (t.extensions.useVAO && a.glVAO && (t.extensions.OES_vertex_array_object.bindVertexArrayOES(null), a.glVAO = null), Xe.gpuInputAssembler = null, t.stateCache.glElementArrayBuffer !== r.glBuffer && s.bindBuffer(s.ELEMENT_ARRAY_BUFFER, r.glBuffer), r.buffer ? s.bufferData(s.ELEMENT_ARRAY_BUFFER, r.buffer, n) : s.bufferData(s.ELEMENT_ARRAY_BUFFER, r.size, n), s.bindBuffer(s.ELEMENT_ARRAY_BUFFER, null), t.stateCache.glElementArrayBuffer = null) : r.usage & c.UNIFORM ? r.buffer && (r.vf32 = new Float32Array(r.buffer.buffer)) : (r.usage & c.INDIRECT || r.usage & c.TRANSFER_DST || r.usage & c.TRANSFER_SRC || console.error("Unsupported BufferType, create buffer failed."), r.glTarget = s.NONE), pe.instance.memoryStatus.bufferSize -= i, pe.instance.memoryStatus.bufferSize += e)));
          }
        }, s.update = function (e, t) {
          var r;
          this._isBufferView ? console.warn("cannot update through buffer views!") : (r = void 0 !== t ? t : this._usage & c.INDIRECT ? 0 : e.byteLength, ke(pe.instance, this._gpuBuffer, e, 0, r));
        }, a(r, [{
          key: "gpuBuffer",
          get: function get() {
            return this._gpuBuffer;
          }
        }, {
          key: "gpuBufferView",
          get: function get() {
            return this._gpuBufferView;
          }
        }]), r;
      }(v),
          Qe = function () {
        function e(e, t) {
          this._frees = void 0, this._freeIdx = 0, this._freeCmds = void 0, this._frees = new Array(t), this._freeCmds = new P(t);

          for (var r = 0; r < t; ++r) {
            this._frees[r] = new e();
          }

          this._freeIdx = t - 1;
        }

        var t = e.prototype;
        return t.alloc = function (e) {
          if (this._freeIdx < 0) {
            var t = 2 * this._frees.length,
                r = this._frees;
            this._frees = new Array(t);

            for (var s = t - r.length, a = 0; a < s; ++a) {
              this._frees[a] = new e();
            }

            for (var n = s, i = 0; n < t; ++n, ++i) {
              this._frees[n] = r[i];
            }

            this._freeIdx += s;
          }

          var u = this._frees[this._freeIdx];
          return this._frees[this._freeIdx--] = null, ++u.refCount, u;
        }, t.free = function (e) {
          0 == --e.refCount && this._freeCmds.push(e);
        }, t.freeCmds = function (e) {
          for (var t = 0; t < e.length; ++t) {
            0 == --e.array[t].refCount && this._freeCmds.push(e.array[t]);
          }
        }, t.release = function () {
          for (var e = 0; e < this._freeCmds.length; ++e) {
            var t = this._freeCmds.array[e];
            t.clear(), this._frees[++this._freeIdx] = t;
          }

          this._freeCmds.clear();
        }, e;
      }(),
          $e = function () {
        function e() {
          this.beginRenderPassCmdPool = void 0, this.bindStatesCmdPool = void 0, this.drawCmdPool = void 0, this.updateBufferCmdPool = void 0, this.copyBufferToTextureCmdPool = void 0, this.beginRenderPassCmdPool = new Qe(Le, 1), this.bindStatesCmdPool = new Qe(De, 1), this.drawCmdPool = new Qe(Me, 1), this.updateBufferCmdPool = new Qe(Ne, 1), this.copyBufferToTextureCmdPool = new Qe(Ue, 1);
        }

        var t = e.prototype;
        return t.clearCmds = function (e) {
          e.beginRenderPassCmds.length && (this.beginRenderPassCmdPool.freeCmds(e.beginRenderPassCmds), e.beginRenderPassCmds.clear()), e.bindStatesCmds.length && (this.bindStatesCmdPool.freeCmds(e.bindStatesCmds), e.bindStatesCmds.clear()), e.drawCmds.length && (this.drawCmdPool.freeCmds(e.drawCmds), e.drawCmds.clear()), e.updateBufferCmds.length && (this.updateBufferCmdPool.freeCmds(e.updateBufferCmds), e.updateBufferCmds.clear()), e.copyBufferToTextureCmds.length && (this.copyBufferToTextureCmdPool.freeCmds(e.copyBufferToTextureCmds), e.copyBufferToTextureCmds.clear()), e.cmds.clear();
        }, t.releaseCmds = function () {
          this.beginRenderPassCmdPool.release(), this.bindStatesCmdPool.release(), this.drawCmdPool.release(), this.updateBufferCmdPool.release(), this.copyBufferToTextureCmdPool.release();
        }, e;
      }(),
          Je = function (e) {
        function r() {
          for (var t, r = arguments.length, s = new Array(r), a = 0; a < r; a++) {
            s[a] = arguments[a];
          }

          return (t = e.call.apply(e, [this].concat(s)) || this).cmdPackage = new we(), t._cmdAllocator = new $e(), t._isInRenderPass = !1, t._curGPUPipelineState = null, t._curGPUInputAssembler = null, t._curGPUDescriptorSets = [], t._curDynamicOffsets = Array(8).fill(0), t._curDynamicStates = new l(), t._isStateInvalied = !1, t;
        }

        t(r, e);
        var s = r.prototype;
        return s.initialize = function (e) {
          this._type = e.type, this._queue = e.queue;

          for (var t = pe.instance.bindingMappings.blockOffsets.length, r = 0; r < t; r++) {
            this._curGPUDescriptorSets.push(null);
          }
        }, s.destroy = function () {
          this._cmdAllocator.clearCmds(this.cmdPackage);
        }, s.begin = function () {
          this._cmdAllocator.clearCmds(this.cmdPackage), this._curGPUPipelineState = null, this._curGPUInputAssembler = null, this._curGPUDescriptorSets.length = 0, this._numDrawCalls = 0, this._numInstances = 0, this._numTris = 0;
        }, s.end = function () {
          this._isStateInvalied && this.bindStates(), this._isInRenderPass = !1;
        }, s.beginRenderPass = function (e, t, r, s, a, n) {
          var i = this._cmdAllocator.beginRenderPassCmdPool.alloc(Le);

          i.gpuRenderPass = e.gpuRenderPass, i.gpuFramebuffer = t.gpuFramebuffer, i.renderArea.copy(r), i.clearColors.length = s.length;

          for (var u = 0; u < s.length; ++u) {
            i.clearColors[u] = s[u];
          }

          i.clearDepth = a, i.clearStencil = n, this.cmdPackage.beginRenderPassCmds.push(i), this.cmdPackage.cmds.push(Fe.BEGIN_RENDER_PASS), this._isInRenderPass = !0;
        }, s.endRenderPass = function () {
          this._isInRenderPass = !1;
        }, s.bindPipelineState = function (e) {
          var t = e.gpuPipelineState;
          t !== this._curGPUPipelineState && (this._curGPUPipelineState = t, this._isStateInvalied = !0);
        }, s.bindDescriptorSet = function (e, t, r) {
          var s = t.gpuDescriptorSet;

          if (s !== this._curGPUDescriptorSets[e] && (this._curGPUDescriptorSets[e] = s, this._isStateInvalied = !0), r) {
            var a,
                n = null === (a = this._curGPUPipelineState) || void 0 === a ? void 0 : a.gpuPipelineLayout;

            if (n) {
              for (var i = this._curDynamicOffsets, u = n.dynamicOffsetOffsets[e], l = 0; l < r.length; l++) {
                i[u + l] = r[l];
              }

              this._isStateInvalied = !0;
            }
          }
        }, s.bindInputAssembler = function (e) {
          var t = e.gpuInputAssembler;
          this._curGPUInputAssembler = t, this._isStateInvalied = !0;
        }, s.setViewport = function (e) {
          var t = this._curDynamicStates.viewport;
          t.left === e.left && t.top === e.top && t.width === e.width && t.height === e.height && t.minDepth === e.minDepth && t.maxDepth === e.maxDepth || (t.left = e.left, t.top = e.top, t.width = e.width, t.height = e.height, t.minDepth = e.minDepth, t.maxDepth = e.maxDepth, this._isStateInvalied = !0);
        }, s.setScissor = function (e) {
          var t = this._curDynamicStates.scissor;
          t.x === e.x && t.y === e.y && t.width === e.width && t.height === e.height || (t.x = e.x, t.y = e.y, t.width = e.width, t.height = e.height, this._isStateInvalied = !0);
        }, s.setLineWidth = function (e) {
          this._curDynamicStates.lineWidth !== e && (this._curDynamicStates.lineWidth = e, this._isStateInvalied = !0);
        }, s.setDepthBias = function (e, t, r) {
          var s = this._curDynamicStates;
          s.depthBiasConstant === e && s.depthBiasClamp === t && s.depthBiasSlope === r || (s.depthBiasConstant = e, s.depthBiasClamp = t, s.depthBiasSlope = r, this._isStateInvalied = !0);
        }, s.setBlendConstants = function (e) {
          var t = this._curDynamicStates.blendConstant;
          t.x === e.x && t.y === e.y && t.z === e.z && t.w === e.w || (t.copy(e), this._isStateInvalied = !0);
        }, s.setDepthBound = function (e, t) {
          var r = this._curDynamicStates;
          r.depthMinBounds === e && r.depthMaxBounds === t || (r.depthMinBounds = e, r.depthMaxBounds = t, this._isStateInvalied = !0);
        }, s.setStencilWriteMask = function (e, t) {
          var r = this._curDynamicStates.stencilStatesFront,
              s = this._curDynamicStates.stencilStatesBack;
          e & G.FRONT && r.writeMask !== t && (r.writeMask = t, this._isStateInvalied = !0), e & G.BACK && s.writeMask !== t && (s.writeMask = t, this._isStateInvalied = !0);
        }, s.setStencilCompareMask = function (e, t, r) {
          var s = this._curDynamicStates.stencilStatesFront,
              a = this._curDynamicStates.stencilStatesBack;
          e & G.FRONT && (s.compareMask === r && s.reference === t || (s.reference = t, s.compareMask = r, this._isStateInvalied = !0)), e & G.BACK && (a.compareMask === r && a.reference === t || (a.reference = t, a.compareMask = r, this._isStateInvalied = !0));
        }, s.draw = function (e) {
          if (this._type === O.PRIMARY && this._isInRenderPass || this._type === O.SECONDARY) {
            this._isStateInvalied && this.bindStates();

            var t = "drawInfo" in e ? e.drawInfo : e,
                r = this._cmdAllocator.drawCmdPool.alloc(Me);

            r.drawInfo.copy(t), this.cmdPackage.drawCmds.push(r), this.cmdPackage.cmds.push(Fe.DRAW), ++this._numDrawCalls, this._numInstances += t.instanceCount;
            var s = t.indexCount || t.vertexCount;
            if (this._curGPUPipelineState) switch (this._curGPUPipelineState.glPrimitive) {
              case 4:
                this._numTris += s / 3 * Math.max(t.instanceCount, 1);
                break;

              case 5:
              case 6:
                this._numTris += (s - 2) * Math.max(t.instanceCount, 1);
            }
          } else console.error("Command 'draw' must be recorded inside a render pass.");
        }, s.updateBuffer = function (e, t, r) {
          if (this._type === O.PRIMARY && !this._isInRenderPass || this._type === O.SECONDARY) {
            var s = e.gpuBuffer;

            if (s) {
              var a,
                  n = this._cmdAllocator.updateBufferCmdPool.alloc(Ne),
                  i = 0;

              e.usage & c.INDIRECT || (i = void 0 !== r ? r : t.byteLength), a = t, n.gpuBuffer = s, n.buffer = a, n.offset = 0, n.size = i, this.cmdPackage.updateBufferCmds.push(n), this.cmdPackage.cmds.push(Fe.UPDATE_BUFFER);
            }
          } else console.error("Command 'updateBuffer' must be recorded outside a render pass.");
        }, s.copyBuffersToTexture = function (e, t, r) {
          if (this._type === O.PRIMARY && !this._isInRenderPass || this._type === O.SECONDARY) {
            var s = t.gpuTexture;

            if (s) {
              var a = this._cmdAllocator.copyBufferToTextureCmdPool.alloc(Ue);

              a && (a.gpuTexture = s, a.regions = r, a.buffers = e, this.cmdPackage.copyBufferToTextureCmds.push(a), this.cmdPackage.cmds.push(Fe.COPY_BUFFER_TO_TEXTURE));
            }
          } else console.error("Command 'copyBufferToTexture' must be recorded outside a render pass.");
        }, s.execute = function (e, t) {
          for (var r = 0; r < t; ++r) {
            for (var s = e[r], a = 0; a < s.cmdPackage.beginRenderPassCmds.length; ++a) {
              var n = s.cmdPackage.beginRenderPassCmds.array[a];
              ++n.refCount, this.cmdPackage.beginRenderPassCmds.push(n);
            }

            for (var i = 0; i < s.cmdPackage.bindStatesCmds.length; ++i) {
              var u = s.cmdPackage.bindStatesCmds.array[i];
              ++u.refCount, this.cmdPackage.bindStatesCmds.push(u);
            }

            for (var l = 0; l < s.cmdPackage.drawCmds.length; ++l) {
              var _ = s.cmdPackage.drawCmds.array[l];
              ++_.refCount, this.cmdPackage.drawCmds.push(_);
            }

            for (var o = 0; o < s.cmdPackage.updateBufferCmds.length; ++o) {
              var c = s.cmdPackage.updateBufferCmds.array[o];
              ++c.refCount, this.cmdPackage.updateBufferCmds.push(c);
            }

            for (var f = 0; f < s.cmdPackage.copyBufferToTextureCmds.length; ++f) {
              var E = s.cmdPackage.copyBufferToTextureCmds.array[f];
              ++E.refCount, this.cmdPackage.copyBufferToTextureCmds.push(E);
            }

            this.cmdPackage.cmds.concat(s.cmdPackage.cmds.array), this._numDrawCalls += s._numDrawCalls, this._numInstances += s._numInstances, this._numTris += s._numTris;
          }
        }, s.pipelineBarrier = function () {}, s.bindStates = function () {
          var e = this._cmdAllocator.bindStatesCmdPool.alloc(De);

          e && (e.gpuPipelineState = this._curGPUPipelineState, Array.prototype.push.apply(e.gpuDescriptorSets, this._curGPUDescriptorSets), Array.prototype.push.apply(e.dynamicOffsets, this._curDynamicOffsets), e.gpuInputAssembler = this._curGPUInputAssembler, e.dynamicStates.copy(this._curDynamicStates), this.cmdPackage.bindStatesCmds.push(e), this.cmdPackage.cmds.push(Fe.BIND_STATES), this._isStateInvalied = !1);
        }, r;
      }(I),
          et = function (e) {
        function r() {
          for (var t, r = arguments.length, s = new Array(r), a = 0; a < r; a++) {
            s[a] = arguments[a];
          }

          return (t = e.call.apply(e, [this].concat(s)) || this)._gpuFramebuffer = null, t;
        }

        t(r, e);
        var s = r.prototype;
        return s.initialize = function (e) {
          this._renderPass = e.renderPass, this._colorTextures = e.colorTextures || [], this._depthStencilTexture = e.depthStencilTexture || null;

          for (var t = 0, r = [], s = 0; s < e.colorTextures.length; ++s) {
            var a = e.colorTextures[s];
            a && (r.push(a.gpuTexture), t = a.lodLevel);
          }

          var n = null;
          e.depthStencilTexture && (n = e.depthStencilTexture.gpuTexture, t = e.depthStencilTexture.lodLevel);
          var i = Number.MAX_SAFE_INTEGER,
              u = Number.MAX_SAFE_INTEGER;
          this._gpuFramebuffer = {
            gpuRenderPass: e.renderPass.gpuRenderPass,
            gpuColorTextures: r,
            gpuDepthStencilTexture: n,
            glFramebuffer: null,
            isOffscreen: !0,

            get width() {
              return this.isOffscreen ? i : this.gpuColorTextures[0].width;
            },

            set width(e) {
              i = e;
            },

            get height() {
              return this.isOffscreen ? u : this.gpuColorTextures[0].height;
            },

            set height(e) {
              u = e;
            },

            lodLevel: t
          }, function (e, t) {
            for (var r = 0; r < t.gpuColorTextures.length; ++r) {
              if (t.gpuColorTextures[r].isSwapchainTexture) return void (t.isOffscreen = !1);
            }

            var s = e.gl,
                a = [],
                n = s.createFramebuffer();

            if (n) {
              t.glFramebuffer = n, e.stateCache.glFramebuffer !== t.glFramebuffer && s.bindFramebuffer(s.FRAMEBUFFER, t.glFramebuffer);

              for (var i = 0; i < t.gpuColorTextures.length; ++i) {
                var u = t.gpuColorTextures[i];
                u && (u.glTexture ? s.framebufferTexture2D(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0 + i, u.glTarget, u.glTexture, 0) : s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0 + i, s.RENDERBUFFER, u.glRenderbuffer), a.push(s.COLOR_ATTACHMENT0 + i), t.width = Math.min(t.width, u.width), t.height = Math.min(t.height, u.height));
              }

              var l = t.gpuDepthStencilTexture;

              if (l) {
                var _ = h[l.format].hasStencil ? s.DEPTH_STENCIL_ATTACHMENT : s.DEPTH_ATTACHMENT;

                l.glTexture ? s.framebufferTexture2D(s.FRAMEBUFFER, _, l.glTarget, l.glTexture, 0) : s.framebufferRenderbuffer(s.FRAMEBUFFER, _, s.RENDERBUFFER, l.glRenderbuffer), t.width = Math.min(t.width, l.width), t.height = Math.min(t.height, l.height);
              }

              e.extensions.WEBGL_draw_buffers && e.extensions.WEBGL_draw_buffers.drawBuffersWEBGL(a);
              var o = s.checkFramebufferStatus(s.FRAMEBUFFER);
              if (o !== s.FRAMEBUFFER_COMPLETE) switch (o) {
                case s.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
                  console.error("glCheckFramebufferStatus() - FRAMEBUFFER_INCOMPLETE_ATTACHMENT");
                  break;

                case s.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
                  console.error("glCheckFramebufferStatus() - FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT");
                  break;

                case s.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
                  console.error("glCheckFramebufferStatus() - FRAMEBUFFER_INCOMPLETE_DIMENSIONS");
                  break;

                case s.FRAMEBUFFER_UNSUPPORTED:
                  console.error("glCheckFramebufferStatus() - FRAMEBUFFER_UNSUPPORTED");
              }
              e.stateCache.glFramebuffer !== t.glFramebuffer && s.bindFramebuffer(s.FRAMEBUFFER, e.stateCache.glFramebuffer);
            }
          }(pe.instance, this._gpuFramebuffer);
        }, s.destroy = function () {
          var e, t;
          this._gpuFramebuffer && (e = pe.instance, (t = this._gpuFramebuffer).glFramebuffer && (e.gl.deleteFramebuffer(t.glFramebuffer), e.stateCache.glFramebuffer === t.glFramebuffer && (e.gl.bindFramebuffer(e.gl.FRAMEBUFFER, null), e.stateCache.glFramebuffer = null), t.glFramebuffer = null), this._gpuFramebuffer = null);
        }, a(r, [{
          key: "gpuFramebuffer",
          get: function get() {
            return this._gpuFramebuffer;
          }
        }]), r;
      }(y),
          tt = function (e) {
        function r() {
          for (var t, r = arguments.length, s = new Array(r), a = 0; a < r; a++) {
            s[a] = arguments[a];
          }

          return (t = e.call.apply(e, [this].concat(s)) || this)._gpuInputAssembler = null, t;
        }

        t(r, e);
        var s = r.prototype;
        return s.initialize = function (e) {
          if (0 !== e.vertexBuffers.length) {
            if (this._attributes = e.attributes, this._attributesHash = this.computeAttributesHash(), this._vertexBuffers = e.vertexBuffers, e.indexBuffer) this._indexBuffer = e.indexBuffer, this._drawInfo.indexCount = this._indexBuffer.size / this._indexBuffer.stride, this._drawInfo.firstIndex = 0;else {
              var t = this._vertexBuffers[0];
              this._drawInfo.vertexCount = t.size / t.stride, this._drawInfo.firstVertex = 0, this._drawInfo.vertexOffset = 0;
            }
            this._drawInfo.instanceCount = 0, this._drawInfo.firstInstance = 0, this._indirectBuffer = e.indirectBuffer || null;

            for (var r = new Array(e.vertexBuffers.length), s = 0; s < e.vertexBuffers.length; ++s) {
              var a = e.vertexBuffers[s];
              a.gpuBuffer && (r[s] = a.gpuBuffer);
            }

            var n = null,
                i = 0;
            if (e.indexBuffer && (n = e.indexBuffer.gpuBuffer)) switch (n.stride) {
              case 1:
                i = 5121;
                break;

              case 2:
                i = 5123;
                break;

              case 4:
                i = 5125;
                break;

              default:
                console.error("Error index buffer stride.");
            }
            var u = null;
            e.indirectBuffer && (u = e.indirectBuffer.gpuBuffer), this._gpuInputAssembler = {
              attributes: e.attributes,
              gpuVertexBuffers: r,
              gpuIndexBuffer: n,
              gpuIndirectBuffer: u,
              glAttribs: [],
              glIndexType: i,
              glVAOs: new Map()
            }, function (e, t) {
              var r = e.gl;
              t.glAttribs = new Array(t.attributes.length);

              for (var s = [0, 0, 0, 0, 0, 0, 0, 0], a = 0; a < t.attributes.length; ++a) {
                var n = t.attributes[a],
                    i = void 0 !== n.stream ? n.stream : 0,
                    u = t.gpuVertexBuffers[i],
                    l = Ce(n.format, r),
                    _ = h[n.format].size;
                t.glAttribs[a] = {
                  name: n.name,
                  glBuffer: u.glBuffer,
                  glType: l,
                  size: _,
                  count: h[n.format].count,
                  stride: u.stride,
                  componentCount: Pe(l, r),
                  isNormalized: void 0 !== n.isNormalized && n.isNormalized,
                  isInstanced: void 0 !== n.isInstanced && n.isInstanced,
                  offset: s[i]
                }, s[i] += _;
              }
            }(pe.instance, this._gpuInputAssembler);
          } else console.error("InputAssemblerInfo.vertexBuffers is null.");
        }, s.destroy = function () {
          var e = pe.instance;
          this._gpuInputAssembler && e.extensions.useVAO && function (e, t) {
            for (var r = t.glVAOs.values(), s = r.next(), a = e.extensions.OES_vertex_array_object, n = e.stateCache.glVAO; !s.done;) {
              a.deleteVertexArrayOES(s.value), n === s.value && (a.bindVertexArrayOES(null), n = null), s = r.next();
            }

            e.stateCache.glVAO = n, t.glVAOs.clear();
          }(e, this._gpuInputAssembler), this._gpuInputAssembler = null;
        }, a(r, [{
          key: "gpuInputAssembler",
          get: function get() {
            return this._gpuInputAssembler;
          }
        }]), r;
      }(L),
          rt = function (e) {
        function r() {
          for (var t, r = arguments.length, s = new Array(r), a = 0; a < r; a++) {
            s[a] = arguments[a];
          }

          return (t = e.call.apply(e, [this].concat(s)) || this)._gpuDescriptorSetLayout = null, t;
        }

        t(r, e);
        var s = r.prototype;
        return s.initialize = function (e) {
          Array.prototype.push.apply(this._bindings, e.bindings);

          for (var t = 0, r = -1, s = [], a = 0; a < this._bindings.length; a++) {
            var n = this._bindings[a];
            s.push(t), t += n.count, n.binding > r && (r = n.binding);
          }

          this._bindingIndices = Array(r + 1).fill(-1);

          for (var i = this._descriptorIndices = Array(r + 1).fill(-1), u = 0; u < this._bindings.length; u++) {
            var l = this._bindings[u];
            this._bindingIndices[l.binding] = u, i[l.binding] = s[u];
          }

          for (var _ = [], o = 0; o < this._bindings.length; o++) {
            var c = this._bindings[o];
            if (c.descriptorType & D) for (var f = 0; f < c.count; f++) {
              _.push(c.binding);
            }
          }

          this._gpuDescriptorSetLayout = {
            bindings: this._bindings,
            dynamicBindings: _,
            descriptorIndices: i,
            descriptorCount: t
          };
        }, s.destroy = function () {
          this._bindings.length = 0;
        }, a(r, [{
          key: "gpuDescriptorSetLayout",
          get: function get() {
            return this._gpuDescriptorSetLayout;
          }
        }]), r;
      }(M),
          st = function (e) {
        function r() {
          for (var t, r = arguments.length, s = new Array(r), a = 0; a < r; a++) {
            s[a] = arguments[a];
          }

          return (t = e.call.apply(e, [this].concat(s)) || this)._gpuPipelineLayout = null, t;
        }

        t(r, e);
        var s = r.prototype;
        return s.initialize = function (e) {
          Array.prototype.push.apply(this._setLayouts, e.setLayouts);

          for (var t = [], r = [], s = 0, a = [], n = 0; n < this._setLayouts.length; n++) {
            for (var i = this._setLayouts[n], u = i.gpuDescriptorSetLayout.dynamicBindings, l = Array(i.bindingIndices.length).fill(-1), _ = 0; _ < u.length; _++) {
              var o = u[_];
              l[o] < 0 && (l[o] = s + _);
            }

            r.push(i.gpuDescriptorSetLayout), t.push(l), a.push(s), s += u.length;
          }

          this._gpuPipelineLayout = {
            gpuSetLayouts: r,
            dynamicOffsetIndices: t,
            dynamicOffsetCount: s,
            dynamicOffsetOffsets: a
          };
        }, s.destroy = function () {
          this._setLayouts.length = 0;
        }, a(r, [{
          key: "gpuPipelineLayout",
          get: function get() {
            return this._gpuPipelineLayout;
          }
        }]), r;
      }(N),
          at = [0, 1, 3, 2, 0, 0, 0, 4, 5, 6, 0, 0, 0, 0],
          nt = function (e) {
        function r() {
          for (var t, r = arguments.length, s = new Array(r), a = 0; a < r; a++) {
            s[a] = arguments[a];
          }

          return (t = e.call.apply(e, [this].concat(s)) || this)._gpuPipelineState = null, t;
        }

        t(r, e);
        var s = r.prototype;
        return s.initialize = function (e) {
          this._primitive = e.primitive, this._shader = e.shader, this._pipelineLayout = e.pipelineLayout;
          var t = this._bs;

          if (e.blendState) {
            var r = e.blendState,
                s = r.targets;
            s && s.forEach(function (e, r) {
              t.setTarget(r, e);
            }), void 0 !== r.isA2C && (t.isA2C = r.isA2C), void 0 !== r.isIndepend && (t.isIndepend = r.isIndepend), void 0 !== r.blendColor && (t.blendColor = r.blendColor);
          }

          Object.assign(this._rs, e.rasterizerState), Object.assign(this._dss, e.depthStencilState), this._is = e.inputState, this._renderPass = e.renderPass, this._dynamicStates = e.dynamicStates;

          for (var a = [], n = 0; n < 31; n++) {
            this._dynamicStates & 1 << n && a.push(1 << n);
          }

          this._gpuPipelineState = {
            glPrimitive: at[e.primitive],
            gpuShader: e.shader.gpuShader,
            gpuPipelineLayout: e.pipelineLayout.gpuPipelineLayout,
            rs: e.rasterizerState,
            dss: e.depthStencilState,
            bs: e.blendState,
            gpuRenderPass: e.renderPass.gpuRenderPass,
            dynamicStates: a
          };
        }, s.destroy = function () {
          this._gpuPipelineState = null;
        }, a(r, [{
          key: "gpuPipelineState",
          get: function get() {
            return this._gpuPipelineState;
          }
        }]), r;
      }(U),
          it = function (e) {
        function r() {
          return e.apply(this, arguments) || this;
        }

        t(r, e);
        var s = r.prototype;
        return s.beginRenderPass = function (e, t, r, s, a, n) {
          Ve(pe.instance, e.gpuRenderPass, t.gpuFramebuffer, r, s, a, n), this._isInRenderPass = !0;
        }, s.draw = function (e) {
          if (this._isInRenderPass) {
            this._isStateInvalied && this.bindStates();
            var t = "drawInfo" in e ? e.drawInfo : e;
            ze(pe.instance, t), ++this._numDrawCalls, this._numInstances += t.instanceCount;
            var r = t.indexCount || t.vertexCount;
            if (this._curGPUPipelineState) switch (this._curGPUPipelineState.glPrimitive) {
              case 4:
                this._numTris += r / 3 * Math.max(t.instanceCount, 1);
                break;

              case 5:
              case 6:
                this._numTris += (r - 2) * Math.max(t.instanceCount, 1);
            }
          } else console.error("Command 'draw' must be recorded inside a render pass.");
        }, s.setViewport = function (e) {
          var t = pe.instance,
              r = t.stateCache,
              s = t.gl;
          r.viewport.left === e.left && r.viewport.top === e.top && r.viewport.width === e.width && r.viewport.height === e.height || (s.viewport(e.left, e.top, e.width, e.height), r.viewport.left = e.left, r.viewport.top = e.top, r.viewport.width = e.width, r.viewport.height = e.height);
        }, s.setScissor = function (e) {
          var t = pe.instance,
              r = t.stateCache,
              s = t.gl;
          r.scissorRect.x === e.x && r.scissorRect.y === e.y && r.scissorRect.width === e.width && r.scissorRect.height === e.height || (s.scissor(e.x, e.y, e.width, e.height), r.scissorRect.x = e.x, r.scissorRect.y = e.y, r.scissorRect.width = e.width, r.scissorRect.height = e.height);
        }, s.updateBuffer = function (e, t, r) {
          if (this._isInRenderPass) console.error("Command 'updateBuffer' must be recorded outside a render pass.");else {
            var s,
                a = e.gpuBuffer;
            a && (s = void 0 !== r ? r : e.usage & c.INDIRECT ? 0 : t.byteLength, ke(pe.instance, a, t, 0, s));
          }
        }, s.copyBuffersToTexture = function (e, t, r) {
          if (this._isInRenderPass) console.error("Command 'copyBufferToTexture' must be recorded outside a render pass.");else {
            var s = t.gpuTexture;
            s && qe(pe.instance, e, s, r);
          }
        }, s.execute = function (e, t) {
          for (var r = 0; r < t; ++r) {
            var s = e[r];
            Ye(pe.instance, s.cmdPackage), this._numDrawCalls += s._numDrawCalls, this._numInstances += s._numInstances, this._numTris += s._numTris;
          }
        }, s.bindStates = function () {
          We(pe.instance, this._curGPUPipelineState, this._curGPUInputAssembler, this._curGPUDescriptorSets, this._curDynamicOffsets, this._curDynamicStates), this._isStateInvalied = !1;
        }, r;
      }(Je),
          ut = function (e) {
        function r() {
          for (var t, r = arguments.length, s = new Array(r), a = 0; a < r; a++) {
            s[a] = arguments[a];
          }

          return (t = e.call.apply(e, [this].concat(s)) || this).numDrawCalls = 0, t.numInstances = 0, t.numTris = 0, t;
        }

        t(r, e);
        var s = r.prototype;
        return s.initialize = function (e) {
          this._type = e.type;
        }, s.destroy = function () {}, s.submit = function (e) {
          for (var t = e.length, r = 0; r < t; r++) {
            var s = e[r];
            this.numDrawCalls += s.numDrawCalls, this.numInstances += s.numInstances, this.numTris += s.numTris;
          }
        }, s.clear = function () {
          this.numDrawCalls = 0, this.numInstances = 0, this.numTris = 0;
        }, r;
      }(w),
          lt = function (e) {
        function r() {
          for (var t, r = arguments.length, s = new Array(r), a = 0; a < r; a++) {
            s[a] = arguments[a];
          }

          return (t = e.call.apply(e, [this].concat(s)) || this)._gpuRenderPass = null, t;
        }

        t(r, e);
        var s = r.prototype;
        return s.initialize = function (e) {
          this._colorInfos = e.colorAttachments, this._depthStencilInfo = e.depthStencilAttachment, this._subpasses = e.subpasses, this._gpuRenderPass = {
            colorAttachments: this._colorInfos,
            depthStencilAttachment: this._depthStencilInfo
          }, this._hash = this.computeHash();
        }, s.destroy = function () {
          this._gpuRenderPass = null;
        }, a(r, [{
          key: "gpuRenderPass",
          get: function get() {
            return this._gpuRenderPass;
          }
        }]), r;
      }(k),
          _t = [10497, 33648, 33071, 33071],
          ot = function (e) {
        function r(t, r) {
          var s;
          (s = e.call(this, t, r) || this)._gpuSampler = null;
          var a,
              n,
              i = s._info.minFilter,
              u = s._info.magFilter,
              l = s._info.mipFilter;
          a = i === X.LINEAR || i === X.ANISOTROPIC ? l === X.LINEAR || l === X.ANISOTROPIC ? 9987 : l === X.POINT ? 9985 : 9729 : l === X.LINEAR || l === X.ANISOTROPIC ? 9986 : l === X.POINT ? 9984 : 9728, n = u === X.LINEAR || u === X.ANISOTROPIC ? 9729 : 9728;
          var _ = _t[s._info.addressU],
              o = _t[s._info.addressV],
              c = _t[s._info.addressW];
          return s._gpuSampler = {
            glMinFilter: a,
            glMagFilter: n,
            glWrapS: _,
            glWrapT: o,
            glWrapR: c
          }, s;
        }

        return t(r, e), a(r, [{
          key: "gpuSampler",
          get: function get() {
            return this._gpuSampler;
          }
        }]), r;
      }(H),
          ct = function (e) {
        function r() {
          for (var t, r = arguments.length, s = new Array(r), a = 0; a < r; a++) {
            s[a] = arguments[a];
          }

          return (t = e.call.apply(e, [this].concat(s)) || this)._gpuShader = null, t;
        }

        t(r, e);
        var s = r.prototype;
        return s.initialize = function (e) {
          this._name = e.name, this._stages = e.stages, this._attributes = e.attributes, this._blocks = e.blocks, this._samplers = e.samplers, this._gpuShader = {
            name: e.name,
            blocks: e.blocks.slice(),
            samplerTextures: e.samplerTextures.slice(),
            subpassInputs: e.subpassInputs.slice(),
            gpuStages: new Array(e.stages.length),
            glProgram: null,
            glInputs: [],
            glUniforms: [],
            glBlocks: [],
            glSamplerTextures: []
          };

          for (var t = 0; t < e.stages.length; ++t) {
            var r = e.stages[t];
            this._gpuShader.gpuStages[t] = {
              type: r.stage,
              source: r.source,
              glShader: null
            };
          }

          !function (e, t) {
            for (var r = e.gl, s = function s(e) {
              var s = t.gpuStages[e],
                  a = 0,
                  n = "",
                  i = 1;

              switch (s.type) {
                case b.VERTEX:
                  n = "VertexShader", a = r.VERTEX_SHADER;
                  break;

                case b.FRAGMENT:
                  n = "FragmentShader", a = r.FRAGMENT_SHADER;
                  break;

                default:
                  return console.error("Unsupported ShaderType."), {
                    v: void 0
                  };
              }

              var u = r.createShader(a);

              if (u && (s.glShader = u, r.shaderSource(s.glShader, s.source), r.compileShader(s.glShader), !r.getShaderParameter(s.glShader, r.COMPILE_STATUS))) {
                console.error(n + " in '" + t.name + "' compilation failed."), console.error("Shader source dump:", s.source.replace(/^|\n/g, function () {
                  return "\n" + i++ + " ";
                })), console.error(r.getShaderInfoLog(s.glShader));

                for (var l = 0; l < t.gpuStages.length; l++) {
                  var _ = t.gpuStages[e];
                  _.glShader && (r.deleteShader(_.glShader), _.glShader = null);
                }

                return {
                  v: void 0
                };
              }
            }, a = 0; a < t.gpuStages.length; a++) {
              var n = s(a);
              if ("object" == _typeof2(n)) return n.v;
            }

            var i = r.createProgram();

            if (i) {
              t.glProgram = i;

              for (var u = 0; u < t.gpuStages.length; u++) {
                var l = t.gpuStages[u];
                r.attachShader(t.glProgram, l.glShader);
              }

              if (r.linkProgram(t.glProgram), e.extensions.destroyShadersImmediately) for (var _ = 0; _ < t.gpuStages.length; _++) {
                var o = t.gpuStages[_];
                o.glShader && (r.detachShader(t.glProgram, o.glShader), r.deleteShader(o.glShader), o.glShader = null);
              }
              if (!r.getProgramParameter(t.glProgram, r.LINK_STATUS)) return console.error("Failed to link shader '" + t.name + "'."), void console.error(r.getProgramInfoLog(t.glProgram));
              R("Shader '" + t.name + "' compilation succeeded.");
              var c = r.getProgramParameter(t.glProgram, r.ACTIVE_ATTRIBUTES);
              t.glInputs = new Array(c);

              for (var f = 0; f < c; ++f) {
                var E = r.getActiveAttrib(t.glProgram, f);

                if (E) {
                  var h,
                      T = E.name.indexOf("[");
                  h = -1 !== T ? E.name.substr(0, T) : E.name;
                  var A = r.getAttribLocation(t.glProgram, h),
                      S = xe(E.type, r),
                      p = be(E.type, r);
                  t.glInputs[f] = {
                    binding: A,
                    name: h,
                    type: S,
                    stride: p,
                    count: E.size,
                    size: p * E.size,
                    glType: E.type,
                    glLoc: A
                  };
                }
              }

              if (t.blocks.length > 0) {
                t.glBlocks = new Array(t.blocks.length);

                for (var C = 0; C < t.blocks.length; ++C) {
                  var B = t.blocks[C],
                      m = {
                    set: B.set,
                    binding: B.binding,
                    name: B.name,
                    size: 0,
                    glUniforms: new Array(B.members.length),
                    glActiveUniforms: []
                  };
                  t.glBlocks[C] = m;

                  for (var x = 0; x < B.members.length; ++x) {
                    var P = B.members[x],
                        F = Be(P.type, r),
                        v = be(F, r),
                        G = v * P.count;
                    m.glUniforms[x] = {
                      binding: -1,
                      name: P.name,
                      type: P.type,
                      stride: v,
                      count: P.count,
                      size: G,
                      offset: 0,
                      glType: F,
                      glLoc: null,
                      array: null
                    };
                  }
                }
              }

              for (var O = 0; O < t.subpassInputs.length; ++O) {
                var I = t.subpassInputs[O];
                t.samplerTextures.push(new g(I.set, I.binding, I.name, d.SAMPLER2D, I.count));
              }

              if (t.samplerTextures.length > 0) {
                t.glSamplerTextures = new Array(t.samplerTextures.length);

                for (var y = 0; y < t.samplerTextures.length; ++y) {
                  var L = t.samplerTextures[y];
                  t.glSamplerTextures[y] = {
                    set: L.set,
                    binding: L.binding,
                    name: L.name,
                    type: L.type,
                    count: L.count,
                    units: [],
                    glUnits: null,
                    glType: Be(L.type, r),
                    glLoc: null
                  };
                }
              }

              for (var D = r.getProgramParameter(t.glProgram, r.ACTIVE_UNIFORMS), M = 0; M < D; ++M) {
                var N = r.getActiveUniform(t.glProgram, M);

                if (N && N.type !== r.SAMPLER_2D && N.type !== r.SAMPLER_CUBE) {
                  var U = r.getUniformLocation(t.glProgram, N.name);

                  if (e.extensions.isLocationActive(U)) {
                    var w,
                        k = N.name.indexOf("[");
                    w = -1 !== k ? N.name.substr(0, k) : N.name;

                    for (var X = 0; X < t.glBlocks.length; X++) {
                      for (var H = t.glBlocks[X], V = 0; V < H.glUniforms.length; V++) {
                        var W = H.glUniforms[V];

                        if (W.name === w) {
                          W.glLoc = U, W.count = N.size, W.size = W.stride * W.count, W.array = new (me(W.type))(W.size / 4), H.glActiveUniforms.push(W);
                          break;
                        }
                      }
                    }
                  }
                }
              }

              for (var z = 0; z < t.glBlocks.length; z++) {
                for (var K = t.glBlocks[z], Y = 0; Y < K.glUniforms.length; Y++) {
                  var q = K.glUniforms[Y];
                  q.offset = K.size / 4, K.size += q.size;
                }
              }

              for (var j = [], Z = [], Q = e.bindingMappings, $ = e.stateCache.texUnitCacheMap, J = 0, ee = 0; ee < t.blocks.length; ++ee) {
                t.blocks[ee].set === Q.flexibleSet && J++;
              }

              for (var te = 0, re = 0; re < t.samplerTextures.length; ++re) {
                var se = t.samplerTextures[re],
                    ae = r.getUniformLocation(t.glProgram, se.name);

                if (e.extensions.isLocationActive(ae) && (j.push(t.glSamplerTextures[re]), Z.push(ae)), void 0 === $[se.name]) {
                  var ne = se.binding + Q.samplerTextureOffsets[se.set] + te;
                  se.set === Q.flexibleSet && (ne -= J), $[se.name] = ne % e.capabilities.maxTextureUnits, te += se.count - 1;
                }
              }

              if (j.length) {
                for (var ie = [], ue = 0; ue < j.length; ++ue) {
                  var le = j[ue],
                      _e = $[le.name];

                  if (void 0 !== _e) {
                    le.glLoc = Z[ue];

                    for (var oe = 0; oe < le.count; ++oe) {
                      for (; ie[_e];) {
                        _e = (_e + 1) % e.capabilities.maxTextureUnits;
                      }

                      le.units.push(_e), ie[_e] = !0;
                    }
                  }
                }

                for (var ce = 0, fe = 0; fe < j.length; ++fe) {
                  var Ee = j[fe];

                  if (!e.extensions.isLocationActive(Ee.glLoc)) {
                    Ee.glLoc = Z[fe];

                    for (var he = 0; he < Ee.count; ++he) {
                      for (; ie[ce];) {
                        ce = (ce + 1) % e.capabilities.maxTextureUnits;
                      }

                      void 0 === $[Ee.name] && ($[Ee.name] = ce), Ee.units.push(ce), ie[ce] = !0;
                    }
                  }
                }

                e.stateCache.glProgram !== t.glProgram && r.useProgram(t.glProgram);

                for (var Te = 0; Te < j.length; Te++) {
                  var Re = j[Te];
                  Re.glUnits = new Int32Array(Re.units), r.uniform1iv(Re.glLoc, Re.glUnits);
                }

                e.stateCache.glProgram !== t.glProgram && r.useProgram(e.stateCache.glProgram);
              }

              for (var ge = 0; ge < t.glBlocks.length;) {
                t.glBlocks[ge].glActiveUniforms.length ? ge++ : (t.glBlocks[ge] = t.glBlocks[t.glBlocks.length - 1], t.glBlocks.length--);
              }

              t.glSamplerTextures = j;
            }
          }(pe.instance, this._gpuShader);
        }, s.destroy = function () {
          this._gpuShader && (function (e, t) {
            if (t.glProgram) {
              var r = e.gl;
              if (!e.extensions.destroyShadersImmediately) for (var s = 0; s < t.gpuStages.length; s++) {
                var a = t.gpuStages[s];
                a.glShader && (r.detachShader(t.glProgram, a.glShader), r.deleteShader(a.glShader), a.glShader = null);
              }
              r.deleteProgram(t.glProgram), e.stateCache.glProgram === t.glProgram && (e.gl.useProgram(null), e.stateCache.glProgram = null), t.glProgram = null;
            }
          }(pe.instance, this._gpuShader), this._gpuShader = null);
        }, a(r, [{
          key: "gpuShader",
          get: function get() {
            return this._gpuShader;
          }
        }]), r;
      }(V),
          ft = function () {
        function e() {
          this.glArrayBuffer = null, this.glElementArrayBuffer = null, this.glVAO = null, this.texUnit = 0, this.glTexUnits = [], this.glRenderbuffer = null, this.glFramebuffer = null, this.viewport = new W(), this.scissorRect = new i(0, 0, 0, 0), this.rs = new z(), this.dss = new K(), this.bs = new Y(), this.glProgram = null, this.glEnabledAttribLocs = [], this.glCurrentAttribLocs = [], this.texUnitCacheMap = {};
        }

        return e.prototype.initialize = function (e, t) {
          for (var r = 0; r < e; ++r) {
            this.glTexUnits.push({
              glTexture: null
            });
          }

          this.glEnabledAttribLocs.length = t, this.glEnabledAttribLocs.fill(!1), this.glCurrentAttribLocs.length = t, this.glCurrentAttribLocs.fill(!1);
        }, e;
      }(),
          Et = function (e) {
        function r() {
          for (var t, r = arguments.length, s = new Array(r), a = 0; a < r; a++) {
            s[a] = arguments[a];
          }

          return (t = e.call.apply(e, [this].concat(s)) || this)._gpuTexture = null, t._lodLevel = 0, t;
        }

        t(r, e);
        var s = r.prototype;
        return s.initialize = function (e, t) {
          var r = e,
              s = e;
          "texture" in e && (r = s.texture.info, this._isTextureView = !0), this._info.copy(r), this._isPowerOf2 = q(this._info.width) && q(this._info.height), this._size = j(this._info.format, this.width, this.height, this.depth, this._info.levelCount) * this._info.layerCount, this._isTextureView ? (this._viewInfo.copy(s), this._lodLevel = s.baseLevel, this._gpuTexture = s.texture._gpuTexture) : (this._gpuTexture = {
            type: r.type,
            format: r.format,
            usage: r.usage,
            width: r.width,
            height: r.height,
            depth: r.depth,
            size: this._size,
            arrayLayer: r.layerCount,
            mipLevel: r.levelCount,
            samples: r.samples,
            flags: r.flags,
            isPowerOf2: this._isPowerOf2,
            glTarget: 0,
            glInternalFmt: 0,
            glFormat: 0,
            glType: 0,
            glUsage: 0,
            glTexture: null,
            glRenderbuffer: null,
            glWrapS: 0,
            glWrapT: 0,
            glMinFilter: 0,
            glMagFilter: 0,
            isSwapchainTexture: t || !1
          }, function (e, t) {
            var r = e.gl;
            t.glFormat = t.glInternalFmt = function (e, t) {
              switch (e) {
                case A.A8:
                  return t.ALPHA;

                case A.L8:
                  return t.LUMINANCE;

                case A.LA8:
                  return t.LUMINANCE_ALPHA;

                case A.RGB8:
                case A.RGB16F:
                case A.RGB32F:
                  return t.RGB;

                case A.BGRA8:
                case A.RGBA8:
                case A.SRGB8_A8:
                case A.RGBA16F:
                case A.RGBA32F:
                  return t.RGBA;

                case A.R5G6B5:
                  return t.RGB;

                case A.RGB5A1:
                case A.RGBA4:
                  return t.RGBA;

                case A.DEPTH:
                  return t.DEPTH_COMPONENT;

                case A.DEPTH_STENCIL:
                  return t.DEPTH_STENCIL;

                case A.BC1:
                  return Ae.COMPRESSED_RGB_S3TC_DXT1_EXT;

                case A.BC1_ALPHA:
                  return Ae.COMPRESSED_RGBA_S3TC_DXT1_EXT;

                case A.BC1_SRGB:
                  return Ae.COMPRESSED_SRGB_S3TC_DXT1_EXT;

                case A.BC1_SRGB_ALPHA:
                  return Ae.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;

                case A.BC2:
                  return Ae.COMPRESSED_RGBA_S3TC_DXT3_EXT;

                case A.BC2_SRGB:
                  return Ae.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;

                case A.BC3:
                  return Ae.COMPRESSED_RGBA_S3TC_DXT5_EXT;

                case A.BC3_SRGB:
                  return Ae.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;

                case A.ETC_RGB8:
                  return Ae.COMPRESSED_RGB_ETC1_WEBGL;

                case A.ETC2_RGB8:
                  return Ae.COMPRESSED_RGB8_ETC2;

                case A.ETC2_SRGB8:
                  return Ae.COMPRESSED_SRGB8_ETC2;

                case A.ETC2_RGB8_A1:
                  return Ae.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2;

                case A.ETC2_SRGB8_A1:
                  return Ae.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2;

                case A.ETC2_RGBA8:
                  return Ae.COMPRESSED_RGBA8_ETC2_EAC;

                case A.ETC2_SRGB8_A8:
                  return Ae.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC;

                case A.EAC_R11:
                  return Ae.COMPRESSED_R11_EAC;

                case A.EAC_R11SN:
                  return Ae.COMPRESSED_SIGNED_R11_EAC;

                case A.EAC_RG11:
                  return Ae.COMPRESSED_RG11_EAC;

                case A.EAC_RG11SN:
                  return Ae.COMPRESSED_SIGNED_RG11_EAC;

                case A.PVRTC_RGB2:
                  return Ae.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;

                case A.PVRTC_RGBA2:
                  return Ae.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

                case A.PVRTC_RGB4:
                  return Ae.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;

                case A.PVRTC_RGBA4:
                  return Ae.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;

                case A.ASTC_RGBA_4X4:
                  return Ae.COMPRESSED_RGBA_ASTC_4x4_KHR;

                case A.ASTC_RGBA_5X4:
                  return Ae.COMPRESSED_RGBA_ASTC_5x4_KHR;

                case A.ASTC_RGBA_5X5:
                  return Ae.COMPRESSED_RGBA_ASTC_5x5_KHR;

                case A.ASTC_RGBA_6X5:
                  return Ae.COMPRESSED_RGBA_ASTC_6x5_KHR;

                case A.ASTC_RGBA_6X6:
                  return Ae.COMPRESSED_RGBA_ASTC_6x6_KHR;

                case A.ASTC_RGBA_8X5:
                  return Ae.COMPRESSED_RGBA_ASTC_8x5_KHR;

                case A.ASTC_RGBA_8X6:
                  return Ae.COMPRESSED_RGBA_ASTC_8x6_KHR;

                case A.ASTC_RGBA_8X8:
                  return Ae.COMPRESSED_RGBA_ASTC_8x8_KHR;

                case A.ASTC_RGBA_10X5:
                  return Ae.COMPRESSED_RGBA_ASTC_10x5_KHR;

                case A.ASTC_RGBA_10X6:
                  return Ae.COMPRESSED_RGBA_ASTC_10x6_KHR;

                case A.ASTC_RGBA_10X8:
                  return Ae.COMPRESSED_RGBA_ASTC_10x8_KHR;

                case A.ASTC_RGBA_10X10:
                  return Ae.COMPRESSED_RGBA_ASTC_10x10_KHR;

                case A.ASTC_RGBA_12X10:
                  return Ae.COMPRESSED_RGBA_ASTC_12x10_KHR;

                case A.ASTC_RGBA_12X12:
                  return Ae.COMPRESSED_RGBA_ASTC_12x12_KHR;

                case A.ASTC_SRGBA_4X4:
                  return Ae.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR;

                case A.ASTC_SRGBA_5X4:
                  return Ae.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR;

                case A.ASTC_SRGBA_5X5:
                  return Ae.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR;

                case A.ASTC_SRGBA_6X5:
                  return Ae.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR;

                case A.ASTC_SRGBA_6X6:
                  return Ae.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR;

                case A.ASTC_SRGBA_8X5:
                  return Ae.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR;

                case A.ASTC_SRGBA_8X6:
                  return Ae.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR;

                case A.ASTC_SRGBA_8X8:
                  return Ae.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR;

                case A.ASTC_SRGBA_10X5:
                  return Ae.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR;

                case A.ASTC_SRGBA_10X6:
                  return Ae.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR;

                case A.ASTC_SRGBA_10X8:
                  return Ae.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR;

                case A.ASTC_SRGBA_10X10:
                  return Ae.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR;

                case A.ASTC_SRGBA_12X10:
                  return Ae.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR;

                case A.ASTC_SRGBA_12X12:
                  return Ae.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR;

                default:
                  return console.error("Unsupported Format, convert to WebGL format failed."), t.RGBA;
              }
            }(t.format, r), t.glType = Ce(t.format, r);
            var s = t.width,
                a = t.height;

            switch (t.type) {
              case f.TEX2D:
                if (t.glTarget = r.TEXTURE_2D, t.isSwapchainTexture) break;
                var n = Math.max(s, a);

                if (n > e.capabilities.maxTextureSize && E(9100, n, e.capabilities.maxTextureSize), e.textureExclusive[t.format] || e.extensions.WEBGL_depth_texture || !h[t.format].hasDepth) {
                  if (t.glTexture = r.createTexture(), t.size > 0) {
                    var i = e.stateCache.glTexUnits[e.stateCache.texUnit];
                    if (i.glTexture !== t.glTexture && (r.bindTexture(r.TEXTURE_2D, t.glTexture), i.glTexture = t.glTexture), h[t.format].isCompressed) for (var u = 0; u < t.mipLevel; ++u) {
                      var l = T(t.format, s, a, 1),
                          _ = new Uint8Array(l);

                      r.compressedTexImage2D(r.TEXTURE_2D, u, t.glInternalFmt, s, a, 0, _), s = Math.max(1, s >> 1), a = Math.max(1, a >> 1);
                    } else for (var o = 0; o < t.mipLevel; ++o) {
                      r.texImage2D(r.TEXTURE_2D, o, t.glInternalFmt, s, a, 0, t.glFormat, t.glType, null), s = Math.max(1, s >> 1), a = Math.max(1, a >> 1);
                    }
                    t.isPowerOf2 ? (t.glWrapS = r.REPEAT, t.glWrapT = r.REPEAT) : (t.glWrapS = r.CLAMP_TO_EDGE, t.glWrapT = r.CLAMP_TO_EDGE), t.glMinFilter = r.LINEAR, t.glMagFilter = r.LINEAR, r.texParameteri(t.glTarget, r.TEXTURE_WRAP_S, t.glWrapS), r.texParameteri(t.glTarget, r.TEXTURE_WRAP_T, t.glWrapT), r.texParameteri(t.glTarget, r.TEXTURE_MIN_FILTER, t.glMinFilter), r.texParameteri(t.glTarget, r.TEXTURE_MAG_FILTER, t.glMagFilter);
                  }
                } else t.glInternalFmt = function (e, t) {
                  switch (e) {
                    case A.R5G6B5:
                      return t.RGB565;

                    case A.RGB5A1:
                      return t.RGB5_A1;

                    case A.RGBA4:
                      return t.RGBA4;

                    case A.RGBA16F:
                      return Ae.RGBA16F_EXT;

                    case A.RGBA32F:
                      return Ae.RGBA32F_EXT;

                    case A.SRGB8_A8:
                      return Ae.SRGB8_ALPHA8_EXT;

                    case A.DEPTH:
                      return t.DEPTH_COMPONENT16;

                    case A.DEPTH_STENCIL:
                      return t.DEPTH_STENCIL;

                    default:
                      return console.error("Unsupported Format, convert to WebGL internal format failed."), t.RGBA;
                  }
                }(t.format, r), t.glRenderbuffer = r.createRenderbuffer(), t.size > 0 && (e.stateCache.glRenderbuffer !== t.glRenderbuffer && (r.bindRenderbuffer(r.RENDERBUFFER, t.glRenderbuffer), e.stateCache.glRenderbuffer = t.glRenderbuffer), r.renderbufferStorage(r.RENDERBUFFER, t.glInternalFmt, s, a));

                break;

              case f.CUBE:
                t.glTarget = r.TEXTURE_CUBE_MAP;
                var c = Math.max(s, a);

                if (c > e.capabilities.maxCubeMapTextureSize && E(9100, c, e.capabilities.maxTextureSize), t.glTexture = r.createTexture(), t.size > 0) {
                  var R = e.stateCache.glTexUnits[e.stateCache.texUnit];
                  if (R.glTexture !== t.glTexture && (r.bindTexture(r.TEXTURE_CUBE_MAP, t.glTexture), R.glTexture = t.glTexture), h[t.format].isCompressed) for (var g = 0; g < 6; ++g) {
                    s = t.width, a = t.height;

                    for (var d = 0; d < t.mipLevel; ++d) {
                      var S = T(t.format, s, a, 1),
                          p = new Uint8Array(S);
                      r.compressedTexImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + g, d, t.glInternalFmt, s, a, 0, p), s = Math.max(1, s >> 1), a = Math.max(1, a >> 1);
                    }
                  } else for (var C = 0; C < 6; ++C) {
                    s = t.width, a = t.height;

                    for (var B = 0; B < t.mipLevel; ++B) {
                      r.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + C, B, t.glInternalFmt, s, a, 0, t.glFormat, t.glType, null), s = Math.max(1, s >> 1), a = Math.max(1, a >> 1);
                    }
                  }
                  t.isPowerOf2 ? (t.glWrapS = r.REPEAT, t.glWrapT = r.REPEAT) : (t.glWrapS = r.CLAMP_TO_EDGE, t.glWrapT = r.CLAMP_TO_EDGE), t.glMinFilter = r.LINEAR, t.glMagFilter = r.LINEAR, r.texParameteri(t.glTarget, r.TEXTURE_WRAP_S, t.glWrapS), r.texParameteri(t.glTarget, r.TEXTURE_WRAP_T, t.glWrapT), r.texParameteri(t.glTarget, r.TEXTURE_MIN_FILTER, t.glMinFilter), r.texParameteri(t.glTarget, r.TEXTURE_MAG_FILTER, t.glMagFilter);
                }

                break;

              default:
                console.error("Unsupported TextureType, create texture failed."), t.type = f.TEX2D, t.glTarget = r.TEXTURE_2D;
            }
          }(pe.instance, this._gpuTexture), pe.instance.memoryStatus.textureSize += this._size, this._viewInfo.texture = this, this._viewInfo.type = e.type, this._viewInfo.format = e.format, this._viewInfo.baseLevel = 0, this._viewInfo.levelCount = e.levelCount, this._viewInfo.baseLayer = 0, this._viewInfo.layerCount = e.layerCount);
        }, s.destroy = function () {
          !this._isTextureView && this._gpuTexture && (function (e, t) {
            var r = e.gl;

            if (t.glTexture) {
              var s = e.stateCache.glTexUnits,
                  a = e.stateCache.texUnit;
              r.deleteTexture(t.glTexture);

              for (var n = 0; n < s.length; n++) {
                s[n].glTexture === t.glTexture && (r.activeTexture(r.TEXTURE0 + n), a = n, r.bindTexture(t.glTarget, null), s[n].glTexture = null);
              }

              e.stateCache.texUnit = a, t.glTexture = null;
            }

            if (t.glRenderbuffer) {
              var i = e.stateCache.glRenderbuffer;
              r.deleteRenderbuffer(t.glRenderbuffer), i === t.glRenderbuffer && (r.bindRenderbuffer(r.RENDERBUFFER, null), i = null), t.glRenderbuffer = null;
            }
          }(pe.instance, this._gpuTexture), pe.instance.memoryStatus.textureSize -= this._size, this._gpuTexture = null);
        }, s.resize = function (e, t) {
          if (this._info.width !== e || this._info.height !== t) {
            this._info.levelCount === r.getLevelCount(this._info.width, this._info.height) ? this._info.levelCount = r.getLevelCount(e, t) : this._info.levelCount > 1 && (this._info.levelCount = Math.min(this._info.levelCount, r.getLevelCount(e, t)));
            var s = this._size;
            this._info.width = e, this._info.height = t, this._size = j(this._info.format, this.width, this.height, this.depth, this._info.levelCount) * this._info.layerCount, !this._isTextureView && this._gpuTexture && (this._gpuTexture.width = e, this._gpuTexture.height = t, this._gpuTexture.size = this._size, function (e, t) {
              if (t.size) {
                var r = e.gl,
                    s = t.width,
                    a = t.height;

                switch (t.type) {
                  case f.TEX2D:
                    t.glTarget = r.TEXTURE_2D;
                    var n = Math.max(s, a);
                    if (n > e.capabilities.maxTextureSize && E(9100, n, e.capabilities.maxTextureSize), t.glRenderbuffer) e.stateCache.glRenderbuffer !== t.glRenderbuffer && (r.bindRenderbuffer(r.RENDERBUFFER, t.glRenderbuffer), e.stateCache.glRenderbuffer = t.glRenderbuffer), r.renderbufferStorage(r.RENDERBUFFER, t.glInternalFmt, s, a);else if (t.glTexture) {
                      var i = e.stateCache.glTexUnits[e.stateCache.texUnit];
                      if (i.glTexture !== t.glTexture && (r.bindTexture(r.TEXTURE_2D, t.glTexture), i.glTexture = t.glTexture), h[t.format].isCompressed) for (var u = 0; u < t.mipLevel; ++u) {
                        var l = T(t.format, s, a, 1),
                            _ = new Uint8Array(l);

                        r.compressedTexImage2D(r.TEXTURE_2D, u, t.glInternalFmt, s, a, 0, _), s = Math.max(1, s >> 1), a = Math.max(1, a >> 1);
                      } else for (var o = 0; o < t.mipLevel; ++o) {
                        r.texImage2D(r.TEXTURE_2D, o, t.glInternalFmt, s, a, 0, t.glFormat, t.glType, null), s = Math.max(1, s >> 1), a = Math.max(1, a >> 1);
                      }
                    }
                    break;

                  case f.CUBE:
                    t.glTarget = r.TEXTURE_CUBE_MAP;
                    var c = Math.max(s, a);
                    c > e.capabilities.maxCubeMapTextureSize && E(9100, c, e.capabilities.maxTextureSize);
                    var R = e.stateCache.glTexUnits[e.stateCache.texUnit];
                    if (R.glTexture !== t.glTexture && (r.bindTexture(r.TEXTURE_CUBE_MAP, t.glTexture), R.glTexture = t.glTexture), h[t.format].isCompressed) for (var g = 0; g < 6; ++g) {
                      s = t.width, a = t.height;

                      for (var d = 0; d < t.mipLevel; ++d) {
                        var A = T(t.format, s, a, 1),
                            S = new Uint8Array(A);
                        r.compressedTexImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + g, d, t.glInternalFmt, s, a, 0, S), s = Math.max(1, s >> 1), a = Math.max(1, a >> 1);
                      }
                    } else for (var p = 0; p < 6; ++p) {
                      s = t.width, a = t.height;

                      for (var C = 0; C < t.mipLevel; ++C) {
                        r.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + p, C, t.glInternalFmt, s, a, 0, t.glFormat, t.glType, null), s = Math.max(1, s >> 1), a = Math.max(1, a >> 1);
                      }
                    }
                    break;

                  default:
                    console.error("Unsupported TextureType, create texture failed."), t.type = f.TEX2D, t.glTarget = r.TEXTURE_2D;
                }
              }
            }(pe.instance, this._gpuTexture), pe.instance.memoryStatus.textureSize -= s, pe.instance.memoryStatus.textureSize += this._size);
          }
        }, s.initAsSwapchainTexture = function (e) {
          var t = new Z();
          t.format = e.format, t.usage = h[e.format].hasDepth ? Q.DEPTH_STENCIL_ATTACHMENT : Q.COLOR_ATTACHMENT, t.width = e.width, t.height = e.height, this.initialize(t, !0);
        }, a(r, [{
          key: "gpuTexture",
          get: function get() {
            return this._gpuTexture;
          }
        }, {
          key: "lodLevel",
          get: function get() {
            return this._lodLevel;
          }
        }]), r;
      }($),
          ht = "webglcontextlost";

      function Tt(e, t) {
        for (var r = ["", "WEBKIT_", "MOZ_"], s = 0; s < r.length; ++s) {
          var a = e.getExtension(r[s] + t);
          if (a) return a;
        }

        return null;
      }

      function Rt(e) {
        var t = {
          EXT_texture_filter_anisotropic: Tt(e, "EXT_texture_filter_anisotropic"),
          EXT_blend_minmax: Tt(e, "EXT_blend_minmax"),
          EXT_frag_depth: Tt(e, "EXT_frag_depth"),
          EXT_shader_texture_lod: Tt(e, "EXT_shader_texture_lod"),
          EXT_sRGB: Tt(e, "EXT_sRGB"),
          OES_vertex_array_object: Tt(e, "OES_vertex_array_object"),
          EXT_color_buffer_half_float: Tt(e, "EXT_color_buffer_half_float"),
          WEBGL_color_buffer_float: Tt(e, "WEBGL_color_buffer_float"),
          WEBGL_compressed_texture_etc1: Tt(e, "WEBGL_compressed_texture_etc1"),
          WEBGL_compressed_texture_etc: Tt(e, "WEBGL_compressed_texture_etc"),
          WEBGL_compressed_texture_pvrtc: Tt(e, "WEBGL_compressed_texture_pvrtc"),
          WEBGL_compressed_texture_s3tc: Tt(e, "WEBGL_compressed_texture_s3tc"),
          WEBGL_compressed_texture_s3tc_srgb: Tt(e, "WEBGL_compressed_texture_s3tc_srgb"),
          WEBGL_debug_shaders: Tt(e, "WEBGL_debug_shaders"),
          WEBGL_draw_buffers: Tt(e, "WEBGL_draw_buffers"),
          WEBGL_lose_context: Tt(e, "WEBGL_lose_context"),
          WEBGL_depth_texture: Tt(e, "WEBGL_depth_texture"),
          OES_texture_half_float: Tt(e, "OES_texture_half_float"),
          OES_texture_half_float_linear: Tt(e, "OES_texture_half_float_linear"),
          OES_texture_float: Tt(e, "OES_texture_float"),
          OES_texture_float_linear: Tt(e, "OES_texture_float_linear"),
          OES_standard_derivatives: Tt(e, "OES_standard_derivatives"),
          OES_element_index_uint: Tt(e, "OES_element_index_uint"),
          ANGLE_instanced_arrays: Tt(e, "ANGLE_instanced_arrays"),
          WEBGL_debug_renderer_info: Tt(e, "WEBGL_debug_renderer_info"),
          WEBGL_multi_draw: null,
          WEBGL_compressed_texture_astc: null,
          destroyShadersImmediately: !0,
          noCompressedTexSubImage2D: !1,
          isLocationActive: function isLocationActive(e) {
            return !!e;
          },
          useVAO: !1
        };
        return te.os === re.IOS && 14 === te.osMainVersion && te.isBrowser || (t.WEBGL_compressed_texture_astc = Tt(e, "WEBGL_compressed_texture_astc")), te.os !== re.ANDROID && te.os !== re.IOS && (t.WEBGL_multi_draw = Tt(e, "WEBGL_multi_draw")), te.browserType === se.UC && (t.ANGLE_instanced_arrays = null), (te.os === re.IOS && te.osMainVersion <= 10 || te.os === re.ANDROID) && (t.destroyShadersImmediately = !1), t.isLocationActive = function (e) {
          return !!e && -1 !== e.id;
        }, t.noCompressedTexSubImage2D = !0, t.OES_vertex_array_object && (t.useVAO = !0), t;
      }

      var gt = function (e) {
        function r() {
          for (var t, r = arguments.length, s = new Array(r), a = 0; a < r; a++) {
            s[a] = arguments[a];
          }

          return (t = e.call.apply(e, [this].concat(s)) || this).stateCache = new ft(), t.cmdAllocator = new $e(), t.nullTex2D = null, t.nullTexCube = null, t._canvas = null, t._webGLContextLostHandler = null, t._extensions = null, t;
        }

        t(r, e);
        var s = r.prototype;
        return s.initialize = function (e) {
          this._canvas = e.windowHandle, this._webGLContextLostHandler = this._onWebGLContextLost.bind(this), this._canvas.addEventListener(ht, this._onWebGLContextLost);
          var t = pe.instance.gl;
          this.stateCache.initialize(pe.instance.capabilities.maxTextureUnits, pe.instance.capabilities.maxVertexAttributes), this._extensions = Rt(t), function (e) {
            e.activeTexture(e.TEXTURE0), e.pixelStorei(e.PACK_ALIGNMENT, 1), e.pixelStorei(e.UNPACK_ALIGNMENT, 1), e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, !1), e.bindFramebuffer(e.FRAMEBUFFER, null), e.enable(e.SCISSOR_TEST), e.enable(e.CULL_FACE), e.cullFace(e.BACK), e.frontFace(e.CCW), e.disable(e.POLYGON_OFFSET_FILL), e.polygonOffset(0, 0), e.enable(e.DEPTH_TEST), e.depthMask(!0), e.depthFunc(e.LESS), e.depthRange(0, 1), e.stencilFuncSeparate(e.FRONT, e.ALWAYS, 1, 65535), e.stencilOpSeparate(e.FRONT, e.KEEP, e.KEEP, e.KEEP), e.stencilMaskSeparate(e.FRONT, 65535), e.stencilFuncSeparate(e.BACK, e.ALWAYS, 1, 65535), e.stencilOpSeparate(e.BACK, e.KEEP, e.KEEP, e.KEEP), e.stencilMaskSeparate(e.BACK, 65535), e.disable(e.STENCIL_TEST), e.disable(e.SAMPLE_ALPHA_TO_COVERAGE), e.disable(e.BLEND), e.blendEquationSeparate(e.FUNC_ADD, e.FUNC_ADD), e.blendFuncSeparate(e.ONE, e.ZERO, e.ONE, e.ZERO), e.colorMask(!0, !0, !0, !0), e.blendColor(0, 0, 0, 0);
          }(t);
          var r = A.RGBA8,
              s = A.DEPTH_STENCIL,
              a = t.getParameter(t.DEPTH_BITS),
              n = t.getParameter(t.STENCIL_BITS);
          a && n ? s = A.DEPTH_STENCIL : a && (s = A.DEPTH), this._colorTexture = new Et(), this._colorTexture.initAsSwapchainTexture({
            swapchain: this,
            format: r,
            width: e.width,
            height: e.height
          }), this._depthStencilTexture = new Et(), this._depthStencilTexture.initAsSwapchainTexture({
            swapchain: this,
            format: s,
            width: e.width,
            height: e.height
          }), this.nullTex2D = pe.instance.createTexture(new Z(f.TEX2D, Q.SAMPLED, A.RGBA8, 2, 2, x.GEN_MIPMAP)), this.nullTexCube = pe.instance.createTexture(new Z(f.CUBE, Q.SAMPLED, A.RGBA8, 2, 2, x.GEN_MIPMAP, 6));
          var i = new ie();
          i.texExtent.width = 2, i.texExtent.height = 2;
          var u = new Uint8Array(this.nullTex2D.size);
          u.fill(0), pe.instance.copyBuffersToTexture([u], this.nullTex2D, [i]), i.texSubres.layerCount = 6, pe.instance.copyBuffersToTexture([u, u, u, u, u, u], this.nullTexCube, [i]);
        }, s.destroy = function () {
          this._canvas && this._webGLContextLostHandler && (this._canvas.removeEventListener(ht, this._webGLContextLostHandler), this._webGLContextLostHandler = null), this.nullTex2D && (this.nullTex2D.destroy(), this.nullTex2D = null), this.nullTexCube && (this.nullTexCube.destroy(), this.nullTexCube = null), this._extensions = null, this._canvas = null;
        }, s.resize = function (e, t) {
          this._colorTexture.width === e && this._colorTexture.height === t || (R("Resizing swapchain: " + e + "x" + t), this._canvas.width = e, this._canvas.height = t, this._colorTexture.resize(e, t), this._depthStencilTexture.resize(e, t));
        }, s._onWebGLContextLost = function (e) {
          J(11e3), ee(e);
        }, a(r, [{
          key: "extensions",
          get: function get() {
            return this._extensions;
          }
        }]), r;
      }(ue),
          dt = e("WebGLDevice", function (e) {
        function r() {
          for (var t, r = arguments.length, s = new Array(r), a = 0; a < r; a++) {
            s[a] = arguments[a];
          }

          return (t = e.call.apply(e, [this].concat(s)) || this)._swapchain = null, t._context = null, t._bindingMappings = null, t._textureExclusive = new Array(A.COUNT), t;
        }

        t(r, e);
        var s = r.prototype;
        return s.initialize = function (e) {
          pe.setInstance(this), this._gfxAPI = le.WEBGL;
          var t = this._bindingMappingInfo = e.bindingMappingInfo,
              r = [],
              s = [],
              a = t.setIndices[0];
          r[a] = 0, s[a] = 0;

          for (var n = 1; n < t.setIndices.length; ++n) {
            var i = t.setIndices[n],
                u = t.setIndices[n - 1];
            r[i] = t.maxBlockCounts[u] + r[u], s[i] = t.maxSamplerTextureCounts[u] + s[u];
          }

          for (var l = 0; l < t.setIndices.length; ++l) {
            var _ = t.setIndices[l];
            s[_] -= t.maxBlockCounts[_];
          }

          this._bindingMappings = {
            blockOffsets: r,
            samplerTextureOffsets: s,
            flexibleSet: t.setIndices[t.setIndices.length - 1]
          };

          var o = this._context = function (e) {
            var t = null;

            try {
              var r = {
                alpha: ae.ENABLE_TRANSPARENT_CANVAS,
                antialias: ne || ae.ENABLE_WEBGL_ANTIALIAS,
                depth: !0,
                stencil: !0,
                premultipliedAlpha: !1,
                preserveDrawingBuffer: !1,
                powerPreference: "default",
                failIfMajorPerformanceCaveat: !1
              };
              t = e.getContext("webgl", r);
            } catch (e) {
              return null;
            }

            return t;
          }(ge.canvas);

          if (!o) return console.error("This device does not support WebGL."), !1;
          this._queue = this.createQueue(new _e(oe.GRAPHICS)), this._cmdBuff = this.createCommandBuffer(new ce(this._queue)), this._caps.maxVertexAttributes = o.getParameter(o.MAX_VERTEX_ATTRIBS), this._caps.maxVertexUniformVectors = o.getParameter(o.MAX_VERTEX_UNIFORM_VECTORS), this._caps.maxFragmentUniformVectors = o.getParameter(o.MAX_FRAGMENT_UNIFORM_VECTORS), this._caps.maxTextureUnits = o.getParameter(o.MAX_TEXTURE_IMAGE_UNITS), this._caps.maxVertexTextureUnits = o.getParameter(o.MAX_VERTEX_TEXTURE_IMAGE_UNITS), this._caps.maxTextureSize = o.getParameter(o.MAX_TEXTURE_SIZE), this._caps.maxCubeMapTextureSize = o.getParameter(o.MAX_CUBE_MAP_TEXTURE_SIZE), this._caps.maxUniformBufferBindings = 16;
          var c = o.getSupportedExtensions(),
              f = "";
          if (c) for (var E, h = fe(c); !(E = h()).done;) {
            f += E.value + " ";
          }
          var T = Rt(o);
          T.WEBGL_debug_renderer_info ? (this._renderer = o.getParameter(T.WEBGL_debug_renderer_info.UNMASKED_RENDERER_WEBGL), this._vendor = o.getParameter(T.WEBGL_debug_renderer_info.UNMASKED_VENDOR_WEBGL)) : (this._renderer = o.getParameter(o.RENDERER), this._vendor = o.getParameter(o.VENDOR));
          var g = o.getParameter(o.VERSION);
          this._features.fill(!1), this.initFormatFeatures(T), T.EXT_blend_minmax && (this._features[Ee.BLEND_MINMAX] = !0), T.OES_element_index_uint && (this._features[Ee.ELEMENT_INDEX_UINT] = !0), T.ANGLE_instanced_arrays && (this._features[Ee.INSTANCED_ARRAYS] = !0), T.WEBGL_draw_buffers && (this._features[Ee.MULTIPLE_RENDER_TARGETS] = !0);
          var d = "";
          return this.getFormatFeatures(A.ETC_RGB8) && (d += "etc1 "), this.getFormatFeatures(A.ETC2_RGB8) && (d += "etc2 "), this.getFormatFeatures(A.BC1) && (d += "dxt "), this.getFormatFeatures(A.PVRTC_RGB2) && (d += "pvrtc "), this.getFormatFeatures(A.ASTC_RGBA_4X4) && (d += "astc "), R("WebGL device initialized."), R("RENDERER: " + this._renderer), R("VENDOR: " + this._vendor), R("VERSION: " + g), R("COMPRESSED_FORMAT: " + d), R("EXTENSIONS: " + f), !0;
        }, s.destroy = function () {
          this._queue && (this._queue.destroy(), this._queue = null), this._cmdBuff && (this._cmdBuff.destroy(), this._cmdBuff = null);
        }, s.flushCommands = function () {}, s.acquire = function () {}, s.present = function () {
          var e = this._queue;
          this._numDrawCalls = e.numDrawCalls, this._numInstances = e.numInstances, this._numTris = e.numTris, e.clear();
        }, s.initFormatFeatures = function (e) {
          this._formatFeatures.fill(he.NONE), this._textureExclusive.fill(!0);
          var t = he.RENDER_TARGET | he.SAMPLED_TEXTURE | he.LINEAR_FILTER;
          this._formatFeatures[A.RGB8] = t, this._formatFeatures[A.R5G6B5] = t, this._textureExclusive[A.R5G6B5] = !1, this._formatFeatures[A.RGBA8] = t, this._formatFeatures[A.RGBA4] = t, this._textureExclusive[A.RGBA4] = !1, this._formatFeatures[A.RGB5A1] = t, this._textureExclusive[A.RGB5A1] = !1, this._formatFeatures[A.DEPTH] = he.RENDER_TARGET, this._textureExclusive[A.DEPTH] = !1, this._formatFeatures[A.DEPTH_STENCIL] = he.RENDER_TARGET, this._textureExclusive[A.DEPTH_STENCIL] = !1, this._formatFeatures[A.R8I] |= he.VERTEX_ATTRIBUTE, this._formatFeatures[A.RG8I] |= he.VERTEX_ATTRIBUTE, this._formatFeatures[A.RGB8I] |= he.VERTEX_ATTRIBUTE, this._formatFeatures[A.RGBA8I] |= he.VERTEX_ATTRIBUTE, this._formatFeatures[A.R8UI] |= he.VERTEX_ATTRIBUTE, this._formatFeatures[A.RG8UI] |= he.VERTEX_ATTRIBUTE, this._formatFeatures[A.RGB8UI] |= he.VERTEX_ATTRIBUTE, this._formatFeatures[A.RGBA8UI] |= he.VERTEX_ATTRIBUTE, this._formatFeatures[A.R8I] |= he.VERTEX_ATTRIBUTE, this._formatFeatures[A.RG8I] |= he.VERTEX_ATTRIBUTE, this._formatFeatures[A.RGB8I] |= he.VERTEX_ATTRIBUTE, this._formatFeatures[A.RGBA8I] |= he.VERTEX_ATTRIBUTE, this._formatFeatures[A.R8UI] |= he.VERTEX_ATTRIBUTE, this._formatFeatures[A.RG8UI] |= he.VERTEX_ATTRIBUTE, this._formatFeatures[A.RGB8UI] |= he.VERTEX_ATTRIBUTE, this._formatFeatures[A.RGBA8UI] |= he.VERTEX_ATTRIBUTE, this._formatFeatures[A.R32F] |= he.VERTEX_ATTRIBUTE, this._formatFeatures[A.RG32F] |= he.VERTEX_ATTRIBUTE, this._formatFeatures[A.RGB32F] |= he.VERTEX_ATTRIBUTE, this._formatFeatures[A.RGBA32F] |= he.VERTEX_ATTRIBUTE, e.EXT_sRGB && (this._formatFeatures[A.SRGB8] = t, this._formatFeatures[A.SRGB8_A8] = t, this._textureExclusive[A.SRGB8_A8] = !1), e.WEBGL_depth_texture && (this._formatFeatures[A.DEPTH] |= t, this._formatFeatures[A.DEPTH_STENCIL] |= t), e.WEBGL_color_buffer_float && (this._formatFeatures[A.RGB32F] |= he.RENDER_TARGET, this._formatFeatures[A.RGBA32F] |= he.RENDER_TARGET, this._textureExclusive[A.RGB32F] = !1, this._textureExclusive[A.RGBA32F] = !1), e.EXT_color_buffer_half_float && (this._formatFeatures[A.RGB16F] |= he.RENDER_TARGET, this._formatFeatures[A.RGBA16F] |= he.RENDER_TARGET, this._textureExclusive[A.RGB16F] = !1, this._textureExclusive[A.RGBA16F] = !1), e.OES_texture_float && (this._formatFeatures[A.RGB32F] |= he.RENDER_TARGET | he.SAMPLED_TEXTURE, this._formatFeatures[A.RGBA32F] |= he.RENDER_TARGET | he.SAMPLED_TEXTURE), e.OES_texture_half_float && (this._formatFeatures[A.RGB16F] |= he.RENDER_TARGET | he.SAMPLED_TEXTURE, this._formatFeatures[A.RGBA16F] |= he.RENDER_TARGET | he.SAMPLED_TEXTURE), e.OES_texture_float_linear && (this._formatFeatures[A.RGB32F] |= he.LINEAR_FILTER, this._formatFeatures[A.RGBA32F] |= he.LINEAR_FILTER), e.OES_texture_half_float_linear && (this._formatFeatures[A.RGB16F] |= he.LINEAR_FILTER, this._formatFeatures[A.RGBA16F] |= he.LINEAR_FILTER);
          var r = he.SAMPLED_TEXTURE | he.LINEAR_FILTER;
          e.WEBGL_compressed_texture_etc1 && (this._formatFeatures[A.ETC_RGB8] = r), e.WEBGL_compressed_texture_etc && (this._formatFeatures[A.ETC2_RGB8] = r, this._formatFeatures[A.ETC2_RGBA8] = r, this._formatFeatures[A.ETC2_SRGB8] = r, this._formatFeatures[A.ETC2_SRGB8_A8] = r, this._formatFeatures[A.ETC2_RGB8_A1] = r, this._formatFeatures[A.ETC2_SRGB8_A1] = r), e.WEBGL_compressed_texture_s3tc && (this._formatFeatures[A.BC1] = r, this._formatFeatures[A.BC1_ALPHA] = r, this._formatFeatures[A.BC1_SRGB] = r, this._formatFeatures[A.BC1_SRGB_ALPHA] = r, this._formatFeatures[A.BC2] = r, this._formatFeatures[A.BC2_SRGB] = r, this._formatFeatures[A.BC3] = r, this._formatFeatures[A.BC3_SRGB] = r), e.WEBGL_compressed_texture_pvrtc && (this._formatFeatures[A.PVRTC_RGB2] |= r, this._formatFeatures[A.PVRTC_RGBA2] |= r, this._formatFeatures[A.PVRTC_RGB4] |= r, this._formatFeatures[A.PVRTC_RGBA4] |= r), e.WEBGL_compressed_texture_astc && (this._formatFeatures[A.ASTC_RGBA_4X4] |= r, this._formatFeatures[A.ASTC_RGBA_5X4] |= r, this._formatFeatures[A.ASTC_RGBA_5X5] |= r, this._formatFeatures[A.ASTC_RGBA_6X5] |= r, this._formatFeatures[A.ASTC_RGBA_6X6] |= r, this._formatFeatures[A.ASTC_RGBA_8X5] |= r, this._formatFeatures[A.ASTC_RGBA_8X6] |= r, this._formatFeatures[A.ASTC_RGBA_8X8] |= r, this._formatFeatures[A.ASTC_RGBA_10X5] |= r, this._formatFeatures[A.ASTC_RGBA_10X6] |= r, this._formatFeatures[A.ASTC_RGBA_10X8] |= r, this._formatFeatures[A.ASTC_RGBA_10X10] |= r, this._formatFeatures[A.ASTC_RGBA_12X10] |= r, this._formatFeatures[A.ASTC_RGBA_12X12] |= r, this._formatFeatures[A.ASTC_SRGBA_4X4] |= r, this._formatFeatures[A.ASTC_SRGBA_5X4] |= r, this._formatFeatures[A.ASTC_SRGBA_5X5] |= r, this._formatFeatures[A.ASTC_SRGBA_6X5] |= r, this._formatFeatures[A.ASTC_SRGBA_6X6] |= r, this._formatFeatures[A.ASTC_SRGBA_8X5] |= r, this._formatFeatures[A.ASTC_SRGBA_8X6] |= r, this._formatFeatures[A.ASTC_SRGBA_8X8] |= r, this._formatFeatures[A.ASTC_SRGBA_10X5] |= r, this._formatFeatures[A.ASTC_SRGBA_10X6] |= r, this._formatFeatures[A.ASTC_SRGBA_10X8] |= r, this._formatFeatures[A.ASTC_SRGBA_10X10] |= r, this._formatFeatures[A.ASTC_SRGBA_12X10] |= r, this._formatFeatures[A.ASTC_SRGBA_12X12] |= r);
        }, s.createCommandBuffer = function (e) {
          var t = new (e.type === O.PRIMARY ? it : Je)();
          return t.initialize(e), t;
        }, s.createSwapchain = function (e) {
          var t = new gt();
          return this._swapchain = t, t.initialize(e), t;
        }, s.createBuffer = function (e) {
          var t = new Ze();
          return t.initialize(e), t;
        }, s.createTexture = function (e) {
          var t = new Et();
          return t.initialize(e), t;
        }, s.createDescriptorSet = function (e) {
          var t = new Se();
          return t.initialize(e), t;
        }, s.createShader = function (e) {
          var t = new ct();
          return t.initialize(e), t;
        }, s.createInputAssembler = function (e) {
          var t = new tt();
          return t.initialize(e), t;
        }, s.createRenderPass = function (e) {
          var t = new lt();
          return t.initialize(e), t;
        }, s.createFramebuffer = function (e) {
          var t = new et();
          return t.initialize(e), t;
        }, s.createDescriptorSetLayout = function (e) {
          var t = new rt();
          return t.initialize(e), t;
        }, s.createPipelineLayout = function (e) {
          var t = new st();
          return t.initialize(e), t;
        }, s.createPipelineState = function (e) {
          var t = new nt();
          return t.initialize(e), t;
        }, s.createQueue = function (e) {
          var t = new ut();
          return t.initialize(e), t;
        }, s.getSampler = function (e) {
          var t = H.computeHash(e);
          return this._samplers.has(t) || this._samplers.set(t, new ot(e, t)), this._samplers.get(t);
        }, s.getGeneralBarrier = function (e) {
          var t = Te.computeHash(e);
          return this._generalBarrierss.has(t) || this._generalBarrierss.set(t, new Te(e, t)), this._generalBarrierss.get(t);
        }, s.getTextureBarrier = function (e) {
          var t = Re.computeHash(e);
          return this._textureBarriers.has(t) || this._textureBarriers.set(t, new Re(e, t)), this._textureBarriers.get(t);
        }, s.copyBuffersToTexture = function (e, t, r) {
          qe(this, e, t.gpuTexture, r);
        }, s.copyTextureToBuffers = function (e, t, r) {
          !function (e, t, r, s) {
            var a = e.gl,
                n = e.stateCache,
                i = a.createFramebuffer();
            a.bindFramebuffer(a.FRAMEBUFFER, i);
            var u = 0,
                l = 0,
                _ = 1,
                o = 1;

            switch (t.glTarget) {
              case a.TEXTURE_2D:
                for (var c = 0; c < s.length; c++) {
                  var f = s[c];
                  a.framebufferTexture2D(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0, t.glTarget, t.glTexture, f.texSubres.mipLevel), u = f.texOffset.x, l = f.texOffset.y, _ = f.texExtent.width, o = f.texExtent.height, a.readPixels(u, l, _, o, t.glFormat, t.glType, r[c]);
                }

                break;

              default:
                console.error("Unsupported GL texture type, copy texture to buffers failed.");
            }

            a.bindFramebuffer(a.FRAMEBUFFER, null), n.glFramebuffer = null, a.deleteFramebuffer(i);
          }(this, e.gpuTexture, t, r);
        }, s.copyTexImagesToTexture = function (e, t, r) {
          !function (e, t, r, s) {
            var a = e.gl,
                n = e.stateCache.glTexUnits[e.stateCache.texUnit];
            n.glTexture !== r.glTexture && (a.bindTexture(r.glTarget, r.glTexture), n.glTexture = r.glTexture);
            var i = 0,
                u = 0;

            switch (r.glTarget) {
              case a.TEXTURE_2D:
                for (var l = 0; l < s.length; l++) {
                  var _ = s[l];
                  a.texSubImage2D(a.TEXTURE_2D, _.texSubres.mipLevel, _.texOffset.x, _.texOffset.y, r.glFormat, r.glType, t[i++]);
                }

                break;

              case a.TEXTURE_CUBE_MAP:
                for (var o = 0; o < s.length; o++) {
                  var c = s[o],
                      f = c.texSubres.baseArrayLayer + c.texSubres.layerCount;

                  for (u = c.texSubres.baseArrayLayer; u < f; ++u) {
                    a.texSubImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X + u, c.texSubres.mipLevel, c.texOffset.x, c.texOffset.y, r.glFormat, r.glType, t[i++]);
                  }
                }

                break;

              default:
                console.error("Unsupported GL texture type, copy buffer to texture failed.");
            }

            r.flags & x.GEN_MIPMAP && r.isPowerOf2 && a.generateMipmap(r.glTarget);
          }(this, e, t.gpuTexture, r);
        }, a(r, [{
          key: "gl",
          get: function get() {
            return this._context;
          }
        }, {
          key: "extensions",
          get: function get() {
            return this._swapchain.extensions;
          }
        }, {
          key: "stateCache",
          get: function get() {
            return this._swapchain.stateCache;
          }
        }, {
          key: "nullTex2D",
          get: function get() {
            return this._swapchain.nullTex2D;
          }
        }, {
          key: "nullTexCube",
          get: function get() {
            return this._swapchain.nullTexCube;
          }
        }, {
          key: "textureExclusive",
          get: function get() {
            return this._textureExclusive;
          }
        }, {
          key: "bindingMappings",
          get: function get() {
            return this._bindingMappings;
          }
        }]), r;
      }(ge));

      de.WebGLDevice = dt;
    }
  };
}); 
 			}); 
		define("__plugin__/wx0446ba2621dda60a/gfx-webgl2.js", function(require, module, exports){ 			
"use strict";

var _typeof2 = require("@babel/runtime/helpers/typeof");

System.register(["./texture-barrier-60b5983b.js"], function (e) {
  "use strict";

  var t, r, s, a, n, i, u, _, l, c, o, f, R, A, E, h, S, T, g, d, B, C, p, m, G, x, P, F, b, I, O, M, D, v, L, U, N, y, w, H, X, k, V, K, W, z, Y, q, Z, j, Q, $, J, ee, te, re, se, ae, ne, ie, ue, _e, le, ce, oe, fe, Re, Ae, Ee, he, Se;

  return {
    setters: [function (e) {
      t = e.bT, r = e.b0, s = e.b1, a = e.bU, n = e.D, i = e.a9, u = e.aY, _ = e.an, l = e.q, c = e.o, o = e.r, f = e.f, R = e.a$, A = e.b5, E = e.v, h = e.bL, S = e.e, T = e.av, g = e.T, d = e.m, B = e.L, C = e.I, p = e.Z, m = e.$, G = e.t, x = e.x, P = e.J, F = e.C, b = e.cH, I = e.B, O = e.a0, M = e.a4, D = e.j, v = e.bb, L = e.bc, U = e.b2, N = e.bd, y = e.be, w = e.bk, H = e.bl, X = e.bm, k = e.bn, V = e.bo, K = e.ag, W = e.bf, z = e.bg, Y = e.bi, q = e.b4, Z = e.b6, j = e.aq, Q = e.s, $ = e.bp, J = e.d, ee = e.w, te = e.bR, re = e.bS, se = e.bQ, ae = e.cw, ne = e.af, ie = e.ba, ue = e.A, _e = e.aT, le = e.a2, ce = e.aS, oe = e.i, fe = e.F, Re = e.u, Ae = e.bq, Ee = e.br, he = e.b9, Se = e.l;
    }],
    execute: function execute() {
      var Te,
          ge = function (e) {
        function n() {
          for (var t, r = arguments.length, s = new Array(r), a = 0; a < r; a++) {
            s[a] = arguments[a];
          }

          return (t = e.call.apply(e, [this].concat(s)) || this)._gpuDescriptorSet = null, t;
        }

        t(n, e);
        var i = n.prototype;
        return i.initialize = function (e) {
          this._layout = e.layout;
          var t = e.layout.gpuDescriptorSetLayout,
              r = t.bindings,
              s = t.descriptorIndices,
              a = t.descriptorCount;
          this._buffers = Array(a).fill(null), this._textures = Array(a).fill(null), this._samplers = Array(a).fill(null);
          var n = [];
          this._gpuDescriptorSet = {
            gpuDescriptors: n,
            descriptorIndices: s
          };

          for (var i = 0; i < r.length; ++i) {
            for (var u = r[i], _ = 0; _ < u.count; _++) {
              n.push({
                type: u.descriptorType,
                gpuBuffer: null,
                gpuTextureView: null,
                gpuSampler: null
              });
            }
          }
        }, i.destroy = function () {
          this._layout = null, this._gpuDescriptorSet = null;
        }, i.update = function () {
          if (this._isDirty && this._gpuDescriptorSet) {
            for (var e = this._gpuDescriptorSet.gpuDescriptors, t = 0; t < e.length; ++t) {
              e[t].type & r ? this._buffers[t] && (e[t].gpuBuffer = this._buffers[t].gpuBuffer) : e[t].type & s && (this._textures[t] && (e[t].gpuTextureView = this._textures[t].gpuTextureView), this._samplers[t] && (e[t].gpuSampler = this._samplers[t].gpuSampler));
            }

            this._isDirty = !1;
          }
        }, a(n, [{
          key: "gpuDescriptorSet",
          get: function get() {
            return this._gpuDescriptorSet;
          }
        }]), n;
      }(n);

      !function (e) {
        e[e.COMPRESSED_RGB_S3TC_DXT1_EXT = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT", e[e.COMPRESSED_RGBA_S3TC_DXT1_EXT = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT", e[e.COMPRESSED_RGBA_S3TC_DXT3_EXT = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT", e[e.COMPRESSED_RGBA_S3TC_DXT5_EXT = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT", e[e.COMPRESSED_SRGB_S3TC_DXT1_EXT = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT", e[e.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT", e[e.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT", e[e.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT", e[e.COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG", e[e.COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG", e[e.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG", e[e.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG", e[e.COMPRESSED_RGB_ETC1_WEBGL = 36196] = "COMPRESSED_RGB_ETC1_WEBGL", e[e.COMPRESSED_R11_EAC = 37488] = "COMPRESSED_R11_EAC", e[e.COMPRESSED_SIGNED_R11_EAC = 37489] = "COMPRESSED_SIGNED_R11_EAC", e[e.COMPRESSED_RG11_EAC = 37490] = "COMPRESSED_RG11_EAC", e[e.COMPRESSED_SIGNED_RG11_EAC = 37491] = "COMPRESSED_SIGNED_RG11_EAC", e[e.COMPRESSED_RGB8_ETC2 = 37492] = "COMPRESSED_RGB8_ETC2", e[e.COMPRESSED_SRGB8_ETC2 = 37493] = "COMPRESSED_SRGB8_ETC2", e[e.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37494] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2", e[e.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37495] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2", e[e.COMPRESSED_RGBA8_ETC2_EAC = 37496] = "COMPRESSED_RGBA8_ETC2_EAC", e[e.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 37497] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC", e[e.COMPRESSED_RGBA_ASTC_4x4_KHR = 37808] = "COMPRESSED_RGBA_ASTC_4x4_KHR", e[e.COMPRESSED_RGBA_ASTC_5x4_KHR = 37809] = "COMPRESSED_RGBA_ASTC_5x4_KHR", e[e.COMPRESSED_RGBA_ASTC_5x5_KHR = 37810] = "COMPRESSED_RGBA_ASTC_5x5_KHR", e[e.COMPRESSED_RGBA_ASTC_6x5_KHR = 37811] = "COMPRESSED_RGBA_ASTC_6x5_KHR", e[e.COMPRESSED_RGBA_ASTC_6x6_KHR = 37812] = "COMPRESSED_RGBA_ASTC_6x6_KHR", e[e.COMPRESSED_RGBA_ASTC_8x5_KHR = 37813] = "COMPRESSED_RGBA_ASTC_8x5_KHR", e[e.COMPRESSED_RGBA_ASTC_8x6_KHR = 37814] = "COMPRESSED_RGBA_ASTC_8x6_KHR", e[e.COMPRESSED_RGBA_ASTC_8x8_KHR = 37815] = "COMPRESSED_RGBA_ASTC_8x8_KHR", e[e.COMPRESSED_RGBA_ASTC_10x5_KHR = 37816] = "COMPRESSED_RGBA_ASTC_10x5_KHR", e[e.COMPRESSED_RGBA_ASTC_10x6_KHR = 37817] = "COMPRESSED_RGBA_ASTC_10x6_KHR", e[e.COMPRESSED_RGBA_ASTC_10x8_KHR = 37818] = "COMPRESSED_RGBA_ASTC_10x8_KHR", e[e.COMPRESSED_RGBA_ASTC_10x10_KHR = 37819] = "COMPRESSED_RGBA_ASTC_10x10_KHR", e[e.COMPRESSED_RGBA_ASTC_12x10_KHR = 37820] = "COMPRESSED_RGBA_ASTC_12x10_KHR", e[e.COMPRESSED_RGBA_ASTC_12x12_KHR = 37821] = "COMPRESSED_RGBA_ASTC_12x12_KHR", e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR = 37840] = "COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR", e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR = 37841] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR", e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR = 37842] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR", e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR = 37843] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR", e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR = 37844] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR", e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR = 37845] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR", e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR = 37846] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR", e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR = 37847] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR", e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR = 37848] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR", e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR = 37849] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR", e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR = 37850] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR", e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR = 37851] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR", e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR = 37852] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR", e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR = 37853] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR";
      }(Te || (Te = {}));

      var de = function () {
        function e() {}

        return e.setInstance = function (t) {
          e._instance = t;
        }, a(e, null, [{
          key: "instance",
          get: function get() {
            return e._instance;
          }
        }]), e;
      }();

      de._instance = null;
      var Be = [10497, 33648, 33071, 33071],
          Ce = new Float32Array(4);

      function pe(e, t) {
        switch (e) {
          case d.R8:
            return t.UNSIGNED_BYTE;

          case d.R8SN:
            return t.BYTE;

          case d.R8UI:
            return t.UNSIGNED_BYTE;

          case d.R8I:
            return t.BYTE;

          case d.R16F:
            return t.HALF_FLOAT;

          case d.R16UI:
            return t.UNSIGNED_SHORT;

          case d.R16I:
            return t.SHORT;

          case d.R32F:
            return t.FLOAT;

          case d.R32UI:
            return t.UNSIGNED_INT;

          case d.R32I:
            return t.INT;

          case d.RG8:
            return t.UNSIGNED_BYTE;

          case d.RG8SN:
            return t.BYTE;

          case d.RG8UI:
            return t.UNSIGNED_BYTE;

          case d.RG8I:
            return t.BYTE;

          case d.RG16F:
            return t.HALF_FLOAT;

          case d.RG16UI:
            return t.UNSIGNED_SHORT;

          case d.RG16I:
            return t.SHORT;

          case d.RG32F:
            return t.FLOAT;

          case d.RG32UI:
            return t.UNSIGNED_INT;

          case d.RG32I:
            return t.INT;

          case d.RGB8:
          case d.SRGB8:
            return t.UNSIGNED_BYTE;

          case d.RGB8SN:
            return t.BYTE;

          case d.RGB8UI:
            return t.UNSIGNED_BYTE;

          case d.RGB8I:
            return t.BYTE;

          case d.RGB16F:
            return t.HALF_FLOAT;

          case d.RGB16UI:
            return t.UNSIGNED_SHORT;

          case d.RGB16I:
            return t.SHORT;

          case d.RGB32F:
            return t.FLOAT;

          case d.RGB32UI:
            return t.UNSIGNED_INT;

          case d.RGB32I:
            return t.INT;

          case d.BGRA8:
          case d.RGBA8:
          case d.SRGB8_A8:
            return t.UNSIGNED_BYTE;

          case d.RGBA8SN:
            return t.BYTE;

          case d.RGBA8UI:
            return t.UNSIGNED_BYTE;

          case d.RGBA8I:
            return t.BYTE;

          case d.RGBA16F:
            return t.HALF_FLOAT;

          case d.RGBA16UI:
            return t.UNSIGNED_SHORT;

          case d.RGBA16I:
            return t.SHORT;

          case d.RGBA32F:
            return t.FLOAT;

          case d.RGBA32UI:
            return t.UNSIGNED_INT;

          case d.RGBA32I:
            return t.INT;

          case d.R5G6B5:
            return t.UNSIGNED_SHORT_5_6_5;

          case d.R11G11B10F:
            return t.UNSIGNED_INT_10F_11F_11F_REV;

          case d.RGB5A1:
            return t.UNSIGNED_SHORT_5_5_5_1;

          case d.RGBA4:
            return t.UNSIGNED_SHORT_4_4_4_4;

          case d.RGB10A2:
          case d.RGB10A2UI:
            return t.UNSIGNED_INT_2_10_10_10_REV;

          case d.RGB9E5:
          case d.DEPTH:
            return t.FLOAT;

          case d.DEPTH_STENCIL:
            return t.UNSIGNED_INT_24_8;

          case d.BC1:
          case d.BC1_SRGB:
          case d.BC2:
          case d.BC2_SRGB:
          case d.BC3:
          case d.BC3_SRGB:
          case d.BC4:
            return t.UNSIGNED_BYTE;

          case d.BC4_SNORM:
            return t.BYTE;

          case d.BC5:
            return t.UNSIGNED_BYTE;

          case d.BC5_SNORM:
            return t.BYTE;

          case d.BC6H_SF16:
          case d.BC6H_UF16:
            return t.FLOAT;

          case d.BC7:
          case d.BC7_SRGB:
          case d.ETC_RGB8:
          case d.ETC2_RGB8:
          case d.ETC2_SRGB8:
          case d.ETC2_RGB8_A1:
          case d.ETC2_SRGB8_A1:
          case d.EAC_R11:
            return t.UNSIGNED_BYTE;

          case d.EAC_R11SN:
            return t.BYTE;

          case d.EAC_RG11:
            return t.UNSIGNED_BYTE;

          case d.EAC_RG11SN:
            return t.BYTE;

          case d.PVRTC_RGB2:
          case d.PVRTC_RGBA2:
          case d.PVRTC_RGB4:
          case d.PVRTC_RGBA4:
          case d.PVRTC2_2BPP:
          case d.PVRTC2_4BPP:
            return t.UNSIGNED_BYTE;

          case d.ASTC_RGBA_4X4:
          case d.ASTC_RGBA_5X4:
          case d.ASTC_RGBA_5X5:
          case d.ASTC_RGBA_6X5:
          case d.ASTC_RGBA_6X6:
          case d.ASTC_RGBA_8X5:
          case d.ASTC_RGBA_8X6:
          case d.ASTC_RGBA_8X8:
          case d.ASTC_RGBA_10X5:
          case d.ASTC_RGBA_10X6:
          case d.ASTC_RGBA_10X8:
          case d.ASTC_RGBA_10X10:
          case d.ASTC_RGBA_12X10:
          case d.ASTC_RGBA_12X12:
          case d.ASTC_SRGBA_4X4:
          case d.ASTC_SRGBA_5X4:
          case d.ASTC_SRGBA_5X5:
          case d.ASTC_SRGBA_6X5:
          case d.ASTC_SRGBA_6X6:
          case d.ASTC_SRGBA_8X5:
          case d.ASTC_SRGBA_8X6:
          case d.ASTC_SRGBA_8X8:
          case d.ASTC_SRGBA_10X5:
          case d.ASTC_SRGBA_10X6:
          case d.ASTC_SRGBA_10X8:
          case d.ASTC_SRGBA_10X10:
          case d.ASTC_SRGBA_12X10:
          case d.ASTC_SRGBA_12X12:
          default:
            return t.UNSIGNED_BYTE;
        }
      }

      function me(e, t) {
        switch (e) {
          case g.BOOL:
            return t.BOOL;

          case g.BOOL2:
            return t.BOOL_VEC2;

          case g.BOOL3:
            return t.BOOL_VEC3;

          case g.BOOL4:
            return t.BOOL_VEC4;

          case g.INT:
            return t.INT;

          case g.INT2:
            return t.INT_VEC2;

          case g.INT3:
            return t.INT_VEC3;

          case g.INT4:
            return t.INT_VEC4;

          case g.UINT:
            return t.UNSIGNED_INT;

          case g.FLOAT:
            return t.FLOAT;

          case g.FLOAT2:
            return t.FLOAT_VEC2;

          case g.FLOAT3:
            return t.FLOAT_VEC3;

          case g.FLOAT4:
            return t.FLOAT_VEC4;

          case g.MAT2:
            return t.FLOAT_MAT2;

          case g.MAT2X3:
            return t.FLOAT_MAT2x3;

          case g.MAT2X4:
            return t.FLOAT_MAT2x4;

          case g.MAT3X2:
            return t.FLOAT_MAT3x2;

          case g.MAT3:
            return t.FLOAT_MAT3;

          case g.MAT3X4:
            return t.FLOAT_MAT3x4;

          case g.MAT4X2:
            return t.FLOAT_MAT4x2;

          case g.MAT4X3:
            return t.FLOAT_MAT4x3;

          case g.MAT4:
            return t.FLOAT_MAT4;

          case g.SAMPLER2D:
            return t.SAMPLER_2D;

          case g.SAMPLER2D_ARRAY:
            return t.SAMPLER_2D_ARRAY;

          case g.SAMPLER3D:
            return t.SAMPLER_3D;

          case g.SAMPLER_CUBE:
            return t.SAMPLER_CUBE;

          default:
            return console.error("Unsupported GLType, convert to GL type failed."), g.UNKNOWN;
        }
      }

      function Ge(e, t) {
        switch (e) {
          case t.BOOL:
            return g.BOOL;

          case t.BOOL_VEC2:
            return g.BOOL2;

          case t.BOOL_VEC3:
            return g.BOOL3;

          case t.BOOL_VEC4:
            return g.BOOL4;

          case t.INT:
            return g.INT;

          case t.INT_VEC2:
            return g.INT2;

          case t.INT_VEC3:
            return g.INT3;

          case t.INT_VEC4:
            return g.INT4;

          case t.UNSIGNED_INT:
            return g.UINT;

          case t.UNSIGNED_INT_VEC2:
            return g.UINT2;

          case t.UNSIGNED_INT_VEC3:
            return g.UINT3;

          case t.UNSIGNED_INT_VEC4:
            return g.UINT4;

          case t.FLOAT:
            return g.FLOAT;

          case t.FLOAT_VEC2:
            return g.FLOAT2;

          case t.FLOAT_VEC3:
            return g.FLOAT3;

          case t.FLOAT_VEC4:
            return g.FLOAT4;

          case t.FLOAT_MAT2:
            return g.MAT2;

          case t.FLOAT_MAT2x3:
            return g.MAT2X3;

          case t.FLOAT_MAT2x4:
            return g.MAT2X4;

          case t.FLOAT_MAT3x2:
            return g.MAT3X2;

          case t.FLOAT_MAT3:
            return g.MAT3;

          case t.FLOAT_MAT3x4:
            return g.MAT3X4;

          case t.FLOAT_MAT4x2:
            return g.MAT4X2;

          case t.FLOAT_MAT4x3:
            return g.MAT4X3;

          case t.FLOAT_MAT4:
            return g.MAT4;

          case t.SAMPLER_2D:
            return g.SAMPLER2D;

          case t.SAMPLER_2D_ARRAY:
            return g.SAMPLER2D_ARRAY;

          case t.SAMPLER_3D:
            return g.SAMPLER3D;

          case t.SAMPLER_CUBE:
            return g.SAMPLER_CUBE;

          default:
            return console.error("Unsupported GLType, convert to Type failed."), g.UNKNOWN;
        }
      }

      function xe(e, t) {
        switch (e) {
          case t.BOOL:
            return 4;

          case t.BOOL_VEC2:
            return 8;

          case t.BOOL_VEC3:
            return 12;

          case t.BOOL_VEC4:
            return 16;

          case t.INT:
            return 4;

          case t.INT_VEC2:
            return 8;

          case t.INT_VEC3:
            return 12;

          case t.INT_VEC4:
            return 16;

          case t.UNSIGNED_INT:
            return 4;

          case t.UNSIGNED_INT_VEC2:
            return 8;

          case t.UNSIGNED_INT_VEC3:
            return 12;

          case t.UNSIGNED_INT_VEC4:
            return 16;

          case t.FLOAT:
            return 4;

          case t.FLOAT_VEC2:
            return 8;

          case t.FLOAT_VEC3:
            return 12;

          case t.FLOAT_VEC4:
          case t.FLOAT_MAT2:
            return 16;

          case t.FLOAT_MAT2x3:
            return 24;

          case t.FLOAT_MAT2x4:
            return 32;

          case t.FLOAT_MAT3x2:
            return 24;

          case t.FLOAT_MAT3:
            return 36;

          case t.FLOAT_MAT3x4:
            return 48;

          case t.FLOAT_MAT4x2:
            return 32;

          case t.FLOAT_MAT4x3:
            return 48;

          case t.FLOAT_MAT4:
            return 64;

          case t.SAMPLER_2D:
          case t.SAMPLER_2D_ARRAY:
          case t.SAMPLER_2D_ARRAY_SHADOW:
          case t.SAMPLER_3D:
          case t.SAMPLER_CUBE:
          case t.INT_SAMPLER_2D:
          case t.INT_SAMPLER_2D_ARRAY:
          case t.INT_SAMPLER_3D:
          case t.INT_SAMPLER_CUBE:
          case t.UNSIGNED_INT_SAMPLER_2D:
          case t.UNSIGNED_INT_SAMPLER_2D_ARRAY:
          case t.UNSIGNED_INT_SAMPLER_3D:
          case t.UNSIGNED_INT_SAMPLER_CUBE:
            return 4;

          default:
            return console.error("Unsupported GLType, get type failed."), 0;
        }
      }

      function Pe(e, t) {
        switch (e) {
          case t.FLOAT_MAT2:
          case t.FLOAT_MAT2x3:
          case t.FLOAT_MAT2x4:
            return 2;

          case t.FLOAT_MAT3x2:
          case t.FLOAT_MAT3:
          case t.FLOAT_MAT3x4:
            return 3;

          case t.FLOAT_MAT4x2:
          case t.FLOAT_MAT4x3:
          case t.FLOAT_MAT4:
            return 4;

          default:
            return 1;
        }
      }

      var Fe,
          be = [512, 513, 514, 515, 516, 517, 518, 519],
          Ie = [0, 7680, 7681, 7682, 7683, 5386, 34055, 34056],
          Oe = [32774, 32778, 32779, 32775, 32776],
          Me = [0, 1, 770, 772, 771, 773, 768, 774, 769, 775, 776, 32769, 32770, 32771, 32772];
      !function (e) {
        e[e.BEGIN_RENDER_PASS = 0] = "BEGIN_RENDER_PASS", e[e.END_RENDER_PASS = 1] = "END_RENDER_PASS", e[e.BIND_STATES = 2] = "BIND_STATES", e[e.DRAW = 3] = "DRAW", e[e.UPDATE_BUFFER = 4] = "UPDATE_BUFFER", e[e.COPY_BUFFER_TO_TEXTURE = 5] = "COPY_BUFFER_TO_TEXTURE", e[e.COUNT = 6] = "COUNT";
      }(Fe || (Fe = {}));

      var De = function De(e) {
        this.cmdType = void 0, this.refCount = 0, this.cmdType = e;
      },
          ve = function (e) {
        function r() {
          var t;
          return (t = e.call(this, Fe.BEGIN_RENDER_PASS) || this).gpuRenderPass = null, t.gpuFramebuffer = null, t.renderArea = new i(), t.clearColors = [], t.clearDepth = 1, t.clearStencil = 0, t;
        }

        return t(r, e), r.prototype.clear = function () {
          this.gpuFramebuffer = null, this.clearColors.length = 0;
        }, r;
      }(De),
          Le = function (e) {
        function r() {
          var t;
          return (t = e.call(this, Fe.BIND_STATES) || this).gpuPipelineState = null, t.gpuInputAssembler = null, t.gpuDescriptorSets = [], t.dynamicOffsets = [], t.dynamicStates = new u(), t;
        }

        return t(r, e), r.prototype.clear = function () {
          this.gpuPipelineState = null, this.gpuInputAssembler = null, this.gpuDescriptorSets.length = 0, this.dynamicOffsets.length = 0;
        }, r;
      }(De),
          Ue = function (e) {
        function r() {
          var t;
          return (t = e.call(this, Fe.DRAW) || this).drawInfo = new _(), t;
        }

        return t(r, e), r.prototype.clear = function () {}, r;
      }(De),
          Ne = function (e) {
        function r() {
          var t;
          return (t = e.call(this, Fe.UPDATE_BUFFER) || this).gpuBuffer = null, t.buffer = null, t.offset = 0, t.size = 0, t;
        }

        return t(r, e), r.prototype.clear = function () {
          this.gpuBuffer = null, this.buffer = null;
        }, r;
      }(De),
          ye = function (e) {
        function r() {
          var t;
          return (t = e.call(this, Fe.COPY_BUFFER_TO_TEXTURE) || this).gpuTexture = null, t.buffers = [], t.regions = [], t;
        }

        return t(r, e), r.prototype.clear = function () {
          this.gpuTexture = null, this.buffers.length = 0, this.regions.length = 0;
        }, r;
      }(De),
          we = function () {
        function e() {
          this.cmds = new F(1), this.beginRenderPassCmds = new F(1), this.bindStatesCmds = new F(1), this.drawCmds = new F(1), this.updateBufferCmds = new F(1), this.copyBufferToTextureCmds = new F(1);
        }

        return e.prototype.clearCmds = function (e) {
          this.beginRenderPassCmds.length && (e.beginRenderPassCmdPool.freeCmds(this.beginRenderPassCmds), this.beginRenderPassCmds.clear()), this.bindStatesCmds.length && (e.bindStatesCmdPool.freeCmds(this.bindStatesCmds), this.bindStatesCmds.clear()), this.drawCmds.length && (e.drawCmdPool.freeCmds(this.drawCmds), this.drawCmds.clear()), this.updateBufferCmds.length && (e.updateBufferCmdPool.freeCmds(this.updateBufferCmds), this.updateBufferCmds.clear()), this.copyBufferToTextureCmds.length && (e.copyBufferToTextureCmdPool.freeCmds(this.copyBufferToTextureCmds), this.copyBufferToTextureCmds.clear()), this.cmds.clear();
        }, e;
      }();

      function He(e, t, r, s, a) {
        if (t.usage & c.INDIRECT) {
          t.indirects.clearDraws();

          for (var n = r.drawInfos, i = 0; i < n.length; ++i) {
            t.indirects.setDrawInfo(s + i, n[i]);
          }
        } else {
          var u = r,
              _ = e.gl,
              l = e.stateCache;

          switch (t.glTarget) {
            case _.ARRAY_BUFFER:
              e.extensions.useVAO && l.glVAO && (_.bindVertexArray(null), l.glVAO = null), Ve.gpuInputAssembler = null, l.glArrayBuffer !== t.glBuffer && (_.bindBuffer(_.ARRAY_BUFFER, t.glBuffer), l.glArrayBuffer = t.glBuffer), a === u.byteLength ? _.bufferSubData(t.glTarget, s, u) : _.bufferSubData(t.glTarget, s, u.slice(0, a));
              break;

            case _.ELEMENT_ARRAY_BUFFER:
              e.extensions.useVAO && l.glVAO && (_.bindVertexArray(null), l.glVAO = null), Ve.gpuInputAssembler = null, l.glElementArrayBuffer !== t.glBuffer && (_.bindBuffer(_.ELEMENT_ARRAY_BUFFER, t.glBuffer), l.glElementArrayBuffer = t.glBuffer), a === u.byteLength ? _.bufferSubData(t.glTarget, s, u) : _.bufferSubData(t.glTarget, s, u.slice(0, a));
              break;

            case _.UNIFORM_BUFFER:
              l.glUniformBuffer !== t.glBuffer && (_.bindBuffer(_.UNIFORM_BUFFER, t.glBuffer), l.glUniformBuffer = t.glBuffer), a === u.byteLength ? _.bufferSubData(t.glTarget, s, u) : _.bufferSubData(t.glTarget, s, new Float32Array(u, 0, a / 4));
              break;

            default:
              console.error("Unsupported BufferType, update buffer failed.");
          }
        }
      }

      function Xe(e, t) {
        var r = e.gl;
        t.glInternalFmt = function (e, t) {
          switch (e) {
            case d.A8:
              return t.ALPHA;

            case d.L8:
              return t.LUMINANCE;

            case d.LA8:
              return t.LUMINANCE_ALPHA;

            case d.R8:
              return t.R8;

            case d.R8SN:
              return t.R8_SNORM;

            case d.R8UI:
              return t.R8UI;

            case d.R8I:
              return t.R8I;

            case d.RG8:
              return t.RG8;

            case d.RG8SN:
              return t.RG8_SNORM;

            case d.RG8UI:
              return t.RG8UI;

            case d.RG8I:
              return t.RG8I;

            case d.RGB8:
              return t.RGB8;

            case d.RGB8SN:
              return t.RGB8_SNORM;

            case d.RGB8UI:
              return t.RGB8UI;

            case d.RGB8I:
              return t.RGB8I;

            case d.BGRA8:
            case d.RGBA8:
              return t.RGBA8;

            case d.RGBA8SN:
              return t.RGBA8_SNORM;

            case d.RGBA8UI:
              return t.RGBA8UI;

            case d.RGBA8I:
              return t.RGBA8I;

            case d.R16I:
              return t.R16I;

            case d.R16UI:
              return t.R16UI;

            case d.R16F:
              return t.R16F;

            case d.RG16I:
              return t.RG16I;

            case d.RG16UI:
              return t.RG16UI;

            case d.RG16F:
              return t.RG16F;

            case d.RGB16I:
              return t.RGB16I;

            case d.RGB16UI:
              return t.RGB16UI;

            case d.RGB16F:
              return t.RGB16F;

            case d.RGBA16I:
              return t.RGBA16I;

            case d.RGBA16UI:
              return t.RGBA16UI;

            case d.RGBA16F:
              return t.RGBA16F;

            case d.R32I:
              return t.R32I;

            case d.R32UI:
              return t.R32UI;

            case d.R32F:
              return t.R32F;

            case d.RG32I:
              return t.RG32I;

            case d.RG32UI:
              return t.RG32UI;

            case d.RG32F:
              return t.RG32F;

            case d.RGB32I:
              return t.RGB32I;

            case d.RGB32UI:
              return t.RGB32UI;

            case d.RGB32F:
              return t.RGB32F;

            case d.RGBA32I:
              return t.RGBA32I;

            case d.RGBA32UI:
              return t.RGBA32UI;

            case d.RGBA32F:
              return t.RGBA32F;

            case d.R5G6B5:
              return t.RGB565;

            case d.RGB5A1:
              return t.RGB5_A1;

            case d.RGBA4:
              return t.RGBA4;

            case d.SRGB8:
              return t.SRGB8;

            case d.SRGB8_A8:
              return t.SRGB8_ALPHA8;

            case d.RGB10A2:
              return t.RGB10_A2;

            case d.RGB10A2UI:
              return t.RGB10_A2UI;

            case d.R11G11B10F:
              return t.R11F_G11F_B10F;

            case d.DEPTH:
              return t.DEPTH_COMPONENT32F;

            case d.DEPTH_STENCIL:
              return t.DEPTH24_STENCIL8;

            case d.BC1:
              return Te.COMPRESSED_RGB_S3TC_DXT1_EXT;

            case d.BC1_ALPHA:
              return Te.COMPRESSED_RGBA_S3TC_DXT1_EXT;

            case d.BC1_SRGB:
              return Te.COMPRESSED_SRGB_S3TC_DXT1_EXT;

            case d.BC1_SRGB_ALPHA:
              return Te.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;

            case d.BC2:
              return Te.COMPRESSED_RGBA_S3TC_DXT3_EXT;

            case d.BC2_SRGB:
              return Te.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;

            case d.BC3:
              return Te.COMPRESSED_RGBA_S3TC_DXT5_EXT;

            case d.BC3_SRGB:
              return Te.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;

            case d.ETC_RGB8:
              return Te.COMPRESSED_RGB_ETC1_WEBGL;

            case d.ETC2_RGB8:
              return Te.COMPRESSED_RGB8_ETC2;

            case d.ETC2_SRGB8:
              return Te.COMPRESSED_SRGB8_ETC2;

            case d.ETC2_RGB8_A1:
              return Te.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2;

            case d.ETC2_SRGB8_A1:
              return Te.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2;

            case d.ETC2_RGBA8:
              return Te.COMPRESSED_RGBA8_ETC2_EAC;

            case d.ETC2_SRGB8_A8:
              return Te.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC;

            case d.EAC_R11:
              return Te.COMPRESSED_R11_EAC;

            case d.EAC_R11SN:
              return Te.COMPRESSED_SIGNED_R11_EAC;

            case d.EAC_RG11:
              return Te.COMPRESSED_RG11_EAC;

            case d.EAC_RG11SN:
              return Te.COMPRESSED_SIGNED_RG11_EAC;

            case d.PVRTC_RGB2:
              return Te.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;

            case d.PVRTC_RGBA2:
              return Te.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

            case d.PVRTC_RGB4:
              return Te.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;

            case d.PVRTC_RGBA4:
              return Te.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;

            case d.ASTC_RGBA_4X4:
              return Te.COMPRESSED_RGBA_ASTC_4x4_KHR;

            case d.ASTC_RGBA_5X4:
              return Te.COMPRESSED_RGBA_ASTC_5x4_KHR;

            case d.ASTC_RGBA_5X5:
              return Te.COMPRESSED_RGBA_ASTC_5x5_KHR;

            case d.ASTC_RGBA_6X5:
              return Te.COMPRESSED_RGBA_ASTC_6x5_KHR;

            case d.ASTC_RGBA_6X6:
              return Te.COMPRESSED_RGBA_ASTC_6x6_KHR;

            case d.ASTC_RGBA_8X5:
              return Te.COMPRESSED_RGBA_ASTC_8x5_KHR;

            case d.ASTC_RGBA_8X6:
              return Te.COMPRESSED_RGBA_ASTC_8x6_KHR;

            case d.ASTC_RGBA_8X8:
              return Te.COMPRESSED_RGBA_ASTC_8x8_KHR;

            case d.ASTC_RGBA_10X5:
              return Te.COMPRESSED_RGBA_ASTC_10x5_KHR;

            case d.ASTC_RGBA_10X6:
              return Te.COMPRESSED_RGBA_ASTC_10x6_KHR;

            case d.ASTC_RGBA_10X8:
              return Te.COMPRESSED_RGBA_ASTC_10x8_KHR;

            case d.ASTC_RGBA_10X10:
              return Te.COMPRESSED_RGBA_ASTC_10x10_KHR;

            case d.ASTC_RGBA_12X10:
              return Te.COMPRESSED_RGBA_ASTC_12x10_KHR;

            case d.ASTC_RGBA_12X12:
              return Te.COMPRESSED_RGBA_ASTC_12x12_KHR;

            case d.ASTC_SRGBA_4X4:
              return Te.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR;

            case d.ASTC_SRGBA_5X4:
              return Te.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR;

            case d.ASTC_SRGBA_5X5:
              return Te.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR;

            case d.ASTC_SRGBA_6X5:
              return Te.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR;

            case d.ASTC_SRGBA_6X6:
              return Te.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR;

            case d.ASTC_SRGBA_8X5:
              return Te.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR;

            case d.ASTC_SRGBA_8X6:
              return Te.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR;

            case d.ASTC_SRGBA_8X8:
              return Te.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR;

            case d.ASTC_SRGBA_10X5:
              return Te.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR;

            case d.ASTC_SRGBA_10X6:
              return Te.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR;

            case d.ASTC_SRGBA_10X8:
              return Te.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR;

            case d.ASTC_SRGBA_10X10:
              return Te.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR;

            case d.ASTC_SRGBA_12X10:
              return Te.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR;

            case d.ASTC_SRGBA_12X12:
              return Te.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR;

            default:
              return console.error("Unsupported Format, convert to WebGL internal format failed."), t.RGBA;
          }
        }(t.format, r), t.glFormat = function (e, t) {
          switch (e) {
            case d.A8:
              return t.ALPHA;

            case d.L8:
              return t.LUMINANCE;

            case d.LA8:
              return t.LUMINANCE_ALPHA;

            case d.R8:
            case d.R8SN:
              return t.RED;

            case d.R8UI:
            case d.R8I:
              return t.RED;

            case d.RG8:
            case d.RG8SN:
            case d.RG8UI:
            case d.RG8I:
              return t.RG;

            case d.RGB8:
            case d.RGB8SN:
            case d.RGB8UI:
            case d.RGB8I:
              return t.RGB;

            case d.BGRA8:
            case d.RGBA8:
            case d.RGBA8SN:
            case d.RGBA8UI:
            case d.RGBA8I:
              return t.RGBA;

            case d.R16UI:
            case d.R16I:
            case d.R16F:
              return t.RED;

            case d.RG16UI:
            case d.RG16I:
            case d.RG16F:
              return t.RG;

            case d.RGB16UI:
            case d.RGB16I:
            case d.RGB16F:
              return t.RGB;

            case d.RGBA16UI:
            case d.RGBA16I:
            case d.RGBA16F:
              return t.RGBA;

            case d.R32UI:
            case d.R32I:
            case d.R32F:
              return t.RED;

            case d.RG32UI:
            case d.RG32I:
            case d.RG32F:
              return t.RG;

            case d.RGB32UI:
            case d.RGB32I:
            case d.RGB32F:
              return t.RGB;

            case d.RGBA32UI:
            case d.RGBA32I:
            case d.RGBA32F:
            case d.RGB10A2:
              return t.RGBA;

            case d.R11G11B10F:
            case d.R5G6B5:
              return t.RGB;

            case d.RGB5A1:
            case d.RGBA4:
              return t.RGBA;

            case d.SRGB8:
              return t.RGB;

            case d.SRGB8_A8:
              return t.RGBA;

            case d.DEPTH:
              return t.DEPTH_COMPONENT;

            case d.DEPTH_STENCIL:
              return t.DEPTH_STENCIL;

            case d.BC1:
              return Te.COMPRESSED_RGB_S3TC_DXT1_EXT;

            case d.BC1_ALPHA:
              return Te.COMPRESSED_RGBA_S3TC_DXT1_EXT;

            case d.BC1_SRGB:
              return Te.COMPRESSED_SRGB_S3TC_DXT1_EXT;

            case d.BC1_SRGB_ALPHA:
              return Te.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;

            case d.BC2:
              return Te.COMPRESSED_RGBA_S3TC_DXT3_EXT;

            case d.BC2_SRGB:
              return Te.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;

            case d.BC3:
              return Te.COMPRESSED_RGBA_S3TC_DXT5_EXT;

            case d.BC3_SRGB:
              return Te.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;

            case d.ETC_RGB8:
              return Te.COMPRESSED_RGB_ETC1_WEBGL;

            case d.ETC2_RGB8:
              return Te.COMPRESSED_RGB8_ETC2;

            case d.ETC2_SRGB8:
              return Te.COMPRESSED_SRGB8_ETC2;

            case d.ETC2_RGB8_A1:
              return Te.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2;

            case d.ETC2_SRGB8_A1:
              return Te.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2;

            case d.ETC2_RGBA8:
              return Te.COMPRESSED_RGBA8_ETC2_EAC;

            case d.ETC2_SRGB8_A8:
              return Te.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC;

            case d.EAC_R11:
              return Te.COMPRESSED_R11_EAC;

            case d.EAC_R11SN:
              return Te.COMPRESSED_SIGNED_R11_EAC;

            case d.EAC_RG11:
              return Te.COMPRESSED_RG11_EAC;

            case d.EAC_RG11SN:
              return Te.COMPRESSED_SIGNED_RG11_EAC;

            case d.PVRTC_RGB2:
              return Te.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;

            case d.PVRTC_RGBA2:
              return Te.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

            case d.PVRTC_RGB4:
              return Te.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;

            case d.PVRTC_RGBA4:
              return Te.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;

            case d.ASTC_RGBA_4X4:
              return Te.COMPRESSED_RGBA_ASTC_4x4_KHR;

            case d.ASTC_RGBA_5X4:
              return Te.COMPRESSED_RGBA_ASTC_5x4_KHR;

            case d.ASTC_RGBA_5X5:
              return Te.COMPRESSED_RGBA_ASTC_5x5_KHR;

            case d.ASTC_RGBA_6X5:
              return Te.COMPRESSED_RGBA_ASTC_6x5_KHR;

            case d.ASTC_RGBA_6X6:
              return Te.COMPRESSED_RGBA_ASTC_6x6_KHR;

            case d.ASTC_RGBA_8X5:
              return Te.COMPRESSED_RGBA_ASTC_8x5_KHR;

            case d.ASTC_RGBA_8X6:
              return Te.COMPRESSED_RGBA_ASTC_8x6_KHR;

            case d.ASTC_RGBA_8X8:
              return Te.COMPRESSED_RGBA_ASTC_8x8_KHR;

            case d.ASTC_RGBA_10X5:
              return Te.COMPRESSED_RGBA_ASTC_10x5_KHR;

            case d.ASTC_RGBA_10X6:
              return Te.COMPRESSED_RGBA_ASTC_10x6_KHR;

            case d.ASTC_RGBA_10X8:
              return Te.COMPRESSED_RGBA_ASTC_10x8_KHR;

            case d.ASTC_RGBA_10X10:
              return Te.COMPRESSED_RGBA_ASTC_10x10_KHR;

            case d.ASTC_RGBA_12X10:
              return Te.COMPRESSED_RGBA_ASTC_12x10_KHR;

            case d.ASTC_RGBA_12X12:
              return Te.COMPRESSED_RGBA_ASTC_12x12_KHR;

            case d.ASTC_SRGBA_4X4:
              return Te.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR;

            case d.ASTC_SRGBA_5X4:
              return Te.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR;

            case d.ASTC_SRGBA_5X5:
              return Te.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR;

            case d.ASTC_SRGBA_6X5:
              return Te.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR;

            case d.ASTC_SRGBA_6X6:
              return Te.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR;

            case d.ASTC_SRGBA_8X5:
              return Te.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR;

            case d.ASTC_SRGBA_8X6:
              return Te.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR;

            case d.ASTC_SRGBA_8X8:
              return Te.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR;

            case d.ASTC_SRGBA_10X5:
              return Te.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR;

            case d.ASTC_SRGBA_10X6:
              return Te.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR;

            case d.ASTC_SRGBA_10X8:
              return Te.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR;

            case d.ASTC_SRGBA_10X10:
              return Te.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR;

            case d.ASTC_SRGBA_12X10:
              return Te.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR;

            case d.ASTC_SRGBA_12X12:
              return Te.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR;

            default:
              return console.error("Unsupported Format, convert to WebGL format failed."), t.RGBA;
          }
        }(t.format, r), t.glType = pe(t.format, r);
        var s = t.width,
            a = t.height;

        switch (t.type) {
          case o.TEX2D:
            if (t.glTarget = r.TEXTURE_2D, t.isSwapchainTexture) break;
            var n = Math.max(s, a);

            if (n > e.capabilities.maxTextureSize && f(9100, n, e.capabilities.maxTextureSize), t.samples === E.ONE) {
              if (t.glTexture = r.createTexture(), t.size > 0) {
                var i = e.stateCache.glTexUnits[e.stateCache.texUnit];
                if (i.glTexture !== t.glTexture && (r.bindTexture(r.TEXTURE_2D, t.glTexture), i.glTexture = t.glTexture), R[t.format].isCompressed) for (var u = 0; u < t.mipLevel; ++u) {
                  var _ = A(t.format, s, a, 1),
                      l = new Uint8Array(_);

                  r.compressedTexImage2D(r.TEXTURE_2D, u, t.glInternalFmt, s, a, 0, l), s = Math.max(1, s >> 1), a = Math.max(1, a >> 1);
                } else r.texStorage2D(r.TEXTURE_2D, t.mipLevel, t.glInternalFmt, s, a);
              }
            } else t.glRenderbuffer = r.createRenderbuffer(), t.size > 0 && (e.stateCache.glRenderbuffer !== t.glRenderbuffer && (r.bindRenderbuffer(r.RENDERBUFFER, t.glRenderbuffer), e.stateCache.glRenderbuffer = t.glRenderbuffer), r.renderbufferStorageMultisample(r.RENDERBUFFER, t.samples, t.glInternalFmt, t.width, t.height));

            break;

          case o.CUBE:
            t.glTarget = r.TEXTURE_CUBE_MAP;
            var c = Math.max(s, a);

            if (c > e.capabilities.maxCubeMapTextureSize && f(9100, c, e.capabilities.maxTextureSize), t.glTexture = r.createTexture(), t.size > 0) {
              var h = e.stateCache.glTexUnits[e.stateCache.texUnit];
              if (h.glTexture !== t.glTexture && (r.bindTexture(r.TEXTURE_CUBE_MAP, t.glTexture), h.glTexture = t.glTexture), R[t.format].isCompressed) for (var S = 0; S < t.mipLevel; ++S) {
                for (var T = A(t.format, s, a, 1), g = new Uint8Array(T), B = 0; B < 6; ++B) {
                  r.compressedTexImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + B, S, t.glInternalFmt, s, a, 0, g);
                }

                s = Math.max(1, s >> 1), a = Math.max(1, a >> 1);
              } else r.texStorage2D(r.TEXTURE_CUBE_MAP, t.mipLevel, t.glInternalFmt, s, a);
            }

            break;

          default:
            console.error("Unsupported TextureType, create texture failed."), t.type = o.TEX2D, t.glTarget = r.TEXTURE_2D;
        }
      }

      function ke(e, t) {
        var r = e.gl;

        if (t.glTexture) {
          var s = e.stateCache.glTexUnits,
              a = e.stateCache.texUnit;
          r.deleteTexture(t.glTexture);

          for (var n = 0; n < s.length; ++n) {
            s[n].glTexture === t.glTexture && (r.activeTexture(r.TEXTURE0 + n), a = n, r.bindTexture(t.glTarget, null), s[n].glTexture = null);
          }

          e.stateCache.texUnit = a, t.glTexture = null;
        }

        if (t.glRenderbuffer) {
          var i = e.stateCache.glRenderbuffer;
          r.deleteRenderbuffer(t.glRenderbuffer), i === t.glRenderbuffer && (r.bindRenderbuffer(r.RENDERBUFFER, null), i = null), t.glRenderbuffer = null;
        }
      }

      var Ve = {
        gpuPipelineState: null,
        gpuInputAssembler: null,
        glPrimitive: 0,
        invalidateAttachments: []
      };

      function Ke(e, t, r, s, a, n, i) {
        var u = e.gl,
            _ = e.stateCache,
            l = 0;

        if (r && t) {
          _.glFramebuffer !== r.glFramebuffer && (u.bindFramebuffer(u.FRAMEBUFFER, r.glFramebuffer), _.glFramebuffer = r.glFramebuffer), _.viewport.left === s.x && _.viewport.top === s.y && _.viewport.width === s.width && _.viewport.height === s.height || (u.viewport(s.x, s.y, s.width, s.height), _.viewport.left = s.x, _.viewport.top = s.y, _.viewport.width = s.width, _.viewport.height = s.height), _.scissorRect.x === s.x && _.scissorRect.y === s.y && _.scissorRect.width === s.width && _.scissorRect.height === s.height || (u.scissor(s.x, s.y, s.width, s.height), _.scissorRect.x = s.x, _.scissorRect.y = s.y, _.scissorRect.width = s.width, _.scissorRect.height = s.height), Ve.invalidateAttachments.length = 0;

          for (var c = 0; c < a.length; ++c) {
            var o = t.colorAttachments[c];
            if (o.format !== d.UNKNOWN) switch (o.loadOp) {
              case B.LOAD:
                break;

              case B.CLEAR:
                if (_.bs.targets[0].blendColorMask !== C.ALL && u.colorMask(!0, !0, !0, !0), r.isOffscreen) Ce[0] = a[c].x, Ce[1] = a[c].y, Ce[2] = a[c].z, Ce[3] = a[c].w, u.clearBufferfv(u.COLOR, c, Ce);else {
                  var f = a[0];
                  u.clearColor(f.x, f.y, f.z, f.w), l |= u.COLOR_BUFFER_BIT;
                }
                break;

              case B.DISCARD:
                Ve.invalidateAttachments.push(u.COLOR_ATTACHMENT0 + c);
            }
          }

          if (t.depthStencilAttachment && t.depthStencilAttachment.format !== d.UNKNOWN) {
            switch (t.depthStencilAttachment.depthLoadOp) {
              case B.LOAD:
                break;

              case B.CLEAR:
                _.dss.depthWrite || u.depthMask(!0), u.clearDepth(n), l |= u.DEPTH_BUFFER_BIT;
                break;

              case B.DISCARD:
                Ve.invalidateAttachments.push(u.DEPTH_ATTACHMENT);
            }

            if (R[t.depthStencilAttachment.format].hasStencil) switch (t.depthStencilAttachment.stencilLoadOp) {
              case B.LOAD:
                break;

              case B.CLEAR:
                _.dss.stencilWriteMaskFront || u.stencilMaskSeparate(u.FRONT, 65535), _.dss.stencilWriteMaskBack || u.stencilMaskSeparate(u.BACK, 65535), u.clearStencil(i), l |= u.STENCIL_BUFFER_BIT;
                break;

              case B.DISCARD:
                Ve.invalidateAttachments.push(u.STENCIL_ATTACHMENT);
            }
          }

          if (r.glFramebuffer && Ve.invalidateAttachments.length && u.invalidateFramebuffer(u.FRAMEBUFFER, Ve.invalidateAttachments), l && u.clear(l), l & u.COLOR_BUFFER_BIT) {
            var A = _.bs.targets[0].blendColorMask;

            if (A !== C.ALL) {
              var E = (A & C.R) !== C.NONE,
                  h = (A & C.G) !== C.NONE,
                  S = (A & C.B) !== C.NONE,
                  T = (A & C.A) !== C.NONE;
              u.colorMask(E, h, S, T);
            }
          }

          l & u.DEPTH_BUFFER_BIT && !_.dss.depthWrite && u.depthMask(!1), l & u.STENCIL_BUFFER_BIT && (_.dss.stencilWriteMaskFront || u.stencilMaskSeparate(u.FRONT, 0), _.dss.stencilWriteMaskBack || u.stencilMaskSeparate(u.BACK, 0));
        }
      }

      function We(e, t, r, s, a, n) {
        var i = e.gl,
            u = e.stateCache,
            _ = t && t.gpuShader,
            l = !1;

        if (t && Ve.gpuPipelineState !== t) {
          if (Ve.gpuPipelineState = t, Ve.glPrimitive = t.glPrimitive, _) {
            var c = _.glProgram;
            u.glProgram !== c && (i.useProgram(c), u.glProgram = c, l = !0);
          }

          var o = t.rs;

          if (o) {
            if (u.rs.cullMode !== o.cullMode) {
              switch (o.cullMode) {
                case p.NONE:
                  i.disable(i.CULL_FACE);
                  break;

                case p.FRONT:
                  i.enable(i.CULL_FACE), i.cullFace(i.FRONT);
                  break;

                case p.BACK:
                  i.enable(i.CULL_FACE), i.cullFace(i.BACK);
              }

              e.stateCache.rs.cullMode = o.cullMode;
            }

            var f = o.isFrontFaceCCW;
            e.stateCache.rs.isFrontFaceCCW !== f && (i.frontFace(f ? i.CCW : i.CW), e.stateCache.rs.isFrontFaceCCW = f), e.stateCache.rs.depthBias === o.depthBias && e.stateCache.rs.depthBiasSlop === o.depthBiasSlop || (i.polygonOffset(o.depthBias, o.depthBiasSlop), e.stateCache.rs.depthBias = o.depthBias, e.stateCache.rs.depthBiasSlop = o.depthBiasSlop), e.stateCache.rs.lineWidth !== o.lineWidth && (i.lineWidth(o.lineWidth), e.stateCache.rs.lineWidth = o.lineWidth);
          }

          var R = t.dss;
          R && (u.dss.depthTest !== R.depthTest && (R.depthTest ? i.enable(i.DEPTH_TEST) : i.disable(i.DEPTH_TEST), u.dss.depthTest = R.depthTest), u.dss.depthWrite !== R.depthWrite && (i.depthMask(R.depthWrite), u.dss.depthWrite = R.depthWrite), u.dss.depthFunc !== R.depthFunc && (i.depthFunc(be[R.depthFunc]), u.dss.depthFunc = R.depthFunc), u.dss.stencilTestFront === R.stencilTestFront && u.dss.stencilTestBack === R.stencilTestBack || (R.stencilTestFront || R.stencilTestBack ? i.enable(i.STENCIL_TEST) : i.disable(i.STENCIL_TEST), u.dss.stencilTestFront = R.stencilTestFront, u.dss.stencilTestBack = R.stencilTestBack), u.dss.stencilFuncFront === R.stencilFuncFront && u.dss.stencilRefFront === R.stencilRefFront && u.dss.stencilReadMaskFront === R.stencilReadMaskFront || (i.stencilFuncSeparate(i.FRONT, be[R.stencilFuncFront], R.stencilRefFront, R.stencilReadMaskFront), u.dss.stencilFuncFront = R.stencilFuncFront, u.dss.stencilRefFront = R.stencilRefFront, u.dss.stencilReadMaskFront = R.stencilReadMaskFront), u.dss.stencilFailOpFront === R.stencilFailOpFront && u.dss.stencilZFailOpFront === R.stencilZFailOpFront && u.dss.stencilPassOpFront === R.stencilPassOpFront || (i.stencilOpSeparate(i.FRONT, Ie[R.stencilFailOpFront], Ie[R.stencilZFailOpFront], Ie[R.stencilPassOpFront]), u.dss.stencilFailOpFront = R.stencilFailOpFront, u.dss.stencilZFailOpFront = R.stencilZFailOpFront, u.dss.stencilPassOpFront = R.stencilPassOpFront), u.dss.stencilWriteMaskFront !== R.stencilWriteMaskFront && (i.stencilMaskSeparate(i.FRONT, R.stencilWriteMaskFront), u.dss.stencilWriteMaskFront = R.stencilWriteMaskFront), u.dss.stencilFuncBack === R.stencilFuncBack && u.dss.stencilRefBack === R.stencilRefBack && u.dss.stencilReadMaskBack === R.stencilReadMaskBack || (i.stencilFuncSeparate(i.BACK, be[R.stencilFuncBack], R.stencilRefBack, R.stencilReadMaskBack), u.dss.stencilFuncBack = R.stencilFuncBack, u.dss.stencilRefBack = R.stencilRefBack, u.dss.stencilReadMaskBack = R.stencilReadMaskBack), u.dss.stencilFailOpBack === R.stencilFailOpBack && u.dss.stencilZFailOpBack === R.stencilZFailOpBack && u.dss.stencilPassOpBack === R.stencilPassOpBack || (i.stencilOpSeparate(i.BACK, Ie[R.stencilFailOpBack], Ie[R.stencilZFailOpBack], Ie[R.stencilPassOpBack]), u.dss.stencilFailOpBack = R.stencilFailOpBack, u.dss.stencilZFailOpBack = R.stencilZFailOpBack, u.dss.stencilPassOpBack = R.stencilPassOpBack), u.dss.stencilWriteMaskBack !== R.stencilWriteMaskBack && (i.stencilMaskSeparate(i.BACK, R.stencilWriteMaskBack), u.dss.stencilWriteMaskBack = R.stencilWriteMaskBack));
          var A = t.bs;

          if (A) {
            u.bs.isA2C !== A.isA2C && (A.isA2C ? i.enable(i.SAMPLE_ALPHA_TO_COVERAGE) : i.disable(i.SAMPLE_ALPHA_TO_COVERAGE), u.bs.isA2C = A.isA2C), u.bs.blendColor.x === A.blendColor.x && u.bs.blendColor.y === A.blendColor.y && u.bs.blendColor.z === A.blendColor.z && u.bs.blendColor.w === A.blendColor.w || (i.blendColor(A.blendColor.x, A.blendColor.y, A.blendColor.z, A.blendColor.w), u.bs.blendColor.x = A.blendColor.x, u.bs.blendColor.y = A.blendColor.y, u.bs.blendColor.z = A.blendColor.z, u.bs.blendColor.w = A.blendColor.w);
            var E = A.targets[0],
                h = u.bs.targets[0];
            h.blend !== E.blend && (E.blend ? i.enable(i.BLEND) : i.disable(i.BLEND), h.blend = E.blend), h.blendEq === E.blendEq && h.blendAlphaEq === E.blendAlphaEq || (i.blendEquationSeparate(Oe[E.blendEq], Oe[E.blendAlphaEq]), h.blendEq = E.blendEq, h.blendAlphaEq = E.blendAlphaEq), h.blendSrc === E.blendSrc && h.blendDst === E.blendDst && h.blendSrcAlpha === E.blendSrcAlpha && h.blendDstAlpha === E.blendDstAlpha || (i.blendFuncSeparate(Me[E.blendSrc], Me[E.blendDst], Me[E.blendSrcAlpha], Me[E.blendDstAlpha]), h.blendSrc = E.blendSrc, h.blendDst = E.blendDst, h.blendSrcAlpha = E.blendSrcAlpha, h.blendDstAlpha = E.blendDstAlpha), h.blendColorMask !== E.blendColorMask && (i.colorMask((E.blendColorMask & C.R) !== C.NONE, (E.blendColorMask & C.G) !== C.NONE, (E.blendColorMask & C.B) !== C.NONE, (E.blendColorMask & C.A) !== C.NONE), h.blendColorMask = E.blendColorMask);
          }
        }

        if (t && t.gpuPipelineLayout && _) {
          for (var T = _.glBlocks.length, g = t.gpuPipelineLayout.dynamicOffsetIndices, d = 0; d < T; d++) {
            var B = _.glBlocks[d],
                G = s[B.set],
                x = G && G.descriptorIndices[B.binding],
                P = x >= 0 && G.gpuDescriptors[x];

            if (P && P.gpuBuffer) {
              var F = g[B.set],
                  b = F && F[B.binding],
                  I = P.gpuBuffer.glOffset;
              b >= 0 && (I += a[b]), u.glBindUBOs[B.glBinding] === P.gpuBuffer.glBuffer && u.glBindUBOOffsets[B.glBinding] === I || (I ? i.bindBufferRange(i.UNIFORM_BUFFER, B.glBinding, P.gpuBuffer.glBuffer, I, P.gpuBuffer.size) : i.bindBufferBase(i.UNIFORM_BUFFER, B.glBinding, P.gpuBuffer.glBuffer), u.glUniformBuffer = u.glBindUBOs[B.glBinding] = P.gpuBuffer.glBuffer, u.glBindUBOOffsets[B.glBinding] = I);
            } else S("Buffer binding '" + B.name + "' at set " + B.set + " binding " + B.binding + " is not bounded");
          }

          for (var O = _.glSamplerTextures.length, M = 0; M < O; M++) {
            for (var D = _.glSamplerTextures[M], v = s[D.set], L = v && v.descriptorIndices[D.binding], U = L >= 0 && v.gpuDescriptors[L], N = 0; N < D.units.length; N++) {
              var y = D.units[N],
                  w = u.glTexUnits[y];

              if (U && U.gpuTextureView && U.gpuTextureView.gpuTexture && U.gpuSampler) {
                var H = U.gpuTextureView,
                    X = H.gpuTexture,
                    k = H.baseLevel,
                    V = k + H.levelCount;

                if (X.size > 0) {
                  w.glTexture !== X.glTexture && (u.texUnit !== y && (i.activeTexture(i.TEXTURE0 + y), u.texUnit = y), X.glTexture ? i.bindTexture(X.glTarget, X.glTexture) : i.bindTexture(X.glTarget, e.nullTex2D.gpuTexture.glTexture), w.glTexture = X.glTexture);
                  var K = U.gpuSampler.getGLSampler(e, k, V);
                  u.glSamplerUnits[y] !== K && (i.bindSampler(y, K), u.glSamplerUnits[y] = K);
                }

                U = v.gpuDescriptors[++L];
              } else S("Sampler binding '" + D.name + "' at set " + D.set + " binding " + D.binding + " index " + N + " is not bounded");
            }
          }
        }

        if (r && _ && (l || Ve.gpuInputAssembler !== r)) if (Ve.gpuInputAssembler = r, e.extensions.useVAO) {
          var W = r.glVAOs.get(_.glProgram);

          if (!W) {
            var z;
            W = i.createVertexArray(), r.glVAOs.set(_.glProgram, W), i.bindVertexArray(W), i.bindBuffer(i.ARRAY_BUFFER, null), i.bindBuffer(i.ELEMENT_ARRAY_BUFFER, null), u.glArrayBuffer = null, u.glElementArrayBuffer = null;

            for (var Y = 0; Y < _.glInputs.length; Y++) {
              var q = _.glInputs[Y];
              z = null;

              for (var Z = 0; Z < r.glAttribs.length; Z++) {
                var j = r.glAttribs[Z];

                if (j.name === q.name) {
                  z = j;
                  break;
                }
              }

              if (z) {
                u.glArrayBuffer !== z.glBuffer && (i.bindBuffer(i.ARRAY_BUFFER, z.glBuffer), u.glArrayBuffer = z.glBuffer);

                for (var Q = 0; Q < z.componentCount; ++Q) {
                  var $ = q.glLoc + Q,
                      J = z.offset + z.size * Q;
                  i.enableVertexAttribArray($), u.glCurrentAttribLocs[$] = !0, i.vertexAttribPointer($, z.count, z.glType, z.isNormalized, z.stride, J), i.vertexAttribDivisor($, z.isInstanced ? 1 : 0);
                }
              }
            }

            var ee = r.gpuIndexBuffer;
            ee && i.bindBuffer(i.ELEMENT_ARRAY_BUFFER, ee.glBuffer), i.bindVertexArray(null), i.bindBuffer(i.ARRAY_BUFFER, null), i.bindBuffer(i.ELEMENT_ARRAY_BUFFER, null), u.glArrayBuffer = null, u.glElementArrayBuffer = null;
          }

          u.glVAO !== W && (i.bindVertexArray(W), u.glVAO = W);
        } else {
          for (var te = 0; te < e.capabilities.maxVertexAttributes; ++te) {
            u.glCurrentAttribLocs[te] = !1;
          }

          for (var re = 0; re < _.glInputs.length; re++) {
            for (var se = _.glInputs[re], ae = null, ne = 0; ne < r.glAttribs.length; ne++) {
              var ie = r.glAttribs[ne];

              if (ie.name === se.name) {
                ae = ie;
                break;
              }
            }

            if (ae) {
              u.glArrayBuffer !== ae.glBuffer && (i.bindBuffer(i.ARRAY_BUFFER, ae.glBuffer), u.glArrayBuffer = ae.glBuffer);

              for (var ue = 0; ue < ae.componentCount; ++ue) {
                var _e = se.glLoc + ue,
                    le = ae.offset + ae.size * ue;

                !u.glEnabledAttribLocs[_e] && _e >= 0 && (i.enableVertexAttribArray(_e), u.glEnabledAttribLocs[_e] = !0), u.glCurrentAttribLocs[_e] = !0, i.vertexAttribPointer(_e, ae.count, ae.glType, ae.isNormalized, ae.stride, le), i.vertexAttribDivisor(_e, ae.isInstanced ? 1 : 0);
              }
            }
          }

          var ce = r.gpuIndexBuffer;
          ce && u.glElementArrayBuffer !== ce.glBuffer && (i.bindBuffer(i.ELEMENT_ARRAY_BUFFER, ce.glBuffer), u.glElementArrayBuffer = ce.glBuffer);

          for (var oe = 0; oe < e.capabilities.maxVertexAttributes; ++oe) {
            u.glEnabledAttribLocs[oe] !== u.glCurrentAttribLocs[oe] && (i.disableVertexAttribArray(oe), u.glEnabledAttribLocs[oe] = !1);
          }
        }
        if (t && t.dynamicStates.length) for (var fe = t.dynamicStates.length, Re = 0; Re < fe; Re++) {
          switch (t.dynamicStates[Re]) {
            case m.LINE_WIDTH:
              u.rs.lineWidth !== n.lineWidth && (i.lineWidth(n.lineWidth), u.rs.lineWidth = n.lineWidth);
              break;

            case m.DEPTH_BIAS:
              u.rs.depthBias === n.depthBiasConstant && u.rs.depthBiasSlop === n.depthBiasSlope || (i.polygonOffset(n.depthBiasConstant, n.depthBiasSlope), u.rs.depthBias = n.depthBiasConstant, u.rs.depthBiasSlop = n.depthBiasSlope);
              break;

            case m.BLEND_CONSTANTS:
              var Ae = n.blendConstant;
              u.bs.blendColor.x === Ae.x && u.bs.blendColor.y === Ae.y && u.bs.blendColor.z === Ae.z && u.bs.blendColor.w === Ae.w || (i.blendColor(Ae.x, Ae.y, Ae.z, Ae.w), u.bs.blendColor.copy(Ae));
              break;

            case m.STENCIL_WRITE_MASK:
              var Ee = n.stencilStatesFront,
                  he = n.stencilStatesBack;
              u.dss.stencilWriteMaskFront !== Ee.writeMask && (i.stencilMaskSeparate(i.FRONT, Ee.writeMask), u.dss.stencilWriteMaskFront = Ee.writeMask), u.dss.stencilWriteMaskBack !== he.writeMask && (i.stencilMaskSeparate(i.BACK, he.writeMask), u.dss.stencilWriteMaskBack = he.writeMask);
              break;

            case m.STENCIL_COMPARE_MASK:
              var Se = n.stencilStatesFront,
                  Te = n.stencilStatesBack;
              u.dss.stencilRefFront === Se.reference && u.dss.stencilReadMaskFront === Se.compareMask || (i.stencilFuncSeparate(i.FRONT, be[u.dss.stencilFuncFront], Se.reference, Se.compareMask), u.dss.stencilRefFront = Se.reference, u.dss.stencilReadMaskFront = Se.compareMask), u.dss.stencilRefBack === Te.reference && u.dss.stencilReadMaskBack === Te.compareMask || (i.stencilFuncSeparate(i.BACK, be[u.dss.stencilFuncBack], Te.reference, Te.compareMask), u.dss.stencilRefBack = Te.reference, u.dss.stencilReadMaskBack = Te.compareMask);
          }
        }
      }

      function ze(e, t) {
        var r = e.gl,
            s = Ve.gpuInputAssembler,
            a = Ve.glPrimitive,
            n = e.extensions.WEBGL_multi_draw;

        if (s) {
          var i = s.gpuIndexBuffer;

          if (s.gpuIndirectBuffer) {
            var u = s.gpuIndirectBuffer.indirects;

            if (u.drawByIndex) {
              for (var _ = 0; _ < u.drawCount; _++) {
                u.byteOffsets[_] = u.offsets[_] * i.stride;
              }

              if (n) u.instancedDraw ? n.multiDrawElementsInstancedWEBGL(a, u.counts, 0, s.glIndexType, u.byteOffsets, 0, u.instances, 0, u.drawCount) : n.multiDrawElementsWEBGL(a, u.counts, 0, s.glIndexType, u.byteOffsets, 0, u.drawCount);else for (var l = 0; l < u.drawCount; l++) {
                u.instances[l] ? r.drawElementsInstanced(a, u.counts[l], s.glIndexType, u.byteOffsets[l], u.instances[l]) : r.drawElements(a, u.counts[l], s.glIndexType, u.byteOffsets[l]);
              }
            } else if (n) u.instancedDraw ? n.multiDrawArraysInstancedWEBGL(a, u.offsets, 0, u.counts, 0, u.instances, 0, u.drawCount) : n.multiDrawArraysWEBGL(a, u.offsets, 0, u.counts, 0, u.drawCount);else for (var c = 0; c < u.drawCount; c++) {
              u.instances[c] ? r.drawArraysInstanced(a, u.offsets[c], u.counts[c], u.instances[c]) : r.drawArrays(a, u.offsets[c], u.counts[c]);
            }
          } else if (t.instanceCount) {
            if (i) {
              if (t.indexCount > 0) {
                var o = t.firstIndex * i.stride;
                r.drawElementsInstanced(a, t.indexCount, s.glIndexType, o, t.instanceCount);
              }
            } else t.vertexCount > 0 && r.drawArraysInstanced(a, t.firstVertex, t.vertexCount, t.instanceCount);
          } else if (i) {
            if (t.indexCount > 0) {
              var f = t.firstIndex * i.stride;
              r.drawElements(a, t.indexCount, s.glIndexType, f);
            }
          } else t.vertexCount > 0 && r.drawArrays(a, t.firstVertex, t.vertexCount);
        }
      }

      var Ye = new Array(Fe.COUNT);

      function qe(e, t) {
        Ye.fill(0);

        for (var r = 0; r < t.cmds.length; ++r) {
          var s = t.cmds.array[r],
              a = Ye[s]++;

          switch (s) {
            case Fe.BEGIN_RENDER_PASS:
              var n = t.beginRenderPassCmds.array[a];
              Ke(e, n.gpuRenderPass, n.gpuFramebuffer, n.renderArea, n.clearColors, n.clearDepth, n.clearStencil);
              break;

            case Fe.BIND_STATES:
              var i = t.bindStatesCmds.array[a];
              We(e, i.gpuPipelineState, i.gpuInputAssembler, i.gpuDescriptorSets, i.dynamicOffsets, i.dynamicStates);
              break;

            case Fe.DRAW:
              ze(e, t.drawCmds.array[a].drawInfo);
              break;

            case Fe.UPDATE_BUFFER:
              var u = t.updateBufferCmds.array[a];
              He(e, u.gpuBuffer, u.buffer, u.offset, u.size);
              break;

            case Fe.COPY_BUFFER_TO_TEXTURE:
              var _ = t.copyBufferToTextureCmds.array[a];
              Ze(e, _.buffers, _.gpuTexture, _.regions);
          }
        }
      }

      function Ze(e, t, r, s) {
        var a = e.gl,
            n = e.stateCache.glTexUnits[e.stateCache.texUnit];
        n.glTexture !== r.glTexture && (a.bindTexture(r.glTarget, r.glTexture), n.glTexture = r.glTexture);
        var i = 0,
            u = 1,
            _ = 1,
            l = 0,
            c = R[r.format].isCompressed;

        switch (r.glTarget) {
          case a.TEXTURE_2D:
            for (var o = 0; o < s.length; o++) {
              var f = s[o];
              u = f.texExtent.width, _ = f.texExtent.height;
              var A = t[i++];
              c ? r.glInternalFmt !== Te.COMPRESSED_RGB_ETC1_WEBGL ? a.compressedTexSubImage2D(a.TEXTURE_2D, f.texSubres.mipLevel, f.texOffset.x, f.texOffset.y, u, _, r.glFormat, A) : a.compressedTexImage2D(a.TEXTURE_2D, f.texSubres.mipLevel, r.glInternalFmt, u, _, 0, A) : a.texSubImage2D(a.TEXTURE_2D, f.texSubres.mipLevel, f.texOffset.x, f.texOffset.y, u, _, r.glFormat, r.glType, A);
            }

            break;

          case a.TEXTURE_CUBE_MAP:
            for (var E = 0; E < s.length; E++) {
              var h = s[E],
                  S = h.texSubres.baseArrayLayer + h.texSubres.layerCount;

              for (l = h.texSubres.baseArrayLayer; l < S; ++l) {
                u = h.texExtent.width, _ = h.texExtent.height;
                var T = t[i++];
                c ? r.glInternalFmt !== Te.COMPRESSED_RGB_ETC1_WEBGL ? a.compressedTexSubImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X + l, h.texSubres.mipLevel, h.texOffset.x, h.texOffset.y, u, _, r.glFormat, T) : a.compressedTexImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X + l, h.texSubres.mipLevel, r.glInternalFmt, u, _, 0, T) : a.texSubImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X + l, h.texSubres.mipLevel, h.texOffset.x, h.texOffset.y, u, _, r.glFormat, r.glType, T);
              }
            }

            break;

          default:
            console.error("Unsupported GL texture type, copy buffer to texture failed.");
        }

        r.flags & G.GEN_MIPMAP && a.generateMipmap(r.glTarget);
      }

      var je = function () {
        function e() {
          this.counts = void 0, this.offsets = void 0, this.instances = void 0, this.drawCount = 0, this.drawByIndex = !1, this.instancedDraw = !1, this.byteOffsets = void 0, this._capacity = 4, this.counts = new Int32Array(this._capacity), this.offsets = new Int32Array(this._capacity), this.instances = new Int32Array(this._capacity), this.byteOffsets = new Int32Array(this._capacity);
        }

        var t = e.prototype;
        return t.clearDraws = function () {
          this.drawCount = 0, this.drawByIndex = !1, this.instancedDraw = !1;
        }, t.setDrawInfo = function (e, t) {
          this._ensureCapacity(e), this.drawByIndex = t.indexCount > 0, this.instancedDraw = !!t.instanceCount, this.drawCount = Math.max(e + 1, this.drawCount), this.drawByIndex ? (this.counts[e] = t.indexCount, this.offsets[e] = t.firstIndex) : (this.counts[e] = t.vertexCount, this.offsets[e] = t.firstVertex), this.instances[e] = Math.max(1, t.instanceCount);
        }, t._ensureCapacity = function (e) {
          if (!(this._capacity > e)) {
            this._capacity = b(e);
            var t = new Int32Array(this._capacity),
                r = new Int32Array(this._capacity),
                s = new Int32Array(this._capacity);
            this.byteOffsets = new Int32Array(this._capacity), t.set(this.counts), r.set(this.offsets), s.set(this.instances), this.counts = t, this.offsets = r, this.instances = s;
          }
        }, e;
      }(),
          Qe = function (e) {
        function r() {
          for (var t, r = arguments.length, s = new Array(r), a = 0; a < r; a++) {
            s[a] = arguments[a];
          }

          return (t = e.call.apply(e, [this].concat(s)) || this)._gpuBuffer = null, t;
        }

        t(r, e);
        var s = r.prototype;
        return s.initialize = function (e) {
          if ("buffer" in e) {
            this._isBufferView = !0;
            var t = e.buffer;
            this._usage = t.usage, this._memUsage = t.memUsage, this._size = this._stride = e.range, this._count = 1, this._flags = t.flags, this._gpuBuffer = {
              usage: this._usage,
              memUsage: this._memUsage,
              size: this._size,
              stride: this._stride,
              buffer: null,
              indirects: t.gpuBuffer.indirects,
              glTarget: t.gpuBuffer.glTarget,
              glBuffer: t.gpuBuffer.glBuffer,
              glOffset: e.offset
            };
          } else this._usage = e.usage, this._memUsage = e.memUsage, this._size = e.size, this._stride = Math.max(e.stride || this._size, 1), this._count = this._size / this._stride, this._flags = e.flags, this._gpuBuffer = {
            usage: this._usage,
            memUsage: this._memUsage,
            size: this._size,
            stride: this._stride,
            buffer: null,
            indirects: new je(),
            glTarget: 0,
            glBuffer: null,
            glOffset: 0
          }, function (e, t) {
            var r = e.gl,
                s = e.stateCache,
                a = t.memUsage & l.HOST ? r.DYNAMIC_DRAW : r.STATIC_DRAW;

            if (t.usage & c.VERTEX) {
              t.glTarget = r.ARRAY_BUFFER;
              var n = r.createBuffer();
              n && (t.glBuffer = n, t.size > 0 && (e.extensions.useVAO && s.glVAO && (r.bindVertexArray(null), s.glVAO = null), Ve.gpuInputAssembler = null, e.stateCache.glArrayBuffer !== t.glBuffer && (r.bindBuffer(r.ARRAY_BUFFER, t.glBuffer), e.stateCache.glArrayBuffer = t.glBuffer), r.bufferData(r.ARRAY_BUFFER, t.size, a), r.bindBuffer(r.ARRAY_BUFFER, null), e.stateCache.glArrayBuffer = null));
            } else if (t.usage & c.INDEX) {
              t.glTarget = r.ELEMENT_ARRAY_BUFFER;
              var i = r.createBuffer();
              i && (t.glBuffer = i, t.size > 0 && (e.extensions.useVAO && s.glVAO && (r.bindVertexArray(null), s.glVAO = null), Ve.gpuInputAssembler = null, e.stateCache.glElementArrayBuffer !== t.glBuffer && (r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, t.glBuffer), e.stateCache.glElementArrayBuffer = t.glBuffer), r.bufferData(r.ELEMENT_ARRAY_BUFFER, t.size, a), r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, null), e.stateCache.glElementArrayBuffer = null));
            } else if (t.usage & c.UNIFORM) {
              t.glTarget = r.UNIFORM_BUFFER;
              var u = r.createBuffer();
              u && t.size > 0 && (t.glBuffer = u, e.stateCache.glUniformBuffer !== t.glBuffer && (r.bindBuffer(r.UNIFORM_BUFFER, t.glBuffer), e.stateCache.glUniformBuffer = t.glBuffer), r.bufferData(r.UNIFORM_BUFFER, t.size, a), r.bindBuffer(r.UNIFORM_BUFFER, null), e.stateCache.glUniformBuffer = null);
            } else t.usage & c.INDIRECT || t.usage & c.TRANSFER_DST || t.usage & c.TRANSFER_SRC || console.error("Unsupported BufferType, create buffer failed."), t.glTarget = r.NONE;
          }(de.instance, this._gpuBuffer), de.instance.memoryStatus.bufferSize += this._size;
        }, s.destroy = function () {
          this._gpuBuffer && (this._isBufferView || (function (e, t) {
            var r = e.gl,
                s = e.stateCache;

            if (t.glBuffer) {
              switch (t.glTarget) {
                case r.ARRAY_BUFFER:
                  e.extensions.useVAO && s.glVAO && (r.bindVertexArray(null), e.stateCache.glVAO = null), Ve.gpuInputAssembler = null, r.bindBuffer(r.ARRAY_BUFFER, null), e.stateCache.glArrayBuffer = null;
                  break;

                case r.ELEMENT_ARRAY_BUFFER:
                  e.extensions.useVAO && s.glVAO && (r.bindVertexArray(null), e.stateCache.glVAO = null), Ve.gpuInputAssembler = null, r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, null), e.stateCache.glElementArrayBuffer = null;
                  break;

                case r.UNIFORM_BUFFER:
                  r.bindBuffer(r.UNIFORM_BUFFER, null), e.stateCache.glUniformBuffer = null;
              }

              r.deleteBuffer(t.glBuffer), t.glBuffer = null;
            }
          }(de.instance, this._gpuBuffer), de.instance.memoryStatus.bufferSize -= this._size), this._gpuBuffer = null);
        }, s.resize = function (e) {
          if (this._isBufferView) console.warn("cannot resize buffer views!");else {
            var t,
                r,
                s,
                a,
                n,
                i = this._size;
            i !== e && (this._size = e, this._count = this._size / this._stride, this._gpuBuffer && (this._gpuBuffer.size = e, e > 0 && (t = de.instance, r = this._gpuBuffer, s = t.gl, a = t.stateCache, n = r.memUsage & l.HOST ? s.DYNAMIC_DRAW : s.STATIC_DRAW, r.usage & c.VERTEX ? (t.extensions.useVAO && a.glVAO && (s.bindVertexArray(null), a.glVAO = null), Ve.gpuInputAssembler = null, a.glArrayBuffer !== r.glBuffer && s.bindBuffer(s.ARRAY_BUFFER, r.glBuffer), r.buffer ? s.bufferData(s.ARRAY_BUFFER, r.buffer, n) : s.bufferData(s.ARRAY_BUFFER, r.size, n), s.bindBuffer(s.ARRAY_BUFFER, null), a.glArrayBuffer = null) : r.usage & c.INDEX ? (t.extensions.useVAO && a.glVAO && (s.bindVertexArray(null), a.glVAO = null), Ve.gpuInputAssembler = null, t.stateCache.glElementArrayBuffer !== r.glBuffer && s.bindBuffer(s.ELEMENT_ARRAY_BUFFER, r.glBuffer), r.buffer ? s.bufferData(s.ELEMENT_ARRAY_BUFFER, r.buffer, n) : s.bufferData(s.ELEMENT_ARRAY_BUFFER, r.size, n), s.bindBuffer(s.ELEMENT_ARRAY_BUFFER, null), t.stateCache.glElementArrayBuffer = null) : r.usage & c.UNIFORM ? (t.stateCache.glUniformBuffer !== r.glBuffer && s.bindBuffer(s.UNIFORM_BUFFER, r.glBuffer), s.bufferData(s.UNIFORM_BUFFER, r.size, n), s.bindBuffer(s.UNIFORM_BUFFER, null), t.stateCache.glUniformBuffer = null) : (r.usage & c.INDIRECT || r.usage & c.TRANSFER_DST || r.usage & c.TRANSFER_SRC || console.error("Unsupported BufferType, create buffer failed."), r.glTarget = s.NONE), de.instance.memoryStatus.bufferSize -= i, de.instance.memoryStatus.bufferSize += e)));
          }
        }, s.update = function (e, t) {
          var r;
          this._isBufferView ? console.warn("cannot update through buffer views!") : (r = void 0 !== t ? t : this._usage & c.INDIRECT ? 0 : e.byteLength, He(de.instance, this._gpuBuffer, e, 0, r));
        }, a(r, [{
          key: "gpuBuffer",
          get: function get() {
            return this._gpuBuffer;
          }
        }]), r;
      }(I),
          $e = function () {
        function e(e, t) {
          this._frees = void 0, this._freeIdx = 0, this._freeCmds = void 0, this._frees = new Array(t), this._freeCmds = new F(t);

          for (var r = 0; r < t; ++r) {
            this._frees[r] = new e();
          }

          this._freeIdx = t - 1;
        }

        var t = e.prototype;
        return t.alloc = function (e) {
          if (this._freeIdx < 0) {
            var t = 2 * this._frees.length,
                r = this._frees;
            this._frees = new Array(t);

            for (var s = t - r.length, a = 0; a < s; ++a) {
              this._frees[a] = new e();
            }

            for (var n = s, i = 0; n < t; ++n, ++i) {
              this._frees[n] = r[i];
            }

            this._freeIdx += s;
          }

          var u = this._frees[this._freeIdx];
          return this._frees[this._freeIdx--] = null, ++u.refCount, u;
        }, t.free = function (e) {
          0 == --e.refCount && this._freeCmds.push(e);
        }, t.freeCmds = function (e) {
          for (var t = 0; t < e.length; ++t) {
            0 == --e.array[t].refCount && this._freeCmds.push(e.array[t]);
          }
        }, t.release = function () {
          for (var e = 0; e < this._freeCmds.length; ++e) {
            var t = this._freeCmds.array[e];
            t.clear(), this._frees[++this._freeIdx] = t;
          }

          this._freeCmds.clear();
        }, e;
      }(),
          Je = function () {
        function e() {
          this.beginRenderPassCmdPool = void 0, this.bindStatesCmdPool = void 0, this.drawCmdPool = void 0, this.updateBufferCmdPool = void 0, this.copyBufferToTextureCmdPool = void 0, this.beginRenderPassCmdPool = new $e(ve, 1), this.bindStatesCmdPool = new $e(Le, 1), this.drawCmdPool = new $e(Ue, 1), this.updateBufferCmdPool = new $e(Ne, 1), this.copyBufferToTextureCmdPool = new $e(ye, 1);
        }

        var t = e.prototype;
        return t.clearCmds = function (e) {
          e.beginRenderPassCmds.length && (this.beginRenderPassCmdPool.freeCmds(e.beginRenderPassCmds), e.beginRenderPassCmds.clear()), e.bindStatesCmds.length && (this.bindStatesCmdPool.freeCmds(e.bindStatesCmds), e.bindStatesCmds.clear()), e.drawCmds.length && (this.drawCmdPool.freeCmds(e.drawCmds), e.drawCmds.clear()), e.updateBufferCmds.length && (this.updateBufferCmdPool.freeCmds(e.updateBufferCmds), e.updateBufferCmds.clear()), e.copyBufferToTextureCmds.length && (this.copyBufferToTextureCmdPool.freeCmds(e.copyBufferToTextureCmds), e.copyBufferToTextureCmds.clear()), e.cmds.clear();
        }, t.releaseCmds = function () {
          this.beginRenderPassCmdPool.release(), this.bindStatesCmdPool.release(), this.drawCmdPool.release(), this.updateBufferCmdPool.release(), this.copyBufferToTextureCmdPool.release();
        }, e;
      }(),
          et = function (e) {
        function r() {
          for (var t, r = arguments.length, s = new Array(r), a = 0; a < r; a++) {
            s[a] = arguments[a];
          }

          return (t = e.call.apply(e, [this].concat(s)) || this).cmdPackage = new we(), t._cmdAllocator = new Je(), t._isInRenderPass = !1, t._curGPUPipelineState = null, t._curGPUDescriptorSets = [], t._curGPUInputAssembler = null, t._curDynamicOffsets = Array(8).fill(0), t._curDynamicStates = new u(), t._isStateInvalied = !1, t;
        }

        t(r, e);
        var s = r.prototype;
        return s.initialize = function (e) {
          this._type = e.type, this._queue = e.queue;

          for (var t = de.instance.bindingMappings.blockOffsets.length, r = 0; r < t; r++) {
            this._curGPUDescriptorSets.push(null);
          }
        }, s.destroy = function () {
          this._cmdAllocator.clearCmds(this.cmdPackage);
        }, s.begin = function () {
          this._cmdAllocator.clearCmds(this.cmdPackage), this._curGPUPipelineState = null, this._curGPUInputAssembler = null, this._curGPUDescriptorSets.length = 0, this._numDrawCalls = 0, this._numInstances = 0, this._numTris = 0;
        }, s.end = function () {
          this._isStateInvalied && this.bindStates(), this._isInRenderPass = !1;
        }, s.beginRenderPass = function (e, t, r, s, a, n) {
          var i = this._cmdAllocator.beginRenderPassCmdPool.alloc(ve);

          i.gpuRenderPass = e.gpuRenderPass, i.gpuFramebuffer = t.gpuFramebuffer, i.renderArea.copy(r);

          for (var u = 0; u < s.length; ++u) {
            i.clearColors[u] = s[u];
          }

          i.clearDepth = a, i.clearStencil = n, this.cmdPackage.beginRenderPassCmds.push(i), this.cmdPackage.cmds.push(Fe.BEGIN_RENDER_PASS), this._isInRenderPass = !0;
        }, s.endRenderPass = function () {
          this._isInRenderPass = !1;
        }, s.bindPipelineState = function (e) {
          var t = e.gpuPipelineState;
          t !== this._curGPUPipelineState && (this._curGPUPipelineState = t, this._isStateInvalied = !0);
        }, s.bindDescriptorSet = function (e, t, r) {
          var s = t.gpuDescriptorSet;

          if (s !== this._curGPUDescriptorSets[e] && (this._curGPUDescriptorSets[e] = s, this._isStateInvalied = !0), r) {
            var a,
                n = null === (a = this._curGPUPipelineState) || void 0 === a ? void 0 : a.gpuPipelineLayout;

            if (n) {
              for (var i = this._curDynamicOffsets, u = n.dynamicOffsetOffsets[e], _ = 0; _ < r.length; _++) {
                i[u + _] = r[_];
              }

              this._isStateInvalied = !0;
            }
          }
        }, s.bindInputAssembler = function (e) {
          var t = e.gpuInputAssembler;
          this._curGPUInputAssembler = t, this._isStateInvalied = !0;
        }, s.setViewport = function (e) {
          var t = this._curDynamicStates.viewport;
          t.left === e.left && t.top === e.top && t.width === e.width && t.height === e.height && t.minDepth === e.minDepth && t.maxDepth === e.maxDepth || (t.left = e.left, t.top = e.top, t.width = e.width, t.height = e.height, t.minDepth = e.minDepth, t.maxDepth = e.maxDepth, this._isStateInvalied = !0);
        }, s.setScissor = function (e) {
          var t = this._curDynamicStates.scissor;
          t.x === e.x && t.y === e.y && t.width === e.width && t.height === e.height || (t.x = e.x, t.y = e.y, t.width = e.width, t.height = e.height, this._isStateInvalied = !0);
        }, s.setLineWidth = function (e) {
          this._curDynamicStates.lineWidth !== e && (this._curDynamicStates.lineWidth = e, this._isStateInvalied = !0);
        }, s.setDepthBias = function (e, t, r) {
          var s = this._curDynamicStates;
          s.depthBiasConstant === e && s.depthBiasClamp === t && s.depthBiasSlope === r || (s.depthBiasConstant = e, s.depthBiasClamp = t, s.depthBiasSlope = r, this._isStateInvalied = !0);
        }, s.setBlendConstants = function (e) {
          var t = this._curDynamicStates.blendConstant;
          t.x === e.x && t.y === e.y && t.z === e.z && t.w === e.w || (t.copy(e), this._isStateInvalied = !0);
        }, s.setDepthBound = function (e, t) {
          var r = this._curDynamicStates;
          r.depthMinBounds === e && r.depthMaxBounds === t || (r.depthMinBounds = e, r.depthMaxBounds = t, this._isStateInvalied = !0);
        }, s.setStencilWriteMask = function (e, t) {
          var r = this._curDynamicStates.stencilStatesFront,
              s = this._curDynamicStates.stencilStatesBack;
          e & O.FRONT && r.writeMask !== t && (r.writeMask = t, this._isStateInvalied = !0), e & O.BACK && s.writeMask !== t && (s.writeMask = t, this._isStateInvalied = !0);
        }, s.setStencilCompareMask = function (e, t, r) {
          var s = this._curDynamicStates.stencilStatesFront,
              a = this._curDynamicStates.stencilStatesBack;
          e & O.FRONT && (s.compareMask === r && s.reference === t || (s.reference = t, s.compareMask = r, this._isStateInvalied = !0)), e & O.BACK && (a.compareMask === r && a.reference === t || (a.reference = t, a.compareMask = r, this._isStateInvalied = !0));
        }, s.draw = function (e) {
          if (this._type === M.PRIMARY && this._isInRenderPass || this._type === M.SECONDARY) {
            this._isStateInvalied && this.bindStates();

            var t = "drawInfo" in e ? e.drawInfo : e,
                r = this._cmdAllocator.drawCmdPool.alloc(Ue);

            r.drawInfo.copy(t), this.cmdPackage.drawCmds.push(r), this.cmdPackage.cmds.push(Fe.DRAW), ++this._numDrawCalls, this._numInstances += t.instanceCount;
            var s = t.indexCount || t.vertexCount;
            if (this._curGPUPipelineState) switch (this._curGPUPipelineState.glPrimitive) {
              case 4:
                this._numTris += s / 3 * Math.max(t.instanceCount, 1);
                break;

              case 5:
              case 6:
                this._numTris += (s - 2) * Math.max(t.instanceCount, 1);
            }
          } else console.error("Command 'draw' must be recorded inside a render pass.");
        }, s.updateBuffer = function (e, t, r) {
          if (this._type === M.PRIMARY && !this._isInRenderPass || this._type === M.SECONDARY) {
            var s = e.gpuBuffer;

            if (s) {
              var a,
                  n = this._cmdAllocator.updateBufferCmdPool.alloc(Ne),
                  i = 0;

              e.usage & c.INDIRECT || (i = void 0 !== r ? r : t.byteLength), a = t, n.gpuBuffer = s, n.buffer = a, n.offset = 0, n.size = i, this.cmdPackage.updateBufferCmds.push(n), this.cmdPackage.cmds.push(Fe.UPDATE_BUFFER);
            }
          } else console.error("Command 'updateBuffer' must be recorded outside a render pass.");
        }, s.copyBuffersToTexture = function (e, t, r) {
          if (this._type === M.PRIMARY && !this._isInRenderPass || this._type === M.SECONDARY) {
            var s = t.gpuTexture;

            if (s) {
              var a = this._cmdAllocator.copyBufferToTextureCmdPool.alloc(ye);

              a.gpuTexture = s, a.regions = r, a.buffers = e, this.cmdPackage.copyBufferToTextureCmds.push(a), this.cmdPackage.cmds.push(Fe.COPY_BUFFER_TO_TEXTURE);
            }
          } else console.error("Command 'copyBufferToTexture' must be recorded outside a render pass.");
        }, s.execute = function (e, t) {
          for (var r = 0; r < t; ++r) {
            for (var s = e[r], a = 0; a < s.cmdPackage.beginRenderPassCmds.length; ++a) {
              var n = s.cmdPackage.beginRenderPassCmds.array[a];
              ++n.refCount, this.cmdPackage.beginRenderPassCmds.push(n);
            }

            for (var i = 0; i < s.cmdPackage.bindStatesCmds.length; ++i) {
              var u = s.cmdPackage.bindStatesCmds.array[i];
              ++u.refCount, this.cmdPackage.bindStatesCmds.push(u);
            }

            for (var _ = 0; _ < s.cmdPackage.drawCmds.length; ++_) {
              var l = s.cmdPackage.drawCmds.array[_];
              ++l.refCount, this.cmdPackage.drawCmds.push(l);
            }

            for (var c = 0; c < s.cmdPackage.updateBufferCmds.length; ++c) {
              var o = s.cmdPackage.updateBufferCmds.array[c];
              ++o.refCount, this.cmdPackage.updateBufferCmds.push(o);
            }

            for (var f = 0; f < s.cmdPackage.copyBufferToTextureCmds.length; ++f) {
              var R = s.cmdPackage.copyBufferToTextureCmds.array[f];
              ++R.refCount, this.cmdPackage.copyBufferToTextureCmds.push(R);
            }

            this.cmdPackage.cmds.concat(s.cmdPackage.cmds.array), this._numDrawCalls += s._numDrawCalls, this._numInstances += s._numInstances, this._numTris += s._numTris;
          }
        }, s.pipelineBarrier = function () {}, s.bindStates = function () {
          var e = this._cmdAllocator.bindStatesCmdPool.alloc(Le);

          e.gpuPipelineState = this._curGPUPipelineState, Array.prototype.push.apply(e.gpuDescriptorSets, this._curGPUDescriptorSets), Array.prototype.push.apply(e.dynamicOffsets, this._curDynamicOffsets), e.gpuInputAssembler = this._curGPUInputAssembler, e.dynamicStates = this._curDynamicStates, this.cmdPackage.bindStatesCmds.push(e), this.cmdPackage.cmds.push(Fe.BIND_STATES), this._isStateInvalied = !1;
        }, r;
      }(D),
          tt = function (e) {
        function r() {
          for (var t, r = arguments.length, s = new Array(r), a = 0; a < r; a++) {
            s[a] = arguments[a];
          }

          return (t = e.call.apply(e, [this].concat(s)) || this)._gpuFramebuffer = null, t;
        }

        t(r, e);
        var s = r.prototype;
        return s.initialize = function (e) {
          this._renderPass = e.renderPass, this._colorTextures = e.colorTextures || [], this._depthStencilTexture = e.depthStencilTexture || null;

          for (var t = [], r = 0; r < e.colorTextures.length; r++) {
            var s = e.colorTextures[r];
            s && t.push(s.gpuTextureView);
          }

          var a = null;
          e.depthStencilTexture && (a = e.depthStencilTexture.gpuTextureView);
          var n = Number.MAX_SAFE_INTEGER;
          this._gpuFramebuffer = {
            gpuRenderPass: e.renderPass.gpuRenderPass,
            gpuColorViews: t,
            gpuDepthStencilView: a,
            glFramebuffer: null,
            isOffscreen: !0,

            get width() {
              return this.isOffscreen ? n : this.gpuColorViews.length > 0 ? this.gpuColorViews[0].gpuTexture.width : this.gpuDepthStencilView.gpuTexture.width;
            },

            set width(e) {
              n = e;
            },

            get height() {
              return this.isOffscreen ? n : this.gpuColorViews.length > 0 ? this.gpuColorViews[0].gpuTexture.height : this.gpuDepthStencilView.gpuTexture.height;
            },

            set height(e) {}

          }, function (e, t) {
            for (var r = 0; r < t.gpuColorViews.length; ++r) {
              if (t.gpuColorViews[r].gpuTexture.isSwapchainTexture) return void (t.isOffscreen = !1);
            }

            var s = e.gl,
                a = [],
                n = s.createFramebuffer();

            if (n) {
              t.glFramebuffer = n, e.stateCache.glFramebuffer !== t.glFramebuffer && s.bindFramebuffer(s.FRAMEBUFFER, t.glFramebuffer);

              for (var i = 0; i < t.gpuColorViews.length; ++i) {
                var u = t.gpuColorViews[i],
                    _ = u.gpuTexture;
                _ && (_.glTexture ? s.framebufferTexture2D(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0 + i, _.glTarget, _.glTexture, u.baseLevel) : s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0 + i, s.RENDERBUFFER, _.glRenderbuffer), a.push(s.COLOR_ATTACHMENT0 + i), t.width = Math.min(t.width, _.width >> u.baseLevel), t.height = Math.min(t.height, _.height >> u.baseLevel));
              }

              var l = t.gpuDepthStencilView;

              if (l) {
                var c = l.gpuTexture,
                    o = R[c.format].hasStencil ? s.DEPTH_STENCIL_ATTACHMENT : s.DEPTH_ATTACHMENT;
                c.glTexture ? s.framebufferTexture2D(s.FRAMEBUFFER, o, c.glTarget, c.glTexture, t.gpuDepthStencilView.baseLevel) : s.framebufferRenderbuffer(s.FRAMEBUFFER, o, s.RENDERBUFFER, c.glRenderbuffer), t.width = Math.min(t.width, c.width >> l.baseLevel), t.height = Math.min(t.height, c.height >> l.baseLevel);
              }

              s.drawBuffers(a);
              var f = s.checkFramebufferStatus(s.FRAMEBUFFER);
              if (f !== s.FRAMEBUFFER_COMPLETE) switch (f) {
                case s.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
                  console.error("glCheckFramebufferStatus() - FRAMEBUFFER_INCOMPLETE_ATTACHMENT");
                  break;

                case s.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
                  console.error("glCheckFramebufferStatus() - FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT");
                  break;

                case s.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
                  console.error("glCheckFramebufferStatus() - FRAMEBUFFER_INCOMPLETE_DIMENSIONS");
                  break;

                case s.FRAMEBUFFER_UNSUPPORTED:
                  console.error("glCheckFramebufferStatus() - FRAMEBUFFER_UNSUPPORTED");
              }
              e.stateCache.glFramebuffer !== t.glFramebuffer && s.bindFramebuffer(s.FRAMEBUFFER, e.stateCache.glFramebuffer);
            }
          }(de.instance, this._gpuFramebuffer);
        }, s.destroy = function () {
          var e, t;
          this._gpuFramebuffer && (e = de.instance, (t = this._gpuFramebuffer).glFramebuffer && (e.gl.deleteFramebuffer(t.glFramebuffer), e.stateCache.glFramebuffer === t.glFramebuffer && (e.gl.bindFramebuffer(e.gl.FRAMEBUFFER, null), e.stateCache.glFramebuffer = null), t.glFramebuffer = null), this._gpuFramebuffer = null);
        }, a(r, [{
          key: "gpuFramebuffer",
          get: function get() {
            return this._gpuFramebuffer;
          }
        }]), r;
      }(v),
          rt = function (e) {
        function r() {
          for (var t, r = arguments.length, s = new Array(r), a = 0; a < r; a++) {
            s[a] = arguments[a];
          }

          return (t = e.call.apply(e, [this].concat(s)) || this)._gpuInputAssembler = null, t;
        }

        t(r, e);
        var s = r.prototype;
        return s.initialize = function (e) {
          if (0 !== e.vertexBuffers.length) {
            if (this._attributes = e.attributes, this._attributesHash = this.computeAttributesHash(), this._vertexBuffers = e.vertexBuffers, e.indexBuffer) this._indexBuffer = e.indexBuffer, this._drawInfo.indexCount = this._indexBuffer.size / this._indexBuffer.stride, this._drawInfo.firstIndex = 0;else {
              var t = this._vertexBuffers[0];
              this._drawInfo.vertexCount = t.size / t.stride, this._drawInfo.firstVertex = 0, this._drawInfo.vertexOffset = 0;
            }
            this._drawInfo.instanceCount = 0, this._drawInfo.firstInstance = 0, this._indirectBuffer = e.indirectBuffer || null;

            for (var r = new Array(e.vertexBuffers.length), s = 0; s < e.vertexBuffers.length; ++s) {
              var a = e.vertexBuffers[s];
              a.gpuBuffer && (r[s] = a.gpuBuffer);
            }

            var n = null,
                i = 0;
            if (e.indexBuffer && (n = e.indexBuffer.gpuBuffer)) switch (n.stride) {
              case 1:
                i = 5121;
                break;

              case 2:
                i = 5123;
                break;

              case 4:
                i = 5125;
                break;

              default:
                console.error("Illegal index buffer stride.");
            }
            var u = null;
            e.indirectBuffer && (u = e.indirectBuffer.gpuBuffer), this._gpuInputAssembler = {
              attributes: e.attributes,
              gpuVertexBuffers: r,
              gpuIndexBuffer: n,
              gpuIndirectBuffer: u,
              glAttribs: [],
              glIndexType: i,
              glVAOs: new Map()
            }, function (e, t) {
              var r = e.gl;
              t.glAttribs = new Array(t.attributes.length);

              for (var s = [0, 0, 0, 0, 0, 0, 0, 0], a = 0; a < t.attributes.length; ++a) {
                var n = t.attributes[a],
                    i = void 0 !== n.stream ? n.stream : 0,
                    u = t.gpuVertexBuffers[i],
                    _ = pe(n.format, r),
                    l = R[n.format].size;

                t.glAttribs[a] = {
                  name: n.name,
                  glBuffer: u.glBuffer,
                  glType: _,
                  size: l,
                  count: R[n.format].count,
                  stride: u.stride,
                  componentCount: Pe(_, r),
                  isNormalized: void 0 !== n.isNormalized && n.isNormalized,
                  isInstanced: void 0 !== n.isInstanced && n.isInstanced,
                  offset: s[i]
                }, s[i] += l;
              }
            }(de.instance, this._gpuInputAssembler);
          } else console.error("InputAssemblerInfo.vertexBuffers is null.");
        }, s.destroy = function () {
          var e = de.instance;
          this._gpuInputAssembler && e.extensions.useVAO && function (e, t) {
            for (var r = t.glVAOs.values(), s = r.next(), a = e.gl, n = e.stateCache.glVAO; !s.done;) {
              a.deleteVertexArray(s.value), n === s.value && (a.bindVertexArray(null), n = null), s = r.next();
            }

            e.stateCache.glVAO = n, t.glVAOs.clear();
          }(e, this._gpuInputAssembler), this._gpuInputAssembler = null;
        }, a(r, [{
          key: "gpuInputAssembler",
          get: function get() {
            return this._gpuInputAssembler;
          }
        }]), r;
      }(L),
          st = function (e) {
        function r() {
          for (var t, r = arguments.length, s = new Array(r), a = 0; a < r; a++) {
            s[a] = arguments[a];
          }

          return (t = e.call.apply(e, [this].concat(s)) || this)._gpuDescriptorSetLayout = null, t;
        }

        t(r, e);
        var s = r.prototype;
        return s.initialize = function (e) {
          Array.prototype.push.apply(this._bindings, e.bindings);

          for (var t = 0, r = -1, s = [], a = 0; a < this._bindings.length; a++) {
            var n = this._bindings[a];
            s.push(t), t += n.count, n.binding > r && (r = n.binding);
          }

          this._bindingIndices = Array(r + 1).fill(-1);

          for (var i = this._descriptorIndices = Array(r + 1).fill(-1), u = 0; u < this._bindings.length; u++) {
            var _ = this._bindings[u];
            this._bindingIndices[_.binding] = u, i[_.binding] = s[u];
          }

          for (var l = [], c = 0; c < this._bindings.length; c++) {
            var o = this._bindings[c];
            if (o.descriptorType & U) for (var f = 0; f < o.count; f++) {
              l.push(o.binding);
            }
          }

          this._gpuDescriptorSetLayout = {
            bindings: this._bindings,
            dynamicBindings: l,
            descriptorIndices: i,
            descriptorCount: t
          };
        }, s.destroy = function () {
          this._bindings.length = 0;
        }, a(r, [{
          key: "gpuDescriptorSetLayout",
          get: function get() {
            return this._gpuDescriptorSetLayout;
          }
        }]), r;
      }(N),
          at = function (e) {
        function r() {
          for (var t, r = arguments.length, s = new Array(r), a = 0; a < r; a++) {
            s[a] = arguments[a];
          }

          return (t = e.call.apply(e, [this].concat(s)) || this)._gpuPipelineLayout = null, t;
        }

        t(r, e);
        var s = r.prototype;
        return s.initialize = function (e) {
          Array.prototype.push.apply(this._setLayouts, e.setLayouts);

          for (var t = [], r = [], s = 0, a = [], n = 0; n < this._setLayouts.length; n++) {
            for (var i = this._setLayouts[n], u = i.gpuDescriptorSetLayout.dynamicBindings, _ = Array(i.bindingIndices.length).fill(-1), l = 0; l < u.length; l++) {
              var c = u[l];
              _[c] < 0 && (_[c] = s + l);
            }

            r.push(i.gpuDescriptorSetLayout), t.push(_), a.push(s), s += u.length;
          }

          this._gpuPipelineLayout = {
            gpuSetLayouts: r,
            dynamicOffsetIndices: t,
            dynamicOffsetCount: s,
            dynamicOffsetOffsets: a
          };
        }, s.destroy = function () {
          this._setLayouts.length = 0;
        }, a(r, [{
          key: "gpuPipelineLayout",
          get: function get() {
            return this._gpuPipelineLayout;
          }
        }]), r;
      }(y),
          nt = [0, 1, 3, 2, 0, 0, 0, 4, 5, 6, 0, 0, 0, 0],
          it = function (e) {
        function r() {
          for (var t, r = arguments.length, s = new Array(r), a = 0; a < r; a++) {
            s[a] = arguments[a];
          }

          return (t = e.call.apply(e, [this].concat(s)) || this)._gpuPipelineState = null, t;
        }

        t(r, e);
        var s = r.prototype;
        return s.initialize = function (e) {
          this._primitive = e.primitive, this._shader = e.shader, this._pipelineLayout = e.pipelineLayout;
          var t = this._bs;

          if (e.blendState) {
            var r = e.blendState,
                s = r.targets;
            s && s.forEach(function (e, r) {
              t.setTarget(r, e);
            }), void 0 !== r.isA2C && (t.isA2C = r.isA2C), void 0 !== r.isIndepend && (t.isIndepend = r.isIndepend), void 0 !== r.blendColor && (t.blendColor = r.blendColor);
          }

          Object.assign(this._rs, e.rasterizerState), Object.assign(this._dss, e.depthStencilState), this._is = e.inputState, this._renderPass = e.renderPass, this._dynamicStates = e.dynamicStates;

          for (var a = [], n = 0; n < 31; n++) {
            this._dynamicStates & 1 << n && a.push(1 << n);
          }

          this._gpuPipelineState = {
            glPrimitive: nt[e.primitive],
            gpuShader: e.shader.gpuShader,
            gpuPipelineLayout: e.pipelineLayout.gpuPipelineLayout,
            rs: e.rasterizerState,
            dss: e.depthStencilState,
            bs: e.blendState,
            gpuRenderPass: e.renderPass.gpuRenderPass,
            dynamicStates: a
          };
        }, s.destroy = function () {
          this._gpuPipelineState = null;
        }, a(r, [{
          key: "gpuPipelineState",
          get: function get() {
            return this._gpuPipelineState;
          }
        }]), r;
      }(w),
          ut = function (e) {
        function r() {
          return e.apply(this, arguments) || this;
        }

        t(r, e);
        var s = r.prototype;
        return s.beginRenderPass = function (e, t, r, s, a, n) {
          Ke(de.instance, e.gpuRenderPass, t.gpuFramebuffer, r, s, a, n), this._isInRenderPass = !0;
        }, s.draw = function (e) {
          if (this._isInRenderPass) {
            this._isStateInvalied && this.bindStates();
            var t = "drawInfo" in e ? e.drawInfo : e;
            ze(de.instance, t), ++this._numDrawCalls, this._numInstances += t.instanceCount;
            var r = t.indexCount || t.vertexCount;
            if (this._curGPUPipelineState) switch (this._curGPUPipelineState.glPrimitive) {
              case 4:
                this._numTris += r / 3 * Math.max(t.instanceCount, 1);
                break;

              case 5:
              case 6:
                this._numTris += (r - 2) * Math.max(t.instanceCount, 1);
            }
          } else console.error("Command 'draw' must be recorded inside a render pass.");
        }, s.setViewport = function (e) {
          var t = de.instance,
              r = t.stateCache,
              s = t.gl;
          r.viewport.left === e.left && r.viewport.top === e.top && r.viewport.width === e.width && r.viewport.height === e.height || (s.viewport(e.left, e.top, e.width, e.height), r.viewport.left = e.left, r.viewport.top = e.top, r.viewport.width = e.width, r.viewport.height = e.height);
        }, s.setScissor = function (e) {
          var t = de.instance,
              r = t.stateCache,
              s = t.gl;
          r.scissorRect.x === e.x && r.scissorRect.y === e.y && r.scissorRect.width === e.width && r.scissorRect.height === e.height || (s.scissor(e.x, e.y, e.width, e.height), r.scissorRect.x = e.x, r.scissorRect.y = e.y, r.scissorRect.width = e.width, r.scissorRect.height = e.height);
        }, s.updateBuffer = function (e, t, r) {
          if (this._isInRenderPass) console.error("Command 'updateBuffer' must be recorded outside a render pass.");else {
            var s,
                a = e.gpuBuffer;
            a && (s = void 0 !== r ? r : e.usage & c.INDIRECT ? 0 : t.byteLength, He(de.instance, a, t, 0, s));
          }
        }, s.copyBuffersToTexture = function (e, t, r) {
          if (this._isInRenderPass) console.error("Command 'copyBufferToTexture' must be recorded outside a render pass.");else {
            var s = t.gpuTexture;
            s && Ze(de.instance, e, s, r);
          }
        }, s.execute = function (e, t) {
          for (var r = 0; r < t; ++r) {
            var s = e[r];
            qe(de.instance, s.cmdPackage), this._numDrawCalls += s._numDrawCalls, this._numInstances += s._numInstances, this._numTris += s._numTris;
          }
        }, s.bindStates = function () {
          We(de.instance, this._curGPUPipelineState, this._curGPUInputAssembler, this._curGPUDescriptorSets, this._curDynamicOffsets, this._curDynamicStates), this._isStateInvalied = !1;
        }, r;
      }(et),
          _t = function (e) {
        function r() {
          for (var t, r = arguments.length, s = new Array(r), a = 0; a < r; a++) {
            s[a] = arguments[a];
          }

          return (t = e.call.apply(e, [this].concat(s)) || this).numDrawCalls = 0, t.numInstances = 0, t.numTris = 0, t;
        }

        t(r, e);
        var s = r.prototype;
        return s.initialize = function (e) {
          this._type = e.type;
        }, s.destroy = function () {}, s.submit = function (e) {
          for (var t = 0; t < e.length; t++) {
            var r = e[t];
            this.numDrawCalls += r.numDrawCalls, this.numInstances += r.numInstances, this.numTris += r.numTris;
          }
        }, s.clear = function () {
          this.numDrawCalls = 0, this.numInstances = 0, this.numTris = 0;
        }, r;
      }(H),
          lt = function (e) {
        function r() {
          for (var t, r = arguments.length, s = new Array(r), a = 0; a < r; a++) {
            s[a] = arguments[a];
          }

          return (t = e.call.apply(e, [this].concat(s)) || this)._gpuRenderPass = null, t;
        }

        t(r, e);
        var s = r.prototype;
        return s.initialize = function (e) {
          this._colorInfos = e.colorAttachments, this._depthStencilInfo = e.depthStencilAttachment, this._subpasses = e.subpasses, this._gpuRenderPass = {
            colorAttachments: this._colorInfos,
            depthStencilAttachment: this._depthStencilInfo
          }, this._hash = this.computeHash();
        }, s.destroy = function () {
          this._gpuRenderPass = null;
        }, a(r, [{
          key: "gpuRenderPass",
          get: function get() {
            return this._gpuRenderPass;
          }
        }]), r;
      }(X),
          ct = function (e) {
        function r(t, r) {
          var s, a, n, i;
          return (s = e.call(this, t, r) || this)._gpuSampler = null, s._gpuSampler = {
            glSamplers: new Map(),
            minFilter: s._info.minFilter,
            magFilter: s._info.magFilter,
            mipFilter: s._info.mipFilter,
            addressU: s._info.addressU,
            addressV: s._info.addressV,
            addressW: s._info.addressW,
            glMinFilter: 0,
            glMagFilter: 0,
            glWrapS: 0,
            glWrapT: 0,
            glWrapR: 0,
            getGLSampler: function getGLSampler(e, t, r) {
              var s = e.gl,
                  a = t << 16 | r;

              if (!this.glSamplers.has(a)) {
                var n = s.createSampler();
                n && (this.glSamplers.set(a, n), s.samplerParameteri(n, s.TEXTURE_MIN_FILTER, this.glMinFilter), s.samplerParameteri(n, s.TEXTURE_MAG_FILTER, this.glMagFilter), s.samplerParameteri(n, s.TEXTURE_WRAP_S, this.glWrapS), s.samplerParameteri(n, s.TEXTURE_WRAP_T, this.glWrapT), s.samplerParameteri(n, s.TEXTURE_WRAP_R, this.glWrapR), s.samplerParameterf(n, s.TEXTURE_MIN_LOD, t), s.samplerParameterf(n, s.TEXTURE_MAX_LOD, r));
              }

              return this.glSamplers.get(a);
            }
          }, a = de.instance, n = s._gpuSampler, i = a.gl, n.minFilter === x.LINEAR || n.minFilter === x.ANISOTROPIC ? n.mipFilter === x.LINEAR || n.mipFilter === x.ANISOTROPIC ? n.glMinFilter = i.LINEAR_MIPMAP_LINEAR : n.mipFilter === x.POINT ? n.glMinFilter = i.LINEAR_MIPMAP_NEAREST : n.glMinFilter = i.LINEAR : n.mipFilter === x.LINEAR || n.mipFilter === x.ANISOTROPIC ? n.glMinFilter = i.NEAREST_MIPMAP_LINEAR : n.mipFilter === x.POINT ? n.glMinFilter = i.NEAREST_MIPMAP_NEAREST : n.glMinFilter = i.NEAREST, n.magFilter === x.LINEAR || n.magFilter === x.ANISOTROPIC ? n.glMagFilter = i.LINEAR : n.glMagFilter = i.NEAREST, n.glWrapS = Be[n.addressU], n.glWrapT = Be[n.addressV], n.glWrapR = Be[n.addressW], s;
        }

        return t(r, e), r.prototype.destroy = function () {
          this._gpuSampler && (function (e, t) {
            for (var r = e.gl, s = t.glSamplers.values().next(); !s.done;) {
              r.deleteSampler(s.value);

              for (var a = e.stateCache.glSamplerUnits, n = 0; n < a.length; ++n) {
                a[n] === s.value && (r.bindSampler(n, null), a[n] = null);
              }
            }

            t.glSamplers.clear();
          }(de.instance, this._gpuSampler), this._gpuSampler = null);
        }, a(r, [{
          key: "gpuSampler",
          get: function get() {
            return this._gpuSampler;
          }
        }]), r;
      }(k),
          ot = function (e) {
        function r() {
          for (var t, r = arguments.length, s = new Array(r), a = 0; a < r; a++) {
            s[a] = arguments[a];
          }

          return (t = e.call.apply(e, [this].concat(s)) || this)._gpuShader = null, t;
        }

        t(r, e);
        var s = r.prototype;
        return s.initialize = function (e) {
          this._name = e.name, this._stages = e.stages, this._attributes = e.attributes, this._blocks = e.blocks, this._samplers = e.samplers, this._gpuShader = {
            name: e.name,
            blocks: e.blocks.slice(),
            samplerTextures: e.samplerTextures.slice(),
            subpassInputs: e.subpassInputs.slice(),
            gpuStages: new Array(e.stages.length),
            glProgram: null,
            glInputs: [],
            glUniforms: [],
            glBlocks: [],
            glSamplerTextures: []
          };

          for (var t = 0; t < e.stages.length; ++t) {
            var r = e.stages[t];
            this._gpuShader.gpuStages[t] = {
              type: r.stage,
              source: r.source,
              glShader: null
            };
          }

          !function (e, t) {
            for (var r = e.gl, s = function s(e) {
              var s = t.gpuStages[e],
                  a = 0,
                  n = "",
                  i = 1;

              switch (s.type) {
                case P.VERTEX:
                  n = "VertexShader", a = r.VERTEX_SHADER;
                  break;

                case P.FRAGMENT:
                  n = "FragmentShader", a = r.FRAGMENT_SHADER;
                  break;

                default:
                  return console.error("Unsupported ShaderType."), {
                    v: void 0
                  };
              }

              var u = r.createShader(a);

              if (u && (s.glShader = u, r.shaderSource(s.glShader, "#version 300 es\n" + s.source), r.compileShader(s.glShader), !r.getShaderParameter(s.glShader, r.COMPILE_STATUS))) {
                console.error(n + " in '" + t.name + "' compilation failed."), console.error("Shader source dump:", s.source.replace(/^|\n/g, function () {
                  return "\n" + i++ + " ";
                })), console.error(r.getShaderInfoLog(s.glShader));

                for (var _ = 0; _ < t.gpuStages.length; _++) {
                  var l = t.gpuStages[e];
                  l.glShader && (r.deleteShader(l.glShader), l.glShader = null);
                }

                return {
                  v: void 0
                };
              }
            }, a = 0; a < t.gpuStages.length; a++) {
              var n = s(a);
              if ("object" == _typeof2(n)) return n.v;
            }

            var i = r.createProgram();

            if (i) {
              t.glProgram = i;

              for (var u = 0; u < t.gpuStages.length; u++) {
                var _ = t.gpuStages[u];
                r.attachShader(t.glProgram, _.glShader);
              }

              r.linkProgram(t.glProgram);

              for (var l = 0; l < t.gpuStages.length; l++) {
                var c = t.gpuStages[l];
                c.glShader && (r.detachShader(t.glProgram, c.glShader), r.deleteShader(c.glShader), c.glShader = null);
              }

              if (!r.getProgramParameter(t.glProgram, r.LINK_STATUS)) return console.error("Failed to link shader '" + t.name + "'."), void console.error(r.getProgramInfoLog(t.glProgram));
              h("Shader '" + t.name + "' compilation succeeded.");
              var o = r.getProgramParameter(t.glProgram, r.ACTIVE_ATTRIBUTES);
              t.glInputs = new Array(o);

              for (var f = 0; f < o; ++f) {
                var R = r.getActiveAttrib(t.glProgram, f);

                if (R) {
                  var A,
                      E = R.name.indexOf("[");
                  A = -1 !== E ? R.name.substr(0, E) : R.name;
                  var d = r.getAttribLocation(t.glProgram, A),
                      B = Ge(R.type, r),
                      C = xe(R.type, r);
                  t.glInputs[f] = {
                    name: A,
                    type: B,
                    stride: C,
                    count: R.size,
                    size: C * R.size,
                    glType: R.type,
                    glLoc: d
                  };
                }
              }

              var p,
                  m,
                  G,
                  x,
                  F = r.getProgramParameter(t.glProgram, r.ACTIVE_UNIFORM_BLOCKS);

              if (F) {
                t.glBlocks = new Array(F);

                for (var b = 0; b < F; ++b) {
                  var I = (p = r.getActiveUniformBlockName(t.glProgram, b)).indexOf("[");
                  -1 !== I && (p = p.substr(0, I)), x = null;

                  for (var O = 0; O < t.blocks.length; O++) {
                    if (t.blocks[O].name === p) {
                      x = t.blocks[O];
                      break;
                    }
                  }

                  if (x) {
                    m = b, G = r.getActiveUniformBlockParameter(t.glProgram, m, r.UNIFORM_BLOCK_DATA_SIZE);
                    var M = x.binding + (e.bindingMappings.blockOffsets[x.set] || 0);
                    r.uniformBlockBinding(t.glProgram, m, M), t.glBlocks[b] = {
                      set: x.set,
                      binding: x.binding,
                      idx: m,
                      name: p,
                      size: G,
                      glBinding: M
                    };
                  } else S("Block '" + p + "' does not bound");
                }
              }

              for (var D = 0; D < t.subpassInputs.length; ++D) {
                var v = t.subpassInputs[D];
                t.samplerTextures.push(new T(v.set, v.binding, v.name, g.SAMPLER2D, v.count));
              }

              if (t.samplerTextures.length > 0) {
                t.glSamplerTextures = new Array(t.samplerTextures.length);

                for (var L = 0; L < t.samplerTextures.length; ++L) {
                  var U = t.samplerTextures[L];
                  t.glSamplerTextures[L] = {
                    set: U.set,
                    binding: U.binding,
                    name: U.name,
                    type: U.type,
                    count: U.count,
                    units: [],
                    glUnits: null,
                    glType: me(U.type, r),
                    glLoc: null
                  };
                }
              }

              for (var N = [], y = [], w = e.stateCache.texUnitCacheMap, H = 0, X = 0; X < t.blocks.length; ++X) {
                t.blocks[X].set === e.bindingMappings.flexibleSet && H++;
              }

              for (var k = 0, V = 0; V < t.samplerTextures.length; ++V) {
                var K = t.samplerTextures[V],
                    W = r.getUniformLocation(t.glProgram, K.name);

                if (W && -1 !== W.id && (N.push(t.glSamplerTextures[V]), y.push(W)), void 0 === w[K.name]) {
                  var z = K.binding + e.bindingMappings.samplerTextureOffsets[K.set] + k;
                  K.set === e.bindingMappings.flexibleSet && (z -= H), w[K.name] = z % e.capabilities.maxTextureUnits, k += K.count - 1;
                }
              }

              if (N.length) {
                for (var Y = [], q = 0; q < N.length; ++q) {
                  var Z = N[q],
                      j = w[Z.name];

                  if (void 0 !== j) {
                    Z.glLoc = y[q];

                    for (var Q = 0; Q < Z.count; ++Q) {
                      for (; Y[j];) {
                        j = (j + 1) % e.capabilities.maxTextureUnits;
                      }

                      Z.units.push(j), Y[j] = !0;
                    }
                  }
                }

                for (var $ = 0, J = 0; J < N.length; ++J) {
                  var ee = N[J];

                  if (!ee.glLoc) {
                    for (ee.glLoc = y[J]; Y[$];) {
                      $++;
                    }

                    for (var te = 0; te < ee.count; ++te) {
                      for (; Y[$];) {
                        $ = ($ + 1) % e.capabilities.maxTextureUnits;
                      }

                      void 0 === w[ee.name] && (w[ee.name] = $), ee.units.push($), Y[$] = !0;
                    }
                  }
                }

                e.stateCache.glProgram !== t.glProgram && r.useProgram(t.glProgram);

                for (var re = 0; re < N.length; re++) {
                  var se = N[re];
                  se.glUnits = new Int32Array(se.units), r.uniform1iv(se.glLoc, se.glUnits);
                }

                e.stateCache.glProgram !== t.glProgram && r.useProgram(e.stateCache.glProgram);
              }

              t.glSamplerTextures = N;
            }
          }(de.instance, this._gpuShader);
        }, s.destroy = function () {
          var e, t;
          this._gpuShader && (e = de.instance, (t = this._gpuShader).glProgram && (e.gl.deleteProgram(t.glProgram), e.stateCache.glProgram === t.glProgram && (e.gl.useProgram(null), e.stateCache.glProgram = null), t.glProgram = null), this._gpuShader = null);
        }, a(r, [{
          key: "gpuShader",
          get: function get() {
            return this._gpuShader;
          }
        }]), r;
      }(V),
          ft = function () {
        function e() {
          this.glArrayBuffer = null, this.glElementArrayBuffer = null, this.glUniformBuffer = null, this.glBindUBOs = [], this.glBindUBOOffsets = [], this.glVAO = null, this.texUnit = 0, this.glTexUnits = [], this.glSamplerUnits = [], this.glRenderbuffer = null, this.glFramebuffer = null, this.glReadFramebuffer = null, this.viewport = new K(), this.scissorRect = new i(0, 0, 0, 0), this.rs = new W(), this.dss = new z(), this.bs = new Y(), this.glProgram = null, this.glEnabledAttribLocs = [], this.glCurrentAttribLocs = [], this.texUnitCacheMap = {};
        }

        return e.prototype.initialize = function (e, t, r) {
          for (var s = 0; s < e; ++s) {
            this.glTexUnits.push({
              glTexture: null
            });
          }

          this.glSamplerUnits.length = e, this.glSamplerUnits.fill(null), this.glBindUBOs.length = t, this.glBindUBOs.fill(null), this.glBindUBOOffsets.length = t, this.glBindUBOOffsets.fill(0), this.glEnabledAttribLocs.length = r, this.glEnabledAttribLocs.fill(!1), this.glCurrentAttribLocs.length = r, this.glCurrentAttribLocs.fill(!1);
        }, e;
      }(),
          Rt = function (e) {
        function r() {
          for (var t, r = arguments.length, s = new Array(r), a = 0; a < r; a++) {
            s[a] = arguments[a];
          }

          return (t = e.call.apply(e, [this].concat(s)) || this)._gpuTexture = null, t._gpuTextureView = null, t;
        }

        t(r, e);
        var s = r.prototype;
        return s.initialize = function (e, t) {
          var r = e,
              s = e;

          if ("texture" in e && (r = s.texture.info, this._isTextureView = !0), this._info.copy(r), this._isPowerOf2 = q(this._info.width) && q(this._info.height), this._size = Z(this._info.format, this.width, this.height, this.depth, this._info.levelCount) * this._info.layerCount, this._isTextureView) {
            var a;
            if (this._viewInfo.copy(s), this._gpuTexture = s.texture._gpuTexture, (null === (a = this._gpuTexture) || void 0 === a ? void 0 : a.format) !== r.format) return void console.log("GPU memory alias is not supported");
            this._gpuTextureView = {
              gpuTexture: this._gpuTexture,
              type: s.type,
              format: s.format,
              baseLevel: s.baseLevel,
              levelCount: s.levelCount
            };
          } else this._gpuTexture = {
            type: r.type,
            format: r.format,
            usage: r.usage,
            width: r.width,
            height: r.height,
            depth: r.depth,
            size: this._size,
            arrayLayer: r.layerCount,
            mipLevel: r.levelCount,
            samples: r.samples,
            flags: r.flags,
            isPowerOf2: this._isPowerOf2,
            glTarget: 0,
            glInternalFmt: 0,
            glFormat: 0,
            glType: 0,
            glUsage: 0,
            glTexture: null,
            glRenderbuffer: null,
            glWrapS: 0,
            glWrapT: 0,
            glMinFilter: 0,
            glMagFilter: 0,
            isSwapchainTexture: t || !1
          }, Xe(de.instance, this._gpuTexture), de.instance.memoryStatus.textureSize += this._size, this._viewInfo.texture = this, this._viewInfo.type = e.type, this._viewInfo.format = e.format, this._viewInfo.baseLevel = 0, this._viewInfo.levelCount = e.levelCount, this._viewInfo.baseLayer = 0, this._viewInfo.layerCount = e.layerCount, this._gpuTextureView = {
            gpuTexture: this._gpuTexture,
            type: this._viewInfo.type,
            format: this._viewInfo.format,
            baseLevel: this._viewInfo.baseLevel,
            levelCount: this._viewInfo.levelCount
          };
        }, s.destroy = function () {
          !this._isTextureView && this._gpuTexture && (ke(de.instance, this._gpuTexture), de.instance.memoryStatus.textureSize -= this._size, this._gpuTexture = null);
        }, s.resize = function (e, t) {
          if (this._info.width !== e || this._info.height !== t) {
            this._info.levelCount === r.getLevelCount(this._info.width, this._info.height) ? this._info.levelCount = r.getLevelCount(e, t) : this._info.levelCount > 1 && (this._info.levelCount = Math.min(this._info.levelCount, r.getLevelCount(e, t)));
            var s = this._size;
            this._info.width = e, this._info.height = t, this._size = Z(this._info.format, this.width, this.height, this.depth, this._info.levelCount) * this._info.layerCount, !this._isTextureView && this._gpuTexture && (this._gpuTexture.width = e, this._gpuTexture.height = t, this._gpuTexture.size = this._size, function (e, t) {
              if (t.size) {
                var r = e.gl,
                    s = t.width,
                    a = t.height;

                switch (t.type) {
                  case o.TEX2D:
                    t.glTarget = r.TEXTURE_2D;
                    var n = Math.max(s, a);

                    if (n > e.capabilities.maxTextureSize && f(9100, n, e.capabilities.maxTextureSize), t.samples === E.ONE) {
                      var i = e.stateCache.glTexUnits[e.stateCache.texUnit];
                      if (i.glTexture !== t.glTexture && (r.bindTexture(r.TEXTURE_2D, t.glTexture), i.glTexture = t.glTexture), R[t.format].isCompressed) for (var u = 0; u < t.mipLevel; ++u) {
                        var _ = A(t.format, s, a, 1),
                            l = new Uint8Array(_);

                        r.compressedTexImage2D(r.TEXTURE_2D, u, t.glInternalFmt, s, a, 0, l), s = Math.max(1, s >> 1), a = Math.max(1, a >> 1);
                      } else ke(e, t), Xe(e, t);
                    } else t.glRenderbuffer && (e.stateCache.glRenderbuffer !== t.glRenderbuffer && (r.bindRenderbuffer(r.RENDERBUFFER, t.glRenderbuffer), e.stateCache.glRenderbuffer = t.glRenderbuffer), r.renderbufferStorageMultisample(r.RENDERBUFFER, t.samples, t.glInternalFmt, t.width, t.height));

                    break;

                  case o.CUBE:
                    t.type = o.CUBE, t.glTarget = r.TEXTURE_CUBE_MAP;
                    var c = Math.max(s, a);
                    c > e.capabilities.maxCubeMapTextureSize && f(9100, c, e.capabilities.maxTextureSize);
                    var h = e.stateCache.glTexUnits[e.stateCache.texUnit];
                    if (h.glTexture !== t.glTexture && (r.bindTexture(r.TEXTURE_CUBE_MAP, t.glTexture), h.glTexture = t.glTexture), R[t.format].isCompressed) for (var S = 0; S < 6; ++S) {
                      s = t.width, a = t.height;

                      for (var T = 0; T < t.mipLevel; ++T) {
                        var g = A(t.format, s, a, 1),
                            d = new Uint8Array(g);
                        r.compressedTexImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + S, T, t.glInternalFmt, s, a, 0, d), s = Math.max(1, s >> 1), a = Math.max(1, a >> 1);
                      }
                    } else ke(e, t), Xe(e, t);
                    break;

                  default:
                    console.error("Unsupported TextureType, create texture failed."), t.type = o.TEX2D, t.glTarget = r.TEXTURE_2D;
                }
              }
            }(de.instance, this._gpuTexture), de.instance.memoryStatus.textureSize -= s, de.instance.memoryStatus.textureSize += this._size);
          }
        }, s.initAsSwapchainTexture = function (e) {
          var t = new j();
          t.format = e.format, t.usage = R[e.format].hasDepth ? Q.DEPTH_STENCIL_ATTACHMENT : Q.COLOR_ATTACHMENT, t.width = e.width, t.height = e.height, this.initialize(t, !0);
        }, a(r, [{
          key: "gpuTexture",
          get: function get() {
            return this._gpuTexture;
          }
        }, {
          key: "gpuTextureView",
          get: function get() {
            return this._gpuTextureView;
          }
        }]), r;
      }($),
          At = "webglcontextlost";

      function Et(e, t) {
        for (var r = ["", "WEBKIT_", "MOZ_"], s = 0; s < r.length; ++s) {
          var a = e.getExtension(r[s] + t);
          if (a) return a;
        }

        return null;
      }

      function ht(e) {
        var t = {
          EXT_texture_filter_anisotropic: Et(e, "EXT_texture_filter_anisotropic"),
          EXT_color_buffer_half_float: Et(e, "EXT_color_buffer_half_float"),
          EXT_color_buffer_float: Et(e, "EXT_color_buffer_float"),
          WEBGL_compressed_texture_etc1: Et(e, "WEBGL_compressed_texture_etc1"),
          WEBGL_compressed_texture_etc: Et(e, "WEBGL_compressed_texture_etc"),
          WEBGL_compressed_texture_pvrtc: Et(e, "WEBGL_compressed_texture_pvrtc"),
          WEBGL_compressed_texture_astc: Et(e, "WEBGL_compressed_texture_astc"),
          WEBGL_compressed_texture_s3tc: Et(e, "WEBGL_compressed_texture_s3tc"),
          WEBGL_compressed_texture_s3tc_srgb: Et(e, "WEBGL_compressed_texture_s3tc_srgb"),
          WEBGL_debug_shaders: Et(e, "WEBGL_debug_shaders"),
          WEBGL_lose_context: Et(e, "WEBGL_lose_context"),
          WEBGL_debug_renderer_info: Et(e, "WEBGL_debug_renderer_info"),
          OES_texture_half_float_linear: Et(e, "OES_texture_half_float_linear"),
          OES_texture_float_linear: Et(e, "OES_texture_float_linear"),
          WEBGL_multi_draw: null,
          useVAO: !0
        };
        return te.os !== re.ANDROID && te.os !== re.IOS && (t.WEBGL_multi_draw = Et(e, "WEBGL_multi_draw")), t;
      }

      var St = function (e) {
        function r() {
          for (var t, r = arguments.length, s = new Array(r), a = 0; a < r; a++) {
            s[a] = arguments[a];
          }

          return (t = e.call.apply(e, [this].concat(s)) || this).stateCache = new ft(), t.nullTex2D = null, t.nullTexCube = null, t._canvas = null, t._webGL2ContextLostHandler = null, t._extensions = null, t;
        }

        t(r, e);
        var s = r.prototype;
        return s.initialize = function (e) {
          this._canvas = e.windowHandle, this._webGL2ContextLostHandler = this._onWebGLContextLost.bind(this), this._canvas.addEventListener(At, this._onWebGLContextLost);
          var t = de.instance.gl;
          this.stateCache.initialize(de.instance.capabilities.maxTextureUnits, de.instance.capabilities.maxUniformBufferBindings, de.instance.capabilities.maxVertexAttributes), this._extensions = ht(t), function (e) {
            e.activeTexture(e.TEXTURE0), e.pixelStorei(e.PACK_ALIGNMENT, 1), e.pixelStorei(e.UNPACK_ALIGNMENT, 1), e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, !1), e.bindFramebuffer(e.FRAMEBUFFER, null), e.enable(e.SCISSOR_TEST), e.enable(e.CULL_FACE), e.cullFace(e.BACK), e.frontFace(e.CCW), e.polygonOffset(0, 0), e.enable(e.DEPTH_TEST), e.depthMask(!0), e.depthFunc(e.LESS), e.stencilFuncSeparate(e.FRONT, e.ALWAYS, 1, 65535), e.stencilOpSeparate(e.FRONT, e.KEEP, e.KEEP, e.KEEP), e.stencilMaskSeparate(e.FRONT, 65535), e.stencilFuncSeparate(e.BACK, e.ALWAYS, 1, 65535), e.stencilOpSeparate(e.BACK, e.KEEP, e.KEEP, e.KEEP), e.stencilMaskSeparate(e.BACK, 65535), e.disable(e.STENCIL_TEST), e.disable(e.SAMPLE_ALPHA_TO_COVERAGE), e.disable(e.BLEND), e.blendEquationSeparate(e.FUNC_ADD, e.FUNC_ADD), e.blendFuncSeparate(e.ONE, e.ZERO, e.ONE, e.ZERO), e.colorMask(!0, !0, !0, !0), e.blendColor(0, 0, 0, 0);
          }(t);
          var r = d.RGBA8,
              s = d.DEPTH_STENCIL,
              a = t.getParameter(t.DEPTH_BITS),
              n = t.getParameter(t.STENCIL_BITS);
          a && n ? s = d.DEPTH_STENCIL : a && (s = d.DEPTH), this._colorTexture = new Rt(), this._colorTexture.initAsSwapchainTexture({
            swapchain: this,
            format: r,
            width: e.width,
            height: e.height
          }), this._depthStencilTexture = new Rt(), this._depthStencilTexture.initAsSwapchainTexture({
            swapchain: this,
            format: s,
            width: e.width,
            height: e.height
          }), this.nullTex2D = de.instance.createTexture(new j(o.TEX2D, Q.SAMPLED, d.RGBA8, 2, 2, G.NONE)), this.nullTexCube = de.instance.createTexture(new j(o.CUBE, Q.SAMPLED, d.RGBA8, 2, 2, G.NONE, 6));
          var i = new ne();
          i.texExtent.width = 2, i.texExtent.height = 2;
          var u = new Uint8Array(this.nullTex2D.size);
          u.fill(0), de.instance.copyBuffersToTexture([u], this.nullTex2D, [i]), i.texSubres.layerCount = 6, de.instance.copyBuffersToTexture([u, u, u, u, u, u], this.nullTexCube, [i]);
        }, s.destroy = function () {
          this._canvas && this._webGL2ContextLostHandler && (this._canvas.removeEventListener(At, this._webGL2ContextLostHandler), this._webGL2ContextLostHandler = null), this.nullTex2D && (this.nullTex2D.destroy(), this.nullTex2D = null), this.nullTexCube && (this.nullTexCube.destroy(), this.nullTexCube = null), this._extensions = null, this._canvas = null;
        }, s.resize = function (e, t) {
          this._colorTexture.width === e && this._colorTexture.height === t || (h("Resizing swapchain: " + e + "x" + t), this._canvas.width = e, this._canvas.height = t, this._colorTexture.resize(e, t), this._depthStencilTexture.resize(e, t));
        }, s._onWebGLContextLost = function (e) {
          J(11e3), ee(e);
        }, a(r, [{
          key: "extensions",
          get: function get() {
            return this._extensions;
          }
        }]), r;
      }(ie),
          Tt = e("WebGL2Device", function (e) {
        function r() {
          for (var t, r = arguments.length, s = new Array(r), a = 0; a < r; a++) {
            s[a] = arguments[a];
          }

          return (t = e.call.apply(e, [this].concat(s)) || this)._swapchain = null, t._context = null, t._bindingMappings = null, t._textureExclusive = new Array(d.COUNT), t;
        }

        t(r, e);
        var s = r.prototype;
        return s.initialize = function (e) {
          de.setInstance(this), this._gfxAPI = ue.WEBGL2;
          var t = this._bindingMappingInfo = e.bindingMappingInfo,
              r = [],
              s = [],
              a = t.setIndices[0];
          r[a] = 0, s[a] = 0;

          for (var n = 1; n < t.setIndices.length; ++n) {
            var i = t.setIndices[n],
                u = t.setIndices[n - 1];
            r[i] = t.maxBlockCounts[u] + r[u], s[i] = t.maxSamplerTextureCounts[u] + s[u];
          }

          for (var _ = 0; _ < t.setIndices.length; ++_) {
            var l = t.setIndices[_];
            s[l] -= t.maxBlockCounts[l];
          }

          this._bindingMappings = {
            blockOffsets: r,
            samplerTextureOffsets: s,
            flexibleSet: t.setIndices[t.setIndices.length - 1]
          };

          var c = this._context = function (e) {
            var t = null;

            try {
              var r = {
                alpha: se.ENABLE_TRANSPARENT_CANVAS,
                antialias: ae || se.ENABLE_WEBGL_ANTIALIAS,
                depth: !0,
                stencil: !0,
                premultipliedAlpha: !1,
                preserveDrawingBuffer: !1,
                powerPreference: "default",
                failIfMajorPerformanceCaveat: !1
              };
              t = e.getContext("webgl2", r);
            } catch (e) {
              return null;
            }

            return t;
          }(he.canvas);

          if (!c) return console.error("This device does not support WebGL."), !1;
          this._queue = this.createQueue(new _e(le.GRAPHICS)), this._cmdBuff = this.createCommandBuffer(new ce(this._queue)), this._caps.maxVertexAttributes = c.getParameter(c.MAX_VERTEX_ATTRIBS), this._caps.maxVertexUniformVectors = c.getParameter(c.MAX_VERTEX_UNIFORM_VECTORS), this._caps.maxFragmentUniformVectors = c.getParameter(c.MAX_FRAGMENT_UNIFORM_VECTORS), this._caps.maxTextureUnits = c.getParameter(c.MAX_TEXTURE_IMAGE_UNITS), this._caps.maxVertexTextureUnits = c.getParameter(c.MAX_VERTEX_TEXTURE_IMAGE_UNITS), this._caps.maxUniformBufferBindings = c.getParameter(c.MAX_UNIFORM_BUFFER_BINDINGS), this._caps.maxUniformBlockSize = c.getParameter(c.MAX_UNIFORM_BLOCK_SIZE), this._caps.maxTextureSize = c.getParameter(c.MAX_TEXTURE_SIZE), this._caps.maxCubeMapTextureSize = c.getParameter(c.MAX_CUBE_MAP_TEXTURE_SIZE), this._caps.uboOffsetAlignment = c.getParameter(c.UNIFORM_BUFFER_OFFSET_ALIGNMENT);
          var o = c.getSupportedExtensions(),
              f = "";
          if (o) for (var R, A = oe(o); !(R = A()).done;) {
            f += R.value + " ";
          }
          var E = ht(c);
          E.WEBGL_debug_renderer_info ? (this._renderer = c.getParameter(E.WEBGL_debug_renderer_info.UNMASKED_RENDERER_WEBGL), this._vendor = c.getParameter(E.WEBGL_debug_renderer_info.UNMASKED_VENDOR_WEBGL)) : (this._renderer = c.getParameter(c.RENDERER), this._vendor = c.getParameter(c.VENDOR));
          var S = c.getParameter(c.VERSION);
          this._features.fill(!1), this.initFormatFeatures(E), this._features[fe.ELEMENT_INDEX_UINT] = !0, this._features[fe.INSTANCED_ARRAYS] = !0, this._features[fe.MULTIPLE_RENDER_TARGETS] = !0, this._features[fe.BLEND_MINMAX] = !0;
          var T = "";
          return this.getFormatFeatures(d.ETC_RGB8) && (T += "etc1 "), this.getFormatFeatures(d.ETC2_RGB8) && (T += "etc2 "), this.getFormatFeatures(d.BC1) && (T += "dxt "), this.getFormatFeatures(d.PVRTC_RGB2) && (T += "pvrtc "), this.getFormatFeatures(d.ASTC_RGBA_4X4) && (T += "astc "), h("WebGL2 device initialized."), h("RENDERER: " + this._renderer), h("VENDOR: " + this._vendor), h("VERSION: " + S), h("COMPRESSED_FORMAT: " + T), h("EXTENSIONS: " + f), !0;
        }, s.destroy = function () {
          this._queue && (this._queue.destroy(), this._queue = null), this._cmdBuff && (this._cmdBuff.destroy(), this._cmdBuff = null);

          for (var e = this._samplers.values(), t = e.next(); !t.done;) {
            t.value.destroy(), t = e.next();
          }

          this._swapchain = null;
        }, s.flushCommands = function () {}, s.acquire = function () {}, s.present = function () {
          var e = this._queue;
          this._numDrawCalls = e.numDrawCalls, this._numInstances = e.numInstances, this._numTris = e.numTris, e.clear();
        }, s.initFormatFeatures = function (e) {
          this._formatFeatures.fill(Re.NONE), this._textureExclusive.fill(!0);
          var t = Re.RENDER_TARGET | Re.SAMPLED_TEXTURE | Re.STORAGE_TEXTURE | Re.LINEAR_FILTER | Re.VERTEX_ATTRIBUTE;
          this._formatFeatures[d.R8] = t, this._formatFeatures[d.RG8] = t, this._formatFeatures[d.RGB8] = t, this._formatFeatures[d.RGBA8] = t, t = Re.RENDER_TARGET | Re.SAMPLED_TEXTURE | Re.STORAGE_TEXTURE | Re.LINEAR_FILTER, this._formatFeatures[d.R8SN] = t, this._formatFeatures[d.RG8SN] = t, this._formatFeatures[d.RGB8SN] = t, this._formatFeatures[d.RGBA8SN] = t, this._formatFeatures[d.R5G6B5] = t, this._formatFeatures[d.RGBA4] = t, this._formatFeatures[d.RGB5A1] = t, this._formatFeatures[d.RGB10A2] = t, this._formatFeatures[d.SRGB8] = t, this._formatFeatures[d.SRGB8_A8] = t, this._formatFeatures[d.R11G11B10F] = t, this._formatFeatures[d.RGB9E5] = t, this._formatFeatures[d.DEPTH] = t, this._formatFeatures[d.DEPTH_STENCIL] = t, this._formatFeatures[d.RGB10A2UI] = Re.RENDER_TARGET | Re.STORAGE_TEXTURE | Re.SAMPLED_TEXTURE | Re.LINEAR_FILTER, t = Re.RENDER_TARGET | Re.SAMPLED_TEXTURE | Re.STORAGE_TEXTURE | Re.VERTEX_ATTRIBUTE, this._formatFeatures[d.R16F] = t, this._formatFeatures[d.RG16F] = t, this._formatFeatures[d.RGB16F] = t, this._formatFeatures[d.RGBA16F] = t, t = Re.STORAGE_TEXTURE | Re.SAMPLED_TEXTURE | Re.VERTEX_ATTRIBUTE, this._formatFeatures[d.R32F] = t, this._formatFeatures[d.RG32F] = t, this._formatFeatures[d.RGB32F] = t, this._formatFeatures[d.RGBA32F] = t, this._formatFeatures[d.RGB10A2UI] = Re.RENDER_TARGET | Re.STORAGE_TEXTURE | Re.SAMPLED_TEXTURE | Re.LINEAR_FILTER, t = Re.RENDER_TARGET | Re.STORAGE_TEXTURE | Re.SAMPLED_TEXTURE | Re.LINEAR_FILTER | Re.VERTEX_ATTRIBUTE, this._formatFeatures[d.R8I] = t, this._formatFeatures[d.R8UI] = t, this._formatFeatures[d.R16I] = t, this._formatFeatures[d.R16UI] = t, this._formatFeatures[d.R32I] = t, this._formatFeatures[d.R32UI] = t, this._formatFeatures[d.RG8I] = t, this._formatFeatures[d.RG8UI] = t, this._formatFeatures[d.RG16I] = t, this._formatFeatures[d.RG16UI] = t, this._formatFeatures[d.RG32I] = t, this._formatFeatures[d.RG32UI] = t, this._formatFeatures[d.RGB8I] = t, this._formatFeatures[d.RGB8UI] = t, this._formatFeatures[d.RGB16I] = t, this._formatFeatures[d.RGB16UI] = t, this._formatFeatures[d.RGB32I] = t, this._formatFeatures[d.RGB32UI] = t, this._formatFeatures[d.RGBA8I] = t, this._formatFeatures[d.RGBA8UI] = t, this._formatFeatures[d.RGBA16I] = t, this._formatFeatures[d.RGBA16UI] = t, this._formatFeatures[d.RGBA32I] = t, this._formatFeatures[d.RGBA32UI] = t, this._textureExclusive[d.R8] = !1, this._textureExclusive[d.RG8] = !1, this._textureExclusive[d.RGB8] = !1, this._textureExclusive[d.R5G6B5] = !1, this._textureExclusive[d.RGBA4] = !1, this._textureExclusive[d.RGB5A1] = !1, this._textureExclusive[d.RGBA8] = !1, this._textureExclusive[d.RGB10A2] = !1, this._textureExclusive[d.RGB10A2UI] = !1, this._textureExclusive[d.SRGB8_A8] = !1, this._textureExclusive[d.R8I] = !1, this._textureExclusive[d.R8UI] = !1, this._textureExclusive[d.R16I] = !1, this._textureExclusive[d.R16UI] = !1, this._textureExclusive[d.R32I] = !1, this._textureExclusive[d.R32UI] = !1, this._textureExclusive[d.RG8I] = !1, this._textureExclusive[d.RG8UI] = !1, this._textureExclusive[d.RG16I] = !1, this._textureExclusive[d.RG16UI] = !1, this._textureExclusive[d.RG32I] = !1, this._textureExclusive[d.RG32UI] = !1, this._textureExclusive[d.RGBA8I] = !1, this._textureExclusive[d.RGBA8UI] = !1, this._textureExclusive[d.RGBA16I] = !1, this._textureExclusive[d.RGBA16UI] = !1, this._textureExclusive[d.RGBA32I] = !1, this._textureExclusive[d.RGBA32UI] = !1, this._textureExclusive[d.DEPTH] = !1, this._textureExclusive[d.DEPTH_STENCIL] = !1, e.EXT_color_buffer_float && (this._formatFeatures[d.R32F] |= Re.RENDER_TARGET, this._formatFeatures[d.RG32F] |= Re.RENDER_TARGET, this._formatFeatures[d.RGBA32F] |= Re.RENDER_TARGET, this._textureExclusive[d.R32F] = !1, this._textureExclusive[d.RG32F] = !1, this._textureExclusive[d.RGBA32F] = !1), e.EXT_color_buffer_half_float && (this._textureExclusive[d.R16F] = !1, this._textureExclusive[d.RG16F] = !1, this._textureExclusive[d.RGBA16F] = !1), e.OES_texture_float_linear && (this._formatFeatures[d.RGB32F] |= Re.LINEAR_FILTER, this._formatFeatures[d.RGBA32F] |= Re.LINEAR_FILTER, this._formatFeatures[d.R32F] |= Re.LINEAR_FILTER, this._formatFeatures[d.RG32F] |= Re.LINEAR_FILTER), e.OES_texture_half_float_linear && (this._formatFeatures[d.RGB16F] |= Re.LINEAR_FILTER, this._formatFeatures[d.RGBA16F] |= Re.LINEAR_FILTER, this._formatFeatures[d.R16F] |= Re.LINEAR_FILTER, this._formatFeatures[d.RG16F] |= Re.LINEAR_FILTER);
          var r = Re.SAMPLED_TEXTURE | Re.LINEAR_FILTER;
          e.WEBGL_compressed_texture_etc1 && (this._formatFeatures[d.ETC_RGB8] = r), e.WEBGL_compressed_texture_etc && (this._formatFeatures[d.ETC2_RGB8] = r, this._formatFeatures[d.ETC2_RGBA8] = r, this._formatFeatures[d.ETC2_SRGB8] = r, this._formatFeatures[d.ETC2_SRGB8_A8] = r, this._formatFeatures[d.ETC2_RGB8_A1] = r, this._formatFeatures[d.ETC2_SRGB8_A1] = r), e.WEBGL_compressed_texture_s3tc && (this._formatFeatures[d.BC1] = r, this._formatFeatures[d.BC1_ALPHA] = r, this._formatFeatures[d.BC1_SRGB] = r, this._formatFeatures[d.BC1_SRGB_ALPHA] = r, this._formatFeatures[d.BC2] = r, this._formatFeatures[d.BC2_SRGB] = r, this._formatFeatures[d.BC3] = r, this._formatFeatures[d.BC3_SRGB] = r), e.WEBGL_compressed_texture_pvrtc && (this._formatFeatures[d.PVRTC_RGB2] = r, this._formatFeatures[d.PVRTC_RGBA2] = r, this._formatFeatures[d.PVRTC_RGB4] = r, this._formatFeatures[d.PVRTC_RGBA4] = r), e.WEBGL_compressed_texture_astc && (this._formatFeatures[d.ASTC_RGBA_4X4] = r, this._formatFeatures[d.ASTC_RGBA_5X4] = r, this._formatFeatures[d.ASTC_RGBA_5X5] = r, this._formatFeatures[d.ASTC_RGBA_6X5] = r, this._formatFeatures[d.ASTC_RGBA_6X6] = r, this._formatFeatures[d.ASTC_RGBA_8X5] = r, this._formatFeatures[d.ASTC_RGBA_8X6] = r, this._formatFeatures[d.ASTC_RGBA_8X8] = r, this._formatFeatures[d.ASTC_RGBA_10X5] = r, this._formatFeatures[d.ASTC_RGBA_10X6] = r, this._formatFeatures[d.ASTC_RGBA_10X8] = r, this._formatFeatures[d.ASTC_RGBA_10X10] = r, this._formatFeatures[d.ASTC_RGBA_12X10] = r, this._formatFeatures[d.ASTC_RGBA_12X12] = r, this._formatFeatures[d.ASTC_SRGBA_4X4] = r, this._formatFeatures[d.ASTC_SRGBA_5X4] = r, this._formatFeatures[d.ASTC_SRGBA_5X5] = r, this._formatFeatures[d.ASTC_SRGBA_6X5] = r, this._formatFeatures[d.ASTC_SRGBA_6X6] = r, this._formatFeatures[d.ASTC_SRGBA_8X5] = r, this._formatFeatures[d.ASTC_SRGBA_8X6] = r, this._formatFeatures[d.ASTC_SRGBA_8X8] = r, this._formatFeatures[d.ASTC_SRGBA_10X5] = r, this._formatFeatures[d.ASTC_SRGBA_10X6] = r, this._formatFeatures[d.ASTC_SRGBA_10X8] = r, this._formatFeatures[d.ASTC_SRGBA_10X10] = r, this._formatFeatures[d.ASTC_SRGBA_12X10] = r, this._formatFeatures[d.ASTC_SRGBA_12X12] = r);
        }, s.createCommandBuffer = function (e) {
          var t = new (e.type === M.PRIMARY ? ut : et)();
          return t.initialize(e), t;
        }, s.createSwapchain = function (e) {
          var t = new St();
          return this._swapchain = t, t.initialize(e), t;
        }, s.createBuffer = function (e) {
          var t = new Qe();
          return t.initialize(e), t;
        }, s.createTexture = function (e) {
          var t = new Rt();
          return t.initialize(e), t;
        }, s.createDescriptorSet = function (e) {
          var t = new ge();
          return t.initialize(e), t;
        }, s.createShader = function (e) {
          var t = new ot();
          return t.initialize(e), t;
        }, s.createInputAssembler = function (e) {
          var t = new rt();
          return t.initialize(e), t;
        }, s.createRenderPass = function (e) {
          var t = new lt();
          return t.initialize(e), t;
        }, s.createFramebuffer = function (e) {
          var t = new tt();
          return t.initialize(e), t;
        }, s.createDescriptorSetLayout = function (e) {
          var t = new st();
          return t.initialize(e), t;
        }, s.createPipelineLayout = function (e) {
          var t = new at();
          return t.initialize(e), t;
        }, s.createPipelineState = function (e) {
          var t = new it();
          return t.initialize(e), t;
        }, s.createQueue = function (e) {
          var t = new _t();
          return t.initialize(e), t;
        }, s.getSampler = function (e) {
          var t = k.computeHash(e);
          return this._samplers.has(t) || this._samplers.set(t, new ct(e, t)), this._samplers.get(t);
        }, s.getGeneralBarrier = function (e) {
          var t = Ae.computeHash(e);
          return this._generalBarrierss.has(t) || this._generalBarrierss.set(t, new Ae(e, t)), this._generalBarrierss.get(t);
        }, s.getTextureBarrier = function (e) {
          var t = Ee.computeHash(e);
          return this._textureBarriers.has(t) || this._textureBarriers.set(t, new Ee(e, t)), this._textureBarriers.get(t);
        }, s.copyBuffersToTexture = function (e, t, r) {
          Ze(this, e, t.gpuTexture, r);
        }, s.copyTextureToBuffers = function (e, t, r) {
          !function (e, t, r, s) {
            var a = e.gl,
                n = e.stateCache,
                i = a.createFramebuffer();
            a.bindFramebuffer(a.FRAMEBUFFER, i);
            var u = 0,
                _ = 0,
                l = 1,
                c = 1;

            switch (t.glTarget) {
              case a.TEXTURE_2D:
                for (var o = 0; o < s.length; o++) {
                  var f = s[o];
                  a.framebufferTexture2D(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0, t.glTarget, t.glTexture, f.texSubres.mipLevel), u = f.texOffset.x, _ = f.texOffset.y, l = f.texExtent.width, c = f.texExtent.height, a.readPixels(u, _, l, c, t.glFormat, t.glType, r[o]);
                }

                break;

              default:
                console.error("Unsupported GL texture type, copy texture to buffers failed.");
            }

            a.bindFramebuffer(a.FRAMEBUFFER, null), n.glFramebuffer = null, a.deleteFramebuffer(i);
          }(this, e.gpuTexture, t, r);
        }, s.copyTexImagesToTexture = function (e, t, r) {
          !function (e, t, r, s) {
            var a = e.gl,
                n = e.stateCache.glTexUnits[e.stateCache.texUnit];
            n.glTexture !== r.glTexture && (a.bindTexture(r.glTarget, r.glTexture), n.glTexture = r.glTexture);
            var i = 0,
                u = 0;

            switch (r.glTarget) {
              case a.TEXTURE_2D:
                for (var _ = 0; _ < s.length; _++) {
                  var l = s[_];
                  a.texSubImage2D(a.TEXTURE_2D, l.texSubres.mipLevel, l.texOffset.x, l.texOffset.y, r.glFormat, r.glType, t[i++]);
                }

                break;

              case a.TEXTURE_CUBE_MAP:
                for (var c = 0; c < s.length; c++) {
                  var o = s[c],
                      f = o.texSubres.baseArrayLayer + o.texSubres.layerCount;

                  for (u = o.texSubres.baseArrayLayer; u < f; ++u) {
                    a.texSubImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X + u, o.texSubres.mipLevel, o.texOffset.x, o.texOffset.y, r.glFormat, r.glType, t[i++]);
                  }
                }

                break;

              default:
                console.error("Unsupported GL texture type, copy buffer to texture failed.");
            }

            r.flags & G.GEN_MIPMAP && a.generateMipmap(r.glTarget);
          }(this, e, t.gpuTexture, r);
        }, a(r, [{
          key: "gl",
          get: function get() {
            return this._context;
          }
        }, {
          key: "extensions",
          get: function get() {
            return this._swapchain.extensions;
          }
        }, {
          key: "stateCache",
          get: function get() {
            return this._swapchain.stateCache;
          }
        }, {
          key: "nullTex2D",
          get: function get() {
            return this._swapchain.nullTex2D;
          }
        }, {
          key: "nullTexCube",
          get: function get() {
            return this._swapchain.nullTexCube;
          }
        }, {
          key: "textureExclusive",
          get: function get() {
            return this._textureExclusive;
          }
        }, {
          key: "bindingMappings",
          get: function get() {
            return this._bindingMappings;
          }
        }]), r;
      }(he));

      Se.WebGL2Device = Tt;
    }
  };
}); 
 			}); 
		define("__plugin__/wx0446ba2621dda60a/graphics-f99ac3d9.js", function(require, module, exports){ 			
"use strict";

System.register(["./texture-barrier-60b5983b.js", "./json-asset-933a1d4c.js", "./renderable-component-7c6600ed.js", "./deprecated-ef6bb945.js", "./renderable-2d-e2838949.js"], function (t) {
  "use strict";

  var e, i, s, o, n, r, l, h, a, c, u, p, f, d, m, _, b, T, v, g, y, C, E, D, R, L, P, M, O, x, w, S, U, N, B, k;

  return {
    setters: [function (t) {
      e = t.bw, i = t.bT, s = t.aC, o = t.m, n = t.d, r = t.l, l = t.al, h = t.o, a = t.q, c = t.W, u = t.bU, p = t.c0, f = t.c1, d = t.b$;
    }, function (t) {
      m = t.V, _ = t.a5, b = t.bW, T = t.bZ, v = t.bo, g = t.aO, y = t.b$, C = t.dz, E = t.cg, D = t.ds, R = t.ch, L = t.cc, P = t.ci, M = t.bX;
    }, function (t) {
      O = t.f;
    }, function (t) {
      x = t.d;
    }, function (t) {
      w = t.M, S = t.d, U = t.e, N = t.g, B = t.R, k = t.I;
    }],
    execute: function execute() {
      var A, I, z;
      t({
        L: void 0,
        a: void 0,
        b: void 0
      }), function (t) {
        t[t.BUTT = 0] = "BUTT", t[t.ROUND = 1] = "ROUND", t[t.SQUARE = 2] = "SQUARE";
      }(A || (A = t("a", {}))), e(A), function (t) {
        t[t.BEVEL = 0] = "BEVEL", t[t.ROUND = 1] = "ROUND", t[t.MITER = 2] = "MITER";
      }(I || (I = t("L", {}))), e(I), function (t) {
        t[t.PT_CORNER = 1] = "PT_CORNER", t[t.PT_LEFT = 2] = "PT_LEFT", t[t.PT_BEVEL = 4] = "PT_BEVEL", t[t.PT_INNERBEVEL = 8] = "PT_INNERBEVEL";
      }(z || (z = t("b", {}))), e(z);
      var F = Math.PI,
          j = Math.min,
          V = Math.max,
          W = Math.cos,
          J = Math.sin,
          X = Math.abs,
          G = Math.sign,
          Y = .5522847493;

      function q(t, e, i, s, o) {
        t.moveTo(e - s, i), t.bezierCurveTo(e - s, i + o * Y, e - s * Y, i + o, e, i + o), t.bezierCurveTo(e + s * Y, i + o, e + s, i + o * Y, e + s, i), t.bezierCurveTo(e + s, i - o * Y, e + s * Y, i - o, e, i - o), t.bezierCurveTo(e - s * Y, i - o, e - s, i - o * Y, e - s, i), t.close();
      }

      function H(t, e, i, s, o, n, r, l, h, a, c) {
        var u, p, f, d, m, _, b, T, v, g, y, C, E, D, R, L;

        a > 10 || (m = .5 * (n + l), _ = .5 * (r + h), b = .5 * ((u = .5 * (e + s)) + (f = .5 * (s + n))), T = .5 * ((p = .5 * (i + o)) + (d = .5 * (o + r))), ((R = X((s - l) * (D = h - i) - (o - h) * (E = l - e))) + (L = X((n - l) * D - (r - h) * E))) * (R + L) < t.tessTol * (E * E + D * D) ? t.addPoint(l, h, 0 === c ? c | z.PT_BEVEL : c) : (H(t, e, i, u, p, b, T, y = .5 * (b + (v = .5 * (f + m))), C = .5 * (T + (g = .5 * (d + _))), a + 1, 0), H(t, y, C, v, g, m, _, l, h, a + 1, c)));
      }

      var K,
          Q,
          $,
          Z,
          tt,
          et,
          it,
          st,
          ot,
          nt,
          rt,
          lt,
          ht,
          at,
          ct,
          ut,
          pt,
          ft,
          dt,
          mt,
          _t,
          bt,
          Tt,
          vt = t("P", function (t) {
        function e(e, i) {
          var s;
          return (s = t.call(this, e, i) || this).dx = 0, s.dy = 0, s.dmx = 0, s.dmy = 0, s.flags = 0, s.len = 0, s.reset(), s;
        }

        return i(e, t), e.prototype.reset = function () {
          this.dx = 0, this.dy = 0, this.dmx = 0, this.dmy = 0, this.flags = 0, this.len = 0;
        }, e;
      }(m)),
          gt = function () {
        function t() {
          this.closed = !1, this.bevel = 0, this.complex = !0, this.points = [], this.reset();
        }

        return t.prototype.reset = function () {
          this.closed = !1, this.bevel = 0, this.complex = !0, this.points ? this.points.length = 0 : this.points = [];
        }, t;
      }(),
          yt = function () {
        function t() {
          this.dataOffset = 0, this.updatePathOffset = !1, this.pathLength = 0, this.pathOffset = 0, this.paths = [], this.tessTol = .25, this.distTol = .01, this.fillColor = _.WHITE.clone(), this.lineCap = A.BUTT, this.strokeColor = _.BLACK.clone(), this.lineJoin = I.MITER, this.lineWidth = 0, this.pointsOffset = 0, this._commandX = 0, this._commandY = 0, this._points = [], this._renderDataList = [], this._curPath = null;
        }

        var e = t.prototype;
        return e.moveTo = function (t, e) {
          this.updatePathOffset && (this.pathOffset = this.pathLength, this.updatePathOffset = !1), this._addPath(), this.addPoint(t, e, z.PT_CORNER), this._commandX = t, this._commandY = e;
        }, e.lineTo = function (t, e) {
          this.addPoint(t, e, z.PT_CORNER), this._commandX = t, this._commandY = e;
        }, e.bezierCurveTo = function (t, e, i, s, o, n) {
          var r = this._curPath,
              l = r.points[r.points.length - 1];
          l && (l.x !== t || l.y !== e || i !== o || s !== n ? (H(this, l.x, l.y, t, e, i, s, o, n, 0, z.PT_CORNER), this._commandX = o, this._commandY = n) : this.lineTo(o, n));
        }, e.quadraticCurveTo = function (t, e, i, s) {
          var o = this._commandX,
              n = this._commandY;
          this.bezierCurveTo(o + 2 / 3 * (t - o), n + 2 / 3 * (e - n), i + 2 / 3 * (t - i), s + 2 / 3 * (e - s), i, s);
        }, e.arc = function (t, e, i, s, o, n) {
          !function (t, e, i, s, o, n, r) {
            var l,
                h,
                a = 0,
                c = 0,
                u = 0,
                p = 0,
                f = 0,
                d = 0,
                m = 0,
                _ = 0,
                b = 0,
                T = 0,
                v = 0,
                g = 0,
                y = 0,
                C = 0;
            if (c = n - o, r = r || !1) {
              if (X(c) >= 2 * F) c = 2 * F;else for (; c < 0;) {
                c += 2 * F;
              }
            } else if (X(c) >= 2 * F) c = 2 * -F;else for (; c > 0;) {
              c -= 2 * F;
            }

            for (h = 0 | V(1, j(X(c) / (.5 * F) + .5, 5)), u = X(4 / 3 * (1 - W(l = c / h / 2)) / J(l)), r || (u = -u), C = 0; C <= h; C++) {
              d = e + (p = W(a = o + c * (C / h))) * s, m = i + (f = J(a)) * s, _ = -f * s * u, b = p * s * u, 0 === C ? t.moveTo(d, m) : t.bezierCurveTo(T + g, v + y, d - _, m - b, d, m), T = d, v = m, g = _, y = b;
            }
          }(this, t, e, i, s, o, n);
        }, e.ellipse = function (t, e, i, s) {
          q(this, t, e, i, s), this._curPath.complex = !1;
        }, e.circle = function (t, e, i) {
          q(this, t, e, i, i), this._curPath.complex = !1;
        }, e.rect = function (t, e, i, s) {
          this.moveTo(t, e), this.lineTo(t + i, e), this.lineTo(t + i, e + s), this.lineTo(t, e + s), this.close(), this._curPath.complex = !1;
        }, e.roundRect = function (t, e, i, s, o) {
          !function (t, e, i, s, o, n) {
            if (n < .1) t.rect(e, i, s, o);else {
              var r = j(n, .5 * X(s)) * G(s),
                  l = j(n, .5 * X(o)) * G(o);
              t.moveTo(e, i + l), t.lineTo(e, i + o - l), t.bezierCurveTo(e, i + o - l * (1 - Y), e + r * (1 - Y), i + o, e + r, i + o), t.lineTo(e + s - r, i + o), t.bezierCurveTo(e + s - r * (1 - Y), i + o, e + s, i + o - l * (1 - Y), e + s, i + o - l), t.lineTo(e + s, i + l), t.bezierCurveTo(e + s, i + l * (1 - Y), e + s - r * (1 - Y), i, e + s - r, i), t.lineTo(e + r, i), t.bezierCurveTo(e + r * (1 - Y), i, e, i + l * (1 - Y), e, i + l), t.close();
            }
          }(this, t, e, i, s, o), this._curPath.complex = !1;
        }, e.clear = function () {
          this.pathLength = 0, this.pathOffset = 0, this.pointsOffset = 0, this.dataOffset = 0, this._curPath = null, this.paths.length = 0, this._points.length = 0;

          for (var t = this._renderDataList, e = 0, i = t.length; e < i; e++) {
            var s = t[e];
            s && w.remove(s);
          }

          this._renderDataList.length = 0;
        }, e.close = function () {
          this._curPath.closed = !0;
        }, e.requestRenderData = function () {
          var t = w.add();
          return this._renderDataList.push(t), t;
        }, e.getRenderDataList = function () {
          return 0 === this._renderDataList.length && this.requestRenderData(), this._renderDataList;
        }, e.addPoint = function (t, e, i) {
          var s = this._curPath;

          if (s) {
            var o = this._points,
                n = s.points,
                r = o[this.pointsOffset++];
            r ? (r.x = t, r.y = e) : (r = new vt(t, e), o.push(r)), r.flags = i, n.push(r);
          }
        }, e._addPath = function () {
          var t = this.pathLength,
              e = this.paths[t];
          return e ? e.reset() : (e = new gt(), this.paths.push(e)), this.pathLength++, this._curPath = e, e;
        }, t;
      }(),
          Ct = S.concat([new s("a_dist", o.R32F)]),
          Et = U(Ct),
          Dt = N(Ct),
          Rt = t("G", (K = b("cc.Graphics"), Q = E(), $ = D(110), Z = R(), tt = L(), et = T(I), it = L(), st = T(A), ot = L(), nt = L(), rt = L(), lt = L(), ht = P(), K(at = Q(at = $(at = Z((Tt = bt = function (t) {
        function e() {
          var e;
          return (e = t.call(this) || this).impl = null, e.model = null, f(e, "_lineWidth", ut, d(e)), f(e, "_strokeColor", pt, d(e)), f(e, "_lineJoin", ft, d(e)), f(e, "_lineCap", dt, d(e)), f(e, "_fillColor", mt, d(e)), f(e, "_miterLimit", _t, d(e)), e._isDrawing = !1, e._isNeedUploadData = !0, e._graphicsUseSubMeshes = [], e._instanceMaterialType = k.ADD_COLOR, e.impl = new yt(), e;
        }

        i(e, t);
        var s = e.prototype;
        return s.onRestore = function () {
          this.impl || this._flushAssembler();
        }, s.onLoad = function () {
          this.model = x.root.createModel(O), this.model.node = this.model.transform = this.node, this._flushAssembler();
        }, s.onEnable = function () {
          t.prototype.onEnable.call(this), this._updateMtlForGraphics();
        }, s.onDisable = function () {
          t.prototype.onDisable.call(this);
        }, s.onDestroy = function () {
          this._sceneGetter = null, this.model && (x.root.destroyModel(this.model), this.model = null);
          var e = this._graphicsUseSubMeshes.length;

          if (e > 0) {
            for (var i = 0; i < e; ++i) {
              this._graphicsUseSubMeshes[i].destroy();
            }

            this._graphicsUseSubMeshes.length = 0;
          }

          this.impl && (this._isDrawing = !1, this.impl.clear(), this.impl = null), t.prototype.onDestroy.call(this);
        }, s.moveTo = function (t, e) {
          this.impl && this.impl.moveTo(t, e);
        }, s.lineTo = function (t, e) {
          this.impl && this.impl.lineTo(t, e);
        }, s.bezierCurveTo = function (t, e, i, s, o, n) {
          this.impl && this.impl.bezierCurveTo(t, e, i, s, o, n);
        }, s.quadraticCurveTo = function (t, e, i, s) {
          this.impl && this.impl.quadraticCurveTo(t, e, i, s);
        }, s.arc = function (t, e, i, s, o, n) {
          this.impl && this.impl.arc(t, e, i, s, o, n);
        }, s.ellipse = function (t, e, i, s) {
          this.impl && this.impl.ellipse(t, e, i, s);
        }, s.circle = function (t, e, i) {
          this.impl && this.impl.circle(t, e, i);
        }, s.rect = function (t, e, i, s) {
          this.impl && this.impl.rect(t, e, i, s);
        }, s.roundRect = function (t, e, i, s, o) {
          this.impl && this.impl.roundRect(t, e, i, s, o);
        }, s.fillRect = function (t, e, i, s) {
          this.rect(t, e, i, s), this.fill();
        }, s.clear = function () {
          if (this.impl) {
            if (this.impl.clear(), this._isDrawing = !1, this.model) for (var t = 0; t < this.model.subModels.length; t++) {
              this.model.subModels[t].inputAssembler.indexCount = 0;
            }
            this.markForUpdateRenderData();
          }
        }, s.close = function () {
          this.impl && this.impl.close();
        }, s.stroke = function () {
          this._assembler || this._flushAssembler(), this._isDrawing = !0, this._isNeedUploadData = !0, this._assembler.stroke(this);
        }, s.fill = function () {
          this._assembler || this._flushAssembler(), this._isDrawing = !0, this._isNeedUploadData = !0, this._assembler.fill(this);
        }, s._updateMtlForGraphics = function () {
          var t;
          this._customMaterial ? t = this.getMaterialInstance(0) : (t = v.get("ui-graphics-material"), this.setMaterial(t, 0), (t = this.getMaterialInstance(0)).recompileShaders({
            USE_LOCAL: !0
          }));
        }, s.activeSubModel = function (t) {
          if (this.model) {
            if (this.model.subModels.length <= t) {
              var e = r.director.root.device,
                  i = e.createBuffer(new l(h.VERTEX | h.TRANSFER_DST, a.DEVICE, 65535 * Dt, Dt)),
                  s = e.createBuffer(new l(h.INDEX | h.TRANSFER_DST, a.DEVICE, 131070 * Uint16Array.BYTES_PER_ELEMENT, Uint16Array.BYTES_PER_ELEMENT)),
                  o = new g([i], Ct, c.TRIANGLE_LIST, s);
              o.subMeshIdx = 0, this.model.initSubModel(t, o, this.getMaterialInstance(0)), this._graphicsUseSubMeshes.push(o);
            }
          } else n(4500, this.node.name);
        }, s._uploadData = function () {
          var t = this.impl;

          if (t) {
            var e = t && t.getRenderDataList();

            if (!(e.length <= 0) && this.model) {
              for (var i = this.model.subModels, s = 0; s < e.length; s++) {
                var o = e[s],
                    n = i[s].inputAssembler;

                if (o.lastFilledVertex !== o.vertexStart) {
                  var r = new Float32Array(o.vData.buffer, 0, o.vertexStart * Et);
                  n.vertexBuffers[0].update(r), n.vertexCount = o.vertexStart;
                  var l = new Uint16Array(o.iData.buffer, 0, o.indexStart);
                  n.indexBuffer.update(l), n.indexCount = o.indexStart, o.lastFilledVertex = o.vertexStart, o.lastFilledIndex = o.indexStart;
                }
              }

              this._isNeedUploadData = !1;
            }
          }
        }, s._render = function (t) {
          if (this._isNeedUploadData) {
            if (this.impl) {
              var e = this.impl.getRenderDataList(),
                  i = this.model.subModels.length;
              if (e.length > i) for (var s = i; s < e.length; s++) {
                this.activeSubModel(s);
              }
            }

            this._uploadData();
          }

          t.commitModel(this, this.model, this.getMaterialInstance(0));
        }, s._flushAssembler = function () {
          var t = e.Assembler.getAssembler(this);
          this._assembler !== t && (this._assembler = t);
        }, s._canRender = function () {
          return !!t.prototype._canRender.call(this) && !!this.model && this._isDrawing;
        }, u(e, [{
          key: "lineWidth",
          get: function get() {
            return this._lineWidth;
          },
          set: function set(t) {
            this._lineWidth = t, this.impl && (this.impl.lineWidth = t);
          }
        }, {
          key: "lineJoin",
          get: function get() {
            return this._lineJoin;
          },
          set: function set(t) {
            this._lineJoin = t, this.impl && (this.impl.lineJoin = t);
          }
        }, {
          key: "lineCap",
          get: function get() {
            return this._lineCap;
          },
          set: function set(t) {
            this._lineCap = t, this.impl && (this.impl.lineCap = t);
          }
        }, {
          key: "strokeColor",
          get: function get() {
            return this._strokeColor;
          },
          set: function set(t) {
            this.impl && (this._strokeColor.set(t), this.impl.strokeColor = this._strokeColor);
          }
        }, {
          key: "fillColor",
          get: function get() {
            return this._fillColor;
          },
          set: function set(t) {
            this.impl && (this._fillColor.set(t), this.impl.fillColor = this._fillColor);
          }
        }, {
          key: "miterLimit",
          get: function get() {
            return this._miterLimit;
          },
          set: function set(t) {
            this._miterLimit = t;
          }
        }, {
          key: "color",
          get: function get() {
            return this._color;
          },
          set: function set(t) {
            this._color !== t && this._color.set(t);
          }
        }, {
          key: "srcBlendFactor",
          get: function get() {
            return this._srcBlendFactor;
          },
          set: function set() {}
        }, {
          key: "dstBlendFactor",
          get: function get() {
            return this._dstBlendFactor;
          },
          set: function set() {}
        }]), e;
      }(B), bt.LineJoin = I, bt.LineCap = A, p((ct = Tt).prototype, "lineWidth", [y, tt], Object.getOwnPropertyDescriptor(ct.prototype, "lineWidth"), ct.prototype), p(ct.prototype, "lineJoin", [et, it], Object.getOwnPropertyDescriptor(ct.prototype, "lineJoin"), ct.prototype), p(ct.prototype, "lineCap", [st, ot], Object.getOwnPropertyDescriptor(ct.prototype, "lineCap"), ct.prototype), p(ct.prototype, "strokeColor", [nt], Object.getOwnPropertyDescriptor(ct.prototype, "strokeColor"), ct.prototype), p(ct.prototype, "fillColor", [rt], Object.getOwnPropertyDescriptor(ct.prototype, "fillColor"), ct.prototype), p(ct.prototype, "miterLimit", [lt], Object.getOwnPropertyDescriptor(ct.prototype, "miterLimit"), ct.prototype), p(ct.prototype, "color", [C, ht], Object.getOwnPropertyDescriptor(ct.prototype, "color"), ct.prototype), ut = p(ct.prototype, "_lineWidth", [M], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 1;
        }
      }), pt = p(ct.prototype, "_strokeColor", [M], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return _.BLACK.clone();
        }
      }), ft = p(ct.prototype, "_lineJoin", [M], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return I.MITER;
        }
      }), dt = p(ct.prototype, "_lineCap", [M], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return A.BUTT;
        }
      }), mt = p(ct.prototype, "_fillColor", [M], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return _.WHITE.clone();
        }
      }), _t = p(ct.prototype, "_miterLimit", [M], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 10;
        }
      }), at = ct)) || at) || at) || at) || at));

      r.Graphics = Rt;
    }
  };
}); 
 			}); 
		define("__plugin__/wx0446ba2621dda60a/index-07804d0e.js", function(require, module, exports){ 			
"use strict";

require("@babel/runtime/helpers/Arrayincludes");

System.register(["./texture-barrier-60b5983b.js", "./json-asset-933a1d4c.js", "./index-f2b92470.js", "./sprite-frame-1edab3eb.js", "./sprite-827770a8.js", "./renderable-2d-e2838949.js", "./graphics-f99ac3d9.js", "./deprecated-e75f11b6.js", "./deprecated-5f7f37d5.js", "./static-vb-accessor-3aa47319.js"], function (t) {
  "use strict";

  var e, r, a, i, n, s, o, h, u, c, l, f, d, v, p, _, x, g, y, m, S, D, w, b, T, C, M, B, E, A, L, R, F, P, I, O, H, k, V, N, U, z, W, Z, G, q, X, j, K, Q, Y, J, $, tt, et, rt, at, it, nt, st, ot, ht, ut, ct, lt, ft, dt, vt, pt, _t, xt, gt, yt, mt, St, Dt, wt;

  return {
    setters: [function (t) {
      e = t.a$, r = t.cF, a = t.ct, i = t.G, n = t.l, s = t.i, o = t.c, h = t.f, u = t.bX, c = t.bW, l = t.bU, f = t.aP, d = t.C, v = t.P, p = t.al, _ = t.o, x = t.q, g = t.bT, y = t.d;
    }, function (t) {
      m = t.Q, S = t.Z, D = t.aa, w = t.a5, b = t.a3, T = t.a1, C = t.V, M = t.dT, B = t.bG, E = t.dU, A = t.bF, L = t.dS, R = t.dV, F = t.dW, P = t.c5, I = t.dX, O = t.aW, H = t.az, k = t.ax, V = t.ay;
    }, function (t) {
      N = t.d, U = t.f;
    }, function (t) {
      z = t.d, W = t.S;
    }, function (t) {
      Z = t.m, G = t.O, q = t.e, X = t.i, j = t.H, K = t.V, Q = t.n, Y = t.o, J = t.c, $ = t.s, tt = t.l, et = t.d, rt = t.g, at = t.B, it = t.a, nt = t.T;
    }, function (t) {
      st = t.S, ot = t.f, ht = t.g, ut = t.b, ct = t.M, lt = t.a;
    }, function (t) {
      ft = t.L, dt = t.a, vt = t.P, pt = t.b, _t = t.G;
    }, function (t) {
      xt = t.L, gt = t.b, yt = t.M, mt = t.d, St = t.D;
    }, function () {}, function (t) {
      Dt = t.S, wt = t.M;
    }],
    execute: function execute() {
      t("e", jt);
      var bt = new m(),
          Tt = new S();

      function Ct(t, e, r, a) {
        var i = r.chunk,
            n = r.data,
            s = i.vb,
            o = r.vertexCount;
        t.getWorldMatrix(Tt);

        for (var h = 0, u = 0; u < o; u++) {
          var c = n[u];
          m.set(bt, c.x, c.y, 0), m.transformMat4(bt, bt, Tt), s[h++] = bt.x, s[h++] = bt.y, s[h++] = bt.z, w.toArray(s, a, h + 2), h += 6;
        }

        for (var l = i.bufferId, f = i.vertexOffset, d = i.vertexAccessor.getMeshBuffer(i.bufferId), v = i.vertexAccessor.getIndexBuffer(l), p = d.indexOffset, _ = 0, x = o / 4; _ < x; _++) {
          var g = f + 4 * _;
          v[p++] = g, v[p++] = g + 1, v[p++] = g + 2, v[p++] = g + 1, v[p++] = g + 3, v[p++] = g + 2;
        }

        d.indexOffset += r.indexCount, d.setDirty();
      }

      var Mt = function Mt(t, e, r) {
        this.i = void 0, this.x = void 0, this.y = void 0, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1, this.i = t, this.x = e, this.y = r;
      };

      function Bt(t, e, r, a, i) {
        var n = 0,
            s = null;
        if (i === function (t, e, r, a) {
          for (var i = 0, n = e, s = r - a; n < r; n += a) {
            i += (t[s] - t[n]) * (t[n + 1] + t[s + 1]), s = n;
          }

          return i;
        }(t, e, r, a) > 0) for (n = e; n < r; n += a) {
          s = qt(n, t[n], t[n + 1], s);
        } else for (n = r - a; n >= e; n -= a) {
          s = qt(n, t[n], t[n + 1], s);
        }
        return s && zt(s, s.next) && (Xt(s), s = s.next), s;
      }

      function Et(t, e) {
        if (void 0 === e && (e = null), !t) return t;
        e || (e = t);
        var r = t,
            a = !1;

        do {
          if (a = !1, r.steiner || !zt(r, r.next) && 0 !== Ut(r.prev, r, r.next)) r = r.next;else {
            if (Xt(r), (r = e = r.prev) === r.next) return null;
            a = !0;
          }
        } while (a || r !== e);

        return e;
      }

      function At(t, e, r, a, i, n, s) {
        if (void 0 === s && (s = 0), t) {
          !s && n && function (t, e, r, a) {
            var i = t;

            do {
              null === i.z && (i.z = Ht(i.x, i.y, e, r, a)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next;
            } while (i !== t);

            i.prevZ.nextZ = null, i.prevZ = null, function (t) {
              var e = 0,
                  r = null,
                  a = null,
                  i = null,
                  n = null,
                  s = 0,
                  o = 0,
                  h = 0,
                  u = 1;

              do {
                for (r = t, t = null, n = null, s = 0; r;) {
                  for (s++, a = r, o = 0, e = 0; e < u && (o++, a = a.nextZ); e++) {
                    ;
                  }

                  for (h = u; o > 0 || h > 0 && a;) {
                    0 === o ? (i = a, a = a.nextZ, h--) : 0 !== h && a ? r.z <= a.z ? (i = r, r = r.nextZ, o--) : (i = a, a = a.nextZ, h--) : (i = r, r = r.nextZ, o--), n ? n.nextZ = i : t = i, i.prevZ = n, n = i;
                  }

                  r = a;
                }

                n.nextZ = null, u *= 2;
              } while (s > 1);
            }(i);
          }(t, a, i, n);

          for (var o = t, h = null, u = null; t.prev !== t.next;) {
            if (h = t.prev, u = t.next, n ? Rt(t, a, i, n) : Lt(t)) e.push(h.i / r), e.push(t.i / r), e.push(u.i / r), Xt(t), t = u.next, o = u.next;else if ((t = u) === o) {
              s ? 1 === s ? At(t = Ft(t, e, r), e, r, a, i, n, 2) : 2 === s && Pt(t, e, r, a, i, n) : At(Et(t), e, r, a, i, n, 1);
              break;
            }
          }
        }
      }

      function Lt(t) {
        var e = t.prev,
            r = t,
            a = t.next;
        if (Ut(e, r, a) >= 0) return !1;

        for (var i = t.next.next; i !== t.prev;) {
          if (Vt(e.x, e.y, r.x, r.y, a.x, a.y, i.x, i.y) && Ut(i.prev, i, i.next) >= 0) return !1;
          i = i.next;
        }

        return !0;
      }

      function Rt(t, e, r, a) {
        var i = t.prev,
            n = t,
            s = t.next;
        if (Ut(i, n, s) >= 0) return !1;

        for (var o = i.x < n.x ? i.x < s.x ? i.x : s.x : n.x < s.x ? n.x : s.x, h = i.y < n.y ? i.y < s.y ? i.y : s.y : n.y < s.y ? n.y : s.y, u = i.x > n.x ? i.x > s.x ? i.x : s.x : n.x > s.x ? n.x : s.x, c = i.y > n.y ? i.y > s.y ? i.y : s.y : n.y > s.y ? n.y : s.y, l = Ht(o, h, e, r, a), f = Ht(u, c, e, r, a), d = t.nextZ; d && d.z <= f;) {
          if (d !== t.prev && d !== t.next && Vt(i.x, i.y, n.x, n.y, s.x, s.y, d.x, d.y) && Ut(d.prev, d, d.next) >= 0) return !1;
          d = d.nextZ;
        }

        for (d = t.prevZ; d && d.z >= l;) {
          if (d !== t.prev && d !== t.next && Vt(i.x, i.y, n.x, n.y, s.x, s.y, d.x, d.y) && Ut(d.prev, d, d.next) >= 0) return !1;
          d = d.prevZ;
        }

        return !0;
      }

      function Ft(t, e, r) {
        var a = t;

        do {
          var i = a.prev,
              n = a.next.next;
          !zt(i, n) && Wt(i, a, a.next, n) && Zt(i, n) && Zt(n, i) && (e.push(i.i / r), e.push(a.i / r), e.push(n.i / r), Xt(a), Xt(a.next), a = t = n), a = a.next;
        } while (a !== t);

        return a;
      }

      function Pt(t, e, r, a, i, n) {
        var s = t;

        do {
          for (var o = s.next.next; o !== s.prev;) {
            if (s.i !== o.i && Nt(s, o)) {
              var h = Gt(s, o);
              return s = Et(s, s.next), h = Et(h, h.next), At(s, e, r, a, i, n), void At(h, e, r, a, i, n);
            }

            o = o.next;
          }

          s = s.next;
        } while (s !== t);
      }

      function It(t, e) {
        return t.x - e.x;
      }

      function Ot(t, e) {
        if (e = function (t, e) {
          var r = e,
              a = t.x,
              i = t.y,
              n = -1 / 0,
              s = null;

          do {
            if (i <= r.y && i >= r.next.y) {
              var o = r.x + (i - r.y) * (r.next.x - r.x) / (r.next.y - r.y);

              if (o <= a && o > n) {
                if (n = o, o === a) {
                  if (i === r.y) return r;
                  if (i === r.next.y) return r.next;
                }

                s = r.x < r.next.x ? r : r.next;
              }
            }

            r = r.next;
          } while (r !== e);

          if (!s) return null;
          if (a === n) return s.prev;
          var h,
              u = s,
              c = s.x,
              l = s.y,
              f = 1 / 0;

          for (r = s.next; r !== u;) {
            a >= r.x && r.x >= c && Vt(i < l ? a : n, i, c, l, i < l ? n : a, i, r.x, r.y) && ((h = Math.abs(i - r.y) / (a - r.x)) < f || h === f && r.x > s.x) && Zt(r, t) && (s = r, f = h), r = r.next;
          }

          return s;
        }(t, e)) {
          var r = Gt(e, t);
          Et(r, r.next);
        }
      }

      function Ht(t, e, r, a, i) {
        return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - r) / i) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - a) / i) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1;
      }

      function kt(t) {
        var e = t,
            r = t;

        do {
          e.x < r.x && (r = e), e = e.next;
        } while (e !== t);

        return r;
      }

      function Vt(t, e, r, a, i, n, s, o) {
        return (i - s) * (e - o) - (t - s) * (n - o) >= 0 && (t - s) * (a - o) - (r - s) * (e - o) >= 0 && (r - s) * (n - o) - (i - s) * (a - o) >= 0;
      }

      function Nt(t, e) {
        return t.next.i !== e.i && t.prev.i !== e.i && !function (t, e) {
          var r = t;

          do {
            if (r.i !== t.i && r.next.i !== t.i && r.i !== e.i && r.next.i !== e.i && Wt(r, r.next, t, e)) return !0;
            r = r.next;
          } while (r !== t);

          return !1;
        }(t, e) && Zt(t, e) && Zt(e, t) && function (t, e) {
          var r = t,
              a = !1,
              i = (t.x + e.x) / 2,
              n = (t.y + e.y) / 2;

          do {
            r.y > n != r.next.y > n && i < (r.next.x - r.x) * (n - r.y) / (r.next.y - r.y) + r.x && (a = !a), r = r.next;
          } while (r !== t);

          return a;
        }(t, e);
      }

      function Ut(t, e, r) {
        return (e.y - t.y) * (r.x - e.x) - (e.x - t.x) * (r.y - e.y);
      }

      function zt(t, e) {
        return t.x === e.x && t.y === e.y;
      }

      function Wt(t, e, r, a) {
        return !!(zt(t, e) && zt(r, a) || zt(t, a) && zt(r, e)) || Ut(t, e, r) > 0 != Ut(t, e, a) > 0 && Ut(r, a, t) > 0 != Ut(r, a, e) > 0;
      }

      function Zt(t, e) {
        return Ut(t.prev, t, t.next) < 0 ? Ut(t, e, t.next) >= 0 && Ut(t, t.prev, e) >= 0 : Ut(t, e, t.prev) < 0 || Ut(t, t.next, e) < 0;
      }

      function Gt(t, e) {
        var r = new Mt(t.i, t.x, t.y),
            a = new Mt(e.i, e.x, e.y),
            i = t.next,
            n = e.prev;
        return t.next = e, e.prev = t, r.next = i, i.prev = r, a.next = r, r.prev = a, n.next = a, a.prev = n, a;
      }

      function qt(t, e, r, a) {
        var i = new Mt(t, e, r);
        return a ? (i.next = a.next, i.prev = a, a.next.prev = i, a.next = i) : (i.prev = i, i.next = i), i;
      }

      function Xt(t) {
        t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ);
      }

      function jt(t, e, r) {
        r = r || 3;
        var a = e ? e.length : 0,
            i = a ? e[0] * r : t.length,
            n = Bt(t, 0, i, r, !0),
            s = [];
        if (!n) return s;
        var o = 0,
            h = 0,
            u = 0,
            c = 0,
            l = 0,
            f = 0,
            d = 0;

        if (a && (n = function (t, e, r, a) {
          var i,
              n = [],
              s = 0,
              o = null;

          for (s = 0, i = e.length; s < i; s++) {
            (o = Bt(t, e[s] * a, s < i - 1 ? e[s + 1] * a : t.length, a, !1)) && (o === o.next && (o.steiner = !0), n.push(kt(o)));
          }

          if (n.sort(It), !r) return r;

          for (s = 0; s < n.length; s++) {
            Ot(n[s], r), r = Et(r, r.next);
          }

          return r;
        }(t, e, n, r)), t.length > 80 * r) {
          o = u = t[0], h = c = t[1];

          for (var v = r; v < i; v += r) {
            (l = t[v]) < o && (o = l), (f = t[v + 1]) < h && (h = f), l > u && (u = l), f > c && (c = f);
          }

          d = Math.max(u - o, c - h);
        }

        return At(n, s, r, o, h, d), s;
      }

      for (var Kt = Math.PI, Qt = Math.min, Yt = Math.max, Jt = Math.ceil, $t = Math.acos, te = Math.cos, ee = Math.sin, re = Math.atan2, ae = null, ie = null, ne = new w(), se = [], oe = 0; oe < 4; oe++) {
        se.push(new m());
      }

      function he(t, e, r) {
        return t < e ? e : t > r ? r : t;
      }

      var ue = {
        useModel: !0,
        updateRenderData: function updateRenderData() {},
        fillBuffers: function fillBuffers() {},
        renderIA: function renderIA() {},
        getRenderData: function getRenderData(t, e) {
          if (!ie) return null;
          var r = ie.getRenderDataList(),
              a = r[ie.dataOffset];
          if (!a) return null;
          var i = a,
              n = i ? i.vertexStart + e : 0;
          return (n > 65535 || 3 * n > 131070) && (++ie.dataOffset, ie.dataOffset < r.length ? a = r[ie.dataOffset] : (a = ie.requestRenderData(), r[ie.dataOffset] = a), i = a), i && i.vertexCount < n && i.request(e, 3 * e), a;
        },
        stroke: function stroke(t) {
          w.copy(ne, t.strokeColor), t.impl && (this._flattenPaths(t.impl), this._expandStroke(t), t.impl.updatePathOffset = !0, this.end(t));
        },
        fill: function fill(t) {
          w.copy(ne, t.fillColor), this._expandFill(t), t.impl && (t.impl.updatePathOffset = !0), this.end(t);
        },
        end: function end(t) {
          t.markForUpdateRenderData();
        },
        _expandStroke: function _expandStroke(t) {
          var e = .5 * t.lineWidth,
              r = t.lineCap,
              a = t.lineJoin,
              i = t.miterLimit;

          if (ie = t.impl) {
            var n,
                s,
                o,
                h,
                u = (n = e, s = Kt, o = ie.tessTol, h = 2 * $t(n / (n + o)), Yt(2, Jt(s / h)));

            this._calculateJoins(ie, e, a, i);

            for (var c = ie.paths, l = 0, f = ie.pathOffset, d = ie.pathLength; f < d; f++) {
              var v = c[f],
                  p = v.points.length;
              a === ft.ROUND ? l += 2 * (p + v.bevel * (u + 2) + 1) : l += 2 * (p + 5 * v.bevel + 1), v.closed || (r === dt.ROUND ? l += 2 * (2 * u + 2) : l += 12);
            }

            var _ = ae = this.getRenderData(t, l);

            if (_) {
              for (var x = _.vData, g = _.iData, y = ie.pathOffset, m = ie.pathLength; y < m; y++) {
                var S = c[y],
                    D = S.points,
                    w = D.length,
                    b = _.vertexStart,
                    T = void 0,
                    C = void 0,
                    M = 0,
                    B = 0,
                    E = S.closed;

                if (E ? (T = D[w - 1], C = D[0], M = 0, B = w) : (T = D[0], C = D[1], M = 1, B = w - 1), C = C || T, !E) {
                  var A = new vt(C.x, C.y);
                  A.subtract(T), A.normalize();
                  var L = A.x,
                      R = A.y;
                  r === dt.BUTT ? this._buttCapStart(T, L, R, e, 0) : r === dt.SQUARE ? this._buttCapStart(T, L, R, e, e) : r === dt.ROUND && this._roundCapStart(T, L, R, e, u);
                }

                for (var F = M; F < B; ++F) {
                  a === ft.ROUND ? this._roundJoin(T, C, e, e, u) : 0 != (C.flags & (pt.PT_BEVEL | pt.PT_INNERBEVEL)) ? this._bevelJoin(T, C, e, e) : (this._vSet(C.x + C.dmx * e, C.y + C.dmy * e, 1), this._vSet(C.x - C.dmx * e, C.y - C.dmy * e, -1)), T = C, C = D[F + 1];
                }

                if (E) {
                  var P = 8 * b;
                  this._vSet(x[P], x[P + 1], 1), this._vSet(x[P + 8], x[P + 8 + 1], -1);
                } else {
                  var I = new vt(C.x, C.y);
                  I.subtract(T), I.normalize();
                  var O = I.x,
                      H = I.y;
                  r === dt.BUTT ? this._buttCapEnd(C, O, H, e, 0) : r === dt.SQUARE ? this._buttCapEnd(C, O, H, e, e) : r === dt.ROUND && this._roundCapEnd(C, O, H, e, u);
                }

                for (var k = _.indexStart, V = b + 2, N = _.vertexStart; V < N; V++) {
                  g[k++] = V - 2, g[k++] = V - 1, g[k++] = V;
                }

                _.indexStart = k;
              }

              ae = null, ie = null;
            }
          }
        },
        _expandFill: function _expandFill(t) {
          if (ie = t.impl) {
            for (var e = ie.paths, r = 0, a = ie.pathOffset, i = ie.pathLength; a < i; a++) {
              r += e[a].points.length;
            }

            var n = ae = this.getRenderData(t, r);

            if (n) {
              for (var s = n, o = s.vData, h = s.iData, u = ie.pathOffset, c = ie.pathLength; u < c; u++) {
                var l = e[u],
                    f = l.points,
                    d = f.length;

                if (0 !== d) {
                  for (var v = n.vertexStart, p = 0; p < d; ++p) {
                    this._vSet(f[p].x, f[p].y);
                  }

                  var _ = n.indexStart;

                  if (l.complex) {
                    for (var x = [], g = v, y = n.vertexStart; g < y; g++) {
                      var m = 8 * g;
                      x.push(o[m++]), x.push(o[m++]), x.push(o[m++]);
                    }

                    var S = jt(x, null, 3);
                    if (!S || 0 === S.length) continue;

                    for (var D = 0, w = S.length; D < w; D++) {
                      h[_++] = S[D] + v;
                    }
                  } else for (var b = v, T = v + 2, C = s.vertexStart; T < C; T++) {
                    h[_++] = b, h[_++] = T - 1, h[_++] = T;
                  }

                  s.indexStart = _;
                }
              }

              ae = null, ie = null;
            }
          }
        },
        _calculateJoins: function _calculateJoins(t, e, r, a) {
          var i = 0;
          e > 0 && (i = 1 / e);

          for (var n = t.paths, s = t.pathOffset, o = t.pathLength; s < o; s++) {
            var h = n[s],
                u = h.points,
                c = u.length,
                l = u[c - 1],
                f = u[0];
            h.bevel = 0;

            for (var d = 0; d < c; d++) {
              var v,
                  p,
                  _ = l.dy,
                  x = -l.dx,
                  g = f.dy,
                  y = -f.dx;

              if (f.dmx = .5 * (_ + g), f.dmy = .5 * (x + y), (v = f.dmx * f.dmx + f.dmy * f.dmy) > 1e-6) {
                var m = 1 / v;
                m > 600 && (m = 600), f.dmx *= m, f.dmy *= m;
              }

              f.dx * l.dy - l.dx * f.dy > 0 && (f.flags |= pt.PT_LEFT), v * (p = Yt(11, Qt(l.len, f.len) * i)) * p < 1 && (f.flags |= pt.PT_INNERBEVEL), f.flags & pt.PT_CORNER && (v * a * a < 1 || r === ft.BEVEL || r === ft.ROUND) && (f.flags |= pt.PT_BEVEL), 0 != (f.flags & (pt.PT_BEVEL | pt.PT_INNERBEVEL)) && h.bevel++, l = f, f = u[d + 1];
            }
          }
        },
        _flattenPaths: function _flattenPaths(t) {
          for (var e = t.paths, r = t.pathOffset, a = t.pathLength; r < a; r++) {
            var i = e[r],
                n = i.points,
                s = n[n.length - 1],
                o = n[0];
            n.length > 2 && s.equals(o) && (i.closed = !0, n.pop(), s = n[n.length - 1]);

            for (var h = 0, u = n.length; h < u; h++) {
              var c = new vt(o.x, o.y);
              c.subtract(s), s.len = c.length(), (c.x || c.y) && c.normalize(), s.dx = c.x, s.dy = c.y, s = o, o = n[h + 1];
            }
          }
        },
        _chooseBevel: function _chooseBevel(t, e, r, a) {
          var i = r.x,
              n = r.y,
              s = 0,
              o = 0,
              h = 0,
              u = 0;
          return 0 !== t ? (s = i + e.dy * a, o = n - e.dx * a, h = i + r.dy * a, u = n - r.dx * a) : (s = h = i + r.dmx * a, o = u = n + r.dmy * a), [s, o, h, u];
        },
        _buttCapStart: function _buttCapStart(t, e, r, a, i) {
          var n = t.x - e * i,
              s = t.y - r * i,
              o = r,
              h = -e;
          this._vSet(n + o * a, s + h * a, 1), this._vSet(n - o * a, s - h * a, -1);
        },
        _buttCapEnd: function _buttCapEnd(t, e, r, a, i) {
          var n = t.x + e * i,
              s = t.y + r * i,
              o = r,
              h = -e;
          this._vSet(n + o * a, s + h * a, 1), this._vSet(n - o * a, s - h * a, -1);
        },
        _roundCapStart: function _roundCapStart(t, e, r, a, i) {
          for (var n = t.x, s = t.y, o = r, h = -e, u = 0; u < i; u++) {
            var c = u / (i - 1) * Kt,
                l = te(c) * a,
                f = ee(c) * a;
            this._vSet(n - o * l - e * f, s - h * l - r * f, 1), this._vSet(n, s, 0);
          }

          this._vSet(n + o * a, s + h * a, 1), this._vSet(n - o * a, s - h * a, -1);
        },
        _roundCapEnd: function _roundCapEnd(t, e, r, a, i) {
          var n = t.x,
              s = t.y,
              o = r,
              h = -e;
          this._vSet(n + o * a, s + h * a, 1), this._vSet(n - o * a, s - h * a, -1);

          for (var u = 0; u < i; u++) {
            var c = u / (i - 1) * Kt,
                l = te(c) * a,
                f = ee(c) * a;
            this._vSet(n, s, 0), this._vSet(n - o * l + e * f, s - h * l + r * f, 1);
          }
        },
        _roundJoin: function _roundJoin(t, e, r, a, i) {
          var n = t.dy,
              s = -t.dx,
              o = e.dy,
              h = -e.dx,
              u = e.x,
              c = e.y;

          if (0 != (e.flags & pt.PT_LEFT)) {
            var l = this._chooseBevel(e.flags & pt.PT_INNERBEVEL, t, e, r),
                f = l[0],
                d = l[1],
                v = l[2],
                p = l[3],
                _ = re(-s, -n),
                x = re(-h, -o);

            x > _ && (x -= 2 * Kt), this._vSet(f, d, 1), this._vSet(u - n * a, e.y - s * a, -1);

            for (var g = he(Jt((_ - x) / Kt) * i, 2, i), y = 0; y < g; y++) {
              var m = _ + y / (g - 1) * (x - _),
                  S = u + te(m) * a,
                  D = c + ee(m) * a;
              this._vSet(u, c, 0), this._vSet(S, D, -1);
            }

            this._vSet(v, p, 1), this._vSet(u - o * a, c - h * a, -1);
          } else {
            var w = this._chooseBevel(e.flags & pt.PT_INNERBEVEL, t, e, -a),
                b = w[0],
                T = w[1],
                C = w[2],
                M = w[3],
                B = re(s, n),
                E = re(h, o);

            E < B && (E += 2 * Kt), this._vSet(u + n * a, c + s * a, 1), this._vSet(b, T, -1);

            for (var A = he(Jt((E - B) / Kt) * i, 2, i), L = 0; L < A; L++) {
              var R = B + L / (A - 1) * (E - B),
                  F = u + te(R) * r,
                  P = c + ee(R) * r;
              this._vSet(F, P, 1), this._vSet(u, c, 0);
            }

            this._vSet(u + o * a, c + h * a, 1), this._vSet(C, M, -1);
          }
        },
        _bevelJoin: function _bevelJoin(t, e, r, a) {
          var i = 0,
              n = 0,
              s = 0,
              o = 0,
              h = 0,
              u = 0,
              c = 0,
              l = 0,
              f = t.dy,
              d = -t.dx,
              v = e.dy,
              p = -e.dx;

          if (e.flags & pt.PT_LEFT) {
            var _ = this._chooseBevel(e.flags & pt.PT_INNERBEVEL, t, e, r);

            h = _[0], u = _[1], c = _[2], l = _[3], this._vSet(h, u, 1), this._vSet(e.x - f * a, e.y - d * a, -1), this._vSet(c, l, 1), this._vSet(e.x - v * a, e.y - p * a, -1);
          } else {
            var x = this._chooseBevel(e.flags & pt.PT_INNERBEVEL, t, e, -a);

            i = x[0], n = x[1], s = x[2], o = x[3], this._vSet(e.x + f * r, e.y + d * r, 1), this._vSet(i, n, -1), this._vSet(e.x + v * r, e.y + p * r, 1), this._vSet(s, o, -1);
          }
        },
        _vSet: function _vSet(t, e, r) {
          if (void 0 === r && (r = 0), ae) {
            var a = ae,
                i = 8 * a.vertexStart,
                n = a.vData;
            n[i++] = t, n[i++] = e, n[i++] = 0, w.toArray(n, ne, i), i += 4, n[i++] = r, a.vertexStart++;
          }
        }
      },
          ce = t("g", {
        getAssembler: function getAssembler() {
          return ue;
        }
      });
      _t.Assembler = ce;

      var le = function le() {
        this.char = "", this.valid = !0, this.x = 0, this.y = 0, this.line = 0, this.hash = "";
      },
          fe = new b(),
          de = null,
          ve = null,
          pe = [],
          _e = [],
          xe = [],
          ge = [],
          ye = new T(),
          me = new T(),
          Se = new C(),
          De = null,
          we = 0,
          be = 0,
          Te = 0,
          Ce = 0,
          Me = 0,
          Be = 1,
          Ee = null,
          Ae = "",
          Le = 0,
          Re = 0,
          Fe = 0,
          Pe = 0,
          Ie = 0,
          Oe = 0,
          He = 0,
          ke = !1,
          Ve = 0,
          Ne = 0,
          Ue = 0,
          ze = {
        updateRenderData: function updateRenderData(t) {
          t.renderData && de !== t && (t.renderData.vertDirty && (ve = (de = t).node._uiProps.uiTransformComp, this._updateFontFamily(t), this._updateProperties(t), this._updateLabelInfo(t), this._updateContent(), de.actualFontSize = Le, ve.setContentSize(me), this.updateUVs(t), de.renderData.vertDirty = !1, de.markForUpdateRenderData(!1), de = null, this._resetProperties()), t.spriteFrame && t.renderData.updateRenderData(t, t.spriteFrame));
        },
        updateUVs: function updateUVs(t) {
          for (var e = t.renderData, r = e.chunk.vb, a = e.vertexCount, i = e.data, n = 3, s = 0; s < a; s++) {
            var o = i[s];
            r[n] = o.u, r[n + 1] = o.v, n += 9;
          }
        },
        _updateFontScale: function _updateFontScale() {
          Be = Le / Re;
        },
        _updateFontFamily: function _updateFontFamily(t) {
          var e = t.font;
          Ee = e.spriteFrame, De = e.fntConfig, Z.fontAtlas = e.fontDefDictionary, z.packToDynamicAtlas(t, Ee);
        },
        _updateLabelInfo: function _updateLabelInfo() {
          Z.hash = "", Z.margin = 0;
        },
        _updateProperties: function _updateProperties(t) {
          Ae = t.string.toString(), Le = t.fontSize, Re = De ? De.fontSize : t.fontSize, Fe = t.horizontalAlign, Pe = t.verticalAlign, Ie = t.spacingX, He = t.overflow, Oe = t._lineHeight;
          var e = ve.contentSize;
          me.width = e.width, me.height = e.height, He === G.NONE ? (ke = !1, me.width += 2 * Z.margin, me.height += 2 * Z.margin) : He === G.RESIZE_HEIGHT ? (ke = !0, me.height += 2 * Z.margin) : ke = t.enableWrapText, Z.lineHeight = Oe, Z.fontSize = Le, this._setupBMFontOverflowMetrics();
        },
        _resetProperties: function _resetProperties() {
          De = null, Ee = null, Z.hash = "", Z.margin = 0;
        },
        _updateContent: function _updateContent() {
          this._updateFontScale(), this._computeHorizontalKerningForText(), this._alignText();
        },
        _computeHorizontalKerningForText: function _computeHorizontalKerningForText() {
          for (var t = Ae, e = t.length, r = De.kerningDict, a = pe, i = -1, n = 0; n < e; ++n) {
            var s = t.charCodeAt(n),
                o = r[i << 16 | 65535 & s] || 0;
            a[n] = n < e - 1 ? o : 0, i = s;
          }
        },
        _multilineTextWrap: function _multilineTextWrap(t) {
          for (var e = Ae.length, r = 0, a = 0, i = 0, n = 0, s = 0, o = 0, h = 0, u = null, c = 0; c < e;) {
            var l = Ae.charAt(c);

            if ("\n" !== l) {
              for (var f = t(Ae, c, e), d = o, v = h, p = s, _ = a, x = !1, g = 0; g < f; ++g) {
                var y = c + g;
                if ("\r" !== (l = Ae.charAt(y))) {
                  if (u = Z.fontAtlas.getLetterDefinitionForChar(l, Z)) {
                    var m = _ + u.offsetX * Be - Z.margin;

                    if (ke && Ue > 0 && a > 0 && m + u.w * Be > Ue && !q(l)) {
                      xe.push(s), s = 0, r++, a = 0, i -= Oe * this._getFontScale() + 0, x = !0;
                      break;
                    }

                    Se.x = m, Se.y = i - u.offsetY * Be, this._recordLetterInfo(Se, l, y, r), y + 1 < pe.length && y < e - 1 && (_ += pe[y + 1]), _ += u.xAdvance * Be + Ie, p = Se.x + u.w * Be, d < Se.y && (d = Se.y), v > Se.y - u.h * Be && (v = Se.y - u.h * Be);
                  } else this._recordPlaceholderInfo(y, l), console.log("Can't find letter definition in texture atlas " + De.atlasName + " for letter:" + l);
                } else this._recordPlaceholderInfo(y, l);
              }

              x || (a = _, o < d && (o = d), h > v && (h = v), n < (s = p) && (n = s), c += f);
            } else xe.push(s), s = 0, r++, a = 0, i -= Oe * this._getFontScale() + 0, this._recordPlaceholderInfo(c, l), c++;
          }

          return xe.push(s), be = (we = r + 1) * Oe * this._getFontScale(), we > 1 && (be += 0 * (we - 1)), me.width = Ve, me.height = Ne, Ve <= 0 && (me.width = parseFloat(n.toFixed(2)) + 2 * Z.margin), Ne <= 0 && (me.height = parseFloat(be.toFixed(2)) + 2 * Z.margin), Ce = me.height, Me = 0, o > 0 && (Ce = me.height + o), h < -be && (Me = be + h), !0;
        },
        _getFirstCharLen: function _getFirstCharLen() {
          return 1;
        },
        _getFontScale: function _getFontScale() {
          return He === G.SHRINK ? Be : 1;
        },
        _getFirstWordLen: function _getFirstWordLen(t, e, r) {
          var a = t.charAt(e);
          if (X(a) || "\n" === a || q(a)) return 1;
          var i = 1,
              n = Z.fontAtlas.getLetterDefinitionForChar(a, Z);
          if (!n) return i;

          for (var s = n.xAdvance * Be + Ie, o = e + 1; o < r && (a = t.charAt(o), n = Z.fontAtlas.getLetterDefinitionForChar(a, Z)); ++o) {
            if (s + n.offsetX * Be + n.w * Be > Ue && !q(a) && Ue > 0) return i;
            if (s += n.xAdvance * Be + Ie, "\n" === a || q(a) || X(a)) break;
            i++;
          }

          return i;
        },
        _multilineTextWrapByWord: function _multilineTextWrapByWord() {
          return this._multilineTextWrap(this._getFirstWordLen);
        },
        _multilineTextWrapByChar: function _multilineTextWrapByChar() {
          return this._multilineTextWrap(this._getFirstCharLen);
        },
        _recordPlaceholderInfo: function _recordPlaceholderInfo(t, e) {
          if (t >= _e.length) {
            var r = new le();

            _e.push(r);
          }

          _e[t].char = e, _e[t].hash = "" + e.charCodeAt(0) + Z.hash, _e[t].valid = !1;
        },
        _recordLetterInfo: function _recordLetterInfo(t, e, r, a) {
          if (r >= _e.length) {
            var i = new le();

            _e.push(i);
          }

          var n = "" + e.charCodeAt(0) + Z.hash;
          _e[r].line = a, _e[r].char = e, _e[r].hash = n, _e[r].valid = Z.fontAtlas.getLetter(n).valid, _e[r].x = t.x, _e[r].y = t.y;
        },
        _alignText: function _alignText() {
          be = 0, xe.length = 0, this._multilineTextWrapByWord(), this._computeAlignmentOffset(), He === G.SHRINK && Le > 0 && this._isVerticalClamp() && this._shrinkLabelToContentSize(this._isVerticalClamp), this._updateQuads() || He === G.SHRINK && this._shrinkLabelToContentSize(this._isHorizontalClamp);
        },
        _scaleFontSizeDown: function _scaleFontSizeDown(t) {
          var e = !0;
          t || (t = .1, e = !1), Le = t, e && this._updateContent();
        },
        _shrinkLabelToContentSize: function _shrinkLabelToContentSize(t) {
          for (var e = 0, r = 0 | Le, a = 0; e < r;) {
            var i = a = e + r + 1 >> 1;
            if (i <= 0) break;
            Be = i / Re, this._multilineTextWrapByWord(), this._computeAlignmentOffset(), t() ? r = a - 1 : e = a;
          }

          e >= 0 && this._scaleFontSizeDown(e);
        },
        _isVerticalClamp: function _isVerticalClamp() {
          return be > me.height;
        },
        _isHorizontalClamp: function _isHorizontalClamp() {
          for (var t = !1, e = 0, r = Ae.length; e < r; ++e) {
            var a = _e[e];

            if (a.valid) {
              var i = Z.fontAtlas.getLetterDefinitionForChar(a.char, Z);
              if (!i) continue;
              var n = a.x + i.w * Be,
                  s = a.line;
              if (Ve > 0) if (ke) {
                if (xe[s] > me.width && (n > me.width || n < 0)) {
                  t = !0;
                  break;
                }
              } else if (n > me.width) {
                t = !0;
                break;
              }
            }
          }

          return t;
        },
        _isHorizontalClamped: function _isHorizontalClamped(t, e) {
          var r = xe[e],
              a = t > me.width || t < 0;
          return ke ? r > me.width && a : a;
        },
        _updateQuads: function _updateQuads() {
          if (!de) return !1;
          var t = Ee ? Ee.texture : Z.fontAtlas.getTexture(),
              e = de.renderData;
          e.dataLength = 0, e.resize(0, 0);

          for (var r = ve.anchorPoint, a = me, i = r.x * a.width, n = r.y * a.height, s = !0, o = 0, h = Ae.length; o < h; ++o) {
            var u = _e[o];

            if (u.valid) {
              var c = Z.fontAtlas.getLetter(u.hash);

              if (c) {
                fe.height = c.h, fe.width = c.w, fe.x = c.u, fe.y = c.v;
                var l = u.y + Te;

                if (Ne > 0) {
                  if (l > Ce) {
                    var f = l - Ce;
                    fe.y += f, fe.height -= f, l -= f;
                  }

                  l - c.h * Be < Me && He === G.CLAMP && (fe.height = l < Me ? 0 : (l - Me) / Be);
                }

                var d = u.line,
                    v = u.x + c.w / 2 * Be + ge[d];
                if (Ve > 0 && this._isHorizontalClamped(v, d)) if (He === G.CLAMP) fe.width = 0;else if (He === G.SHRINK) {
                  if (me.width > c.w) {
                    s = !1;
                    break;
                  }

                  fe.width = 0;
                }

                if (fe.height > 0 && fe.width > 0) {
                  var p = this._determineRect(),
                      _ = u.x + ge[u.line];

                  this.appendQuad(de, t, fe, p, _ - i, l - n, Be);
                }
              } else console.warn("Can't find letter in this bitmap-font");
            }
          }

          return s;
        },
        appendQuad: function appendQuad() {},
        _determineRect: function _determineRect() {
          var t = Ee.isRotated(),
              e = Ee.getOriginalSize(),
              r = Ee.getRect(),
              a = Ee.getOffset(),
              i = a.x + (e.width - r.width) / 2,
              n = a.y - (e.height - r.height) / 2;

          if (t) {
            var s = fe.x;
            fe.x = r.x + r.height - fe.y - fe.height - n, fe.y = s + r.y - i, fe.y < 0 && (fe.height += n);
          } else fe.x += r.x - i, fe.y += r.y + n;

          return t;
        },
        _computeAlignmentOffset: function _computeAlignmentOffset() {
          switch (ge.length = 0, Fe) {
            case j.LEFT:
              for (var t = 0; t < we; ++t) {
                ge.push(0);
              }

              break;

            case j.CENTER:
              for (var e = 0, r = xe.length; e < r; e++) {
                ge.push((me.width - xe[e]) / 2);
              }

              break;

            case j.RIGHT:
              for (var a = 0, i = xe.length; a < i; a++) {
                ge.push(me.width - xe[a]);
              }

          }

          if (Te = me.height, Pe !== K.TOP) {
            var n = me.height - be + Oe * this._getFontScale() - Re * Be;
            Pe === K.BOTTOM ? Te -= n : Te -= n / 2;
          }
        },
        _setupBMFontOverflowMetrics: function _setupBMFontOverflowMetrics() {
          var t = me.width,
              e = me.height;
          He === G.RESIZE_HEIGHT && (e = 0), He === G.NONE && (t = 0, e = 0), Ve = t, Ne = e, ye.width = t, ye.height = e, Ue = t;
        }
      },
          We = new w(255, 255, 255, 255),
          Ze = {
        createData: function createData(t) {
          return t.requestRenderData();
        },
        fillBuffers: function fillBuffers(t) {
          var e = t.node;
          We.set(t.color), We.a = 255 * e._uiProps.opacity, Ct(e, 0, t.renderData, We);
        },
        appendQuad: function appendQuad(t, e, r, a, i, n, s) {
          var o = t.renderData;

          if (o) {
            var h = o.dataLength;
            o.dataLength += 4, o.resize(o.dataLength, o.dataLength / 2 * 3);
            var u = o.data,
                c = e.width,
                l = e.height,
                f = r.width,
                d = r.height,
                v = 0,
                p = 0,
                _ = 0,
                x = 0;
            a ? (v = r.x / c, x = (r.x + d) / c, p = (r.y + f) / l, _ = r.y / l, u[h].u = v, u[h].v = _, u[h + 1].u = v, u[h + 1].v = p, u[h + 2].u = x, u[h + 2].v = _, u[h + 3].u = x, u[h + 3].v = p) : (v = r.x / c, x = (r.x + f) / c, p = (r.y + d) / l, _ = r.y / l, u[h].u = v, u[h].v = p, u[h + 1].u = x, u[h + 1].v = p, u[h + 2].u = v, u[h + 2].v = _, u[h + 3].u = x, u[h + 3].v = _), u[h].x = i, u[h].y = n - d * s, u[h + 1].x = i + f * s, u[h + 1].y = n - d * s, u[h + 2].x = i, u[h + 2].y = n, u[h + 3].x = i + f * s, u[h + 3].y = n;
          }
        },
        updateColor: function updateColor() {}
      };

      r(Ze, ze);
      var Ge = null,
          qe = a(ze, {
        getAssemblerData: function getAssemblerData() {
          return Ge || (Ge = new Q(1024, 1024)), Ge.getTexture();
        },
        _updateFontFamily: function _updateFontFamily(t) {
          Z.fontAtlas = Ge, Z.fontFamily = this._getFontFamily(t);
          var e = t.getComponent(xt);
          e && e.enabled ? (Z.isOutlined = !0, Z.margin = e.width, Z.out = e.color.clone(), Z.out.a = e.color.a * t.color.a / 255) : (Z.isOutlined = !1, Z.margin = 0);
        },
        _getFontFamily: function _getFontFamily(t) {
          var e = "Arial";
          return t.useSystemFont ? e = t.fontFamily || "Arial" : t.font && (e = t.font._nativeAsset || "Arial"), e;
        },
        _updateLabelInfo: function _updateLabelInfo(t) {
          Z.fontDesc = this._getFontDesc(), Z.color = t.color, Z.hash = Y(Z);
        },
        _getFontDesc: function _getFontDesc() {
          return Z.fontSize.toString() + "px " + Z.fontFamily;
        },
        _computeHorizontalKerningForText: function _computeHorizontalKerningForText() {},
        _determineRect: function _determineRect() {
          return !1;
        }
      }),
          Xe = new w(255, 255, 255, 255),
          je = {
        createData: function createData(t) {
          return t.requestRenderData();
        },
        fillBuffers: function fillBuffers(t) {
          if (t.renderData) {
            var e = t.node;
            Xe.a = 255 * e._uiProps.opacity, Ct(e, 0, t.renderData, Xe);
          }
        },
        updateColor: function updateColor() {},
        appendQuad: Ze.appendQuad
      };
      r(je, qe);
      var Ke = J.Overflow,
          Qe = rt(),
          Ye = (1 / 255).toFixed(3),
          Je = null,
          $e = null,
          tr = null,
          er = "",
          rr = "",
          ar = 0,
          ir = 0,
          nr = [],
          sr = new T(),
          or = 0,
          hr = 0,
          ur = 0,
          cr = new w(),
          lr = "",
          fr = Ke.NONE,
          dr = !1,
          vr = null,
          pr = w.BLACK.clone(),
          _r = null,
          xr = w.BLACK.clone(),
          gr = new b(),
          yr = T.ZERO.clone(),
          mr = T.ZERO.clone(),
          Sr = C.ZERO.clone(),
          Dr = C.ZERO.clone(),
          wr = 0,
          br = 0,
          Tr = !1,
          Cr = !1,
          Mr = !1,
          Br = ["left", "center", "right"],
          Er = {
        getAssemblerData: function getAssemblerData() {
          return J._canvasPool.get();
        },
        resetAssemblerData: function resetAssemblerData(t) {
          t && J._canvasPool.put(t);
        },
        updateRenderData: function updateRenderData(t) {
          if (t.renderData) {
            if (t.renderData.vertDirty) {
              var e = t.node._uiProps.uiTransformComp;
              this._updateFontFamily(t), this._updateProperties(t, e), this._calculateLabelFont(), this._updateLabelDimensions(), this._updateTexture(t), this._calDynamicAtlas(t), t.actualFontSize = ar, e.setContentSize(sr), this.updateVertexData(t), this.updateUVs(t), t.markForUpdateRenderData(!1), Je = null, $e = null, tr = null;
            }

            t.spriteFrame && t.renderData.updateRenderData(t, t.spriteFrame);
          }
        },
        updateVertexData: function updateVertexData() {},
        updateUVs: function updateUVs() {},
        _updateFontFamily: function _updateFontFamily(t) {
          lr = t.useSystemFont ? t.fontFamily || "Arial" : t.font && t.font._nativeAsset || "Arial";
        },
        _updateProperties: function _updateProperties(t, e) {
          var r = t.assemblerData;
          r && (Je = r.context, $e = r.canvas, tr = t.spriteFrame, rr = t.string.toString(), ar = t.fontSize, ir = ar, fr = t.overflow, mr.width = sr.width = e.width, mr.height = sr.height = e.height, br = t.underlineHeight, or = t.lineHeight, hr = t.horizontalAlign, ur = t.verticalAlign, cr = t.color, t.node._uiProps.opacity, Tr = t.isBold, Cr = t.isItalic, Mr = t.isUnderline, dr = fr !== Ke.NONE && (fr === Ke.RESIZE_HEIGHT || t.enableWrapText), (vr = (vr = xt && t.getComponent(xt)) && vr.enabled && vr.width > 0 ? vr : null) && pr.set(vr.color), (_r = (_r = gt && t.getComponent(gt)) && _r.enabled ? _r : null) && xr.set(_r.color), this._updatePaddingRect());
        },
        _updatePaddingRect: function _updatePaddingRect() {
          var t = 0,
              e = 0,
              r = 0,
              a = 0,
              i = 0;

          if (yr.width = yr.height = 0, vr && (t = e = r = a = i = vr.width, yr.width = yr.height = 2 * i), _r) {
            var n = _r.blur + i,
                s = _r.offset.x,
                o = _r.offset.y;
            r = Math.max(r, -s + n), a = Math.max(a, s + n), t = Math.max(t, o + n), e = Math.max(e, -o + n);
          }

          if (Cr) {
            var h = ir * Math.tan(.20943951);
            a += h, yr.width += h;
          }

          gr.x = r, gr.y = t, gr.width = r + a, gr.height = t + e;
        },
        _calculateFillTextStartPosition: function _calculateFillTextStartPosition() {
          var t = 0;
          hr === j.RIGHT ? t = sr.width - gr.width : hr === j.CENTER && (t = (sr.width - gr.width) / 2);
          var e = this._getLineHeight() * (nr.length - 1),
              r = ar * (1 - et / 2);

          if (ur !== K.TOP) {
            var a = e + gr.height + ar - sr.height;
            ur === K.BOTTOM ? r -= a += et / 2 * ar : r -= a / 2;
          }

          r += Qe * ar, Sr.set(t + gr.x, r + gr.y);
        },
        _updateTexture: function _updateTexture(t) {
          if (Je && $e) {
            Je.clearRect(0, 0, $e.width, $e.height), Je.font = er, this._calculateFillTextStartPosition();

            var e = this._getLineHeight();

            Je.lineJoin = "round", vr ? (Je.fillStyle = "rgba(" + pr.r + ", " + pr.g + ", " + pr.b + ", " + Ye + ")", Je.fillRect(0, 0, $e.width, $e.height)) : t._srcBlendFactor === i.SRC_ALPHA && (Je.fillStyle = "rgba(" + cr.r + ", " + cr.g + ", " + cr.b + ", " + Ye + ")", Je.fillRect(0, 0, $e.width, $e.height)), Je.fillStyle = "rgb(" + cr.r + ", " + cr.g + ", " + cr.b + ")";
            var r = Sr.x,
                a = 0;

            this._drawTextEffect(Sr, e);

            for (var n = 0; n < nr.length; ++n) {
              a = Sr.y + n * e, vr && Je.strokeText(nr[n], r, a), Je.fillText(nr[n], r, a);
            }

            _r && (Je.shadowColor = "transparent"), this._uploadTexture(t);
          }
        },
        _uploadTexture: function _uploadTexture(t) {
          if (t.cacheMode === J.CacheMode.BITMAP) {
            var e = t.ttfSpriteFrame;
            z.deleteAtlasSpriteFrame(e), e._resetDynamicAtlasFrame();
          }

          var r;
          tr && $e && (r = tr instanceof W ? tr.texture : tr, 0 !== $e.width && 0 !== $e.height && (r.reset({
            width: $e.width,
            height: $e.height,
            mipmapLevel: 1
          }), r.uploadData($e), r.setWrapMode(M.CLAMP_TO_EDGE, M.CLAMP_TO_EDGE), tr instanceof W && (tr.rect = new b(0, 0, $e.width, $e.height), tr._calculateUV()), t.renderData && (t.renderData.textureDirty = !0), n.director.root && n.director.root.batcher2D && n.director.root.batcher2D._releaseDescriptorSetCache(r.getHash())));
        },
        _calDynamicAtlas: function _calDynamicAtlas(t) {
          if (!(t.cacheMode !== J.CacheMode.BITMAP || !$e || $e.width <= 0 || $e.height <= 0)) {
            var e = t.ttfSpriteFrame;
            z.packToDynamicAtlas(t, e);
          }
        },
        _setupOutline: function _setupOutline() {
          Je.strokeStyle = "rgba(" + pr.r + ", " + pr.g + ", " + pr.b + ", " + pr.a / 255 + ")", Je.lineWidth = 2 * vr.width;
        },
        _setupShadow: function _setupShadow() {
          Je.shadowColor = "rgba(" + xr.r + ", " + xr.g + ", " + xr.b + ", " + xr.a / 255 + ")", Je.shadowBlur = _r.blur, Je.shadowOffsetX = _r.offset.x, Je.shadowOffsetY = -_r.offset.y;
        },
        _drawTextEffect: function _drawTextEffect(t, e) {
          if (_r || vr || Mr) {
            var r = nr.length > 1 && _r,
                a = this._measureText(Je, er),
                i = 0,
                n = 0;

            _r && this._setupShadow(), vr && this._setupOutline();

            for (var s = 0; s < nr.length; ++s) {
              i = t.x, n = t.y + s * e, r && (vr && Je.strokeText(nr[s], i, n), Je.fillText(nr[s], i, n)), Mr && (wr = a(nr[s]), hr === j.RIGHT ? Dr.x = t.x - wr : hr === j.CENTER ? Dr.x = t.x - wr / 2 : Dr.x = t.x, Dr.y = n + ir / 8, Je.fillRect(Dr.x, Dr.y, wr, br));
            }

            r && (Je.shadowColor = "transparent");
          }
        },
        _updateLabelDimensions: function _updateLabelDimensions() {
          sr.width = Math.min(sr.width, 2048), sr.height = Math.min(sr.height, 2048);
          var t = !1;
          $e.width !== sr.width && ($e.width = sr.width, t = !0), $e.height !== sr.height && ($e.height = sr.height, t = !0), t && (Je.font = er), Je.textAlign = Br[hr], Je.textBaseline = "alphabetic";
        },
        _getFontDesc: function _getFontDesc() {
          var t = ar.toString() + "px ";
          return t += lr, Tr && (t = "bold " + t), Cr && (t = "italic " + t), t;
        },
        _getLineHeight: function _getLineHeight() {
          return 0 | (0 === or ? ar : or * ar / ir);
        },
        _calculateParagraphLength: function _calculateParagraphLength(t, e) {
          for (var r, a = [], i = s(t); !(r = i()).done;) {
            var n = r.value,
                o = $(e, n, er);
            a.push(o);
          }

          return a;
        },
        _measureText: function _measureText(t, e) {
          return function (r) {
            return $(t, r, e);
          };
        },
        _calculateShrinkFont: function _calculateShrinkFont(t) {
          if (Je) {
            var e = this._calculateParagraphLength(t, Je),
                r = 0,
                a = 0,
                i = 0;

            if (dr) {
              var n = mr.width,
                  s = mr.height;
              if (n < 0 || s < 0) return;
              a = s + 1;

              for (var h = 0, u = 0 | ar + 1, c = 0; h < u;) {
                if ((c = h + u + 1 >> 1) <= 0) {
                  o(4003);
                  break;
                }

                ar = c, er = this._getFontDesc(), Je.font = er;

                var l = this._getLineHeight();

                for (a = 0, r = 0; r < t.length; ++r) {
                  var f = $(Je, t[r], er);
                  a += tt(t[r], f, n, this._measureText(Je, er)).length * l;
                }

                a > s ? u = c - 1 : h = c;
              }

              0 === h ? o(4003) : (ar = h, er = this._getFontDesc(), Je.font = er);
            } else {
              for (a = t.length * this._getLineHeight(), r = 0; r < t.length; ++r) {
                i < e[r] && (i = e[r]);
              }

              var d = (sr.width - gr.width) / i,
                  v = sr.height / a;
              ar = ir * Math.min(1, d, v) | 0, er = this._getFontDesc(), Je.font = er;
            }
          }
        },
        _calculateWrapText: function _calculateWrapText(t) {
          if (dr && Je) {
            nr = [];

            for (var e = mr.width, r = 0; r < t.length; ++r) {
              var a = $(Je, t[r], er),
                  i = tt(t[r], a, e, this._measureText(Je, er));
              nr = nr.concat(i);
            }
          }
        },
        _calculateLabelFont: function _calculateLabelFont() {
          if (Je) {
            var t = rr.split("\n");

            switch (nr = t, er = this._getFontDesc(), Je.font = er, fr) {
              case Ke.NONE:
                for (var e = 0, r = 0, a = 0; a < t.length; ++a) {
                  var i = $(Je, t[a], er);
                  e = e > i ? e : i;
                }

                r = (nr.length + et) * this._getLineHeight();
                var n = parseFloat(e.toFixed(2)),
                    s = parseFloat(r.toFixed(2));
                sr.width = n + gr.width, sr.height = s + gr.height, mr.width = n + yr.width, mr.height = s + yr.height;
                break;

              case Ke.SHRINK:
                this._calculateShrinkFont(t), this._calculateWrapText(t);
                break;

              case Ke.CLAMP:
                this._calculateWrapText(t);

                break;

              case Ke.RESIZE_HEIGHT:
                this._calculateWrapText(t);

                var o = (nr.length + et) * this._getLineHeight();

                sr.height = o + gr.height, mr.height = o + yr.height;
            }
          }
        }
      },
          Ar = w.WHITE.clone(),
          Lr = {
        createData: function createData(t) {
          var e = t.requestRenderData();
          e.dataLength = 2, e.resize(4, 6);
          var r = e.chunk.vb;
          r[3] = r[21] = r[22] = r[31] = 0, r[4] = r[12] = r[13] = r[30] = 1;

          for (var a = 5, i = 0; i < 4; i++) {
            w.toArray(r, Ar, a), a += 9;
          }

          return e;
        },
        fillBuffers: function fillBuffers(t) {
          var e = t.renderData.chunk,
              r = t.renderData.data,
              a = t.node,
              i = e.vb,
              n = r[0],
              s = r[1];
          a.updateWorldTransform();
          var o = a._pos,
              h = a._rot,
              u = a._scale,
              c = n.x * u.x,
              l = s.x * u.x,
              f = n.y * u.y,
              d = s.y * u.y,
              v = h.x,
              p = h.y,
              _ = h.z,
              x = h.w,
              g = v * p,
              y = _ * x,
              m = v * v - p * p,
              S = x * x - _ * _,
              D = S + m,
              w = 2 * (g - y),
              b = S - m,
              T = 2 * (g + y),
              C = o.x,
              M = o.y;
          i[0] = D * c + w * f + C, i[1] = b * f + T * c + M, i[9] = D * l + w * f + C, i[10] = b * f + T * l + M, i[18] = D * c + w * d + C, i[19] = b * d + T * c + M, i[27] = D * l + w * d + C, i[28] = b * d + T * l + M;
          var B = e.bufferId,
              E = e.vertexOffset,
              A = e.vertexAccessor.getMeshBuffer(e.bufferId),
              L = e.vertexAccessor.getIndexBuffer(B),
              R = A.indexOffset;
          L[R++] = E, L[R++] = E + 1, L[R++] = E + 2, L[R++] = E + 2, L[R++] = E + 1, L[R++] = E + 3, A.indexOffset += 6;
        },
        updateVertexData: function updateVertexData(t) {
          var e = t.renderData;

          if (e) {
            var r = t.node._uiProps.uiTransformComp,
                a = r.width,
                i = r.height,
                n = r.anchorX * a,
                s = r.anchorY * i,
                o = e.data;
            o[0].x = -n, o[0].y = -s, o[1].x = a - n, o[1].y = i - s;
          }
        },
        updateUVs: function updateUVs(t) {
          var e = t.renderData;

          if (e && t.ttfSpriteFrame) {
            var r = e.chunk.vb,
                a = t.ttfSpriteFrame.uv;
            r[3] = a[0], r[4] = a[1], r[12] = a[2], r[13] = a[3], r[21] = a[4], r[22] = a[5], r[30] = a[6], r[31] = a[7];
          }
        },
        updateColor: function updateColor() {}
      };
      r(Lr, Er);
      var Rr = t("l", {
        getAssembler: function getAssembler(t) {
          var e = Lr;
          return t.font instanceof at ? e = Ze : t.cacheMode === J.CacheMode.CHAR && (e = je), e;
        }
      });
      J.Assembler = Rr;
      var Fr = it.FillType,
          Pr = new S(),
          Ir = new m(),
          Or = {
        updateRenderData: function updateRenderData(t) {
          var e = t.spriteFrame;
          z.packToDynamicAtlas(t, e);
          var r = t.renderData;

          if (r && e) {
            if (r.updateRenderData(t, e), !r.vertDirty) return;
            var a = t.fillStart,
                i = t.fillRange;
            i < 0 && (a += i, i = -i), i = (i = (i = a + i) > 1 ? 1 : i) < 0 ? 0 : i;
            var n = (a = (a = a > 1 ? 1 : a) < 0 ? 0 : a) + (i = (i -= a) < 0 ? 0 : i);
            n = n > 1 ? 1 : n, this.updateUVs(t, a, n), this.updateVertexData(t, a, n);
          }
        },
        updateUVs: function updateUVs(t, e, r) {
          var a = t.spriteFrame,
              i = t.renderData.chunk.vb,
              n = a.width,
              s = a.height,
              o = a.rect,
              u = 0,
              c = 0,
              l = 0,
              f = 0,
              d = 0,
              v = 0,
              p = 0,
              _ = 0,
              x = 0,
              g = 0;

          switch (a.isRotated() ? (u = o.x / n, c = (o.y + o.width) / s, l = d = u, p = x = (o.x + o.height) / n, v = g = c, f = _ = o.y / s) : (u = o.x / n, c = (o.y + o.height) / s, l = p = u, d = x = (o.x + o.width) / n, f = v = c, _ = g = o.y / s), t.fillType) {
            case Fr.HORIZONTAL:
              i[3] = l + (d - l) * e, i[4] = f + (v - f) * e, i[12] = l + (d - l) * r, i[13] = f + (v - f) * r, i[21] = p + (x - p) * e, i[22] = _ + (g - _) * e, i[30] = p + (x - p) * r, i[31] = _ + (g - _) * r;
              break;

            case Fr.VERTICAL:
              i[3] = l + (p - l) * e, i[4] = f + (_ - f) * e, i[12] = d + (x - d) * e, i[13] = v + (g - v) * e, i[21] = l + (p - l) * r, i[22] = f + (_ - f) * r, i[30] = d + (x - d) * r, i[31] = v + (g - v) * r;
              break;

            default:
              h(2626);
          }
        },
        updateVertexData: function updateVertexData(t, e, r) {
          var a = t.renderData.data,
              i = t.node._uiProps.uiTransformComp,
              n = i.width,
              s = i.height,
              o = i.anchorX * n,
              u = i.anchorY * s,
              c = -o,
              l = -u,
              f = n - o,
              d = s - u,
              v = 0;

          switch (t.fillType) {
            case Fr.HORIZONTAL:
              v = c + (f - c) * r, c += (f - c) * e, f = v;
              break;

            case Fr.VERTICAL:
              v = l + (d - l) * r, l += (d - l) * e, d = v;
              break;

            default:
              h(2626);
          }

          a[0].x = c, a[0].y = l, a[1].x = f, a[1].y = l, a[2].x = c, a[2].y = d, a[3].x = f, a[3].y = d;
        },
        createData: function createData(t) {
          var e = t.requestRenderData();
          e.dataLength = 4, e.resize(4, 6);

          for (var r, a = e.data, i = s(a); !(r = i()).done;) {
            r.value.z = 0;
          }

          return e;
        },
        updateWorldVertexData: function updateWorldVertexData(t, e) {
          t.node.getWorldMatrix(Pr);

          for (var r = t.renderData.floatStride, a = t.renderData.data, i = e.vb, n = 0, s = 0; s < 4; s++) {
            var o = a[s];
            m.transformMat4(Ir, o, Pr), i[n = s * r] = Ir.x, i[n + 1] = Ir.y, i[n + 2] = Ir.z;
          }
        },
        fillBuffers: function fillBuffers(t) {
          var e = t.renderData,
              r = e.chunk;
          (t.node.hasChangedFlags || e.vertDirty) && (this.updateWorldVertexData(t, r), e.vertDirty = !1);
          var a = r.bufferId,
              i = r.vertexOffset,
              n = r.vertexAccessor.getMeshBuffer(r.bufferId),
              s = r.vertexAccessor.getIndexBuffer(a),
              o = n.indexOffset;
          s[o++] = i, s[o++] = i + 1, s[o++] = i + 2, s[o++] = i + 2, s[o++] = i + 1, s[o++] = i + 3, n.indexOffset += 6;
        },
        updateColor: function updateColor(t) {
          for (var e = t.renderData, r = e.chunk.vb, a = e.floatStride, i = 5, n = t.color, s = n.r / 255, o = n.g / 255, h = n.b / 255, u = t.node._uiProps.opacity, c = 0; c < 4; c++) {
            r[i] = s, r[i + 1] = o, r[i + 2] = h, r[i + 3] = u, i += a;
          }
        }
      },
          Hr = 2 * Math.PI,
          kr = 1e-6,
          Vr = new S(),
          Nr = new m(),
          Ur = [new C(), new C(), new C(), new C()],
          zr = new Array(4),
          Wr = new Array(8),
          Zr = [new C(), new C(), new C(), new C()],
          Gr = [new C(), new C(), new C(), new C()],
          qr = new C(),
          Xr = [new C(), new C(), new C(), new C()];

      function jr(t, e, r, a, i, n, s) {
        var o = Math.sin(n);
        o = Math.abs(o) > kr ? o : 0;
        var h = Math.cos(n),
            u = 0,
            c = 0;

        if (0 !== (h = Math.abs(h) > kr ? h : 0)) {
          if (u = o / h, (t - i.x) * h > 0) {
            var l = i.y + u * (t - i.x);
            s[0].x = t, s[0].y = l;
          }

          if ((e - i.x) * h > 0) {
            var f = i.y + u * (e - i.x);
            s[2].x = e, s[2].y = f;
          }
        }

        if (0 !== o) {
          if (c = h / o, (a - i.y) * o > 0) {
            var d = i.x + c * (a - i.y);
            s[3].x = d, s[3].y = a;
          }

          if ((r - i.y) * o > 0) {
            var v = i.x + c * (r - i.y);
            s[1].x = v, s[1].y = r;
          }
        }
      }

      function Kr(t, e) {
        var r = e.x - t.x,
            a = e.y - t.y;
        if (0 === r && 0 === a) return 0;
        if (0 === r) return a > 0 ? .5 * Math.PI : 1.5 * Math.PI;
        var i = Math.atan(a / r);
        return r < 0 && (i += Math.PI), i;
      }

      function Qr(t, e, r, a, i) {
        var n = zr,
            s = n[0],
            o = n[1],
            h = n[2],
            u = n[3];
        t[e].x = r.x, t[e].y = r.y, t[e + 1].x = a.x, t[e + 1].y = a.y, t[e + 2].x = i.x, t[e + 2].y = i.y, Yr((r.x - s) / (h - s), (r.y - o) / (u - o), t, e), Yr((a.x - s) / (h - s), (a.y - o) / (u - o), t, e + 1), Yr((i.x - s) / (h - s), (i.y - o) / (u - o), t, e + 2);
      }

      function Yr(t, e, r, a) {
        var i = Wr,
            n = i[0] + (i[2] - i[0]) * t,
            s = i[4] + (i[6] - i[4]) * t,
            o = i[1] + (i[3] - i[1]) * t,
            h = i[5] + (i[7] - i[5]) * t,
            u = r[a];
        u.u = n + (s - n) * e, u.v = o + (h - o) * e;
      }

      for (var Jr = {
        useModel: !1,
        createData: function createData(t) {
          return t.requestRenderData();
        },
        updateRenderData: function updateRenderData(t) {
          var e = t.spriteFrame;
          z.packToDynamicAtlas(t, e), this.updateUVs(t);
          var r,
              a,
              i,
              n,
              o,
              h,
              u,
              c,
              l,
              f = t.renderData;

          if (f && e) {
            if (!f.vertDirty) return;
            var d = f.data,
                v = t.fillStart,
                p = t.fillRange;

            for (p < 0 && (v += p, p = -p); v >= 1;) {
              v -= 1;
            }

            for (; v < 0;) {
              v += 1;
            }

            var _ = (v *= Hr) + (p *= Hr);

            !function (t) {
              var e = t.node._uiProps.uiTransformComp,
                  r = e.width,
                  a = e.height,
                  i = e.anchorX * r,
                  n = e.anchorY * a,
                  o = -i,
                  h = -n,
                  u = r - i,
                  c = a - n,
                  l = zr;
              l[0] = o, l[1] = h, l[2] = u, l[3] = c;
              var f = t.fillCenter,
                  d = qr.x = Math.min(Math.max(0, f.x), 1) * (u - o) + o,
                  v = qr.y = Math.min(Math.max(0, f.y), 1) * (c - h) + h;
              Ur[0].x = Ur[3].x = o, Ur[1].x = Ur[2].x = u, Ur[0].y = Ur[1].y = h, Ur[2].y = Ur[3].y = c;

              for (var p, _ = s(Xr); !(p = _()).done;) {
                var x = p.value;
                C.set(x, 0, 0);
              }

              d !== l[0] && C.set(Xr[0], 3, 0), d !== l[2] && C.set(Xr[2], 1, 2), v !== l[1] && C.set(Xr[1], 0, 1), v !== l[3] && C.set(Xr[3], 2, 3);
            }(t), a = (r = e).width, i = r.height, n = r.getRect(), o = 0, h = 0, u = 0, c = 0, l = Wr, r.isRotated() ? (o = n.x / a, h = (n.x + n.height) / a, u = n.y / i, c = (n.y + n.width) / i, l[0] = l[2] = o, l[4] = l[6] = h, l[3] = l[7] = c, l[1] = l[5] = u) : (o = n.x / a, h = (n.x + n.width) / a, u = n.y / i, c = (n.y + n.height) / i, l[0] = l[4] = o, l[2] = l[6] = h, l[1] = l[3] = c, l[5] = l[7] = u), jr(zr[0], zr[2], zr[1], zr[3], qr, v, Zr), jr(zr[0], zr[2], zr[1], zr[3], qr, v + p, Gr);

            for (var x = 0, g = 0; g < 4; ++g) {
              var y = Xr[g];
              if (y) if (p >= Hr) f.dataLength = x + 3, Qr(d, x, qr, Ur[y.x], Ur[y.y]), x += 3;else {
                var m = Kr(qr, Ur[y.x]),
                    S = Kr(qr, Ur[y.y]);
                S < m && (S += Hr), m -= Hr, S -= Hr;

                for (var D = 0; D < 3; ++D) {
                  m >= _ || (m >= v ? (f.dataLength = x + 3, Qr(d, x, qr, Ur[y.x], S >= _ ? Gr[g] : Ur[y.y]), x += 3) : S > v && (S <= _ ? (f.dataLength = x + 3, Qr(d, x, qr, Zr[g], Ur[y.y]), x += 3) : (f.dataLength = x + 3, Qr(d, x, qr, Zr[g], Gr[g]), x += 3))), m += Hr, S += Hr;
                }
              }
            }

            f.resize(x, x), f.updateRenderData(t, e);
          }
        },
        fillBuffers: function fillBuffers(t) {
          var e = t.node,
              r = t.renderData,
              a = r.chunk;
          (e.hasChangedFlags || r.vertDirty) && (this.updateWorldVertexAndUVData(t, a), r.vertDirty = !1), this.updataColorLate(t);

          for (var i = a.bufferId, n = a.vertexOffset, s = a.vertexAccessor.getMeshBuffer(a.bufferId), o = a.vertexAccessor.getIndexBuffer(i), h = s.indexOffset, u = 0; u < r.indexCount; u++) {
            o[h + u] = n + u;
          }

          s.indexOffset += r.indexCount, s.setDirty();
        },
        updateWorldVertexAndUVData: function updateWorldVertexAndUVData(t, e) {
          t.node.getWorldMatrix(Vr);

          for (var r = t.renderData, a = r.floatStride, i = t.renderData.data, n = e.vb, s = r.vertexCount, o = 0, h = 0; h < s; h++) {
            var u = i[h];
            m.set(Nr, u.x, u.y, 0), m.transformMat4(Nr, Nr, Vr), n[o + 0] = Nr.x, n[o + 1] = Nr.y, n[o + 2] = Nr.z, n[o + 3] = u.u, n[o + 4] = u.v, o += a;
          }
        },
        updateUVs: function updateUVs(t) {
          t.renderData.vertDirty = !0, t.markForUpdateRenderData();
        },
        updataColorLate: function updataColorLate(t) {
          for (var e = t.renderData, r = e.chunk.vb, a = e.floatStride, i = e.vertexCount, n = 5, s = t.color, o = s.r / 255, h = s.g / 255, u = s.b / 255, c = t.node._uiProps.opacity, l = 0; l < i; l++) {
            r[n] = o, r[n + 1] = h, r[n + 2] = u, r[n + 3] = c, n += a;
          }
        },
        updateColor: function updateColor() {}
      }, $r = [], ta = 0; ta < 4; ta++) {
        $r.push(new m());
      }

      for (var ea = {
        createData: function createData(t) {
          var e = t.requestRenderData();
          return e.dataLength = 2, e.resize(4, 6), e;
        },
        updateRenderData: function updateRenderData(t) {
          var e = t.spriteFrame;
          z.packToDynamicAtlas(t, e), this.updateUVs(t);
          var r = t.renderData;
          r && e && (r.vertDirty && this.updateVertexData(t), r.updateRenderData(t, e));
        },
        updateWorldVerts: function updateWorldVerts(t, e) {
          var r = t.renderData,
              a = e.vb,
              i = r.data,
              n = t.node,
              s = i[0],
              o = i[1],
              h = n.worldMatrix,
              u = h.m00,
              c = h.m01,
              l = h.m04,
              f = h.m05,
              d = 1 === u && 0 === c && 0 === l && 1 === f,
              v = h.m12,
              p = h.m13,
              _ = s.x,
              x = o.x,
              g = s.y,
              y = o.y;

          if (d) {
            var m = _ + v,
                S = x + v,
                D = g + p,
                w = y + p;
            a[0] = m, a[1] = D, a[9] = S, a[10] = D, a[18] = m, a[19] = w, a[27] = S, a[28] = w;
          } else {
            var b = u * _,
                T = u * x,
                C = c * _,
                M = c * x,
                B = l * g + v,
                E = l * y + v,
                A = f * g + p,
                L = f * y + p;
            a[0] = b + B, a[1] = C + A, a[9] = T + B, a[10] = M + A, a[18] = b + E, a[19] = C + L, a[27] = T + E, a[28] = M + L;
          }
        },
        fillBuffers: function fillBuffers(t) {
          if (null !== t) {
            var e = t.renderData,
                r = e.chunk;
            (t.node.hasChangedFlags || e.vertDirty) && (this.updateWorldVerts(t, r), e.vertDirty = !1);
            var a = r.bufferId,
                i = r.vertexOffset,
                n = r.vertexAccessor.getMeshBuffer(a),
                s = r.vertexAccessor.getIndexBuffer(a),
                o = n.indexOffset;
            s[o++] = i, s[o++] = i + 1, s[o++] = i + 2, s[o++] = i + 2, s[o++] = i + 1, s[o++] = i + 3, n.indexOffset += 6;
          }
        },
        updateVertexData: function updateVertexData(t) {
          var e = t.renderData;

          if (e) {
            var r = t.node._uiProps.uiTransformComp,
                a = e.data,
                i = r.width,
                n = r.height,
                s = r.anchorX * i,
                o = r.anchorY * n,
                h = 0,
                u = 0,
                c = 0,
                l = 0;
            if (t.trim) h = -s, u = -o, c = i - s, l = n - o;else {
              var f = t.spriteFrame,
                  d = f.getOriginalSize(),
                  v = f.getRect(),
                  p = d.width,
                  _ = d.height,
                  x = v.width,
                  g = v.height,
                  y = f.getOffset(),
                  m = i / p,
                  S = n / _,
                  D = y.x + (p - x) / 2,
                  w = y.x - (p - x) / 2;
              h = D * m - s, u = (y.y + (_ - g) / 2) * S - o, c = i + w * m - s, l = n + (y.y - (_ - g) / 2) * S - o;
            }
            a[0].x = h, a[0].y = u, a[1].x = c, a[1].y = l, e.vertDirty = !0;
          }
        },
        updateUVs: function updateUVs(t) {
          if (t.spriteFrame) {
            var e = t.renderData.chunk.vb,
                r = t.spriteFrame.uv;
            e[3] = r[0], e[4] = r[1], e[12] = r[2], e[13] = r[3], e[21] = r[4], e[22] = r[5], e[30] = r[6], e[31] = r[7];
          }
        },
        updateColor: function updateColor(t) {
          for (var e = t.renderData, r = e.chunk.vb, a = 5, i = t.color, n = i.r / 255, s = i.g / 255, o = i.b / 255, h = i.a / 255, u = 0; u < 4; u++, a += e.floatStride) {
            r[a] = n, r[a + 1] = s, r[a + 2] = o, r[a + 3] = h;
          }
        }
      }, ra = new m(), aa = new S(), ia = {
        createData: function createData(t) {
          var e = t.requestRenderData();
          return e.dataLength = 4, e.resize(16, 54), e;
        },
        updateRenderData: function updateRenderData(t) {
          var e = t.spriteFrame;
          z.packToDynamicAtlas(t, e), this.updateUVs(t);
          var r = t.renderData;
          r && e && (r.vertDirty && this.updateVertexData(t), r.updateRenderData(t, e));
        },
        updateVertexData: function updateVertexData(t) {
          var e = t.renderData.data,
              r = t.node._uiProps.uiTransformComp,
              a = r.width,
              i = r.height,
              n = r.anchorX * a,
              s = r.anchorY * i,
              o = t.spriteFrame,
              h = o.insetLeft,
              u = o.insetRight,
              c = o.insetTop,
              l = o.insetBottom,
              f = a - h - u,
              d = i - c - l,
              v = a / (h + u),
              p = i / (c + l);
          v = Number.isNaN(v) || v > 1 ? 1 : v, p = Number.isNaN(p) || p > 1 ? 1 : p, f = f < 0 ? 0 : f, d = d < 0 ? 0 : d, e[0].x = -n, e[0].y = -s, e[1].x = h * v - n, e[1].y = l * p - s, e[2].x = e[1].x + f, e[2].y = e[1].y + d, e[3].x = a - n, e[3].y = i - s;
        },
        fillBuffers: function fillBuffers(t) {
          var e = t.renderData,
              r = e.chunk;
          (t.node.hasChangedFlags || e.vertDirty) && (this.updateWorldVertexData(t, r), e.vertDirty = !1);

          for (var a = r.bufferId, i = r.vertexOffset, n = r.vertexAccessor.getMeshBuffer(r.bufferId), s = r.vertexAccessor.getIndexBuffer(a), o = n.indexOffset, h = 0; h < 3; ++h) {
            for (var u = 0; u < 3; ++u) {
              var c = i + 4 * h + u;
              s[o++] = c, s[o++] = c + 1, s[o++] = c + 4, s[o++] = c + 1, s[o++] = c + 5, s[o++] = c + 4;
            }
          }

          n.indexOffset = o;
        },
        updateWorldVertexData: function updateWorldVertexData(t, e) {
          t.node.getWorldMatrix(aa);

          for (var r = t.renderData, a = r.floatStride, i = r.data, n = e.vb, s = 0, o = 0; o < 4; ++o) {
            for (var h = i[o], u = 0; u < 4; ++u) {
              var c = i[u];
              m.set(ra, c.x, h.y, 0), m.transformMat4(ra, ra, aa), s = (4 * o + u) * a, n[s++] = ra.x, n[s++] = ra.y, n[s++] = ra.z;
            }
          }
        },
        updateUVs: function updateUVs(t) {
          if (t.spriteFrame) for (var e = t.renderData, r = e.chunk.vb, a = e.floatStride, i = t.spriteFrame.uvSliced, n = 3, s = 0; s < 16; s++) {
            r[n] = i[s].u, r[n + 1] = i[s].v, n += a;
          }
        },
        updateColor: function updateColor(t) {
          for (var e = t.renderData, r = e.chunk.vb, a = e.floatStride, i = 5, n = t.color, s = n.r / 255, o = n.g / 255, h = n.b / 255, u = t.node._uiProps.opacity, c = 0; c < 16; c++) {
            r[i] = s, r[i + 1] = o, r[i + 2] = h, r[i + 3] = u, i += a;
          }
        }
      }, na = [], sa = 0; sa < 4; sa++) {
        na.push(new m());
      }

      var oa = new S(),
          ha = {
        createData: function createData(t) {
          return t.requestRenderData();
        },
        updateRenderData: function updateRenderData(t) {
          var e = t.renderData,
              r = t.spriteFrame;

          if (r && e && (e.updateRenderData(t, r), e.vertDirty)) {
            var a = t.node._uiProps.uiTransformComp,
                i = Math.abs(a.width),
                n = Math.abs(a.height),
                s = r.getRect(),
                o = r.insetLeft,
                h = r.insetRight,
                u = s.width - o - h,
                c = r.insetTop,
                l = r.insetBottom,
                f = s.height - c - l,
                d = i - o - h,
                v = n - c - l;
            d = d > 0 ? d : 0, v = v > 0 ? v : 0;

            var p = 0 === u ? d : d / u,
                _ = 0 === f ? v : v / f,
                x = Math.ceil(_ + 2),
                g = Math.ceil(p + 2);

            e.dataLength = Math.max(8, x + 1, g + 1), this.updateVerts(t, d, v, x, g), e.resize(x * g * 4, x * g * 6);
          }
        },
        updateUVs: function updateUVs(t) {
          t.renderData.vertDirty = !0, t.markForUpdateRenderData();
        },
        fillBuffers: function fillBuffers(t) {
          var e = t.node,
              r = t.renderData,
              a = r.chunk;
          (e.hasChangedFlags || r.vertDirty) && (this.updateWorldVertexAndUVData(t, a), r.vertDirty = !1), this.updataColorLate(t);

          for (var i = a.bufferId, n = a.vertexOffset, s = a.vertexAccessor.getMeshBuffer(a.bufferId), o = a.vertexAccessor.getIndexBuffer(i), h = s.indexOffset, u = 0; u < r.indexCount; u += 6) {
            o[h++] = n, o[h++] = n + 1, o[h++] = n + 2, o[h++] = n + 1, o[h++] = n + 3, o[h++] = n + 2, n += 4, s.indexOffset += 6;
          }

          s.setDirty();
        },
        updateWorldVertexAndUVData: function updateWorldVertexAndUVData(t, e) {
          var r = t.node;
          r.getWorldMatrix(oa);
          var a = t.renderData,
              i = a.floatStride,
              n = a.data,
              s = e.vb,
              o = r._uiProps.uiTransformComp,
              h = Math.abs(o.width),
              u = Math.abs(o.height),
              c = t.spriteFrame,
              l = c.rotated,
              f = c.uv,
              d = c.uvSliced,
              v = c.rect,
              p = c.insetLeft,
              _ = c.insetRight,
              x = v.width - p - _,
              g = c.insetTop,
              y = c.insetBottom,
              S = v.height - g - y,
              D = h - p - _,
              w = u - g - y;
          D = D > 0 ? D : 0, w = w > 0 ? w : 0;

          for (var b = 0 === x ? D : D / x, T = 0 === S ? w : w / S, C = Math.ceil(T + 2), M = Math.ceil(b + 2), B = 0, E = 0, A = 0, L = 0, R = 0, F = 0, P = C; F < P; ++F) {
            L = n[F].y, R = n[F + 1].y;

            for (var I = 0, O = M; I < O; ++I) {
              E = n[I].x, A = n[I + 1].x, m.set(na[0], E, L, 0), m.set(na[1], A, L, 0), m.set(na[2], E, R, 0), m.set(na[3], A, R, 0);

              for (var H = 0; H < 4; H++) {
                var k = na[H];
                m.transformMat4(k, k, oa);
                var V = H * i;
                s[B + V] = k.x, s[B + V + 1] = k.y, s[B + V + 2] = k.z;
              }

              B += 4 * i;
            }
          }

          B = 0;

          for (var N = i, U = 2 * i, z = 3 * i, W = 4 * i, Z = 0, G = 0, q = [], X = [], j = 0, K = C; j < K; ++j) {
            G = w > S ? w >= j * S ? 1 : T % 1 : T;

            for (var Q = 0, Y = M; Q < Y; ++Q) {
              Z = D > x ? D >= Q * x ? 1 : b % 1 : b;
              var J = B + 3,
                  $ = J + 1;
              l ? (0 === j ? (q[0] = d[0].u, q[1] = d[0].u, q[2] = d[4].u + (d[8].u - d[4].u) * G) : j < C - 1 ? (q[0] = d[4].u, q[1] = d[4].u, q[2] = d[4].u + (d[8].u - d[4].u) * G) : j === C - 1 && (q[0] = d[8].u, q[1] = d[8].u, q[2] = d[12].u), 0 === Q ? (X[0] = d[0].v, X[1] = d[1].v + (d[2].v - d[1].v) * Z, X[2] = d[0].v) : Q < M - 1 ? (X[0] = d[1].v, X[1] = d[1].v + (d[2].v - d[1].v) * Z, X[2] = d[1].v) : Q === M - 1 && (X[0] = d[2].v, X[1] = d[3].v, X[2] = d[2].v), q[3] = q[2], X[3] = X[1]) : (0 === Q ? (q[0] = d[0].u, q[1] = d[1].u + (d[2].u - d[1].u) * Z, q[2] = f[0]) : Q < M - 1 ? (q[0] = d[1].u, q[1] = d[1].u + (d[2].u - d[1].u) * Z, q[2] = d[1].u) : Q === M - 1 && (q[0] = d[2].u, q[1] = d[3].u, q[2] = d[2].u), 0 === j ? (X[0] = d[0].v, X[1] = d[0].v, X[2] = d[4].v + (d[8].v - d[4].v) * G) : j < C - 1 ? (X[0] = d[4].v, X[1] = d[4].v, X[2] = d[4].v + (d[8].v - d[4].v) * G) : j === C - 1 && (X[0] = d[8].v, X[1] = d[8].v, X[2] = d[12].v), q[3] = q[1], X[3] = X[2]), s[J] = q[0], s[$] = X[0], s[J + N] = q[1], s[$ + N] = X[1], s[J + U] = q[2], s[$ + U] = X[2], s[J + z] = q[3], s[$ + z] = X[3], B += W;
            }
          }
        },
        updateVerts: function updateVerts(t, e, r, a, i) {
          var n,
              s,
              o = t.node._uiProps.uiTransformComp,
              h = t.renderData.data,
              u = t.spriteFrame,
              c = u.rect,
              l = Math.abs(o.width),
              f = Math.abs(o.height),
              d = o.anchorX * l,
              v = o.anchorY * f,
              p = u.insetLeft,
              _ = u.insetRight,
              x = c.width - p - _,
              g = u.insetTop,
              y = u.insetBottom,
              m = c.height - g - y,
              S = o.width / (p + _) > 1 ? 1 : o.width / (p + _),
              D = o.height / (g + y) > 1 ? 1 : o.height / (g + y);
          n = x > 0 ? Math.floor(1e3 * e) / 1e3 % x == 0 ? x : e % x : e, s = m > 0 ? Math.floor(1e3 * r) / 1e3 % m == 0 ? m : r % m : r;

          for (var w = 0; w <= i; w++) {
            0 === w ? h[w].x = -d : w > 0 && w < i ? h[w].x = 1 === w ? p * S + Math.min(x, e) - d : x > 0 ? w === i - 1 ? p + n + x * (w - 2) - d : p + Math.min(x, e) + x * (w - 2) - d : p + e - d : w === i && (h[w].x = Math.min(p + e + _, l) - d);
          }

          for (var b = 0; b <= a; b++) {
            0 === b ? h[b].y = -v : b > 0 && b < a ? h[b].y = 1 === b ? y * D + Math.min(m, r) - v : m > 0 ? b === a - 1 ? y + s + (b - 2) * m - v : y + Math.min(m, r) + (b - 2) * m - v : y + r - v : b === a && (h[b].y = Math.min(y + r + g, f) - v);
          }
        },
        updataColorLate: function updataColorLate(t) {
          for (var e = t.renderData, r = e.chunk.vb, a = e.floatStride, i = e.vertexCount, n = 5, s = t.color, o = s.r / 255, h = s.g / 255, u = s.b / 255, c = t.node._uiProps.opacity, l = 0; l < i; l++) {
            r[n] = o, r[n + 1] = h, r[n + 2] = u, r[n + 3] = c, n += a;
          }
        },
        updateColor: function updateColor() {}
      },
          ua = it.Type,
          ca = it.FillType,
          la = t("s", {
        getAssembler: function getAssembler(t) {
          var e = ea,
              r = t;

          switch (r.type) {
            case ua.SLICED:
              e = ia;
              break;

            case ua.TILED:
              e = ha;
              break;

            case ua.FILLED:
              e = r.fillType === ca.RADIAL ? Jr : Or;
          }

          return e;
        }
      });
      it.Assembler = la;
      var fa = st.sharedManager,
          da = {
        createData: function createData(t) {
          var e = t.requestRenderData();
          return e.dataLength = 2, e.resize(4, 6), e;
        },
        updateRenderData: function updateRenderData(t) {
          t.type === mt.IMAGE_STENCIL && (ea.updateRenderData(t), ea.updateColor(t));
        },
        fillBuffers: function fillBuffers(t, e) {
          (t.type !== mt.IMAGE_STENCIL || t.spriteFrame) && (fa.pushMask(t), e.finishMergeBatches(), function (t, e) {
            fa.clear(t), e.commitModel(t, t._clearModel, t._clearStencilMtl);
          }(t, e), function (t, e) {
            if (fa.enterLevel(t), t.type === mt.IMAGE_STENCIL) {
              ea.fillBuffers(t, e);
              var r = t.graphics.getMaterialInstance(0);
              e.forceMergeBatches(r, t.spriteFrame, t.graphics);
            } else t.graphics.updateAssembler(e);
          }(t, e), fa.enableMask());
        }
      },
          va = {
        fillBuffers: function fillBuffers() {
          fa.exitMask();
        }
      },
          pa = {
        getAssembler: function getAssembler() {
          return da;
        }
      },
          _a = {
        getAssembler: function getAssembler() {
          return va;
        }
      };
      yt.Assembler = pa, yt.PostAssembler = _a;

      var xa = [B.EventType.MOUSE_DOWN, B.EventType.MOUSE_MOVE, B.EventType.MOUSE_UP, B.EventType.MOUSE_WHEEL],
          ga = [B.EventType.TOUCH_START, B.EventType.TOUCH_MOVE, B.EventType.TOUCH_END, B.EventType.TOUCH_CANCEL],
          ya = (new (function () {
        function t() {
          this.priority = E.UI, this._isListDirty = !1, this._inDispatchCount = 0, this._pointerEventProcessorList = [], this._processorListToAdd = [], this._processorListToRemove = [], A._registerEventDispatcher(this), L.callbacksInvoker.on(R.ADD_POINTER_EVENT_PROCESSOR, this.addPointerEventProcessor, this), L.callbacksInvoker.on(R.REMOVE_POINTER_EVENT_PROCESSOR, this.removePointerEventProcessor, this), L.callbacksInvoker.on(R.MARK_LIST_DIRTY, this._markListDirty, this);
        }

        var e = t.prototype;
        return e.dispatchEvent = function (t) {
          var e = t.type;
          return ga.includes(e) ? this.dispatchEventTouch(t) : !xa.includes(e) || this.dispatchEventMouse(t);
        }, e.addPointerEventProcessor = function (t) {
          0 === this._inDispatchCount ? this._pointerEventProcessorList.includes(t) || (this._pointerEventProcessorList.push(t), this._isListDirty = !0) : this._processorListToAdd.includes(t) || this._processorListToAdd.push(t), u.array.remove(this._processorListToRemove, t);
        }, e.removePointerEventProcessor = function (t) {
          0 === this._inDispatchCount ? (u.array.remove(this._pointerEventProcessorList, t), this._isListDirty = !0) : this._processorListToRemove.includes(t) || this._processorListToRemove.push(t), u.array.remove(this._processorListToAdd, t);
        }, e.dispatchEventMouse = function (t) {
          this._inDispatchCount++, this._sortPointerEventProcessorList();

          for (var e = this._pointerEventProcessorList, r = e.length, a = !0, i = 0; i < r; ++i) {
            var n = e[i];

            if (n.isEnabled && n.shouldHandleEventMouse && n._handleEventMouse(t)) {
              if (a = !1, !t.preventSwallow) break;
              t.preventSwallow = !1;
            }
          }

          return --this._inDispatchCount <= 0 && this._updatePointerEventProcessorList(), a;
        }, e.dispatchEventTouch = function (t) {
          this._inDispatchCount++, this._sortPointerEventProcessorList();

          for (var e = this._pointerEventProcessorList, r = e.length, a = t.touch, i = !0, n = 0; n < r; ++n) {
            var s = e[n];
            if (s.isEnabled && s.shouldHandleEventTouch) if (t.type === F.TOUCH_START) {
              if (s._handleEventTouch(t)) {
                if (s.claimedTouchIdList.push(a.getID()), i = !1, !t.preventSwallow) break;
                t.preventSwallow = !1;
              }
            } else if (s.claimedTouchIdList.length > 0) {
              var o = s.claimedTouchIdList.indexOf(a.getID());

              if (-1 !== o) {
                if (s._handleEventTouch(t), t.type !== F.TOUCH_END && t.type !== F.TOUCH_CANCEL || u.array.removeAt(s.claimedTouchIdList, o), i = !1, !t.preventSwallow) break;
                t.preventSwallow = !1;
              }
            }
          }

          return --this._inDispatchCount <= 0 && this._updatePointerEventProcessorList(), i;
        }, e._updatePointerEventProcessorList = function () {
          for (var t = this._processorListToAdd, e = t.length, r = 0; r < e; ++r) {
            this.addPointerEventProcessor(t[r]);
          }

          t.length = 0;

          for (var a = this._processorListToRemove, i = a.length, n = 0; n < i; ++n) {
            this.removePointerEventProcessor(a[n]);
          }

          a.length = 0;
        }, e._sortPointerEventProcessorList = function () {
          if (this._isListDirty) {
            for (var t = this._pointerEventProcessorList, e = t.length, r = 0; r < e; ++r) {
              var a = t[r],
                  i = a.node;

              if (i._uiProps) {
                var n = i._uiProps.uiTransformComp;
                a.cachedCameraPriority = n.cameraPriority;
              }
            }

            t.sort(this._sortByPriority), this._isListDirty = !1;
          }
        }, e._sortByPriority = function (t, e) {
          var r = t.node,
              a = e.node;
          if (!(e && a && a.activeInHierarchy && a._uiProps.uiTransformComp)) return -1;
          if (!(t && r && r.activeInHierarchy && r._uiProps.uiTransformComp)) return 1;
          if (t.cachedCameraPriority !== e.cachedCameraPriority) return e.cachedCameraPriority - t.cachedCameraPriority;

          for (var i = r, n = a, s = !1; (null === (o = i.parent) || void 0 === o ? void 0 : o._id) !== (null === (h = n.parent) || void 0 === h ? void 0 : h._id);) {
            var o, h, u, c, l, f;
            i = null === (null === (u = i) || void 0 === u || null === (c = u.parent) || void 0 === c ? void 0 : c.parent) ? (s = !0) && a : i && i.parent, n = null === (null === (l = n) || void 0 === l || null === (f = l.parent) || void 0 === f ? void 0 : f.parent) ? (s = !0) && r : n && n.parent;
          }

          if (i._id === n._id) {
            if (i._id === a._id) return -1;
            if (i._id === r._id) return 1;
          }

          var d = i ? i.getSiblingIndex() : 0,
              v = n ? n.getSiblingIndex() : 0;
          return s ? d - v : v - d;
        }, e._markListDirty = function () {
          this._isListDirty = !0;
        }, t;
      }())(), new f(null)),
          ma = new S(),
          Sa = t("B", function () {
        function t(t) {
          var e = this;
          this.device = void 0, this._screens = [], this._staticVBBuffer = null, this._bufferAccessors = new Map(), this._drawBatchPool = void 0, this._batches = void 0, this._currBID = -1, this._indexStart = 0, this._emptyMaterial = new O(), this._currRenderData = null, this._currMaterial = this._emptyMaterial, this._currTexture = null, this._currSampler = null, this._currStaticRoot = null, this._currComponent = null, this._currTransform = null, this._currTextureHash = 0, this._currSamplerHash = 0, this._currLayer = 0, this._currDepthStencilStateStage = null, this._currIsStatic = !1, this._currHash = 0, this._pOpacity = 1, this._opacityDirty = 0, this._descriptorSetCache = new wa(), this._meshDataArray = [], this._root = t, this.device = t.device, this._batches = new d(64), this._drawBatchPool = new v(function () {
            return new St();
          }, 128, function (t) {
            return t.destroy(e);
          });
        }

        var r = t.prototype;
        return r.initialize = function () {
          return !0;
        }, r.destroy = function () {
          for (var t = 0; t < this._batches.length; t++) {
            this._batches.array[t] && this._batches.array[t].destroy(this);
          }

          this._batches.destroy(), this._bufferAccessors.forEach(function (t) {
            t.destroy();
          }), this._bufferAccessors.clear(), this._drawBatchPool && this._drawBatchPool.destroy(), this._descriptorSetCache.destroy(), st.sharedManager.destroy();
        }, r.addScreen = function (t) {
          this._screens.push(t), this._screens.sort(this._screenSort);
        }, r.removeScreen = function (t) {
          var e = this._screens.indexOf(t);

          -1 !== e && this._screens.splice(e, 1);
        }, r.sortScreens = function () {
          this._screens.sort(this._screenSort);
        }, r.getFirstRenderCamera = function (t) {
          if (t.scene && t.scene.renderScene) for (var e = t.scene.renderScene.cameras, r = 0; r < e.length; r++) {
            var a = e[r];
            if (a.visibility & t.layer) return a;
          }
          return null;
        }, r.update = function () {
          for (var t = this._screens, e = 0, r = 0; r < t.length; ++r) {
            var a = t[r],
                i = a._getRenderScene();

            if (a.enabledInHierarchy && i) {
              this._opacityDirty = 0, this._pOpacity = 1, this.walk(a.node), this.autoMergeBatches(this._currComponent), this.resetRenderStates();
              var n = 0;
              if (this._batches.length > e) for (; e < this._batches.length; ++e) {
                var s = this._batches.array[e];
                if (s.model) for (var o = s.model.subModels, h = 0; h < o.length; h++) {
                  o[h].priority = n++;
                } else s.descriptorSet = this._descriptorSetCache.getDescriptorSet(s);
                i.addBatch(s);
              }
            }
          }
        }, r.uploadBuffers = function () {
          this._batches.length > 0 && (this._meshDataArray.forEach(function (t) {
            t.uploadBuffers();
          }), this._bufferAccessors.forEach(function (t) {
            t.uploadBuffers(), t.reset();
          }), this._descriptorSetCache.update());
        }, r.reset = function () {
          for (var t = 0; t < this._batches.length; ++t) {
            var e = this._batches.array[t];
            e.isStatic || (e.clear(), this._drawBatchPool.free(e));
          }

          this._bufferAccessors.forEach(function (t) {
            t.reset();
          }), this._meshDataArray.forEach(function (t) {
            t.freeIAPool();
          }), this._meshDataArray.length = 0, this._staticVBBuffer = null, this._currBID = -1, this._indexStart = 0, this._currHash = 0, this._currLayer = 0, this._currRenderData = null, this._currMaterial = this._emptyMaterial, this._currTexture = null, this._currSampler = null, this._currComponent = null, this._currTransform = null, this._batches.clear(), st.sharedManager.reset();
        }, r.switchBufferAccessor = function (t) {
          void 0 === t && (t = ot);
          var e = t === ot ? 36 : ht(t);

          if (!this._staticVBBuffer || this._staticVBBuffer.vertexFormatBytes !== e) {
            var r = this._bufferAccessors.get(e);

            r || (r = new Dt(this.device, t), this._bufferAccessors.set(e, r)), this._staticVBBuffer = r, this._currBID = -1;
          }

          return this._staticVBBuffer;
        }, r.registerBufferAccessor = function (t, e) {
          this._bufferAccessors.set(t, e);
        }, r.updateBuffer = function (t, e) {
          var r = this.switchBufferAccessor(t);
          this._currBID !== e && (this._currBID = e, this._indexStart = r.getMeshBuffer(e).indexOffset);
        }, r.commitComp = function (t, e, r, a, i) {
          var n,
              s = 0,
              o = -1;

          if (e && e.chunk) {
            if (!e.isValid()) return;
            s = e.dataHash, n = e.material, o = e.chunk.bufferId;
          }

          t.stencilStage = st.sharedManager.stage;
          var h = t.stencilStage;
          this._currHash === s && 0 !== s && this._currMaterial === n && this._currDepthStencilStateStage === h || (this.autoMergeBatches(this._currComponent), e && !e.isMeshBuffer && this.updateBuffer(e.vertexFormat, o), this._currRenderData = e, this._currHash = e ? e.dataHash : 0, this._currComponent = t, this._currTransform = i, this._currMaterial = t.getRenderMaterial(0), this._currDepthStencilStateStage = h, this._currLayer = t.node.layer, r ? (this._currTexture = r.getGFXTexture(), this._currSampler = r.getGFXSampler(), this._currTextureHash = r.getHash(), this._currSamplerHash = this._currSampler.hash) : (this._currTexture = null, this._currSampler = null, this._currTextureHash = 0, this._currSamplerHash = 0)), a.fillBuffers(t, this);
        }, r.commitIA = function (t, e, r, a, i) {
          var n, s;
          this._currMaterial !== this._emptyMaterial && (this.autoMergeBatches(this._currComponent), this.resetRenderStates());
          var o = 0,
              h = 0;
          t && (n = -1 === t.blendHash ? null : t.getBlendState(), h = t.blendHash, t.stencilStage = st.sharedManager.stage, s = null !== t.customMaterial ? st.sharedManager.getStencilStage(t.stencilStage, a) : st.sharedManager.getStencilStage(t.stencilStage), o = st.sharedManager.getStencilHash(t.stencilStage));
          var u = this._currStaticRoot ? this._currStaticRoot._requireDrawBatch() : this._drawBatchPool.alloc();
          u.visFlags = t.node.layer, u.inputAssembler = e, u.useLocalData = i || null, r && (u.texture = r.getGFXTexture(), u.sampler = r.getGFXSampler(), u.textureHash = r.getHash(), u.samplerHash = u.sampler.hash), u.fillPasses(a || null, s, o, n, h, null, this), this._batches.push(u);
        }, r.commitModel = function (t, e, r) {
          var a;
          this._currMaterial !== this._emptyMaterial && (this.autoMergeBatches(this._currComponent), this.resetRenderStates());
          var i = 0;
          r && (t.stencilStage !== ut.ENABLED && t.stencilStage !== ut.DISABLED || (t.stencilStage = st.sharedManager.stage), a = st.sharedManager.getStencilStage(t.stencilStage, r), i = st.sharedManager.getStencilHash(t.stencilStage));
          var s = n.director.getTotalFrames();
          e && (e.updateTransform(s), e.updateUBOs(s));

          for (var o = 0; o < e.subModels.length; o++) {
            var h = this._drawBatchPool.alloc(),
                u = e.subModels[o];

            h.visFlags = t.node.layer, h.model = e, h.texture = null, h.sampler = null, h.useLocalData = null, a || (a = null), h.fillPasses(r, a, i, null, 0, u.patches, this), h.inputAssembler = u.inputAssembler, h.model.visFlags = h.visFlags, h.descriptorSet = u.descriptorSet, this._batches.push(h);
          }
        }, r.setupStaticBatch = function (t, e) {
          this.finishMergeBatches(), this._staticVBBuffer = e, this.currStaticRoot = t;
        }, r.endStaticBatch = function () {
          this.finishMergeBatches(), this.currStaticRoot = null, this._staticVBBuffer = null, this.switchBufferAccessor();
        }, r.commitStaticBatch = function (t) {
          this._batches.concat(t.drawBatchList), this.finishMergeBatches();
        }, r.autoMergeBatches = function (t) {
          var e = this._currMaterial;

          if (e) {
            var r,
                a = this._currRenderData,
                i = this._staticVBBuffer;
            if (a && a.isMeshBuffer) r = a.requestIA(this.device), -1 === this._meshDataArray.indexOf(a) && this._meshDataArray.push(a);else if (i) {
              var n = this._currBID,
                  s = i.getMeshBuffer(n);
              if (!s) return;
              var o = s.indexOffset - this._indexStart;
              if (o <= 0) return;
              c(this._indexStart < s.indexOffset), s.setDirty(), (r = s.requireFreeIA(this.device)).firstIndex = this._indexStart, r.indexCount = o, this._indexStart = s.indexOffset;
            }

            if (this._currBID = -1, r) {
              var h,
                  u,
                  l = 0,
                  f = 0;
              t && (h = -1 === t.blendHash ? null : t.getBlendState(), f = t.blendHash, u = null !== t.customMaterial ? st.sharedManager.getStencilStage(t.stencilStage, e) : st.sharedManager.getStencilStage(t.stencilStage), l = st.sharedManager.getStencilHash(t.stencilStage));
              var d = this._currStaticRoot ? this._currStaticRoot._requireDrawBatch() : this._drawBatchPool.alloc();
              d.visFlags = this._currLayer, d.texture = this._currTexture, d.sampler = this._currSampler, d.inputAssembler = r, d.useLocalData = this._currTransform, d.textureHash = this._currTextureHash, d.samplerHash = this._currSamplerHash, d.fillPasses(e, u, l, h, f, null, this), this._batches.push(d);
            }
          }
        }, r.forceMergeBatches = function (t, e, r) {
          this._currMaterial = t, e ? (this._currTexture = e.getGFXTexture(), this._currSampler = e.getGFXSampler(), this._currTextureHash = e.getHash(), this._currSamplerHash = this._currSampler.hash) : (this._currTexture = this._currSampler = null, this._currTextureHash = this._currSamplerHash = 0), this._currLayer = r.node.layer, this.autoMergeBatches(r);
        }, r.resetRenderStates = function () {
          this._currMaterial = this._emptyMaterial, this._currRenderData = null, this._currTexture = null, this._currComponent = null, this._currTransform = null, this._currTextureHash = 0, this._currSamplerHash = 0, this._currLayer = 0;
        }, r.finishMergeBatches = function () {
          this.autoMergeBatches(), this.resetRenderStates();
        }, r.flushMaterial = function (t) {
          this._currMaterial = t;
        }, r.walk = function (t, r) {
          if (void 0 === r && (r = 0), t.activeInHierarchy) {
            var a = t.children,
                i = t._uiProps,
                n = i.uiComp,
                s = this._pOpacity,
                o = s,
                h = n && n.color ? n.color.a / 255 : 1;

            if (this._pOpacity = o *= h * i.localOpacity, i._opacity = o, i.colorDirty && this._opacityDirty++, n && n.enabledInHierarchy && n.updateAssembler(this), this._opacityDirty && n && !n.useVertexOpacity && n.renderData && n.renderData.vertexCount > 0) {
              !function (t, r) {
                for (var a, i, n, s = t.vertexFormat, o = t.chunk.vb, h = 0, u = 0; u < s.length; ++u) {
                  if (a = s[u], (i = e[a.format]).hasAlpha) if (n = t.floatStride, i.size / i.count == 1) for (var c = ~~D(Math.round(255 * r), 0, 255), l = h; l < o.length; l += n) {
                    o[l] = (4294967040 & o[l] | c) >>> 0;
                  } else if (i.size / i.count == 4) for (var f = h + 3; f < o.length; f += n) {
                    o[f] = r;
                  }
                  h += i.size >> 2;
                }
              }(n.renderData, o);
              var u = n.renderData.getMeshBuffer();
              u && u.setDirty();
            }

            if (a.length > 0 && !t._static) for (var c = 0; c < a.length; ++c) {
              var l = a[c];
              this.walk(l, r);
            }
            i.colorDirty && (this._opacityDirty--, i.colorDirty = !1), this._pOpacity = s, n && n.enabledInHierarchy && n.postUpdateAssembler(this), r += 1;
          }
        }, r._screenSort = function (t, e) {
          return t.node.getSiblingIndex() - e.node.getSiblingIndex();
        }, r._releaseDescriptorSetCache = function (t) {
          this._descriptorSetCache.releaseDescriptorSetCache(t);
        }, l(t, [{
          key: "currBufferAccessor",
          get: function get() {
            return this._staticVBBuffer || (this._staticVBBuffer = this.switchBufferAccessor()), this._staticVBBuffer;
          }
        }, {
          key: "batches",
          get: function get() {
            return this._batches;
          }
        }, {
          key: "currStaticRoot",
          set: function set(t) {
            this._currStaticRoot = t;
          }
        }, {
          key: "currIsStatic",
          set: function set(t) {
            this._currIsStatic = t;
          }
        }]), t;
      }()),
          Da = function () {
        function t() {
          this._descriptorSet = null, this._transform = null, this._textureHash = 0, this._samplerHash = 0, this._localBuffer = null, this._transformUpdate = !0;
          var t = n.director.root.device;
          this._localData = new Float32Array(P.COUNT), this._localBuffer = t.createBuffer(new p(_.UNIFORM | _.TRANSFER_DST, x.HOST | x.DEVICE, P.SIZE, P.SIZE));
        }

        var e = t.prototype;
        return e.initialize = function (t) {
          var e = n.director.root.device;
          this._transform = t.useLocalData, this._textureHash = t.textureHash, this._samplerHash = t.samplerHash, ya.layout = t.passes[0].localSetLayout, this._descriptorSet = e.createDescriptorSet(ya), this._descriptorSet.bindBuffer(P.BINDING, this._localBuffer);
          var r = I.SAMPLER_SPRITE;
          this._descriptorSet.bindTexture(r, t.texture), this._descriptorSet.bindSampler(r, t.sampler), this._descriptorSet.update(), this._transformUpdate = !0;
        }, e.updateTransform = function (t) {
          t !== this._transform && (this._transform = t, this._transformUpdate = !0, this.uploadLocalData());
        }, e.equals = function (t, e, r) {
          return this._transform === t && this._textureHash === e && this._samplerHash === r;
        }, e.reset = function () {
          this._transform = null, this._textureHash = 0, this._samplerHash = 0;
        }, e.destroy = function () {
          this._localBuffer && (this._localBuffer.destroy(), this._localBuffer = null), this._descriptorSet && (this._descriptorSet.destroy(), this._descriptorSet = null), this._localData = null;
        }, e.isValid = function () {
          return this._transform && this._transform.isValid;
        }, e.uploadLocalData = function () {
          var t = this._transform;

          if ((t.hasChangedFlags || t._dirtyFlags) && (t.updateWorldTransform(), this._transformUpdate = !0), this._transformUpdate) {
            var e = t.worldMatrix;
            S.toArray(this._localData, e, P.MAT_WORLD_OFFSET), S.inverseTranspose(ma, e);
            var r = S.determinant(ma),
                a = 1 / Math.sqrt(r);
            S.multiplyScalar(ma, ma, a), S.toArray(this._localData, ma, P.MAT_WORLD_IT_OFFSET), this._localBuffer.update(this._localData), this._transformUpdate = !1;
          }
        }, l(t, [{
          key: "descriptorSet",
          get: function get() {
            return this._descriptorSet;
          }
        }]), t;
      }(),
          wa = function () {
        function t() {
          this._descriptorSetCache = new Map(), this._dsCacheHashByTexture = new Map(), this._localDescriptorSetCache = [], this._localCachePool = void 0, this._localCachePool = new v(function () {
            return new Da();
          }, 16, function (t) {
            return t.destroy();
          });
        }

        var e = t.prototype;
        return e.getDescriptorSet = function (t) {
          var e,
              r = n.director.root;

          if (t.useLocalData) {
            for (var a = this._localDescriptorSetCache, i = 0, s = a.length; i < s; i++) {
              var o = a[i];
              if (o.equals(t.useLocalData, t.textureHash, t.samplerHash)) return o.descriptorSet;
            }

            var h = this._localCachePool.alloc();

            return h.initialize(t), this._localDescriptorSetCache.push(h), h.descriptorSet;
          }

          if (e = t.textureHash ^ t.samplerHash, this._descriptorSetCache.has(e)) return this._descriptorSetCache.get(e);
          ya.layout = t.passes[0].localSetLayout;
          var u = r.device.createDescriptorSet(ya),
              c = I.SAMPLER_SPRITE;
          return u.bindTexture(c, t.texture), u.bindSampler(c, t.sampler), u.update(), this._descriptorSetCache.set(e, u), this._dsCacheHashByTexture.set(t.textureHash, e), u;
        }, e.update = function () {
          var t = this._localDescriptorSetCache,
              e = [];
          t.forEach(function (r) {
            if (r.isValid()) r.uploadLocalData();else {
              r.reset();
              var a = t.indexOf(r);
              e.push(a);
            }
          });

          for (var r = e.length - 1; r >= 0; r--) {
            t.splice(e[r], 1);
          }
        }, e.reset = function () {
          var t = this;
          this._localDescriptorSetCache.forEach(function (e) {
            t._localCachePool.free(e);
          }), this._localDescriptorSetCache.length = 0;
        }, e.releaseDescriptorSetCache = function (t) {
          var e = this._dsCacheHashByTexture.get(t);

          e && this._descriptorSetCache.has(e) && (this._descriptorSetCache.get(e).destroy(), this._descriptorSetCache.delete(e), this._dsCacheHashByTexture.delete(t));
        }, e.destroy = function () {
          this._descriptorSetCache.forEach(function (t) {
            t.destroy();
          }), this._descriptorSetCache.clear(), this._dsCacheHashByTexture.clear(), this._localDescriptorSetCache.length = 0, this._localCachePool.destroy();
        }, t;
      }();

      n.internal.Batcher2D = Sa, H(wt.prototype, "MeshBuffer", ["byteStart", "vertexStart", "indicesStart", "request"].map(function (t) {
        return {
          name: t,
          suggest: "please use meshBuffer.accessor." + t + " instead"
        };
      })), k(wt.prototype, "MeshBuffer", [{
        name: "indicesOffset",
        newName: "indexOffset"
      }]), V(wt.prototype, "MeshBuffer", [{
        name: "vertexBuffers"
      }, {
        name: "indexBuffer"
      }]), k(Sa.prototype, "Batcher2D", [{
        name: "currBufferBatch",
        newName: "currBufferAccessor"
      }, {
        name: "acquireBufferBatch",
        newName: "switchBufferAccessor"
      }]), V(ct.prototype, "MeshRenderData", [{
        name: "formatByte"
      }, {
        name: "byteStart"
      }, {
        name: "byteCount"
      }]), k(ct.prototype, "MeshRenderData", [{
        name: "indicesStart",
        newName: "indexStart"
      }]), t("Q", function (t) {
        function e(e) {
          var r;
          return r = t.call(this, e) || this, y(9006), r;
        }

        return g(e, t), e;
      }(ct));
      var ba,
          Ta = null,
          Ca = -1,
          Ma = "BES bswy:->@123",
          Ba = Object.create(null),
          Ea = [],
          Aa = 3e3;

      function La() {
        for (var t = !0, e = Date.now(), r = Ea.length - 1; r >= 0; r--) {
          var a = Ea[r],
              i = a.fontFamilyName;
          if (e - a.startTime > Aa) y(4933, i), a.onComplete(null, i), Ea.splice(r, 1);else {
            var n = a.refWidth,
                s = "40px " + i;
            Ta.font = s, n !== $(Ta, Ma, s) ? (Ea.splice(r, 1), a.onComplete(null, i)) : t = !1;
          }
        }

        t && (clearInterval(Ca), Ca = -1);
      }

      function Ra(t, e, r) {
        var a = function (t) {
          var e = t.lastIndexOf(".ttf");
          if (-1 === e) return t;
          var r,
              a = t.lastIndexOf("/");
          return -1 !== (r = -1 === a ? t.substring(0, e) + "_LABEL" : t.substring(a + 1, e) + "_LABEL").indexOf(" ") && (r = '"' + r + '"'), r;
        }(t);

        if (Ba[a]) r(null, a);else {
          if (!Ta) {
            var i = document.createElement("canvas");
            i.width = 100, i.height = 100, Ta = i.getContext("2d");
          }

          var n = $(Ta, Ma, "40px " + a),
              s = document.createElement("style");
          s.type = "text/css";
          var o = "";
          Number.isNaN(a) ? o += "@font-face { font-family:" + a + "; src:" : o += '@font-face { font-family:"' + a + '"; src:', o += 'url("' + t + '");', s.textContent = o + "}", document.body.appendChild(s);
          var h,
              u,
              c,
              l,
              f,
              d,
              v = document.createElement("div"),
              p = v.style;
          if (p.fontFamily = a, v.innerHTML = ".", p.position = "absolute", p.left = "-100px", p.top = "-100px", document.body.appendChild(v), function () {
            if (void 0 === ba) if ("FontFace" in window) {
              var t = /Gecko.*Firefox\/(\d+)/.exec(window.navigator.userAgent),
                  e = /OS X.*Version\/10\..*Safari/.exec(window.navigator.userAgent) && /Apple/.exec(window.navigator.vendor);
              ba = t ? parseInt(t[1], 10) > 42 : !e;
            } else ba = !1;
            return ba;
          }()) h = Date.now(), u = a, c = r, l = new Promise(function (t, e) {
            !function r() {
              Date.now() - h >= Aa ? e() : document.fonts.load("40px " + u).then(function (e) {
                e.length >= 1 ? t() : setTimeout(r, 100);
              }, function () {
                e();
              });
            }();
          }), f = null, d = new Promise(function (t, e) {
            f = setTimeout(e, Aa);
          }), Promise.race([d, l]).then(function () {
            f && (clearTimeout(f), f = null), c(null, u);
          }, function () {
            y(4933, u), c(null, u);
          });else {
            var _ = {
              fontFamilyName: a,
              refWidth: n,
              onComplete: r,
              startTime: Date.now()
            };
            Ea.push(_), -1 === Ca && (Ca = setInterval(La, 100));
          }
          Ba[a] = s;
        }
      }

      function Fa(t, e, r, a) {
        var i = new nt();
        i._nativeUrl = t, i._nativeAsset = e, a(null, i);
      }

      N.register({
        ".font": Ra,
        ".eot": Ra,
        ".ttf": Ra,
        ".woff": Ra,
        ".svg": Ra,
        ".ttc": Ra
      }), U.register({
        ".font": Fa,
        ".eot": Fa,
        ".ttf": Fa,
        ".woff": Fa,
        ".svg": Fa,
        ".ttc": Fa
      }), n.UI = {
        MeshBuffer: wt,
        spriteAssembler: la,
        graphicsAssembler: ce,
        labelAssembler: Rr,
        RenderData: lt,
        MeshRenderData: ct
      };
    }
  };
}); 
 			}); 
		define("__plugin__/wx0446ba2621dda60a/index-5d4b7661.js", function(require, module, exports){ 			
"use strict";

System.register(["./texture-barrier-60b5983b.js", "./json-asset-933a1d4c.js", "./index-f2b92470.js", "./renderable-component-7c6600ed.js", "./create-mesh-39923017.js", "./mesh-f5415e9d.js", "./mesh-renderer-fb3b7695.js", "./deprecated-6c081405.js", "./skeleton-b0039cea.js", "./deprecated-e75308d4.js"], function (t) {
  "use strict";

  var e, i, o, n, r, a, s, h, l, c, u, p, g, d, _, y, m, w, b, f, D, O, S, R, L, z, P, k, j, N, B, H, F, v, T, A, E, M, C, x, I, U, X, W, G, V, Z, $, K;

  return {
    setters: [function (t) {
      e = t.l, i = t.bX, o = t.bv, n = t.bU, r = t.c0, a = t.bT, s = t.c1, h = t.b$, l = t.bG, c = t.bF;
    }, function (t) {
      u = t.b9, p = t.df, g = t.dg, d = t.dh, _ = t.Z, y = t.ay, m = t.Q, w = t.bW, b = t.b$, f = t.bZ, D = t.di, O = t.bX, S = t.cc, R = t.dj, L = t.bY, z = t.bm, P = t.a5, k = t.dk, j = t.P, N = t.cd, B = t.cg, H = t.ch, F = t.ci, v = t.aa, T = t.i, A = t.dl, E = t.ad, M = t.ax;
    }, function () {}, function (t) {
      C = t.L, x = t.i, I = t.D, U = t.e, X = t.j, W = t.n, G = t.k;
    }, function (t) {
      V = t.r, Z = t.c;
    }, function (t) {
      $ = t.M;
    }, function (t) {
      K = t.M;
    }, function () {}, function () {}, function () {}],
    execute: function execute() {
      var Q,
          Y,
          q,
          J,
          tt,
          et,
          it,
          ot,
          nt,
          rt,
          at,
          st,
          ht,
          lt,
          ct,
          ut,
          pt,
          gt,
          dt,
          _t,
          yt,
          mt,
          wt = Object.freeze({
        __proto__: null,
        find: u,
        toPPM: function toPPM(t, e, i) {
          return "P3 " + e + " " + i + " 255\n" + t.filter(function (t, e) {
            return e % 4 < 3;
          }).toString() + "\n";
        },
        readMesh: V,
        createMesh: Z,
        readBuffer: p,
        writeBuffer: g,
        mapBuffer: d
      });

      function bt(t, e) {
        var i = t.sharedMaterials.length;
        if (i !== e.sharedMaterials.length) return !1;

        for (var o = 0; o < i; o++) {
          if (t.getRenderMaterial(o) !== e.getRenderMaterial(o)) return !1;
        }

        return !0;
      }

      t("u", wt), t("B", function () {
        function t() {}

        return t.batchStaticModel = function (t, e) {
          var i = t.getComponentsInChildren(K);
          if (i.length < 2) return console.error("the number of static models to batch is less than 2,it needn't batch."), !1;

          for (var o = 1; o < i.length; o++) {
            if (!i[0].mesh.validateMergingMesh(i[o].mesh)) return console.error("the meshes of " + i[0].node.name + " and " + i[o].node.name + " can't be merged"), !1;
            if (!bt(i[0], i[o])) return console.error("the materials of " + i[0].node.name + " and " + i[o].node.name + " can't be merged"), !1;
          }

          var n = new $(),
              r = new _(),
              a = new _();
          t.getWorldMatrix(a), _.invert(a, a);

          for (var s = 0; s < i.length; s++) {
            var h = i[s];
            h.node.getWorldMatrix(r), _.multiply(r, a, r), n.merge(i[s].mesh, r), h.enabled = !1;
          }

          var l = e.addComponent(K);
          return l.mesh = n, l.sharedMaterials = i[0].sharedMaterials, !0;
        }, t.unbatchStaticModel = function (t, e) {
          for (var i = t.getComponentsInChildren(K), o = 0; o < i.length; o++) {
            i[o].enabled = !0;
          }

          var n = e.getComponent(K);
          return n && (n.mesh && n.mesh.destroyRenderingMesh(), n.destroy()), !0;
        }, t;
      }()), y(K.prototype, "MeshRenderer.prototype", [{
        name: "enableDynamicBatching"
      }, {
        name: "recieveShadows"
      }]), e.ModelComponent = K, i.setClassAlias(K, "cc.ModelComponent");

      var ft,
          Dt,
          Ot,
          St,
          Rt,
          Lt,
          zt,
          Pt,
          kt,
          jt,
          Nt,
          Bt,
          Ht,
          Ft,
          vt,
          Tt,
          At,
          Et,
          Mt,
          Ct,
          xt,
          It,
          Ut,
          Xt,
          Wt,
          Gt,
          Vt,
          Zt,
          $t,
          Kt,
          Qt,
          Yt,
          qt,
          Jt,
          te,
          ee,
          ie,
          oe,
          ne,
          re,
          ae,
          se,
          he,
          le,
          ce,
          ue,
          pe,
          ge,
          de,
          _e,
          ye,
          me,
          we,
          be,
          fe,
          De,
          Oe,
          Se,
          Re,
          Le,
          ze,
          Pe,
          ke,
          je,
          Ne,
          Be,
          He,
          Fe,
          ve,
          Te,
          Ae,
          Ee,
          Me,
          Ce,
          xe,
          Ie,
          Ue,
          Xe,
          We,
          Ge,
          Ve,
          Ze,
          $e,
          Ke,
          Qe,
          Ye,
          qe,
          Je,
          ti,
          ei,
          ii,
          oi,
          ni,
          ri,
          ai,
          si,
          hi,
          li,
          ci,
          ui,
          pi,
          gi,
          di,
          _i,
          yi,
          mi,
          wi,
          bi,
          fi,
          Di,
          Oi,
          Si,
          Ri,
          Li,
          zi,
          Pi,
          ki,
          ji,
          Ni,
          Bi,
          Hi = new m(),
          Fi = o({
        LUMINOUS_FLUX: 0,
        LUMINANCE: 1
      }),
          vi = w("cc.StaticLightSettings")((it = function () {
        function t() {
          s(this, "_baked", q, this), s(this, "_editorOnly", J, this), s(this, "_bakeable", tt, this), s(this, "_castShadow", et, this);
        }

        return n(t, [{
          key: "editorOnly",
          get: function get() {
            return this._editorOnly;
          },
          set: function set(t) {
            this._editorOnly = t;
          }
        }, {
          key: "baked",
          get: function get() {
            return this._baked;
          },
          set: function set(t) {
            this._baked = t;
          }
        }, {
          key: "bakeable",
          get: function get() {
            return this._bakeable;
          },
          set: function set(t) {
            this._bakeable = t;
          }
        }, {
          key: "castShadow",
          get: function get() {
            return this._castShadow;
          },
          set: function set(t) {
            this._castShadow = t;
          }
        }]), t;
      }(), q = r((Y = it).prototype, "_baked", [O], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !1;
        }
      }), J = r(Y.prototype, "_editorOnly", [O], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !1;
        }
      }), tt = r(Y.prototype, "_bakeable", [O], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !1;
        }
      }), et = r(Y.prototype, "_castShadow", [O], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !1;
        }
      }), r(Y.prototype, "editorOnly", [b], Object.getOwnPropertyDescriptor(Y.prototype, "editorOnly"), Y.prototype), r(Y.prototype, "bakeable", [b], Object.getOwnPropertyDescriptor(Y.prototype, "bakeable"), Y.prototype), r(Y.prototype, "castShadow", [b], Object.getOwnPropertyDescriptor(Y.prototype, "castShadow"), Y.prototype), Q = Y)) || Q,
          Ti = t("L", (ot = w("cc.Light"), nt = S(), rt = S(), at = R(), st = S(), ht = f(vi), lt = L(), ot((mt = yt = function (t) {
        function i() {
          var e;
          return e = t.call(this) || this, s(e, "_color", pt, h(e)), s(e, "_useColorTemperature", gt, h(e)), s(e, "_colorTemperature", dt, h(e)), s(e, "_staticSettings", _t, h(e)), e._type = C.UNKNOWN, e._lightType = void 0, e._light = null, e._lightType = x, e;
        }

        a(i, t);
        var o = i.prototype;
        return o.onLoad = function () {
          this._createLight();
        }, o.onEnable = function () {
          this._attachToScene();
        }, o.onDisable = function () {
          this._detachFromScene();
        }, o.onDestroy = function () {
          this._destroyLight();
        }, o._createLight = function () {
          this._light || (this._light = e.director.root.createLight(this._lightType)), this.color = this._color, this.useColorTemperature = this._useColorTemperature, this.colorTemperature = this._colorTemperature, this._light.node = this.node, this._light.baked = this.baked;
        }, o._destroyLight = function () {
          this._light && (e.director.root.destroyLight(this), this._light = null);
        }, o._attachToScene = function () {
          if (this._detachFromScene(), this._light && !this._light.scene && this.node.scene) {
            var t = this._getRenderScene();

            switch (this._type) {
              case C.DIRECTIONAL:
                t.addDirectionalLight(this._light), t.setMainLight(this._light);
                break;

              case C.SPHERE:
                t.addSphereLight(this._light);
                break;

              case C.SPOT:
                t.addSpotLight(this._light);
            }
          }
        }, o._detachFromScene = function () {
          if (this._light && this._light.scene) {
            var t = this._light.scene;

            switch (this._type) {
              case C.DIRECTIONAL:
                t.removeDirectionalLight(this._light), t.unsetMainLight(this._light);
                break;

              case C.SPHERE:
                t.removeSphereLight(this._light);
                break;

              case C.SPOT:
                t.removeSpotLight(this._light);
            }
          }
        }, n(i, [{
          key: "color",
          get: function get() {
            return this._color;
          },
          set: function set(t) {
            this._color = t, this._light && (Hi.x = t.r / 255, Hi.y = t.g / 255, Hi.z = t.b / 255, this._light.color = Hi);
          }
        }, {
          key: "useColorTemperature",
          get: function get() {
            return this._useColorTemperature;
          },
          set: function set(t) {
            this._useColorTemperature = t, this._light && (this._light.useColorTemperature = t);
          }
        }, {
          key: "colorTemperature",
          get: function get() {
            return this._colorTemperature;
          },
          set: function set(t) {
            this._colorTemperature = t, this._light && (this._light.colorTemperature = t);
          }
        }, {
          key: "staticSettings",
          get: function get() {
            return this._staticSettings;
          },
          set: function set(t) {
            this._staticSettings = t;
          }
        }, {
          key: "type",
          get: function get() {
            return this._type;
          }
        }, {
          key: "baked",
          get: function get() {
            return this.staticSettings.baked;
          },
          set: function set(t) {
            this.staticSettings.baked = t, null !== this._light && (this._light.baked = t);
          }
        }]), i;
      }(z), yt.Type = C, yt.PhotometricTerm = Fi, pt = r((ut = mt).prototype, "_color", [O], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return P.WHITE.clone();
        }
      }), gt = r(ut.prototype, "_useColorTemperature", [O], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !1;
        }
      }), dt = r(ut.prototype, "_colorTemperature", [O], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 6550;
        }
      }), _t = r(ut.prototype, "_staticSettings", [O], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return new vi();
        }
      }), r(ut.prototype, "color", [nt], Object.getOwnPropertyDescriptor(ut.prototype, "color"), ut.prototype), r(ut.prototype, "useColorTemperature", [rt], Object.getOwnPropertyDescriptor(ut.prototype, "useColorTemperature"), ut.prototype), r(ut.prototype, "colorTemperature", [D, at, st], Object.getOwnPropertyDescriptor(ut.prototype, "colorTemperature"), ut.prototype), r(ut.prototype, "staticSettings", [ht, lt], Object.getOwnPropertyDescriptor(ut.prototype, "staticSettings"), ut.prototype), ct = ut)) || ct)),
          Ai = t("D", (ft = w("cc.DirectionalLight"), Dt = B(), Ot = H(), St = A("_illuminance"), Rt = S(), Lt = F(), zt = k({
        group: {
          name: "DynamicShadowSettings",
          displayOrder: 1
        }
      }), Pt = f(l), kt = F(), jt = k({
        group: {
          name: "DynamicShadowSettings",
          displayOrder: 5
        }
      }), Nt = f(j), Bt = F(), Ht = k({
        group: {
          name: "DynamicShadowSettings",
          displayOrder: 6
        }
      }), Ft = f(c), vt = F(), Tt = k({
        group: {
          name: "DynamicShadowSettings",
          displayOrder: 7
        }
      }), At = f(c), Et = F(), Mt = k({
        group: {
          name: "DynamicShadowSettings",
          displayOrder: 8
        }
      }), Ct = R(), xt = f(c), It = F(), Ut = k({
        group: {
          name: "DynamicShadowSettings",
          displayOrder: 9
        }
      }), Xt = S(), Wt = R(), Gt = f(c), Vt = F(), Zt = k({
        group: {
          name: "DynamicShadowSettings",
          displayOrder: 10
        }
      }), $t = S(), Kt = R(), Qt = f(c), Yt = F(), qt = k({
        group: {
          name: "DynamicShadowSettings",
          displayOrder: 11
        }
      }), Jt = f(l), te = F(), ee = k({
        group: {
          name: "DynamicShadowSettings",
          displayOrder: 12
        }
      }), ie = f(c), oe = F(), ne = k({
        group: {
          name: "DynamicShadowSettings",
          displayOrder: 13
        }
      }), re = f(c), ae = F(), se = k({
        group: {
          name: "DynamicShadowSettings",
          displayOrder: 14
        }
      }), he = f(c), ft(le = Dt(le = Ot(le = N((Re = function (t) {
        function i() {
          var e;
          return e = t.call(this) || this, s(e, "_illuminanceHDR", ue, h(e)), s(e, "_illuminanceLDR", pe, h(e)), s(e, "_shadowEnabled", ge, h(e)), s(e, "_shadowPcf", de, h(e)), s(e, "_shadowBias", _e, h(e)), s(e, "_shadowNormalBias", ye, h(e)), s(e, "_shadowSaturation", me, h(e)), s(e, "_shadowDistance", we, h(e)), s(e, "_shadowInvisibleOcclusionRange", be, h(e)), s(e, "_shadowFixedArea", fe, h(e)), s(e, "_shadowNear", De, h(e)), s(e, "_shadowFar", Oe, h(e)), s(e, "_shadowOrthoSize", Se, h(e)), e._type = C.DIRECTIONAL, e._light = null, e._lightType = I, e;
        }

        return a(i, t), i.prototype._createLight = function () {
          t.prototype._createLight.call(this), this._light && (this._light.illuminanceHDR = this._illuminanceHDR, this._light.illuminanceLDR = this._illuminanceLDR, this._light.shadowEnabled = this._shadowEnabled, this._light.shadowPcf = this._shadowPcf, this._light.shadowBias = this._shadowBias, this._light.shadowNormalBias = this._shadowNormalBias, this._light.shadowSaturation = this._shadowSaturation, this._light.shadowDistance = this._shadowDistance, this._light.shadowInvisibleOcclusionRange = this._shadowInvisibleOcclusionRange, this._light.shadowFixedArea = this._shadowFixedArea, this._light.shadowNear = this._shadowNear, this._light.shadowFar = this._shadowFar, this._light.shadowOrthoSize = this._shadowOrthoSize);
        }, n(i, [{
          key: "illuminance",
          get: function get() {
            return e.director.root.pipeline.pipelineSceneData.isHDR ? this._illuminanceHDR : this._illuminanceLDR;
          },
          set: function set(t) {
            e.director.root.pipeline.pipelineSceneData.isHDR ? (this._illuminanceHDR = t, this._light && (this._light.illuminanceHDR = this._illuminanceHDR)) : (this._illuminanceLDR = t, this._light && (this._light.illuminanceLDR = this._illuminanceLDR));
          }
        }, {
          key: "shadowEnabled",
          get: function get() {
            return this._shadowEnabled;
          },
          set: function set(t) {
            this._shadowEnabled = t, this._light && (this._light.shadowEnabled = this._shadowEnabled);
          }
        }, {
          key: "shadowPcf",
          get: function get() {
            return this._shadowPcf;
          },
          set: function set(t) {
            this._shadowPcf = t, this._light && (this._light.shadowPcf = this._shadowPcf);
          }
        }, {
          key: "shadowBias",
          get: function get() {
            return this._shadowBias;
          },
          set: function set(t) {
            this._shadowBias = t, this._light && (this._light.shadowBias = this._shadowBias);
          }
        }, {
          key: "shadowNormalBias",
          get: function get() {
            return this._shadowNormalBias;
          },
          set: function set(t) {
            this._shadowNormalBias = t, this._light && (this._light.shadowNormalBias = this._shadowNormalBias);
          }
        }, {
          key: "shadowSaturation",
          get: function get() {
            return this._shadowSaturation;
          },
          set: function set(t) {
            this._shadowSaturation = v(t, 0, 1), this._light && (this._light.shadowSaturation = this._shadowSaturation);
          }
        }, {
          key: "shadowDistance",
          get: function get() {
            return this._shadowDistance;
          },
          set: function set(t) {
            this._shadowDistance = Math.min(t, T.MAX_FAR), this._light && (this._light.shadowDistance = this._shadowDistance);
          }
        }, {
          key: "shadowInvisibleOcclusionRange",
          get: function get() {
            return this._shadowInvisibleOcclusionRange;
          },
          set: function set(t) {
            this._shadowInvisibleOcclusionRange = Math.min(t, T.MAX_FAR), this._light && (this._light.shadowInvisibleOcclusionRange = this._shadowInvisibleOcclusionRange);
          }
        }, {
          key: "shadowFixedArea",
          get: function get() {
            return this._shadowFixedArea;
          },
          set: function set(t) {
            this._shadowFixedArea = t, this._light && (this._light.shadowFixedArea = this._shadowFixedArea);
          }
        }, {
          key: "shadowNear",
          get: function get() {
            return this._shadowNear;
          },
          set: function set(t) {
            this._shadowNear = t, this._light && (this._light.shadowNear = this._shadowNear);
          }
        }, {
          key: "shadowFar",
          get: function get() {
            return this._shadowFar;
          },
          set: function set(t) {
            this._shadowFar = Math.min(t, T.MAX_FAR), this._light && (this._light.shadowFar = this._shadowFar);
          }
        }, {
          key: "shadowOrthoSize",
          get: function get() {
            return this._shadowOrthoSize;
          },
          set: function set(t) {
            this._shadowOrthoSize = t, this._light && (this._light.shadowOrthoSize = this._shadowOrthoSize);
          }
        }]), i;
      }(Ti), ue = r((ce = Re).prototype, "_illuminanceHDR", [k, St], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 65e3;
        }
      }), pe = r(ce.prototype, "_illuminanceLDR", [O], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 65e3 * U.standardExposureValue;
        }
      }), ge = r(ce.prototype, "_shadowEnabled", [O], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !1;
        }
      }), de = r(ce.prototype, "_shadowPcf", [O], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return j.HARD;
        }
      }), _e = r(ce.prototype, "_shadowBias", [O], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 1e-5;
        }
      }), ye = r(ce.prototype, "_shadowNormalBias", [O], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 0;
        }
      }), me = r(ce.prototype, "_shadowSaturation", [O], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 1;
        }
      }), we = r(ce.prototype, "_shadowDistance", [O], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 100;
        }
      }), be = r(ce.prototype, "_shadowInvisibleOcclusionRange", [O], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 200;
        }
      }), fe = r(ce.prototype, "_shadowFixedArea", [O], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !1;
        }
      }), De = r(ce.prototype, "_shadowNear", [O], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return .1;
        }
      }), Oe = r(ce.prototype, "_shadowFar", [O], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 10;
        }
      }), Se = r(ce.prototype, "_shadowOrthoSize", [O], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 5;
        }
      }), r(ce.prototype, "illuminance", [Rt], Object.getOwnPropertyDescriptor(ce.prototype, "illuminance"), ce.prototype), r(ce.prototype, "shadowEnabled", [Lt, zt, b, Pt], Object.getOwnPropertyDescriptor(ce.prototype, "shadowEnabled"), ce.prototype), r(ce.prototype, "shadowPcf", [kt, jt, b, Nt], Object.getOwnPropertyDescriptor(ce.prototype, "shadowPcf"), ce.prototype), r(ce.prototype, "shadowBias", [Bt, Ht, b, Ft], Object.getOwnPropertyDescriptor(ce.prototype, "shadowBias"), ce.prototype), r(ce.prototype, "shadowNormalBias", [vt, Tt, b, At], Object.getOwnPropertyDescriptor(ce.prototype, "shadowNormalBias"), ce.prototype), r(ce.prototype, "shadowSaturation", [Et, Mt, b, Ct, D, xt], Object.getOwnPropertyDescriptor(ce.prototype, "shadowSaturation"), ce.prototype), r(ce.prototype, "shadowDistance", [It, Ut, b, Xt, Wt, D, Gt], Object.getOwnPropertyDescriptor(ce.prototype, "shadowDistance"), ce.prototype), r(ce.prototype, "shadowInvisibleOcclusionRange", [Vt, Zt, b, $t, Kt, D, Qt], Object.getOwnPropertyDescriptor(ce.prototype, "shadowInvisibleOcclusionRange"), ce.prototype), r(ce.prototype, "shadowFixedArea", [Yt, qt, b, Jt], Object.getOwnPropertyDescriptor(ce.prototype, "shadowFixedArea"), ce.prototype), r(ce.prototype, "shadowNear", [te, ee, b, ie], Object.getOwnPropertyDescriptor(ce.prototype, "shadowNear"), ce.prototype), r(ce.prototype, "shadowFar", [oe, ne, b, re], Object.getOwnPropertyDescriptor(ce.prototype, "shadowFar"), ce.prototype), r(ce.prototype, "shadowOrthoSize", [ae, se, he], Object.getOwnPropertyDescriptor(ce.prototype, "shadowOrthoSize"), ce.prototype), le = ce)) || le) || le) || le) || le)),
          Ei = t("S", (Le = w("cc.SphereLight"), ze = B(), Pe = H(), ke = A("_luminance"), je = L(), Ne = S(), Be = L(), He = S(), Fe = f(Fi), ve = L(), Te = S(), Ae = S(), Ee = S(), Le(Me = ze(Me = Pe(Me = N((Ge = function (t) {
        function i() {
          var e;
          return e = t.call(this) || this, s(e, "_size", xe, h(e)), s(e, "_luminanceHDR", Ie, h(e)), s(e, "_luminanceLDR", Ue, h(e)), s(e, "_term", Xe, h(e)), s(e, "_range", We, h(e)), e._type = C.SPHERE, e._light = null, e._lightType = X, e;
        }

        return a(i, t), i.prototype._createLight = function () {
          t.prototype._createLight.call(this), this.size = this._size, this.range = this._range, this._light && (this._light.luminanceHDR = this._luminanceHDR, this._light.luminanceLDR = this._luminanceLDR);
        }, n(i, [{
          key: "luminousFlux",
          get: function get() {
            return e.director.root.pipeline.pipelineSceneData.isHDR ? this._luminanceHDR * W(this._size) : this._luminanceLDR;
          },
          set: function set(t) {
            var i = 0;
            e.director.root.pipeline.pipelineSceneData.isHDR ? (this._luminanceHDR = t / W(this._size), i = this._luminanceHDR) : (this._luminanceLDR = t, i = this._luminanceLDR), this._light && (this._light.luminance = i);
          }
        }, {
          key: "luminance",
          get: function get() {
            return e.director.root.pipeline.pipelineSceneData.isHDR ? this._luminanceHDR : this._luminanceLDR;
          },
          set: function set(t) {
            e.director.root.pipeline.pipelineSceneData.isHDR ? (this._luminanceHDR = t, this._light && (this._light.luminanceHDR = this._luminanceHDR)) : (this._luminanceLDR = t, this._light && (this._light.luminanceLDR = this._luminanceLDR));
          }
        }, {
          key: "term",
          get: function get() {
            return this._term;
          },
          set: function set(t) {
            this._term = t;
          }
        }, {
          key: "size",
          get: function get() {
            return this._size;
          },
          set: function set(t) {
            this._size = t, this._light && (this._light.size = t);
          }
        }, {
          key: "range",
          get: function get() {
            return this._range;
          },
          set: function set(t) {
            this._range = t, this._light && (this._light.range = t);
          }
        }]), i;
      }(Ti), xe = r((Ce = Ge).prototype, "_size", [O], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return .15;
        }
      }), Ie = r(Ce.prototype, "_luminanceHDR", [O, ke], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 1700 / W(.15);
        }
      }), Ue = r(Ce.prototype, "_luminanceLDR", [O], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 1700 / W(.15) * U.standardExposureValue * U.standardLightMeterScale;
        }
      }), Xe = r(Ce.prototype, "_term", [O], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return Fi.LUMINOUS_FLUX;
        }
      }), We = r(Ce.prototype, "_range", [O], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 1;
        }
      }), r(Ce.prototype, "luminousFlux", [je, Ne], Object.getOwnPropertyDescriptor(Ce.prototype, "luminousFlux"), Ce.prototype), r(Ce.prototype, "luminance", [Be, He], Object.getOwnPropertyDescriptor(Ce.prototype, "luminance"), Ce.prototype), r(Ce.prototype, "term", [Fe, ve, Te], Object.getOwnPropertyDescriptor(Ce.prototype, "term"), Ce.prototype), r(Ce.prototype, "size", [Ae], Object.getOwnPropertyDescriptor(Ce.prototype, "size"), Ce.prototype), r(Ce.prototype, "range", [Ee], Object.getOwnPropertyDescriptor(Ce.prototype, "range"), Ce.prototype), Me = Ce)) || Me) || Me) || Me) || Me)),
          Mi = t("a", (Ve = w("cc.SpotLight"), Ze = B(), $e = H(), Ke = A("_luminance"), Qe = S(), Ye = L(), qe = S(), Je = L(), ti = f(Fi), ei = L(), ii = S(), oi = S(), ni = S(), ri = R(), ai = S(), si = F(), hi = k({
        group: {
          name: "DynamicShadowSettings",
          displayOrder: 1
        }
      }), li = f(l), ci = F(), ui = k({
        group: {
          name: "DynamicShadowSettings",
          displayOrder: 2
        }
      }), pi = f(j), gi = F(), di = k({
        group: {
          name: "DynamicShadowSettings",
          displayOrder: 3
        }
      }), _i = f(c), yi = F(), mi = k({
        group: {
          name: "DynamicShadowSettings",
          displayOrder: 4
        }
      }), wi = f(c), Ve(bi = Ze(bi = $e(bi = N((Bi = function (t) {
        function i() {
          var e;
          return e = t.call(this) || this, s(e, "_size", Di, h(e)), s(e, "_luminanceHDR", Oi, h(e)), s(e, "_luminanceLDR", Si, h(e)), s(e, "_term", Ri, h(e)), s(e, "_range", Li, h(e)), s(e, "_spotAngle", zi, h(e)), s(e, "_shadowEnabled", Pi, h(e)), s(e, "_shadowPcf", ki, h(e)), s(e, "_shadowBias", ji, h(e)), s(e, "_shadowNormalBias", Ni, h(e)), e._type = C.SPOT, e._light = null, e._lightType = G, e;
        }

        return a(i, t), i.prototype._createLight = function () {
          t.prototype._createLight.call(this), this.size = this._size, this.range = this._range, this.spotAngle = this._spotAngle, this._light && (this._light.luminanceHDR = this._luminanceHDR, this._light.luminanceLDR = this._luminanceLDR, this._light.shadowEnabled = this._shadowEnabled, this._light.shadowPcf = this._shadowPcf, this._light.shadowBias = this._shadowBias, this._light.shadowNormalBias = this._shadowNormalBias);
        }, n(i, [{
          key: "luminousFlux",
          get: function get() {
            return e.director.root.pipeline.pipelineSceneData.isHDR ? this._luminanceHDR * W(this._size) : this._luminanceLDR;
          },
          set: function set(t) {
            var i = 0;
            e.director.root.pipeline.pipelineSceneData.isHDR ? (this._luminanceHDR = t / W(this._size), i = this._luminanceHDR) : (this._luminanceLDR = t, i = this._luminanceLDR), this._light && (this._light.luminance = i);
          }
        }, {
          key: "luminance",
          get: function get() {
            return e.director.root.pipeline.pipelineSceneData.isHDR ? this._luminanceHDR : this._luminanceLDR;
          },
          set: function set(t) {
            e.director.root.pipeline.pipelineSceneData.isHDR ? (this._luminanceHDR = t, this._light && (this._light.luminanceHDR = this._luminanceHDR)) : (this._luminanceLDR = t, this._light && (this._light.luminanceLDR = this._luminanceLDR));
          }
        }, {
          key: "term",
          get: function get() {
            return this._term;
          },
          set: function set(t) {
            this._term = t;
          }
        }, {
          key: "size",
          get: function get() {
            return this._size;
          },
          set: function set(t) {
            this._size = t, this._light && (this._light.size = t);
          }
        }, {
          key: "range",
          get: function get() {
            return this._range;
          },
          set: function set(t) {
            this._range = t, this._light && (this._light.range = t);
          }
        }, {
          key: "spotAngle",
          get: function get() {
            return this._spotAngle;
          },
          set: function set(t) {
            this._spotAngle = t, this._light && (this._light.spotAngle = E(t));
          }
        }, {
          key: "shadowEnabled",
          get: function get() {
            return this._shadowEnabled;
          },
          set: function set(t) {
            this._shadowEnabled = t, this._light && (this._light.shadowEnabled = t);
          }
        }, {
          key: "shadowPcf",
          get: function get() {
            return this._shadowPcf;
          },
          set: function set(t) {
            this._shadowPcf = t, this._light && (this._light.shadowPcf = t);
          }
        }, {
          key: "shadowBias",
          get: function get() {
            return this._shadowBias;
          },
          set: function set(t) {
            this._shadowBias = t, this._light && (this._light.shadowBias = t);
          }
        }, {
          key: "shadowNormalBias",
          get: function get() {
            return this._shadowNormalBias;
          },
          set: function set(t) {
            this._shadowNormalBias = t, this._light && (this._light.shadowNormalBias = t);
          }
        }]), i;
      }(Ti), Di = r((fi = Bi).prototype, "_size", [O], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return .15;
        }
      }), Oi = r(fi.prototype, "_luminanceHDR", [O, Ke], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 1700 / W(.15);
        }
      }), Si = r(fi.prototype, "_luminanceLDR", [O], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 1700 / W(.15) * U.standardExposureValue * U.standardLightMeterScale;
        }
      }), Ri = r(fi.prototype, "_term", [O], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return Fi.LUMINOUS_FLUX;
        }
      }), Li = r(fi.prototype, "_range", [O], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 1;
        }
      }), zi = r(fi.prototype, "_spotAngle", [O], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 60;
        }
      }), Pi = r(fi.prototype, "_shadowEnabled", [O], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !1;
        }
      }), ki = r(fi.prototype, "_shadowPcf", [O], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return j.HARD;
        }
      }), ji = r(fi.prototype, "_shadowBias", [O], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 1e-5;
        }
      }), Ni = r(fi.prototype, "_shadowNormalBias", [O], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 0;
        }
      }), r(fi.prototype, "luminousFlux", [Qe, Ye], Object.getOwnPropertyDescriptor(fi.prototype, "luminousFlux"), fi.prototype), r(fi.prototype, "luminance", [qe, Je], Object.getOwnPropertyDescriptor(fi.prototype, "luminance"), fi.prototype), r(fi.prototype, "term", [ti, ei, ii], Object.getOwnPropertyDescriptor(fi.prototype, "term"), fi.prototype), r(fi.prototype, "size", [oi], Object.getOwnPropertyDescriptor(fi.prototype, "size"), fi.prototype), r(fi.prototype, "range", [ni], Object.getOwnPropertyDescriptor(fi.prototype, "range"), fi.prototype), r(fi.prototype, "spotAngle", [D, ri, ai], Object.getOwnPropertyDescriptor(fi.prototype, "spotAngle"), fi.prototype), r(fi.prototype, "shadowEnabled", [si, hi, b, li], Object.getOwnPropertyDescriptor(fi.prototype, "shadowEnabled"), fi.prototype), r(fi.prototype, "shadowPcf", [ci, ui, b, pi], Object.getOwnPropertyDescriptor(fi.prototype, "shadowPcf"), fi.prototype), r(fi.prototype, "shadowBias", [gi, di, b, _i], Object.getOwnPropertyDescriptor(fi.prototype, "shadowBias"), fi.prototype), r(fi.prototype, "shadowNormalBias", [yi, mi, b, wi], Object.getOwnPropertyDescriptor(fi.prototype, "shadowNormalBias"), fi.prototype), bi = fi)) || bi) || bi) || bi) || bi));

      e.LightComponent = Ti, i.setClassAlias(Ti, "cc.LightComponent"), e.DirectionalLightComponent = Ai, i.setClassAlias(Ai, "cc.DirectionalLightComponent"), e.SphereLightComponent = Ei, i.setClassAlias(Ei, "cc.SphereLightComponent"), e.SpotLightComponent = Mi, i.setClassAlias(Mi, "cc.SpotLightComponent"), M(Mi.prototype, "SpotLight.prototype", [{
        name: "luminousPower",
        newName: "luminousFlux",
        customGetter: function customGetter() {
          return this.luminousFlux;
        },
        customSetter: function customSetter(t) {
          this.luminousFlux = t;
        }
      }]), M(Ei.prototype, "SphereLight.prototype", [{
        name: "luminousPower",
        newName: "luminousFlux",
        customGetter: function customGetter() {
          return this.luminousFlux;
        },
        customSetter: function customSetter(t) {
          this.luminousFlux = t;
        }
      }]), M(Ti.PhotometricTerm, "Light.PhotometricTerm", [{
        name: "LUMINOUS_POWER",
        newName: "LUMINOUS_FLUX"
      }]), e.utils = wt;
    }
  };
}); 
 			}); 
		define("__plugin__/wx0446ba2621dda60a/index-f2b92470.js", function(require, module, exports){ 			
"use strict";

require("@babel/runtime/helpers/Arrayincludes");

var _typeof2 = require("@babel/runtime/helpers/typeof");

System.register(["./texture-barrier-60b5983b.js", "./json-asset-933a1d4c.js", "./renderable-component-7c6600ed.js", "./deprecated-26630860.js", "./deprecated-ef6bb945.js"], function (e, t) {
  "use strict";

  var n, r, a, i, s, o, u, l, c, d, h, f, p, g, m, v, _, y, w, b, A, R, x, T, N, I, P, k, E, S, C, M, D, B, L, j, O, U, F, q, W, V, G, z, H, X, Q, Y, J, K, Z, $, ee, te, ne, re, ae, ie, se, oe, ue, le, ce, de, he, fe, pe, ge, me, ve, _e, ye, we, be, Ae, Re, xe, Te, Ne, Ie, Pe, ke, Ee, Se, Ce, Me, De, Be, Le, je, Oe, Ue, Fe, qe, We, Ve, Ge, ze, He, Xe, Qe, Ye, Je, Ke, Ze, $e, et, tt, nt, rt, at, it, st, ot, ut, lt, ct, dt, ht, ft, pt, gt, mt, vt, _t, yt, wt, bt, At, Rt, xt, Tt, Nt, It, Pt, kt, Et, St, Ct, Mt, Dt, Bt, Lt, jt, Ot, Ut, Ft, qt, Wt, Vt, Gt, zt, Ht, Xt, Qt, Yt;

  return {
    setters: [function (e) {
      n = e.bt, r = e.e, a = e.ah, i = e.l, s = e.a9, o = e.al, u = e.o, l = e.q, c = e.aC, d = e.m, h = e.aE, f = e.as, p = e.y, g = e.aq, m = e.r, v = e.s, _ = e.bU, y = e.k, w = e.af, b = e.bX, A = e.i, R = e.cE, x = e.bD, T = e.cp, N = e.f, I = e.bO, P = e.ct, k = e.cw, E = e.bT, S = e.d, C = e.cF, M = e.cG, D = e.bQ;
    }, function (e) {
      B = e.V, L = e.O, j = e.Q, O = e.R, U = e.T, F = e.U, q = e.W, W = e.X, V = e.Y, G = e.Z, z = e.$, H = e.a0, X = e.a1, Q = e.a2, Y = e.a3, J = e.a4, K = e.a5, Z = e.a6, $ = e.a7, ee = e.a8, te = e.a9, ne = e.aa, re = e.ab, ae = e.ac, ie = e.ad, se = e.ae, oe = e.af, ue = e.ag, le = e.ah, ce = e.ai, de = e.aj, he = e.ak, fe = e.al, pe = e.am, ge = e.an, me = e.ao, ve = e.ap, _e = e.aq, ye = e.ar, we = e.as, be = e.at, Ae = e.ck, Re = e.cl, xe = e.bM, Te = e.cm, Ne = e.cn, Ie = e.cf, Pe = e.co, ke = e.bK, Ee = e.bJ, Se = e.cp, Ce = e.cq, Me = e.bL, De = e.cr, Be = e.cs, Le = e.ct, je = e.cu, Oe = e.cv, Ue = e.cw, Fe = e.cx, qe = e.cy, We = e.cz, Ve = e.cA, Ge = e.cB, ze = e.cC, He = e.aW, Xe = e.b3, Qe = e.bQ, Ye = e.cD, Je = e.ax, Ke = e.ay, Ze = e.az, $e = e.cE, et = e.cF, tt = e.cG, nt = e.cH, rt = e.cI, at = e.aL, it = e.cJ, st = e.cK, ot = e.cL, ut = e.cM, lt = e.cN, ct = e.aP, dt = e.cO, ht = e.b0, ft = e.cP, pt = e.m, gt = e.cQ, mt = e.b, vt = e.cR, _t = e.aS, yt = e.aR, wt = e.aQ, bt = e.aM, At = e.cS, Rt = e.cT, xt = e.aT, Tt = e.cU, Nt = e.cV, It = e.cW, Pt = e.cX, kt = e.cY, Et = e.cZ, St = e.c_, Ct = e.c$, Mt = e.d0, Dt = e.d1, Bt = e.d2, Lt = e.d3, jt = e.e, Ot = e.d4, Ut = e.d5, Ft = e.c, qt = e.d6, Wt = e.d;
    }, function (e) {
      Vt = e.g;
    }, function (e) {
      Gt = e.g;
    }, function (e) {
      zt = e.S, Ht = e.a, Xt = e.R, Qt = e.D, Yt = e.d;
    }],
    execute: function execute() {
      var Jt = Object.freeze({
        __proto__: null,
        bits: n,
        Vec2: B,
        v2: L,
        Vec3: j,
        v3: O,
        Vec4: U,
        v4: F,
        Quat: q,
        quat: W,
        Mat3: V,
        Mat4: G,
        mat4: z,
        AffineTransform: H,
        Size: X,
        size: Q,
        Rect: Y,
        rect: J,
        Color: K,
        color: Z,
        EPSILON: $,
        equals: ee,
        approx: te,
        clamp: ne,
        clamp01: re,
        lerp: ae,
        toRadian: ie,
        toDegree: se,
        random: oe,
        randomRange: ue,
        randomRangeInt: le,
        pseudoRandom: ce,
        pseudoRandomRange: de,
        pseudoRandomRangeInt: he,
        nextPow2: fe,
        repeat: pe,
        pingPong: ge,
        inverseLerp: me,
        absMaxComponent: ve,
        absMax: _e,
        enumerableProps: ye,
        MATH_FLOAT_ARRAY: we,
        MathBase: be
      });
      e("m", Jt);
      var Kt = Object.freeze({
        __proto__: null,
        distance: Ae,
        enums: Re,
        intersect: xe,
        Line: Te,
        Plane: Ne,
        Ray: Ie,
        Triangle: Pe,
        Sphere: ke,
        AABB: Ee,
        OBB: Se,
        Capsule: Ce,
        Frustum: Me,
        Keyframe: De,
        AnimationCurve: Be,

        get ERaycastMode() {
          return Le;
        },

        line: je,
        plane: Oe,
        ray: Ue,
        triangle: Fe,
        sphere: qe,
        aabb: We,
        obb: Ve,
        capsule: Ge,
        frustum: ze
      });
      e("g", Kt);

      var Zt = new B(),
          $t = function () {
        var e = t.prototype;

        function t() {
          this.handle = 0, this.callBack = null, this.cancelAnimate = !1, this.startTime = -1, this.isPause = !1, this._splashFinish = !1, this._loadFinish = !1, this._directCall = !1;
        }

        return e.pauseRendering = function () {
          this.isPause = !0;
        }, e.resumeRendering = function () {
          this.isPause = !1;
        }, e.main = function (e) {
          if (null != e) {
            if (window._CCSettings && window._CCSettings.splashScreen) {
              var t = this.settings = window._CCSettings.splashScreen;
              t.totalTime = null != this.settings.totalTime ? this.settings.totalTime : 3e3, t.base64src = this.settings.base64src || "", t.effect = this.settings.effect || "FADE-INOUT", t.clearColor = this.settings.clearColor || new a(.88, .88, .88, 1), t.displayRatio = null != this.settings.displayRatio ? this.settings.displayRatio : .4, t.displayWatermark = null == this.settings.displayWatermark || this.settings.displayWatermark;
            } else this.settings = {
              totalTime: 3e3,
              base64src: "",
              effect: "FADE-INOUT",
              clearColor: new a(.88, .88, .88, 1),
              displayRatio: .4,
              displayWatermark: !0
            };

            if ("" === this.settings.base64src || this.settings.totalTime <= 0) this.callBack && this.callBack(), this.callBack = null, this.settings = null, this._directCall = !0;else {
              i.view.resizeWithBrowserSize(!0);
              var n = window._CCSettings.designResolution;
              n ? i.view.setDesignResolutionSize(n.width, n.height, n.policy) : i.view.setDesignResolutionSize(960, 640, 4), this.device = e.device, this.swapchain = e.mainWindow.swapchain, this.framebuffer = e.mainWindow.framebuffer, i.game.once(i.Game.EVENT_GAME_INITED, function () {
                i.director._lateUpdate = performance.now();
              }, i.director), this.callBack = null, this.cancelAnimate = !1, this.startTime = -1, this.preInit(), this.logoImage = new Image(), this.logoImage.onload = this.init.bind(this), this.logoImage.src = this.settings.base64src;
            }
          } else r("RENDER ROOT IS NULL.");
        }, e.setOnFinish = function (e) {
          if (this._directCall && e) return t._ins = void 0, void e();
          this.callBack = e;
        }, e._tryToStart = function () {
          this._splashFinish && this._loadFinish && this.callBack && (this.callBack(), this.hide(), i.game.resume());
        }, e.preInit = function () {
          var e = this.settings.clearColor;
          this.clearColors = [new a(e.x, e.y, e.z, e.w)];
          var t = this.device,
              n = this.swapchain;
          this.renderArea = new s(0, 0, n.width, n.height), this.cmdBuff = t.commandBuffer;
          var r = new Float32Array([.5, .5, 1, 0, -.5, .5, 0, 0, .5, -.5, 1, 1, -.5, -.5, 0, 1]),
              i = 4 * Float32Array.BYTES_PER_ELEMENT,
              f = 4 * i;
          this.vertexBuffers = t.createBuffer(new o(u.VERTEX | u.TRANSFER_DST, l.DEVICE, f, i)), this.vertexBuffers.update(r);
          var p = new Uint16Array([0, 1, 2, 1, 3, 2]),
              g = Uint16Array.BYTES_PER_ELEMENT,
              m = 6 * g;
          this.indicesBuffers = t.createBuffer(new o(u.INDEX | u.TRANSFER_DST, l.DEVICE, m, g)), this.indicesBuffers.update(p);

          var v = [new c("a_position", d.RG32F), new c("a_texCoord", d.RG32F)],
              _ = new h(v, [this.vertexBuffers], this.indicesBuffers);

          this.quadAssmebler = t.createInputAssembler(_), this.projection = new G(), G.ortho(this.projection, -1, 1, -1, 1, -1, 1, t.capabilities.clipSpaceMinZ, t.capabilities.clipSpaceSignY, n.surfaceTransform);
        }, e.init = function () {
          var e = this;
          this.initLogo(), this.settings.displayWatermark && this.initWarterMark(), i.game.pause(), this.handle = requestAnimationFrame(function t(n) {
            if (!e.cancelAnimate) {
              var r = e.settings,
                  a = e.device,
                  i = e.swapchain;
              G.ortho(e.projection, -1, 1, -1, 1, -1, 1, a.capabilities.clipSpaceMinZ, a.capabilities.clipSpaceSignY, i.surfaceTransform);
              var s = i.width,
                  o = i.height,
                  u = s < o ? s : o;
              e.startTime < 0 && (e.startTime = n);
              var l = n - e.startTime,
                  c = re(l / r.totalTime),
                  d = Ye(c);
              "NONE" === r.effect && (d = 1);
              var h = e.logoTexture.width,
                  f = e.logoTexture.height,
                  p = u * r.displayRatio,
                  g = p * h / f,
                  m = p;

              if (i.surfaceTransform !== y.ROTATE_90 && i.surfaceTransform !== y.ROTATE_270 || (g = p * s / o, m = p * f / h * o / s), e.logoMat.setProperty("resolution", Zt.set(s, o), 0), e.logoMat.setProperty("scale", Zt.set(g, m), 0), e.logoMat.setProperty("translate", Zt.set(.5 * s, .5 * o), 0), e.logoMat.setProperty("percent", d), e.logoMat.setProperty("u_projection", e.projection), e.logoMat.passes[0].update(), r.displayWatermark && e.watermarkMat) {
                var v = .5 * u,
                    _ = e.watermarkTexture.width,
                    w = v,
                    b = v * e.watermarkTexture.height / _;
                i.surfaceTransform !== y.ROTATE_90 && i.surfaceTransform !== y.ROTATE_270 || (w = .5 * v, b = v * s / o * .5), e.watermarkMat.setProperty("resolution", Zt.set(s, o), 0), e.watermarkMat.setProperty("scale", Zt.set(w, b), 0), e.watermarkMat.setProperty("translate", Zt.set(.5 * s, .1 * o), 0), e.watermarkMat.setProperty("percent", d), e.watermarkMat.setProperty("u_projection", e.projection), e.watermarkMat.passes[0].update();
              }

              e.isPause || (e.frame(), l > r.totalTime && (e.splashFinish = !0)), requestAnimationFrame(t);
            }
          });
        }, e.hide = function () {
          cancelAnimationFrame(this.handle), this.cancelAnimate = !0, setTimeout(this.destroy.bind(this));
        }, e.initLogo = function () {
          var e = this.device;
          this.logoMat = new He(), this.logoMat.initialize({
            effectName: "splash-screen"
          });
          var t = new f();
          t.addressU = p.CLAMP, t.addressV = p.CLAMP, t.addressW = p.CLAMP, this.sampler = e.getSampler(t), this.logoTexture = e.createTexture(new g(m.TEX2D, v.SAMPLED | v.TRANSFER_DST, d.RGBA8, this.logoImage.width, this.logoImage.height));
          var n = this.logoMat.passes[0],
              r = n.getBinding("mainTexture");
          n.bindTexture(r, this.logoTexture), this.shader = n.getShaderVariant();
          var a = n.descriptorSet;
          a.bindSampler(r, this.sampler), a.update();
          var i = new w();
          i.texExtent.width = this.logoImage.width, i.texExtent.height = this.logoImage.height, i.texExtent.depth = 1, e.copyTexImagesToTexture([this.logoImage], this.logoTexture, [i]);
        }, e.initWarterMark = function () {
          var e = document.createElement("canvas");
          e.width = 330, e.height = 30, e.style.width = "" + e.width, e.style.height = "" + e.height;
          var t = e.getContext("2d");
          t.font = "18px Arial", t.textBaseline = "top", t.textAlign = "left", t.fillStyle = "`#424242`";
          var n = "Powered by Cocos Creator",
              r = t.measureText(n);
          t.fillText(n, (330 - r.width) / 2, 6);
          var a = new w();
          a.texExtent.width = e.width, a.texExtent.height = e.height, a.texExtent.depth = 1, this.watermarkTexture = this.device.createTexture(new g(m.TEX2D, v.SAMPLED | v.TRANSFER_DST, d.RGBA8, e.width, e.height)), this.device.copyTexImagesToTexture([e], this.watermarkTexture, [a]), this.watermarkMat = new He(), this.watermarkMat.initialize({
            effectName: "splash-screen"
          });
          var i = this.watermarkMat.passes[0],
              s = i.getBinding("mainTexture");
          i.bindTexture(s, this.watermarkTexture), i.descriptorSet.update();
        }, e.frame = function () {
          var e = this.device,
              t = this.swapchain;
          e.acquire([t]);
          var n = this.cmdBuff,
              r = this.framebuffer,
              a = this.renderArea;
          a.width = t.width, a.height = t.height, n.begin(), n.beginRenderPass(r.renderPass, r, a, this.clearColors, 1, 0);
          var i = this.logoMat.passes[0],
              s = Xe.getOrCreatePipelineState(e, i, this.shader, r.renderPass, this.quadAssmebler);

          if (n.bindPipelineState(s), n.bindDescriptorSet(Qe.MATERIAL, i.descriptorSet), n.bindInputAssembler(this.quadAssmebler), n.draw(this.quadAssmebler), this.settings.displayWatermark && this.watermarkMat) {
            var o = this.watermarkMat.passes[0],
                u = Xe.getOrCreatePipelineState(e, o, this.shader, r.renderPass, this.quadAssmebler);
            n.bindPipelineState(u), n.bindDescriptorSet(Qe.MATERIAL, o.descriptorSet), n.bindInputAssembler(this.quadAssmebler), n.draw(this.quadAssmebler);
          }

          n.endRenderPass(), n.end(), e.flushCommands([n]), e.queue.submit([n]), e.present();
        }, e.destroy = function () {
          this.callBack = null, this.device = null, this.swapchain = null, this.clearColors = null, this.logoImage.destroy && this.logoImage.destroy(), this.logoImage = null, this.framebuffer = null, this.renderArea = null, this.cmdBuff = null, this.shader = null, this.logoMat.destroy(), this.logoMat = null, this.logoTexture.destroy(), this.logoTexture = null, this.quadAssmebler.destroy(), this.quadAssmebler = null, this.vertexBuffers.destroy(), this.vertexBuffers = null, this.indicesBuffers.destroy(), this.indicesBuffers = null, this.sampler = null, this.watermarkTexture && (this.watermarkMat.destroy(), this.watermarkMat = null, this.watermarkTexture.destroy(), this.watermarkTexture = null), this.settings = null, t._ins = void 0;
        }, _(t, [{
          key: "splashFinish",
          set: function set(e) {
            this._splashFinish = e, this._tryToStart();
          }
        }, {
          key: "loadFinish",
          set: function set(e) {
            this._loadFinish = e, this._tryToStart();
          }
        }], [{
          key: "instance",
          get: function get() {
            return t._ins || (t._ins = new t()), t._ins;
          }
        }]), t;
      }();

      $t._ins = void 0, i.internal.SplashScreen = $t;
      var en = {};
      Je(en, "vmath", [{
        name: "vec2",
        newName: "Vec2",
        target: Jt,
        targetName: "math"
      }, {
        name: "vec3",
        newName: "Vec3",
        target: Jt,
        targetName: "math"
      }, {
        name: "vec4",
        newName: "Vec4",
        target: Jt,
        targetName: "math"
      }, {
        name: "quat",
        newName: "Quat",
        target: Jt,
        targetName: "math"
      }, {
        name: "mat3",
        newName: "Mat3",
        target: Jt,
        targetName: "math"
      }, {
        name: "mat4",
        newName: "Mat4",
        target: Jt,
        targetName: "math"
      }, {
        name: "color4",
        newName: "Color",
        target: Jt,
        targetName: "math"
      }, {
        name: "rect",
        newName: "Rect",
        target: Jt,
        targetName: "math"
      }, {
        name: "approx",
        newName: "approx",
        target: Jt,
        targetName: "math"
      }, {
        name: "EPSILON",
        newName: "EPSILON",
        target: Jt,
        targetName: "math"
      }, {
        name: "equals",
        newName: "equals",
        target: Jt,
        targetName: "math"
      }, {
        name: "clamp",
        newName: "clamp",
        target: Jt,
        targetName: "math"
      }, {
        name: "clamp01",
        newName: "clamp01",
        target: Jt,
        targetName: "math"
      }, {
        name: "lerp",
        newName: "lerp",
        target: Jt,
        targetName: "math"
      }, {
        name: "toRadian",
        newName: "toRadian",
        target: Jt,
        targetName: "math"
      }, {
        name: "toDegree",
        newName: "toDegree",
        target: Jt,
        targetName: "math"
      }, {
        name: "random",
        newName: "random",
        target: Jt,
        targetName: "math"
      }, {
        name: "randomRange",
        newName: "randomRange",
        target: Jt,
        targetName: "math"
      }, {
        name: "randomRangeInt",
        newName: "randomRangeInt",
        target: Jt,
        targetName: "math"
      }, {
        name: "pseudoRandom",
        newName: "pseudoRandom",
        target: Jt,
        targetName: "math"
      }, {
        name: "pseudoRandomRangeInt",
        newName: "pseudoRandomRangeInt",
        target: Jt,
        targetName: "math"
      }, {
        name: "nextPow2",
        newName: "nextPow2",
        target: Jt,
        targetName: "math"
      }, {
        name: "repeat",
        newName: "repeat",
        target: Jt,
        targetName: "math"
      }, {
        name: "pingPong",
        newName: "pingPong",
        target: Jt,
        targetName: "math"
      }, {
        name: "inverseLerp",
        newName: "inverseLerp",
        target: Jt,
        targetName: "math"
      }]), i.vmath = en, Je(zt.prototype, "Scheduler.prototype", [{
        name: "enableForTarget",
        newName: "enableForTarget",
        target: zt,
        targetName: "Scheduler"
      }]), Je(zt, "Scheduler", [{
        name: "PRIORITY_SYSTEM",
        newName: "System.Priority.SCHEDULER",
        customGetter: function customGetter() {
          return Ht.Priority.SCHEDULER;
        }
      }]), Ke(zt, "Scheduler", [{
        name: "PRIORITY_NON_SYSTEM",
        suggest: "Use enum` System.Priority` instead"
      }]), Je(Vt.prototype, "SubModel.prototype", [{
        name: "subMeshData",
        newName: "subMesh"
      }]), Ke(Vt.prototype, "SubModel.prototype", [{
        name: "getSubModel",
        suggest: "Use `subModels[i]` instead"
      }, {
        name: "subModelNum",
        suggest: "Use `subModels.length` instead"
      }]), Je(Xt.prototype, "Root.prototype", [{
        name: "ui",
        newName: "batcher2D"
      }]), Ze(Gt, "game", [{
        name: "collisionMatrix"
      }, {
        name: "groupList"
      }]), Ze(Qt.prototype, "director", [{
        name: "calculateDeltaTime"
      }, {
        name: "getDeltaTime",
        suggest: "Use game.deltaTime instead"
      }, {
        name: "getTotalTime",
        suggest: "Use game.totalTime instead"
      }, {
        name: "getCurrentTime",
        suggest: "Use game.frameStartTime instead"
      }]), Ke(Qt.prototype, "director", [{
        name: "setAnimationInterval",
        suggest: "please use game.frameRate instead"
      }, {
        name: "getAnimationInterval",
        suggest: "please use game.frameRate instead"
      }, {
        name: "getRunningScene",
        suggest: "please use getScene instead"
      }, {
        name: "setDepthTest",
        suggest: "please use camera API instead"
      }, {
        name: "setClearColor",
        suggest: "please use camera API instead"
      }, {
        name: "getWinSize",
        suggest: "please use view.getVisibleSize instead"
      }, {
        name: "getWinSizeInPixels"
      }, {
        name: "purgeCachedData",
        suggest: "please use assetManager.releaseAll instead"
      }, {
        name: "convertToGL"
      }, {
        name: "convertToUI"
      }]);

      var tn = function () {
        function e() {
          this.name = "", this.base = "", this.importBase = "", this.nativeBase = "", this.deps = null, this.assetInfos = new $e(), this.scenes = new $e(), this.paths = new $e();
        }

        var t = e.prototype;
        return t.init = function (e) {
          var t = this;
          !function (e) {
            var t = e.uuids,
                n = e.paths,
                r = e.types,
                a = e.deps,
                i = e.paths = Object.create(null);

            if (!1 === e.debug) {
              for (var s = 0, o = t.length; s < o; s++) {
                t[s] = tt(t[s]);
              }

              for (var u in n) {
                var l = n[u],
                    c = l[1];
                l[1] = r[c];
              }
            } else {
              for (var d = Object.create(null), h = 0, f = t.length; h < f; h++) {
                var p = t[h];
                t[h] = d[p] = tt(p);
              }

              t = d;
            }

            for (var g in n) {
              var m = n[g];
              i[t[g]] = m;
            }

            var v = e.scenes;

            for (var _ in v) {
              var y = v[_];
              v[_] = t[y];
            }

            var w = e.packs;

            for (var b in w) {
              for (var A = w[b], R = 0; R < A.length; ++R) {
                A[R] = t[A[R]];
              }
            }

            var x = e.versions;
            if (x) for (var T in x) {
              for (var N = x[T], I = 0; I < N.length; I += 2) {
                var P = N[I];
                N[I] = t[P] || P;
              }
            }
            var k = e.redirect;
            if (k) for (var E = 0; E < k.length; E += 2) {
              k[E] = t[k[E]], k[E + 1] = a[k[E + 1]];
            }

            if (e.extensionMap) {
              var S = function S(n) {
                if (!Object.prototype.hasOwnProperty.call(e.extensionMap, n)) return "continue";
                e.extensionMap[n].forEach(function (r, a) {
                  e.extensionMap[n][a] = t[r] || r;
                });
              };

              for (var C in e.extensionMap) {
                S(C);
              }
            }
          }(e), this.importBase = e.importBase || "", this.nativeBase = e.nativeBase || "", this.base = e.base || "", this.name = e.name || "", this.deps = e.deps || [], this._initUuid(e.uuids), this._initPath(e.paths), this._initScene(e.scenes), this._initPackage(e.packs), this._initVersion(e.versions), this._initRedirect(e.redirect);

          var n = function n(_n2) {
            if (!Object.prototype.hasOwnProperty.call(e.extensionMap, _n2)) return "continue";

            e.extensionMap[_n2].forEach(function (e) {
              var r = t.assetInfos.get(e);
              r && (r.extension = _n2);
            });
          };

          for (var r in e.extensionMap) {
            n(r);
          }
        }, t.getInfoWithPath = function (e, t) {
          if (!e) return null;
          e = et(e);
          var n = this.paths.get(e);

          if (n) {
            if (!t) return n[0];

            for (var r = 0, a = n.length; r < a; r++) {
              var i = n[r];
              if (b.isChildClassOf(i.ctor, t)) return i;
            }
          }

          return null;
        }, t.getDirWithPath = function (e, t, n) {
          "/" === (e = et(e))[e.length - 1] && (e = e.slice(0, -1));
          var r = n || [];
          return this.paths.forEach(function (n, a) {
            if (a.startsWith(e) && function (e, t) {
              return !(e.length > t.length) || 47 === e.charCodeAt(t.length);
            }(a, e) || !e) for (var i = 0, s = n.length; i < s; i++) {
              var o = n[i];
              t && !b.isChildClassOf(o.ctor, t) || r.push(o);
            }
          }), r;
        }, t.getAssetInfo = function (e) {
          return this.assetInfos.get(e) || null;
        }, t.getSceneInfo = function (e) {
          return e.endsWith(".scene") || (e += ".scene"), "/" === e[0] || e.startsWith("db://") || (e = "/" + e), this.scenes.find(function (t, n) {
            return n.endsWith(e);
          });
        }, t.destroy = function () {
          this.paths.destroy(), this.scenes.destroy(), this.assetInfos.destroy();
        }, t._initUuid = function (e) {
          if (e) {
            this.assetInfos.clear();

            for (var t = 0, n = e.length; t < n; t++) {
              var r = e[t];
              this.assetInfos.add(r, {
                uuid: r
              });
            }
          }
        }, t._initPath = function (e) {
          if (e) {
            var t = this.paths;

            for (var n in t.clear(), e) {
              var r = e[n],
                  a = r[0],
                  i = r[1],
                  s = 3 === r.length,
                  o = this.assetInfos.get(n);
              o.path = a, o.ctor = b._getClassById(i), t.has(a) ? s ? t.get(a).push(o) : t.get(a).unshift(o) : t.add(a, [o]);
            }
          }
        }, t._initScene = function (e) {
          if (e) {
            var t = this.scenes;
            t.clear();
            var n = this.assetInfos;

            for (var r in e) {
              var a = e[r],
                  i = n.get(a);
              i.url = r, t.add(r, i);
            }
          }
        }, t._initPackage = function (e) {
          if (e) {
            var t = this.assetInfos;

            for (var n in e) {
              var r = e[n],
                  a = {
                uuid: n,
                packedUuids: r,
                ext: ".json"
              };
              t.add(n, a);

              for (var i = 0, s = r.length; i < s; i++) {
                var o = r[i],
                    u = t.get(o),
                    l = u.packs;
                l ? 1 === s ? l.unshift(a) : l.push(a) : u.packs = [a];
              }
            }
          }
        }, t._initVersion = function (e) {
          if (e) {
            var t = this.assetInfos,
                n = e.import;
            if (n) for (var r = 0, a = n.length; r < a; r += 2) {
              var i = n[r];
              t.get(i).ver = n[r + 1];
            }
            if (n = e.native) for (var s = 0, o = n.length; s < o; s += 2) {
              var u = n[s];
              t.get(u).nativeVer = n[s + 1];
            }
          }
        }, t._initRedirect = function (e) {
          if (e) for (var t = this.assetInfos, n = 0, r = e.length; n < r; n += 2) {
            var a = e[n];
            t.get(a).redirect = e[n + 1];
          }
        }, e;
      }();

      function nn(e, t) {
        e._uuid && t.push(e._uuid);
      }

      function rn(e, t) {
        for (var n = Object.getOwnPropertyNames(e), r = 0; r < n.length; r++) {
          var a = n[r];

          if ("node" !== a && "__eventTargets" !== a) {
            var i = e[a];
            if ("object" == _typeof2(i) && i) if (Array.isArray(i)) for (var s = 0; s < i.length; s++) {
              var o = i[s];
              o instanceof at && nn(o, t);
            } else if (i.constructor && i.constructor !== Object) i instanceof at && nn(i, t);else for (var u = Object.getOwnPropertyNames(i), l = 0; l < u.length; l++) {
              var c = i[u[l]];
              c instanceof at && nn(c, t);
            }
          }
        }
      }

      function an(e, t) {
        for (var n = 0; n < e._components.length; n++) {
          rn(e._components[n], t);
        }

        for (var r = 0; r < e._children.length; r++) {
          an(e._children[r], t);
        }
      }

      function sn(e, t, n, r) {
        n.push(e._uuid);

        for (var a = rt.getDeps(e._uuid), i = 0, s = a.length; i < s; i++) {
          var o = nt.get(a[i]);

          if (o) {
            var u = o._uuid;
            u in t ? t[u] += r : t[u] = o.refCount + r, n.includes(u) || sn(o, t, n, r);
          }
        }
      }

      var on = [],
          un = new (function () {
        function e() {
          this._persistNodeDeps = new $e(), this._toDelete = new $e(), this._eventListener = !1;
        }

        var t = e.prototype;
        return t.init = function () {
          this._persistNodeDeps.clear(), this._toDelete.clear();
        }, t._addPersistNodeRef = function (e) {
          var t = [];
          an(e, t);

          for (var n = 0, r = t.length; n < r; n++) {
            var a = nt.get(t[n]);
            a && a.addRef();
          }

          this._persistNodeDeps.add(e.uuid, t);
        }, t._removePersistNodeRef = function (e) {
          if (this._persistNodeDeps.has(e.uuid)) {
            for (var t = this._persistNodeDeps.get(e.uuid), n = 0, r = t.length; n < r; n++) {
              var a = nt.get(t[n]);
              a && a.decRef();
            }

            this._persistNodeDeps.remove(e.uuid);
          }
        }, t._autoRelease = function (e, t, n) {
          if (e) {
            for (var r = rt.getDeps(e.uuid), a = 0, i = r.length; a < i; a++) {
              var s = nt.get(r[a]);
              s && s.decRef(e.autoReleaseAssets);
            }

            var o = rt._depends.get(e.uuid);

            if (o && o.persistDeps) for (var u = o.persistDeps, l = 0, c = u.length; l < c; l++) {
              var d = nt.get(u[l]);
              d && d.decRef(e.autoReleaseAssets);
            }
            e.uuid !== t.uuid && rt.remove(e.uuid);
          }

          var h = rt._depends.get(t.uuid);

          for (var f in h && (h.persistDeps = []), n) {
            for (var p, g, m = n[f], v = this._persistNodeDeps.get(m.uuid), _ = A(v); !(g = _()).done;) {
              var y = g.value,
                  w = nt.get(y);
              w && w.addRef();
            }

            h && (p = h.persistDeps).push.apply(p, v);
          }
        }, t.tryRelease = function (e, t) {
          void 0 === t && (t = !1), e instanceof at && (t ? this._free(e, t) : (this._toDelete.add(e._uuid, e), this._eventListener || (this._eventListener = !0, R(this._freeAssets.bind(this)))));
        }, t._freeAssets = function () {
          var e = this;
          this._eventListener = !1, this._toDelete.forEach(function (t) {
            e._free(t);
          }), this._toDelete.clear();
        }, t._free = function (e, t) {
          void 0 === t && (t = !1);
          var n = e._uuid;

          if (this._toDelete.remove(n), x(e, !0) && !(!t && e.refCount > 0 && function (e) {
            var t = Object.create(null);
            if (t[e._uuid] = e.refCount, sn(e, t, on, -1), on.length = 0, 0 !== t[e._uuid]) return t[e._uuid];

            for (var n in t) {
              0 !== t[n] && sn(nt.get(n), t, on, 1);
            }

            return on.length = 0, t[e._uuid];
          }(e) > 0)) {
            nt.remove(n);

            for (var r = rt.getDeps(n), a = 0, i = r.length; a < i; a++) {
              var s = nt.get(r[a]);
              s && (s.decRef(!1), this._free(s, !1));
            }

            e.destroy(), rt.remove(n);
          }
        }, e;
      }())(),
          ln = null;

      function cn(e, t) {
        for (var n = 0, r = e.input.length; n < r; n++) {
          var a = e.input[n];
          t && !a.isNative && a.content instanceof at && a.content.decRef(!1), a.recycle();
        }

        e.input = null;
      }

      function dn(e, t) {
        return t ? /\?/.test(e) ? e + "&_t=" + Date.now() : e + "?_t=" + Date.now() : e;
      }

      function hn(e, t, n, r, a) {
        void 0 === a && (a = 0), e(a, function (i, s) {
          a++, !i || a > t ? r && r(i, s) : setTimeout(function () {
            hn(e, t, n, r, a);
          }, n);
        });
      }

      function fn(e, t, n, a, i) {
        try {
          for (var s = rt.parse(e, t), o = 0, u = s.deps.length; o < u; o++) {
            var l = s.deps[o];
            l in n || (n[l] = !0, a.push({
              uuid: l,
              bundle: i && i.name
            }));
          }

          s.nativeDep && (i && (s.nativeDep.bundle = i.name), a.push(T({}, s.nativeDep)));
        } catch (e) {
          r(e.message, e.stack);
        }
      }

      function pn(e, t, n) {
        t && (n = void 0 !== n ? n : i.assetManager.cacheAsset, it(t) || !n || t.isDefault || nt.add(e, t));
      }

      function gn(e, t, n) {
        var r = 0,
            a = [],
            i = e.length;
        0 === i && n && n(a);

        for (var s = function s(e) {
          e && a.push(e), ++r === i && n && n(a);
        }, o = 0; o < i; o++) {
          t(e[o], s);
        }
      }

      function mn(e, t, n) {
        var r = e,
            a = t,
            i = n;

        if (void 0 === n) {
          var s = "function" == typeof e;
          t ? (i = t, s || (a = null)) : void 0 === t && s && (i = e, r = null, a = null), void 0 !== t && s && (a = e, r = null);
        }

        return {
          options: r || Object.create(null),
          onProgress: a,
          onComplete: i
        };
      }

      function vn(e, t, n) {
        var r = e,
            a = t,
            i = n;

        if (void 0 === n) {
          var s = b.isChildClassOf(e, at);
          t ? (i = t, s && (a = null)) : void 0 !== t || s || (i = e, a = null, r = null), void 0 === t || s || (a = e, r = null);
        }

        return {
          type: r,
          onProgress: a || ln,
          onComplete: i
        };
      }

      function _n(e, t, n, r) {
        if (void 0 === r && (r = {}), !n[t] || r[t]) return !1;
        r[t] = !0;
        var a = !1,
            i = rt.getDeps(t);
        if (i) for (var s = 0, o = i.length; s < o; s++) {
          var u = i[s];

          if (u === e || _n(e, u, n, r)) {
            a = !0;
            break;
          }
        }
        return a;
      }

      function yn(e) {
        return function (t, n) {
          if (e) {
            var r = [];
            Array.isArray(n) ? n.forEach(function (e) {
              return e instanceof at && r.push(e.addRef());
            }) : n instanceof at && r.push(n.addRef()), R(function () {
              r.forEach(function (e) {
                return e.decRef(!1);
              }), e(t, n);
            });
          }
        };
      }

      var wn = function () {
        function e() {
          this._config = new tn();
        }

        var t = e.prototype;
        return t.getInfoWithPath = function (e, t) {
          return this._config.getInfoWithPath(e, t);
        }, t.getDirWithPath = function (e, t, n) {
          return this._config.getDirWithPath(e, t, n);
        }, t.getAssetInfo = function (e) {
          return this._config.getAssetInfo(e);
        }, t.getSceneInfo = function (e) {
          return this._config.getSceneInfo(e);
        }, t.init = function (e) {
          this._config.init(e), ut.add(e.name, this);
        }, t.load = function (e, t, n, r) {
          var a = vn(t, n, r),
              s = a.type,
              o = a.onProgress,
              u = a.onComplete,
              l = {
            __requestType__: lt.PATH,
            type: s,
            bundle: this.name,
            __outputAsArray__: Array.isArray(e)
          };
          i.assetManager.loadAny(e, l, o, u);
        }, t.preload = function (e, t, n, r) {
          var a = vn(t, n, r),
              s = a.type,
              o = a.onProgress,
              u = a.onComplete;
          i.assetManager.preloadAny(e, {
            __requestType__: lt.PATH,
            type: s,
            bundle: this.name
          }, o, u);
        }, t.loadDir = function (e, t, n, r) {
          var a = vn(t, n, r),
              s = a.type,
              o = a.onProgress,
              u = a.onComplete;
          i.assetManager.loadAny(e, {
            __requestType__: lt.DIR,
            type: s,
            bundle: this.name,
            __outputAsArray__: !0
          }, o, u);
        }, t.preloadDir = function (e, t, n, r) {
          var a = vn(t, n, r),
              s = a.type,
              o = a.onProgress,
              u = a.onComplete;
          i.assetManager.preloadAny(e, {
            __requestType__: lt.DIR,
            type: s,
            bundle: this.name
          }, o, u);
        }, t.loadScene = function (e, t, n, a) {
          var s = mn(t, n, a),
              o = s.options,
              u = s.onProgress,
              l = s.onComplete;
          o.preset = o.preset || "scene", o.bundle = this.name, i.assetManager.loadAny({
            scene: e
          }, o, u, function (e, t) {
            if (e) r(e.message, e.stack);else if (t instanceof ct && t.scene) {
              var n = t.scene;
              n._id = t._uuid, n.name = t.name;
            } else e = new Error("The asset " + t._uuid + " is not a scene");
            l && l(e, t);
          });
        }, t.preloadScene = function (e, t, n, r) {
          var a = mn(t, n, r),
              s = a.options,
              o = a.onProgress,
              u = a.onComplete;
          s.bundle = this.name, i.assetManager.preloadAny({
            scene: e
          }, s, o, function (t) {
            t && N(1210, e, t.message), u && u(t);
          });
        }, t.get = function (e, t) {
          var n = this.getInfoWithPath(e, t);
          return n && nt.get(n.uuid) || null;
        }, t.release = function (e, t) {
          var n = this.get(e, t);
          n && un.tryRelease(n, !0);
        }, t.releaseUnusedAssets = function () {
          var e = this;
          nt.forEach(function (t) {
            var n = e.getAssetInfo(t._uuid);
            n && !n.redirect && un.tryRelease(t);
          });
        }, t.releaseAll = function () {
          var e = this;
          nt.forEach(function (t) {
            var n = e.getAssetInfo(t._uuid);
            n && !n.redirect && un.tryRelease(t, !0);
          });
        }, t._destroy = function () {
          this._config.destroy();
        }, _(e, [{
          key: "config",
          get: function get() {
            return this._config;
          }
        }, {
          key: "name",
          get: function get() {
            return this._config.name;
          }
        }, {
          key: "deps",
          get: function get() {
            return this._config.deps;
          }
        }, {
          key: "base",
          get: function get() {
            return this._config.base;
          }
        }]), e;
      }(),
          bn = e("r", new wn());

      function An(e, t, n) {
        var r = new Image();

        function a() {
          r.removeEventListener("load", a), r.removeEventListener("error", i), n && n(null, r);
        }

        function i() {
          r.removeEventListener("load", a), r.removeEventListener("error", i), n && n(new Error(I(4930, e)));
        }

        return "file:" !== window.location.protocol && (r.crossOrigin = "anonymous"), r.addEventListener("load", a), r.addEventListener("error", i), r.src = e, r;
      }

      function Rn(e, t, n, r) {
        var a = new XMLHttpRequest(),
            i = "download failed: " + e + ", status: ";
        if (a.open("GET", e, !0), void 0 !== t.xhrResponseType && (a.responseType = t.xhrResponseType), void 0 !== t.xhrWithCredentials && (a.withCredentials = t.xhrWithCredentials), void 0 !== t.xhrMimeType && a.overrideMimeType && a.overrideMimeType(t.xhrMimeType), void 0 !== t.xhrTimeout && (a.timeout = t.xhrTimeout), t.xhrHeader) for (var s in t.xhrHeader) {
          a.setRequestHeader(s, t.xhrHeader[s]);
        }
        return a.onload = function () {
          200 === a.status || 0 === a.status ? r && r(null, a.response) : r && r(new Error("" + i + a.status + "(no response)"));
        }, n && (a.onprogress = function (e) {
          e.lengthComputable && n(e.loaded, e.total);
        }), a.onerror = function () {
          r && r(new Error("" + i + a.status + "(error)"));
        }, a.ontimeout = function () {
          r && r(new Error("" + i + a.status + "(time out)"));
        }, a.onabort = function () {
          r && r(new Error("" + i + a.status + "(abort)"));
        }, a.send(null), a;
      }

      i.resources = bn;
      var xn = {};

      function Tn(e, t, n) {
        if (xn[e]) return n && n(null), null;
        var r = document.createElement("script");

        function a() {
          r.parentNode.removeChild(r), r.removeEventListener("load", a, !1), r.removeEventListener("error", i, !1), xn[e] = !0, n && n(null);
        }

        function i() {
          r.parentNode.removeChild(r), r.removeEventListener("load", a, !1), r.removeEventListener("error", i, !1), n && n(new Error(I(4928, e)));
        }

        return "file:" !== window.location.protocol && (r.crossOrigin = "anonymous"), r.async = t.scriptAsyncLoading || !1, r.src = e, r.addEventListener("load", a, !1), r.addEventListener("error", i, !1), document.body.appendChild(r), r;
      }

      var Nn = /^(?:\w+:\/\/|\.+\/).+/,
          In = function In(e, t, n) {
        (ht.hasFeature(ht.Feature.IMAGE_BITMAP) && i.assetManager.allowImageBitmap ? Pn : An)(e, t, n);
      },
          Pn = function Pn(e, t, n) {
        t.xhrResponseType = "blob", Rn(e, t, t.onFileProgress, n);
      },
          kn = function kn(e, t, n) {
        t.xhrResponseType = "json", Rn(e, t, t.onFileProgress, n);
      },
          En = function En(e, t, n) {
        t.xhrResponseType = "arraybuffer", Rn(e, t, t.onFileProgress, n);
      },
          Sn = function Sn(e, t, n) {
        kn(e, t, function (t, r) {
          if (t) n(t);else {
            var a = ft(r);
            Promise.all(a.chunks.map(function (n) {
              return new Promise(function (r, a) {
                En("" + pt(e) + n, {}, function (e, n) {
                  t ? a(t) : r(new Uint8Array(n));
                });
              });
            })).then(function (e) {
              var t = new vt(a.document, e);
              n(null, t);
            }).catch(function (e) {
              n(e);
            });
          }
        });
      },
          Cn = function Cn(e, t, n) {
        En(e, t, function (e, t) {
          if (e) n(e);else try {
            var r = gt(new Uint8Array(t));
            n(null, r);
          } catch (e) {
            n(e);
          }
        });
      },
          Mn = function Mn(e, t, n) {
        t.xhrResponseType = "text", Rn(e, t, t.onFileProgress, n);
      },
          Dn = function Dn(e, t, n) {
        var r = mt(e),
            a = e;
        Nn.test(a) || (a = -1 !== Ln.remoteBundles.indexOf(r) ? Ln.remoteServerAddress + "remote/" + r : "assets/" + r);
        var i = t.version || Ln.bundleVers[r],
            s = 0,
            o = null,
            u = null;
        kn(a + "/config." + (i ? i + "." : "") + "json", t, function (e, t) {
          u = e, (o = t) && (o.base = a + "/"), 2 == ++s && n(u, o);
        }), Tn(a + "/index." + (i ? i + "." : "") + "js", t, function (e) {
          u = e, 2 == ++s && n(e, o);
        });
      },
          Bn = function () {
        function e() {
          this.maxConcurrency = 6, this.maxRequestsPerFrame = 6, this.maxRetryCount = 3, this.appendTimeStamp = !!k, this.limited = !k, this.retryInterval = 2e3, this.bundleVers = null, this.remoteBundles = [], this.downloadDomImage = An, this.downloadDomAudio = null, this.downloadFile = Rn, this.downloadScript = Tn, this._downloaders = {
            ".png": In,
            ".jpg": In,
            ".bmp": In,
            ".jpeg": In,
            ".gif": In,
            ".ico": In,
            ".tiff": In,
            ".webp": In,
            ".image": In,
            ".pvr": En,
            ".pkm": En,
            ".astc": En,
            ".txt": Mn,
            ".xml": Mn,
            ".vsh": Mn,
            ".fsh": Mn,
            ".atlas": Mn,
            ".tmx": Mn,
            ".tsx": Mn,
            ".json": kn,
            ".ExportJson": kn,
            ".plist": Mn,
            ".ccon": Sn,
            ".cconb": Cn,
            ".fnt": Mn,
            ".binary": En,
            ".bin": En,
            ".dbbin": En,
            ".skel": En,
            ".js": Tn,
            bundle: Dn,
            default: Mn
          }, this._downloading = new $e(), this._queue = [], this._queueDirty = !1, this._totalNum = 0, this._totalNumThisPeriod = 0, this._lastDate = -1, this._checkNextPeriod = !1, this._remoteServerAddress = "", this._maxInterval = 1 / 30;
        }

        var t = e.prototype;
        return t.init = function (e, t, n) {
          void 0 === e && (e = ""), void 0 === t && (t = {}), void 0 === n && (n = []), this._downloading.clear(), this._queue.length = 0, this._remoteServerAddress = e, this.bundleVers = t, this.remoteBundles = n;
        }, t.register = function (e, t) {
          "object" == _typeof2(e) ? P(this._downloaders, e) : this._downloaders[e] = t;
        }, t.download = function (e, t, n, r, a) {
          var i = this,
              s = dt.get(e);
          if (s) a(null, s);else {
            var o = this._downloading.get(e);

            if (o) {
              o.push(a);

              var u = this._queue.find(function (t) {
                return t.id === e;
              });

              if (!u) return;
              var l = r.priority || 0;
              u.priority < l && (u.priority = l, this._queueDirty = !0);
            } else {
              var c = void 0 !== r.maxRetryCount ? r.maxRetryCount : this.maxRetryCount,
                  d = void 0 !== r.maxConcurrency ? r.maxConcurrency : this.maxConcurrency,
                  h = void 0 !== r.maxRequestsPerFrame ? r.maxRequestsPerFrame : this.maxRequestsPerFrame,
                  f = this._downloaders[n] || this._downloaders.default;
              hn(function (n, s) {
                if (0 === n && i._downloading.add(e, [a]), i.limited) {
                  i._updateTime();

                  var o = function o(e, t) {
                    i._totalNum--, i._handleQueueInNextFrame(d, h), s(e, t);
                  };

                  i._totalNum < d && i._totalNumThisPeriod < h ? (f(dn(t, i.appendTimeStamp), r, o), i._totalNum++, i._totalNumThisPeriod++) : (i._queue.push({
                    id: e,
                    priority: r.priority || 0,
                    url: t,
                    options: r,
                    done: o,
                    handler: f
                  }), i._queueDirty = !0, i._totalNum < d && i._handleQueueInNextFrame(d, h));
                } else f(dn(t, i.appendTimeStamp), r, s);
              }, c, this.retryInterval, function (t, n) {
                t || dt.add(e, n);

                for (var r = i._downloading.remove(e), a = 0, s = r.length; a < s; a++) {
                  r[a](t, n);
                }
              });
            }
          }
        }, t.loadSubpackage = function (e, t) {
          i.assetManager.loadBundle(e, null, t);
        }, t._updateTime = function () {
          var e = performance.now(),
              t = i.game.deltaTime,
              n = t > this._maxInterval ? this._maxInterval : t;
          e - this._lastDate > 1e3 * n && (this._totalNumThisPeriod = 0, this._lastDate = e);
        }, t._handleQueue = function (e, t) {
          for (this._checkNextPeriod = !1, this._updateTime(); this._queue.length > 0 && this._totalNum < e && this._totalNumThisPeriod < t;) {
            this._queueDirty && (this._queue.sort(function (e, t) {
              return e.priority - t.priority;
            }), this._queueDirty = !1);

            var n = this._queue.pop();

            if (!n) break;
            this._totalNum++, this._totalNumThisPeriod++, n.handler(dn(n.url, this.appendTimeStamp), n.options, n.done);
          }

          this._handleQueueInNextFrame(e, t);
        }, t._handleQueueInNextFrame = function (e, t) {
          !this._checkNextPeriod && this._queue.length > 0 && (R(this._handleQueue.bind(this), e, t), this._checkNextPeriod = !0);
        }, _(e, [{
          key: "remoteServerAddress",
          get: function get() {
            return this._remoteServerAddress;
          }
        }]), e;
      }(),
          Ln = e("d", new Bn());

      function jn(e, t, n, r) {
        var a = null,
            i = null;

        try {
          (a = new _t())._nativeUrl = e, a._nativeAsset = t;
        } catch (e) {
          i = e;
        }

        r(i, a);
      }

      function On(e, t, n, r) {
        var a = new yt();
        a.json = t, r(null, a);
      }

      function Un(e, t, n, r) {
        var a = new wt();
        a.text = t, r(null, a);
      }

      function Fn(e, t, n, r) {
        var a = new bt();
        a._nativeUrl = e, a._nativeAsset = t, r(null, a);
      }

      function qn(e, t, n, r) {
        var a = new at();
        a._nativeUrl = e, a._nativeAsset = t, r(null, a);
      }

      function Wn(e, n, r, a) {
        var i = ut.get(n.name);
        i || (i = n.name === At.RESOURCES ? bn : new wn(), n.base = n.base || e + "/", i.init(n)), t.import("virtual:///prerequisite-imports/" + i.name).then(function () {
          a(null, i);
        }).catch(a);
      }

      var Vn = function () {
        function e() {
          this._creating = new $e(), this._producers = {
            ".png": jn,
            ".jpg": jn,
            ".bmp": jn,
            ".jpeg": jn,
            ".gif": jn,
            ".ico": jn,
            ".tiff": jn,
            ".webp": jn,
            ".image": jn,
            ".pvr": jn,
            ".pkm": jn,
            ".txt": Un,
            ".xml": Un,
            ".vsh": Un,
            ".fsh": Un,
            ".atlas": Un,
            ".tmx": Un,
            ".tsx": Un,
            ".fnt": Un,
            ".json": On,
            ".ExportJson": On,
            ".binary": Fn,
            ".bin": Fn,
            ".dbbin": Fn,
            ".skel": Fn,
            bundle: Wn,
            default: qn
          };
        }

        var t = e.prototype;
        return t.register = function (e, t) {
          "object" == _typeof2(e) ? b.mixin(this._producers, e) : this._producers[e] = t;
        }, t.create = function (e, t, n, r, a) {
          var i = this,
              s = this._producers[n] || this._producers.default,
              o = nt.get(e);

          if (r.reloadAsset || !o) {
            var u = this._creating.get(e);

            u ? u.push(a) : (this._creating.add(e, [a]), s(e, t, r, function (t, n) {
              !t && n instanceof at && (n._uuid = e, pn(e, n, r.cacheAsset));

              for (var a = i._creating.remove(e), s = 0, o = a.length; s < o; s++) {
                a[s](t, n);
              }
            }));
          } else a(null, o);
        }, e;
      }(),
          Gn = e("f", new Vn()),
          zn = new (function () {
        function e() {
          this._loading = new $e(), this._unpackers = {
            ".json": this.unpackJson
          };
        }

        var t = e.prototype;
        return t.unpackJson = function (e, t, n, r) {
          var a = b.createMap(!0),
              i = null;

          if (Array.isArray(t)) {
            (t = Rt(t)).length !== e.length && N(4915);

            for (var s = 0; s < e.length; s++) {
              a[e[s] + "@import"] = t[s];
            }
          } else {
            var o = b._getClassId(xt),
                u = b._getClassId(_t);

            if (t.type === o && t.data) {
              var l = t.data;
              l.length !== e.length && N(4915);

              for (var c = 0; c < e.length; c++) {
                a[e[c] + "@import"] = Tt(o, {
                  base: l[c][0],
                  mipmaps: l[c][1]
                });
              }
            } else if (t.type === u && t.data) {
              var d = t.data;
              d.length !== e.length && N(4915);

              for (var h = 0; h < e.length; h++) {
                a[e[h] + "@import"] = d[h];
              }
            } else i = new Error("unmatched type pack!"), a = null;
          }

          r(i, a);
        }, t.init = function () {
          this._loading.clear();
        }, t.register = function (e, t) {
          "object" == _typeof2(e) ? b.mixin(this._unpackers, e) : this._unpackers[e] = t;
        }, t.unpack = function (e, t, n, r, a) {
          t ? (0, this._unpackers[n])(e, t, r, a) : a(new Error("package data is wrong!"));
        }, t.load = function (e, t, n) {
          var a = this;
          if (!e.isNative && e.info && e.info.packs) {
            if (dt.has(e.id)) n(null, dt.get(e.id));else {
              var i = e.info.packs,
                  s = i.find(function (e) {
                return a._loading.has(e.uuid);
              });
              if (s) this._loading.get(s.uuid).push({
                onComplete: n,
                id: e.id
              });else {
                s = i[0], this._loading.add(s.uuid, [{
                  onComplete: n,
                  id: e.id
                }]);
                var o = Nt(s.uuid, {
                  ext: s.ext,
                  bundle: e.config.name
                });
                Ln.download(s.uuid, o, s.ext, e.options, function (t, n) {
                  dt.remove(s.uuid), t && r(t.message, t.stack), a.unpack(s.packedUuids, n, s.ext, e.options, function (e, n) {
                    if (!e) for (var r in n) {
                      dt.add(r, n[r]);
                    }

                    for (var i = a._loading.remove(s.uuid), o = 0, u = i.length; o < u; o++) {
                      var l = i[o];
                      if (t || e) l.onComplete(t || e);else {
                        var c = n[l.id];
                        c ? l.onComplete(null, c) : l.onComplete(new Error("can not retrieve data from package"));
                      }
                    }
                  });
                });
              }
            }
          } else Ln.download(e.id, e.url, e.ext, e.options, n);
        }, e;
      }())();

      function Hn(e, t) {
        var n = !1;
        e.progress || (e.progress = {
          finish: 0,
          total: e.input.length,
          canInvoke: !0
        }, n = !0);
        var a = e.options,
            s = e.progress,
            o = [],
            u = s.total,
            l = a.__exclude__ = a.__exclude__ || Object.create(null);
        e.output = [], gn(e.input, function (a, c) {
          if (!a.isNative && nt.has(a.uuid)) {
            var d = nt.get(a.uuid);
            return a.content = d.addRef(), e.output.push(a), s.canInvoke && e.dispatch("progress", ++s.finish, s.total, a), void c();
          }

          zn.load(a, e.options, function (d, h) {
            d ? e.isFinish || (!i.assetManager.force || n ? (r(d.message, d.stack), s.canInvoke = !1, t(d)) : (e.output.push(a), s.canInvoke && e.dispatch("progress", ++s.finish, s.total, a))) : e.isFinish || (a.file = h, e.output.push(a), a.isNative || (l[a.uuid] = !0, fn(a.uuid, h, l, o, a.config), s.total = u + o.length), s.canInvoke && e.dispatch("progress", ++s.finish, s.total, a)), c();
          });
        }, function () {
          if (e.isFinish) return cn(e, !0), void e.dispatch("error");

          if (o.length > 0) {
            var r = It.create({
              input: o,
              progress: s,
              options: a,
              onProgress: e.onProgress,
              onError: It.prototype.recycle,
              onComplete: function onComplete(a) {
                var i;
                a || ((i = e.output).push.apply(i, r.output), r.recycle()), n && Xn(e), t(a);
              }
            });
            Pt.async(r);
          } else n && Xn(e), t();
        });
      }

      function Xn(e) {
        for (var t = e.output, n = 0, r = t.length; n < r; n++) {
          t[n].content && t[n].content.decRef(!1);
        }
      }

      var Qn = new (function (e) {
        function t() {
          return e.apply(this, arguments) || this;
        }

        E(t, e);
        var n = t.prototype;
        return n.parse = function (e) {
          var t = this._parseXML(e).documentElement;

          if ("plist" !== t.tagName) return S(5100), {};

          for (var n = null, r = 0, a = t.childNodes.length; r < a && 1 !== (n = t.childNodes[r]).nodeType; r++) {
            ;
          }

          return this._parseNode(n);
        }, n._parseNode = function (e) {
          var t = null,
              n = e.tagName;
          if ("dict" === n) t = this._parseDict(e);else if ("array" === n) t = this._parseArray(e);else if ("string" === n) {
            if (1 === e.childNodes.length) t = e.firstChild.nodeValue;else {
              t = "";

              for (var r = 0; r < e.childNodes.length; r++) {
                t += e.childNodes[r].nodeValue;
              }
            }
          } else "false" === n ? t = !1 : "true" === n ? t = !0 : "real" === n ? t = parseFloat(e.firstChild.nodeValue) : "integer" === n && (t = parseInt(e.firstChild.nodeValue, 10));
          return t;
        }, n._parseArray = function (e) {
          for (var t = [], n = 0, r = e.childNodes.length; n < r; n++) {
            var a = e.childNodes[n];
            1 === a.nodeType && t.push(this._parseNode(a));
          }

          return t;
        }, n._parseDict = function (e) {
          for (var t = {}, n = "", r = 0, a = e.childNodes.length; r < a; r++) {
            var i = e.childNodes[r];
            1 === i.nodeType && ("key" === i.tagName ? n = i.firstChild.nodeValue : t[n] = this._parseNode(i));
          }

          return t;
        }, t;
      }(e("S", function () {
        function e() {
          this._parser = null, window.DOMParser && (this._parser = new DOMParser());
        }

        var t = e.prototype;
        return t.parse = function (e) {
          return this._parseXML(e);
        }, t._parseXML = function (e) {
          if (this._parser) return this._parser.parseFromString(e, "text/xml");
          throw new Error("Dom parser is not supported in this platform!");
        }, e;
      }())))();

      function Yn(e, t) {
        return e[t] << 8 | e[t + 1];
      }

      var Jn = new (function () {
        function e() {
          this._parsing = new $e(), this._parsers = {
            ".png": this.parseImage,
            ".jpg": this.parseImage,
            ".bmp": this.parseImage,
            ".jpeg": this.parseImage,
            ".gif": this.parseImage,
            ".ico": this.parseImage,
            ".tiff": this.parseImage,
            ".webp": this.parseImage,
            ".image": this.parseImage,
            ".pvr": this.parsePVRTex,
            ".pkm": this.parsePKMTex,
            ".astc": this.parseASTCTex,
            ".plist": this.parsePlist,
            import: this.parseImport,
            ".ccon": this.parseImport,
            ".cconb": this.parseImport
          };
        }

        var t = e.prototype;
        return t.parseImage = function (e, t, n) {
          e instanceof HTMLImageElement ? n(null, e) : createImageBitmap(e, {
            premultiplyAlpha: "none"
          }).then(function (e) {
            n(null, e);
          }, function (e) {
            n(e, null);
          });
        }, t.parsePVRTex = function (e, t, n) {
          var r = null,
              a = null;

          try {
            var i = e instanceof ArrayBuffer ? e : e.buffer,
                s = new Int32Array(i, 0, 13);

            if (55727696 === s[0]) {
              var o = s[7],
                  u = s[6],
                  l = s[12] + 52;
              a = {
                _data: new Uint8Array(i, l),
                _compressed: !0,
                width: o,
                height: u,
                format: 0
              };
            } else {
              if (559044176 !== s[11]) throw new Error("Invalid magic number in PVR header");
              var c = s[0],
                  d = s[1],
                  h = s[2];
              a = {
                _data: new Uint8Array(i, c),
                _compressed: !0,
                width: h,
                height: d,
                format: 0
              };
            }
          } catch (e) {
            r = e;
          }

          n(r, a);
        }, t.parsePKMTex = function (e, t, n) {
          var r = null,
              a = null;

          try {
            var i = e instanceof ArrayBuffer ? e : e.buffer,
                s = new Uint8Array(i),
                o = Yn(s, 6);
            if (0 !== o && 1 !== o && 3 !== o) throw new Error("Invalid magic number in ETC header");
            var u = Yn(s, 12),
                l = Yn(s, 14);
            Yn(s, 8), Yn(s, 10), a = {
              _data: new Uint8Array(i, 16),
              _compressed: !0,
              width: u,
              height: l,
              format: 0
            };
          } catch (e) {
            r = e;
          }

          n(r, a);
        }, t.parseASTCTex = function (e, t, n) {
          var r = null,
              a = null;

          try {
            var i = e instanceof ArrayBuffer ? e : e.buffer,
                s = new Uint8Array(i);
            if (1554098963 !== s[0] + (s[1] << 8) + (s[2] << 16) + (s[3] << 24)) throw new Error("Invalid magic number in ASTC header");
            var o = s[4],
                u = s[5],
                l = s[6];
            if ((o < 3 || o > 6 || u < 3 || u > 6 || l < 3 || l > 6) && (o < 4 || 7 === o || 9 === o || 11 === o || o > 12 || u < 4 || 7 === u || 9 === u || 11 === u || u > 12 || 1 !== l)) throw new Error("Invalid block number in ASTC header");

            var c = function (e, t) {
              return 4 === e ? St.RGBA_ASTC_4x4 : 5 === e ? 4 === t ? St.RGBA_ASTC_5x4 : St.RGBA_ASTC_5x5 : 6 === e ? 5 === t ? St.RGBA_ASTC_6x5 : St.RGBA_ASTC_6x6 : 8 === e ? 5 === t ? St.RGBA_ASTC_8x5 : 6 === t ? St.RGBA_ASTC_8x6 : St.RGBA_ASTC_8x8 : 10 === e ? 5 === t ? St.RGBA_ASTC_10x5 : 6 === t ? St.RGBA_ASTC_10x6 : 8 === t ? St.RGBA_ASTC_10x8 : St.RGBA_ASTC_10x10 : 10 === t ? St.RGBA_ASTC_12x10 : St.RGBA_ASTC_12x12;
            }(o, u),
                d = s[7] + (s[8] << 8) + (s[9] << 16),
                h = s[10] + (s[11] << 8) + (s[12] << 16);

            s[13], s[14], s[15], a = {
              _data: new Uint8Array(i, 16),
              _compressed: !0,
              width: d,
              height: h,
              format: c
            };
          } catch (e) {
            r = e;
          }

          n(r, a);
        }, t.parsePlist = function (e, t, n) {
          var r = null,
              a = Qn.parse(e);
          a || (r = new Error("parse failed")), n(r, a);
        }, t.parseImport = function (e, t, n) {
          if (e) {
            var r = null,
                a = null;

            try {
              r = kt(e, t);
            } catch (e) {
              a = e;
            }

            n(a, r);
          } else n(new Error("The json file of asset " + t.__uuid__ + " is empty or missing"));
        }, t.init = function () {
          this._parsing.clear();
        }, t.register = function (e, t) {
          "object" == _typeof2(e) ? P(this._parsers, e) : this._parsers[e] = t;
        }, t.parse = function (e, t, n, r, a) {
          var i = this,
              s = Et.get(e);
          if (s) a(null, s);else {
            var o = this._parsing.get(e);

            if (o) o.push(a);else {
              var u = this._parsers[n];
              u ? (this._parsing.add(e, [a]), u(t, r, function (t, n) {
                t ? dt.remove(e) : it(n) || Et.add(e, n);

                for (var r = i._parsing.remove(e), a = 0, s = r.length; a < s; a++) {
                  r[a](t, n);
                }
              })) : a(null, t);
            }
          }
        }, e;
      }())();

      function Kn(e, t) {
        var n = !1;
        e.progress || (e.progress = {
          finish: 0,
          total: e.input.length,
          canInvoke: !0
        }, n = !0);
        var a = e.options,
            s = e.progress;
        a.__exclude__ = a.__exclude__ || Object.create(null), e.output = [], gn(e.input, function (o, u) {
          var l = It.create({
            input: o,
            onProgress: e.onProgress,
            options: a,
            progress: s,
            onComplete: function onComplete(a, c) {
              a && !e.isFinish && (!i.assetManager.force || n ? (r(a.message, a.stack), s.canInvoke = !1, t(a)) : s.canInvoke && e.dispatch("progress", ++s.finish, s.total, o)), e.output.push(c), l.recycle(), u(null);
            }
          });
          Zn.async(l);
        }, function () {
          if (a.__exclude__ = null, e.isFinish) return cn(e, !0), void e.dispatch("error");
          !function (e) {
            var t = e.source;
            if (e.options.__outputAsArray__ || 1 !== t.length) for (var n = e.output = [], r = 0, a = t.length; r < a; r++) {
              n.push(t[r].content);
            } else e.output = t[0].content;
          }(e), cn(e, !0), t();
        });
      }

      var Zn = new Ct("loadOneAsset", [function (e, t) {
        var n = e.output = e.input,
            r = n.options,
            a = n.isNative,
            i = n.uuid,
            s = n.file,
            o = r.reloadAsset;
        s || !o && !a && nt.has(i) ? t() : zn.load(n, e.options, function (e, r) {
          n.file = r, t(e);
        });
      }, function (e, t) {
        var n = e.output = e.input,
            a = e.progress,
            i = e.options.__exclude__,
            s = n.id,
            o = n.file,
            u = n.options;
        if (n.isNative) Jn.parse(s, o, n.ext, u, function (r, i) {
          r ? t(r) : (n.content = i, a.canInvoke && e.dispatch("progress", ++a.finish, a.total, n), dt.remove(s), Et.remove(s), t());
        });else {
          var l = n.uuid;

          if (l in i) {
            var c = i[l],
                d = c.finish,
                h = c.content,
                f = c.err,
                p = c.callbacks;
            a.canInvoke && e.dispatch("progress", ++a.finish, a.total, n), d || _n(l, l, i) ? (h && h.addRef(), n.content = h, t(f)) : p.push({
              done: t,
              item: n
            });
          } else if (!u.reloadAsset && nt.has(l)) {
            var g = nt.get(l);
            n.content = g.addRef(), a.canInvoke && e.dispatch("progress", ++a.finish, a.total, n), t();
          } else u.__uuid__ = l, Jn.parse(s, o, "import", u, function (n, a) {
            n ? t(n) : function (e, t, n) {
              var a = e.input,
                  i = e.progress,
                  s = a,
                  o = s.uuid,
                  u = s.id,
                  l = s.options,
                  c = s.config,
                  d = l.cacheAsset,
                  h = [];
              t.addRef && t.addRef(), fn(o, t, Object.create(null), h, c), i.canInvoke && e.dispatch("progress", ++i.finish, i.total += h.length, a);
              var f = e.options.__exclude__[o] = {
                content: t,
                finish: !1,
                callbacks: [{
                  done: n,
                  item: a
                }]
              },
                  p = It.create({
                input: h,
                options: e.options,
                onProgress: e.onProgress,
                onError: It.prototype.recycle,
                progress: i,
                onComplete: function onComplete(e) {
                  if (t.decRef && t.decRef(!1), f.finish = !0, f.err = e, !e) {
                    for (var n, a = Array.isArray(p.output) ? p.output : [p.output], i = Object.create(null), s = A(a); !(n = s()).done;) {
                      var l = n.value;
                      l && (i[l instanceof at ? l._uuid + "@import" : o + "@native"] = l);
                    }

                    !function (e, t, n) {
                      var a = st.get(t);

                      if (a) {
                        for (var i = 0, s = a.length; i < s; i++) {
                          var o = a[i],
                              u = n[o.uuid + "@import"];
                          if (u) o.owner[o.prop] = u.addRef();else {
                            if (r("The asset " + o.uuid + " is missing!"), o.type && o.type !== at) {
                              var l = new o.type();
                              l.initDefault(o.uuid), o.owner[o.prop] = l;
                            }

                            !0;
                          }
                        }

                        st.delete(t);
                      }

                      ot.has(t) && (n[e + "@native"] ? t._nativeAsset = n[e + "@native"] : (!0, console.error("the native asset of " + e + " is missing!")), ot.delete(t));
                    }(o, t, i);

                    try {
                      "function" != typeof t.onLoaded || Mt.has(t) || ot.has(t) || (t.onLoaded(), Mt.add(t));
                    } catch (e) {
                      r("The asset " + o + " is invalid for some reason, detail message: " + e.message + ", stack: " + e.stack);
                    }

                    dt.remove(u), Et.remove(u), pn(o, t, d), p.recycle();
                  }

                  for (var c = f.callbacks, h = 0, g = c.length; h < g; h++) {
                    var m = c[h];
                    t.addRef && t.addRef(), m.item.content = t, m.done(e);
                  }

                  c.length = 0;
                }
              });
              Dt.async(p);
            }(e, a, t);
          });
        }
      }]);

      function $n(e, t) {
        var n = e.options,
            r = Object.create(null),
            a = Object.create(null);

        for (var i in n) {
          switch (i) {
            case lt.PATH:
            case lt.UUID:
            case lt.DIR:
            case lt.SCENE:
            case lt.URL:
              break;

            case "__requestType__":
            case "__isNative__":
            case "ext":
            case "type":
            case "__nativeName__":
            case "audioLoadMode":
            case "bundle":
              r[i] = n[i];
              break;

            case "__exclude__":
            case "__outputAsArray__":
              a[i] = n[i];
              break;

            default:
              r[i] = n[i], a[i] = n[i];
          }
        }

        e.options = a;
        var s = It.create({
          input: e.input,
          options: r
        }),
            o = null;

        try {
          e.output = e.source = Bt.sync(s);
        } catch (e) {
          o = e;

          for (var u = 0, l = s.output.length; u < l; u++) {
            s.output[u].recycle();
          }
        }

        s.recycle(), t(o);
      }

      var er = function () {
        function e() {
          this.uuid = "", this.url = "", this.ext = ".json", this.content = null, this.file = null, this.info = null, this.config = null, this.isNative = !1, this.options = Object.create(null), this._id = "";
        }

        return e.create = function () {
          return 0 !== e._deadPool.length ? e._deadPool.pop() : new e();
        }, e.prototype.recycle = function () {
          e._deadPool.length !== e.MAX_DEAD_NUM && (this._id = "", this.uuid = "", this.url = "", this.ext = ".json", this.content = null, this.file = null, this.info = null, this.config = null, this.isNative = !1, this.options = Object.create(null), e._deadPool.push(this));
        }, _(e, [{
          key: "id",
          get: function get() {
            return this._id || (this._id = this.uuid + "@" + (this.isNative ? "native" : "import")), this._id;
          }
        }]), e;
      }();

      er.MAX_DEAD_NUM = 500, er._deadPool = [];
      var tr = [];

      function nr(e) {
        var t = e.options,
            n = Array.isArray(e.input) ? e.input : [e.input];
        e.output = [];

        for (var r = function r(_r) {
          var a,
              i = n[_r],
              s = er.create(),
              o = null,
              u = null;
          if ("string" == typeof i && ((i = Object.create(null))[t.__requestType__ || lt.UUID] = n[_r]), "object" == _typeof2(i)) for (var l in C(i, t), i.preset && C(i, Lt[i.preset]), i) {
            switch (l) {
              case lt.UUID:
                if ("break" === function () {
                  var e,
                      t = s.uuid = tt(i.uuid);

                  if (!i.bundle) {
                    var n = ut.find(function (e) {
                      return !!e.getAssetInfo(t);
                    });
                    i.bundle = n && n.name;
                  }

                  if (ut.has(i.bundle)) {
                    if (o = ut.get(i.bundle).config, (u = o.getAssetInfo(t)) && u.redirect) {
                      if (!ut.has(u.redirect)) throw new Error("Please load bundle " + u.redirect + " first");
                      o = ut.get(u.redirect).config, u = o.getAssetInfo(t);
                    }

                    s.config = o, s.info = u;
                  }

                  return s.ext = i.ext || (null === (e = u) || void 0 === e ? void 0 : e.extension) || ".json", "break";
                }()) break;

              case "__requestType__":
              case "ext":
              case "bundle":
              case "preset":
              case "type":
                break;

              case lt.DIR:
                if (ut.has(i.bundle)) {
                  ut.get(i.bundle).config.getDirWithPath(i.dir, i.type, tr);

                  for (var c, d = A(tr); !(c = d()).done;) {
                    var h = c.value;
                    n.push({
                      uuid: h.uuid,
                      __isNative__: !1,
                      ext: h.extension || ".json",
                      bundle: i.bundle
                    });
                  }

                  tr.length = 0;
                }

                s.recycle(), s = null;
                break;

              case lt.PATH:
                if (ut.has(i.bundle)) {
                  if (o = ut.get(i.bundle).config, (u = o.getInfoWithPath(i.path, i.type)) && u.redirect) {
                    if (!ut.has(u.redirect)) throw new Error("you need to load bundle " + u.redirect + " first");
                    o = ut.get(u.redirect).config, u = o.getAssetInfo(u.uuid);
                  }

                  if (!u) throw s.recycle(), new Error("Bundle " + i.bundle + " doesn't contain " + i.path);
                  s.config = o, s.uuid = u.uuid, s.info = u;
                }

                s.ext = i.ext || (null === (a = u) || void 0 === a ? void 0 : a.extension) || ".json";
                break;

              case lt.SCENE:
                if (!i.bundle) {
                  var f = ut.find(function (e) {
                    return !!e.getSceneInfo(i.scene);
                  });
                  i.bundle = f && f.name;
                }

                if (ut.has(i.bundle)) {
                  if (o = ut.get(i.bundle).config, (u = o.getSceneInfo(i.scene)) && u.redirect) {
                    if (!ut.has(u.redirect)) throw new Error("you need to load bundle " + u.redirect + " first");
                    o = ut.get(u.redirect).config, u = o.getAssetInfo(u.uuid);
                  }

                  if (!u) throw s.recycle(), new Error("Bundle " + o.name + " doesn't contain scene " + i.scene);
                  s.config = o, s.uuid = u.uuid, s.info = u;
                }

                break;

              case "__isNative__":
                s.isNative = i.__isNative__;
                break;

              case lt.URL:
                s.url = i.url, s.uuid = i.uuid || i.url, s.ext = i.ext || jt(i.url), s.isNative = void 0 === i.__isNative__ || i.__isNative__;
                break;

              default:
                s.options[l] = i[l];
            }

            if (!s) break;
          }
          if (!s) return "continue";
          if (e.output.push(s), !s.uuid && !s.url) throw new Error("Can not parse this input:" + JSON.stringify(i));
        }, a = 0; a < n.length; a++) {
          r(a);
        }

        return null;
      }

      function rr(e) {
        for (var t = e.output = e.input, n = 0; n < t.length; n++) {
          var r = t[n];

          if (!r.url) {
            var a,
                s,
                o = r.config;
            s = r.isNative ? o && o.nativeBase ? o.base + o.nativeBase : i.assetManager.generalNativeBase : o && o.importBase ? o.base + o.importBase : i.assetManager.generalImportBase;
            var u = r.uuid,
                l = "";
            r.info && (l = r.isNative ? r.info.nativeVer ? "." + r.info.nativeVer : "" : r.info.ver ? "." + r.info.ver : ""), a = ".ttf" === r.ext ? s + "/" + u.slice(0, 2) + "/" + u + l + "/" + r.options.__nativeName__ : s + "/" + u.slice(0, 2) + "/" + u + l + r.ext, r.url = a;
          }
        }

        return null;
      }

      var ar = e("A", function () {
        function e() {
          this.pipeline = Dt.append($n).append(Kn), this.fetchPipeline = Pt.append($n).append(Hn), this.transformPipeline = Bt.append(nr).append(rr), this.bundles = ut, this.assets = nt, this.generalImportBase = "", this.generalNativeBase = "", this.dependUtil = rt, this.force = M, this.allowImageBitmap = !ht.isMobile, this.utils = Ot, this.downloader = Ln, this.parser = Jn, this.packManager = zn, this.cacheAsset = !0, this.cacheManager = null, this.presets = Lt, this.factory = Gn, this.preprocessPipe = $n, this.fetchPipe = Hn, this.loadPipe = Kn, this.references = Ut, this._releaseManager = un, this._files = dt, this._parsed = Et, this._parsePipeline = null;
        }

        var t = e.prototype;
        return t.init = function (e) {
          void 0 === e && (e = {}), this._files.clear(), this._parsed.clear(), this._releaseManager.init(), this.assets.clear(), this.bundles.clear(), this.packManager.init(), this.downloader.init(e.server, e.bundleVers, e.remoteBundles), this.parser.init(), this.dependUtil.init();
          var t = e.importBase || "";
          t && t.endsWith("/") && (t = t.substr(0, t.length - 1));
          var n = e.nativeBase || "";
          n && n.endsWith("/") && (n = n.substr(0, n.length - 1)), this.generalImportBase = t, this.generalNativeBase = n;
        }, t.getBundle = function (e) {
          return ut.get(e) || null;
        }, t.removeBundle = function (e) {
          e._destroy(), ut.remove(e.name);
        }, t.loadAny = function (e, t, n, r) {
          var a = mn(t, n, r),
              i = a.options,
              s = a.onProgress,
              o = a.onComplete;
          i.preset = i.preset || "default", e = Array.isArray(e) ? e.slice() : e;
          var u = It.create({
            input: e,
            onProgress: s,
            onComplete: yn(o),
            options: i
          });
          Dt.async(u);
        }, t.preloadAny = function (e, t, n, r) {
          var a = mn(t, n, r),
              i = a.options,
              s = a.onProgress,
              o = a.onComplete;
          i.preset = i.preset || "preload", e = Array.isArray(e) ? e.slice() : e;
          var u = It.create({
            input: e,
            onProgress: s,
            onComplete: yn(o),
            options: i
          });
          Pt.async(u);
        }, t.loadRemote = function (e, t, n) {
          var a = mn(t, void 0, n),
              i = a.options,
              s = a.onComplete;
          i.reloadAsset || !this.assets.has(e) ? (i.__isNative__ = !0, i.preset = i.preset || "remote", this.loadAny({
            url: e
          }, i, null, function (t, n) {
            t ? (r(t.message, t.stack), s && s(t, n)) : Gn.create(e, n, i.ext || jt(e), i, function (e, t) {
              s && s(e, t);
            });
          })) : yn(s)(null, this.assets.get(e));
        }, t.loadBundle = function (e, t, n) {
          var a = mn(t, void 0, n),
              i = a.options,
              s = a.onComplete,
              o = mt(e);
          this.bundles.has(o) ? yn(s)(null, this.getBundle(o)) : (i.preset = i.preset || "bundle", i.ext = "bundle", i.__isNative__ = !0, this.loadAny({
            url: e
          }, i, null, function (t, n) {
            t ? (r(t.message, t.stack), s && s(t, n)) : Gn.create(e, n, "bundle", i, function (e, t) {
              s && s(e, t);
            });
          }));
        }, t.releaseAsset = function (e) {
          un.tryRelease(e, !0);
        }, t.releaseUnusedAssets = function () {
          nt.forEach(function (e) {
            un.tryRelease(e);
          });
        }, t.releaseAll = function () {
          nt.forEach(function (e) {
            un.tryRelease(e, !0);
          });
        }, t.loadWithJson = function () {
          throw new Error("Only valid in Editor");
        }, _(e, [{
          key: "main",
          get: function get() {
            return ut.get(At.MAIN) || null;
          }
        }, {
          key: "resources",
          get: function get() {
            return ut.get(At.RESOURCES) || null;
          }
        }]), e;
      }());
      ar.Pipeline = Ct, ar.Task = It, ar.Cache = $e, ar.RequestItem = er, ar.Bundle = wn, ar.BuiltinBundleName = At;
      var ir = e("a", i.assetManager = new ar());
      i.AssetManager = ar;
      var sr = [".png", ".jpg", ".bmp", ".jpeg", ".gif", ".ico", ".tiff", ".webp", ".image", ".pvr", ".pkm", ".astc"],
          or = [".mp3", ".ogg", ".wav", ".m4a"];

      function ur() {
        return !0;
      }

      var lr = {
        transformURL: function transformURL(e) {
          var t = qt(e);
          if (!t) return e;
          var n = ut.find(function (e) {
            return !!e.getAssetInfo(t);
          });
          if (!n) return e;
          var r,
              a = n.getAssetInfo(t);
          if (!(r = e.startsWith(n.base + n.config.nativeBase) ? a.nativeVer || "" : a.ver || "") || -1 !== e.indexOf(r)) return e;
          var i = !1;

          if (".ttf" === jt(e) && (i = !0), i) {
            var s = Wt(e),
                o = mt(e);
            e = s + "." + r + "/" + o;
          } else e = e.replace(/.*[/\\][0-9a-fA-F]{2}[/\\]([0-9a-fA-F-@]{8,})/, function (e) {
            return e + "." + r;
          });

          return e;
        }
      },
          cr = e("C", function () {
        function e() {
          this._autoReleaseSetting = Object.create(null), this._parseLoadResArgs = vn;
        }

        var t = e.prototype;
        return t.load = function (e, t, n) {
          void 0 === n && void 0 !== t && (n = t, t = null);

          for (var r = Array.isArray(e) ? e : [e], a = 0; a < r.length; a++) {
            var i = r[a];
            "string" == typeof i ? r[a] = {
              url: i,
              __isNative__: !0
            } : (i.type && (i.ext = "." + i.type, i.type = void 0), i.url && (i.__isNative__ = !0));
          }

          var s = [],
              o = [];
          ir.loadAny(r, null, function (e, n, r) {
            r.content && (sr.includes(r.ext) ? s.push(r.content) : or.includes(r.ext) && o.push(r.content)), t && t(e, n, r);
          }, function (e, t) {
            var a = null;

            if (!e) {
              t = Array.isArray(t) ? t : [t];

              for (var i = function i(e) {
                var n = t[e];

                if (!(n instanceof at)) {
                  var a = n,
                      i = r[e].url;
                  s.includes(a) ? Gn.create(i, n, ".png", {}, function (n, r) {
                    a = t[e] = r;
                  }) : o.includes(a) && Gn.create(i, n, ".mp3", {}, function (n, r) {
                    a = t[e] = r;
                  }), nt.add(i, a);
                }
              }, u = 0; u < t.length; u++) {
                i(u);
              }

              if (t.length > 1) {
                var l = Object.create(null);
                t.forEach(function (e) {
                  l[e._uuid] = e;
                }), a = {
                  isCompleted: ur,
                  _map: l
                };
              } else a = t[0];
            }

            n && n(e, a);
          });
        }, t.getXMLHttpRequest = function () {
          return new XMLHttpRequest();
        }, t.getItem = function (e) {
          return ir.assets.has(e) ? {
            content: ir.assets.get(e)
          } : null;
        }, t.loadRes = function (e, t, n, r) {
          var a = this._parseLoadResArgs(t, n, r),
              i = a.type,
              s = a.onProgress,
              o = a.onComplete,
              u = jt(e);

          u && !bn.getInfoWithPath(e, i) && (e = e.slice(0, -u.length)), bn.load(e, i, s, o);
        }, t.loadResArray = function (e, t, n, r) {
          var a = this._parseLoadResArgs(t, n, r),
              i = a.type,
              s = a.onProgress,
              o = a.onComplete;

          e.forEach(function (t, n) {
            var r = jt(t);
            r && !bn.getInfoWithPath(t, i) && (e[n] = t.slice(0, -r.length));
          }), bn.load(e, i, s, o);
        }, t.loadResDir = function (e, t, n, r) {
          var a = this._parseLoadResArgs(t, n, r),
              i = a.type,
              s = a.onProgress,
              o = a.onComplete;

          bn.loadDir(e, i, s, function (t, n) {
            var r = [];
            t || (r = bn.getDirWithPath(e, i).map(function (e) {
              return e.path;
            })), o && o(t, n, r);
          });
        }, t.getRes = function (e, t) {
          return nt.has(e) ? nt.get(e) : bn.get(e, t);
        }, t.getResCount = function () {
          return nt.count;
        }, t.getDependsRecursively = function (e) {
          if (!e) return [];
          var t = "string" == typeof e ? e : e._uuid;
          return rt.getDepsRecursively(t).concat([t]);
        }, t.addDownloadHandlers = function (e) {
          var t = Object.create(null),
              n = function n(_n3) {
            var r = e[_n3];

            t["." + _n3] = function (e, t, n) {
              r({
                url: e
              }, n);
            };
          };

          for (var r in e) {
            n(r);
          }

          Ln.register(t);
        }, t.addLoadHandlers = function (e) {
          var t = Object.create(null),
              n = function n(_n4) {
            var r = e[_n4];

            t["." + _n4] = function (e, t, n) {
              r({
                content: e
              }, n);
            };
          };

          for (var r in e) {
            n(r);
          }

          Jn.register(t);
        }, t.release = function (e) {
          if (Array.isArray(e)) for (var t = 0; t < e.length; t++) {
            var n = e[t];
            "string" == typeof n && (n = nt.get(n)), ir.releaseAsset(n);
          } else e && ("string" == typeof e && (e = nt.get(e)), ir.releaseAsset(e));
        }, t.releaseAsset = function (e) {
          ir.releaseAsset(e);
        }, t.releaseRes = function (e, t) {
          bn.release(e, t);
        }, t.releaseAll = function () {
          ir.releaseAll(), nt.clear();
        }, t.removeItem = function (e) {
          return !!nt.remove(e);
        }, t.setAutoRelease = function (e, t) {
          "object" == _typeof2(e) && (e = e._uuid), this._autoReleaseSetting[e] = !!t;
        }, t.setAutoReleaseRecursively = function (e, t) {
          "object" == _typeof2(e) && (e = e._uuid), t = !!t, this._autoReleaseSetting[e] = t;

          for (var n = rt.getDepsRecursively(e), r = 0; r < n.length; r++) {
            this._autoReleaseSetting[n[r]] = t;
          }
        }, t.isAutoRelease = function (e) {
          return "object" == _typeof2(e) && (e = e._uuid), !!this._autoReleaseSetting[e];
        }, _(e, [{
          key: "onProgress",
          set: function set(e) {
            ln = e;
          }
        }, {
          key: "_cache",
          get: function get() {
            if (nt instanceof $e) return nt._map;
            var e = {};
            return nt.forEach(function (t, n) {
              e[n] = t;
            }), e;
          }
        }, {
          key: "md5Pipe",
          get: function get() {
            return lr;
          }
        }, {
          key: "downloader",
          get: function get() {
            return Ln;
          }
        }, {
          key: "loader",
          get: function get() {
            return ir.parser;
          }
        }]), e;
      }()),
          dr = e("l", new cr()),
          hr = e("b", {
        init: function init(e) {
          e.importBase = e.libraryPath, e.nativeBase = e.rawAssetsBase, ir.init(e), e.rawAssets && bn.init({
            base: "",
            deps: [],
            scenes: {},
            redirect: [],
            debug: !0,
            packs: {},
            types: [],
            versions: {
              import: [],
              native: []
            },
            name: At.RESOURCES,
            importBase: e.importBase,
            nativeBase: e.nativeBase,
            paths: e.rawAssets.assets,
            uuids: Object.keys(e.rawAssets.assets),
            extensionMap: {}
          });
        },
        loadAsset: function loadAsset(e, t) {
          ir.loadAny(e, t);
        }
      }),
          fr = e("u", {});
      Je(fr, "url", [{
        name: "normalize",
        target: ir.utils,
        targetName: "assetManager.utils",
        newName: "normalize"
      }, {
        name: "raw",
        targetName: "Asset.prototype",
        newName: "nativeUrl",
        customFunction: function customFunction(e) {
          return e.startsWith("resources/") ? Nt({
            path: Ft(e.substr(10)),
            bundle: At.RESOURCES,
            __isNative__: !0,
            ext: jt(e)
          }) : "";
        }
      }]), Ke(hr, "AssetLibrary", [{
        name: "getLibUrlNoExt",
        suggest: "AssetLibrary.getLibUrlNoExt was removed, if you want to transform url, please use assetManager.utils.getUrlWithUuid instead"
      }, {
        name: "queryAssetInfo",
        suggest: "AssetLibrary.queryAssetInfo was removed"
      }]), Ke(dr, "loader", [{
        name: "releaseResDir",
        suggest: "loader.releaseResDir was removed, please use assetManager.releaseAsset instead"
      }, {
        name: "flowInDeps",
        suggest: "loader.flowInDeps was removed"
      }, {
        name: "assetLoader",
        suggest: "loader.assetLoader was removed, assetLoader and md5Pipe were merged into assetManager.transformPipeline"
      }]), Je(i, "cc", [{
        name: "loader",
        newName: "assetManager",
        logTimes: 1,
        customGetter: function customGetter() {
          return dr;
        }
      }, {
        name: "AssetLibrary",
        newName: "assetManager",
        logTimes: 1,
        customGetter: function customGetter() {
          return hr;
        }
      }, {
        name: "Pipeline",
        target: ar,
        targetName: "AssetManager",
        newName: "Pipeline",
        logTimes: 1
      }, {
        name: "url",
        targetName: "assetManager",
        newName: "utils",
        logTimes: 1,
        customGetter: function customGetter() {
          return fr;
        }
      }]), Ke(i, "cc", [{
        name: "LoadingItems",
        suggest: I(1400, "LoadingItems", "AssetManager.Task")
      }]), Je(D, "macro", [{
        name: "DOWNLOAD_MAX_CONCURRENT",
        target: Ln,
        targetName: "assetManager.downloader",
        newName: "maxConcurrency"
      }]), Je(Yt, "director", [{
        name: "_getSceneUuid",
        targetName: "assetManager.main",
        newName: "getSceneInfo",
        customFunction: function customFunction(e) {
          var t;
          return ir.main ? null === (t = ir.main.getSceneInfo(e)) || void 0 === t ? void 0 : t.uuid : "";
        }
      }]), Je(Gt, "game", [{
        name: "_sceneInfos",
        targetName: "assetManager.main",
        newName: "getSceneInfo",
        customGetter: function customGetter() {
          var e = [];
          return ir.main && ir.main.config.scenes.forEach(function (t) {
            e.push(t);
          }), e;
        }
      }]);
      var pr = un._autoRelease;
      un._autoRelease = function (e, t, n) {
        pr.call(un, e, t, n);

        for (var r = dr._autoReleaseSetting, a = Object.keys(r), i = 0; i < a.length; i++) {
          var s = a[i];

          if (!0 === r[s]) {
            var o = nt.get(s);
            o && un.tryRelease(o);
          }
        }
      }, i.math = Jt, i.geometry = Kt;
    }
  };
}); 
 			}); 
		define("__plugin__/wx0446ba2621dda60a/intersection-2d-65003b3c.js", function(require, module, exports){ 			
"use strict";

System.register(["./json-asset-933a1d4c.js", "./index-f2b92470.js"], function (n) {
  "use strict";

  var r;
  return {
    setters: [function (n) {
      r = n.V;
    }, function () {}],
    execute: function execute() {
      function t(n, r, t, e) {
        var i = (e.x - t.x) * (n.y - t.y) - (e.y - t.y) * (n.x - t.x),
            x = (r.x - n.x) * (n.y - t.y) - (r.y - n.y) * (n.x - t.x),
            y = (e.y - t.y) * (r.x - n.x) - (e.x - t.x) * (r.y - n.y);

        if (0 !== y) {
          var u = i / y,
              o = x / y;
          if (u >= 0 && u <= 1 && o >= 0 && o <= 1) return !0;
        }

        return !1;
      }

      var e = new r(),
          i = new r(),
          x = new r(),
          y = new r();

      function u(n, r, e) {
        for (var i = e.length, x = 0; x < i; ++x) {
          if (t(n, r, e[x], e[(x + 1) % i])) return !0;
        }

        return !1;
      }

      function o(n, r) {
        for (var t = !1, e = n.x, i = n.y, x = r.length, y = 0, u = x - 1; y < x; u = y++) {
          var o = r[y].x,
              f = r[y].y,
              a = r[u].x,
              c = r[u].y;
          f > i != c > i && e < (a - o) * (i - f) / (c - f) + o && (t = !t);
        }

        return t;
      }

      function f(n, r, t, i) {
        var x,
            y = t.x - r.x,
            u = t.y - r.y,
            o = y * y + u * u,
            f = ((n.x - r.x) * y + (n.y - r.y) * u) / o;
        return x = i ? o ? f < 0 ? r : f > 1 ? t : e.set(r.x + f * y, r.y + f * u) : r : e.set(r.x + f * y, r.y + f * u), y = n.x - x.x, u = n.y - x.y, Math.sqrt(y * y + u * u);
      }

      var a = n("I", function () {});
      a.lineLine = t, a.lineRect = function (n, r, u) {
        var o = e.set(u.x, u.y),
            f = i.set(u.x, u.yMax),
            a = x.set(u.xMax, u.yMax),
            c = y.set(u.xMax, u.y);
        return !!(t(n, r, o, f) || t(n, r, f, a) || t(n, r, a, c) || t(n, r, c, o));
      }, a.linePolygon = u, a.rectRect = function (n, r) {
        var t = n.x,
            e = n.y,
            i = n.x + n.width,
            x = n.y + n.height,
            y = r.x,
            u = r.y,
            o = r.x + r.width,
            f = r.y + r.height;
        return t <= o && i >= y && e <= f && x >= u;
      }, a.rectPolygon = function (n, r) {
        var t = e.set(n.x, n.y),
            f = i.set(n.x, n.yMax),
            a = x.set(n.xMax, n.yMax),
            c = y.set(n.xMax, n.y);
        if (u(t, f, r)) return !0;
        if (u(f, a, r)) return !0;
        if (u(a, c, r)) return !0;
        if (u(c, t, r)) return !0;

        for (var s = 0, l = r.length; s < l; ++s) {
          if (n.contains(r[s])) return !0;
        }

        return !!(o(t, r) || o(f, r) || o(a, r) || o(c, r));
      }, a.rectCircle = function (n, r, t) {
        var e = r.x,
            i = r.y,
            x = n.x,
            y = n.y,
            u = n.width,
            o = n.height,
            f = e,
            a = i;
        e < x ? f = x : e > x + u && (f = x + u), i < y ? a = y : i > y + o && (a = y + o);
        var c = e - f,
            s = i - a;
        return Math.sqrt(c * c + s * s) <= t;
      }, a.polygonPolygon = function (n, r) {
        var t, e;

        for (t = 0, e = n.length; t < e; ++t) {
          if (u(n[t], n[(t + 1) % e], r)) return !0;
        }

        for (t = 0, e = r.length; t < e; ++t) {
          if (o(r[t], n)) return !0;
        }

        for (t = 0, e = n.length; t < e; ++t) {
          if (o(n[t], r)) return !0;
        }

        return !1;
      }, a.circleCircle = function (n, t, e, i) {
        return r.distance(n, e) < t + i;
      }, a.polygonCircle = function (n, r, t) {
        var e = r;
        if (o(e, n)) return !0;

        for (var i = 0, x = n.length; i < x; i++) {
          if (f(e, 0 === i ? n[n.length - 1] : n[i - 1], n[i], !0) < t) return !0;
        }

        return !1;
      }, a.pointInPolygon = o, a.pointLineDistance = f;
    }
  };
}); 
 			}); 
		define("__plugin__/wx0446ba2621dda60a/intersection-2d.js", function(require, module, exports){ 			
"use strict";

System.register(["./texture-barrier-60b5983b.js", "./json-asset-933a1d4c.js", "./index-f2b92470.js", "./renderable-component-7c6600ed.js", "./deprecated-26630860.js", "./deprecated-ef6bb945.js", "./intersection-2d-65003b3c.js"], function (e) {
  "use strict";

  return {
    setters: [function () {}, function () {}, function () {}, function () {}, function () {}, function () {}, function (n) {
      e("Intersection2D", n.I);
    }],
    execute: function execute() {}
  };
}); 
 			}); 
		define("__plugin__/wx0446ba2621dda60a/json-asset-933a1d4c.js", function(require, module, exports){ 			
System.register(["./texture-barrier-60b5983b.js"],(function(e){"use strict";var t,n,i,o,a,r,c,s,l,f,_,u,m,d,p,h,v,g,x,y,C,S,E,P,I,T,b,A,w,N,D,R,M,O,L,z,F,U,G,B,H,V,k,j,q,W,Y,X,K,J,Q,Z,$,ee,te,ne,ie,oe,ae,re,ce,se,le,fe,_e,ue,me,de,pe,he,ve,ge,xe,ye,Ce,Se,Ee,Pe,Ie,Te,be,Ae,we,Ne,De,Re,Me,Oe,Le,ze,Fe,Ue,Ge,Be,He,Ve,ke,je,qe,We,Ye,Xe,Ke,Je,Qe,Ze,$e,et,tt,nt,it,ot,at,rt,ct,st,lt,ft,_t,ut,mt,dt,pt,ht,vt,gt,xt,yt,Ct,St,Et,Pt,It,Tt,bt,At,wt,Nt,Dt,Rt,Mt,Ot,Lt,zt,Ft,Ut,Gt,Bt,Ht,Vt;return{setters:[function(e){t=e.bR,n=e.bS,i=e.w,o=e.e,a=e.bT,r=e.bU,c=e.bB,s=e.l,l=e.bx,f=e.bV,_=e.b9,u=e.ba,m=e.B,d=e.bp,p=e.bn,h=e.bo,v=e.bc,g=e.bm,x=e.bb,y=e.D,C=e.bd,S=e.be,E=e.bk,P=e.j,I=e.bl,T=e.bq,b=e.br,A=e.bf,w=e.bi,N=e.bh,D=e.bg,R=e.bj,M=e.F,O=e.aF,L=e.aG,z=e.W,F=e.bw,U=e.bW,G=e.bX,B=e.bY,H=e.bZ,V=e.bF,k=e.bG,j=e.bH,q=e.bE,W=e.d,Y=e.b_,X=e.i,K=e.bC,J=e.b$,Q=e.bL,Z=e.bO,$=e.bK,ee=e.c0,te=e.c1,ne=e.g,ie=e.c2,oe=e.c3,ae=e.c4,re=e.c5,ce=e.c6,se=e.c7,le=e.c8,fe=e.bJ,_e=e.c9,ue=e.ca,me=e.cb,de=e.cc,pe=e.cd,he=e.a,ve=e.ce,ge=e.cf,xe=e.cg,ye=e.ch,Ce=e.ci,Se=e.cj,Ee=e.ck,Pe=e.cl,Ie=e.cm,Te=e.f,be=e.cn,Ae=e.co,we=e.bI,Ne=e.bv,De=e.bu,Re=e.cp,Me=e.cq,Oe=e.ai,Le=e.aN,ze=e.a1,Fe=e.J,Ue=e.au,Ge=e.at,Be=e.T,He=e.av,Ve=e.ay,ke=e.m,je=e.u,qe=e.y,We=e.x,Ye=e.as,Xe=e.bA,Ke=e.bQ,Je=e.cr,Qe=e.t,Ze=e.s,$e=e.af,et=e.A,tt=e.aq,nt=e.r,it=e.ar,ot=e.aO,at=e.aD,rt=e.b7,ct=e.aw,st=e.ax,lt=e.az,ft=e.aA,_t=e.aC,ut=e.aB,mt=e.aQ,dt=e.b0,pt=e.b1,ht=e.al,vt=e.o,gt=e.q,xt=e.aE,yt=e.am,Ct=e.aP,St=e.$,Et=e.aR,Pt=e.ag,It=e.a9,Tt=e.aJ,bt=e.aK,At=e.N,wt=e.cs,Nt=e.ct,Dt=e.cu,Rt=e.cv,Mt=e.cw,Ot=e.cx,Lt=e.n,zt=e.a$,Ft=e.a_,Ut=e.cy,Gt=e.cz,Bt=e.cA,Ht=e.cB,Vt=e.bD}],execute:function(){e({$:Yn,B:void 0,D:void 0,G:void 0,I:void 0,K:void 0,O:Qn,R:Rn,U:$n,X:Vn,_:$t,a:Zt,a2:ni,a4:oi,a6:An,a8:function(e,t){return Math.abs(e-t)<=dn*Math.max(1,Math.abs(e),Math.abs(t))},a9:pn,aA:Ov,aB:Lv,aE:ls,aG:function(e){return e[Wa]},aH:Is,aa:hn,ab:function(e){return e<0?0:e>1?1:e},ac:vn,ad:function(e){return e*un},ae:gn,ag:yn,ah:function(e,t){return Math.floor(yn(e,t))},ai:Cn,aj:Sn,ak:function(e,t,n){return Math.floor(Sn(e,t,n))},al:function(e){return--e,e|=e>>1,e|=e>>2,e|=e>>4,e|=e>>8,e|=e>>16,++e},am:En,an:Pn,ao:function(e,t,n){return(n-e)/(t-e)},ap:In,aq:function(e,t){return Math.abs(e)>Math.abs(t)?e:t},ar:function(e,t){t.forEach((function(t){Object.defineProperty(e,t,{enumerable:!0})}))},aw:function(e){e>0&&(ln=e)},ax:void 0,ay:void 0,az:void 0,b:Kt,b9:OC,bD:void 0,bO:void 0,bQ:void 0,bV:nu,bZ:xr,b_:function(e){for(var t=e.length-1;t>=0;--t){var n=e[t];if(n.window.swapchain)return void(cd=n)}cd=null},bq:void 0,br:void 0,bs:void 0,bu:void 0,bw:void 0,c:Qt,c1:function(e,t,n,i,o){if(i&&i.enabled&&o===cd){var a=i.subModels[0],r=a.inputAssembler,c=a.passes,s=a.shaders,l=a.descriptorSet;Xm.width=Km.width=o.window.width,Xm.height=Km.height=o.window.height;var f=Ym.getOrCreatePipelineState(e,c[0],s[0],t,r);n.setViewport(Xm),n.setScissor(Km),n.bindPipelineState(f),n.bindDescriptorSet(Qf.MATERIAL,c[0].descriptorSet),n.bindDescriptorSet(Qf.LOCAL,l),n.bindInputAssembler(r),n.draw(r)}},c4:Jm,cD:Gs,cF:Hr,cG:zr,cJ:Br,cN:void 0,cP:Oc,cQ:Lc,cS:void 0,cT:function(e,t,n){if(e[qc]<1)throw new Error(Z(5304,e[qc]));cs(e,!0,t,null!=n?n:ls.reportMissingClass),ss(e);for(var i=new fs(e[qc]),o=e[Wc],a=e[Yc],r=e[Xc],c=e[Kc],s=e[Jc],l=0;l<s.length;++l)s[l].unshift(i,o,a,r,c);return s},cU:function(e,t,n){return[1,0,0,[e],0,n?[t,-1]:[t],[0],0,[],[],[]]},cV:Vr,cY:wu,c_:void 0,ce:void 0,ct:void 0,d:Jt,d$:function(){var e=new zl;return e.assignSorted([[0,{interpolationMode:Ta.CUBIC,value:1}],[1,{interpolationMode:Ta.CUBIC,value:1}]]),e},d6:Ur,d8:void 0,dE:ef,dF:xf,dH:Ia,dI:function(e){return"function"==typeof e.lerp},dJ:void 0,dK:void 0,dL:void 0,dR:void 0,dT:void 0,dU:void 0,dV:void 0,dW:void 0,dX:void 0,df:function(e,t,n,i,o,a){void 0===t&&(t=ke.R32F),void 0===n&&(n=0),void 0===i&&(i=e.byteLength-n),void 0===o&&(o=0),void 0===a&&(a=[]);var r=zt[t];o||(o=r.size);for(var c="get"+qv(r),s=r.size/r.count,l=Math.floor(i/o),f=Nc.isLittleEndian,_=0;_<l;++_)for(var u=n+o*_,m=0;m<r.count;++m){var d=u+s*m;a[r.count*_+m]=e[c](d,f)}return a},dg:function(e,t,n,i,o){void 0===n&&(n=ke.R32F),void 0===i&&(i=0),void 0===o&&(o=0);var a=zt[n];o||(o=a.size);for(var r="set"+qv(a),c=a.size/a.count,s=Math.floor(t.length/a.count),l=Nc.isLittleEndian,f=0;f<s;++f)for(var _=i+o*f,u=0;u<a.count;++u){var m=_+c*u;e[r](m,t[a.count*f+u],l)}},dh:Wv,dk:ka,dl:Xa,dy:void 0,e:Yt,g:tn,j:Wt,m:Xt,s:en,v:mm,w:dm,y:Sm});var kt=/(\.[^\.\/\?\\]*)(\?.*)?$/,jt=/((.*)(\/|\\|\\\\))?(.*?\..*$)?/,qt=/[^\.\/]+\/\.\.\//;function Wt(){for(var e="",t=arguments.length,n=new Array(t),i=0;i<t;i++)n[i]=arguments[i];for(var o=0,a=n;o<a.length;o++){var r=a[o];e=(e+(""===e?"":"/")+r).replace(/(\/|\\\\)$/,"")}return e}function Yt(e){var t=kt.exec(e);return t?t[1]:""}function Xt(e){if(e){var t=e.lastIndexOf(".");if(-1!==t)return e.substring(0,t)}return e}function Kt(e,t){var n=e.indexOf("?");n>0&&(e=e.substring(0,n));var i=/(\/|\\)([^\/\\]+)$/g.exec(e.replace(/(\/|\\)$/,""));if(!i)return e;var o=i[2];return t&&e.substring(e.length-t.length).toLowerCase()===t.toLowerCase()?o.substring(0,o.length-t.length):o}function Jt(e){var t=jt.exec(e);return t?t[2]:""}function Qt(e,t){t=t||"";var n=e.indexOf("?"),i="";return n>0&&(i=e.substring(n),e=e.substring(0,n)),(n=e.lastIndexOf("."))<0?e+t+i:e.substring(0,n)+t+i}function Zt(e,t,n){if(0===t.indexOf("."))return Qt(e,t);var i=e.indexOf("?"),o="",a=n?Yt(e):"";return i>0&&(o=e.substring(i),e=e.substring(0,i)),i=(i=e.lastIndexOf("/"))<=0?0:i+1,e.substring(0,i)+t+a+o}function $t(e){var t=e=String(e);do{t=e,e=e.replace(qt,"")}while(t.length!==e.length);return e}function en(e){return e.replace(/[\/\\]$/,"")}function tn(){return t.os===n.WINDOWS?"\\":"/"}e("au",Object.freeze({__proto__:null,join:Wt,extname:Yt,mainFileName:Xt,basename:Kt,dirname:Jt,changeExtname:Qt,changeBasename:Zt,_normalize:$t,stripSep:en,getSeperator:tn}));var nn,on,an,rn,cn,sn,ln=10,fn=0,_n=new Map;rn=function(e,t,n,i,o,a,r){var c=_n.get(a);c&&c.logTimes>c.count&&(o("'%s' is deprecated, please use '%s' instead. "+r,e+"."+t,n+"."+i),c.count++)},nn=e("ax",(function(e,t,n){null!=e&&n.forEach((function(n){var o=fn++;_n.set(o,{id:o,count:0,logTimes:void 0!==n.logTimes?n.logTimes:ln});var a=null!=n.target?n.target:e,r=null!=n.newName?n.newName:n.name,c=null!=n.targetName?n.targetName:t,s=a===e,l=n.suggest?"("+n.suggest+")":"";if(null!=n.customFunction)e[n.name]=function(){var e;return rn(t,n.name,c,r,i,o,l),(e=n.customFunction).call.apply(e,[this].concat(Array.prototype.slice.call(arguments)))};else if(null!=n.customSetter||null!=n.customGetter){var f=null!=n.customSetter,_=null!=n.customGetter;f&&_?Object.defineProperty(e,n.name,{get:function(){return rn(t,n.name,c,r,i,o,l),n.customGetter.call(this)},set:function(e){rn(t,n.name,c,r,i,o,l),n.customSetter.call(this,e)},enumerable:!1}):f?Object.defineProperty(e,n.name,{set:function(e){rn(t,n.name,c,r,i,o,l),n.customSetter.call(this,e)},enumerable:!1}):_&&Object.defineProperty(e,n.name,{get:function(){return rn(t,n.name,c,r,i,o,l),n.customGetter.call(this)},enumerable:!1})}else Object.defineProperty(e,n.name,{get:function(){return rn(t,n.name,c,r,i,o,l),s?this[r]:a[r]},set:function(e){rn(t,n.name,c,r,i,o,l),s?this[r]=e:a[r]=e},enumerable:!1})}))})),sn=function(e,t,n,i,o){var a=_n.get(i);a&&a.logTimes>a.count&&(n("'%s' has been removed. "+o,e+"."+t),a.count++)},on=e("ay",(function(e,t,n){null!=e&&n.forEach((function(n){var i=fn++;_n.set(i,{id:i,count:0,logTimes:void 0!==n.logTimes?n.logTimes:ln});var a=n.suggest?"("+n.suggest+")":"";Object.defineProperty(e,n.name,{get:function(){return sn(t,n.name,o,i,a)},set:function(){sn(t,n.name,o,i,a)},enumerable:!1})}))})),cn=function(e,t,n,i,o){var a=_n.get(i);a&&a.logTimes>a.count&&(n("'%s' is deprecated. "+o,e+"."+t),a.count++)},an=e("az",(function(e,t,n){null!=e&&n.forEach((function(n){var o=n.name,a=Object.getOwnPropertyDescriptor(e,o);if(a&&a.configurable){var r=fn++;_n.set(r,{id:r,count:0,logTimes:void 0!==n.logTimes?n.logTimes:ln});var c=n.suggest?"("+n.suggest+")":"";if(void 0!==a.value)if("function"==typeof a.value){var s=a.value;e[o]=function(){return cn(t,o,i,r,c),s.call.apply(s,[this].concat(Array.prototype.slice.call(arguments)))}}else{var l=a.value;Object.defineProperty(e,o,{configurable:!0,get:function(){return cn(t,o,i,r,c),l}}),a.writable&&Object.defineProperty(e,o,{set:function(e){cn(t,o,i,r,c),l=e}})}else!function(t,n,i,o,a,r){if(t.get){var c=t.get;t.get=function(){return cn(n,i,o,a,r),c.call(this)}}if(t.set){var s=t.set;t.set=function(e){cn(n,i,o,a,r),s.call(this,e)}}Object.defineProperty(e,i,t)}(a,t,o,i,r,c);Object.defineProperty(e,o,{enumerable:!1})}}))}));var un=Math.PI/180,mn=180/Math.PI,dn=e("a7",1e-6);function pn(e,t,n){return n=n||dn,Math.abs(e-t)<=n}function hn(e,t,n){if(t>n){var i=t;t=n,n=i}return e<t?t:e>n?n:e}function vn(e,t,n){return e+(t-e)*n}function gn(e){return e*mn}var xn=e("af",Math.random);function yn(e,t){return Math.random()*(t-e)+e}function Cn(e){return(e=(9301*e+49297)%233280)/233280}function Sn(e,t,n){return Cn(e)*(n-t)+t}function En(e,t){return e-Math.floor(e/t)*t}function Pn(e,t){return e=En(e,2*t),t-Math.abs(e-t)}function In(e){return Math.abs(e.x)>Math.abs(e.y)?Math.abs(e.x)>Math.abs(e.z)?e.x:e.z:Math.abs(e.y)>Math.abs(e.z)?e.y:e.z}var Tn=1/255,bn=e("a5",function(e){function t(t,n,i,o){var a;return(a=e.call(this)||this)._val=0,"string"==typeof t?a.fromHEX(t):void 0!==n?a.set(t,n,i,o):a.set(t),a}a(t,e),t.clone=function(e){var n=new t;return e._val?n._val=e._val:n._val=(e.a<<24>>>0)+(e.b<<16)+(e.g<<8)+e.r,n},t.copy=function(e,t){return e.r=t.r,e.g=t.g,e.b=t.b,e.a=t.a,e},t.set=function(e,t,n,i,o){return e.r=t,e.g=n,e.b=i,e.a=o,e},t.fromHEX=function(e,t){t=0===t.indexOf("#")?t.substring(1):t,e.r=parseInt(t.substr(0,2),16)||0,e.g=parseInt(t.substr(2,2),16)||0,e.b=parseInt(t.substr(4,2),16)||0;var n=parseInt(t.substr(6,2),16);return e.a=Number.isNaN(n)?255:n,e._val=(e.a<<24>>>0)+(e.b<<16)+(e.g<<8)+e.r,e},t.add=function(e,t,n){return e.r=t.r+n.r,e.g=t.g+n.g,e.b=t.b+n.b,e.a=t.a+n.a,e},t.subtract=function(e,t,n){return e.r=t.r-n.r,e.g=t.g-n.g,e.b=t.b-n.b,e.a=t.a-n.a,e},t.multiply=function(e,t,n){return e.r=t.r*n.r,e.g=t.g*n.g,e.b=t.b*n.b,e.a=t.a*n.a,e},t.divide=function(e,t,n){return e.r=t.r/n.r,e.g=t.g/n.g,e.b=t.b/n.b,e.a=t.a/n.a,e},t.scale=function(e,t,n){return e.r=t.r*n,e.g=t.g*n,e.b=t.b*n,e.a=t.a*n,e},t.lerp=function(e,t,n,i){var o=t.r,a=t.g,r=t.b,c=t.a;return o+=(n.r-o)*i,a+=(n.g-a)*i,r+=(n.b-r)*i,c+=(n.a-c)*i,e._val=Math.floor((c<<24>>>0)+(r<<16)+(a<<8)+o),e},t.toArray=function(e,n,i){void 0===i&&(i=0);var o=n instanceof t||n.a>1?1/255:1;return e[i+0]=n.r*o,e[i+1]=n.g*o,e[i+2]=n.b*o,e[i+3]=n.a*o,e},t.fromArray=function(e,t,n){return void 0===n&&(n=0),t.r=255*e[n+0],t.g=255*e[n+1],t.b=255*e[n+2],t.a=255*e[n+3],t},t.strictEquals=function(e,t){return e.r===t.r&&e.g===t.g&&e.b===t.b&&e.a===t.a},t.equals=function(e,t,n){return void 0===n&&(n=dn),Math.abs(e.r-t.r)<=n*Math.max(1,Math.abs(e.r),Math.abs(t.r))&&Math.abs(e.g-t.g)<=n*Math.max(1,Math.abs(e.g),Math.abs(t.g))&&Math.abs(e.b-t.b)<=n*Math.max(1,Math.abs(e.b),Math.abs(t.b))&&Math.abs(e.a-t.a)<=n*Math.max(1,Math.abs(e.a),Math.abs(t.a))},t.hex=function(e){return(255*e.r<<24|255*e.g<<16|255*e.b<<8|255*e.a)>>>0};var n=t.prototype;return n.clone=function(){var e=new t;return e._val=this._val,e},n.equals=function(e){return e&&this._val===e._val},n.lerp=function(e,t){var n=this.r,i=this.g,o=this.b,a=this.a;return n+=(e.r-n)*t,i+=(e.g-i)*t,o+=(e.b-o)*t,a+=(e.a-a)*t,this._val=Math.floor((a<<24>>>0)+(o<<16)+(i<<8)+n),this},n.toString=function(){return"rgba("+this.r.toFixed()+", "+this.g.toFixed()+", "+this.b.toFixed()+", "+this.a.toFixed()+")"},n.toCSS=function(e){return void 0===e&&(e="rgba"),"rgba"===e?"rgba("+this.r+","+this.g+","+this.b+","+(this.a*Tn).toFixed(2)+")":"rgb"===e?"rgb("+this.r+","+this.g+","+this.b+")":"#"+this.toHEX(e)},n.fromHEX=function(e){e=0===e.indexOf("#")?e.substring(1):e;var t=parseInt(e.substr(0,2),16)||0,n=parseInt(e.substr(2,2),16)||0,i=parseInt(e.substr(4,2),16)||0,o=parseInt(e.substr(6,2),16);return o=Number.isNaN(o)?255:o,this._val=(o<<24>>>0)+(i<<16)+(n<<8)+(0|t),this},n.toHEX=function(e){void 0===e&&(e="#rrggbb");var t="0",n=[(this.r<16?t:"")+this.r.toString(16),(this.g<16?t:"")+this.g.toString(16),(this.b<16?t:"")+this.b.toString(16)];return"#rgb"===e?(n[0]=n[0][0],n[1]=n[1][0],n[2]=n[2][0]):"#rrggbbaa"===e&&n.push((this.a<16?t:"")+this.a.toString(16)),n.join("")},n.toRGBValue=function(){return 16777215&this._val},n.fromHSV=function(e,t,n){var i=0,o=0,a=0;if(0===t)i=o=a=n;else if(0===n)i=o=a=0;else{1===e&&(e=0),e*=6;var r=Math.floor(e),c=e-r,s=n*(1-t),l=n*(1-t*c),f=n*(1-t*(1-c));switch(r){case 0:i=n,o=f,a=s;break;case 1:i=l,o=n,a=s;break;case 2:i=s,o=n,a=f;break;case 3:i=s,o=l,a=n;break;case 4:i=f,o=s,a=n;break;case 5:i=n,o=s,a=l}}return i*=255,o*=255,a*=255,this._val=(this.a<<24>>>0)+(a<<16)+(o<<8)+(0|i),this},n.toHSV=function(){var e=this.r*Tn,t=this.g*Tn,n=this.b*Tn,i={h:0,s:0,v:0},o=Math.max(e,t,n),a=Math.min(e,t,n),r=0;return i.v=o,i.s=o?(o-a)/o:0,i.s?(r=o-a,i.h=e===o?(t-n)/r:t===o?2+(n-e)/r:4+(e-t)/r,i.h/=6,i.h<0&&(i.h+=1)):i.h=0,i},n.set=function(e,t,n,i){return"object"==typeof e?null!=e._val?this._val=e._val:(t=e.g||0,n=e.b||0,i="number"==typeof e.a?e.a:255,e=e.r||0,this._val=(i<<24>>>0)+(n<<16)+(t<<8)+(0|e)):(e=e||0,t=t||0,n=n||0,i="number"==typeof i?i:255,this._val=(i<<24>>>0)+(n<<16)+(t<<8)+(0|e)),this},n.multiply=function(e){var t=(255&this._val)*e.r>>8,n=(65280&this._val)*e.g>>8,i=(16711680&this._val)*e.b>>8,o=((4278190080&this._val)>>>8)*e.a;return this._val=4278190080&o|16711680&i|65280&n|255&t,this},n._set_r_unsafe=function(e){return this._val=(4294967040&this._val|e)>>>0,this},n._set_g_unsafe=function(e){return this._val=(4294902015&this._val|e<<8)>>>0,this},n._set_b_unsafe=function(e){return this._val=(4278255615&this._val|e<<16)>>>0,this},n._set_a_unsafe=function(e){return this._val=(16777215&this._val|e<<24)>>>0,this},r(t,[{key:"r",get:function(){return 255&this._val},set:function(e){e=~~hn(e,0,255),this._val=(4294967040&this._val|e)>>>0}},{key:"g",get:function(){return(65280&this._val)>>8},set:function(e){e=~~hn(e,0,255),this._val=(4294902015&this._val|e<<8)>>>0}},{key:"b",get:function(){return(16711680&this._val)>>16},set:function(e){e=~~hn(e,0,255),this._val=(4278255615&this._val|e<<16)>>>0}},{key:"a",get:function(){return(4278190080&this._val)>>>24},set:function(e){e=~~hn(e,0,255),this._val=(16777215&this._val|e<<24)>>>0}},{key:"x",get:function(){return this.r*Tn},set:function(e){this.r=255*e}},{key:"y",get:function(){return this.g*Tn},set:function(e){this.g=255*e}},{key:"z",get:function(){return this.b*Tn},set:function(e){this.b=255*e}},{key:"w",get:function(){return this.a*Tn},set:function(e){this.a=255*e}}]),t}(l));function An(e,t,n,i){return new bn(e,t,n,i)}bn.WHITE=Object.freeze(new bn(255,255,255,255)),bn.GRAY=Object.freeze(new bn(127,127,127,255)),bn.BLACK=Object.freeze(new bn(0,0,0,255)),bn.TRANSPARENT=Object.freeze(new bn(0,0,0,0)),bn.RED=Object.freeze(new bn(255,0,0,255)),bn.GREEN=Object.freeze(new bn(0,255,0,255)),bn.BLUE=Object.freeze(new bn(0,0,255,255)),bn.CYAN=Object.freeze(new bn(0,255,255,255)),bn.MAGENTA=Object.freeze(new bn(255,0,255,255)),bn.YELLOW=Object.freeze(new bn(255,255,0,255)),c.fastDefine("cc.Color",bn,{r:0,g:0,b:0,a:255}),s.Color=bn,s.color=An;var wn=e("Q",function(e){function t(t,n,i){var o;return o=e.call(this)||this,t&&"object"==typeof t?(o.x=t.x,o.y=t.y,o.z=t.z):(o.x=t||0,o.y=n||0,o.z=i||0),o}a(t,e),t.zero=function(e){return e.x=0,e.y=0,e.z=0,e},t.clone=function(e){return new t(e.x,e.y,e.z)},t.copy=function(e,t){return e.x=t.x,e.y=t.y,e.z=t.z,e},t.set=function(e,t,n,i){return e.x=t,e.y=n,e.z=i,e},t.add=function(e,t,n){return e.x=t.x+n.x,e.y=t.y+n.y,e.z=t.z+n.z,e},t.subtract=function(e,t,n){return e.x=t.x-n.x,e.y=t.y-n.y,e.z=t.z-n.z,e},t.multiply=function(e,t,n){return e.x=t.x*n.x,e.y=t.y*n.y,e.z=t.z*n.z,e},t.divide=function(e,t,n){return e.x=t.x/n.x,e.y=t.y/n.y,e.z=t.z/n.z,e},t.ceil=function(e,t){return e.x=Math.ceil(t.x),e.y=Math.ceil(t.y),e.z=Math.ceil(t.z),e},t.floor=function(e,t){return e.x=Math.floor(t.x),e.y=Math.floor(t.y),e.z=Math.floor(t.z),e},t.min=function(e,t,n){return e.x=Math.min(t.x,n.x),e.y=Math.min(t.y,n.y),e.z=Math.min(t.z,n.z),e},t.max=function(e,t,n){return e.x=Math.max(t.x,n.x),e.y=Math.max(t.y,n.y),e.z=Math.max(t.z,n.z),e},t.round=function(e,t){return e.x=Math.round(t.x),e.y=Math.round(t.y),e.z=Math.round(t.z),e},t.multiplyScalar=function(e,t,n){return e.x=t.x*n,e.y=t.y*n,e.z=t.z*n,e},t.scaleAndAdd=function(e,t,n,i){return e.x=t.x+n.x*i,e.y=t.y+n.y*i,e.z=t.z+n.z*i,e},t.distance=function(e,t){var n=t.x-e.x,i=t.y-e.y,o=t.z-e.z;return Math.sqrt(n*n+i*i+o*o)},t.squaredDistance=function(e,t){var n=t.x-e.x,i=t.y-e.y,o=t.z-e.z;return n*n+i*i+o*o},t.len=function(e){var t=e.x,n=e.y,i=e.z;return Math.sqrt(t*t+n*n+i*i)},t.lengthSqr=function(e){var t=e.x,n=e.y,i=e.z;return t*t+n*n+i*i},t.negate=function(e,t){return e.x=-t.x,e.y=-t.y,e.z=-t.z,e},t.invert=function(e,t){return e.x=1/t.x,e.y=1/t.y,e.z=1/t.z,e},t.invertSafe=function(e,t){var n=t.x,i=t.y,o=t.z;return Math.abs(n)<dn?e.x=0:e.x=1/n,Math.abs(i)<dn?e.y=0:e.y=1/i,Math.abs(o)<dn?e.z=0:e.z=1/o,e},t.normalize=function(e,t){var n=t.x,i=t.y,o=t.z,a=n*n+i*i+o*o;return a>0&&(a=1/Math.sqrt(a),e.x=n*a,e.y=i*a,e.z=o*a),e},t.dot=function(e,t){return e.x*t.x+e.y*t.y+e.z*t.z},t.cross=function(e,t,n){var i=t.x,o=t.y,a=t.z,r=n.x,c=n.y,s=n.z;return e.x=o*s-a*c,e.y=a*r-i*s,e.z=i*c-o*r,e},t.lerp=function(e,t,n,i){return e.x=t.x+i*(n.x-t.x),e.y=t.y+i*(n.y-t.y),e.z=t.z+i*(n.z-t.z),e},t.random=function(e,t){t=t||1;var n=2*xn()*Math.PI,i=2*xn()-1,o=Math.sqrt(1-i*i);return e.x=o*Math.cos(n)*t,e.y=o*Math.sin(n)*t,e.z=i*t,e},t.transformMat4=function(e,t,n){var i=t.x,o=t.y,a=t.z,r=n.m03*i+n.m07*o+n.m11*a+n.m15;return r=r?Math.abs(1/r):1,e.x=(n.m00*i+n.m04*o+n.m08*a+n.m12)*r,e.y=(n.m01*i+n.m05*o+n.m09*a+n.m13)*r,e.z=(n.m02*i+n.m06*o+n.m10*a+n.m14)*r,e},t.transformMat4Normal=function(e,t,n){var i=t.x,o=t.y,a=t.z,r=n.m03*i+n.m07*o+n.m11*a;return r=r?Math.abs(1/r):1,e.x=(n.m00*i+n.m04*o+n.m08*a)*r,e.y=(n.m01*i+n.m05*o+n.m09*a)*r,e.z=(n.m02*i+n.m06*o+n.m10*a)*r,e},t.transformMat3=function(e,t,n){var i=t.x,o=t.y,a=t.z;return e.x=i*n.m00+o*n.m03+a*n.m06,e.y=i*n.m01+o*n.m04+a*n.m07,e.z=i*n.m02+o*n.m05+a*n.m08,e},t.transformAffine=function(e,t,n){var i=t.x,o=t.y,a=t.z;return e.x=n.m00*i+n.m04*o+n.m08*a+n.m12,e.y=n.m01*i+n.m05*o+n.m09*a+n.m13,e.z=n.m02*i+n.m06*o+n.m10*a+n.m14,e},t.transformQuat=function(e,t,n){var i=n.w*t.x+n.y*t.z-n.z*t.y,o=n.w*t.y+n.z*t.x-n.x*t.z,a=n.w*t.z+n.x*t.y-n.y*t.x,r=-n.x*t.x-n.y*t.y-n.z*t.z;return e.x=i*n.w+r*-n.x+o*-n.z-a*-n.y,e.y=o*n.w+r*-n.y+a*-n.x-i*-n.z,e.z=a*n.w+r*-n.z+i*-n.y-o*-n.x,e},t.transformRTS=function(e,t,n,i,o){var a=t.x*o.x,r=t.y*o.y,c=t.z*o.z,s=n.w*a+n.y*c-n.z*r,l=n.w*r+n.z*a-n.x*c,f=n.w*c+n.x*r-n.y*a,_=-n.x*a-n.y*r-n.z*c;return e.x=s*n.w+_*-n.x+l*-n.z-f*-n.y+i.x,e.y=l*n.w+_*-n.y+f*-n.x-s*-n.z+i.y,e.z=f*n.w+_*-n.z+s*-n.y-l*-n.x+i.z,e},t.transformInverseRTS=function(e,t,n,i,o){var a=t.x-i.x,r=t.y-i.y,c=t.z-i.z,s=n.w*a-n.y*c+n.z*r,l=n.w*r-n.z*a+n.x*c,f=n.w*c-n.x*r+n.y*a,_=n.x*a+n.y*r+n.z*c;return e.x=(s*n.w+_*n.x+l*n.z-f*n.y)/o.x,e.y=(l*n.w+_*n.y+f*n.x-s*n.z)/o.y,e.z=(f*n.w+_*n.z+s*n.y-l*n.x)/o.z,e},t.rotateX=function(e,t,n,i){var o=t.x-n.x,a=t.y-n.y,r=t.z-n.z,c=Math.cos(i),s=Math.sin(i),l=o,f=a*c-r*s,_=a*s+r*c;return e.x=l+n.x,e.y=f+n.y,e.z=_+n.z,e},t.rotateY=function(e,t,n,i){var o=t.x-n.x,a=t.y-n.y,r=t.z-n.z,c=Math.cos(i),s=Math.sin(i),l=r*s+o*c,f=a,_=r*c-o*s;return e.x=l+n.x,e.y=f+n.y,e.z=_+n.z,e},t.rotateZ=function(e,t,n,i){var o=t.x-n.x,a=t.y-n.y,r=t.z-n.z,c=Math.cos(i),s=Math.sin(i),l=o*c-a*s,f=o*s+a*c,_=r;return e.x=l+n.x,e.y=f+n.y,e.z=_+n.z,e},t.toArray=function(e,t,n){return void 0===n&&(n=0),e[n+0]=t.x,e[n+1]=t.y,e[n+2]=t.z,e},t.fromArray=function(e,t,n){return void 0===n&&(n=0),e.x=t[n+0],e.y=t[n+1],e.z=t[n+2],e},t.strictEquals=function(e,t){return e.x===t.x&&e.y===t.y&&e.z===t.z},t.equals=function(e,t,n){void 0===n&&(n=dn);var i=e.x,o=e.y,a=e.z,r=t.x,c=t.y,s=t.z;return Math.abs(i-r)<=n*Math.max(1,Math.abs(i),Math.abs(r))&&Math.abs(o-c)<=n*Math.max(1,Math.abs(o),Math.abs(c))&&Math.abs(a-s)<=n*Math.max(1,Math.abs(a),Math.abs(s))},t.angle=function(e,n){t.normalize(Nn,e),t.normalize(Dn,n);var i=t.dot(Nn,Dn);return i>1?0:i<-1?Math.PI:Math.acos(i)},t.projectOnPlane=function(e,n,i){return t.subtract(e,n,t.project(e,n,i))},t.project=function(e,n,i){var o=t.lengthSqr(i);return o<1e-6?t.set(e,0,0,0):t.multiplyScalar(e,i,t.dot(n,i)/o)};var n=t.prototype;return n.clone=function(){return new t(this.x,this.y,this.z)},n.set=function(e,t,n){return e&&"object"==typeof e?(this.x=e.x,this.y=e.y,this.z=e.z):(this.x=e||0,this.y=t||0,this.z=n||0),this},n.equals=function(e,t){return void 0===t&&(t=dn),Math.abs(this.x-e.x)<=t*Math.max(1,Math.abs(this.x),Math.abs(e.x))&&Math.abs(this.y-e.y)<=t*Math.max(1,Math.abs(this.y),Math.abs(e.y))&&Math.abs(this.z-e.z)<=t*Math.max(1,Math.abs(this.z),Math.abs(e.z))},n.equals3f=function(e,t,n,i){return void 0===i&&(i=dn),Math.abs(this.x-e)<=i*Math.max(1,Math.abs(this.x),Math.abs(e))&&Math.abs(this.y-t)<=i*Math.max(1,Math.abs(this.y),Math.abs(t))&&Math.abs(this.z-n)<=i*Math.max(1,Math.abs(this.z),Math.abs(n))},n.strictEquals=function(e){return this.x===e.x&&this.y===e.y&&this.z===e.z},n.strictEquals3f=function(e,t,n){return this.x===e&&this.y===t&&this.z===n},n.toString=function(){return"("+this.x.toFixed(2)+", "+this.y.toFixed(2)+", "+this.z.toFixed(2)+")"},n.lerp=function(e,t){return this.x+=t*(e.x-this.x),this.y+=t*(e.y-this.y),this.z+=t*(e.z-this.z),this},n.add=function(e){return this.x+=e.x,this.y+=e.y,this.z+=e.z,this},n.add3f=function(e,t,n){return this.x+=e,this.y+=t,this.z+=n,this},n.subtract=function(e){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this},n.subtract3f=function(e,t,n){return this.x-=e,this.y-=t,this.z-=n,this},n.multiplyScalar=function(e){return"object"==typeof e&&console.warn("should use Vec3.multiply for vector * vector operation"),this.x*=e,this.y*=e,this.z*=e,this},n.multiply=function(e){return"object"!=typeof e&&console.warn("should use Vec3.scale for vector * scalar operation"),this.x*=e.x,this.y*=e.y,this.z*=e.z,this},n.multiply3f=function(e,t,n){return this.x*=e,this.y*=t,this.z*=n,this},n.divide=function(e){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this},n.divide3f=function(e,t,n){return this.x/=e,this.y/=t,this.z/=n,this},n.negative=function(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this},n.clampf=function(e,t){return this.x=hn(this.x,e.x,t.x),this.y=hn(this.y,e.y,t.y),this.z=hn(this.z,e.z,t.z),this},n.dot=function(e){return this.x*e.x+this.y*e.y+this.z*e.z},n.cross=function(e){var t=this.x,n=this.y,i=this.z,o=e.x,a=e.y,r=e.z;return this.x=n*r-i*a,this.y=i*o-t*r,this.z=t*a-n*o,this},n.length=function(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)},n.lengthSqr=function(){return this.x*this.x+this.y*this.y+this.z*this.z},n.normalize=function(){var e=this.x,t=this.y,n=this.z,i=e*e+t*t+n*n;return i>0&&(i=1/Math.sqrt(i),this.x=e*i,this.y=t*i,this.z=n*i),this},n.transformMat4=function(e){var t=this.x,n=this.y,i=this.z,o=e.m03*t+e.m07*n+e.m11*i+e.m15;return o=o?1/o:1,this.x=(e.m00*t+e.m04*n+e.m08*i+e.m12)*o,this.y=(e.m01*t+e.m05*n+e.m09*i+e.m13)*o,this.z=(e.m02*t+e.m06*n+e.m10*i+e.m14)*o,this},t}(l));wn.UNIT_X=Object.freeze(new wn(1,0,0)),wn.UNIT_Y=Object.freeze(new wn(0,1,0)),wn.UNIT_Z=Object.freeze(new wn(0,0,1)),wn.RIGHT=Object.freeze(new wn(1,0,0)),wn.UP=Object.freeze(new wn(0,1,0)),wn.FORWARD=Object.freeze(new wn(0,0,-1)),wn.ZERO=Object.freeze(new wn(0,0,0)),wn.ONE=Object.freeze(new wn(1,1,1)),wn.NEG_ONE=Object.freeze(new wn(-1,-1,-1));var Nn=new wn,Dn=new wn;function Rn(e,t,n){return new wn(e,t,n)}c.fastDefine("cc.Vec3",wn,{x:0,y:0,z:0}),s.Vec3=wn,s.v3=Rn;var Mn=e("Y",function(e){function t(t,n,i,o,a,r,c,s,l){var f;return void 0===t&&(t=1),void 0===n&&(n=0),void 0===i&&(i=0),void 0===o&&(o=0),void 0===a&&(a=1),void 0===r&&(r=0),void 0===c&&(c=0),void 0===s&&(s=0),void 0===l&&(l=1),f=e.call(this)||this,"object"==typeof t?(f.m00=t.m00,f.m01=t.m01,f.m02=t.m02,f.m03=t.m03,f.m04=t.m04,f.m05=t.m05,f.m06=t.m06,f.m07=t.m07,f.m08=t.m08):(f.m00=t,f.m01=n,f.m02=i,f.m03=o,f.m04=a,f.m05=r,f.m06=c,f.m07=s,f.m08=l),f}a(t,e),t.clone=function(e){return new t(e.m00,e.m01,e.m02,e.m03,e.m04,e.m05,e.m06,e.m07,e.m08)},t.copy=function(e,t){return e.m00=t.m00,e.m01=t.m01,e.m02=t.m02,e.m03=t.m03,e.m04=t.m04,e.m05=t.m05,e.m06=t.m06,e.m07=t.m07,e.m08=t.m08,e},t.set=function(e,t,n,i,o,a,r,c,s,l){return e.m00=t,e.m01=n,e.m02=i,e.m03=o,e.m04=a,e.m05=r,e.m06=c,e.m07=s,e.m08=l,e},t.identity=function(e){return e.m00=1,e.m01=0,e.m02=0,e.m03=0,e.m04=1,e.m05=0,e.m06=0,e.m07=0,e.m08=1,e},t.transpose=function(e,t){if(e===t){var n=t.m01,i=t.m02,o=t.m05;e.m01=t.m03,e.m02=t.m06,e.m03=n,e.m05=t.m07,e.m06=i,e.m07=o}else e.m00=t.m00,e.m01=t.m03,e.m02=t.m06,e.m03=t.m01,e.m04=t.m04,e.m05=t.m07,e.m06=t.m02,e.m07=t.m05,e.m08=t.m08;return e},t.invert=function(e,t){var n=t.m00,i=t.m01,o=t.m02,a=t.m03,r=t.m04,c=t.m05,s=t.m06,l=t.m07,f=t.m08,_=f*r-c*l,u=-f*a+c*s,m=l*a-r*s,d=n*_+i*u+o*m;return 0===d?(e.m00=0,e.m01=0,e.m02=0,e.m03=0,e.m04=0,e.m05=0,e.m06=0,e.m07=0,e.m08=0,e):(d=1/d,e.m00=_*d,e.m01=(-f*i+o*l)*d,e.m02=(c*i-o*r)*d,e.m03=u*d,e.m04=(f*n-o*s)*d,e.m05=(-c*n+o*a)*d,e.m06=m*d,e.m07=(-l*n+i*s)*d,e.m08=(r*n-i*a)*d,e)},t.determinant=function(e){var t=e.m00,n=e.m01,i=e.m02,o=e.m03,a=e.m04,r=e.m05,c=e.m06,s=e.m07,l=e.m08;return t*(l*a-r*s)+n*(-l*o+r*c)+i*(s*o-a*c)},t.multiply=function(e,t,n){var i=t.m00,o=t.m01,a=t.m02,r=t.m03,c=t.m04,s=t.m05,l=t.m06,f=t.m07,_=t.m08,u=n.m00,m=n.m01,d=n.m02,p=n.m03,h=n.m04,v=n.m05,g=n.m06,x=n.m07,y=n.m08;return e.m00=u*i+m*r+d*l,e.m01=u*o+m*c+d*f,e.m02=u*a+m*s+d*_,e.m03=p*i+h*r+v*l,e.m04=p*o+h*c+v*f,e.m05=p*a+h*s+v*_,e.m06=g*i+x*r+y*l,e.m07=g*o+x*c+y*f,e.m08=g*a+x*s+y*_,e},t.multiplyMat4=function(e,t,n){var i=t.m00,o=t.m01,a=t.m02,r=t.m03,c=t.m04,s=t.m05,l=t.m06,f=t.m07,_=t.m08,u=n.m00,m=n.m01,d=n.m02,p=n.m04,h=n.m05,v=n.m06,g=n.m08,x=n.m09,y=n.m10;return e.m00=u*i+m*r+d*l,e.m01=u*o+m*c+d*f,e.m02=u*a+m*s+d*_,e.m03=p*i+h*r+v*l,e.m04=p*o+h*c+v*f,e.m05=p*a+h*s+v*_,e.m06=g*i+x*r+y*l,e.m07=g*o+x*c+y*f,e.m08=g*a+x*s+y*_,e},t.transform=function(e,t,n){var i=t.m00,o=t.m01,a=t.m02,r=t.m03,c=t.m04,s=t.m05,l=t.m06,f=t.m07,_=t.m08,u=n.x,m=n.y;return e.m00=i,e.m01=o,e.m02=a,e.m03=r,e.m04=c,e.m05=s,e.m06=u*i+m*r+l,e.m07=u*o+m*c+f,e.m08=u*a+m*s+_,e},t.scale=function(e,t,n){var i=n.x,o=n.y;return e.m00=i*t.m00,e.m01=i*t.m01,e.m02=i*t.m02,e.m03=o*t.m03,e.m04=o*t.m04,e.m05=o*t.m05,e.m06=t.m06,e.m07=t.m07,e.m08=t.m08,e},t.rotate=function(e,t,n){var i=t.m00,o=t.m01,a=t.m02,r=t.m03,c=t.m04,s=t.m05,l=t.m06,f=t.m07,_=t.m08,u=Math.sin(n),m=Math.cos(n);return e.m00=m*i+u*r,e.m01=m*o+u*c,e.m02=m*a+u*s,e.m03=m*r-u*i,e.m04=m*c-u*o,e.m05=m*s-u*a,e.m06=l,e.m07=f,e.m08=_,e},t.fromMat4=function(e,t){return e.m00=t.m00,e.m01=t.m01,e.m02=t.m02,e.m03=t.m04,e.m04=t.m05,e.m05=t.m06,e.m06=t.m08,e.m07=t.m09,e.m08=t.m10,e},t.fromViewUp=function(e,n,i){return wn.lengthSqr(n)<dn*dn?(t.identity(e),e):(i=i||wn.UNIT_Y,wn.normalize(On,wn.cross(On,i,n)),wn.lengthSqr(On)<dn*dn?(t.identity(e),e):(wn.cross(Ln,n,On),t.set(e,On.x,On.y,On.z,Ln.x,Ln.y,Ln.z,n.x,n.y,n.z),e))},t.fromTranslation=function(e,t){return e.m00=1,e.m01=0,e.m02=0,e.m03=0,e.m04=1,e.m05=0,e.m06=t.x,e.m07=t.y,e.m08=1,e},t.fromScaling=function(e,t){return e.m00=t.x,e.m01=0,e.m02=0,e.m03=0,e.m04=t.y,e.m05=0,e.m06=0,e.m07=0,e.m08=1,e},t.fromRotation=function(e,t){var n=Math.sin(t),i=Math.cos(t);return e.m00=i,e.m01=n,e.m02=0,e.m03=-n,e.m04=i,e.m05=0,e.m06=0,e.m07=0,e.m08=1,e},t.fromQuat=function(e,t){var n=t.x,i=t.y,o=t.z,a=t.w,r=n+n,c=i+i,s=o+o,l=n*r,f=i*r,_=i*c,u=o*r,m=o*c,d=o*s,p=a*r,h=a*c,v=a*s;return e.m00=1-_-d,e.m03=f-v,e.m06=u+h,e.m01=f+v,e.m04=1-l-d,e.m07=m-p,e.m02=u-h,e.m05=m+p,e.m08=1-l-_,e},t.inverseTransposeMat4=function(e,t){var n=t.m00,i=t.m01,o=t.m02,a=t.m03,r=t.m04,c=t.m05,s=t.m06,l=t.m07,f=t.m08,_=t.m09,u=t.m10,m=t.m11,d=t.m12,p=t.m13,h=t.m14,v=t.m15,g=n*c-i*r,x=n*s-o*r,y=n*l-a*r,C=i*s-o*c,S=i*l-a*c,E=o*l-a*s,P=f*p-_*d,I=f*h-u*d,T=f*v-m*d,b=_*h-u*p,A=_*v-m*p,w=u*v-m*h,N=g*w-x*A+y*b+C*T-S*I+E*P;return N?(N=1/N,e.m00=(c*w-s*A+l*b)*N,e.m01=(s*T-r*w-l*I)*N,e.m02=(r*A-c*T+l*P)*N,e.m03=(o*A-i*w-a*b)*N,e.m04=(n*w-o*T+a*I)*N,e.m05=(i*T-n*A-a*P)*N,e.m06=(p*E-h*S+v*C)*N,e.m07=(h*y-d*E-v*x)*N,e.m08=(d*S-p*y+v*g)*N,e):null},t.toArray=function(e,t,n){return void 0===n&&(n=0),e[n+0]=t.m00,e[n+1]=t.m01,e[n+2]=t.m02,e[n+3]=t.m03,e[n+4]=t.m04,e[n+5]=t.m05,e[n+6]=t.m06,e[n+7]=t.m07,e[n+8]=t.m08,e},t.fromArray=function(e,t,n){return void 0===n&&(n=0),e.m00=t[n+0],e.m01=t[n+1],e.m02=t[n+2],e.m03=t[n+3],e.m04=t[n+4],e.m05=t[n+5],e.m06=t[n+6],e.m07=t[n+7],e.m08=t[n+8],e},t.add=function(e,t,n){return e.m00=t.m00+n.m00,e.m01=t.m01+n.m01,e.m02=t.m02+n.m02,e.m03=t.m03+n.m03,e.m04=t.m04+n.m04,e.m05=t.m05+n.m05,e.m06=t.m06+n.m06,e.m07=t.m07+n.m07,e.m08=t.m08+n.m08,e},t.subtract=function(e,t,n){return e.m00=t.m00-n.m00,e.m01=t.m01-n.m01,e.m02=t.m02-n.m02,e.m03=t.m03-n.m03,e.m04=t.m04-n.m04,e.m05=t.m05-n.m05,e.m06=t.m06-n.m06,e.m07=t.m07-n.m07,e.m08=t.m08-n.m08,e},t.multiplyScalar=function(e,t,n){return e.m00=t.m00*n,e.m01=t.m01*n,e.m02=t.m02*n,e.m03=t.m03*n,e.m04=t.m04*n,e.m05=t.m05*n,e.m06=t.m06*n,e.m07=t.m07*n,e.m08=t.m08*n,e},t.multiplyScalarAndAdd=function(e,t,n,i){return e.m00=n.m00*i+t.m00,e.m01=n.m01*i+t.m01,e.m02=n.m02*i+t.m02,e.m03=n.m03*i+t.m03,e.m04=n.m04*i+t.m04,e.m05=n.m05*i+t.m05,e.m06=n.m06*i+t.m06,e.m07=n.m07*i+t.m07,e.m08=n.m08*i+t.m08,e},t.strictEquals=function(e,t){return e.m00===t.m00&&e.m01===t.m01&&e.m02===t.m02&&e.m03===t.m03&&e.m04===t.m04&&e.m05===t.m05&&e.m06===t.m06&&e.m07===t.m07&&e.m08===t.m08},t.equals=function(e,t,n){return void 0===n&&(n=dn),Math.abs(e.m00-t.m00)<=n*Math.max(1,Math.abs(e.m00),Math.abs(t.m00))&&Math.abs(e.m01-t.m01)<=n*Math.max(1,Math.abs(e.m01),Math.abs(t.m01))&&Math.abs(e.m02-t.m02)<=n*Math.max(1,Math.abs(e.m02),Math.abs(t.m02))&&Math.abs(e.m03-t.m03)<=n*Math.max(1,Math.abs(e.m03),Math.abs(t.m03))&&Math.abs(e.m04-t.m04)<=n*Math.max(1,Math.abs(e.m04),Math.abs(t.m04))&&Math.abs(e.m05-t.m05)<=n*Math.max(1,Math.abs(e.m05),Math.abs(t.m05))&&Math.abs(e.m06-t.m06)<=n*Math.max(1,Math.abs(e.m06),Math.abs(t.m06))&&Math.abs(e.m07-t.m07)<=n*Math.max(1,Math.abs(e.m07),Math.abs(t.m07))&&Math.abs(e.m08-t.m08)<=n*Math.max(1,Math.abs(e.m08),Math.abs(t.m08))};var n=t.prototype;return n.clone=function(){var e=this;return new t(e.m00,e.m01,e.m02,e.m03,e.m04,e.m05,e.m06,e.m07,e.m08)},n.set=function(e,t,n,i,o,a,r,c,s){return void 0===e&&(e=1),void 0===t&&(t=0),void 0===n&&(n=0),void 0===i&&(i=0),void 0===o&&(o=1),void 0===a&&(a=0),void 0===r&&(r=0),void 0===c&&(c=0),void 0===s&&(s=1),"object"==typeof e?(this.m00=e.m00,this.m01=e.m01,this.m02=e.m02,this.m03=e.m03,this.m04=e.m04,this.m05=e.m05,this.m06=e.m06,this.m07=e.m07,this.m08=e.m08):(this.m00=e,this.m01=t,this.m02=n,this.m03=i,this.m04=o,this.m05=a,this.m06=r,this.m07=c,this.m08=s),this},n.equals=function(e,t){return void 0===t&&(t=dn),Math.abs(this.m00-e.m00)<=t*Math.max(1,Math.abs(this.m00),Math.abs(e.m00))&&Math.abs(this.m01-e.m01)<=t*Math.max(1,Math.abs(this.m01),Math.abs(e.m01))&&Math.abs(this.m02-e.m02)<=t*Math.max(1,Math.abs(this.m02),Math.abs(e.m02))&&Math.abs(this.m03-e.m03)<=t*Math.max(1,Math.abs(this.m03),Math.abs(e.m03))&&Math.abs(this.m04-e.m04)<=t*Math.max(1,Math.abs(this.m04),Math.abs(e.m04))&&Math.abs(this.m05-e.m05)<=t*Math.max(1,Math.abs(this.m05),Math.abs(e.m05))&&Math.abs(this.m06-e.m06)<=t*Math.max(1,Math.abs(this.m06),Math.abs(e.m06))&&Math.abs(this.m07-e.m07)<=t*Math.max(1,Math.abs(this.m07),Math.abs(e.m07))&&Math.abs(this.m08-e.m08)<=t*Math.max(1,Math.abs(this.m08),Math.abs(e.m08))},n.strictEquals=function(e){return this.m00===e.m00&&this.m01===e.m01&&this.m02===e.m02&&this.m03===e.m03&&this.m04===e.m04&&this.m05===e.m05&&this.m06===e.m06&&this.m07===e.m07&&this.m08===e.m08},n.toString=function(){var e=this;return"[\n"+e.m00+", "+e.m01+", "+e.m02+",\n"+e.m03+",\n"+e.m04+", "+e.m05+",\n"+e.m06+", "+e.m07+",\n"+e.m08+"\n]"},n.identity=function(){return this.m00=1,this.m01=0,this.m02=0,this.m03=0,this.m04=1,this.m05=0,this.m06=0,this.m07=0,this.m08=1,this},n.transpose=function(){var e=this.m01,t=this.m02,n=this.m05;return this.m01=this.m03,this.m02=this.m06,this.m03=e,this.m05=this.m07,this.m06=t,this.m07=n,this},n.invert=function(){var e=this.m00,t=this.m01,n=this.m02,i=this.m03,o=this.m04,a=this.m05,r=this.m06,c=this.m07,s=this.m08,l=s*o-a*c,f=-s*i+a*r,_=c*i-o*r,u=e*l+t*f+n*_;return 0===u?(this.set(0,0,0,0,0,0,0,0,0),this):(u=1/u,this.m00=l*u,this.m01=(-s*t+n*c)*u,this.m02=(a*t-n*o)*u,this.m03=f*u,this.m04=(s*e-n*r)*u,this.m05=(-a*e+n*i)*u,this.m06=_*u,this.m07=(-c*e+t*r)*u,this.m08=(o*e-t*i)*u,this)},n.determinant=function(){var e=this.m00,t=this.m01,n=this.m02,i=this.m03,o=this.m04,a=this.m05,r=this.m06,c=this.m07,s=this.m08;return e*(s*o-a*c)+t*(-s*i+a*r)+n*(c*i-o*r)},n.add=function(e){return this.m00+=e.m00,this.m01+=e.m01,this.m02+=e.m02,this.m03+=e.m03,this.m04+=e.m04,this.m05+=e.m05,this.m06+=e.m06,this.m07+=e.m07,this.m08+=e.m08,this},n.subtract=function(e){return this.m00-=e.m00,this.m01-=e.m01,this.m02-=e.m02,this.m03-=e.m03,this.m04-=e.m04,this.m05-=e.m05,this.m06-=e.m06,this.m07-=e.m07,this.m08-=e.m08,this},n.multiply=function(e){var t=this.m00,n=this.m01,i=this.m02,o=this.m03,a=this.m04,r=this.m05,c=this.m06,s=this.m07,l=this.m08,f=e.m00,_=e.m01,u=e.m02,m=e.m03,d=e.m04,p=e.m05,h=e.m06,v=e.m07,g=e.m08;return this.m00=f*t+_*o+u*c,this.m01=f*n+_*a+u*s,this.m02=f*i+_*r+u*l,this.m03=m*t+d*o+p*c,this.m04=m*n+d*a+p*s,this.m05=m*i+d*r+p*l,this.m06=h*t+v*o+g*c,this.m07=h*n+v*a+g*s,this.m08=h*i+v*r+g*l,this},n.multiplyScalar=function(e){return this.m00*=e,this.m01*=e,this.m02*=e,this.m03*=e,this.m04*=e,this.m05*=e,this.m06*=e,this.m07*=e,this.m08*=e,this},n.scale=function(e){var t=e.x,n=e.y;return this.m00=t*this.m00,this.m01=t*this.m01,this.m02=t*this.m02,this.m03=n*this.m03,this.m04=n*this.m04,this.m05=n*this.m05,this.m06=this.m06,this.m07=this.m07,this.m08=this.m08,this},n.rotate=function(e){var t=this.m00,n=this.m01,i=this.m02,o=this.m03,a=this.m04,r=this.m05,c=this.m06,s=this.m07,l=this.m08,f=Math.sin(e),_=Math.cos(e);return this.m00=_*t+f*o,this.m01=_*n+f*a,this.m02=_*i+f*r,this.m03=_*o-f*t,this.m04=_*a-f*n,this.m05=_*r-f*i,this.m06=c,this.m07=s,this.m08=l,this},n.fromQuat=function(e){var t=e.x,n=e.y,i=e.z,o=e.w,a=t+t,r=n+n,c=i+i,s=t*a,l=n*a,f=n*r,_=i*a,u=i*r,m=i*c,d=o*a,p=o*r,h=o*c;return this.m00=1-f-m,this.m03=l-h,this.m06=_+p,this.m01=l+h,this.m04=1-s-m,this.m07=u-d,this.m02=_-p,this.m05=u+d,this.m08=1-s-f,this},t}(l));Mn.IDENTITY=Object.freeze(new Mn);var On=new wn,Ln=new wn;c.fastDefine("cc.Mat3",Mn,{m00:1,m01:0,m02:0,m03:0,m04:1,m05:0,m06:0,m07:0,m08:1}),s.Mat3=Mn;var zn=e("W",function(e){function t(t,n,i,o){var a;return a=e.call(this)||this,t&&"object"==typeof t?(a.x=t.x,a.y=t.y,a.z=t.z,a.w=t.w):(a.x=t||0,a.y=n||0,a.z=i||0,a.w=null!=o?o:1),a}a(t,e),t.clone=function(e){return new t(e.x,e.y,e.z,e.w)},t.copy=function(e,t){return e.x=t.x,e.y=t.y,e.z=t.z,e.w=t.w,e},t.set=function(e,t,n,i,o){return e.x=t,e.y=n,e.z=i,e.w=o,e},t.identity=function(e){return e.x=0,e.y=0,e.z=0,e.w=1,e},t.rotationTo=function(e,n,i){var o=wn.dot(n,i);return o<-.999999?(wn.cross(Gn,wn.UNIT_X,n),Gn.length()<1e-6&&wn.cross(Gn,wn.UNIT_Y,n),wn.normalize(Gn,Gn),t.fromAxisAngle(e,Gn,Math.PI),e):o>.999999?(e.x=0,e.y=0,e.z=0,e.w=1,e):(wn.cross(Gn,n,i),e.x=Gn.x,e.y=Gn.y,e.z=Gn.z,e.w=1+o,t.normalize(e,e))},t.getAxisAngle=function(e,t){var n=2*Math.acos(t.w),i=Math.sin(n/2);return 0!==i?(e.x=t.x/i,e.y=t.y/i,e.z=t.z/i):(e.x=1,e.y=0,e.z=0),n},t.multiply=function(e,t,n){var i=t.x*n.w+t.w*n.x+t.y*n.z-t.z*n.y,o=t.y*n.w+t.w*n.y+t.z*n.x-t.x*n.z,a=t.z*n.w+t.w*n.z+t.x*n.y-t.y*n.x,r=t.w*n.w-t.x*n.x-t.y*n.y-t.z*n.z;return e.x=i,e.y=o,e.z=a,e.w=r,e},t.multiplyScalar=function(e,t,n){return e.x=t.x*n,e.y=t.y*n,e.z=t.z*n,e.w=t.w*n,e},t.scaleAndAdd=function(e,t,n,i){return e.x=t.x+n.x*i,e.y=t.y+n.y*i,e.z=t.z+n.z*i,e.w=t.w+n.w*i,e},t.rotateX=function(e,t,n){n*=.5;var i=Math.sin(n),o=Math.cos(n),a=t.x,r=t.y,c=t.z,s=t.w;return e.x=a*o+s*i,e.y=r*o+c*i,e.z=c*o-r*i,e.w=s*o-a*i,e},t.rotateY=function(e,t,n){n*=.5;var i=Math.sin(n),o=Math.cos(n),a=t.x,r=t.y,c=t.z,s=t.w;return e.x=a*o-c*i,e.y=r*o+s*i,e.z=c*o+a*i,e.w=s*o-r*i,e},t.rotateZ=function(e,t,n){n*=.5;var i=Math.sin(n),o=Math.cos(n),a=t.x,r=t.y,c=t.z,s=t.w;return e.x=a*o+r*i,e.y=r*o-a*i,e.z=c*o+s*i,e.w=s*o-c*i,e},t.rotateAround=function(e,n,i,o){return t.invert(Fn,n),wn.transformQuat(Gn,i,Fn),t.fromAxisAngle(Fn,Gn,o),t.multiply(e,n,Fn),e},t.rotateAroundLocal=function(e,n,i,o){return t.fromAxisAngle(Fn,i,o),t.multiply(e,n,Fn),e},t.calculateW=function(e,t){return e.x=t.x,e.y=t.y,e.z=t.z,e.w=Math.sqrt(Math.abs(1-t.x*t.x-t.y*t.y-t.z*t.z)),e},t.dot=function(e,t){return e.x*t.x+e.y*t.y+e.z*t.z+e.w*t.w},t.lerp=function(e,t,n,i){return e.x=t.x+i*(n.x-t.x),e.y=t.y+i*(n.y-t.y),e.z=t.z+i*(n.z-t.z),e.w=t.w+i*(n.w-t.w),e},t.slerp=function(e,t,n,i){var o=0,a=0,r=n.x,c=n.y,s=n.z,l=n.w,f=t.x*n.x+t.y*n.y+t.z*n.z+t.w*n.w;if(f<0&&(f=-f,r=-r,c=-c,s=-s,l=-l),1-f>1e-6){var _=Math.acos(f),u=Math.sin(_);o=Math.sin((1-i)*_)/u,a=Math.sin(i*_)/u}else o=1-i,a=i;return e.x=o*t.x+a*r,e.y=o*t.y+a*c,e.z=o*t.z+a*s,e.w=o*t.w+a*l,e},t.sqlerp=function(e,n,i,o,a,r){return t.slerp(Fn,n,a,r),t.slerp(Un,i,o,r),t.slerp(e,Fn,Un,2*r*(1-r)),e},t.invert=function(e,t){var n=t.x*t.x+t.y*t.y+t.z*t.z+t.w*t.w,i=n?1/n:0;return e.x=-t.x*i,e.y=-t.y*i,e.z=-t.z*i,e.w=t.w*i,e},t.conjugate=function(e,t){return e.x=-t.x,e.y=-t.y,e.z=-t.z,e.w=t.w,e},t.len=function(e){return Math.sqrt(e.x*e.x+e.y*e.y+e.z*e.z+e.w*e.w)},t.lengthSqr=function(e){return e.x*e.x+e.y*e.y+e.z*e.z+e.w*e.w},t.normalize=function(e,t){var n=t.x*t.x+t.y*t.y+t.z*t.z+t.w*t.w;return n>0&&(n=1/Math.sqrt(n),e.x=t.x*n,e.y=t.y*n,e.z=t.z*n,e.w=t.w*n),e},t.fromAxes=function(e,n,i,o){return Mn.set(Bn,n.x,n.y,n.z,i.x,i.y,i.z,o.x,o.y,o.z),t.normalize(e,t.fromMat3(e,Bn))},t.fromViewUp=function(e,n,i){return Mn.fromViewUp(Bn,n,i),t.normalize(e,t.fromMat3(e,Bn))},t.fromAxisAngle=function(e,t,n){n*=.5;var i=Math.sin(n);return e.x=i*t.x,e.y=i*t.y,e.z=i*t.z,e.w=Math.cos(n),e},t.fromMat3=function(e,t){var n=t.m00,i=t.m03,o=t.m06,a=t.m01,r=t.m04,c=t.m07,s=t.m02,l=t.m05,f=t.m08,_=n+r+f;if(_>0){var u=.5/Math.sqrt(_+1);e.w=.25/u,e.x=(l-c)*u,e.y=(o-s)*u,e.z=(a-i)*u}else if(n>r&&n>f){var m=2*Math.sqrt(1+n-r-f);e.w=(l-c)/m,e.x=.25*m,e.y=(i+a)/m,e.z=(o+s)/m}else if(r>f){var d=2*Math.sqrt(1+r-n-f);e.w=(o-s)/d,e.x=(i+a)/d,e.y=.25*d,e.z=(c+l)/d}else{var p=2*Math.sqrt(1+f-n-r);e.w=(a-i)/p,e.x=(o+s)/p,e.y=(c+l)/p,e.z=.25*p}return e},t.fromEuler=function(e,t,n,i){t*=Hn,n*=Hn,i*=Hn;var o=Math.sin(t),a=Math.cos(t),r=Math.sin(n),c=Math.cos(n),s=Math.sin(i),l=Math.cos(i);return e.x=o*c*l+a*r*s,e.y=a*r*l+o*c*s,e.z=a*c*s-o*r*l,e.w=a*c*l-o*r*s,e},t.fromAngleZ=function(e,t){return t*=Hn,e.x=e.y=0,e.z=Math.sin(t),e.w=Math.cos(t),e},t.toAxisX=function(e,t){var n=2*t.y,i=2*t.z;return e.x=1-n*t.y-i*t.z,e.y=n*t.x+i*t.w,e.z=i*t.x+n*t.w,e},t.toAxisY=function(e,t){var n=2*t.x,i=2*t.y,o=2*t.z;return e.x=i*t.x-o*t.w,e.y=1-n*t.x-o*t.z,e.z=o*t.y+n*t.w,e},t.toAxisZ=function(e,t){var n=2*t.x,i=2*t.y,o=2*t.z;return e.x=o*t.x-i*t.w,e.y=o*t.y-n*t.w,e.z=1-n*t.x-i*t.y,e},t.toEuler=function(e,t,n){var i=t.x,o=t.y,a=t.z,r=t.w,c=0,s=0,l=0,f=i*o+a*r;if(f>.499999)c=0,s=gn(2*Math.atan2(i,r)),l=90;else if(f<-.499999)c=0,s=-gn(2*Math.atan2(i,r)),l=-90;else{var _=i*i,u=o*o,m=a*a;c=gn(Math.atan2(2*i*r-2*o*a,1-2*_-2*m)),s=gn(Math.atan2(2*o*r-2*i*a,1-2*u-2*m)),l=gn(Math.asin(2*f)),n&&(c=-180*Math.sign(c+1e-6)+c,s=-180*Math.sign(s+1e-6)+s,l=180*Math.sign(l+1e-6)-l)}return e.x=c,e.y=s,e.z=l,e},t.toArray=function(e,t,n){return void 0===n&&(n=0),e[n+0]=t.x,e[n+1]=t.y,e[n+2]=t.z,e[n+3]=t.w,e},t.fromArray=function(e,t,n){return void 0===n&&(n=0),e.x=t[n+0],e.y=t[n+1],e.z=t[n+2],e.w=t[n+3],e},t.strictEquals=function(e,t){return e.x===t.x&&e.y===t.y&&e.z===t.z&&e.w===t.w},t.equals=function(e,t,n){return void 0===n&&(n=dn),Math.abs(e.x-t.x)<=n*Math.max(1,Math.abs(e.x),Math.abs(t.x))&&Math.abs(e.y-t.y)<=n*Math.max(1,Math.abs(e.y),Math.abs(t.y))&&Math.abs(e.z-t.z)<=n*Math.max(1,Math.abs(e.z),Math.abs(t.z))&&Math.abs(e.w-t.w)<=n*Math.max(1,Math.abs(e.w),Math.abs(t.w))};var n=t.prototype;return n.clone=function(){return new t(this.x,this.y,this.z,this.w)},n.set=function(e,t,n,i){return e&&"object"==typeof e?(this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w):(this.x=e||0,this.y=t||0,this.z=n||0,this.w=null!=i?i:1),this},n.equals=function(e,t){return void 0===t&&(t=dn),Math.abs(this.x-e.x)<=t*Math.max(1,Math.abs(this.x),Math.abs(e.x))&&Math.abs(this.y-e.y)<=t*Math.max(1,Math.abs(this.y),Math.abs(e.y))&&Math.abs(this.z-e.z)<=t*Math.max(1,Math.abs(this.z),Math.abs(e.z))&&Math.abs(this.w-e.w)<=t*Math.max(1,Math.abs(this.w),Math.abs(e.w))},n.strictEquals=function(e){return e&&this.x===e.x&&this.y===e.y&&this.z===e.z&&this.w===e.w},n.getEulerAngles=function(e){return t.toEuler(e,this)},n.lerp=function(e,t){return this.x+=t*(e.x-this.x),this.y+=t*(e.y-this.y),this.z+=t*(e.z-this.z),this.w+=t*(e.w-this.w),this},n.slerp=function(e,n){return t.slerp(this,this,e,n)},n.length=function(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)},n.lengthSqr=function(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w},t}(l));zn.IDENTITY=Object.freeze(new zn);var Fn=new zn,Un=new zn,Gn=new wn,Bn=new Mn,Hn=.5*Math.PI/180;function Vn(e,t,n,i){return void 0===e&&(e=0),void 0===t&&(t=0),void 0===n&&(n=0),void 0===i&&(i=1),new zn(e,t,n,i)}c.fastDefine("cc.Quat",zn,{x:0,y:0,z:0,w:1}),s.Quat=zn,s.quat=Vn;var kn=e("d7",Object.freeze([Object.freeze([1,0,0,1]),Object.freeze([0,1,-1,0]),Object.freeze([-1,0,0,-1]),Object.freeze([0,-1,1,0])])),jn=e("Z",function(e){function t(t,n,i,o,a,r,c,s,l,f,_,u,m,d,p,h){var v;return void 0===t&&(t=1),void 0===n&&(n=0),void 0===i&&(i=0),void 0===o&&(o=0),void 0===a&&(a=0),void 0===r&&(r=1),void 0===c&&(c=0),void 0===s&&(s=0),void 0===l&&(l=0),void 0===f&&(f=0),void 0===_&&(_=1),void 0===u&&(u=0),void 0===m&&(m=0),void 0===d&&(d=0),void 0===p&&(p=0),void 0===h&&(h=1),(v=e.call(this)||this).m00=void 0,v.m01=void 0,v.m02=void 0,v.m03=void 0,v.m04=void 0,v.m05=void 0,v.m06=void 0,v.m07=void 0,v.m08=void 0,v.m09=void 0,v.m10=void 0,v.m11=void 0,v.m12=void 0,v.m13=void 0,v.m14=void 0,v.m15=void 0,"object"==typeof t?(v.m00=t.m00,v.m01=t.m01,v.m02=t.m02,v.m03=t.m03,v.m04=t.m04,v.m05=t.m05,v.m06=t.m06,v.m07=t.m07,v.m08=t.m08,v.m09=t.m09,v.m10=t.m10,v.m11=t.m11,v.m12=t.m12,v.m13=t.m13,v.m14=t.m14,v.m15=t.m15):(v.m00=t,v.m01=n,v.m02=i,v.m03=o,v.m04=a,v.m05=r,v.m06=c,v.m07=s,v.m08=l,v.m09=f,v.m10=_,v.m11=u,v.m12=m,v.m13=d,v.m14=p,v.m15=h),v}a(t,e),t.clone=function(e){return new t(e.m00,e.m01,e.m02,e.m03,e.m04,e.m05,e.m06,e.m07,e.m08,e.m09,e.m10,e.m11,e.m12,e.m13,e.m14,e.m15)},t.copy=function(e,t){return e.m00=t.m00,e.m01=t.m01,e.m02=t.m02,e.m03=t.m03,e.m04=t.m04,e.m05=t.m05,e.m06=t.m06,e.m07=t.m07,e.m08=t.m08,e.m09=t.m09,e.m10=t.m10,e.m11=t.m11,e.m12=t.m12,e.m13=t.m13,e.m14=t.m14,e.m15=t.m15,e},t.set=function(e,t,n,i,o,a,r,c,s,l,f,_,u,m,d,p,h){return e.m00=t,e.m01=n,e.m02=i,e.m03=o,e.m04=a,e.m05=r,e.m06=c,e.m07=s,e.m08=l,e.m09=f,e.m10=_,e.m11=u,e.m12=m,e.m13=d,e.m14=p,e.m15=h,e},t.identity=function(e){return e.m00=1,e.m01=0,e.m02=0,e.m03=0,e.m04=0,e.m05=1,e.m06=0,e.m07=0,e.m08=0,e.m09=0,e.m10=1,e.m11=0,e.m12=0,e.m13=0,e.m14=0,e.m15=1,e},t.transpose=function(e,t){if(e===t){var n=t.m01,i=t.m02,o=t.m03,a=t.m06,r=t.m07,c=t.m11;e.m01=t.m04,e.m02=t.m08,e.m03=t.m12,e.m04=n,e.m06=t.m09,e.m07=t.m13,e.m08=i,e.m09=a,e.m11=t.m14,e.m12=o,e.m13=r,e.m14=c}else e.m00=t.m00,e.m01=t.m04,e.m02=t.m08,e.m03=t.m12,e.m04=t.m01,e.m05=t.m05,e.m06=t.m09,e.m07=t.m13,e.m08=t.m02,e.m09=t.m06,e.m10=t.m10,e.m11=t.m14,e.m12=t.m03,e.m13=t.m07,e.m14=t.m11,e.m15=t.m15;return e},t.invert=function(e,t){var n=t.m00,i=t.m01,o=t.m02,a=t.m03,r=t.m04,c=t.m05,s=t.m06,l=t.m07,f=t.m08,_=t.m09,u=t.m10,m=t.m11,d=t.m12,p=t.m13,h=t.m14,v=t.m15,g=n*c-i*r,x=n*s-o*r,y=n*l-a*r,C=i*s-o*c,S=i*l-a*c,E=o*l-a*s,P=f*p-_*d,I=f*h-u*d,T=f*v-m*d,b=_*h-u*p,A=_*v-m*p,w=u*v-m*h,N=g*w-x*A+y*b+C*T-S*I+E*P;return 0===N?(e.m00=0,e.m01=0,e.m02=0,e.m03=0,e.m04=0,e.m05=0,e.m06=0,e.m07=0,e.m08=0,e.m09=0,e.m10=0,e.m11=0,e.m12=0,e.m13=0,e.m14=0,e.m15=0,e):(N=1/N,e.m00=(c*w-s*A+l*b)*N,e.m01=(o*A-i*w-a*b)*N,e.m02=(p*E-h*S+v*C)*N,e.m03=(u*S-_*E-m*C)*N,e.m04=(s*T-r*w-l*I)*N,e.m05=(n*w-o*T+a*I)*N,e.m06=(h*y-d*E-v*x)*N,e.m07=(f*E-u*y+m*x)*N,e.m08=(r*A-c*T+l*P)*N,e.m09=(i*T-n*A-a*P)*N,e.m10=(d*S-p*y+v*g)*N,e.m11=(_*y-f*S-m*g)*N,e.m12=(c*I-r*b-s*P)*N,e.m13=(n*b-i*I+o*P)*N,e.m14=(p*x-d*C-h*g)*N,e.m15=(f*C-_*x+u*g)*N,e)},t.determinant=function(e){var t=e.m00,n=e.m01,i=e.m02,o=e.m03,a=e.m04,r=e.m05,c=e.m06,s=e.m07,l=e.m08,f=e.m09,_=e.m10,u=e.m11,m=e.m12,d=e.m13,p=e.m14,h=e.m15;return(t*r-n*a)*(_*h-u*p)-(t*c-i*a)*(f*h-u*d)+(t*s-o*a)*(f*p-_*d)+(n*c-i*r)*(l*h-u*m)-(n*s-o*r)*(l*p-_*m)+(i*s-o*c)*(l*d-f*m)},t.multiply=function(e,t,n){var i=t.m00,o=t.m01,a=t.m02,r=t.m03,c=t.m04,s=t.m05,l=t.m06,f=t.m07,_=t.m08,u=t.m09,m=t.m10,d=t.m11,p=t.m12,h=t.m13,v=t.m14,g=t.m15,x=n.m00,y=n.m01,C=n.m02,S=n.m03;return e.m00=x*i+y*c+C*_+S*p,e.m01=x*o+y*s+C*u+S*h,e.m02=x*a+y*l+C*m+S*v,e.m03=x*r+y*f+C*d+S*g,x=n.m04,y=n.m05,C=n.m06,S=n.m07,e.m04=x*i+y*c+C*_+S*p,e.m05=x*o+y*s+C*u+S*h,e.m06=x*a+y*l+C*m+S*v,e.m07=x*r+y*f+C*d+S*g,x=n.m08,y=n.m09,C=n.m10,S=n.m11,e.m08=x*i+y*c+C*_+S*p,e.m09=x*o+y*s+C*u+S*h,e.m10=x*a+y*l+C*m+S*v,e.m11=x*r+y*f+C*d+S*g,x=n.m12,y=n.m13,C=n.m14,S=n.m15,e.m12=x*i+y*c+C*_+S*p,e.m13=x*o+y*s+C*u+S*h,e.m14=x*a+y*l+C*m+S*v,e.m15=x*r+y*f+C*d+S*g,e},t.transform=function(e,t,n){var i=n.x,o=n.y,a=n.z;if(t===e)e.m12=t.m00*i+t.m04*o+t.m08*a+t.m12,e.m13=t.m01*i+t.m05*o+t.m09*a+t.m13,e.m14=t.m02*i+t.m06*o+t.m10*a+t.m14,e.m15=t.m03*i+t.m07*o+t.m11*a+t.m15;else{var r=t.m00,c=t.m01,s=t.m02,l=t.m03,f=t.m04,_=t.m05,u=t.m06,m=t.m07,d=t.m08,p=t.m09,h=t.m10,v=t.m11;t.m12,t.m13,t.m14,t.m15,e.m00=r,e.m01=c,e.m02=s,e.m03=l,e.m04=f,e.m05=_,e.m06=u,e.m07=m,e.m08=d,e.m09=p,e.m10=h,e.m11=v,e.m12=r*i+f*o+d*a+t.m12,e.m13=c*i+_*o+p*a+t.m13,e.m14=s*i+u*o+h*a+t.m14,e.m15=l*i+m*o+v*a+t.m15}return e},t.translate=function(e,t,n){return console.warn("function changed"),t===e?(e.m12+=n.x,e.m13+=n.y,e.m14+=n.z):(e.m00=t.m00,e.m01=t.m01,e.m02=t.m02,e.m03=t.m03,e.m04=t.m04,e.m05=t.m05,e.m06=t.m06,e.m07=t.m07,e.m08=t.m08,e.m09=t.m09,e.m10=t.m10,e.m11=t.m11,e.m12+=n.x,e.m13+=n.y,e.m14+=n.z,e.m15=t.m15),e},t.scale=function(e,t,n){var i=n.x,o=n.y,a=n.z;return e.m00=t.m00*i,e.m01=t.m01*i,e.m02=t.m02*i,e.m03=t.m03*i,e.m04=t.m04*o,e.m05=t.m05*o,e.m06=t.m06*o,e.m07=t.m07*o,e.m08=t.m08*a,e.m09=t.m09*a,e.m10=t.m10*a,e.m11=t.m11*a,e.m12=t.m12,e.m13=t.m13,e.m14=t.m14,e.m15=t.m15,e},t.rotate=function(e,t,n,i){var o=i.x,a=i.y,r=i.z,c=Math.sqrt(o*o+a*a+r*r);if(Math.abs(c)<dn)return null;o*=c=1/c,a*=c,r*=c;var s=Math.sin(n),l=Math.cos(n),f=1-l,_=t.m00,u=t.m01,m=t.m02,d=t.m03,p=t.m04,h=t.m05,v=t.m06,g=t.m07,x=t.m08,y=t.m09,C=t.m10,S=t.m11,E=o*o*f+l,P=a*o*f+r*s,I=r*o*f-a*s,T=o*a*f-r*s,b=a*a*f+l,A=r*a*f+o*s,w=o*r*f+a*s,N=a*r*f-o*s,D=r*r*f+l;return e.m00=_*E+p*P+x*I,e.m01=u*E+h*P+y*I,e.m02=m*E+v*P+C*I,e.m03=d*E+g*P+S*I,e.m04=_*T+p*b+x*A,e.m05=u*T+h*b+y*A,e.m06=m*T+v*b+C*A,e.m07=d*T+g*b+S*A,e.m08=_*w+p*N+x*D,e.m09=u*w+h*N+y*D,e.m10=m*w+v*N+C*D,e.m11=d*w+g*N+S*D,t!==e&&(e.m12=t.m12,e.m13=t.m13,e.m14=t.m14,e.m15=t.m15),e},t.rotateX=function(e,t,n){var i=Math.sin(n),o=Math.cos(n),a=t.m04,r=t.m05,c=t.m06,s=t.m07,l=t.m08,f=t.m09,_=t.m10,u=t.m11;return t!==e&&(e.m00=t.m00,e.m01=t.m01,e.m02=t.m02,e.m03=t.m03,e.m12=t.m12,e.m13=t.m13,e.m14=t.m14,e.m15=t.m15),e.m04=a*o+l*i,e.m05=r*o+f*i,e.m06=c*o+_*i,e.m07=s*o+u*i,e.m08=l*o-a*i,e.m09=f*o-r*i,e.m10=_*o-c*i,e.m11=u*o-s*i,e},t.rotateY=function(e,t,n){var i=Math.sin(n),o=Math.cos(n),a=t.m00,r=t.m01,c=t.m02,s=t.m03,l=t.m08,f=t.m09,_=t.m10,u=t.m11;return t!==e&&(e.m04=t.m04,e.m05=t.m05,e.m06=t.m06,e.m07=t.m07,e.m12=t.m12,e.m13=t.m13,e.m14=t.m14,e.m15=t.m15),e.m00=a*o-l*i,e.m01=r*o-f*i,e.m02=c*o-_*i,e.m03=s*o-u*i,e.m08=a*i+l*o,e.m09=r*i+f*o,e.m10=c*i+_*o,e.m11=s*i+u*o,e},t.rotateZ=function(e,t,n){var i=Math.sin(n),o=Math.cos(n),a=t.m00,r=t.m01,c=t.m02,s=t.m03,l=t.m04,f=t.m05,_=t.m06,u=t.m07;return t!==e&&(e.m08=t.m08,e.m09=t.m09,e.m10=t.m10,e.m11=t.m11,e.m12=t.m12,e.m13=t.m13,e.m14=t.m14,e.m15=t.m15),e.m00=a*o+l*i,e.m01=r*o+f*i,e.m02=c*o+_*i,e.m03=s*o+u*i,e.m04=l*o-a*i,e.m05=f*o-r*i,e.m06=_*o-c*i,e.m07=u*o-s*i,e},t.fromTranslation=function(e,t){return e.m00=1,e.m01=0,e.m02=0,e.m03=0,e.m04=0,e.m05=1,e.m06=0,e.m07=0,e.m08=0,e.m09=0,e.m10=1,e.m11=0,e.m12=t.x,e.m13=t.y,e.m14=t.z,e.m15=1,e},t.fromScaling=function(e,t){return e.m00=t.x,e.m01=0,e.m02=0,e.m03=0,e.m04=0,e.m05=t.y,e.m06=0,e.m07=0,e.m08=0,e.m09=0,e.m10=t.z,e.m11=0,e.m12=0,e.m13=0,e.m14=0,e.m15=1,e},t.fromRotation=function(e,t,n){var i=n.x,o=n.y,a=n.z,r=Math.sqrt(i*i+o*o+a*a);if(Math.abs(r)<dn)return null;i*=r=1/r,o*=r,a*=r;var c=Math.sin(t),s=Math.cos(t),l=1-s;return e.m00=i*i*l+s,e.m01=o*i*l+a*c,e.m02=a*i*l-o*c,e.m03=0,e.m04=i*o*l-a*c,e.m05=o*o*l+s,e.m06=a*o*l+i*c,e.m07=0,e.m08=i*a*l+o*c,e.m09=o*a*l-i*c,e.m10=a*a*l+s,e.m11=0,e.m12=0,e.m13=0,e.m14=0,e.m15=1,e},t.fromXRotation=function(e,t){var n=Math.sin(t),i=Math.cos(t);return e.m00=1,e.m01=0,e.m02=0,e.m03=0,e.m04=0,e.m05=i,e.m06=n,e.m07=0,e.m08=0,e.m09=-n,e.m10=i,e.m11=0,e.m12=0,e.m13=0,e.m14=0,e.m15=1,e},t.fromYRotation=function(e,t){var n=Math.sin(t),i=Math.cos(t);return e.m00=i,e.m01=0,e.m02=-n,e.m03=0,e.m04=0,e.m05=1,e.m06=0,e.m07=0,e.m08=n,e.m09=0,e.m10=i,e.m11=0,e.m12=0,e.m13=0,e.m14=0,e.m15=1,e},t.fromZRotation=function(e,t){var n=Math.sin(t),i=Math.cos(t);return e.m00=i,e.m01=n,e.m02=0,e.m03=0,e.m04=-n,e.m05=i,e.m06=0,e.m07=0,e.m08=0,e.m09=0,e.m10=1,e.m11=0,e.m12=0,e.m13=0,e.m14=0,e.m15=1,e},t.fromRT=function(e,t,n){var i=t.x,o=t.y,a=t.z,r=t.w,c=i+i,s=o+o,l=a+a,f=i*c,_=i*s,u=i*l,m=o*s,d=o*l,p=a*l,h=r*c,v=r*s,g=r*l;return e.m00=1-(m+p),e.m01=_+g,e.m02=u-v,e.m03=0,e.m04=_-g,e.m05=1-(f+p),e.m06=d+h,e.m07=0,e.m08=u+v,e.m09=d-h,e.m10=1-(f+m),e.m11=0,e.m12=n.x,e.m13=n.y,e.m14=n.z,e.m15=1,e},t.getTranslation=function(e,t){return e.x=t.m12,e.y=t.m13,e.z=t.m14,e},t.getScaling=function(e,t){var n=Wn.m00=t.m00,i=Wn.m01=t.m01,o=Wn.m02=t.m02,a=Wn.m03=t.m04,r=Wn.m04=t.m05,c=Wn.m05=t.m06,s=Wn.m06=t.m08,l=Wn.m07=t.m09,f=Wn.m08=t.m10;return e.x=Math.sqrt(n*n+i*i+o*o),e.y=Math.sqrt(a*a+r*r+c*c),e.z=Math.sqrt(s*s+l*l+f*f),Mn.determinant(Wn)<0&&(e.x*=-1),e},t.getRotation=function(e,t){var n=t.m00+t.m05+t.m10,i=0;return n>0?(i=2*Math.sqrt(n+1),e.w=.25*i,e.x=(t.m06-t.m09)/i,e.y=(t.m08-t.m02)/i,e.z=(t.m01-t.m04)/i):t.m00>t.m05&&t.m00>t.m10?(i=2*Math.sqrt(1+t.m00-t.m05-t.m10),e.w=(t.m06-t.m09)/i,e.x=.25*i,e.y=(t.m01+t.m04)/i,e.z=(t.m08+t.m02)/i):t.m05>t.m10?(i=2*Math.sqrt(1+t.m05-t.m00-t.m10),e.w=(t.m08-t.m02)/i,e.x=(t.m01+t.m04)/i,e.y=.25*i,e.z=(t.m06+t.m09)/i):(i=2*Math.sqrt(1+t.m10-t.m00-t.m05),e.w=(t.m01-t.m04)/i,e.x=(t.m08+t.m02)/i,e.y=(t.m06+t.m09)/i,e.z=.25*i),e},t.toRTS=function(e,t,n,i){i.x=wn.set(qn,e.m00,e.m01,e.m02).length(),Wn.m00=e.m00/i.x,Wn.m01=e.m01/i.x,Wn.m02=e.m02/i.x,i.y=wn.set(qn,e.m04,e.m05,e.m06).length(),Wn.m03=e.m04/i.y,Wn.m04=e.m05/i.y,Wn.m05=e.m06/i.y,i.z=wn.set(qn,e.m08,e.m09,e.m10).length(),Wn.m06=e.m08/i.z,Wn.m07=e.m09/i.z,Wn.m08=e.m10/i.z,Mn.determinant(Wn)<0&&(i.x*=-1,Wn.m00*=-1,Wn.m01*=-1,Wn.m02*=-1),zn.fromMat3(t,Wn),wn.set(n,e.m12,e.m13,e.m14)},t.fromRTS=function(e,t,n,i){var o=t.x,a=t.y,r=t.z,c=t.w,s=o+o,l=a+a,f=r+r,_=o*s,u=o*l,m=o*f,d=a*l,p=a*f,h=r*f,v=c*s,g=c*l,x=c*f,y=i.x,C=i.y,S=i.z;return e.m00=(1-(d+h))*y,e.m01=(u+x)*y,e.m02=(m-g)*y,e.m03=0,e.m04=(u-x)*C,e.m05=(1-(_+h))*C,e.m06=(p+v)*C,e.m07=0,e.m08=(m+g)*S,e.m09=(p-v)*S,e.m10=(1-(_+d))*S,e.m11=0,e.m12=n.x,e.m13=n.y,e.m14=n.z,e.m15=1,e},t.fromRTSOrigin=function(e,t,n,i,o){var a=t.x,r=t.y,c=t.z,s=t.w,l=a+a,f=r+r,_=c+c,u=a*l,m=a*f,d=a*_,p=r*f,h=r*_,v=c*_,g=s*l,x=s*f,y=s*_,C=i.x,S=i.y,E=i.z,P=o.x,I=o.y,T=o.z;return e.m00=(1-(p+v))*C,e.m01=(m+y)*C,e.m02=(d-x)*C,e.m03=0,e.m04=(m-y)*S,e.m05=(1-(u+v))*S,e.m06=(h+g)*S,e.m07=0,e.m08=(d+x)*E,e.m09=(h-g)*E,e.m10=(1-(u+p))*E,e.m11=0,e.m12=n.x+P-(e.m00*P+e.m04*I+e.m08*T),e.m13=n.y+I-(e.m01*P+e.m05*I+e.m09*T),e.m14=n.z+T-(e.m02*P+e.m06*I+e.m10*T),e.m15=1,e},t.fromQuat=function(e,t){var n=t.x,i=t.y,o=t.z,a=t.w,r=n+n,c=i+i,s=o+o,l=n*r,f=i*r,_=i*c,u=o*r,m=o*c,d=o*s,p=a*r,h=a*c,v=a*s;return e.m00=1-_-d,e.m01=f+v,e.m02=u-h,e.m03=0,e.m04=f-v,e.m05=1-l-d,e.m06=m+p,e.m07=0,e.m08=u+h,e.m09=m-p,e.m10=1-l-_,e.m11=0,e.m12=0,e.m13=0,e.m14=0,e.m15=1,e},t.frustum=function(e,t,n,i,o,a,r){var c=1/(n-t),s=1/(o-i),l=1/(a-r);return e.m00=2*a*c,e.m01=0,e.m02=0,e.m03=0,e.m04=0,e.m05=2*a*s,e.m06=0,e.m07=0,e.m08=(n+t)*c,e.m09=(o+i)*s,e.m10=(r+a)*l,e.m11=-1,e.m12=0,e.m13=0,e.m14=r*a*2*l,e.m15=0,e},t.perspective=function(e,t,n,i,o,a,r,c,s){void 0===a&&(a=!0),void 0===r&&(r=-1),void 0===c&&(c=1),void 0===s&&(s=0);var l=1/Math.tan(t/2),f=1/(i-o),_=a?l/n:l,u=(a?l:l*n)*c,m=kn[s];return e.m00=_*m[0],e.m01=_*m[1],e.m02=0,e.m03=0,e.m04=u*m[2],e.m05=u*m[3],e.m06=0,e.m07=0,e.m08=0,e.m09=0,e.m10=(o-r*i)*f,e.m11=-1,e.m12=0,e.m13=0,e.m14=o*i*f*(1-r),e.m15=0,e},t.ortho=function(e,t,n,i,o,a,r,c,s,l){void 0===c&&(c=-1),void 0===s&&(s=1),void 0===l&&(l=0);var f=1/(t-n),_=1/(i-o)*s,u=1/(a-r),m=-2*f,d=-2*_,p=(t+n)*f,h=(o+i)*_,v=kn[l];return e.m00=m*v[0],e.m01=m*v[1],e.m02=0,e.m03=0,e.m04=d*v[2],e.m05=d*v[3],e.m06=0,e.m07=0,e.m08=0,e.m09=0,e.m10=u*(1-c),e.m11=0,e.m12=p*v[0]+h*v[2],e.m13=p*v[1]+h*v[3],e.m14=(a-c*r)*u,e.m15=1,e},t.lookAt=function(e,t,n,i){var o=t.x,a=t.y,r=t.z,c=i.x,s=i.y,l=i.z,f=o-n.x,_=a-n.y,u=r-n.z,m=1/Math.sqrt(f*f+_*_+u*u),d=s*(u*=m)-l*(_*=m),p=l*(f*=m)-c*u,h=c*_-s*f,v=_*(h*=m=1/Math.sqrt(d*d+p*p+h*h))-u*(p*=m),g=u*(d*=m)-f*h,x=f*p-_*d;return e.m00=d,e.m01=v,e.m02=f,e.m03=0,e.m04=p,e.m05=g,e.m06=_,e.m07=0,e.m08=h,e.m09=x,e.m10=u,e.m11=0,e.m12=-(d*o+p*a+h*r),e.m13=-(v*o+g*a+x*r),e.m14=-(f*o+_*a+u*r),e.m15=1,e},t.inverseTranspose=function(e,t){var n=t.m00,i=t.m01,o=t.m02,a=t.m03,r=t.m04,c=t.m05,s=t.m06,l=t.m07,f=t.m08,_=t.m09,u=t.m10,m=t.m11,d=t.m12,p=t.m13,h=t.m14,v=t.m15,g=n*c-i*r,x=n*s-o*r,y=n*l-a*r,C=i*s-o*c,S=i*l-a*c,E=o*l-a*s,P=f*p-_*d,I=f*h-u*d,T=f*v-m*d,b=_*h-u*p,A=_*v-m*p,w=u*v-m*h,N=g*w-x*A+y*b+C*T-S*I+E*P;return N?(N=1/N,e.m00=(c*w-s*A+l*b)*N,e.m01=(s*T-r*w-l*I)*N,e.m02=(r*A-c*T+l*P)*N,e.m03=0,e.m04=(o*A-i*w-a*b)*N,e.m05=(n*w-o*T+a*I)*N,e.m06=(i*T-n*A-a*P)*N,e.m07=0,e.m08=(p*E-h*S+v*C)*N,e.m09=(h*y-d*E-v*x)*N,e.m10=(d*S-p*y+v*g)*N,e.m11=0,e.m12=0,e.m13=0,e.m14=0,e.m15=1,e):null},t.toArray=function(e,t,n){return void 0===n&&(n=0),e[n+0]=t.m00,e[n+1]=t.m01,e[n+2]=t.m02,e[n+3]=t.m03,e[n+4]=t.m04,e[n+5]=t.m05,e[n+6]=t.m06,e[n+7]=t.m07,e[n+8]=t.m08,e[n+9]=t.m09,e[n+10]=t.m10,e[n+11]=t.m11,e[n+12]=t.m12,e[n+13]=t.m13,e[n+14]=t.m14,e[n+15]=t.m15,e},t.fromArray=function(e,t,n){return void 0===n&&(n=0),e.m00=t[n+0],e.m01=t[n+1],e.m02=t[n+2],e.m03=t[n+3],e.m04=t[n+4],e.m05=t[n+5],e.m06=t[n+6],e.m07=t[n+7],e.m08=t[n+8],e.m09=t[n+9],e.m10=t[n+10],e.m11=t[n+11],e.m12=t[n+12],e.m13=t[n+13],e.m14=t[n+14],e.m15=t[n+15],e},t.add=function(e,t,n){return e.m00=t.m00+n.m00,e.m01=t.m01+n.m01,e.m02=t.m02+n.m02,e.m03=t.m03+n.m03,e.m04=t.m04+n.m04,e.m05=t.m05+n.m05,e.m06=t.m06+n.m06,e.m07=t.m07+n.m07,e.m08=t.m08+n.m08,e.m09=t.m09+n.m09,e.m10=t.m10+n.m10,e.m11=t.m11+n.m11,e.m12=t.m12+n.m12,e.m13=t.m13+n.m13,e.m14=t.m14+n.m14,e.m15=t.m15+n.m15,e},t.subtract=function(e,t,n){return e.m00=t.m00-n.m00,e.m01=t.m01-n.m01,e.m02=t.m02-n.m02,e.m03=t.m03-n.m03,e.m04=t.m04-n.m04,e.m05=t.m05-n.m05,e.m06=t.m06-n.m06,e.m07=t.m07-n.m07,e.m08=t.m08-n.m08,e.m09=t.m09-n.m09,e.m10=t.m10-n.m10,e.m11=t.m11-n.m11,e.m12=t.m12-n.m12,e.m13=t.m13-n.m13,e.m14=t.m14-n.m14,e.m15=t.m15-n.m15,e},t.multiplyScalar=function(e,t,n){return e.m00=t.m00*n,e.m01=t.m01*n,e.m02=t.m02*n,e.m03=t.m03*n,e.m04=t.m04*n,e.m05=t.m05*n,e.m06=t.m06*n,e.m07=t.m07*n,e.m08=t.m08*n,e.m09=t.m09*n,e.m10=t.m10*n,e.m11=t.m11*n,e.m12=t.m12*n,e.m13=t.m13*n,e.m14=t.m14*n,e.m15=t.m15*n,e},t.multiplyScalarAndAdd=function(e,t,n,i){return e.m00=t.m00+n.m00*i,e.m01=t.m01+n.m01*i,e.m02=t.m02+n.m02*i,e.m03=t.m03+n.m03*i,e.m04=t.m04+n.m04*i,e.m05=t.m05+n.m05*i,e.m06=t.m06+n.m06*i,e.m07=t.m07+n.m07*i,e.m08=t.m08+n.m08*i,e.m09=t.m09+n.m09*i,e.m10=t.m10+n.m10*i,e.m11=t.m11+n.m11*i,e.m12=t.m12+n.m12*i,e.m13=t.m13+n.m13*i,e.m14=t.m14+n.m14*i,e.m15=t.m15+n.m15*i,e},t.strictEquals=function(e,t){return e.m00===t.m00&&e.m01===t.m01&&e.m02===t.m02&&e.m03===t.m03&&e.m04===t.m04&&e.m05===t.m05&&e.m06===t.m06&&e.m07===t.m07&&e.m08===t.m08&&e.m09===t.m09&&e.m10===t.m10&&e.m11===t.m11&&e.m12===t.m12&&e.m13===t.m13&&e.m14===t.m14&&e.m15===t.m15},t.equals=function(e,t,n){return void 0===n&&(n=dn),Math.abs(e.m00-t.m00)<=n*Math.max(1,Math.abs(e.m00),Math.abs(t.m00))&&Math.abs(e.m01-t.m01)<=n*Math.max(1,Math.abs(e.m01),Math.abs(t.m01))&&Math.abs(e.m02-t.m02)<=n*Math.max(1,Math.abs(e.m02),Math.abs(t.m02))&&Math.abs(e.m03-t.m03)<=n*Math.max(1,Math.abs(e.m03),Math.abs(t.m03))&&Math.abs(e.m04-t.m04)<=n*Math.max(1,Math.abs(e.m04),Math.abs(t.m04))&&Math.abs(e.m05-t.m05)<=n*Math.max(1,Math.abs(e.m05),Math.abs(t.m05))&&Math.abs(e.m06-t.m06)<=n*Math.max(1,Math.abs(e.m06),Math.abs(t.m06))&&Math.abs(e.m07-t.m07)<=n*Math.max(1,Math.abs(e.m07),Math.abs(t.m07))&&Math.abs(e.m08-t.m08)<=n*Math.max(1,Math.abs(e.m08),Math.abs(t.m08))&&Math.abs(e.m09-t.m09)<=n*Math.max(1,Math.abs(e.m09),Math.abs(t.m09))&&Math.abs(e.m10-t.m10)<=n*Math.max(1,Math.abs(e.m10),Math.abs(t.m10))&&Math.abs(e.m11-t.m11)<=n*Math.max(1,Math.abs(e.m11),Math.abs(t.m11))&&Math.abs(e.m12-t.m12)<=n*Math.max(1,Math.abs(e.m12),Math.abs(t.m12))&&Math.abs(e.m13-t.m13)<=n*Math.max(1,Math.abs(e.m13),Math.abs(t.m13))&&Math.abs(e.m14-t.m14)<=n*Math.max(1,Math.abs(e.m14),Math.abs(t.m14))&&Math.abs(e.m15-t.m15)<=n*Math.max(1,Math.abs(e.m15),Math.abs(t.m15))};var n=t.prototype;return n.clone=function(){return new t(this.m00,this.m01,this.m02,this.m03,this.m04,this.m05,this.m06,this.m07,this.m08,this.m09,this.m10,this.m11,this.m12,this.m13,this.m14,this.m15)},n.set=function(e,t,n,i,o,a,r,c,s,l,f,_,u,m,d,p){return void 0===e&&(e=1),void 0===t&&(t=0),void 0===n&&(n=0),void 0===i&&(i=0),void 0===o&&(o=0),void 0===a&&(a=1),void 0===r&&(r=0),void 0===c&&(c=0),void 0===s&&(s=0),void 0===l&&(l=0),void 0===f&&(f=1),void 0===_&&(_=0),void 0===u&&(u=0),void 0===m&&(m=0),void 0===d&&(d=0),void 0===p&&(p=1),"object"==typeof e?(this.m01=e.m01,this.m02=e.m02,this.m03=e.m03,this.m04=e.m04,this.m05=e.m05,this.m06=e.m06,this.m07=e.m07,this.m08=e.m08,this.m09=e.m09,this.m10=e.m10,this.m11=e.m11,this.m12=e.m12,this.m13=e.m13,this.m14=e.m14,this.m15=e.m15,this.m00=e.m00):(this.m01=t,this.m02=n,this.m03=i,this.m04=o,this.m05=a,this.m06=r,this.m07=c,this.m08=s,this.m09=l,this.m10=f,this.m11=_,this.m12=u,this.m13=m,this.m14=d,this.m15=p,this.m00=e),this},n.equals=function(e,t){return void 0===t&&(t=dn),Math.abs(this.m00-e.m00)<=t*Math.max(1,Math.abs(this.m00),Math.abs(e.m00))&&Math.abs(this.m01-e.m01)<=t*Math.max(1,Math.abs(this.m01),Math.abs(e.m01))&&Math.abs(this.m02-e.m02)<=t*Math.max(1,Math.abs(this.m02),Math.abs(e.m02))&&Math.abs(this.m03-e.m03)<=t*Math.max(1,Math.abs(this.m03),Math.abs(e.m03))&&Math.abs(this.m04-e.m04)<=t*Math.max(1,Math.abs(this.m04),Math.abs(e.m04))&&Math.abs(this.m05-e.m05)<=t*Math.max(1,Math.abs(this.m05),Math.abs(e.m05))&&Math.abs(this.m06-e.m06)<=t*Math.max(1,Math.abs(this.m06),Math.abs(e.m06))&&Math.abs(this.m07-e.m07)<=t*Math.max(1,Math.abs(this.m07),Math.abs(e.m07))&&Math.abs(this.m08-e.m08)<=t*Math.max(1,Math.abs(this.m08),Math.abs(e.m08))&&Math.abs(this.m09-e.m09)<=t*Math.max(1,Math.abs(this.m09),Math.abs(e.m09))&&Math.abs(this.m10-e.m10)<=t*Math.max(1,Math.abs(this.m10),Math.abs(e.m10))&&Math.abs(this.m11-e.m11)<=t*Math.max(1,Math.abs(this.m11),Math.abs(e.m11))&&Math.abs(this.m12-e.m12)<=t*Math.max(1,Math.abs(this.m12),Math.abs(e.m12))&&Math.abs(this.m13-e.m13)<=t*Math.max(1,Math.abs(this.m13),Math.abs(e.m13))&&Math.abs(this.m14-e.m14)<=t*Math.max(1,Math.abs(this.m14),Math.abs(e.m14))&&Math.abs(this.m15-e.m15)<=t*Math.max(1,Math.abs(this.m15),Math.abs(e.m15))},n.strictEquals=function(e){return this.m00===e.m00&&this.m01===e.m01&&this.m02===e.m02&&this.m03===e.m03&&this.m04===e.m04&&this.m05===e.m05&&this.m06===e.m06&&this.m07===e.m07&&this.m08===e.m08&&this.m09===e.m09&&this.m10===e.m10&&this.m11===e.m11&&this.m12===e.m12&&this.m13===e.m13&&this.m14===e.m14&&this.m15===e.m15},n.toString=function(){return"[\n"+this.m00+", "+this.m01+", "+this.m02+", "+this.m03+",\n"+this.m04+", "+this.m05+", "+this.m06+", "+this.m07+",\n"+this.m08+", "+this.m09+", "+this.m10+", "+this.m11+",\n"+this.m12+", "+this.m13+", "+this.m14+", "+this.m15+"\n]"},n.identity=function(){return this.m00=1,this.m01=0,this.m02=0,this.m03=0,this.m04=0,this.m05=1,this.m06=0,this.m07=0,this.m08=0,this.m09=0,this.m10=1,this.m11=0,this.m12=0,this.m13=0,this.m14=0,this.m15=1,this},n.zero=function(){return this.m00=0,this.m01=0,this.m02=0,this.m03=0,this.m04=0,this.m05=0,this.m06=0,this.m07=0,this.m08=0,this.m09=0,this.m10=0,this.m11=0,this.m12=0,this.m13=0,this.m14=0,this.m15=0,this},n.transpose=function(){var e=this.m01,t=this.m02,n=this.m03,i=this.m06,o=this.m07,a=this.m11;return this.m01=this.m04,this.m02=this.m08,this.m03=this.m12,this.m04=e,this.m06=this.m09,this.m07=this.m13,this.m08=t,this.m09=i,this.m11=this.m14,this.m12=n,this.m13=o,this.m14=a,this},n.invert=function(){var e=this.m00,t=this.m01,n=this.m02,i=this.m03,o=this.m04,a=this.m05,r=this.m06,c=this.m07,s=this.m08,l=this.m09,f=this.m10,_=this.m11,u=this.m12,m=this.m13,d=this.m14,p=this.m15,h=e*a-t*o,v=e*r-n*o,g=e*c-i*o,x=t*r-n*a,y=t*c-i*a,C=n*c-i*r,S=s*m-l*u,E=s*d-f*u,P=s*p-_*u,I=l*d-f*m,T=l*p-_*m,b=f*p-_*d,A=h*b-v*T+g*I+x*P-y*E+C*S;return 0===A?(this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),this):(A=1/A,this.m00=(a*b-r*T+c*I)*A,this.m01=(n*T-t*b-i*I)*A,this.m02=(m*C-d*y+p*x)*A,this.m03=(f*y-l*C-_*x)*A,this.m04=(r*P-o*b-c*E)*A,this.m05=(e*b-n*P+i*E)*A,this.m06=(d*g-u*C-p*v)*A,this.m07=(s*C-f*g+_*v)*A,this.m08=(o*T-a*P+c*S)*A,this.m09=(t*P-e*T-i*S)*A,this.m10=(u*y-m*g+p*h)*A,this.m11=(l*g-s*y-_*h)*A,this.m12=(a*E-o*I-r*S)*A,this.m13=(e*I-t*E+n*S)*A,this.m14=(m*v-u*x-d*h)*A,this.m15=(s*x-l*v+f*h)*A,this)},n.determinant=function(){var e=this.m00,t=this.m01,n=this.m02,i=this.m03,o=this.m04,a=this.m05,r=this.m06,c=this.m07,s=this.m08,l=this.m09,f=this.m10,_=this.m11,u=this.m12,m=this.m13,d=this.m14,p=this.m15;return(e*a-t*o)*(f*p-_*d)-(e*r-n*o)*(l*p-_*m)+(e*c-i*o)*(l*d-f*m)+(t*r-n*a)*(s*p-_*u)-(t*c-i*a)*(s*d-f*u)+(n*c-i*r)*(s*m-l*u)},n.add=function(e){return this.m00+=e.m00,this.m01+=e.m01,this.m02+=e.m02,this.m03+=e.m03,this.m04+=e.m04,this.m05+=e.m05,this.m06+=e.m06,this.m07+=e.m07,this.m08+=e.m08,this.m09+=e.m09,this.m10+=e.m10,this.m11+=e.m11,this.m12+=e.m12,this.m13+=e.m13,this.m14+=e.m14,this.m15+=e.m15,this},n.subtract=function(e){return this.m00-=e.m00,this.m01-=e.m01,this.m02-=e.m02,this.m03-=e.m03,this.m04-=e.m04,this.m05-=e.m05,this.m06-=e.m06,this.m07-=e.m07,this.m08-=e.m08,this.m09-=e.m09,this.m10-=e.m10,this.m11-=e.m11,this.m12-=e.m12,this.m13-=e.m13,this.m14-=e.m14,this.m15-=e.m15,this},n.multiply=function(e){var t=this.m00,n=this.m01,i=this.m02,o=this.m03,a=this.m04,r=this.m05,c=this.m06,s=this.m07,l=this.m08,f=this.m09,_=this.m10,u=this.m11,m=this.m12,d=this.m13,p=this.m14,h=this.m15,v=e.m00,g=e.m01,x=e.m02,y=e.m03;return this.m00=v*t+g*a+x*l+y*m,this.m01=v*n+g*r+x*f+y*d,this.m02=v*i+g*c+x*_+y*p,this.m03=v*o+g*s+x*u+y*h,v=e.m04,g=e.m05,x=e.m06,y=e.m07,this.m04=v*t+g*a+x*l+y*m,this.m05=v*n+g*r+x*f+y*d,this.m06=v*i+g*c+x*_+y*p,this.m07=v*o+g*s+x*u+y*h,v=e.m08,g=e.m09,x=e.m10,y=e.m11,this.m08=v*t+g*a+x*l+y*m,this.m09=v*n+g*r+x*f+y*d,this.m10=v*i+g*c+x*_+y*p,this.m11=v*o+g*s+x*u+y*h,v=e.m12,g=e.m13,x=e.m14,y=e.m15,this.m12=v*t+g*a+x*l+y*m,this.m13=v*n+g*r+x*f+y*d,this.m14=v*i+g*c+x*_+y*p,this.m15=v*o+g*s+x*u+y*h,this},n.multiplyScalar=function(e){return this.m00*=e,this.m01*=e,this.m02*=e,this.m03*=e,this.m04*=e,this.m05*=e,this.m06*=e,this.m07*=e,this.m08*=e,this.m09*=e,this.m10*=e,this.m11*=e,this.m12*=e,this.m13*=e,this.m14*=e,this.m15*=e,this},n.translate=function(e){return console.warn("function changed"),this.m12+=e.x,this.m13+=e.y,this.m14+=e.z,this},n.scale=function(e){var t=e.x,n=e.y,i=e.z;return this.m00*=t,this.m01*=t,this.m02*=t,this.m03*=t,this.m04*=n,this.m05*=n,this.m06*=n,this.m07*=n,this.m08*=i,this.m09*=i,this.m10*=i,this.m11*=i,this},n.rotate=function(e,t){var n=t.x,i=t.y,o=t.z,a=Math.sqrt(n*n+i*i+o*o);if(Math.abs(a)<dn)return null;n*=a=1/a,i*=a,o*=a;var r=Math.sin(e),c=Math.cos(e),s=1-c,l=this.m00,f=this.m01,_=this.m02,u=this.m03,m=this.m04,d=this.m05,p=this.m06,h=this.m07,v=this.m08,g=this.m09,x=this.m10,y=this.m11,C=n*n*s+c,S=i*n*s+o*r,E=o*n*s-i*r,P=n*i*s-o*r,I=i*i*s+c,T=o*i*s+n*r,b=n*o*s+i*r,A=i*o*s-n*r,w=o*o*s+c;return this.m00=l*C+m*S+v*E,this.m01=f*C+d*S+g*E,this.m02=_*C+p*S+x*E,this.m03=u*C+h*S+y*E,this.m04=l*P+m*I+v*T,this.m05=f*P+d*I+g*T,this.m06=_*P+p*I+x*T,this.m07=u*P+h*I+y*T,this.m08=l*b+m*A+v*w,this.m09=f*b+d*A+g*w,this.m10=_*b+p*A+x*w,this.m11=u*b+h*A+y*w,this},n.getTranslation=function(e){return e.x=this.m12,e.y=this.m13,e.z=this.m14,e},n.getScale=function(e){var t=Wn.m00=this.m00,n=Wn.m01=this.m01,i=Wn.m02=this.m02,o=Wn.m03=this.m04,a=Wn.m04=this.m05,r=Wn.m05=this.m06,c=Wn.m06=this.m08,s=Wn.m07=this.m09,l=Wn.m08=this.m10;return e.x=Math.sqrt(t*t+n*n+i*i),e.y=Math.sqrt(o*o+a*a+r*r),e.z=Math.sqrt(c*c+s*s+l*l),Mn.determinant(Wn)<0&&(e.x*=-1),e},n.getRotation=function(e){var t=this.m00+this.m05+this.m10,n=0;return t>0?(n=2*Math.sqrt(t+1),e.w=.25*n,e.x=(this.m06-this.m09)/n,e.y=(this.m08-this.m02)/n,e.z=(this.m01-this.m04)/n):this.m00>this.m05&&this.m00>this.m10?(n=2*Math.sqrt(1+this.m00-this.m05-this.m10),e.w=(this.m06-this.m09)/n,e.x=.25*n,e.y=(this.m01+this.m04)/n,e.z=(this.m08+this.m02)/n):this.m05>this.m10?(n=2*Math.sqrt(1+this.m05-this.m00-this.m10),e.w=(this.m08-this.m02)/n,e.x=(this.m01+this.m04)/n,e.y=.25*n,e.z=(this.m06+this.m09)/n):(n=2*Math.sqrt(1+this.m10-this.m00-this.m05),e.w=(this.m01-this.m04)/n,e.x=(this.m08+this.m02)/n,e.y=(this.m06+this.m09)/n,e.z=.25*n),e},n.fromRTS=function(e,t,n){var i=e.x,o=e.y,a=e.z,r=e.w,c=i+i,s=o+o,l=a+a,f=i*c,_=i*s,u=i*l,m=o*s,d=o*l,p=a*l,h=r*c,v=r*s,g=r*l,x=n.x,y=n.y,C=n.z;return this.m00=(1-(m+p))*x,this.m01=(_+g)*x,this.m02=(u-v)*x,this.m03=0,this.m04=(_-g)*y,this.m05=(1-(f+p))*y,this.m06=(d+h)*y,this.m07=0,this.m08=(u+v)*C,this.m09=(d-h)*C,this.m10=(1-(f+m))*C,this.m11=0,this.m12=t.x,this.m13=t.y,this.m14=t.z,this.m15=1,this},n.fromQuat=function(e){var t=e.x,n=e.y,i=e.z,o=e.w,a=t+t,r=n+n,c=i+i,s=t*a,l=n*a,f=n*r,_=i*a,u=i*r,m=i*c,d=o*a,p=o*r,h=o*c;return this.m00=1-f-m,this.m01=l+h,this.m02=_-p,this.m03=0,this.m04=l-h,this.m05=1-s-m,this.m06=u+d,this.m07=0,this.m08=_+p,this.m09=u-d,this.m10=1-s-f,this.m11=0,this.m12=0,this.m13=0,this.m14=0,this.m15=1,this},t}(l));jn.IDENTITY=Object.freeze(new jn);var qn=new wn,Wn=new Mn;function Yn(e,t,n,i,o,a,r,c,s,l,f,_,u,m,d,p){return new jn(e,t,n,i,o,a,r,c,s,l,f,_,u,m,d,p)}c.fastDefine("cc.Mat4",jn,{m00:1,m01:0,m02:0,m03:0,m04:0,m05:1,m06:0,m07:0,m08:0,m09:0,m10:1,m11:0,m12:0,m13:0,m14:0,m15:1}),s.Mat4=jn,s.mat4=Yn;var Xn=e("V",function(e){function t(t,n){var i;return i=e.call(this)||this,t&&"object"==typeof t?(i.x=t.x,i.y=t.y):(i.x=t||0,i.y=n||0),i}a(t,e),t.clone=function(e){return new t(e.x,e.y)},t.copy=function(e,t){return e.x=t.x,e.y=t.y,e},t.set=function(e,t,n){return e.x=t,e.y=n,e},t.add=function(e,t,n){return e.x=t.x+n.x,e.y=t.y+n.y,e},t.subtract=function(e,t,n){return e.x=t.x-n.x,e.y=t.y-n.y,e},t.multiply=function(e,t,n){return e.x=t.x*n.x,e.y=t.y*n.y,e},t.divide=function(e,t,n){return e.x=t.x/n.x,e.y=t.y/n.y,e},t.ceil=function(e,t){return e.x=Math.ceil(t.x),e.y=Math.ceil(t.y),e},t.floor=function(e,t){return e.x=Math.floor(t.x),e.y=Math.floor(t.y),e},t.min=function(e,t,n){return e.x=Math.min(t.x,n.x),e.y=Math.min(t.y,n.y),e},t.max=function(e,t,n){return e.x=Math.max(t.x,n.x),e.y=Math.max(t.y,n.y),e},t.round=function(e,t){return e.x=Math.round(t.x),e.y=Math.round(t.y),e},t.multiplyScalar=function(e,t,n){return e.x=t.x*n,e.y=t.y*n,e},t.scaleAndAdd=function(e,t,n,i){return e.x=t.x+n.x*i,e.y=t.y+n.y*i,e},t.distance=function(e,t){var n=t.x-e.x,i=t.y-e.y;return Math.sqrt(n*n+i*i)},t.squaredDistance=function(e,t){var n=t.x-e.x,i=t.y-e.y;return n*n+i*i},t.len=function(e){var t=e.x,n=e.y;return Math.sqrt(t*t+n*n)},t.lengthSqr=function(e){var t=e.x,n=e.y;return t*t+n*n},t.negate=function(e,t){return e.x=-t.x,e.y=-t.y,e},t.inverse=function(e,t){return e.x=1/t.x,e.y=1/t.y,e},t.inverseSafe=function(e,t){var n=t.x,i=t.y;return Math.abs(n)<dn?e.x=0:e.x=1/n,Math.abs(i)<dn?e.y=0:e.y=1/i,e},t.normalize=function(e,t){var n=t.x,i=t.y,o=n*n+i*i;return o>0&&(o=1/Math.sqrt(o),e.x=n*o,e.y=i*o),e},t.dot=function(e,t){return e.x*t.x+e.y*t.y},t.cross=function(e,t,n){return e instanceof wn?(e.x=e.y=0,e.z=t.x*n.y-t.y*n.x,e):e.x*t.y-e.y*t.x},t.lerp=function(e,t,n,i){var o=t.x,a=t.y;return e.x=o+i*(n.x-o),e.y=a+i*(n.y-a),e},t.random=function(e,t){t=t||1;var n=2*xn()*Math.PI;return e.x=Math.cos(n)*t,e.y=Math.sin(n)*t,e},t.transformMat3=function(e,t,n){var i=t.x,o=t.y;return e.x=n.m00*i+n.m03*o+n.m06,e.y=n.m01*i+n.m04*o+n.m07,e},t.transformMat4=function(e,t,n){var i=t.x,o=t.y;return e.x=n.m00*i+n.m04*o+n.m12,e.y=n.m01*i+n.m05*o+n.m13,e},t.str=function(e){return"Vec2("+e.x+", "+e.y+")"},t.toArray=function(e,t,n){return void 0===n&&(n=0),e[n+0]=t.x,e[n+1]=t.y,e},t.fromArray=function(e,t,n){return void 0===n&&(n=0),e.x=t[n+0],e.y=t[n+1],e},t.strictEquals=function(e,t){return e.x===t.x&&e.y===t.y},t.equals=function(e,t,n){return void 0===n&&(n=dn),Math.abs(e.x-t.x)<=n*Math.max(1,Math.abs(e.x),Math.abs(t.x))&&Math.abs(e.y-t.y)<=n*Math.max(1,Math.abs(e.y),Math.abs(t.y))},t.angle=function(e,n){t.normalize(Kn,e),t.normalize(Jn,n);var i=t.dot(Kn,Jn);return i>1?0:i<-1?Math.PI:Math.acos(i)};var n=t.prototype;return n.clone=function(){return new t(this.x,this.y)},n.set=function(e,t){return e&&"object"==typeof e?(this.x=e.x,this.y=e.y):(this.x=e||0,this.y=t||0),this},n.equals=function(e,t){return void 0===t&&(t=dn),Math.abs(this.x-e.x)<=t*Math.max(1,Math.abs(this.x),Math.abs(e.x))&&Math.abs(this.y-e.y)<=t*Math.max(1,Math.abs(this.y),Math.abs(e.y))},n.equals2f=function(e,t,n){return void 0===n&&(n=dn),Math.abs(this.x-e)<=n*Math.max(1,Math.abs(this.x),Math.abs(e))&&Math.abs(this.y-t)<=n*Math.max(1,Math.abs(this.y),Math.abs(t))},n.strictEquals=function(e){return e&&this.x===e.x&&this.y===e.y},n.strictEquals2f=function(e,t){return this.x===e&&this.y===t},n.toString=function(){return"("+this.x.toFixed(2)+", "+this.y.toFixed(2)+")"},n.lerp=function(e,t){var n=this.x,i=this.y;return this.x=n+t*(e.x-n),this.y=i+t*(e.y-i),this},n.clampf=function(e,t){return this.x=hn(this.x,e.x,t.x),this.y=hn(this.y,e.y,t.y),this},n.add=function(e){return this.x+=e.x,this.y+=e.y,this},n.add2f=function(e,t){return this.x+=e,this.y+=t,this},n.subtract=function(e){return this.x-=e.x,this.y-=e.y,this},n.subtract2f=function(e,t){return this.x-=e,this.y-=t,this},n.multiplyScalar=function(e){return"object"==typeof e&&console.warn("should use Vec2.multiply for vector * vector operation"),this.x*=e,this.y*=e,this},n.multiply=function(e){return"object"!=typeof e&&console.warn("should use Vec2.scale for vector * scalar operation"),this.x*=e.x,this.y*=e.y,this},n.multiply2f=function(e,t){return this.x*=e,this.y*=t,this},n.divide=function(e){return this.x/=e.x,this.y/=e.y,this},n.divide2f=function(e,t){return this.x/=e,this.y/=t,this},n.negative=function(){return this.x=-this.x,this.y=-this.y,this},n.dot=function(e){return this.x*e.x+this.y*e.y},n.cross=function(e){return this.x*e.y-this.y*e.x},n.length=function(){return Math.sqrt(this.x*this.x+this.y*this.y)},n.lengthSqr=function(){return this.x*this.x+this.y*this.y},n.normalize=function(){var e=this.x,t=this.y,n=e*e+t*t;return n>0&&(n=1/Math.sqrt(n),this.x*=n,this.y*=n),this},n.angle=function(e){var t=this.lengthSqr(),n=e.lengthSqr();if(0===t||0===n)return console.warn("Can't get angle between zero vector"),0;var i=this.dot(e)/Math.sqrt(t*n);return i=hn(i,-1,1),Math.acos(i)},n.signAngle=function(e){var t=this.angle(e);return this.cross(e)<0?-t:t},n.rotate=function(e){var t=this.x,n=this.y,i=Math.sin(e),o=Math.cos(e);return this.x=o*t-i*n,this.y=i*t+o*n,this},n.project=function(e){var t=this.dot(e)/e.dot(e);return this.x=e.x*t,this.y=e.y*t,this},n.transformMat4=function(e){var t=this.x,n=this.y;return this.x=e.m00*t+e.m04*n+e.m12,this.y=e.m01*t+e.m05*n+e.m13,this},t}(l));Xn.ZERO=Object.freeze(new Xn(0,0)),Xn.ONE=Object.freeze(new Xn(1,1)),Xn.NEG_ONE=Object.freeze(new Xn(-1,-1)),Xn.UNIT_X=Object.freeze(new Xn(1,0)),Xn.UNIT_Y=Object.freeze(new Xn(0,1));var Kn=new Xn,Jn=new Xn;function Qn(e,t){return new Xn(e,t)}c.fastDefine("cc.Vec2",Xn,{x:0,y:0}),s.Vec2=Xn,s.v2=Qn;var Zn=e("T",function(e){function t(t,n,i,o){var a;return a=e.call(this)||this,t&&"object"==typeof t?(a.x=t.x,a.y=t.y,a.z=t.z,a.w=t.w):(a.x=t||0,a.y=n||0,a.z=i||0,a.w=o||0),a}a(t,e),t.clone=function(e){return new t(e.x,e.y,e.z,e.w)},t.copy=function(e,t){return e.x=t.x,e.y=t.y,e.z=t.z,e.w=t.w,e},t.set=function(e,t,n,i,o){return e.x=t,e.y=n,e.z=i,e.w=o,e},t.add=function(e,t,n){return e.x=t.x+n.x,e.y=t.y+n.y,e.z=t.z+n.z,e.w=t.w+n.w,e},t.subtract=function(e,t,n){return e.x=t.x-n.x,e.y=t.y-n.y,e.z=t.z-n.z,e.w=t.w-n.w,e},t.multiply=function(e,t,n){return e.x=t.x*n.x,e.y=t.y*n.y,e.z=t.z*n.z,e.w=t.w*n.w,e},t.divide=function(e,t,n){return e.x=t.x/n.x,e.y=t.y/n.y,e.z=t.z/n.z,e.w=t.w/n.w,e},t.ceil=function(e,t){return e.x=Math.ceil(t.x),e.y=Math.ceil(t.y),e.z=Math.ceil(t.z),e.w=Math.ceil(t.w),e},t.floor=function(e,t){return e.x=Math.floor(t.x),e.y=Math.floor(t.y),e.z=Math.floor(t.z),e.w=Math.floor(t.w),e},t.min=function(e,t,n){return e.x=Math.min(t.x,n.x),e.y=Math.min(t.y,n.y),e.z=Math.min(t.z,n.z),e.w=Math.min(t.w,n.w),e},t.max=function(e,t,n){return e.x=Math.max(t.x,n.x),e.y=Math.max(t.y,n.y),e.z=Math.max(t.z,n.z),e.w=Math.max(t.w,n.w),e},t.round=function(e,t){return e.x=Math.round(t.x),e.y=Math.round(t.y),e.z=Math.round(t.z),e.w=Math.round(t.w),e},t.multiplyScalar=function(e,t,n){return e.x=t.x*n,e.y=t.y*n,e.z=t.z*n,e.w=t.w*n,e},t.scaleAndAdd=function(e,t,n,i){return e.x=t.x+n.x*i,e.y=t.y+n.y*i,e.z=t.z+n.z*i,e.w=t.w+n.w*i,e},t.distance=function(e,t){var n=t.x-e.x,i=t.y-e.y,o=t.z-e.z,a=t.w-e.w;return Math.sqrt(n*n+i*i+o*o+a*a)},t.squaredDistance=function(e,t){var n=t.x-e.x,i=t.y-e.y,o=t.z-e.z,a=t.w-e.w;return n*n+i*i+o*o+a*a},t.len=function(e){var t=e.x,n=e.y,i=e.z,o=e.w;return Math.sqrt(t*t+n*n+i*i+o*o)},t.lengthSqr=function(e){var t=e.x,n=e.y,i=e.z,o=e.w;return t*t+n*n+i*i+o*o},t.negate=function(e,t){return e.x=-t.x,e.y=-t.y,e.z=-t.z,e.w=-t.w,e},t.inverse=function(e,t){return e.x=1/t.x,e.y=1/t.y,e.z=1/t.z,e.w=1/t.w,e},t.inverseSafe=function(e,t){var n=t.x,i=t.y,o=t.z,a=t.w;return Math.abs(n)<dn?e.x=0:e.x=1/n,Math.abs(i)<dn?e.y=0:e.y=1/i,Math.abs(o)<dn?e.z=0:e.z=1/o,Math.abs(a)<dn?e.w=0:e.w=1/a,e},t.normalize=function(e,t){var n=t.x,i=t.y,o=t.z,a=t.w,r=n*n+i*i+o*o+a*a;return r>0&&(r=1/Math.sqrt(r),e.x=n*r,e.y=i*r,e.z=o*r,e.w=a*r),e},t.dot=function(e,t){return e.x*t.x+e.y*t.y+e.z*t.z+e.w*t.w},t.lerp=function(e,t,n,i){return e.x=t.x+i*(n.x-t.x),e.y=t.y+i*(n.y-t.y),e.z=t.z+i*(n.z-t.z),e.w=t.w+i*(n.w-t.w),e},t.random=function(e,t){t=t||1;var n=2*xn()*Math.PI,i=2*xn()-1,o=Math.sqrt(1-i*i);return e.x=o*Math.cos(n)*t,e.y=o*Math.sin(n)*t,e.z=i*t,e.w=0,e},t.transformMat4=function(e,t,n){var i=t.x,o=t.y,a=t.z,r=t.w;return e.x=n.m00*i+n.m04*o+n.m08*a+n.m12*r,e.y=n.m01*i+n.m05*o+n.m09*a+n.m13*r,e.z=n.m02*i+n.m06*o+n.m10*a+n.m14*r,e.w=n.m03*i+n.m07*o+n.m11*a+n.m15*r,e},t.transformAffine=function(e,t,n){var i=t.x,o=t.y,a=t.z,r=t.w;return e.x=n.m00*i+n.m04*o+n.m08*a+n.m12*r,e.y=n.m01*i+n.m05*o+n.m09*a+n.m13*r,e.z=n.m02*i+n.m06*o+n.m10*a+n.m14*r,e.w=t.w,e},t.transformQuat=function(e,t,n){var i=t.x,o=t.y,a=t.z,r=n.x,c=n.y,s=n.z,l=n.w,f=l*i+c*a-s*o,_=l*o+s*i-r*a,u=l*a+r*o-c*i,m=-r*i-c*o-s*a;return e.x=f*l+m*-r+_*-s-u*-c,e.y=_*l+m*-c+u*-r-f*-s,e.z=u*l+m*-s+f*-c-_*-r,e.w=t.w,e},t.toArray=function(e,t,n){return void 0===n&&(n=0),e[n+0]=t.x,e[n+1]=t.y,e[n+2]=t.z,e[n+3]=t.w,e},t.fromArray=function(e,t,n){return void 0===n&&(n=0),e.x=t[n+0],e.y=t[n+1],e.z=t[n+2],e.w=t[n+3],e},t.strictEquals=function(e,t){return e.x===t.x&&e.y===t.y&&e.z===t.z&&e.w===t.w},t.equals=function(e,t,n){return void 0===n&&(n=dn),Math.abs(e.x-t.x)<=n*Math.max(1,Math.abs(e.x),Math.abs(t.x))&&Math.abs(e.y-t.y)<=n*Math.max(1,Math.abs(e.y),Math.abs(t.y))&&Math.abs(e.z-t.z)<=n*Math.max(1,Math.abs(e.z),Math.abs(t.z))&&Math.abs(e.w-t.w)<=n*Math.max(1,Math.abs(e.w),Math.abs(t.w))};var n=t.prototype;return n.clone=function(){return new t(this.x,this.y,this.z,this.w)},n.set=function(e,t,n,i){return e&&"object"==typeof e?(this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w):(this.x=e||0,this.y=t||0,this.z=n||0,this.w=i||0),this},n.equals=function(e,t){return void 0===t&&(t=dn),Math.abs(this.x-e.x)<=t*Math.max(1,Math.abs(this.x),Math.abs(e.x))&&Math.abs(this.y-e.y)<=t*Math.max(1,Math.abs(this.y),Math.abs(e.y))&&Math.abs(this.z-e.z)<=t*Math.max(1,Math.abs(this.z),Math.abs(e.z))&&Math.abs(this.w-e.w)<=t*Math.max(1,Math.abs(this.w),Math.abs(e.w))},n.equals4f=function(e,t,n,i,o){return void 0===o&&(o=dn),Math.abs(this.x-e)<=o*Math.max(1,Math.abs(this.x),Math.abs(e))&&Math.abs(this.y-t)<=o*Math.max(1,Math.abs(this.y),Math.abs(t))&&Math.abs(this.z-n)<=o*Math.max(1,Math.abs(this.z),Math.abs(n))&&Math.abs(this.w-i)<=o*Math.max(1,Math.abs(this.w),Math.abs(i))},n.strictEquals=function(e){return this.x===e.x&&this.y===e.y&&this.z===e.z&&this.w===e.w},n.strictEquals4f=function(e,t,n,i){return this.x===e&&this.y===t&&this.z===n&&this.w===i},n.lerp=function(e,t){var n=this.x,i=this.y,o=this.z,a=this.w;return this.x=n+t*(e.x-n),this.y=i+t*(e.y-i),this.z=o+t*(e.z-o),this.w=a+t*(e.w-a),this},n.toString=function(){return"("+this.x.toFixed(2)+", "+this.y.toFixed(2)+", "+this.z.toFixed(2)+", "+this.w.toFixed(2)+")"},n.clampf=function(e,t){return this.x=hn(this.x,e.x,t.x),this.y=hn(this.y,e.y,t.y),this.z=hn(this.z,e.z,t.z),this.w=hn(this.w,e.w,t.w),this},n.add=function(e){return this.x+=e.x,this.y+=e.y,this.z+=e.z,this.w+=e.w,this},n.add4f=function(e,t,n,i){return this.x+=e,this.y+=t,this.z+=n,this.w+=i,this},n.subtract=function(e){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this.w-=e.w,this},n.subtract4f=function(e,t,n,i){return this.x-=e,this.y-=t,this.z-=n,this.w-=i,this},n.multiplyScalar=function(e){return"object"==typeof e&&console.warn("should use Vec4.multiply for vector * vector operation"),this.x*=e,this.y*=e,this.z*=e,this.w*=e,this},n.multiply=function(e){return"object"!=typeof e&&console.warn("should use Vec4.scale for vector * scalar operation"),this.x*=e.x,this.y*=e.y,this.z*=e.z,this.w*=e.w,this},n.multiply4f=function(e,t,n,i){return this.x*=e,this.y*=t,this.z*=n,this.w*=i,this},n.divide=function(e){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this.w/=e.w,this},n.divide4f=function(e,t,n,i){return this.x/=e,this.y/=t,this.z/=n,this.w/=i,this},n.negative=function(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this},n.dot=function(e){return this.x*e.x+this.y*e.y+this.z*e.z+this.w*e.w},n.cross=function(e){var t=this.x,n=this.y,i=this.z,o=e.x,a=e.y,r=e.z;return this.x=n*r-i*a,this.y=i*o-t*r,this.z=t*a-n*o,this},n.length=function(){var e=this.x,t=this.y,n=this.z,i=this.w;return Math.sqrt(e*e+t*t+n*n+i*i)},n.lengthSqr=function(){var e=this.x,t=this.y,n=this.z,i=this.w;return e*e+t*t+n*n+i*i},n.normalize=function(){var e=this.x,t=this.y,n=this.z,i=this.w,o=e*e+t*t+n*n+i*i;return o>0&&(o=1/Math.sqrt(o),this.x=e*o,this.y=t*o,this.z=n*o,this.w=i*o),this},n.transformMat4=function(e){var t=this.x,n=this.y,i=this.z,o=this.w;return this.x=e.m00*t+e.m04*n+e.m08*i+e.m12*o,this.y=e.m01*t+e.m05*n+e.m09*i+e.m13*o,this.z=e.m02*t+e.m06*n+e.m10*i+e.m14*o,this.w=e.m03*t+e.m07*n+e.m11*i+e.m15*o,this},t}(l));function $n(e,t,n,i){return new Zn(e,t,n,i)}Zn.ZERO=Object.freeze(new Zn(0,0,0,0)),Zn.ONE=Object.freeze(new Zn(1,1,1,1)),Zn.NEG_ONE=Object.freeze(new Zn(-1,-1,-1,-1)),c.fastDefine("cc.Vec4",Zn,{x:0,y:0,z:0,w:0}),s.Vec4=Zn,s.v4=$n,nn(Xn,"Vec2",[{name:"sub",newName:"subtract",target:Xn,targetName:"Vec2"},{name:"mul",newName:"multiply",target:Xn,targetName:"Vec2"},{name:"div",newName:"divide",target:Xn,targetName:"Vec2"},{name:"dist",newName:"distance",target:Xn,targetName:"Vec2"},{name:"sqrDist",newName:"squaredDistance",target:Xn,targetName:"Vec2"},{name:"mag",newName:"len",target:Xn,targetName:"Vec2"},{name:"sqrMag",newName:"lengthSqr",target:Xn,targetName:"Vec2"},{name:"scale",newName:"multiplyScalar",target:Xn,targetName:"Vec2"},{name:"exactEquals",newName:"strictEquals",target:Xn,targetName:"Vec2"}]),nn(Xn.prototype,"Vec2",[{name:"mag",newName:"length",target:Xn.prototype,targetName:"Vec2"},{name:"magSqr",newName:"lengthSqr",target:Xn.prototype,targetName:"Vec2"},{name:"scale",newName:"multiplyScalar",target:Xn.prototype,targetName:"Vec2"},{name:"exactEquals",newName:"strictEquals",target:Xn.prototype,targetName:"Vec2"}]),nn(wn,"Vec3",[{name:"sub",newName:"subtract",target:wn,targetName:"Vec3"},{name:"mul",newName:"multiply",target:wn,targetName:"Vec3"},{name:"div",newName:"divide",target:wn,targetName:"Vec3"},{name:"dist",newName:"distance",target:wn,targetName:"Vec3"},{name:"sqrDist",newName:"squaredDistance",target:wn,targetName:"Vec3"},{name:"mag",newName:"len",target:wn,targetName:"Vec3"},{name:"sqrMag",newName:"lengthSqr",target:wn,targetName:"Vec3"},{name:"scale",newName:"multiplyScalar",target:wn,targetName:"Vec3"},{name:"exactEquals",newName:"strictEquals",target:wn,targetName:"Vec3"}]),nn(wn.prototype,"Vec3",[{name:"mag",newName:"length",target:wn.prototype,targetName:"Vec3"},{name:"magSqr",newName:"lengthSqr",target:wn.prototype,targetName:"Vec3"},{name:"scale",newName:"multiplyScalar",target:wn.prototype,targetName:"Vec3"},{name:"exactEquals",newName:"strictEquals",target:wn.prototype,targetName:"Vec3"}]),nn(Zn,"Vec4",[{name:"sub",newName:"subtract",target:Zn,targetName:"Vec4"},{name:"mul",newName:"multiply",target:Zn,targetName:"Vec4"},{name:"div",newName:"divide",target:Zn,targetName:"Vec4"},{name:"dist",newName:"distance",target:Zn,targetName:"Vec4"},{name:"sqrDist",newName:"squaredDistance",target:Zn,targetName:"Vec4"},{name:"mag",newName:"len",target:Zn,targetName:"Vec4"},{name:"sqrMag",newName:"lengthSqr",target:Zn,targetName:"Vec4"},{name:"scale",newName:"multiplyScalar",target:Zn,targetName:"Vec4"},{name:"exactEquals",newName:"strictEquals",target:Zn,targetName:"Vec4"}]),nn(Zn.prototype,"Vec4",[{name:"mag",newName:"length",target:Zn.prototype,targetName:"Vec4"},{name:"magSqr",newName:"lengthSqr",target:Zn.prototype,targetName:"Vec4"},{name:"scale",newName:"multiplyScalar",target:Zn.prototype,targetName:"Vec4"},{name:"exactEquals",newName:"strictEquals",target:Zn.prototype,targetName:"Vec4"}]),nn(zn,"Quat",[{name:"mag",newName:"len",target:zn,targetName:"Quat"},{name:"mul",newName:"multiply",target:zn,targetName:"Quat"},{name:"sqrMag",newName:"lengthSqr",target:zn,targetName:"Quat"},{name:"scale",newName:"multiplyScalar",target:zn,targetName:"Quat"},{name:"exactEquals",newName:"strictEquals",target:zn,targetName:"Quat"}]),nn(zn.prototype,"Quat",[{name:"scale",newName:"multiplyScalar",target:zn.prototype,targetName:"Quat"},{name:"exactEquals",newName:"strictEquals",target:zn.prototype,targetName:"Quat"}]),nn(bn,"Color",[{name:"sub",newName:"subtract",target:bn,targetName:"Color"},{name:"mul",newName:"multiply",target:bn,targetName:"Color"},{name:"div",newName:"divide",target:bn,targetName:"Color"},{name:"exactEquals",newName:"strictEquals",target:bn,targetName:"Color"},{name:"fromHex",newName:"fromHEX",customFunction:function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];var i=t[1].toString(16);return s.Color.fromHEX(t[0],i)}}]),nn(Mn,"Mat3",[{name:"sub",newName:"subtract",target:Mn,targetName:"Mat3"},{name:"mul",newName:"multiply",target:Mn,targetName:"Mat3"},{name:"exactEquals",newName:"strictEquals",target:Mn,targetName:"Mat3"},{name:"transfrom",newName:"transform",target:Mn,targetName:"Mat3"}]),nn(Mn.prototype,"Mat3",[{name:"sub",newName:"subtract",target:Mn.prototype,targetName:"Mat3"},{name:"mul",newName:"multiply",target:Mn.prototype,targetName:"Mat3"},{name:"mulScalar",newName:"multiplyScalar",target:Mn.prototype,targetName:"Mat3"},{name:"exactEquals",newName:"strictEquals",target:Mn.prototype,targetName:"Mat3"}]),nn(jn,"Mat4",[{name:"sub",newName:"subtract",target:jn,targetName:"Mat4"},{name:"mul",newName:"multiply",target:jn,targetName:"Mat4"},{name:"exactEquals",newName:"strictEquals",target:jn,targetName:"Mat4"}]),nn(jn.prototype,"Mat4",[{name:"sub",newName:"subtract",target:jn.prototype,targetName:"Mat4"},{name:"mul",newName:"multiply",target:jn.prototype,targetName:"Mat4"},{name:"mulScalar",newName:"multiplyScalar",target:jn.prototype,targetName:"Mat4"},{name:"exactEquals",newName:"strictEquals",target:jn.prototype,targetName:"Mat4"}]);var ei=e("a0",function(){function e(e,t,n,i,o,a){void 0===e&&(e=1),void 0===t&&(t=0),void 0===n&&(n=0),void 0===i&&(i=1),void 0===o&&(o=0),void 0===a&&(a=0),this.a=e,this.b=t,this.c=n,this.d=i,this.tx=o,this.ty=a}return e.identity=function(){return new e},e.clone=function(t){return new e(t.a,t.b,t.c,t.d,t.tx,t.ty)},e.concat=function(e,t,n){var i=t.a,o=t.b,a=t.c,r=t.d,c=t.tx,s=t.ty;e.a=i*n.a+o*n.c,e.b=i*n.b+o*n.d,e.c=a*n.a+r*n.c,e.d=a*n.b+r*n.d,e.tx=c*n.a+s*n.c+n.tx,e.ty=c*n.b+s*n.d+n.ty},e.invert=function(e,t){var n=1/(t.a*t.d-t.b*t.c);e.a=n*t.d,e.b=-n*t.b,e.c=-n*t.c,e.d=n*t.a,e.tx=n*(t.c*t.ty-t.d*t.tx),e.ty=n*(t.b*t.tx-t.a*t.ty)},e.fromMat4=function(e,t){e.a=t.m00,e.b=t.m01,e.c=t.m04,e.d=t.m05,e.tx=t.m12,e.ty=t.m13},e.transformVec2=function(e,t,n,i){var o,a;i?(o=t,a=n):(i=n,o=t.x,a=t.y),e.x=i.a*o+i.c*a+i.tx,e.y=i.b*o+i.d*a+i.ty},e.transformSize=function(e,t,n){e.width=n.a*t.width+n.c*t.height,e.height=n.b*t.width+n.d*t.height},e.transformRect=function(e,t,n){var i=t.x+t.width,o=t.y+t.height,a=n.a*t.x+n.c*t.y+n.tx,r=n.b*t.x+n.d*t.y+n.ty,c=n.a*i+n.c*t.y+n.tx,s=n.b*i+n.d*t.y+n.ty,l=n.a*t.x+n.c*o+n.tx,f=n.b*t.x+n.d*o+n.ty,_=n.a*i+n.c*o+n.tx,u=n.b*i+n.d*o+n.ty,m=Math.min(a,c,l,_),d=Math.max(a,c,l,_),p=Math.min(r,s,f,u),h=Math.max(r,s,f,u);e.x=m,e.y=p,e.width=d-m,e.height=h-p},e.transformObb=function(e,t,n,i,o,a){var r=a.a*o.x+a.c*o.y+a.tx,c=a.b*o.x+a.d*o.y+a.ty,s=a.a*o.width,l=a.b*o.width,f=a.c*o.height,_=a.d*o.height;t.x=r,t.y=c,n.x=s+r,n.y=l+c,e.x=f+r,e.y=_+c,i.x=s+f+r,i.y=l+_+c},e}());s.AffineTransform=ei;var ti=e("a1",function(e){function t(t,n){var i;return i=e.call(this)||this,t&&"object"==typeof t?(i.width=t.width,i.height=t.height):(i.width=t||0,i.height=n||0),i}a(t,e),t.lerp=function(e,t,n,i){return e.width=t.width+(n.width-t.width)*i,e.height=t.height+(n.height-t.height)*i,e};var n=t.prototype;return n.clone=function(){return new t(this.width,this.height)},n.set=function(e,t){return e&&"object"==typeof e?(this.height=e.height,this.width=e.width):(this.width=e||0,this.height=t||0),this},n.equals=function(e){return this.width===e.width&&this.height===e.height},n.lerp=function(e,t){return this.width+=(e.width-this.width)*t,this.height+=(e.height-this.height)*t,this},n.toString=function(){return"("+this.width.toFixed(2)+", "+this.height.toFixed(2)+")"},r(t,[{key:"x",get:function(){return this.width},set:function(e){this.width=e}},{key:"y",get:function(){return this.height},set:function(e){this.height=e}}]),t}(l));function ni(e,t){return void 0===e&&(e=0),void 0===t&&(t=0),new ti(e,t)}ti.ZERO=Object.freeze(new ti(0,0)),ti.ONE=Object.freeze(new ti(1,1)),c.fastDefine("cc.Size",ti,{width:0,height:0}),s.size=ni,s.Size=ti;var ii=e("a3",function(e){function t(t,n,i,o){var a;return a=e.call(this)||this,t&&"object"==typeof t?(a.y=t.y,a.width=t.width,a.height=t.height,a.x=t.x):(a.x=t||0,a.y=n||0,a.width=i||0,a.height=o||0),a}a(t,e),t.fromMinMax=function(e,t,n){var i=Math.min(t.x,n.x),o=Math.min(t.y,n.y),a=Math.max(t.x,n.x),r=Math.max(t.y,n.y);return e.x=i,e.y=o,e.width=a-i,e.height=r-o,e},t.lerp=function(e,t,n,i){var o=t.x,a=t.y,r=t.width,c=t.height;return e.x=o+(n.x-o)*i,e.y=a+(n.y-a)*i,e.width=r+(n.width-r)*i,e.height=c+(n.height-c)*i,e},t.intersection=function(e,t,n){var i=t.x,o=t.y,a=t.x+t.width,r=t.y+t.height,c=n.x,s=n.y,l=n.x+n.width,f=n.y+n.height;return e.x=Math.max(i,c),e.y=Math.max(o,s),e.width=Math.min(a,l)-e.x,e.height=Math.min(r,f)-e.y,e},t.union=function(e,t,n){var i=t.x,o=t.y,a=t.width,r=t.height,c=n.x,s=n.y,l=n.width,f=n.height;return e.x=Math.min(i,c),e.y=Math.min(o,s),e.width=Math.max(i+a,c+l)-e.x,e.height=Math.max(o+r,s+f)-e.y,e};var n=t.prototype;return n.clone=function(){return new t(this.x,this.y,this.width,this.height)},n.set=function(e,t,n,i){return e&&"object"==typeof e?(this.y=e.y,this.width=e.width,this.height=e.height,this.x=e.x):(this.x=e||0,this.y=t||0,this.width=n||0,this.height=i||0),this},n.equals=function(e){return this.x===e.x&&this.y===e.y&&this.width===e.width&&this.height===e.height},n.lerp=function(e,t){var n=this.x,i=this.y,o=this.width,a=this.height;return this.x=n+(e.x-n)*t,this.y=i+(e.y-i)*t,this.width=o+(e.width-o)*t,this.height=a+(e.height-a)*t,this},n.toString=function(){return"("+this.x.toFixed(2)+", "+this.y.toFixed(2)+", "+this.width.toFixed(2)+", "+this.height.toFixed(2)+")"},n.intersects=function(e){var t=this.x+this.width,n=this.y+this.height,i=e.x+e.width,o=e.y+e.height;return!(t<e.x||i<this.x||n<e.y||o<this.y)},n.contains=function(e){return this.x<=e.x&&this.x+this.width>=e.x&&this.y<=e.y&&this.y+this.height>=e.y},n.containsRect=function(e){return this.x<=e.x&&this.x+this.width>=e.x+e.width&&this.y<=e.y&&this.y+this.height>=e.y+e.height},n.transformMat4=function(e){var t=this.x,n=this.y,i=t+this.width,o=n+this.height,a=e.m00*t+e.m04*n+e.m12,r=e.m01*t+e.m05*n+e.m13,c=e.m00*i+e.m04*n+e.m12,s=e.m01*i+e.m05*n+e.m13,l=e.m00*t+e.m04*o+e.m12,f=e.m01*t+e.m05*o+e.m13,_=e.m00*i+e.m04*o+e.m12,u=e.m01*i+e.m05*o+e.m13,m=Math.min(a,c,l,_),d=Math.max(a,c,l,_),p=Math.min(r,s,f,u),h=Math.max(r,s,f,u);return this.x=m,this.y=p,this.width=d-m,this.height=h-p,this},n.transformMat4ToPoints=function(e,t,n,i,o){var a=this.x,r=this.y,c=a+this.width,s=r+this.height;t.x=e.m00*a+e.m04*r+e.m12,t.y=e.m01*a+e.m05*r+e.m13,o.x=e.m00*c+e.m04*r+e.m12,o.y=e.m01*c+e.m05*r+e.m13,n.x=e.m00*a+e.m04*s+e.m12,n.y=e.m01*a+e.m05*s+e.m13,i.x=e.m00*c+e.m04*s+e.m12,i.y=e.m01*c+e.m05*s+e.m13},r(t,[{key:"xMin",get:function(){return this.x},set:function(e){this.width+=this.x-e,this.x=e}},{key:"yMin",get:function(){return this.y},set:function(e){this.height+=this.y-e,this.y=e}},{key:"xMax",get:function(){return this.x+this.width},set:function(e){this.width=e-this.x}},{key:"yMax",get:function(){return this.y+this.height},set:function(e){this.height=e-this.y}},{key:"center",get:function(){return new Xn(this.x+.5*this.width,this.y+.5*this.height)},set:function(e){this.x=e.x-.5*this.width,this.y=e.y-.5*this.height}},{key:"origin",get:function(){return new Xn(this.x,this.y)},set:function(e){this.x=e.x,this.y=e.y}},{key:"size",get:function(){return new ti(this.width,this.height)},set:function(e){this.width=e.width,this.height=e.height}},{key:"z",get:function(){return this.width},set:function(e){this.width=e}},{key:"w",get:function(){return this.height},set:function(e){this.height=e}}]),t}(l));function oi(e,t,n,i){return void 0===e&&(e=0),void 0===t&&(t=0),void 0===n&&(n=0),void 0===i&&(i=0),new ii(e,t,n,i)}c.fastDefine("cc.Rect",ii,{x:0,y:0,width:0,height:0}),s.Rect=ii,s.rect=oi;var ai=e("as",Float64Array),ri=(e("at",function(e){function t(){return e.apply(this,arguments)||this}return a(t,e),t.createFloatArray=function(e){return new ai(e)},r(t,[{key:"array",get:function(){return this._array}}]),t}(l)),new wn),ci=new wn,si=new wn,li=new wn,fi=new wn,_i=new wn,ui=new Array(3),mi=new Array(3);function di(e,t){return wn.dot(t.n,e)-t.d}function pi(e,t,n){return wn.copy(e,t),wn.subtract(fi,n.center,n.halfExtents),wn.add(_i,n.center,n.halfExtents),e.x=e.x<fi.x?fi.x:e.x,e.y=e.y<fi.y?fi.y:e.y,e.z=e.z<fi.z?fi.z:e.z,e.x=e.x>_i.x?_i.x:e.x,e.y=e.y>_i.y?_i.y:e.y,e.z=e.z>_i.z?_i.z:e.z,e}function hi(e,t,n){wn.set(ri,n.orientation.m00,n.orientation.m01,n.orientation.m02),wn.set(ci,n.orientation.m03,n.orientation.m04,n.orientation.m05),wn.set(si,n.orientation.m06,n.orientation.m07,n.orientation.m08),ui[0]=ri,ui[1]=ci,ui[2]=si,mi[0]=n.halfExtents.x,mi[1]=n.halfExtents.y,mi[2]=n.halfExtents.z,wn.subtract(li,t,n.center),wn.set(e,n.center.x,n.center.y,n.center.z);for(var i=0;i<3;i++){var o=wn.dot(li,ui[i]);o>mi[i]&&(o=mi[i]),o<-mi[i]&&(o=-mi[i]),e.x+=o*ui[i].x,e.y+=o*ui[i].y,e.z+=o*ui[i].z}return e}e("ck",Object.freeze({__proto__:null,point_plane:di,pt_point_plane:function(e,t,n){var i=di(t,n);return wn.subtract(e,t,wn.multiplyScalar(e,n.n,i))},pt_point_aabb:pi,pt_point_obb:hi,pt_point_line:function(e,t,n,i){wn.subtract(ri,n,i);var o=ri,a=wn.lengthSqr(o);if(0==a)wn.copy(e,n);else{wn.subtract(ri,t,n);var r=wn.dot(ri,o)/a;r<0?wn.copy(e,n):r>1?wn.copy(e,i):wn.scaleAndAdd(e,n,o,r)}}}));var vi=e("cl",{SHAPE_RAY:1,SHAPE_LINE:2,SHAPE_SPHERE:4,SHAPE_AABB:8,SHAPE_OBB:16,SHAPE_PLANE:32,SHAPE_TRIANGLE:64,SHAPE_FRUSTUM:128,SHAPE_FRUSTUM_ACCURATE:256,SHAPE_CAPSULE:512}),gi=e("cm",function(){function e(e,t,n,i,o,a){void 0===e&&(e=0),void 0===t&&(t=0),void 0===n&&(n=0),void 0===i&&(i=0),void 0===o&&(o=0),void 0===a&&(a=-1),this.s=void 0,this.e=void 0,this._type=void 0,this._type=vi.SHAPE_LINE,this.s=new wn(e,t,n),this.e=new wn(i,o,a)}return e.create=function(t,n,i,o,a,r){return new e(t,n,i,o,a,r)},e.clone=function(t){return new e(t.s.x,t.s.y,t.s.z,t.e.x,t.e.y,t.e.z)},e.copy=function(e,t){return wn.copy(e.s,t.s),wn.copy(e.e,t.e),e},e.fromPoints=function(e,t,n){return wn.copy(e.s,t),wn.copy(e.e,n),e},e.set=function(e,t,n,i,o,a,r){return e.s.x=t,e.s.y=n,e.s.z=i,e.e.x=o,e.e.y=a,e.e.z=r,e},e.len=function(e){return wn.distance(e.s,e.e)},e.prototype.length=function(){return wn.distance(this.s,this.e)},r(e,[{key:"type",get:function(){return this._type}}]),e}()),xi=e("cf",function(){function e(e,t,n,i,o,a){void 0===e&&(e=0),void 0===t&&(t=0),void 0===n&&(n=0),void 0===i&&(i=0),void 0===o&&(o=0),void 0===a&&(a=-1),this.o=void 0,this.d=void 0,this._type=void 0,this._type=vi.SHAPE_RAY,this.o=new wn(e,t,n),this.d=new wn(i,o,a)}return e.create=function(t,n,i,o,a,r){return void 0===t&&(t=0),void 0===n&&(n=0),void 0===i&&(i=0),void 0===o&&(o=0),void 0===a&&(a=0),void 0===r&&(r=1),new e(t,n,i,o,a,r)},e.clone=function(t){return new e(t.o.x,t.o.y,t.o.z,t.d.x,t.d.y,t.d.z)},e.copy=function(e,t){return wn.copy(e.o,t.o),wn.copy(e.d,t.d),e},e.fromPoints=function(e,t,n){return wn.copy(e.o,t),wn.normalize(e.d,wn.subtract(e.d,n,t)),e},e.set=function(e,t,n,i,o,a,r){return e.o.x=t,e.o.y=n,e.o.z=i,e.d.x=o,e.d.y=a,e.d.z=r,e},e.prototype.computeHit=function(e,t){wn.normalize(e,this.d),wn.scaleAndAdd(e,this.o,e,t)},r(e,[{key:"type",get:function(){return this._type}}]),e}()),yi=new wn,Ci=new wn,Si=new wn,Ei=new wn;function Pi(e){return Math.max(Math.max(e.x,e.y),e.z)}var Ii=e("bK",function(){function e(e,t,n,i){void 0===e&&(e=0),void 0===t&&(t=0),void 0===n&&(n=0),void 0===i&&(i=1),this._center=new wn(0,0,0),this._radius=0,this._type=void 0,this._type=vi.SHAPE_SPHERE,this._center=new wn(e,t,n),this._radius=i}e.create=function(t,n,i,o){return new e(t,n,i,o)},e.clone=function(t){return new e(t.center.x,t.center.y,t.center.z,t.radius)},e.copy=function(e,t){return wn.copy(e.center,t.center),e.radius=t.radius,e},e.fromPoints=function(e,t,n){return wn.multiplyScalar(e.center,wn.add(yi,t,n),.5),e.radius=.5*wn.subtract(yi,n,t).length(),e},e.set=function(e,t,n,i,o){return e.center.x=t,e.center.y=n,e.center.z=i,e.radius=o,e};var t=e.prototype;return t.destroy=function(){},t.clone=function(){return e.clone(this)},t.copy=function(t){return e.copy(this,t)},t.getBoundary=function(e,t){wn.set(e,this.center.x-this.radius,this.center.y-this.radius,this.center.z-this.radius),wn.set(t,this.center.x+this.radius,this.center.y+this.radius,this.center.z+this.radius)},t.transform=function(e,t,n,i,o){wn.transformMat4(o.center,this.center,e),o.radius=this.radius*Pi(i)},t.translateAndRotate=function(e,t,n){wn.transformMat4(n.center,this.center,e)},t.setScale=function(e,t){t.radius=this.radius*Pi(e)},t.mergePoint=function(e){this.radius<0&&(this.center.set(e),this.radius=0),wn.subtract(Ci,e,this.center);var t=Ci.length();if(t>this.radius){var n=.5*(t-this.radius);this.radius+=n,wn.multiplyScalar(Ci,Ci,n/t),wn.add(this.center,this.center,Ci)}},t.mergePoints=function(e){var t=e.length;if(!(t<1)){this.radius=-1;for(var n=0;n<t;n++)this.mergePoint(e[n])}},t.mergeAABB=function(e){e.getBoundary(Si,Ei),this.mergePoint(Si),this.mergePoint(Ei)},r(e,[{key:"center",get:function(){return this._center},set:function(e){this._center=e}},{key:"radius",get:function(){return this._radius},set:function(e){this._radius=e}},{key:"type",get:function(){return this._type}}]),e}()),Ti=e("co",function(){function e(e,t,n,i,o,a,r,c,s){void 0===e&&(e=0),void 0===t&&(t=0),void 0===n&&(n=0),void 0===i&&(i=1),void 0===o&&(o=0),void 0===a&&(a=0),void 0===r&&(r=0),void 0===c&&(c=1),void 0===s&&(s=0),this.a=void 0,this.b=void 0,this.c=void 0,this._type=void 0,this._type=vi.SHAPE_TRIANGLE,this.a=new wn(e,t,n),this.b=new wn(i,o,a),this.c=new wn(r,c,s)}return e.create=function(t,n,i,o,a,r,c,s,l){return void 0===t&&(t=1),void 0===n&&(n=0),void 0===i&&(i=0),void 0===o&&(o=0),void 0===a&&(a=0),void 0===r&&(r=0),void 0===c&&(c=0),void 0===s&&(s=0),void 0===l&&(l=1),new e(t,n,i,o,a,r,c,s,l)},e.clone=function(t){return new e(t.a.x,t.a.y,t.a.z,t.b.x,t.b.y,t.b.z,t.c.x,t.c.y,t.c.z)},e.copy=function(e,t){return wn.copy(e.a,t.a),wn.copy(e.b,t.b),wn.copy(e.c,t.c),e},e.fromPoints=function(e,t,n,i){return wn.copy(e.a,t),wn.copy(e.b,n),wn.copy(e.c,i),e},e.set=function(e,t,n,i,o,a,r,c,s,l){return e.a.x=t,e.a.y=n,e.a.z=i,e.b.x=o,e.b.y=a,e.b.z=r,e.c.x=c,e.c.y=s,e.c.z=l,e},r(e,[{key:"type",get:function(){return this._type}}]),e}()),bi={Device:_,Swapchain:u,Buffer:m,Texture:d,Sampler:p,Shader:h,InputAssembler:v,RenderPass:g,Framebuffer:x,DescriptorSet:y,DescriptorSetLayout:C,PipelineLayout:S,PipelineState:E,CommandBuffer:P,Queue:I,GeneralBarrier:T,TextureBarrier:b,RasterizerState:A,BlendState:w,BlendTarget:N,DepthStencilState:D,PipelineStateInfo:R};Object.assign(bi,f),s.gfx=bi;var Ai,wi={GFXDevice:!0,GFXBuffer:!0,GFXTexture:!0,GFXSampler:!0,GFXShader:!0,GFXInputAssembler:!0,GFXRenderPass:!0,GFXFramebuffer:!0,GFXPipelineState:!0,GFXCommandBuffer:!0,GFXQueue:!0,GFXObjectType:!0,GFXObject:!1,GFXAttributeName:!0,GFXType:!0,GFXFormat:!0,GFXBufferUsageBit:!0,GFXMemoryUsageBit:!0,GFXBufferFlagBit:!0,GFXBufferAccessBit:"MemoryAccessBit",GFXPrimitiveMode:!0,GFXPolygonMode:!0,GFXShadeModel:!0,GFXCullMode:!0,GFXComparisonFunc:!0,GFXStencilOp:!0,GFXBlendOp:!0,GFXBlendFactor:!0,GFXColorMask:!0,GFXFilter:!0,GFXAddress:!0,GFXTextureType:!0,GFXTextureUsageBit:!0,GFXSampleCount:!0,GFXTextureFlagBit:!0,GFXShaderStageFlagBit:!0,GFXDescriptorType:!0,GFXCommandBufferType:!0,GFXLoadOp:!0,GFXStoreOp:!0,GFXPipelineBindPoint:!0,GFXDynamicStateFlagBit:!0,GFXStencilFace:!0,GFXQueueType:!0,GFXRect:!0,GFXViewport:!0,GFXColor:!0,GFXClearFlag:!0,GFXOffset:!0,GFXExtent:!0,GFXTextureSubres:"TextureSubresLayers",GFXTextureCopy:!0,GFXBufferTextureCopy:!0,GFXFormatType:!0,GFXFormatInfo:!0,GFXMemoryStatus:!0,GFXFormatInfos:!0,GFXFormatSize:!0,GFXFormatSurfaceSize:!0,GFXGetTypeSize:!0,getTypedArrayConstructor:!1};for(var Ni in wi){var Di=wi[Ni];!0===Di?Di=Ni.slice(3):!1===Di&&(Di=Ni),nn(s,"cc",[{name:Ni,newName:Di,target:s.gfx,targetName:"cc.gfx"}])}on(s,"cc",[{name:"GFX_MAX_VERTEX_ATTRIBUTES"},{name:"GFX_MAX_TEXTURE_UNITS"},{name:"GFX_MAX_ATTACHMENTS"},{name:"GFX_MAX_BUFFER_BINDINGS"},{name:"GFXTextureLayout"}]),on(M,"Feature",[{name:"COLOR_FLOAT",suggest:"Please use device.getFormatFeatures() instead, like: \nlet isSupported = device.getFormatFeatures(Format.R32F) & FormatFeatureBit.RENDER_TARGET;"},{name:"COLOR_HALF_FLOAT",suggest:"Please use device.getFormatFeatures() instead, like: \nlet isSupported = device.getFormatFeatures(Format.R16F) & FormatFeatureBit.RENDER_TARGET;"},{name:"TEXTURE_FLOAT",suggest:"Please use device.getFormatFeatures() instead, like: \nlet isSupported = (device.getFormatFeatures(Format.R32F) & (FormatFeatureBit.RENDER_TARGET | FormatFeatureBit.SAMPLED_TEXTURE)) === (FormatFeatureBit.RENDER_TARGET | FormatFeatureBit.SAMPLED_TEXTURE);"},{name:"TEXTURE_HALF_FLOAT",suggest:"Please use device.getFormatFeatures() instead, like: \nlet isSupported = (device.getFormatFeatures(Format.R16F) & (FormatFeatureBit.RENDER_TARGET | FormatFeatureBit.SAMPLED_TEXTURE)) === (FormatFeatureBit.RENDER_TARGET | FormatFeatureBit.SAMPLED_TEXTURE);"},{name:"TEXTURE_FLOAT_LINEAR",suggest:"Please use device.getFormatFeatures() instead, like: \nlet isSupported = device.getFormatFeatures(Format.R32F) & FormatFeatureBit.LINEAR_FILTER;"},{name:"TEXTURE_HALF_FLOAT_LINEAR",suggest:"Please use device.getFormatFeatures() instead, like: \nlet isSupported = device.getFormatFeatures(Format.R16F) & FormatFeatureBit.LINEAR_FILTER;"},{name:"FORMAT_R11G11B10F",suggest:"Please use device.getFormatFeatures() instead, like: \nlet isSupported = device.getFormatFeatures(Format.R11G11B10F) !== FormatFeatureBit.NONE;"},{name:"FORMAT_SRGB",suggest:"Please use device.getFormatFeatures() instead, like: \nlet isSupported = device.getFormatFeatures(Format.SRGB8) !== FormatFeatureBit.NONE;"},{name:"FORMAT_ETC1",suggest:"Please use device.getFormatFeatures() instead, like: \nlet isSupported = device.getFormatFeatures(Format.ETC_RGB8) !== FormatFeatureBit.NONE;"},{name:"FORMAT_ETC2",suggest:"Please use device.getFormatFeatures() instead, like: \nlet isSupported = device.getFormatFeatures(Format.ETC2_RGB8) !== FormatFeatureBit.NONE;"},{name:"FORMAT_DXT",suggest:"Please use device.getFormatFeatures() instead, like: \nlet isSupported = device.getFormatFeatures(Format.BC1) !== FormatFeatureBit.NONE;"},{name:"FORMAT_PVRTC",suggest:"Please use device.getFormatFeatures() instead, like: \nlet isSupported = device.getFormatFeatures(Format.PVRTC_RGB2) !== FormatFeatureBit.NONE;"},{name:"FORMAT_ASTC",suggest:"Please use device.getFormatFeatures() instead, like: \nlet isSupported = device.getFormatFeatures(Format.ASTC_RGBA_4x4) !== FormatFeatureBit.NONE;"},{name:"FORMAT_RGB8",suggest:"Please use device.getFormatFeatures() instead, like: \nlet isSupported = device.getFormatFeatures(Format.RGB8) !== FormatFeatureBit.NONE;"}]),on(O.prototype,"ColorAttachment",[{name:"beginAccesses",suggest:"Please assign to ColorAttachment.barrier instead"},{name:"endAccesses",suggest:"Please assign to ColorAttachment.barrier instead"}]),on(L.prototype,"DepthStencilAttachment",[{name:"beginAccesses",suggest:"Please assign to DepthStencilAttachment.barrier instead"},{name:"endAccesses",suggest:"Please assign to DepthStencilAttachment.barrier instead"}]),nn(_.prototype,"Device",[{name:"getGlobalBarrier",newName:"getGeneralBarrier"}]),function(e){e[e.ALL=0]="ALL",e[e.CLOSEST=1]="CLOSEST",e[e.ANY=2]="ANY"}(Ai||(Ai=e("ct",{})));var Ri,Mi,Oi,Li,zi,Fi,Ui=(Ri=new wn(0,0,0),function(e,t){var n=wn.dot(e.d,t.n);if(Math.abs(n)<Number.EPSILON)return 0;wn.multiplyScalar(Ri,t.n,t.d);var i=wn.dot(wn.subtract(Ri,Ri,e.o),t.n)/n;return i<0?0:i}),Gi=(Mi=new wn(0,0,0),Oi=new wn(0,0,0),Li=new wn(0,0,0),zi=new wn(0,0,0),Fi=new wn(0,0,0),function(e,t,n){wn.subtract(Mi,t.b,t.a),wn.subtract(Oi,t.c,t.a),wn.cross(Li,e.d,Oi);var i=wn.dot(Mi,Li);if(i<Number.EPSILON&&(!n||i>-Number.EPSILON))return 0;var o=1/i;wn.subtract(zi,e.o,t.a);var a=wn.dot(zi,Li)*o;if(a<0||a>1)return 0;wn.cross(Fi,zi,Mi);var r=wn.dot(e.d,Fi)*o;if(r<0||a+r>1)return 0;var c=wn.dot(Oi,Fi)*o;return c<0?0:c}),Bi=function(){var e=new wn(0,0,0);return function(t,n){var i=n.radius,o=n.center,a=t.o,r=t.d,c=i*i;wn.subtract(e,o,a);var s=e.lengthSqr(),l=wn.dot(e,r),f=c-(s-l*l);if(f<0)return 0;var _=Math.sqrt(f),u=s<c?l+_:l-_;return u<0?0:u}}(),Hi=function(){var e=new wn,t=new wn;return function(n,i){return wn.subtract(e,i.center,i.halfExtents),wn.add(t,i.center,i.halfExtents),Vi(n,e,t)}}();function Vi(e,t,n){var i=e.o,o=e.d,a=1/o.x,r=1/o.y,c=1/o.z,s=(t.x-i.x)*a,l=(n.x-i.x)*a,f=(t.y-i.y)*r,_=(n.y-i.y)*r,u=(t.z-i.z)*c,m=(n.z-i.z)*c,d=Math.max(Math.max(Math.min(s,l),Math.min(f,_)),Math.min(u,m)),p=Math.min(Math.min(Math.max(s,l),Math.max(f,_)),Math.max(u,m));return p<0||d>p?0:d>0?d:p}var ki,ji,qi,Wi,Yi=function(){var e=new wn,t=new wn,n=new wn,i=new wn,o=new wn,a=new wn,r=new wn,c=new Array(3),s=new Array(3),l=new Array(3),f=new Array(6);return function(_,u){c[0]=u.halfExtents.x,c[1]=u.halfExtents.y,c[2]=u.halfExtents.z,e=u.center,t=_.o,n=_.d,wn.set(i,u.orientation.m00,u.orientation.m01,u.orientation.m02),wn.set(o,u.orientation.m03,u.orientation.m04,u.orientation.m05),wn.set(a,u.orientation.m06,u.orientation.m07,u.orientation.m08),wn.subtract(r,e,t),s[0]=wn.dot(i,n),s[1]=wn.dot(o,n),s[2]=wn.dot(a,n),l[0]=wn.dot(i,r),l[1]=wn.dot(o,r),l[2]=wn.dot(a,r);for(var m=0;m<3;++m){if(0===s[m]){if(-l[m]-c[m]>0||-l[m]+c[m]<0)return 0;s[m]=1e-7}f[2*m+0]=(l[m]+c[m])/s[m],f[2*m+1]=(l[m]-c[m])/s[m]}var d=Math.max(Math.max(Math.min(f[0],f[1]),Math.min(f[2],f[3])),Math.min(f[4],f[5])),p=Math.min(Math.min(Math.max(f[0],f[1]),Math.max(f[2],f[3])),Math.max(f[4],f[5]));return p<0||d>p?0:d>0?d:p}}(),Xi=function(){var e=new wn,t=new wn,n=new wn,i=new wn,o=new wn,a=new wn,r=new wn,c=new Ii;return function(s,l){var f=l.radius*l.radius,_=wn.normalize(e,s.d),u=l.ellipseCenter0,m=l.ellipseCenter1,d=wn.subtract(t,m,u);if(d.equals(wn.ZERO))return c.radius=l.radius,c.center.set(l.ellipseCenter0),Mo.raySphere(s,c);var p=s.o,h=wn.subtract(n,p,u),v=wn.cross(i,_,d),g=v.lengthSqr();if(0===g){c.radius=l.radius;var x=wn.subtract(o,m,p);return h.lengthSqr()<x.lengthSqr()?c.center.set(l.ellipseCenter0):c.center.set(l.ellipseCenter1),Mo.raySphere(s,c)}var y=wn.cross(o,h,d),C=d.lengthSqr(),S=2*wn.dot(v,y),E=S*S-4*g*(y.lengthSqr()-f*C);if(E<0)return 0;var P=(-S-Math.sqrt(E))/(2*g);if(P<0){c.radius=l.radius;var I=wn.subtract(a,m,p);return h.lengthSqr()<I.lengthSqr()?c.center.set(l.ellipseCenter0):c.center.set(l.ellipseCenter1),Mo.raySphere(s,c)}var T=wn.scaleAndAdd(a,s.o,_,P),b=wn.subtract(r,T,u),A=wn.dot(b,d)/C;return A>=0&&A<=1?P:A<0?(c.radius=l.radius,c.center.set(l.ellipseCenter0),Mo.raySphere(s,c)):A>1?(c.radius=l.radius,c.center.set(l.ellipseCenter1),Mo.raySphere(s,c)):0}}(),Ki=(ki=Ti.create(),ji={distance:1/0,doubleSided:!1,mode:Ai.ANY},qi=0,Wi=function(e,t,n,i,o,a){e===Ai.CLOSEST?(qi>t||0===qi)&&(qi=t,a&&(0===a.length?a.push({distance:t,vertexIndex0:n/3,vertexIndex1:i/3,vertexIndex2:o/3}):(a[0].distance=t,a[0].vertexIndex0=n/3,a[0].vertexIndex1=i/3,a[0].vertexIndex2=o/3))):(qi=t,a&&a.push({distance:t,vertexIndex0:n/3,vertexIndex1:i/3,vertexIndex2:o/3}))},function(e,t,n){if(qi=0,0===t.geometricInfo.positions.length)return qi;var i=void 0===n?ji:n;if(Vi(e,t.geometricInfo.boundingBox.min,t.geometricInfo.boundingBox.max)){var o=t.primitiveMode,a=t.geometricInfo;!function(e,t,n,i,o){if(n===z.TRIANGLE_LIST)for(var a=t.length,r=0;r<a;r+=3){var c=3*t[r],s=3*t[r+1],l=3*t[r+2];wn.set(ki.a,e[c],e[c+1],e[c+2]),wn.set(ki.b,e[s],e[s+1],e[s+2]),wn.set(ki.c,e[l],e[l+1],e[l+2]);var f=Mo.rayTriangle(i,ki,o.doubleSided);if(!(0===f||f>o.distance)&&(Wi(o.mode,f,c,s,l,o.result),o.mode===Ai.ANY))return f}else if(n===z.TRIANGLE_STRIP)for(var _=t.length-2,u=0,m=0;m<_;m+=1){var d=3*t[m-u],p=3*t[m+u+1],h=3*t[m+2];wn.set(ki.a,e[d],e[d+1],e[d+2]),wn.set(ki.b,e[p],e[p+1],e[p+2]),wn.set(ki.c,e[h],e[h+1],e[h+2]),u=~u;var v=Mo.rayTriangle(i,ki,o.doubleSided);if(!(0===v||v>o.distance)&&(Wi(o.mode,v,d,p,h,o.result),o.mode===Ai.ANY))return v}else if(n===z.TRIANGLE_FAN){var g=t.length-1,x=3*t[0];wn.set(ki.a,e[x],e[x+1],e[x+2]);for(var y=1;y<g;y+=1){var C=3*t[y],S=3*t[y+1];wn.set(ki.b,e[C],e[C+1],e[C+2]),wn.set(ki.c,e[S],e[S+1],e[S+2]);var E=Mo.rayTriangle(i,ki,o.doubleSided);if(!(0===E||E>o.distance)&&(Wi(o.mode,E,x,C,S,o.result),o.mode===Ai.ANY))return E}}}(a.positions,a.indices,o,e,i)}return qi}),Ji=function(){var e=0,t={distance:1/0,doubleSided:!1,mode:Ai.ANY};return function(n,i,o){e=0;var a=void 0===o?t:o,r=i.renderingSubMeshes.length,c=i.struct.minPosition,s=i.struct.maxPosition;if(c&&s&&!Vi(n,c,s))return e;for(var l=0;l<r;l++){var f=i.renderingSubMeshes[l],_=Ki(n,f,a);if(_)if(a.mode===Ai.CLOSEST)(0===e||e>_)&&(e=_,a.subIndices&&(a.subIndices[0]=l));else if(e=_,a.subIndices&&a.subIndices.push(l),a.mode===Ai.ANY)return _}return e&&a.mode===Ai.CLOSEST&&(a.result&&(a.result[0].distance=e,a.result.length=1),a.subIndices&&(a.subIndices.length=1)),e}}(),Qi=function(){var e=0,t={distance:1/0,doubleSided:!1,mode:Ai.ANY},n=new xi,i=new jn;return function(o,a,r){e=0;var c=void 0===r?t:r,s=a.worldBounds;if(s&&!Hi(o,s))return e;xi.copy(n,o),a.node&&(jn.invert(i,a.node.getWorldMatrix(i)),wn.transformMat4(n.o,o.o,i),wn.transformMat4Normal(n.d,o.d,i));for(var l=a.subModels,f=0;f<l.length;f++){var _=l[f].subMesh,u=Ki(n,_,c);if(u)if(c.mode===Ai.CLOSEST)(0===e||e>u)&&(e=u,c.subIndices&&(c.subIndices[0]=f));else if(e=u,c.subIndices&&c.subIndices.push(f),c.mode===Ai.ANY)return u}return e&&c.mode===Ai.CLOSEST&&(c.result&&(c.result[0].distance=e,c.result.length=1),c.subIndices&&(c.subIndices.length=1)),e}}(),Zi=function(){var e=new wn(0,0,0);return function(t,n){wn.subtract(e,t.e,t.s);var i=(n.d-wn.dot(t.s,n.n))/wn.dot(e,n.n);return i<0||i>1?0:i}}(),$i=function(){var e=new wn(0,0,0),t=new wn(0,0,0),n=new wn(0,0,0),i=new wn(0,0,0),o=new wn(0,0,0),a=new wn(0,0,0);return function(r,c,s){wn.subtract(e,c.b,c.a),wn.subtract(t,c.c,c.a),wn.subtract(n,r.s,r.e),wn.cross(o,e,t);var l=wn.dot(n,o);if(l<=0)return 0;wn.subtract(i,r.s,c.a);var f=wn.dot(i,o);if(f<0||f>l)return 0;wn.cross(a,n,i);var _=wn.dot(t,a);if(_<0||_>l)return 0;var u=-wn.dot(e,a);if(u<0||_+u>l)return 0;if(s){var m=1/l,d=1-(_*=m)-(u*=m);wn.set(s,c.a.x*d+c.b.x*_+c.c.x*u,c.a.y*d+c.b.y*_+c.c.y*u,c.a.z*d+c.b.z*_+c.c.z*u)}return 1}}(),eo=new xi;function to(e,t){eo.o.set(e.s),wn.subtract(eo.d,e.e,e.s),eo.d.normalize();var n=Hi(eo,t);return n<=e.length()?n:0}function no(e,t){eo.o.set(e.s),wn.subtract(eo.d,e.e,e.s),eo.d.normalize();var n=Yi(eo,t);return n<=e.length()?n:0}function io(e,t){eo.o.set(e.s),wn.subtract(eo.d,e.e,e.s),eo.d.normalize();var n=Bi(eo,t);return n<=e.length()?n:0}var oo,ao,ro,co,so=(oo=new wn,ao=new wn,ro=new wn,co=new wn,function(e,t){return wn.subtract(oo,e.center,e.halfExtents),wn.add(ao,e.center,e.halfExtents),wn.subtract(ro,t.center,t.halfExtents),wn.add(co,t.center,t.halfExtents),oo.x<=co.x&&ao.x>=ro.x&&oo.y<=co.y&&ao.y>=ro.y&&oo.z<=co.z&&ao.z>=ro.z});function lo(e,t,n,i,o,a){wn.set(a[0],e.x+n.x*t.x+i.x*t.y+o.x*t.z,e.y+n.y*t.x+i.y*t.y+o.y*t.z,e.z+n.z*t.x+i.z*t.y+o.z*t.z),wn.set(a[1],e.x-n.x*t.x+i.x*t.y+o.x*t.z,e.y-n.y*t.x+i.y*t.y+o.y*t.z,e.z-n.z*t.x+i.z*t.y+o.z*t.z),wn.set(a[2],e.x+n.x*t.x-i.x*t.y+o.x*t.z,e.y+n.y*t.x-i.y*t.y+o.y*t.z,e.z+n.z*t.x-i.z*t.y+o.z*t.z),wn.set(a[3],e.x+n.x*t.x+i.x*t.y-o.x*t.z,e.y+n.y*t.x+i.y*t.y-o.y*t.z,e.z+n.z*t.x+i.z*t.y-o.z*t.z),wn.set(a[4],e.x-n.x*t.x-i.x*t.y-o.x*t.z,e.y-n.y*t.x-i.y*t.y-o.y*t.z,e.z-n.z*t.x-i.z*t.y-o.z*t.z),wn.set(a[5],e.x+n.x*t.x-i.x*t.y-o.x*t.z,e.y+n.y*t.x-i.y*t.y-o.y*t.z,e.z+n.z*t.x-i.z*t.y-o.z*t.z),wn.set(a[6],e.x-n.x*t.x+i.x*t.y-o.x*t.z,e.y-n.y*t.x+i.y*t.y-o.y*t.z,e.z-n.z*t.x+i.z*t.y-o.z*t.z),wn.set(a[7],e.x-n.x*t.x-i.x*t.y+o.x*t.z,e.y-n.y*t.x-i.y*t.y+o.y*t.z,e.z-n.z*t.x-i.z*t.y+o.z*t.z)}function fo(e,t){for(var n=wn.dot(t,e[0]),i=n,o=1;o<8;++o){var a=wn.dot(t,e[o]);n=a<n?a:n,i=a>i?a:i}return[n,i]}var _o,uo,mo,po=function(){for(var e=new Array(15),t=0;t<15;t++)e[t]=new wn(0,0,0);for(var n=new Array(8),i=new Array(8),o=0;o<8;o++)n[o]=new wn(0,0,0),i[o]=new wn(0,0,0);var a=new wn,r=new wn;return function(t,o){wn.set(e[0],1,0,0),wn.set(e[1],0,1,0),wn.set(e[2],0,0,1),wn.set(e[3],o.orientation.m00,o.orientation.m01,o.orientation.m02),wn.set(e[4],o.orientation.m03,o.orientation.m04,o.orientation.m05),wn.set(e[5],o.orientation.m06,o.orientation.m07,o.orientation.m08);for(var c=0;c<3;++c)wn.cross(e[6+3*c],e[c],e[3]),wn.cross(e[7+3*c],e[c],e[4]),wn.cross(e[7+3*c],e[c],e[5]);wn.subtract(a,t.center,t.halfExtents),wn.add(r,t.center,t.halfExtents),function(e,t,n){wn.set(n[0],e.x,t.y,t.z),wn.set(n[1],e.x,t.y,e.z),wn.set(n[2],e.x,e.y,t.z),wn.set(n[3],e.x,e.y,e.z),wn.set(n[4],t.x,t.y,t.z),wn.set(n[5],t.x,t.y,e.z),wn.set(n[6],t.x,e.y,t.z),wn.set(n[7],t.x,e.y,e.z)}(a,r,n),lo(o.center,o.halfExtents,e[3],e[4],e[5],i);for(var s=0;s<15;++s){var l=fo(n,e[s]),f=fo(i,e[s]);if(f[0]>l[1]||l[0]>f[1])return 0}return 1}}(),ho=function(e,t){var n=e.halfExtents.x*Math.abs(t.n.x)+e.halfExtents.y*Math.abs(t.n.y)+e.halfExtents.z*Math.abs(t.n.z),i=wn.dot(t.n,e.center);return i+n<t.d?-1:i-n>t.d?0:1},vo=function(e,t){for(var n=0;n<t.planes.length;n++)if(-1===ho(e,t.planes[n]))return 0;return 1},go=function(){for(var e=new Array(8),t=0,n=0,i=0;i<e.length;i++)e[i]=new wn(0,0,0);return function(i,o){for(var a=0,r=!1,c=0;c<o.planes.length;c++){if(-1===(a=ho(i,o.planes[c])))return 0;1===a&&(r=!0)}if(!r)return 1;for(var s=0;s<o.vertices.length;s++)wn.subtract(e[s],o.vertices[s],i.center);t=0,n=0;for(var l=0;l<o.vertices.length;l++)e[l].x>i.halfExtents.x?t++:e[l].x<-i.halfExtents.x&&n++;if(t===o.vertices.length||n===o.vertices.length)return 0;t=0,n=0;for(var f=0;f<o.vertices.length;f++)e[f].y>i.halfExtents.y?t++:e[f].y<-i.halfExtents.y&&n++;if(t===o.vertices.length||n===o.vertices.length)return 0;t=0,n=0;for(var _=0;_<o.vertices.length;_++)e[_].z>i.halfExtents.z?t++:e[_].z<-i.halfExtents.z&&n++;return t===o.vertices.length||n===o.vertices.length?0:1}}(),xo=(_o=new wn(0,0,0),uo=new Mn,function(e,t){return wn.subtract(_o,t,e.center),wn.transformMat3(_o,_o,Mn.transpose(uo,e.orientation)),n=_o,i=e.halfExtents,Math.abs(n.x)<i.x&&Math.abs(n.y)<i.y&&Math.abs(n.z)<i.z;var n,i}),yo=(mo=function(e,t,n,i){return Math.abs(e.x*t+e.y*n+e.z*i)},function(e,t){var n=e.halfExtents.x*mo(t.n,e.orientation.m00,e.orientation.m01,e.orientation.m02)+e.halfExtents.y*mo(t.n,e.orientation.m03,e.orientation.m04,e.orientation.m05)+e.halfExtents.z*mo(t.n,e.orientation.m06,e.orientation.m07,e.orientation.m08),i=wn.dot(t.n,e.center);return i+n<t.d?-1:i-n>t.d?0:1}),Co=function(e,t){for(var n=0;n<t.planes.length;n++)if(-1===yo(e,t.planes[n]))return 0;return 1},So=function(){for(var e=new Array(8),t=0,n=0,i=0,o=0;o<e.length;o++)e[o]=new wn(0,0,0);var a=function(e,t,n,i){return e.x*t+e.y*n+e.z*i};return function(o,r){for(var c=0,s=!1,l=0;l<r.planes.length;l++){if(-1===(c=yo(o,r.planes[l])))return 0;1===c&&(s=!0)}if(!s)return 1;for(var f=0;f<r.vertices.length;f++)wn.subtract(e[f],r.vertices[f],o.center);n=0,i=0;for(var _=0;_<r.vertices.length;_++)(t=a(e[_],o.orientation.m00,o.orientation.m01,o.orientation.m02))>o.halfExtents.x?n++:t<-o.halfExtents.x&&i++;if(n===r.vertices.length||i===r.vertices.length)return 0;n=0,i=0;for(var u=0;u<r.vertices.length;u++)(t=a(e[u],o.orientation.m03,o.orientation.m04,o.orientation.m05))>o.halfExtents.y?n++:t<-o.halfExtents.y&&i++;if(n===r.vertices.length||i===r.vertices.length)return 0;n=0,i=0;for(var m=0;m<r.vertices.length;m++)(t=a(e[m],o.orientation.m06,o.orientation.m07,o.orientation.m08))>o.halfExtents.z?n++:t<-o.halfExtents.z&&i++;return n===r.vertices.length||i===r.vertices.length?0:1}}(),Eo=function(){for(var e=new Array(15),t=0;t<15;t++)e[t]=new wn(0,0,0);for(var n=new Array(8),i=new Array(8),o=0;o<8;o++)n[o]=new wn(0,0,0),i[o]=new wn(0,0,0);return function(t,o){wn.set(e[0],t.orientation.m00,t.orientation.m01,t.orientation.m02),wn.set(e[1],t.orientation.m03,t.orientation.m04,t.orientation.m05),wn.set(e[2],t.orientation.m06,t.orientation.m07,t.orientation.m08),wn.set(e[3],o.orientation.m00,o.orientation.m01,o.orientation.m02),wn.set(e[4],o.orientation.m03,o.orientation.m04,o.orientation.m05),wn.set(e[5],o.orientation.m06,o.orientation.m07,o.orientation.m08);for(var a=0;a<3;++a)wn.cross(e[6+3*a],e[a],e[3]),wn.cross(e[7+3*a],e[a],e[4]),wn.cross(e[8+3*a],e[a],e[5]);lo(t.center,t.halfExtents,e[0],e[1],e[2],n),lo(o.center,o.halfExtents,e[3],e[4],e[5],i);for(var r=0;r<15;++r){var c=fo(n,e[r]),s=fo(i,e[r]);if(s[0]>c[1]||c[0]>s[1])return 0}return 1}}(),Po=function(){for(var e=new Ii,t=new wn,n=new wn,i=new wn,o=new Array(8),a=0;a<8;a++)o[a]=new wn;for(var r=new Array(8),c=0;c<8;c++)r[c]=new wn;return function(a,c){if(0===wn.squaredDistance(c.ellipseCenter0,c.ellipseCenter1))return e.radius=c.radius,e.center.set(c.ellipseCenter0),Mo.sphereOBB(e,a);t.x=a.orientation.m00,t.y=a.orientation.m01,t.z=a.orientation.m02,n.x=a.orientation.m03,n.y=a.orientation.m04,n.z=a.orientation.m05,i.x=a.orientation.m06,i.y=a.orientation.m07,i.z=a.orientation.m08,lo(a.center,a.halfExtents,t,n,i,o);var s=r,l=wn.copy(s[0],t),f=wn.copy(s[1],n),_=wn.copy(s[2],i);wn.subtract(s[3],c.center,a.center).normalize();var u=wn.subtract(s[4],c.ellipseCenter0,c.ellipseCenter1);u.normalize(),wn.cross(s[5],l,u),wn.cross(s[6],f,u),wn.cross(s[7],_,u);for(var m=0;m<8;++m){var d=fo(o,s[m]),p=wn.dot(s[m],c.ellipseCenter0),h=wn.dot(s[m],c.ellipseCenter1),v=Math.max(p,h),g=Math.min(p,h)-c.radius,x=v+c.radius;if(g>d[1]||d[0]>x)return 0}return 1}}(),Io=function(e,t){var n=wn.dot(t.n,e.center),i=e.radius*t.n.length();return n+i<t.d?-1:n-i>t.d?0:1},To=function(e,t){for(var n=0;n<t.planes.length;n++)if(-1===Io(e,t.planes[n]))return 0;return 1},bo=function(){var e=new wn(0,0,0),t=[1,-1,1,-1,1,-1];return function(n,i){for(var o=0;o<6;o++){var a=i.planes[o],r=n.radius,c=n.center,s=a.n,l=a.d,f=wn.dot(s,c);if(f+r<l)return 0;if(!(f-r>l)){wn.add(e,c,wn.multiplyScalar(e,s,r));for(var _=0;_<6;_++)if(_!==o&&_!==o+t[o]){var u=i.planes[_];if(wn.dot(u.n,e)<u.d)return 0}}}return 1}}(),Ao=function(e,t){var n=e.radius+t.radius;return wn.squaredDistance(e.center,t.center)<n*n},wo=function(){var e=new wn;return function(t,n){return pi(e,t.center,n),wn.squaredDistance(t.center,e)<t.radius*t.radius}}(),No=function(){var e=new wn;return function(t,n){return hi(e,t.center,n),wn.squaredDistance(t.center,e)<t.radius*t.radius}}(),Do=function(){var e=new wn,t=new wn;return function(n,i){var o=n.radius+i.radius,a=o*o,r=wn.squaredDistance(i.ellipseCenter0,i.ellipseCenter1);if(0===r)return wn.squaredDistance(n.center,i.center)<a;wn.subtract(e,n.center,i.ellipseCenter0),wn.subtract(t,i.ellipseCenter1,i.ellipseCenter0);var c=wn.dot(e,t)/r;return c<0?wn.squaredDistance(n.center,i.ellipseCenter0)<a:c>1?wn.squaredDistance(n.center,i.ellipseCenter1)<a:(wn.scaleAndAdd(e,i.ellipseCenter0,t,c),wn.squaredDistance(n.center,e)<a)}}(),Ro=function(){var e=new wn,t=new wn,n=new wn,i=new wn,o=new wn,a=new wn;return function(r,c){var s,l,f=wn.subtract(e,r.ellipseCenter1,r.ellipseCenter0),_=wn.subtract(t,c.ellipseCenter1,c.ellipseCenter0),u=wn.subtract(n,r.ellipseCenter0,c.ellipseCenter0),m=wn.dot(f,f),d=wn.dot(f,_),p=wn.dot(_,_),h=wn.dot(f,u),v=wn.dot(_,u),g=m*p-d*d,x=g,y=g;g<dn?(s=0,x=1,l=v,y=p):(l=m*v-d*h,(s=d*v-p*h)<0?(s=0,l=v,y=p):s>x&&(s=x,l=v+d,y=p)),l<0?(l=0,-h<0?s=0:-h>m?s=x:(s=-h,x=m)):l>y&&(l=y,-h+d<0?s=0:-h+d>m?s=x:(s=-h+d,x=m));var C=Math.abs(s)<dn?0:s/x,S=Math.abs(l)<dn?0:l/y,E=i;E.set(u),E.add(wn.multiplyScalar(o,f,C)),E.subtract(wn.multiplyScalar(a,_,S));var P=r.radius+c.radius;return E.lengthSqr()<P*P}}(),Mo=e("bM",{raySphere:Bi,rayAABB:Hi,rayOBB:Yi,rayPlane:Ui,rayTriangle:Gi,rayCapsule:Xi,raySubMesh:Ki,rayMesh:Ji,rayModel:Qi,lineSphere:io,lineAABB:to,lineOBB:no,linePlane:Zi,lineTriangle:$i,sphereWithSphere:Ao,sphereAABB:wo,sphereOBB:No,spherePlane:Io,sphereFrustum:To,sphereFrustumAccurate:bo,sphereCapsule:Do,aabbWithAABB:so,aabbWithOBB:po,aabbPlane:ho,aabbFrustum:vo,aabbFrustumAccurate:go,obbWithOBB:Eo,obbPlane:yo,obbFrustum:Co,obbFrustumAccurate:So,obbPoint:xo,obbCapsule:Po,capsuleWithCapsule:Ro,resolve:function(e,t,n){void 0===n&&(n=null);var i=e._type,o=t._type,a=this[i|o];return i<o?a(e,t,n):a(t,e,n)}});Mo[vi.SHAPE_RAY|vi.SHAPE_SPHERE]=Bi,Mo[vi.SHAPE_RAY|vi.SHAPE_AABB]=Hi,Mo[vi.SHAPE_RAY|vi.SHAPE_OBB]=Yi,Mo[vi.SHAPE_RAY|vi.SHAPE_PLANE]=Ui,Mo[vi.SHAPE_RAY|vi.SHAPE_TRIANGLE]=Gi,Mo[vi.SHAPE_RAY|vi.SHAPE_CAPSULE]=Xi,Mo[vi.SHAPE_LINE|vi.SHAPE_SPHERE]=io,Mo[vi.SHAPE_LINE|vi.SHAPE_AABB]=to,Mo[vi.SHAPE_LINE|vi.SHAPE_OBB]=no,Mo[vi.SHAPE_LINE|vi.SHAPE_PLANE]=Zi,Mo[vi.SHAPE_LINE|vi.SHAPE_TRIANGLE]=$i,Mo[vi.SHAPE_SPHERE]=Ao,Mo[vi.SHAPE_SPHERE|vi.SHAPE_AABB]=wo,Mo[vi.SHAPE_SPHERE|vi.SHAPE_OBB]=No,Mo[vi.SHAPE_SPHERE|vi.SHAPE_PLANE]=Io,Mo[vi.SHAPE_SPHERE|vi.SHAPE_FRUSTUM]=To,Mo[vi.SHAPE_SPHERE|vi.SHAPE_FRUSTUM_ACCURATE]=bo,Mo[vi.SHAPE_SPHERE|vi.SHAPE_CAPSULE]=Do,Mo[vi.SHAPE_AABB]=so,Mo[vi.SHAPE_AABB|vi.SHAPE_OBB]=po,Mo[vi.SHAPE_AABB|vi.SHAPE_PLANE]=ho,Mo[vi.SHAPE_AABB|vi.SHAPE_FRUSTUM]=vo,Mo[vi.SHAPE_AABB|vi.SHAPE_FRUSTUM_ACCURATE]=go,Mo[vi.SHAPE_OBB]=Eo,Mo[vi.SHAPE_OBB|vi.SHAPE_PLANE]=yo,Mo[vi.SHAPE_OBB|vi.SHAPE_FRUSTUM]=Co,Mo[vi.SHAPE_OBB|vi.SHAPE_FRUSTUM_ACCURATE]=So,Mo[vi.SHAPE_OBB|vi.SHAPE_CAPSULE]=Po,Mo[vi.SHAPE_CAPSULE]=Ro,nn(gi.prototype,"line",[{name:"mag",newName:"len"},{name:"magnitude",newName:"len"}]),on(Mo,"intersect",[{name:"line_quad"}]);var Oo,Lo,zo,Fo,Uo,Go,Bo,Ho=new wn(0,0,0),Vo=new wn(0,0,0),ko=s.mat4(),jo=s.v4(),qo=e("cn",function(){function e(e,t,n,i){void 0===e&&(e=0),void 0===t&&(t=1),void 0===n&&(n=0),void 0===i&&(i=0),this.n=void 0,this.d=void 0,this._type=void 0,this._type=vi.SHAPE_PLANE,this.n=new wn(e,t,n),this.d=i}return e.create=function(t,n,i,o){return new e(t,n,i,o)},e.clone=function(t){return new e(t.n.x,t.n.y,t.n.z,t.d)},e.copy=function(e,t){return wn.copy(e.n,t.n),e.d=t.d,e},e.fromPoints=function(e,t,n,i){return wn.subtract(Ho,n,t),wn.subtract(Vo,i,t),wn.normalize(e.n,wn.cross(e.n,Ho,Vo)),e.d=wn.dot(e.n,t),e},e.set=function(e,t,n,i,o){return e.n.x=t,e.n.y=n,e.n.z=i,e.d=o,e},e.fromNormalAndPoint=function(e,t,n){return wn.copy(e.n,t),e.d=wn.dot(t,n),e},e.normalize=function(e,t){var n=t.n.length();return wn.normalize(e.n,t.n),n>0&&(e.d=t.d/n),e},e.prototype.transform=function(e){jn.invert(ko,e),jn.transpose(ko,ko),Zn.set(jo,this.n.x,this.n.y,this.n.z,this.d),Zn.transformMat4(jo,jo,ko),wn.set(this.n,jo.x,jo.y,jo.z),this.d=jo.w},r(e,[{key:"type",get:function(){return this._type}},{key:"x",get:function(){return this.n.x},set:function(e){this.n.x=e}},{key:"y",get:function(){return this.n.y},set:function(e){this.n.y=e}},{key:"z",get:function(){return this.n.z},set:function(e){this.n.z=e}},{key:"w",get:function(){return this.d},set:function(e){this.d=e}}]),e}()),Wo=function(){function e(e,t,n){this._arrayBuffers=[],this._chunkSize=void 0,this._chunkSize=n*(1<<t)}return e.prototype.allocateNewChunk=function(){return new ArrayBuffer(this._chunkSize)},e}();!function(e){e[e.UINT32=0]="UINT32",e[e.FLOAT32=1]="FLOAT32",e[e.NEVER=2]="NEVER"}(Bo||(Bo={}));var Yo,Xo=function(){function e(e,t,n,i,o){void 0===o&&(o=8),this._dataType=void 0,this._dataMembers=void 0,this._elementCount=void 0,this._entryBits=void 0,this._stride=void 0,this._entriesPerChunk=void 0,this._entryMask=void 0,this._chunkMask=void 0,this._poolFlag=void 0,this._arrayBuffers=[],this._freeLists=[],this._uint32BufferViews=[],this._float32BufferViews=[],this._hasUint32=!1,this._hasFloat32=!1,this._nativePool=void 0,this._elementCount=i.COUNT,this._entryBits=o,this._dataType=t,this._dataMembers=n,this._stride=4*this._elementCount,this._entriesPerChunk=1<<o,this._entryMask=this._entriesPerChunk-1,this._poolFlag=1<<30,this._chunkMask=~(this._entryMask|this._poolFlag),this._nativePool=new Wo(e,o,this._stride);var a=Bo.NEVER,r=!1,c=!1;for(var s in t){if(r=this._hasFloat32,(c=this._hasUint32)&&r)break;a=t[s],r||a!==Bo.FLOAT32?c||a!==Bo.UINT32||(this._hasUint32=!0):this._hasFloat32=!0}}var t=e.prototype;return t.alloc=function(){for(var e=0;e<this._freeLists.length;e++){var t=this._freeLists[e];if(t.length){var n=t[t.length-1];return t.length--,(e<<this._entryBits)+n+this._poolFlag}}for(var i=this._nativePool.allocateNewChunk(),o=[],a=[],r=[],c=this._hasFloat32,s=this._hasUint32,l=0;l<this._entriesPerChunk;l++)c&&o.push(new Float32Array(i,this._stride*l,this._elementCount)),s&&a.push(new Uint32Array(i,this._stride*l,this._elementCount)),l&&r.push(l);return s&&this._uint32BufferViews.push(a),c&&this._float32BufferViews.push(o),this._freeLists.push(r),this._arrayBuffers.push(i),(e<<this._entryBits)+this._poolFlag},t.getBuffer=function(e){var t=(this._chunkMask&e)>>this._entryBits,n=this._entryMask&e;return(this._hasFloat32?this._float32BufferViews:this._uint32BufferViews)[t][n]},t.getTypedArray=function(e,t){var n=(this._chunkMask&e)>>this._entryBits,i=this._entryMask&e,o=t,a=(this._dataType[t]===Bo.UINT32?this._uint32BufferViews:this._float32BufferViews)[n][i],r=this._dataMembers[t];return a.subarray(o,o+r)},t.free=function(e){var t=(this._chunkMask&e)>>this._entryBits,n=this._entryMask&e;(this._hasUint32?this._uint32BufferViews:this._float32BufferViews)[t][n].fill(0),this._freeLists[t].push(n)},e}();!function(e){e[e.NODE=0]="NODE",e[e.PASS=1]="PASS",e[e.AABB=2]="AABB"}(Yo||(Yo=e("D",{})));var Ko,Jo=e("N",0);!function(e){e[e.DIRTY_FLAG=0]="DIRTY_FLAG",e[e.LAYER=1]="LAYER",e[e.WORLD_SCALE=2]="WORLD_SCALE",e[e.WORLD_POSITION=5]="WORLD_POSITION",e[e.WORLD_ROTATION=8]="WORLD_ROTATION",e[e.WORLD_MATRIX=12]="WORLD_MATRIX",e[e.LOCAL_SCALE=28]="LOCAL_SCALE",e[e.LOCAL_POSITION=31]="LOCAL_POSITION",e[e.LOCAL_ROTATION=34]="LOCAL_ROTATION",e[e.COUNT=38]="COUNT"}(Ko||(Ko=e("G",{})));var Qo,Zo=((Oo={})[Ko.DIRTY_FLAG]=Bo.UINT32,Oo[Ko.LAYER]=Bo.UINT32,Oo[Ko.WORLD_SCALE]=Bo.FLOAT32,Oo[Ko.WORLD_POSITION]=Bo.FLOAT32,Oo[Ko.WORLD_ROTATION]=Bo.FLOAT32,Oo[Ko.WORLD_MATRIX]=Bo.FLOAT32,Oo[Ko.LOCAL_SCALE]=Bo.FLOAT32,Oo[Ko.LOCAL_POSITION]=Bo.FLOAT32,Oo[Ko.LOCAL_ROTATION]=Bo.FLOAT32,Oo[Ko.COUNT]=Bo.NEVER,Oo),$o=((Lo={})[Ko.DIRTY_FLAG]=Ko.LAYER-Ko.DIRTY_FLAG,Lo[Ko.LAYER]=Ko.WORLD_SCALE-Ko.LAYER,Lo[Ko.WORLD_SCALE]=Ko.WORLD_POSITION-Ko.WORLD_SCALE,Lo[Ko.WORLD_POSITION]=Ko.WORLD_ROTATION-Ko.WORLD_POSITION,Lo[Ko.WORLD_ROTATION]=Ko.WORLD_MATRIX-Ko.WORLD_ROTATION,Lo[Ko.WORLD_MATRIX]=Ko.LOCAL_SCALE-Ko.WORLD_MATRIX,Lo[Ko.LOCAL_SCALE]=Ko.LOCAL_POSITION-Ko.LOCAL_SCALE,Lo[Ko.LOCAL_POSITION]=Ko.LOCAL_ROTATION-Ko.LOCAL_POSITION,Lo[Ko.LOCAL_ROTATION]=Ko.COUNT-Ko.LOCAL_ROTATION,Lo[Ko.COUNT]=1,Lo);e("H",new Xo(Yo.NODE,Zo,$o,Ko)),function(e){e[e.PRIORITY=0]="PRIORITY",e[e.STAGE=1]="STAGE",e[e.PHASE=2]="PHASE",e[e.PRIMITIVE=3]="PRIMITIVE",e[e.BATCHING_SCHEME=4]="BATCHING_SCHEME",e[e.DYNAMIC_STATE=5]="DYNAMIC_STATE",e[e.HASH=6]="HASH",e[e.COUNT=7]="COUNT"}(Qo||(Qo=e("I",{})));var ea,ta=((zo={})[Qo.PRIORITY]=Bo.UINT32,zo[Qo.STAGE]=Bo.UINT32,zo[Qo.PHASE]=Bo.UINT32,zo[Qo.PRIMITIVE]=Bo.UINT32,zo[Qo.BATCHING_SCHEME]=Bo.UINT32,zo[Qo.DYNAMIC_STATE]=Bo.UINT32,zo[Qo.HASH]=Bo.UINT32,zo[Qo.COUNT]=Bo.NEVER,zo),na=((Fo={})[Qo.PRIORITY]=Qo.STAGE-Qo.PRIORITY,Fo[Qo.STAGE]=Qo.PHASE-Qo.STAGE,Fo[Qo.PHASE]=Qo.PRIMITIVE-Qo.PHASE,Fo[Qo.PRIMITIVE]=Qo.BATCHING_SCHEME-Qo.PRIMITIVE,Fo[Qo.BATCHING_SCHEME]=Qo.DYNAMIC_STATE-Qo.BATCHING_SCHEME,Fo[Qo.DYNAMIC_STATE]=Qo.HASH-Qo.DYNAMIC_STATE,Fo[Qo.HASH]=Qo.COUNT-Qo.HASH,Fo[Qo.COUNT]=1,Fo);e("J",new Xo(Yo.PASS,ta,na,Qo)),function(e){e[e.CENTER=0]="CENTER",e[e.HALFEXTENTS=3]="HALFEXTENTS",e[e.COUNT=6]="COUNT"}(ea||(ea=e("K",{})));var ia=((Uo={})[ea.CENTER]=Bo.FLOAT32,Uo[ea.HALFEXTENTS]=Bo.FLOAT32,Uo[ea.COUNT]=Bo.NEVER,Uo),oa=((Go={})[ea.CENTER]=ea.HALFEXTENTS-ea.CENTER,Go[ea.HALFEXTENTS]=ea.COUNT-ea.HALFEXTENTS,Go[ea.COUNT]=1,Go),aa=(e("L",new Xo(Yo.AABB,ia,oa,ea)),new wn),ra=new wn,ca=new wn,sa=new wn,la=new Mn,fa=function(e,t,n){la.m00=Math.abs(n.m00),la.m01=Math.abs(n.m01),la.m02=Math.abs(n.m02),la.m03=Math.abs(n.m04),la.m04=Math.abs(n.m05),la.m05=Math.abs(n.m06),la.m06=Math.abs(n.m08),la.m07=Math.abs(n.m09),la.m08=Math.abs(n.m10),wn.transformMat3(e,t,la)},_a=e("bJ",function(){function e(e,t,n,i,o,a){void 0===e&&(e=0),void 0===t&&(t=0),void 0===n&&(n=0),void 0===i&&(i=1),void 0===o&&(o=1),void 0===a&&(a=1),this.center=void 0,this.halfExtents=void 0,this._type=void 0,this._aabbHandle=Jo,this._type=vi.SHAPE_AABB,this.center=new wn(e,t,n),this.halfExtents=new wn(i,o,a)}e.create=function(t,n,i,o,a,r){return new e(t,n,i,o,a,r)},e.clone=function(t){return new e(t.center.x,t.center.y,t.center.z,t.halfExtents.x,t.halfExtents.y,t.halfExtents.z)},e.copy=function(e,t){return wn.copy(e.center,t.center),wn.copy(e.halfExtents,t.halfExtents),e},e.fromPoints=function(e,t,n){return wn.add(aa,n,t),wn.subtract(ra,n,t),wn.multiplyScalar(e.center,aa,.5),wn.multiplyScalar(e.halfExtents,ra,.5),e},e.set=function(e,t,n,i,o,a,r){return e.center.set(t,n,i),e.halfExtents.set(o,a,r),e},e.merge=function(t,n,i){return wn.subtract(aa,n.center,n.halfExtents),wn.subtract(ra,i.center,i.halfExtents),wn.add(ca,n.center,n.halfExtents),wn.add(sa,i.center,i.halfExtents),wn.max(sa,ca,sa),wn.min(ca,aa,ra),e.fromPoints(t,ca,sa)},e.toBoundingSphere=function(e,t){return e.center.set(t.center),e.radius=t.halfExtents.length(),e},e.transform=function(e,t,n){return wn.transformMat4(e.center,t.center,n),fa(e.halfExtents,t.halfExtents,n),e};var t=e.prototype;return t.getBoundary=function(e,t){wn.subtract(e,this.center,this.halfExtents),wn.add(t,this.center,this.halfExtents)},t.transform=function(e,t,n,i,o){wn.transformMat4(o.center,this.center,e),fa(o.halfExtents,this.halfExtents,e)},t.clone=function(){return e.clone(this)},t.copy=function(t){return e.copy(this,t)},t.mergePoint=function(e){this.getBoundary(aa,ra),e.x<aa.x&&(aa.x=e.x),e.y<aa.y&&(aa.y=e.y),e.z<aa.z&&(aa.z=e.z),e.x>ra.x&&(ra.x=e.x),e.y>ra.y&&(ra.y=e.y),e.z>ra.z&&(ra.z=e.z),wn.add(ca,aa,ra),this.center.set(wn.multiplyScalar(ca,ca,.5)),this.halfExtents.set(ra.x-ca.x,ra.y-ca.y,ra.z-ca.z)},t.mergePoints=function(e){if(!(e.length<1))for(var t=0;t<e.length;t++)this.mergePoint(e[t])},t.mergeFrustum=function(e){return this.mergePoints(e.vertices)},r(e,[{key:"type",get:function(){return this._type}},{key:"native",get:function(){return this._nativeObj}}]),e}()),ua=new wn,ma=new wn,da=new Mn,pa=e("cp",function(){function e(e,t,n,i,o,a,r,c,s,l,f,_,u,m,d){void 0===e&&(e=0),void 0===t&&(t=0),void 0===n&&(n=0),void 0===i&&(i=1),void 0===o&&(o=1),void 0===a&&(a=1),void 0===r&&(r=1),void 0===c&&(c=0),void 0===s&&(s=0),void 0===l&&(l=0),void 0===f&&(f=1),void 0===_&&(_=0),void 0===u&&(u=0),void 0===m&&(m=0),void 0===d&&(d=1),this.center=void 0,this.halfExtents=void 0,this.orientation=void 0,this._type=void 0,this._type=vi.SHAPE_OBB,this.center=new wn(e,t,n),this.halfExtents=new wn(i,o,a),this.orientation=new Mn(r,c,s,l,f,_,u,m,d)}e.create=function(t,n,i,o,a,r,c,s,l,f,_,u,m,d,p){return new e(t,n,i,o,a,r,c,s,l,f,_,u,m,d,p)},e.clone=function(t){return new e(t.center.x,t.center.y,t.center.z,t.halfExtents.x,t.halfExtents.y,t.halfExtents.z,t.orientation.m00,t.orientation.m01,t.orientation.m02,t.orientation.m03,t.orientation.m04,t.orientation.m05,t.orientation.m06,t.orientation.m07,t.orientation.m08)},e.copy=function(e,t){return wn.copy(e.center,t.center),wn.copy(e.halfExtents,t.halfExtents),Mn.copy(e.orientation,t.orientation),e},e.fromPoints=function(e,t,n){return wn.multiplyScalar(e.center,wn.add(ua,t,n),.5),wn.multiplyScalar(e.halfExtents,wn.subtract(ma,n,t),.5),Mn.identity(e.orientation),e},e.set=function(e,t,n,i,o,a,r,c,s,l,f,_,u,m,d,p){return wn.set(e.center,t,n,i),wn.set(e.halfExtents,o,a,r),Mn.set(e.orientation,c,s,l,f,_,u,m,d,p),e};var t=e.prototype;return t.getBoundary=function(e,t){!function(e,t,n){da.m00=Math.abs(n.m00),da.m01=Math.abs(n.m01),da.m02=Math.abs(n.m02),da.m03=Math.abs(n.m03),da.m04=Math.abs(n.m04),da.m05=Math.abs(n.m05),da.m06=Math.abs(n.m06),da.m07=Math.abs(n.m07),da.m08=Math.abs(n.m08),wn.transformMat3(e,t,da)}(ua,this.halfExtents,this.orientation),wn.subtract(e,this.center,ua),wn.add(t,this.center,ua)},t.transform=function(e,t,n,i,o){wn.transformMat4(o.center,this.center,e),Mn.fromQuat(o.orientation,n),wn.multiply(o.halfExtents,this.halfExtents,i)},t.translateAndRotate=function(e,t,n){wn.transformMat4(n.center,this.center,e),Mn.fromQuat(n.orientation,t)},t.setScale=function(e,t){wn.multiply(t.halfExtents,this.halfExtents,e)},r(e,[{key:"type",get:function(){return this._type}}]),e}()),ha=e("cq",function(){function e(e,t,n){void 0===e&&(e=.5),void 0===t&&(t=.5),void 0===n&&(n=1),this._type=void 0,this.radius=void 0,this.halfHeight=void 0,this.axis=void 0,this.center=void 0,this.rotation=void 0,this.ellipseCenter0=void 0,this.ellipseCenter1=void 0,this._type=vi.SHAPE_CAPSULE,this.radius=e,this.halfHeight=t,this.axis=n,this.center=new wn,this.rotation=new zn,this.ellipseCenter0=new wn(0,t,0),this.ellipseCenter1=new wn(0,-t,0),this.updateCache()}var t=e.prototype;return t.transform=function(e,t,n,i,o){var a=i,r=In(a);o.radius=this.radius*Math.abs(r);var c=(this.halfHeight+this.radius)*Math.abs(a.y)-o.radius;c<0&&(c=0),o.halfHeight=c,wn.transformMat4(o.center,this.center,e),zn.multiply(o.rotation,this.rotation,n),o.updateCache()},t.updateCache=function(){this.updateLocalCenter(),wn.transformQuat(this.ellipseCenter0,this.ellipseCenter0,this.rotation),wn.transformQuat(this.ellipseCenter1,this.ellipseCenter1,this.rotation),this.ellipseCenter0.add(this.center),this.ellipseCenter1.add(this.center)},t.updateLocalCenter=function(){var e=this.halfHeight;switch(this.axis){case 0:this.ellipseCenter0.set(e,0,0),this.ellipseCenter1.set(-e,0,0);break;case 1:this.ellipseCenter0.set(0,e,0),this.ellipseCenter1.set(0,-e,0);break;case 2:this.ellipseCenter0.set(0,0,e),this.ellipseCenter1.set(0,0,-e)}},r(e,[{key:"type",get:function(){return this._type}}]),e}()),va=new Array(8);va[0]=new wn(1,1,1),va[1]=new wn(-1,1,1),va[2]=new wn(-1,-1,1),va[3]=new wn(1,-1,1),va[4]=new wn(1,1,-1),va[5]=new wn(-1,1,-1),va[6]=new wn(-1,-1,-1),va[7]=new wn(1,-1,-1);var ga,xa,ya,Ca=new wn,Sa=new wn,Ea=new wn,Pa=e("bL",function(){function e(){this.planes=void 0,this.vertices=void 0,this._type=void 0,this._type=vi.SHAPE_FRUSTUM,this.planes=new Array(6);for(var e=0;e<6;++e)this.planes[e]=qo.create(0,0,0,0);this.vertices=new Array(8);for(var t=0;t<8;++t)this.vertices[t]=new wn}e.createFromAABB=function(e,t){var n=new wn,i=new wn;return wn.subtract(n,t.center,t.halfExtents),wn.add(i,t.center,t.halfExtents),e.vertices[0].set(n.x,i.y,n.z),e.vertices[1].set(i.x,i.y,n.z),e.vertices[2].set(i.x,n.y,n.z),e.vertices[3].set(n.x,n.y,n.z),e.vertices[4].set(n.x,i.y,i.z),e.vertices[5].set(i.x,i.y,i.z),e.vertices[6].set(i.x,n.y,i.z),e.vertices[7].set(n.x,n.y,i.z),e._type!==vi.SHAPE_FRUSTUM_ACCURATE||e.updatePlanes(),e},e.split=function(e,t,n,i,o){var a=Math.tan(.5*t.fov),r=a*t.aspect;Ca.set(i*r,i*a,i),Sa.set(o*r,o*a,o);var c=e.vertices;return Ea.set(Ca.x,Ca.y,Ca.z),wn.transformMat4(c[0],Ea,n),Ea.set(-Ca.x,Ca.y,Ca.z),wn.transformMat4(c[1],Ea,n),Ea.set(-Ca.x,-Ca.y,Ca.z),wn.transformMat4(c[2],Ea,n),Ea.set(Ca.x,-Ca.y,Ca.z),wn.transformMat4(c[3],Ea,n),Ea.set(Sa.x,Sa.y,Sa.z),wn.transformMat4(c[4],Ea,n),Ea.set(-Sa.x,Sa.y,Sa.z),wn.transformMat4(c[5],Ea,n),Ea.set(-Sa.x,-Sa.y,Sa.z),wn.transformMat4(c[6],Ea,n),Ea.set(Sa.x,-Sa.y,Sa.z),wn.transformMat4(c[7],Ea,n),e.updatePlanes(),e},e.create=function(){return new e},e.clone=function(t){return e.copy(new e,t)},e.copy=function(e,t){e._type=t._type;for(var n=0;n<6;++n)qo.copy(e.planes[n],t.planes[n]);for(var i=0;i<8;++i)wn.copy(e.vertices[i],t.vertices[i]);return e};var t=e.prototype;return t.update=function(e,t){if(wn.set(this.planes[0].n,e.m03+e.m00,e.m07+e.m04,e.m11+e.m08),this.planes[0].d=-(e.m15+e.m12),wn.set(this.planes[1].n,e.m03-e.m00,e.m07-e.m04,e.m11-e.m08),this.planes[1].d=-(e.m15-e.m12),wn.set(this.planes[2].n,e.m03+e.m01,e.m07+e.m05,e.m11+e.m09),this.planes[2].d=-(e.m15+e.m13),wn.set(this.planes[3].n,e.m03-e.m01,e.m07-e.m05,e.m11-e.m09),this.planes[3].d=-(e.m15-e.m13),wn.set(this.planes[4].n,e.m03+e.m02,e.m07+e.m06,e.m11+e.m10),this.planes[4].d=-(e.m15+e.m14),wn.set(this.planes[5].n,e.m03-e.m02,e.m07-e.m06,e.m11-e.m10),this.planes[5].d=-(e.m15-e.m14),this._type===vi.SHAPE_FRUSTUM_ACCURATE){for(var n=0;n<6;n++){var i=this.planes[n],o=1/i.n.length();wn.multiplyScalar(i.n,i.n,o),i.d*=o}for(var a=0;a<8;a++)wn.transformMat4(this.vertices[a],va[a],t)}},t.transform=function(e){if(this._type===vi.SHAPE_FRUSTUM_ACCURATE){for(var t=0;t<8;t++)wn.transformMat4(this.vertices[t],this.vertices[t],e);this.updatePlanes()}},t.updatePlanes=function(){qo.fromPoints(this.planes[0],this.vertices[1],this.vertices[6],this.vertices[5]),qo.fromPoints(this.planes[1],this.vertices[3],this.vertices[4],this.vertices[7]),qo.fromPoints(this.planes[2],this.vertices[6],this.vertices[3],this.vertices[7]),qo.fromPoints(this.planes[3],this.vertices[0],this.vertices[5],this.vertices[4]),qo.fromPoints(this.planes[4],this.vertices[2],this.vertices[0],this.vertices[3]),qo.fromPoints(this.planes[5],this.vertices[7],this.vertices[5],this.vertices[6])},r(e,[{key:"accurate",set:function(e){this._type=e?vi.SHAPE_FRUSTUM_ACCURATE:vi.SHAPE_FRUSTUM}},{key:"type",get:function(){return this._type}}]),e}());function Ia(e,t,n){void 0===n&&(n=1e-6);for(var i=0,o=e.length-1,a=o>>>1;i<=o;a=i+o>>>1){var r=e[a];if(r>t+n)o=a-1;else{if(!(r<t-n))return a;i=a+1}}return~i}Pa.createOrtho=function(e,t,n,i,o,a){var r=t/2,c=n/2;wn.set(Ea,r,c,-i),wn.transformMat4(e.vertices[0],Ea,a),wn.set(Ea,-r,c,-i),wn.transformMat4(e.vertices[1],Ea,a),wn.set(Ea,-r,-c,-i),wn.transformMat4(e.vertices[2],Ea,a),wn.set(Ea,r,-c,-i),wn.transformMat4(e.vertices[3],Ea,a),wn.set(Ea,r,c,-o),wn.transformMat4(e.vertices[4],Ea,a),wn.set(Ea,-r,c,-o),wn.transformMat4(e.vertices[5],Ea,a),wn.set(Ea,-r,-c,-o),wn.transformMat4(e.vertices[6],Ea,a),wn.set(Ea,r,-c,-o),wn.transformMat4(e.vertices[7],Ea,a),qo.fromPoints(e.planes[0],e.vertices[1],e.vertices[6],e.vertices[5]),qo.fromPoints(e.planes[1],e.vertices[3],e.vertices[4],e.vertices[7]),qo.fromPoints(e.planes[2],e.vertices[6],e.vertices[3],e.vertices[7]),qo.fromPoints(e.planes[3],e.vertices[0],e.vertices[5],e.vertices[4]),qo.fromPoints(e.planes[4],e.vertices[2],e.vertices[0],e.vertices[3]),qo.fromPoints(e.planes[5],e.vertices[7],e.vertices[5],e.vertices[6])},function(e){e[e.Default=0]="Default",e[e.Normal=1]="Normal",e[e.Loop=2]="Loop",e[e.ShouldWrap=4]="ShouldWrap",e[e.Clamp=8]="Clamp",e[e.PingPong=22]="PingPong",e[e.Reverse=36]="Reverse"}(ga||(ga=e("dL",{}))),function(e){e[e.Default=ga.Default]="Default",e[e.Normal=ga.Normal]="Normal",e[e.Reverse=ga.Reverse]="Reverse",e[e.Loop=ga.Loop]="Loop",e[e.LoopReverse=ga.Loop|ga.Reverse]="LoopReverse",e[e.PingPong=ga.PingPong]="PingPong",e[e.PingPongReverse=ga.PingPong|ga.Reverse]="PingPongReverse"}(xa||(xa=e("dK",{}))),F(xa),e("dM",function(){function e(e){this.ratio=0,this.time=0,this.direction=1,this.stopped=!0,this.iterations=0,this.frameIndex=void 0,e&&this.set(e)}return e.prototype.set=function(e){this.ratio=e.ratio,this.time=e.time,this.direction=e.direction,this.stopped=e.stopped,this.iterations=e.iterations,this.frameIndex=e.frameIndex},e}()),ya=Symbol.iterator;var Ta,ba,Aa,wa=function(){function e(){this._times=[],this._values=[]}var t=e.prototype;return t[ya]=function(){var e=this,t=0;return{next:function(){if(t>=e._times.length)return{done:!0,value:void 0};var n=[e._times[t],e._values[t]];return++t,{done:!1,value:n}}}},t.keyframes=function(){return this},t.times=function(){return this._times},t.values=function(){return this._values},t.getKeyframeTime=function(e){return this._times[e]},t.getKeyframeValue=function(e){return this._values[e]},t.addKeyFrame=function(e,t){return this._insertNewKeyframe(e,t)},t.removeKeyframe=function(e){this._times.splice(e,1),this._values.splice(e,1)},t.indexOfKeyframe=function(e){return Ia(this._times,e)},t.updateTime=function(e,t){var n=this._values[e];this.removeKeyframe(e),this._insertNewKeyframe(t,n)},t.assignSorted=function(e,t){if(void 0!==t)this.setKeyframes(e.slice(),t.slice());else{var n=Array.from(e);this.setKeyframes(n.map((function(e){return e[0]})),n.map((function(e){return e[1]})))}},t.clear=function(){this._times.length=0,this._values.length=0},t.searchKeyframe=function(e){return Ia(this._times,e)},t.setKeyframes=function(e,t){U(e.length===t.length),U(function(e){return e.every((function(e,t,n){return 0===t||e>n[t-1]||pn(e,n[t-1],1e-6)}))}(e)),this._times=e,this._values=t},t._insertNewKeyframe=function(e,t){var n=this._times,i=this._values,o=n.length,a=Ia(n,e);if(a>=0)return a;var r=~a;return 0===r?(n.unshift(e),i.unshift(t)):r===o?(n.push(e),i.push(t)):(n.splice(r-1,0,e),i.splice(r-1,0,t)),r},r(e,[{key:"keyFramesCount",get:function(){return this._times.length}},{key:"rangeMin",get:function(){return this._times[0]}},{key:"rangeMax",get:function(){return this._times[this._values.length-1]}}]),e}();function Na(e){return e>-1e-9&&e<1e-9}c.fastDefine("cc.KeyframeCurve",wa,{_times:[],_values:[]}),function(e){e[e.LINEAR=0]="LINEAR",e[e.CONSTANT=1]="CONSTANT",e[e.CUBIC=2]="CUBIC"}(Ta||(Ta=e("bq",{}))),function(e){e[e.LINEAR=0]="LINEAR",e[e.CLAMP=1]="CLAMP",e[e.LOOP=2]="LOOP",e[e.PING_PONG=3]="PING_PONG"}(ba||(ba=e("br",{}))),function(e){e[e.NONE=0]="NONE",e[e.LEFT=1]="LEFT",e[e.RIGHT=2]="RIGHT",e[e.BOTH=3]="BOTH"}(Aa||(Aa=e("bs",{})));var Da=function(){},Ra=function(){return Da},Ma=Oa((function(){}));function Oa(e){return function(t){return"function"==typeof t?e(t):function(n){return e(n,t)}}}function La(e){return function(t){return function(n){!function(e,t,n){var i=Fa(e);if(i){var o=Ua(i,"proto");Ua(o,"editor")[t]=n}}(n,e,t)}}}var za="__ccclassCache__";function Fa(e){return Ua(e,za)}function Ua(e,t){return e[t]||(e[t]={})}var Ga=e("bW",Oa((function(e,t){var n=G.getSuper(e);n===Object&&(n=null);var i={name:t,extends:n,ctor:e},o=e[za];if(o){var a=o.proto;a&&G.mixin(i,a),e[za]=void 0}return c(i)}))),Ba=e("dQ",La("requireComponent")),Ha=e("ds",La("executionOrder")),Va=e("dP",Ma);function ka(e,t,n){var i=null;function o(e,t,n){!function(e,t,n,i,o,a){var r,c=a&&(a.get||a.set);o&&(r=B(o,c));var s=G.mixin(t,r||o||{});c?(a.get&&(s.get=a.get),a.set&&(s.set=a.set)):qa(e,s,n,i,a)}(function(e){return Fa(e.constructor)}(e),function(e,t){var n,i,o=Ua(Fa(e.constructor),"proto"),a=Ua(o,"properties");return null!==(i=a[n=t])&&void 0!==i?i:a[n]={}}(e,t),e.constructor,t,i,n)}return void 0===e?ka({type:void 0}):void 0===t?(i=e,o):void o(e,t,n)}function ja(e,t,n){var i,o,a=Fa(e.constructor),r=Ua(a,"proto"),c=Ua(r,"properties"),s=null!==(o=c[i=t])&&void 0!==o?o:c[i]={};return s.__internalFlags|=H.STANDALONE,n&&(n.get||n.set)?(n.get&&(s.get=n.get),n.set&&(s.set=n.set)):qa(a,s,e.constructor,t,n),s}function qa(e,t,n,i,o){if(o)o.initializer&&(t.default=function(e){var t;try{t=e()}catch(t){return e}return"object"!=typeof t||null===t?t:e}(o.initializer));else{var a=e.default||(e.default=function(e){var t;try{t=new e}catch(e){return{}}return t}(n));a.hasOwnProperty(i)&&(t.default=a[i])}}var Wa=Symbol("cc:SerializationMetadata"),Ya=e("bX",(function(e,t,n){Ja(ja(e,t,n))}));function Xa(e){return function(t,n,i){var o=ja(t,n,i);o.formerlySerializedAs=e,Ja(o)}}var Ka=e("d_",(function(e,t,n){var i=ja(e,t,n);i.editorOnly=!0,Ja(i)}));function Ja(e){e.__internalFlags|=H.IMPLICIT_SERIALIZABLE}var Qa=e("dG",Da),Za=e("cd",Ma),$a=e("ch",Ra),er=e("e1",Ma),tr=Ra,nr=Ra,ir=e("cg",Ra),or=e("b$",Da),ar=e("ci",Ra),rr=e("e2",Da),cr=e("de",Ra),sr=e("cc",Ra),lr=e("dj",Ra),fr=e("dY",Ra),_r=(e("dZ",Ra),Ra),ur=e("di",Da),mr=e("bY",Ra),dr=(e("e0",Da),e("dO",Da),e("dr",Da)),pr=xr(q),hr=e("dB",xr(V)),vr=xr(k),gr=e("dN",xr(j));function xr(e){return ka({type:e})}var yr=e("dz",(function(e,t,n){ja(e,t,n).override=!0})),Cr=e("dC",(function(){})),Sr=Object.freeze({__proto__:null,uniquelyReferenced:Qa,ccclass:Ga,property:ka,requireComponent:Ba,executionOrder:Ha,disallowMultiple:Va,allowReplicated:function(e){c.Attr.setClassAttr(e,"replicated","visible",!0)},executeInEditMode:Za,menu:$a,playOnFocus:er,inspector:tr,icon:nr,help:ir,type:xr,integer:pr,float:hr,boolean:vr,string:gr});e("aD",Sr);var Er=e("cE",function(){function e(e){this._map=null,this._count=0,e?(this._map=e,this._count=Object.keys(e).length):(this._map=G.createMap(!0),this._count=0)}var t=e.prototype;return t.add=function(e,t){return e in this._map||this._count++,this._map[e]=t},t.get=function(e){return this._map[e]},t.has=function(e){return e in this._map},t.remove=function(e){var t=this._map[e];return e in this._map&&(delete this._map[e],this._count--),t},t.clear=function(){0!==this._count&&(this._map=G.createMap(!0),this._count=0)},t.forEach=function(e){for(var t in this._map)e(this._map[t],t)},t.find=function(e){for(var t in this._map)if(e(this._map[t],t))return this._map[t];return null},t.destroy=function(){this._map=null},r(e,[{key:"count",get:function(){return this._count}}]),e}()),Pr=e("c$",function(){function e(t,n){this.id=e._pipelineId++,this.name="",this.pipes=[],this.name=t;for(var i=0,o=n.length;i<o;i++)this.pipes.push(n[i])}var t=e.prototype;return t.insert=function(e,t){return t>this.pipes.length?(W(4921),this):(this.pipes.splice(t,0,e),this)},t.append=function(e){return this.pipes.push(e),this},t.remove=function(e){return this.pipes.splice(e,1),this},t.sync=function(e){var t=this.pipes;if(0===t.length)return null;e.isFinish=!1;for(var n=0,i=t.length;n<i;){var o=(0,t[n])(e);if(o)return e.isFinish=!0,o;++n!==i&&(e.input=e.output,e.output=null)}return e.isFinish=!0,e.output},t.async=function(e){0!==this.pipes.length&&(e.isFinish=!1,this._flow(0,e))},t._flow=function(e,t){var n=this;(0,this.pipes[e])(t,(function(i){i?(t.isFinish=!0,t.dispatch("complete",i)):++e<n.pipes.length?(t.input=t.output,t.output=null,n._flow(e,t)):(t.isFinish=!0,t.dispatch("complete",i,t.output))}))},e}());Pr._pipelineId=0,function(){function e(e){if(this._weakMap={},void 0===window.WeakRef)throw new Error("this platform does not support WeakRef!");if(e)for(var t in e)this._weakMap[t]=new WeakRef(e[t])}var t=e.prototype;t.add=function(e,t){return this._weakMap[e]=new WeakRef(t),t},t.has=function(e){return e in this._weakMap&&!!this._weakMap[e].deref()},t.get=function(e){return this._weakMap[e]&&this._weakMap[e].deref()},t.remove=function(e){var t=this._weakMap[e];return delete this._weakMap[e],t&&t.deref()},t.clear=function(){this._weakMap=G.createMap(!0)},t.forEach=function(e){for(var t in this._weakMap){var n=this.get(t);n&&e(n,t)}},t.find=function(e){for(var t in this._weakMap){var n=this.get(t);if(n&&e(n,t))return this._weakMap[t].deref()}return null},t.destroy=function(){this._weakMap={}},r(e,[{key:"count",get:function(){return Object.values(this._weakMap).filter((function(e){return e.deref()})).length}}])}(),e("cH",new Er);var Ir,Tr,br=e("cO",new Er),Ar=e("cZ",new Er),wr=e("cM",new Er),Nr=(e("d1",new Pr("normal load",[])),e("cX",new Pr("fetch",[])),e("d2",new Pr("transform url",[])));e("d5",null),function(e){e.UUID="uuid",e.PATH="path",e.DIR="dir",e.URL="url",e.SCENE="scene"}(Ir||(Ir=e("cN",{}))),e("d3",{default:{priority:0},preload:{maxConcurrency:6,maxRequestsPerFrame:2,priority:-1},scene:{maxConcurrency:20,maxRequestsPerFrame:20,priority:1},bundle:{maxConcurrency:20,maxRequestsPerFrame:20,priority:2},remote:{maxRetryCount:4}}),function(e){e.RESOURCES="resources",e.MAIN="main",e.START_SCENE="start-scene"}(Tr||(Tr=e("cS",{})));var Dr=e("cW",function(){function e(t){this.id=e._taskId++,this.onComplete=null,this.onProgress=null,this.onError=null,this.source=null,this.output=null,this.input=null,this.progress=null,this.options=null,this.isFinish=!0,this.set(t)}e.create=function(t){var n;return 0!==e._deadPool.length?(n=e._deadPool.pop()).set(t):n=new e(t),n};var t=e.prototype;return t.set=function(e){void 0===e&&(e=Object.create(null)),this.onComplete=e.onComplete||null,this.onProgress=e.onProgress||null,this.onError=e.onError||null,this.source=this.input=e.input,this.output=null,this.progress=e.progress,this.options=e.options||Object.create(null)},t.dispatch=function(e,t,n,i,o){switch(e){case"complete":this.onComplete&&this.onComplete(t,n);break;case"progress":this.onProgress&&this.onProgress(t,n,i,o);break;case"error":this.onError&&this.onError(t,n,i,o);break;default:var a="on"+e[0].toUpperCase()+e.substr(1);"function"==typeof this[a]&&this[a](t,n,i,o)}},t.recycle=function(){e._deadPool.length!==e.MAX_DEAD_NUM&&(this.onComplete=null,this.onProgress=null,this.onError=null,this.source=this.output=this.input=null,this.progress=null,this.options=null,e._deadPool.push(this))},e}());Dr.MAX_DEAD_NUM=500,Dr._taskId=0,Dr._deadPool=[];var Rr="0123456789abcdef".split(""),Mr=["","","",""],Or=Mr.concat(Mr,"-",Mr,"-",Mr,"-",Mr,"-",Mr,Mr,Mr),Lr=Or.map((function(e,t){return"-"===e?NaN:t})).filter(isFinite);function zr(e){var t=e.split("@")[0];if(22!==t.length)return e;Or[0]=e[0],Or[1]=e[1];for(var n=2,i=2;n<22;n+=2){var o=Y[e.charCodeAt(n)],a=Y[e.charCodeAt(n+1)];Or[Lr[i++]]=Rr[o>>2],Or[Lr[i++]]=Rr[(3&o)<<2|a>>4],Or[Lr[i++]]=Rr[15&a]}return e.replace(t,Or.join(""))}var Fr=/.*[/\\][0-9a-fA-F]{2}[/\\]([0-9a-fA-F-@]{8,}).*/;function Ur(e){var t=Fr.exec(e);return t?t[1]:""}function Gr(e,t){(t=t||Object.create(null)).__isNative__=t.isNative,t.nativeExt&&(t.ext=t.nativeExt);var n=wr.find((function(t){return!!t.getAssetInfo(e)}));return n&&(t.bundle=n.name),Vr(e,t)}function Br(e){return!!e&&(e instanceof s.SceneAsset||e instanceof s.Scene)}function Hr(e){return e&&(46===e.charCodeAt(0)&&47===e.charCodeAt(1)?e=e.slice(2):47===e.charCodeAt(0)&&(e=e.slice(1))),e}function Vr(e,t){var n=Dr.create({input:e,options:t}),i=[];try{for(var a,r=Nr.sync(n),c=X(r);!(a=c()).done;){var s=a.value,l=s.url;s.recycle(),i.push(l)}}catch(e){for(var f,_=X(n.output);!(f=_()).done;)f.value.recycle();o(e.message,e.stack)}return n.recycle(),i.length>1?i:i[0]}e("d4",Object.freeze({__proto__:null,getUuidFromURL:Ur,getUrlWithUuid:Gr,isScene:Br,normalize:Hr,transform:Vr,decodeUuid:zr}));var kr,jr,qr,Wr,Yr,Xr,Kr,Jr,Qr=function(){function e(){this._finalizationRegistry=null}var t=e.prototype;return t.registerGCObject=function(e){return e},t.unregisterGCObject=function(){},t.init=function(){},t.finalizationRegistryCallback=function(e){e.isValid&&e.destroy()},t.destroy=function(){},e}(),Zr=e("c8",new Qr),$r=Ga("cc.GCObject")(kr=function(e){function t(){for(var t,n=arguments.length,i=new Array(n),o=0;o<n;o++)i[o]=arguments[o];return t=e.call.apply(e,[this].concat(i))||this,Zr.registerGCObject(J(t))||J(t)}a(t,e);var n=t.prototype;return n.equals=function(e){return!!e&&e===this},n.destroy=function(){return Zr.unregisterGCObject(this),e.prototype.destroy.call(this)},t}(K))||kr,ec=e("aL",Ga("cc.Asset")((Yr=function(e){function t(){for(var t,n=arguments.length,i=new Array(n),o=0;o<n;o++)i[o]=arguments[o];return(t=e.call.apply(e,[this].concat(i))||this).loaded=!0,te(t,"_native",Wr,J(t)),t._nativeUrl="",t._file=null,t._ref=0,Object.defineProperty(J(t),"_uuid",{value:"",writable:!0}),t}a(t,e),t.deserialize=function(e){return s.deserialize(e)};var n=t.prototype;return n.toString=function(){return this.nativeUrl},n.serialize=function(){},n._setRawAsset=function(e,t){void 0===t&&(t=!0),this._native=!1!==t?e||"":"/"+e},n.addRef=function(){return this._ref++,this},n.decRef=function(e){return void 0===e&&(e=!0),this._ref>0&&this._ref--,e&&s.assetManager._releaseManager.tryRelease(this),this},n.onLoaded=function(){},n.initDefault=function(e){e&&(this._uuid=e),this.isDefault=!0},n.validate=function(){return!0},n.destroy=function(){return Q(Z(12101,this._uuid)),e.prototype.destroy.call(this)},r(t,[{key:"nativeUrl",get:function(){if(!this._nativeUrl){if(!this._native)return"";var e=this._native;if(47===e.charCodeAt(0))return e.slice(1);46===e.charCodeAt(0)?this._nativeUrl=Gr(this._uuid,{nativeExt:e,isNative:!0}):this._nativeUrl=Gr(this._uuid,{__nativeName__:e,nativeExt:Yt(e),isNative:!0})}return this._nativeUrl}},{key:"_nativeAsset",get:function(){return this._file},set:function(e){this._file=e}},{key:"_nativeDep",get:function(){if(this._native)return{__isNative__:!0,uuid:this._uuid,ext:this._native}}},{key:"refCount",get:function(){return this._ref}}]),t}($($r)),Wr=ee((qr=Yr).prototype,"_native",[Ya],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return""}}),ee(qr.prototype,"_nativeAsset",[ka],Object.getOwnPropertyDescriptor(qr.prototype,"_nativeAsset"),qr.prototype),jr=qr))||jr);ec.prototype.createNode=null,s.Asset=ec;var tc=e("aY",Ga("cc.Script")(Xr=function(e){function t(){return e.apply(this,arguments)||this}return a(t,e),t}(ec))||Xr);s._Script=tc;var nc=e("aZ",Ga("cc.JavaScript")(Kr=function(e){function t(){return e.apply(this,arguments)||this}return a(t,e),t}(tc))||Kr);s._JavaScript=nc;var ic,oc,ac,rc,cc,sc,lc,fc,_c,uc,mc,dc=e("a_",Ga("cc.TypeScript")(Jr=function(e){function t(){return e.apply(this,arguments)||this}return a(t,e),t}(tc))||Jr);s._TypeScript=dc;var pc,hc,vc,gc,xc=new ae("Comp"),yc=K.Flags.IsOnLoadCalled,Cc=e("bm",(ic=Ga("cc.Component"),oc=cr(),ac=xr(tc),rc=sr(),ic((mc=uc=function(e){function t(){for(var t,n=arguments.length,i=new Array(n),o=0;o<n;o++)i[o]=arguments[o];return t=e.call.apply(e,[this].concat(i))||this,te(t,"node",lc,J(t)),te(t,"_enabled",fc,J(t)),te(t,"__prefab",_c,J(t)),t._sceneGetter=null,t._id=xc.getNewId(),t}a(t,e);var n=t.prototype;return n._getRenderScene=function(){return this._sceneGetter?this._sceneGetter():this.node.scene.renderScene},n.addComponent=function(e){return this.node.addComponent(e)},n.getComponent=function(e){return this.node.getComponent(e)},n.getComponents=function(e){return this.node.getComponents(e)},n.getComponentInChildren=function(e){return this.node.getComponentInChildren(e)},n.getComponentsInChildren=function(e){return this.node.getComponentsInChildren(e)},n.destroy=function(){return!!e.prototype.destroy.call(this)&&(this._enabled&&this.node.activeInHierarchy&&s.director._compScheduler.disableComp(this),!0)},n._onPreDestroy=function(){this.unscheduleAllCallbacks(),s.director._nodeActivator.destroyComp(this),this.node._removeComponent(this)},n._instantiate=function(e){return e||(e=s.instantiate._clone(this,this)),e&&(e.node=null),e},n.schedule=function(e,t,n,i){void 0===t&&(t=0),void 0===n&&(n=s.macro.REPEAT_FOREVER),void 0===i&&(i=0),ne(e,1619),ne((t=t||0)>=0,1620),n=Number.isNaN(n)?s.macro.REPEAT_FOREVER:n,i=i||0;var o=s.director.getScheduler(),a=o.isTargetPaused(this);o.schedule(e,this,t,n,i,a)},n.scheduleOnce=function(e,t){void 0===t&&(t=0),this.schedule(e,0,0,t)},n.unschedule=function(e){e&&s.director.getScheduler().unschedule(e,this)},n.unscheduleAllCallbacks=function(){s.director.getScheduler().unscheduleAllForTarget(this)},r(t,[{key:"name",get:function(){if(this._name)return this._name;var e=oe(this),t=e.lastIndexOf(".");return t>=0&&(e=e.slice(t+1)),this.node?this.node.name+"<"+e+">":e},set:function(e){this._name=e}},{key:"uuid",get:function(){return this._id}},{key:"__scriptAsset",get:function(){return null}},{key:"enabled",get:function(){return this._enabled},set:function(e){if(this._enabled!==e&&(this._enabled=e,this.node.activeInHierarchy)){var t=s.director._compScheduler;e?t.enableComp(this):t.disableComp(this)}}},{key:"enabledInHierarchy",get:function(){return this._enabled&&this.node&&this.node.activeInHierarchy}},{key:"_isOnLoadCalled",get:function(){return this._objFlags&yc}}]),t}(K),uc.system=null,ee((sc=mc).prototype,"__scriptAsset",[oc,ac,rc,dr],Object.getOwnPropertyDescriptor(sc.prototype,"__scriptAsset"),sc.prototype),lc=ee(sc.prototype,"node",[Ya],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return null}}),fc=ee(sc.prototype,"_enabled",[Ya],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return!0}}),_c=ee(sc.prototype,"__prefab",[Ya],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return null}}),cc=sc))||cc)),Sc=Cc.prototype;Sc.update=null,Sc.lateUpdate=null,Sc.__preload=null,Sc.onLoad=null,Sc.start=null,Sc.onEnable=null,Sc.onDisable=null,Sc.onDestroy=null,Sc.onFocusInEditor=null,Sc.onLostFocusInEditor=null,Sc.resetInEditor=null,Sc._getLocalBounds=null,Sc.onRestore=null,Cc._requireComponent=null,Cc._executionOrder=0,ie(Cc,"_registerEditorProps",(function(e,t){var n=t.requireComponent;n&&(Array.isArray(n)&&(n=n.filter(Boolean)),e._requireComponent=n);var i=t.executionOrder;i&&"number"==typeof i&&(e._executionOrder=i)})),s.Component=Cc;var Ec=e("bl",Ga("cc.MissingScript")(pc=tr()((gc=function(e){function t(){var t;return t=e.call(this)||this,te(t,"_$erialized",vc,J(t)),t}return a(t,e),t.safeFindClass=function(e){var t=re(e);if(t)return t;s.deserialize.reportMissingClass(e)},t.prototype.onLoad=function(){W(4600,this.node.name)},t}(Cc),vc=ee((hc=gc).prototype,"_$erialized",[Ya,Ka],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return null}}),pc=hc))||pc)||pc);s._MissingScript=Ec;try{var Pc=Ec.__values__;0!==Pc.length&&"_$erialized"===Pc[Pc.length-1]||(o("The '_$erialized' prop in MissingScript is missing. Please contact jare."),o("    Error props: ['"+Pc+"']"))}catch(mi){o("Error when checking MissingScript 5, "+mi)}try{if(ce&&t.os===n.IOS&&!se.isDevTool){var Ic=my.getFileSystemManager();JSON.parse(Ic.readFileSync({filePath:"game.json",encoding:"utf8"}).data).screenOrientation}}catch(mi){console.error(mi)}var Tc=function(e){function t(){var t,n;return(t=e.call(this)||this).isFrameRotated=!1,t.handleResizeEvent=!0,t._cbToUpdateFrameBuffer=void 0,t._resolutionScale=1,t._isProportionalToFrame=!1,null===(n=se.onWindowResize)||void 0===n||n.call(se,(function(){t.emit("window-resize")})),t}a(t,e);var n=t.prototype;return n.init=function(e,t){this._cbToUpdateFrameBuffer=t,this._cbToUpdateFrameBuffer()},n.requestFullScreen=function(){return Promise.reject(new Error("request fullscreen is not supported on this platform."))},n.exitFullScreen=function(){return Promise.reject(new Error("exit fullscreen is not supported on this platform."))},r(t,[{key:"supportFullScreen",get:function(){return!1}},{key:"isFullScreen",get:function(){return!1}},{key:"devicePixelRatio",get:function(){return se.getSystemInfoSync().pixelRatio}},{key:"windowSize",get:function(){var e=se.getSystemInfoSync(),t=this.devicePixelRatio,n=e.screenWidth,i=e.screenHeight;return new ti(n*t,i*t)},set:function(){W(1221)}},{key:"resolution",get:function(){var e=this.windowSize,t=this.resolutionScale;return new ti(e.width*t,e.height*t)}},{key:"resolutionScale",get:function(){return this._resolutionScale},set:function(e){var t;e!==this._resolutionScale&&(this._resolutionScale=e,null===(t=this._cbToUpdateFrameBuffer)||void 0===t||t.call(this))}},{key:"orientation",get:function(){return se.orientation},set:function(){console.warn("Setting orientation is not supported yet.")}},{key:"safeAreaEdge",get:function(){var e=se.getSafeArea(),t=this.windowSize,n=this.devicePixelRatio,i=e.top*n,o=t.height-e.bottom*n,a=e.left*n,r=t.width-e.right*n;return this.orientation===le.PORTRAIT?i<o?i=o:o=i:a<r?a=r:r=a,{top:i,bottom:o,left:a,right:r}}},{key:"isProportionalToFrame",get:function(){return this._isProportionalToFrame},set:function(){}}]),t}(fe),bc=e("ca",new Tc),Ac=function(){function e(){}var t=e.prototype;return t._init=function(e){bc.init(e,(function(){var e,t=s.director;(null===(e=t.root)||void 0===e?void 0:e.pipeline)?t.root.pipeline.pipelineSceneData.shadingScale=bc.resolutionScale:W(1220)}))},t.fullScreen=function(){return bc.isFullScreen},t.requestFullScreen=function(e,t,n){return arguments.length>0&&W(1400,"screen.requestFullScreen(element, onFullScreenChange?, onFullScreenError?)","screen.requestFullScreen(): Promise"),bc.requestFullScreen().then((function(){null==t||t()})).catch((function(e){console.error(e),null==n||n()}))},t.exitFullScreen=function(){return bc.exitFullScreen()},t.autoFullScreen=function(e,t){var n;null===(n=this.requestFullScreen(e,t))||void 0===n||n.catch((function(){}))},t.disableAutoFullScreen=function(){},r(e,[{key:"devicePixelRatio",get:function(){return bc.devicePixelRatio}},{key:"windowSize",get:function(){return bc.windowSize},set:function(e){bc.windowSize=e}},{key:"resolution",get:function(){return bc.resolution}},{key:"supportsFullScreen",get:function(){return bc.supportFullScreen}}]),e}(),wc=e("a$",new Ac);s.screen=wc;var Nc=e("b0",{Feature:_e,hasFeature:function(e){return t.hasFeature(e)},NetworkType:ue,Language:me,OS:n,Platform:de,BrowserType:pe,isNative:t.isNative,isBrowser:t.isBrowser,isMobile:t.isMobile,isLittleEndian:t.isLittleEndian,platform:t.platform,language:t.language,languageCode:t.nativeLanguage,os:t.os,osVersion:t.osVersion,osMainVersion:t.osMainVersion,browserType:t.browserType,browserVersion:t.browserVersion,windowPixelResolution:wc.windowSize,capabilities:{canvas:!0,opengl:!0,webp:t.hasFeature(_e.WEBP),imageBitmap:t.hasFeature(_e.IMAGE_BITMAP),touches:t.hasFeature(_e.INPUT_TOUCH),mouse:t.hasFeature(_e.EVENT_MOUSE),keyboard:t.hasFeature(_e.EVENT_KEYBOARD),accelerometer:t.hasFeature(_e.EVENT_ACCELEROMETER)},localStorage:{},getNetworkType:function(){return t.networkType},getBatteryLevel:function(){return t.getBatteryLevel()},garbageCollect:function(){t.triggerGC()},isObjectValid:function(e){return null!=e},dump:function(){var e="";e+="isMobile : "+this.isMobile+"\r\n",e+="language : "+this.language+"\r\n",e+="browserType : "+this.browserType+"\r\n",e+="browserVersion : "+this.browserVersion+"\r\n",e+="capabilities : "+JSON.stringify(this.capabilities)+"\r\n",e+="os : "+this.os+"\r\n",e+="osVersion : "+this.osVersion+"\r\n",e+="platform : "+this.platform+"\r\n",e+="Using "+(s.game.renderType===s.game.RENDER_TYPE_WEBGL?"WEBGL":"CANVAS")+" renderer.\r\n",he(e)},openURL:function(e){t.openURL(e)},now:function(){return t.now()},restartVM:function(){t.restartJSVM()},getSafeAreaRect:function(){var e=s.view,t=bc.safeAreaEdge,n=bc.windowSize,i=new Xn(t.left,t.bottom),o=new Xn(n.width-t.right,n.height-t.top);e._convertToUISpace(i),e._convertToUISpace(o);var a=i.x,r=i.y,c=o.x-i.x,l=o.y-i.y;return new ii(a,r,c,l)}});!function(){try{var e=Nc.localStorage=window.localStorage;e.setItem("storage",""),e.removeItem("storage"),e=null}catch(e){var t=function(){W(5200)};Nc.localStorage={getItem:t,setItem:t,clear:t,removeItem:t}}var i;Nc.__isWebIOS14OrIPadOS14Env=(Nc.os===n.IOS||Nc.os===n.OSX)&&(null===(i=GameGlobal)||void 0===i?void 0:i.isIOSHighPerformanceMode)&&/(OS 1[4-9])|(Version\/1[4-9])/.test(window.navigator.userAgent)}(),s.sys=Nc;var Dc=e("aK",Symbol("[[Serialize]]")),Rc=e("aJ",Symbol("[[Deserialize]]")),Mc=e("cR",function(){function e(e,t){this._document=void 0,this._chunks=void 0,this._document=e,this._chunks=t}return r(e,[{key:"document",get:function(){return this._document}},{key:"chunks",get:function(){return this._chunks}}]),e}());function Oc(e){var t=e;return{chunks:t.chunks,document:t.document}}function Lc(e){if(e.length<16)throw new zc(Z(13102));var t=new DataView(e.buffer,e.byteOffset,e.byteLength);if(1313817411!==t.getUint32(0,!0))throw new zc(Z(13100));var n=t.getUint32(4,!0);if(1!==n)throw new zc(Z(13101,n));if(t.getUint32(8,!0)!==t.byteLength)throw new zc(Z(13102));var i=12,o=t.getUint32(i,!0);i+=4;var a=new Uint8Array(t.buffer,i+t.byteOffset,o);i+=o;var r,c=function(e){if("undefined"!=typeof TextDecoder)return(new TextDecoder).decode(e);if("Buffer"in globalThis)return globalThis.Buffer.from(e.buffer,e.byteOffset,e.byteLength).toString();throw new Error(Z(13104))}(a);try{r=JSON.parse(c)}catch(e){throw new zc(e)}for(var s=[];i<t.byteLength;){i%8!=0&&(i+=8-i%8);var l=t.getUint32(i,!0);i+=4,s.push(new Uint8Array(t.buffer,i+t.byteOffset,l)),i+=l}if(i!==t.byteLength)throw new zc(Z(13102));return new Mc(r,s)}var zc=function(e){function t(){return e.apply(this,arguments)||this}return a(t,e),t}(ve(Error));!function(){function e(){this._viewOrPaddings=[],this._length=0}var t=e.prototype;t.alignAs=function(e){if(0!==e){var t=this._length%e;if(0!==t){var n=e-t;return this._viewOrPaddings.push(n),this._length+=n,n}}return 0},t.append=function(e){var t=this._length;return this._viewOrPaddings.push(e),this._length+=e.byteLength,t},t.get=function(){var e=new Uint8Array(this._length),t=0;return this._viewOrPaddings.forEach((function(n){"number"==typeof n?t+=n:(e.set(new Uint8Array(n.buffer,n.byteOffset,n.byteLength),t),t+=n.byteLength)})),e},r(e,[{key:"byteLength",get:function(){return this._length}}])}(),s.internal.parseCCONJson=Oc,s.internal.decodeCCONBinary=Lc,s.internal.CCON=Mc;var Fc=Pe+"type",Uc=Pe+"default",Gc=Pe+"formerlySerializedAs",Bc=function(e){function t(){return e.call(this,(function(e){e.clear()}),1)||this}return a(t,e),t.prototype.get=function(e,t,n,i,o){var a=this._get();return a?(a.reset(e,t,n,i,o),a):new Hc(e,t,n,i,o)},t}(ge),Hc=function(){function e(e,t,n,i){this.deserializedList=void 0,this.deserializedData=void 0,this._ignoreEditorOnly=void 0,this.result=e,this.customEnv=i,this.deserializedList=[],this.deserializedData=null,this._classFinder=t,this._reportMissingClass=n,this._onDereferenced=null==t?void 0:t.onDereferenced}var t=e.prototype;return t.reset=function(e,t,n,i){this.result=e,this.customEnv=i,this._classFinder=t,this._reportMissingClass=n,this._onDereferenced=null==t?void 0:t.onDereferenced},t.clear=function(){this.result=null,this.customEnv=null,this.deserializedList.length=0,this.deserializedData=null,this._classFinder=null,this._reportMissingClass=null,this._onDereferenced=null},t.deserialize=function(e){var t,n=!1;e instanceof Mc?(n=!0,t=e.document,e.chunks.length>0&&(U(1===e.chunks.length),this._mainBinChunk=e.chunks[0])):t=e,this._serializedData=t,this._context={fromCCON:n};var i=Array.isArray(t)?t[0]:t;return this.deserializedData=this._deserializeObject(i,0),this._serializedData=void 0,this._mainBinChunk=void 0,this._context=void 0,this.deserializedData},t._deserializeObject=function(e,t,n,i){switch(e.__type__){case"TypedArray":return this._deserializeTypedArrayView(e);case"TypedArrayRef":return this._deserializeTypedArrayViewRef(e);default:return e.__type__?this._deserializeTypeTaggedObject(e,t,n,i):Array.isArray(e)?this._deserializeArray(e):this._deserializePlainObject(e)}},t._deserializeTypedArrayView=function(e){return globalThis[e.ctor].from(e.array)},t._deserializeTypedArrayViewRef=function(e){var t=e.offset,n=e.length,i=e.ctor;return new globalThis[i](this._mainBinChunk.buffer,this._mainBinChunk.byteOffset+t,n)},t._deserializeArray=function(e){for(var t,n=new Array(e.length),i=0;i<e.length;i++)"object"==typeof(t=e[i])&&t?this._deserializeAndAssignField(n,t,""+i)&&(n[i]=null):n[i]=t;return n},t._deserializePlainObject=function(e){var t={};return this._fillPlainObject(t,e),t},t._deserializeTypeTaggedObject=function(e,t,n,i){var o=this,a=e.__type__,r=this._classFinder(a,e,n,i);if(!r)return this._classFinder===re&&this._reportMissingClass(a),null;var c=function(e){var n=new e;return t>=0&&(o.deserializedList[t]=n),n}(r);return this._deserializeInto(e,c,r),c},t._deserializeInto=function(e,t,n,i){void 0===i&&(i=!1),i||!t[Rc]?t._deserialize?t._deserialize(e.content,this):s.Class._isCCClass(n)?this._deserializeFireClass(t,e,n):this._deserializeFastDefinedObject(t,e,n):this._runCustomizedDeserialize(e,t,n)},t._runCustomizedDeserialize=function(e,t,n){var i=this,o={readProperty:function(t){var n=e[t];return"object"==typeof n&&n?i._deserializeObjectField(n):n},readThis:function(){i._deserializeInto(e,t,n,!0)},readSuper:function(){var o=Ee(n);o&&i._deserializeInto(e,t,o)}};t[Rc](o,this._context)},t._deserializeFireClass=function(e,t,n){var i;if(n.hasOwnProperty("__deserialize__"))i=n.__deserialize__;else{i=function(e,t){var n=ye.test(Ce(t)),i=Se(t,s._BaseNode)||Se(t,s.Component),o=!1,a=[],r=a,l=[],f=l,_=[];return function(){var e=t.__values__;o="_$erialized"===e[e.length-1];for(var i=xe(t),u=0;u<e.length;u++){var m=e[u],d=m;i[m+Gc]&&(d=i[m+Gc]);var p=c.getDefault(i[m+Uc]),h=!1;if(n){var v=i[m+Fc];if(void 0===p&&v)h=v instanceof Ie;else{var g=typeof p;h="string"===g||"number"===g||"boolean"===g}}n&&h?(d!==m&&r===a&&(r=a.slice()),a.push(m),r!==a&&r.push(d)):(d!==m&&f===l&&(f=l.slice()),l.push(m),f!==l&&f.push(d),_.push(p instanceof s.ValueType&&p.constructor))}}(),function(e,t,c){for(var s=0;s<a.length;++s){var u=c[r[s]];void 0!==u&&(t[a[s]]=u)}for(var m=0;m<l.length;++m){var d=l[m],p=c[f[m]];if(void 0!==p)if(n||"object"==typeof p){var h=_[m];h?n||p?e._deserializeFastDefinedObject(t[d],p,h):t[d]=null:p?e._deserializeAndAssignField(t,p,d):t[d]=null}else t[d]=p}i&&c._id&&(t._id=c._id),o&&(t._$erialized=JSON.parse(JSON.stringify(c)),e._fillPlainObject(t._$erialized,c))}}(0,n);try{if(n===Ec){var a=n.__values__;0!==a.length&&"_$erialized"===a[a.length-1]||(o("The '_$erialized' prop of MissingScript is missing. Will force the raw data to be save."),o("    Error props: ['"+a+"']. Please contact jare."));var r=i;i=function(e,t,n,i){r(e,t,n,i),t._$erialized||o("Unable to stash previously serialized data. "+JSON.stringify(n))}}}catch(e){o("Error when checking MissingScript 6, "+e)}ie(n,"__deserialize__",i,!0)}i(this,e,t,n)},t._deserializeAndAssignField=function(e,t,n){var i=t.__id__;if("number"==typeof i){var o=this.deserializedList[i];if(o)e[n]=o;else{var a,r=this._serializedData[i];e[n]=this._deserializeObject(r,i,void 0,n),null===(a=this._onDereferenced)||void 0===a||a.call(this,this.deserializedList,i,e,n)}}else{var c=t.__uuid__;if(c){var s=t.__expectedType__;this.result.push(e,n,c,s)}else e[n]=this._deserializeObject(t,-1)}return!1},t._deserializeObjectField=function(e){var t=e.__id__;if("number"==typeof t){var n=this.deserializedList[t];if(n)return n;var i=this._serializedData[t];return this._deserializeObject(i,t,void 0,void 0)}if(e.__uuid__)throw e.__expectedType__,new Error("Asset reference field serialization is currently not supported in custom serialization.");return this._deserializeObject(e,-1)},t._fillPlainObject=function(e,t){for(var n in t)if(t.hasOwnProperty(n)){var i=t[n];"object"!=typeof i?"__type__"!==n&&(e[n]=i):i?this._deserializeAndAssignField(e,i,n)&&(e[n]=null):e[n]=null}},t._deserializeFastDefinedObject=function(e,t,n){if(n===s.Vec2)return e.x=t.x||0,void(e.y=t.y||0);if(n===s.Vec3)return e.x=t.x||0,e.y=t.y||0,void(e.z=t.z||0);if(n!==s.Color){if(n===s.Size)return e.width=t.width||0,void(e.height=t.height||0);for(var i=xe(n),o=n.__values__,a=0;a<o.length;a++){var r=o[a],l=t[r];void 0!==l||t.hasOwnProperty(r)||(l=c.getDefault(i[r+Uc])),"object"!=typeof l?e[r]=l:l?this._deserializeAndAssignField(e,l,r):e[r]=null}}else{e.r=t.r||0,e.g=t.g||0,e.b=t.b||0;var f=t.a;e.a=void 0===f?255:f}},e}();Hc.pool=new Bc;var Vc=[Xn,wn,Zn,zn,bn,ti,ii,jn];function kc(e,t){e.x=t[1],e.y=t[2],e.z=t[3],e.w=t[4]}var jc=[function(e,t){e.x=t[1],e.y=t[2]},function(e,t){e.x=t[1],e.y=t[2],e.z=t[3]},kc,kc,function(e,t){e._val=t[1]},function(e,t){e.width=t[1],e.height=t[2]},function(e,t){e.x=t[1],e.y=t[2],e.width=t[3],e.height=t[4]},function(e,t){jn.fromArray(e,t,1)}],qc=0,Wc=1,Yc=2,Xc=3,Kc=4,Jc=5,Qc=e("aF",function(){function e(){this.uuidObjList=null,this.uuidPropList=null,this.uuidList=null,this.uuidTypeList=[]}var t=e.prototype;return t.init=function(e){e?(this.uuidObjList=e[8],this.uuidPropList=e[9],this.uuidList=e[10]):this.uuidList||(this.uuidList=[],this.uuidObjList=[],this.uuidPropList=[],this.uuidTypeList=[])},t.reset=function(){this.uuidList&&(this.uuidList.length=0,this.uuidObjList.length=0,this.uuidPropList.length=0,this.uuidTypeList.length=0)},t.push=function(e,t,n,i){this.uuidObjList.push(e),this.uuidPropList.push(t),this.uuidList.push(n),this.uuidTypeList.push(i||"")},e}());function Zc(e,t){for(var n=e[Kc][t[0]],i=n[0],o=new(0,i[0]),a=i[1],r=i[2],c=n[n.length-1],s=1;s<c;++s)o[a[n[s]]]=t[s];for(;s<t.length;++s){var l=a[n[s]],f=i[n[s]+r];(0,os[f])(e,o,l,t[s])}return o}function $c(e,t,n){var i=new t;return i._deserialize?i._deserialize(n,e[0]):Te(5303,oe(t)),i}function es(e,t,n,i){i>=0?t[n]=e[5][i]:e[7][3*~i]=t}function ts(e){return function(t,n,i,o){n[i]=o;for(var a=0;a<o.length;++a)e(t,o,a,o[a])}}function ns(e,t,n,i){t[n]=null,e[8][i]=t}function is(e,t,n,i){t[n]=Zc(e,i)}Qc.pool=new ge((function(e){e.reset()}),5),Qc.pool.get=function(){return this._get()||new Qc};var os=new Array(13);function as(e,t,n){return e||n(t),Object}function rs(e,t,n,i,o,a,r){var c,s,l,f=e(t);if(!f){if(o)return void(n[i]=(c=n,s=i,l=t,function(){var t=e(l)||as(a,l,r);return c[s]=t,new t}));f=as(a,t,r)}n[i]=f}function cs(e,t,n,i){for(var o=n||re,a=e[Xc],r=0;r<a.length;++r){var c=a[r];"string"!=typeof c?rs(o,c[0],c,0,t,n,i):rs(o,c,a,r,t,n,i)}}function ss(e){var t=e[Kc];if(t)for(var n=e[Xc],i=0;i<t.length;++i){var o=t[i];o[0]=n[o[0]]}}function ls(e,t,n){"string"==typeof e&&(e=JSON.parse(e));var i,o=!t;if(t=t||Qc.pool.get(),function(e){if(Array.isArray(e)){var t=e[0];return"number"==typeof t||t instanceof fs}return!1}(e)){t.init(e),n=n||{};var a,r=e[qc],c=!1;if("object"==typeof r&&(c=r.preprocessed,r=r.version),r<1)throw new Error(Z(5304,r));n._version=r,n.result=t,e[0]=n,c||(cs(e,!1,n.classFinder,null!==(a=n.reportMissingClass)&&void 0!==a?a:ls.reportMissingClass),ss(e)),s.game._isCloning=!0;var l=e[5],f=function(e){var t=e[5],n=e[6],i=0===n?0:n.length,o=t[t.length-1],a=t.length-i;"number"!=typeof o?o=0:(o<0&&(o=~o),--a);for(var r=0;r<a;++r)t[r]=Zc(e,t[r]);for(var c=e[Xc],s=0;s<i;++s,++r){var l=n[s],f=t[r];if(l>=0){var _=c[l];t[r]=$c(e,_,f)}else(0,os[l=~l])(e,t,r,f)}return o}(e);s.game._isCloning=!1,e[7]&&function(e,t,n){for(var i=e.length-1,o=0,a=3*e[i];o<a;o+=3){var r=e[o],c=t[e[o+2]],s=e[o+1];s>=0?r[n[s]]=c:r[~s]=c}for(;o<i;o+=3){var l=t[e[o]],f=t[e[o+2]],_=e[o+1];_>=0?l[n[_]]=f:l[~_]=f}}(e[7],l,e[Yc]),function(e){for(var t=e[5],n=e[Yc],i=e[Wc],o=e[8],a=e[9],r=e[10],c=0;c<o.length;++c){var s=o[c];"number"==typeof s&&(o[c]=t[s]);var l=a[c];"number"==typeof l&&(l=l>=0?n[l]:~l,a[c]=l);var f=r[c];"number"==typeof f&&(r[c]=i[f])}}(e),i=l[f]}else i=function(e,t,n){var i,o=(n=n||{}).classFinder||re,a=n.createAssetRefs||Nc.platform===de.EDITOR_CORE,r=n.customEnv,c=n.ignoreEditorOnly,l=null!==(i=n.reportMissingClass)&&void 0!==i?i:s.deserialize.reportMissingClass;t.init();var f=Hc.pool.get(t,o,l,r,c);s.game._isCloning=!0;var _=f.deserialize(e);return s.game._isCloning=!1,Hc.pool.put(f),a&&t.assignAssetsBy(EditorExtends.serialize.asAsset),_}(e,t,n);return o&&Qc.pool.put(t),i}os[0]=function(e,t,n,i){t[n]=i},os[1]=es,os[2]=ts(es),os[3]=ts(ns),os[4]=is,os[5]=function(e,t,n,i){jc[i[0]](t[n],i)},os[6]=ns,os[7]=function(e,t,n,i){t[n].set(i)},os[8]=function(e,t,n,i){var o=new Vc[i[0]];jc[i[0]](o,i),t[n]=o},os[9]=ts(is),os[10]=function(e,t,n,i){var o=e[Xc][i[0]];t[n]=$c(e,o,i[1])},os[11]=function(e,t,n,i){var o=i[0];t[n]=o;for(var a=1;a<i.length;a+=3){var r=i[a],c=i[a+1],s=i[a+2];(0,os[c])(e,o,r,s)}},os[12]=function(e,t,n,i){var o=i[0];t[n]=o;for(var a=0;a<o.length;++a){var r=o[a],c=i[a+1];0!==c&&(0,os[c])(e,o,a,r)}},ls.Details=Qc,ls.reportMissingClass=function(e){Te(5302,e)};var fs=function(e){this.preprocessed=!0,this.version=e};s.deserialize=ls;var _s,us,ms,ds,ps,hs,vs,gs,xs,ys,Cs,Ss=K.Flags.Destroyed,Es=K.Flags.PersistentMask,Ps=[];function Is(e){var t;if(e instanceof K){if(e._instantiate)return s.game._isCloning=!0,t=e._instantiate(null,!0),s.game._isCloning=!1,t;if(e instanceof s.Asset)throw new TypeError(Z(6903))}return s.game._isCloning=!0,t=Ts(e),s.game._isCloning=!1,t}function Ts(e,t){var n;bs(e,n=e._iN$t?e._iN$t:e.constructor?new(0,e.constructor):Object.create(null),t);for(var i=0,o=Ps.length;i<o;++i)Ps[i]._iN$t=null;return Ps.length=0,n}function bs(e,t,n){G.value(e,"_iN$t",t,!0),Ps.push(e);var i=e.constructor;if(be(i))!function(e,t,n,i){for(var o=e.__values__,a=0;a<o.length;a++){var r=o[a],c=t[r];if("object"==typeof c&&c){var s=n[r];s instanceof l&&s.constructor===c.constructor?s.set(c):n[r]=c._iN$t||As(c,i)}else n[r]=c}}(i,e,t,n);else for(var o in e)if(e.hasOwnProperty(o)&&(95!==o.charCodeAt(0)||95!==o.charCodeAt(1)||"__type__"===o||"__prefab"===o)){var a=e[o];if("object"==typeof a&&a){if(a===t)continue;t[o]=a._iN$t||As(a,n)}else t[o]=a}e instanceof K&&(t._objFlags&=Es)}function As(e,t){if(e instanceof l)return e.clone();if(e instanceof s.Asset)return e;var n;if(ArrayBuffer.isView(e)){var i=e.length;n=new e.constructor(i),e._iN$t=n,Ps.push(e);for(var o=0;o<i;++o)n[o]=e[o];return n}if(Array.isArray(e)){var a=e.length;n=new Array(a),e._iN$t=n,Ps.push(e);for(var r=0;r<a;++r){var c=e[r];n[r]="object"==typeof c&&c?c._iN$t||As(c,t):c}return n}if(e._objFlags&Ss)return null;var f=e.constructor;if(be(f)){if(t)if(t instanceof s.Component){if(e instanceof s._BaseNode||e instanceof s.Component)return e}else if(t instanceof s._BaseNode)if(e instanceof s._BaseNode){if(!e.isChildOf(t))return e}else if(e instanceof s.Component&&e.node&&!e.node.isChildOf(t))return e;n=new f}else if(f===Object)n={};else{if(f)return e;n=Object.create(null)}return bs(e,n,t),n}function ws(e,t){return(t<<3)+e}function Ns(e){return Rs[e]}function Ds(e){switch(e){case ys.Uint8:return Uint8Array;case ys.Uint16:return Uint16Array;case ys.Uint32:return Uint32Array;case ys.Int8:return Int8Array;case ys.Int16:return Int16Array;case ys.Int32:return Int32Array;case ys.Float32:return Float32Array;case ys.Float64:return Float64Array}}Is._clone=Ts,s.instantiate=Is,function(e){e[e.Uint8=0]="Uint8",e[e.Uint16=1]="Uint16",e[e.Uint32=2]="Uint32",e[e.Int8=3]="Int8",e[e.Int16=4]="Int16",e[e.Int32=5]="Int32",e[e.Float32=6]="Float32",e[e.Float64=7]="Float64"}(ys||(ys={})),function(e){e[e.Scalar=0]="Scalar",e[e.Vec2=1]="Vec2",e[e.Vec3=2]="Vec3",e[e.Vec4=3]="Vec4",e[e.Quat=4]="Quat",e[e.Mat4=5]="Mat4"}(Cs||(Cs={})),e("aI",Ga("cc.CompactValueTypeArray")((gs=vs=function(){function e(){te(this,"_byteOffset",ms,this),te(this,"_unitCount",ds,this),te(this,"_unitElement",ps,this),te(this,"_length",hs,this)}return e.lengthFor=function(e,t,n){return Ns(t).requiredUnits*e.length*Ds(n).BYTES_PER_ELEMENT},e.compress=function(t,n,i,o,a,r){for(var c=Ns(n),s=Ds(i),l=c.requiredUnits*t.length,f=new s(o,a,l),_=0;_<t.length;++_)c.compress(f,_,t[_]);var u=new e;return u._unitElement=ws(i,n),u._byteOffset=r,u._unitCount=l,u._length=t.length,u},e.prototype.decompress=function(e){for(var t,n={storageUnit:7&(t=this._unitElement),elementType:t>>3},i=n.storageUnit,o=Ns(n.elementType),a=new(Ds(i))(e,this._byteOffset,this._unitCount),r=new Array(this._length),c=0;c<this._length;++c)r[c]=o.decompress(a,c);return r},e}(),vs.StorageUnit=ys,vs.ElementType=Cs,ms=ee((us=gs).prototype,"_byteOffset",[Ya],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return 0}}),ds=ee(us.prototype,"_unitCount",[Ya],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return 0}}),ps=ee(us.prototype,"_unitElement",[Ya],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return ws(ys.Uint8,Cs.Scalar)}}),hs=ee(us.prototype,"_length",[Ya],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return 0}}),_s=us))||_s);var Rs=((xs={})[Cs.Scalar]={requiredUnits:1,compress:function(e,t,n){e[t]=n},decompress:function(e,t){return e[t]}},xs[Cs.Vec2]={requiredUnits:2,compress:function(e,t,n){e[2*t]=n.x,e[2*t+1]=n.y},decompress:function(e,t){return new wn(e[2*t],e[2*t+1])}},xs[Cs.Vec3]={requiredUnits:3,compress:function(e,t,n){e[3*t]=n.x,e[3*t+1]=n.y,e[3*t+2]=n.z},decompress:function(e,t){return new wn(e[3*t],e[3*t+1],e[3*t+2])}},xs[Cs.Vec4]={requiredUnits:4,compress:function(e,t,n){e[4*t]=n.x,e[4*t+1]=n.y,e[4*t+2]=n.z,e[4*t+3]=n.w},decompress:function(e,t){return new Zn(e[4*t],e[4*t+1],e[4*t+2],e[4*t+3])}},xs[Cs.Quat]={requiredUnits:4,compress:function(e,t,n){e[4*t]=n.x,e[4*t+1]=n.y,e[4*t+2]=n.z,e[4*t+3]=n.w},decompress:function(e,t){return new zn(e[4*t],e[4*t+1],e[4*t+2],e[4*t+3])}},xs[Cs.Mat4]={requiredUnits:16,compress:function(e,t,n){jn.toArray(e,n,16*t)},decompress:function(e,t){return jn.fromArray(new jn,e,16*t)}},xs);function Ms(){return 0}function Os(e){return e}function Ls(e){return e*e}function zs(e){return e*(2-e)}function Fs(e){return(e*=2)<1?.5*e*e:-.5*(--e*(e-2)-1)}function Us(e){return e*e*e}function Gs(e){return--e*e*e+1}function Bs(e){return(e*=2)<1?.5*e*e*e:.5*((e-=2)*e*e+2)}function Hs(e){return e*e*e*e}function Vs(e){return 1- --e*e*e*e}function ks(e){return(e*=2)<1?.5*e*e*e*e:-.5*((e-=2)*e*e*e-2)}function js(e){return e*e*e*e*e}function qs(e){return--e*e*e*e*e+1}function Ws(e){return(e*=2)<1?.5*e*e*e*e*e:.5*((e-=2)*e*e*e*e+2)}function Ys(e){return 1===e?1:1-Math.cos(e*Math.PI/2)}function Xs(e){return Math.sin(e*Math.PI/2)}function Ks(e){return.5*(1-Math.cos(Math.PI*e))}function Js(e){return 0===e?0:Math.pow(1024,e-1)}function Qs(e){return 1===e?1:1-Math.pow(2,-10*e)}function Zs(e){return 0===e?0:1===e?1:(e*=2)<1?.5*Math.pow(1024,e-1):.5*(2-Math.pow(2,-10*(e-1)))}function $s(e){return 1-Math.sqrt(1-e*e)}function el(e){return Math.sqrt(1- --e*e)}function tl(e){return(e*=2)<1?-.5*(Math.sqrt(1-e*e)-1):.5*(Math.sqrt(1-(e-=2)*e)+1)}function nl(e){var t,n=.1;return 0===e?0:1===e?1:(!n||n<1?(n=1,t=.1):t=.4*Math.asin(1/n)/(2*Math.PI),-n*Math.pow(2,10*(e-=1))*Math.sin(2*(e-t)*Math.PI/.4))}function il(e){var t,n=.1;return 0===e?0:1===e?1:(!n||n<1?(n=1,t=.1):t=.4*Math.asin(1/n)/(2*Math.PI),n*Math.pow(2,-10*e)*Math.sin(2*(e-t)*Math.PI/.4)+1)}function ol(e){var t,n=.1;return 0===e?0:1===e?1:(!n||n<1?(n=1,t=.1):t=.4*Math.asin(1/n)/(2*Math.PI),(e*=2)<1?n*Math.pow(2,10*(e-=1))*Math.sin(2*(e-t)*Math.PI/.4)*-.5:n*Math.pow(2,-10*(e-=1))*Math.sin(2*(e-t)*Math.PI/.4)*.5+1)}function al(e){if(1===e)return 1;var t=1.70158;return e*e*((t+1)*e-t)}function rl(e){if(0===e)return 0;var t=1.70158;return--e*e*((t+1)*e+t)+1}function cl(e){var t=2.5949095;return(e*=2)<1?e*e*((t+1)*e-t)*.5:.5*((e-=2)*e*((t+1)*e+t)+2)}function sl(e){return 1-ll(1-e)}function ll(e){return e<1/2.75?7.5625*e*e:e<2/2.75?7.5625*(e-=1.5/2.75)*e+.75:e<2.5/2.75?7.5625*(e-=2.25/2.75)*e+.9375:7.5625*(e-=2.625/2.75)*e+.984375}function fl(e){return e<.5?.5*sl(2*e):.5*ll(2*e-1)+.5}function _l(e){return e<=0?0:e>=1?1:e*e*(3-2*e)}function ul(e){return e<=0?0:e>=1?1:e*e*e*(e*(6*e-15)+10)}s._decorator=Sr;var ml,dl,pl=Il(Ls,zs),hl=Il(Us,Gs),vl=Il(Hs,Vs),gl=Il(js,qs),xl=Il(Ys,Xs),yl=Il(Js,Qs),Cl=Il($s,el),Sl=Il(nl,il),El=Il(al,rl),Pl=Il(sl,ll);function Il(e,t){return function(n){return n<.5?t(2*n)/2:e(2*n-1)/2+.5}}e("dD",Object.freeze({__proto__:null,constant:Ms,linear:Os,quadIn:Ls,quadOut:zs,quadInOut:Fs,cubicIn:Us,cubicOut:Gs,cubicInOut:Bs,quartIn:Hs,quartOut:Vs,quartInOut:ks,quintIn:js,quintOut:qs,quintInOut:Ws,sineIn:Ys,sineOut:Xs,sineInOut:Ks,expoIn:Js,expoOut:Qs,expoInOut:Zs,circIn:$s,circOut:el,circInOut:tl,elasticIn:nl,elasticOut:il,elasticInOut:ol,backIn:al,backOut:rl,backInOut:cl,bounceIn:sl,bounceOut:ll,bounceInOut:fl,smooth:_l,fade:ul,quadOutIn:pl,cubicOutIn:hl,quartOutIn:vl,quintOutIn:gl,sineOutIn:xl,expoOutIn:yl,circOutIn:Cl,elasticOutIn:Sl,backOutIn:El,bounceOutIn:Pl})),function(e){e[e.LINEAR=0]="LINEAR",e[e.CONSTANT=1]="CONSTANT",e[e.QUAD_IN=2]="QUAD_IN",e[e.QUAD_OUT=3]="QUAD_OUT",e[e.QUAD_IN_OUT=4]="QUAD_IN_OUT",e[e.QUAD_OUT_IN=5]="QUAD_OUT_IN",e[e.CUBIC_IN=6]="CUBIC_IN",e[e.CUBIC_OUT=7]="CUBIC_OUT",e[e.CUBIC_IN_OUT=8]="CUBIC_IN_OUT",e[e.CUBIC_OUT_IN=9]="CUBIC_OUT_IN",e[e.QUART_IN=10]="QUART_IN",e[e.QUART_OUT=11]="QUART_OUT",e[e.QUART_IN_OUT=12]="QUART_IN_OUT",e[e.QUART_OUT_IN=13]="QUART_OUT_IN",e[e.QUINT_IN=14]="QUINT_IN",e[e.QUINT_OUT=15]="QUINT_OUT",e[e.QUINT_IN_OUT=16]="QUINT_IN_OUT",e[e.QUINT_OUT_IN=17]="QUINT_OUT_IN",e[e.SINE_IN=18]="SINE_IN",e[e.SINE_OUT=19]="SINE_OUT",e[e.SINE_IN_OUT=20]="SINE_IN_OUT",e[e.SINE_OUT_IN=21]="SINE_OUT_IN",e[e.EXPO_IN=22]="EXPO_IN",e[e.EXPO_OUT=23]="EXPO_OUT",e[e.EXPO_IN_OUT=24]="EXPO_IN_OUT",e[e.EXPO_OUT_IN=25]="EXPO_OUT_IN",e[e.CIRC_IN=26]="CIRC_IN",e[e.CIRC_OUT=27]="CIRC_OUT",e[e.CIRC_IN_OUT=28]="CIRC_IN_OUT",e[e.CIRC_OUT_IN=29]="CIRC_OUT_IN",e[e.ELASTIC_IN=30]="ELASTIC_IN",e[e.ELASTIC_OUT=31]="ELASTIC_OUT",e[e.ELASTIC_IN_OUT=32]="ELASTIC_IN_OUT",e[e.ELASTIC_OUT_IN=33]="ELASTIC_OUT_IN",e[e.BACK_IN=34]="BACK_IN",e[e.BACK_OUT=35]="BACK_OUT",e[e.BACK_IN_OUT=36]="BACK_IN_OUT",e[e.BACK_OUT_IN=37]="BACK_OUT_IN",e[e.BOUNCE_IN=38]="BOUNCE_IN",e[e.BOUNCE_OUT=39]="BOUNCE_OUT",e[e.BOUNCE_IN_OUT=40]="BOUNCE_IN_OUT",e[e.BOUNCE_OUT_IN=41]="BOUNCE_OUT_IN",e[e.SMOOTH=42]="SMOOTH",e[e.FADE=43]="FADE"}(dl||(dl=e("dJ",{})));var Tl,bl=((ml={})[dl.CONSTANT]=Ms,ml[dl.LINEAR]=Os,ml[dl.QUAD_IN]=Ls,ml[dl.QUAD_OUT]=zs,ml[dl.QUAD_IN_OUT]=Fs,ml[dl.QUAD_OUT_IN]=pl,ml[dl.CUBIC_IN]=Us,ml[dl.CUBIC_OUT]=Gs,ml[dl.CUBIC_IN_OUT]=Bs,ml[dl.CUBIC_OUT_IN]=hl,ml[dl.QUART_IN]=Hs,ml[dl.QUART_OUT]=Vs,ml[dl.QUART_IN_OUT]=ks,ml[dl.QUART_OUT_IN]=vl,ml[dl.QUINT_IN]=js,ml[dl.QUINT_OUT]=qs,ml[dl.QUINT_IN_OUT]=Ws,ml[dl.QUINT_OUT_IN]=gl,ml[dl.SINE_IN]=Ys,ml[dl.SINE_OUT]=Xs,ml[dl.SINE_IN_OUT]=Ks,ml[dl.SINE_OUT_IN]=xl,ml[dl.EXPO_IN]=Js,ml[dl.EXPO_OUT]=Qs,ml[dl.EXPO_IN_OUT]=Zs,ml[dl.EXPO_OUT_IN]=yl,ml[dl.CIRC_IN]=$s,ml[dl.CIRC_OUT]=el,ml[dl.CIRC_IN_OUT]=tl,ml[dl.CIRC_OUT_IN]=Cl,ml[dl.ELASTIC_IN]=nl,ml[dl.ELASTIC_OUT]=il,ml[dl.ELASTIC_IN_OUT]=ol,ml[dl.ELASTIC_OUT_IN]=Sl,ml[dl.BACK_IN]=al,ml[dl.BACK_OUT]=rl,ml[dl.BACK_IN_OUT]=cl,ml[dl.BACK_OUT_IN]=El,ml[dl.BOUNCE_IN]=sl,ml[dl.BOUNCE_OUT]=ll,ml[dl.BOUNCE_IN_OUT]=fl,ml[dl.BOUNCE_OUT_IN]=Pl,ml[dl.SMOOTH]=_l,ml[dl.FADE]=ul,ml);function Al(e){return bl[e]}U(8===0+Ae(255)),U(16===8+Ae(65280));var wl,Nl,Dl,Rl=Ta.LINEAR<<0|Aa.NONE<<8|dl.LINEAR<<16,Ml=function(e){function t(){for(var t,n=arguments.length,i=new Array(n),o=0;o<n;o++)i[o]=arguments[o];return(t=e.call.apply(e,[this].concat(i))||this).value=0,t.rightTangent=0,t.rightTangentWeight=0,t.leftTangent=0,t.leftTangentWeight=0,t._flags=Rl,t}return a(t,e),r(t,[{key:"interpolationMode",get:function(){return(255&this._flags)>>0},set:function(e){this._flags&=-256,this._flags|=e<<0}},{key:"tangentWeightMode",get:function(){return(65280&this._flags)>>8},set:function(e){this._flags&=-65281,this._flags|=e<<8}},{key:"easingMethod",get:function(){return(16711680&this._flags)>>16},set:function(e){this._flags&=-16711681,this._flags|=e<<16}}]),t}(Cr);function Ol(e){var t=new Ml;if("number"==typeof e)t.value=e;else{var n=e.interpolationMode,i=e.tangentWeightMode,o=e.value,a=e.rightTangent,r=e.rightTangentWeight,c=e.leftTangent,s=e.leftTangentWeight,l=e.easingMethod,f=e[we];t.value=null!=o?o:t.value,t.rightTangent=null!=a?a:t.rightTangent,t.rightTangentWeight=null!=r?r:t.rightTangentWeight,t.leftTangent=null!=c?c:t.leftTangent,t.leftTangentWeight=null!=s?s:t.leftTangentWeight,t.interpolationMode=null!=n?n:t.interpolationMode,t.tangentWeightMode=null!=i?i:t.tangentWeightMode,t.easingMethod=null!=l?l:t.easingMethod,f&&(t[we]=f)}return t}c.fastDefine("cc.RealKeyframeValue",Ml,((Tl={interpolationMode:Ta.LINEAR,tangentWeightMode:Aa.NONE,value:0,rightTangent:0,rightTangentWeight:0,leftTangent:0,leftTangentWeight:0,easingMethod:dl.LINEAR})[we]=void 0,Tl)),c.Attr.setClassAttr(Ml,we,"editorOnly",!0),(wl=Ml,null!==(Dl=(Nl=wl)[Wa])&&void 0!==Dl?Dl:Nl[Wa]={}).uniquelyReferenced=!0;var Ll,zl=e("bp",function(e){function t(){for(var t,n=arguments.length,i=new Array(n),o=0;o<n;o++)i[o]=arguments[o];return(t=e.call.apply(e,[this].concat(i))||this).preExtrapolation=ba.CLAMP,t.postExtrapolation=ba.CLAMP,t}a(t,e);var n=t.prototype;return n.evaluate=function(e){var t=this._times,n=this._values,i=t.length;if(0===i)return 0;var o=t[0],a=t[i-1];if(e<o){var r=this.preExtrapolation,c=n[0];if(r===ba.CLAMP||i<2)return c.value;switch(r){case ba.LINEAR:return Zl(o,n[0].value,t[1],n[1].value,e);case ba.LOOP:e=Jl(e,o,a);break;case ba.PING_PONG:e=Ql(e,o,a);break;default:return c.value}}else if(e>a){var s=this.postExtrapolation,l=n[i-1];if(s===ba.CLAMP||i<2)return l.value;switch(s){case ba.LINEAR:return Zl(a,l.value,t[i-2],n[i-2].value,e);case ba.LOOP:e=Jl(e,o,a);break;case ba.PING_PONG:e=Ql(e,o,a);break;default:return l.value}}var f=Ia(t,e);if(f>=0)return n[f].value;var _=~f,u=_-1,m=t[u],d=n[u],p=t[_];return function(e,t,n,i,o){var a=n-e;switch(t.interpolationMode){default:case Ta.CONSTANT:return t.value;case Ta.LINEAR:var r=t.easingMethod===dl.LINEAR?o:Al(t.easingMethod)(o);return vn(t.value,i.value,r);case Ta.CUBIC:var c=1/3,s=t.rightTangent,l=t.rightTangentWeight,f=0!=(t.tangentWeightMode&Aa.RIGHT),_=i.leftTangent,u=i.leftTangentWeight,m=0!=(i.tangentWeightMode&Aa.LEFT);if(f||m){var d=0;if(f)d=l;else{var p=a,h=a*s;d=Math.sqrt(p*p+h*h)*c}var v=Math.atan(s),g=Math.cos(v)*d+e,x=Math.sin(v)*d+t.value,y=0;if(m)y=u;else{var C=a,S=a*_;y=Math.sqrt(C*C+S*S)*c}var E=Math.atan(_),P=(g-e)/a,I=(-Math.cos(E)*y+n-e)/a,T=x,b=-Math.sin(E)*y+i.value,A=[0,0,0],w=function(e,t,n,i,o){var a=n/i,r=t/i,c=a*a,s=1/3*(-1/3*c+r),l=.5*(2/27*a*c-1/3*a*r+e/i),f=s*s*s,_=l*l+f,u=0;if(Na(_)){if(Na(l))return o[0]=0,1;var m=Math.cbrt(-l);return o[0]=2*m,o[1]=-m,2}if(_<0){var d=1/3*Math.acos(-l/Math.sqrt(-f)),p=2*Math.sqrt(-s);o[0]=p*Math.cos(d),o[1]=-p*Math.cos(d+Math.PI/3),o[2]=-p*Math.cos(d-Math.PI/3),u=3}else{var h=Math.sqrt(_),v=Math.cbrt(h-l),g=-Math.cbrt(h+l);o[0]=v+g,u=1}for(var x=1/3*a,y=0;y<u;++y)o[y]-=x;return u}(0-o,3*P,3*I-6*P,3*(P-I)+1,A),N=function(e,t,n){var i=n;if(1===t)i=e[0];else{i=-1/0;for(var o=0;o<t;++o){var a=e[o];a>=0&&a<=1&&a>i&&(i=a)}i===-1/0&&(i=0)}return i}(A,w,o);return $l(t.value,T,b,i.value,N)}var D=t.value+c*s*a,R=i.value-c*_*a;return $l(t.value,D,R,i.value,o)}}(m,d,p,n[_],(e-m)/(p-m))},n.addKeyFrame=function(t,n){return e.prototype.addKeyFrame.call(this,t,Ol(n))},n.assignSorted=function(e,t){if(void 0!==t)this.setKeyframes(e.slice(),t.map((function(e){return Ol(e)})));else{var n=Array.from(e);this.setKeyframes(n.map((function(e){return e[0]})),n.map((function(e){return Ol(e[1])})))}},n.isConstant=function(e){if(this._values.length<=1)return!0;var t=this._values[0].value;return this._values.every((function(n){return pn(n.value,t,e)}))},n[Dc]=function(e,t){if(t.toCCON){var n=this._times,i=this._values,o=n.length,a=new DataView(new ArrayBuffer(0+Fl+Fl+Ul+Gl*o+Yl*o)),r=0;a.setUint8(r,this.preExtrapolation),r+=Fl,a.setUint8(r,this.postExtrapolation),r+=Fl,a.setUint32(r,o,!0),r+=Ul,n.forEach((function(e,t){return a.setFloat32(r+Gl*t,e,!0)})),r+=Gl*o;for(var c,s=X(i);!(c=s()).done;){var l=c.value;r=Xl(a,l,r)}var f=new Uint8Array(a.buffer,0,r);e.writeProperty("bytes",f);var _=i.map((function(e){return e[we]}));_.some((function(e){return void 0!==e}))&&e.writeProperty("keyframeValueEditorExtras",_)}else e.writeThis()},n[Rc]=function(e,t){if(t.fromCCON){var n=e.readProperty("bytes"),i=new DataView(n.buffer,n.byteOffset,n.byteLength),o=0;this.preExtrapolation=i.getUint8(o),o+=Fl,this.postExtrapolation=i.getUint8(o),o+=Fl;var a=i.getUint32(o,!0);o+=Ul;var r=Array.from({length:a},(function(e,t){return i.getFloat32(o+Gl*t,!0)}));o+=Gl*a;for(var c=new Array(a),s=0;s<a;++s){var l=Ol({});o=Kl(i,l,o),c[s]=l}U(o===n.byteLength);var f=e.readProperty("keyframeValueEditorExtras");f&&(U(f.length===a),f.forEach((function(e,t){return c[t][we]=e}))),this._times=r,this._values=c}else e.readThis()},t}(wa));c.fastDefine("cc.RealCurve",zl,{_times:[],_values:[],preExtrapolation:ba.CLAMP,postExtrapolation:ba.CLAMP}),function(e){e[e.VALUE=1]="VALUE",e[e.INTERPOLATION_MODE=2]="INTERPOLATION_MODE",e[e.TANGENT_WEIGHT_MODE=4]="TANGENT_WEIGHT_MODE",e[e.LEFT_TANGENT=8]="LEFT_TANGENT",e[e.LEFT_TANGENT_WEIGHT=16]="LEFT_TANGENT_WEIGHT",e[e.RIGHT_TANGENT=32]="RIGHT_TANGENT",e[e.RIGHT_TANGENT_WEIGHT=64]="RIGHT_TANGENT_WEIGHT"}(Ll||(Ll={}));var Fl=1,Ul=4,Gl=4,Bl=Ol({}),Hl=Bl.interpolationMode,Vl=Bl.tangentWeightMode,kl=Bl.leftTangent,jl=Bl.leftTangentWeight,ql=Bl.rightTangent,Wl=Bl.rightTangentWeight,Yl=26;function Xl(e,t,n){var i=0,o=n,a=o;o+=4;var r=t.value,c=t.interpolationMode,s=t.tangentWeightMode,l=t.rightTangent,f=t.rightTangentWeight,_=t.leftTangent,u=t.leftTangentWeight,m=t.easingMethod;return e.setFloat32(o,r,!0),o+=4,c!==Hl&&(i|=Ll.INTERPOLATION_MODE,e.setUint8(o,c),o+=1),s!==Vl&&(i|=Ll.TANGENT_WEIGHT_MODE,e.setUint8(o,s),o+=1),_!==kl&&(i|=Ll.LEFT_TANGENT,e.setFloat32(o,_,!0),o+=4),u!==jl&&(i|=Ll.LEFT_TANGENT_WEIGHT,e.setFloat32(o,u,!0),o+=4),l!==ql&&(i|=Ll.RIGHT_TANGENT,e.setFloat32(o,l,!0),o+=4),f!==Wl&&(i|=Ll.RIGHT_TANGENT_WEIGHT,e.setFloat32(o,f,!0),o+=4),i|=m<<8,e.setUint32(a,i,!0),o}function Kl(e,t,n){var i=n,o=e.getUint32(i,!0);i+=4,t.value=e.getFloat32(i,!0),i+=4,o&Ll.INTERPOLATION_MODE&&(t.interpolationMode=e.getUint8(i),i+=1),o&Ll.TANGENT_WEIGHT_MODE&&(t.tangentWeightMode=e.getUint8(i),i+=1),o&Ll.LEFT_TANGENT&&(t.leftTangent=e.getFloat32(i,!0),i+=4),o&Ll.LEFT_TANGENT_WEIGHT&&(t.leftTangentWeight=e.getFloat32(i,!0),i+=4),o&Ll.RIGHT_TANGENT&&(t.rightTangent=e.getFloat32(i,!0),i+=4),o&Ll.RIGHT_TANGENT_WEIGHT&&(t.rightTangentWeight=e.getFloat32(i,!0),i+=4);var a=(65280&o)>>8;return t.easingMethod=a,i}function Jl(e,t,n){return t+En(e-t,n-t)}function Ql(e,t,n){return t+Pn(e-t,n-t)}function Zl(e,t,n,i,o){return t+(i-t)/(n-e)*(o-e)}function $l(e,t,n,i,o){var a=1-o;return a*a*a*e+3*a*a*o*t+3*a*o*o*n+o*o*o*i}function ef(e,t,n,i,o){var a=1-o;return a*(a*(e+(3*t-e)*o)+3*n*o*o)+i*o*o*o}s.bezier=ef;var tf,nf,of,af,rf,cf,sf,lf,ff,_f,uf,mf=Math.cos,df=Math.acos,pf=Math.max,hf=2*Math.PI,vf=Math.sqrt;function gf(e){return e<0?-Math.pow(-e,1/3):Math.pow(e,1/3)}function xf(e,t){var n=function(e,t){var n,i,o,a,r=t-0,c=t-e[0],s=3*r,l=3*c,f=3*(t-e[2]),_=1/(-r+l-f+(t-1)),u=1/3,m=(s-6*c+f)*_,d=m*u,p=(-s+l)*_,h=(3*p-m*m)*u,v=h*u,g=(2*m*m*m-9*m*p+r*_*27)/27,x=g/2,y=x*x+v*v*v;if(y<0){var C=-h*u,S=vf(C*C*C),E=-g/(2*S),P=df(E<-1?-1:E>1?1:E),I=2*gf(S);return i=I*mf(P*u)-d,o=I*mf((P+hf)*u)-d,a=I*mf((P+2*hf)*u)-d,i>=0&&i<=1?o>=0&&o<=1?a>=0&&a<=1?pf(i,o,a):pf(i,o):a>=0&&a<=1?pf(i,a):i:o>=0&&o<=1?a>=0&&a<=1?pf(o,a):o:a}if(0===y)return o=-(n=x<0?gf(-x):-gf(x))-d,(i=2*n-d)>=0&&i<=1?o>=0&&o<=1?pf(i,o):i:o;var T=vf(y);return(n=gf(-x+T))-gf(x+T)-d}(e,t),i=e[1];return((1-n)*(i+(e[3]-i)*n)*3+n*n)*n}s.bezierByTime=xf,function(e){e[e.SLERP=0]="SLERP",e[e.CONSTANT=1]="CONSTANT"}(uf||(uf=e("bu",{})));var yf,Cf=Ga("cc.QuatKeyframeValue")(tf=Qa((of=ee((nf=function(e){var t=void 0===e?{}:e,n=t.value,i=t.interpolationMode,o=t.easingMethod;te(this,"interpolationMode",of,this),te(this,"value",af,this),te(this,"easingMethod",rf,this),this.value=n?zn.clone(n):this.value,this.interpolationMode=null!=i?i:this.interpolationMode,this.easingMethod=null!=o?o:this.easingMethod}).prototype,"interpolationMode",[Ya],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return uf.SLERP}}),af=ee(nf.prototype,"value",[Ya],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return zn.clone(zn.IDENTITY)}}),rf=ee(nf.prototype,"easingMethod",[Ya],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return dl.LINEAR}}),tf=nf))||tf)||tf;function Sf(e){return new Cf(e)}e("bt",Ga("cc.QuatCurve")((_f=function(e){function t(){for(var t,n=arguments.length,i=new Array(n),o=0;o<n;o++)i[o]=arguments[o];return t=e.call.apply(e,[this].concat(i))||this,te(t,"preExtrapolation",lf,J(t)),te(t,"postExtrapolation",ff,J(t)),t}a(t,e);var n=t.prototype;return n.evaluate=function(e,t){var n;null!==(n=t)&&void 0!==n||(t=new zn);var i=this._times,o=this._values,a=this.postExtrapolation,r=this.preExtrapolation,c=i.length;if(0===c)return t;var s=i[0],l=i[c-1];if(e<s){var f=o[0];switch(r){case ba.LOOP:e=s+En(e-s,l-s);break;case ba.PING_PONG:e=s+Pn(e-s,l-s);break;case ba.CLAMP:default:return zn.copy(t,f.value)}}else if(e>l){var _=o[c-1];switch(a){case ba.LOOP:e=s+En(e-s,l-s);break;case ba.PING_PONG:e=s+Pn(e-s,l-s);break;case ba.CLAMP:default:return zn.copy(t,_.value)}}var u=Ia(i,e);if(u>=0)return zn.copy(t,o[u].value);var m=~u,d=m-1,p=i[d],h=o[d],v=i[m],g=o[m],x=(e-p)/(v-p);switch(h.interpolationMode){default:case uf.CONSTANT:return zn.copy(t,h.value);case uf.SLERP:var y=h.easingMethod,C=y===dl.LINEAR?x:Array.isArray(y)?xf(y,x):Al(y)(x);return zn.slerp(t,h.value,g.value,C)}},n.addKeyFrame=function(t,n){var i=new Cf(n);return e.prototype.addKeyFrame.call(this,t,i)},n.assignSorted=function(e,t){if(void 0!==t)this.setKeyframes(e.slice(),t.map((function(e){return Sf(e)})));else{var n=Array.from(e);this.setKeyframes(n.map((function(e){return e[0]})),n.map((function(e){return Sf(e[1])})))}},n[Dc]=function(e,t){if(t.toCCON){var n=this._times,i=this._values,o=!0;i.forEach((function(e,t,n){var i=n[0];o&&e.interpolationMode!==i.interpolationMode&&(o=!1)}));var a=n.length,r=Af*(o?1:a),c=i.reduce((function(e,t){var n=t.easingMethod;return e+(Array.isArray(n)?wf+4*Df:wf)}),0),s=0,l=new DataView(new ArrayBuffer(s+=Pf+If+Tf*a+4*bf*a+c+r+0)),f=0,_=0;o&&(_|=yf.INTERPOLATION_MODE),l.setUint32(f,_,!0),f+=Pf,l.setUint32(f,a,!0),f+=If,n.forEach((function(e,t){return l.setFloat32(f+Tf*t,e,!0)})),f+=Tf*a,i.forEach((function(e,t){var n=e.value,i=n.x,o=n.y,a=n.z,r=n.w,c=f+4*bf*t;l.setFloat32(c+0*bf,i,!0),l.setFloat32(c+1*bf,o,!0),l.setFloat32(c+2*bf,a,!0),l.setFloat32(c+3*bf,r,!0)})),f+=4*bf*a,i.forEach((function(e){var t=e.easingMethod;Array.isArray(t)?(l.setUint8(f,Nf),++f,l.setFloat32(f+0*Df,t[0],!0),l.setFloat32(f+1*Df,t[1],!0),l.setFloat32(f+2*Df,t[2],!0),l.setFloat32(f+3*Df,t[3],!0),f+=4*Df):(l.setUint8(f,t),++f)}));var u=f;f+=r;var m=u;i.forEach((function(e){var t=e.interpolationMode;l.setUint8(m,t),o||(m+=Af)}));var d=new Uint8Array(l.buffer);e.writeProperty("bytes",d)}else e.writeThis()},n[Rc]=function(e,t){if(t.fromCCON){var n=e.readProperty("bytes"),i=new DataView(n.buffer,n.byteOffset,n.byteLength),o=0,a=i.getUint32(o,!0);o+=Pf;var r=a&yf.INTERPOLATION_MODE,c=i.getUint32(o,!0);o+=If;var s=Array.from({length:c},(function(e,t){return i.getFloat32(o+Tf*t,!0)})),l=o+=Tf*c;o+=4*bf*c;var f=Array.from({length:c},(function(e,t){var n=l+4*bf*t,a=i.getFloat32(n+0*bf,!0),r=i.getFloat32(n+1*bf,!0),c=i.getFloat32(n+2*bf,!0),s=i.getFloat32(n+3*bf,!0),f=i.getUint8(o);++o;var _=Sf({value:{x:a,y:r,z:c,w:s}});return f!==Nf?_.easingMethod=f:(_.easingMethod=[i.getFloat32(o+0*Df,!0),i.getFloat32(o+1*Df,!0),i.getFloat32(o+2*Df,!0),i.getFloat32(o+3*Df,!0)],o+=4*Df),_}));if(r){var _=i.getUint8(o);++o;for(var u=0;u<c;++u)f[u].interpolationMode=_}else{for(var m=0;m<c;++m){var d=i.getUint8(o+m);f[m].interpolationMode=d}o+=c}this._times=s,this._values=f}else e.readThis()},t}(wa),lf=ee((sf=_f).prototype,"preExtrapolation",[Ya],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return ba.CLAMP}}),ff=ee(sf.prototype,"postExtrapolation",[Ya],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return ba.CLAMP}}),cf=sf))||cf),function(e){e[e.INTERPOLATION_MODE=1]="INTERPOLATION_MODE"}(yf||(yf={}));var Ef,Pf=1,If=4,Tf=4,bf=4,Af=1,wf=1,Nf=255,Df=4,Rf=(e("bv",Ga("cc.ObjectCurve")(Ef=function(e){function t(){return e.apply(this,arguments)||this}return a(t,e),t.prototype.evaluate=function(e){var t=this.searchKeyframe(e);if(t>=0)return this._values[t];var n=hn(~t-1,0,this._values.length-1);return this._values[n]},t}(wa))||Ef),e("cr",(function(){this.time=0,this.value=0,this.inTangent=0,this.outTangent=0})));c.fastDefine("cc.Keyframe",Rf,{time:0,value:0,inTangent:0,outTangent:0});var Mf=function(){function e(){this.index=void 0,this.time=void 0,this.endTime=void 0,this.coefficient=void 0,this.index=-1,this.time=0,this.endTime=0,this.coefficient=new Float32Array(4)}return e.prototype.evaluate=function(e){return t=e-this.time,n=this.coefficient,t*(t*(t*n[0]+n[1])+n[2])+n[3];var t,n},e}(),Of=e("cs",function(){function e(e){if(void 0===e&&(e=null),this.cachedKey=void 0,e instanceof zl)this._curve=e;else{var t=new zl;this._curve=t,t.preExtrapolation=ba.LOOP,t.postExtrapolation=ba.CLAMP,e?t.assignSorted(e.map((function(e){return[e.time,{interpolationMode:Ta.CUBIC,value:e.value,leftTangent:e.inTangent,rightTangent:e.outTangent}]}))):t.assignSorted([[0,{interpolationMode:Ta.CUBIC,value:1}],[1,{interpolationMode:Ta.CUBIC,value:1}]])}this.cachedKey=new Mf}var t=e.prototype;return t.addKey=function(e){e?this._curve.addKeyFrame(e.time,{interpolationMode:Ta.CUBIC,value:e.value,leftTangent:e.inTangent,rightTangent:e.outTangent}):this._curve.clear()},t.evaluate_slow=function(e){return this._curve.evaluate(e)},t.evaluate=function(e){var t=this.cachedKey,n=this._curve,i=n.keyFramesCount-1,o=e,a=e<0?n.preExtrapolation:n.postExtrapolation,r=n.getKeyframeTime(0),c=n.getKeyframeTime(i);switch(a){case ba.LOOP:o=En(e-r,c-r)+r;break;case ba.PING_PONG:o=Pn(e-r,c-r)+r;break;case ba.CLAMP:default:o=hn(e,r,c)}if(o>=t.time&&o<t.endTime)return t.evaluate(o);var s=this.findIndex(t,o),l=Math.min(s+1,i);return this.calcOptimizedKey(t,s,l),t.evaluate(o)},t.calcOptimizedKey=function(e,t,n){var i=this._curve.getKeyframeTime(t),o=this._curve.getKeyframeTime(n),a=this._curve.getKeyframeValue(t),r=a.value,c=a.leftTangent,s=this._curve.getKeyframeValue(n),l=s.value,f=s.rightTangent;e.index=t,e.time=i,e.endTime=o;var _=o-i,u=l-r,m=1/(_*_),d=c*_,p=f*_;e.coefficient[0]=(d+p-u-u)*m/_,e.coefficient[1]=(u+u+u-d-d-p)*m,e.coefficient[2]=c,e.coefficient[3]=r},t.findIndex=function(e,t){var n=this._curve,i=n.keyFramesCount,o=e.index;if(-1!==o)if(t>n.getKeyframeTime(o))for(var a=0;a<3;a++){var r=o+a;if(r+1<i&&n.getKeyframeTime(r+1)>t)return r}else for(var c=0;c<3;c++){var s=o-c;if(s>=0&&n.getKeyframeTime(s-1)<=t)return s-1}for(var l,f=0,_=i;_-f>1;)l=Math.floor((f+_)/2),n.getKeyframeTime(l)>=t?_=l:f=l;return f},r(e,[{key:"_internalCurve",get:function(){return this._curve}},{key:"keyFrames",get:function(){return Array.from(this._curve.keyframes()).map((function(e){var t=e[0],n=e[1],i=new Rf;return i.time=t,i.value=n.value,i.inTangent=n.leftTangent,i.outTangent=n.rightTangent,i}))},set:function(e){this._curve.assignSorted(e.map((function(e){return[e.time,{interpolationMode:Ta.CUBIC,value:e.value,leftTangent:e.inTangent,rightTangent:e.outTangent}]})))}},{key:"preWrapMode",get:function(){return zf(this._curve.preExtrapolation)},set:function(e){this._curve.preExtrapolation=Lf(e)}},{key:"postWrapMode",get:function(){return zf(this._curve.postExtrapolation)},set:function(e){this._curve.postExtrapolation=Lf(e)}}]),e}());function Lf(e){switch(e){default:case ga.Default:case ga.Normal:case ga.Clamp:return ba.CLAMP;case ga.PingPong:return ba.PING_PONG;case ga.Loop:return ba.LOOP}}function zf(e){switch(e){default:case ba.LINEAR:case ba.CLAMP:return ga.Clamp;case ba.PING_PONG:return ga.PingPong;case ba.LOOP:return ga.Loop}}function Ff(e,t){console.warn(e+" is deprecated, please use "+t+" instead.")}Of.defaultKF=[{time:0,value:1,inTangent:0,outTangent:0},{time:1,value:1,inTangent:0,outTangent:0}],c.fastDefine("cc.AnimationCurve",Of,{_curve:null}),nn(Mo,"intersect",[{name:"ray_aabb",newName:"rayAABB"},{name:"ray_plane",newName:"rayPlane"},{name:"ray_triangle",newName:"rayTriangle"},{name:"ray_sphere",newName:"raySphere"},{name:"ray_obb",newName:"rayOBB"},{name:"ray_capsule",newName:"rayCapsule"},{name:"ray_subMesh",newName:"raySubMesh"},{name:"ray_mesh",newName:"rayMesh"},{name:"ray_model",newName:"rayModel"},{name:"line_plane",newName:"linePlane"},{name:"line_triangle",newName:"lineTriangle"},{name:"line_aabb",newName:"lineAABB"},{name:"line_obb",newName:"lineOBB"},{name:"line_sphere",newName:"lineSphere"},{name:"aabb_aabb",newName:"aabbWithAABB"},{name:"aabb_obb",newName:"aabbWithOBB"},{name:"aabb_plane",newName:"aabbPlane"},{name:"aabb_frustum",newName:"aabbFrustum"},{name:"aabbFrustum_accurate",newName:"aabbFrustumAccurate"},{name:"obb_point",newName:"obbPoint"},{name:"obb_plane",newName:"obbPlane"},{name:"obb_frustum",newName:"obbFrustum"},{name:"obbFrustum_accurate",newName:"obbFrustumAccurate"},{name:"obb_obb",newName:"obbWithOBB"},{name:"obb_capsule",newName:"obbCapsule"},{name:"sphere_plane",newName:"spherePlane"},{name:"sphere_frustum",newName:"sphereFrustum"},{name:"sphereFrustum_accurate",newName:"sphereFrustumAccurate"},{name:"sphere_sphere",newName:"sphereWithSphere"},{name:"sphere_aabb",newName:"sphereAABB"},{name:"sphere_obb",newName:"sphereOBB"},{name:"sphere_capsule",newName:"sphereCapsule"},{name:"capsule_capsule",newName:"capsuleWithCapsule"}]),e("cu",function(e){function t(){var t;return t=e.call(this)||this,Ff("line","Line"),t}return a(t,e),t}(gi)),e("cv",function(e){function t(){var t;return t=e.call(this)||this,Ff("plane","Plane"),t}return a(t,e),t}(qo)),e("cw",function(e){function t(){var t;return t=e.call(this)||this,Ff("ray","Ray"),t}return a(t,e),t}(xi)),e("cx",function(e){function t(){var t;return t=e.call(this)||this,Ff("triangle","Triangle"),t}return a(t,e),t}(Ti)),e("cy",function(e){function t(){var t;return t=e.call(this)||this,Ff("sphere","Sphere"),t}return a(t,e),t}(Ii)),e("cz",function(e){function t(){var t;return t=e.call(this)||this,Ff("aabb","AABB"),t}return a(t,e),t}(_a)),e("cA",function(e){function t(){var t;return t=e.call(this)||this,Ff("obb","OBB"),t}return a(t,e),t}(pa)),e("cB",function(e){function t(){var t;return t=e.call(this)||this,Ff("capsule","Capsule"),t}return a(t,e),t}(ha)),e("cC",function(e){function t(){var t;return t=e.call(this)||this,Ff("frustum","Frustum"),t}return a(t,e),t}(Pa));var Uf={NONE:0,IGNORE_RAYCAST:1<<20,GIZMOS:1<<21,EDITOR:1<<22,UI_3D:1<<23,SCENE_GIZMO:1<<24,UI_2D:1<<25,PROFILER:1<<28,DEFAULT:1<<30,ALL:4294967295},Gf=e("b8",function(){function e(){}return e.makeMaskInclude=function(e){for(var t,n=0,i=X(e);!(t=i()).done;)n|=t.value;return n},e.makeMaskExclude=function(t){return~e.makeMaskInclude(t)},e.addLayer=function(t,n){if(void 0!==n)if(n>19||n<0)console.warn("maximum layers reached.");else{var i=1<<n;U(!e.Enum[t],Z(2104,t)),e.Enum[t]=i,G.value(e.Enum,String(i),t),e.BitMask[t]=i,G.value(e.BitMask,String(i),t)}else console.warn("bitNum can't be undefined")},e.deleteLayer=function(t){if(t>19||t<0)console.warn("do not change buildin layers.");else{var n=1<<t;delete e.Enum[e.Enum[n]],delete e.Enum[n],delete e.BitMask[e.BitMask[n]],delete e.BitMask[n]}},e.nameToLayer=function(t){return void 0===t?(console.warn("name can't be undefined"),-1):Me(e.Enum[t])},e.layerToName=function(t){return t>31||t<0?(console.warn("Unable to access unknown layer."),""):e.Enum[1<<t]},e}());Gf.Enum=Ne(Uf),Gf.BitMask=De(Re({},Uf)),s.Layers=Gf;var Bf,Hf,Vf=e("c7","MainFlow"),kf=e("c2","ForwardFlow"),jf=e("c3","ShadowFlow");!function(e){e[e.DEFAULT=100]="DEFAULT",e[e.UI=200]="UI"}(Bf||(Bf={})),s.RenderPassStage=Bf,function(e){e[e.MIN=0]="MIN",e[e.MAX=255]="MAX",e[e.DEFAULT=128]="DEFAULT"}(Hf||(Hf=e("d8",{})));var qf,Wf=e("bP",{bindings:[],layouts:{}}),Yf={bindings:[],layouts:{}};!function(e){e[e.UBO_GLOBAL=0]="UBO_GLOBAL",e[e.UBO_CAMERA=1]="UBO_CAMERA",e[e.UBO_SHADOW=2]="UBO_SHADOW",e[e.SAMPLER_SHADOWMAP=3]="SAMPLER_SHADOWMAP",e[e.SAMPLER_ENVIRONMENT=4]="SAMPLER_ENVIRONMENT",e[e.SAMPLER_SPOT_LIGHTING_MAP=5]="SAMPLER_SPOT_LIGHTING_MAP",e[e.SAMPLER_DIFFUSEMAP=6]="SAMPLER_DIFFUSEMAP",e[e.COUNT=7]="COUNT"}(qf||(qf=e("bO",{})));var Xf,Kf=qf.SAMPLER_SHADOWMAP,Jf=qf.COUNT-Kf;!function(e){e[e.UBO_LOCAL=0]="UBO_LOCAL",e[e.UBO_FORWARD_LIGHTS=1]="UBO_FORWARD_LIGHTS",e[e.UBO_SKINNING_ANIMATION=2]="UBO_SKINNING_ANIMATION",e[e.UBO_SKINNING_TEXTURE=3]="UBO_SKINNING_TEXTURE",e[e.UBO_MORPH=4]="UBO_MORPH",e[e.UBO_UI_LOCAL=5]="UBO_UI_LOCAL",e[e.SAMPLER_JOINTS=6]="SAMPLER_JOINTS",e[e.SAMPLER_MORPH_POSITION=7]="SAMPLER_MORPH_POSITION",e[e.SAMPLER_MORPH_NORMAL=8]="SAMPLER_MORPH_NORMAL",e[e.SAMPLER_MORPH_TANGENT=9]="SAMPLER_MORPH_TANGENT",e[e.SAMPLER_LIGHTMAP=10]="SAMPLER_LIGHTMAP",e[e.SAMPLER_SPRITE=11]="SAMPLER_SPRITE",e[e.SAMPLER_REFLECTION=12]="SAMPLER_REFLECTION",e[e.STORAGE_REFLECTION=13]="STORAGE_REFLECTION",e[e.COUNT=14]="COUNT"}(Xf||(Xf=e("dX",{})));var Qf,Zf=Xf.SAMPLER_JOINTS,$f=Xf.STORAGE_REFLECTION-Zf,e_=Xf.COUNT-Zf-$f;!function(e){e[e.GLOBAL=0]="GLOBAL",e[e.MATERIAL=1]="MATERIAL",e[e.LOCAL=2]="LOCAL"}(Qf||(Qf=e("bQ",{})));var t_=e("c9",new Oe([Kf,0,Zf],[Jf,0,$f],[0,0,0],[0,0,0],[0,0,0],[0,0,e_],[0,0,0],[0,2,1])),n_=e("bR",(function(){}));n_.TIME_OFFSET=0,n_.NATIVE_SIZE_OFFSET=n_.TIME_OFFSET+4,n_.SCREEN_SIZE_OFFSET=n_.NATIVE_SIZE_OFFSET+4,n_.COUNT=n_.SCREEN_SIZE_OFFSET+4,n_.SIZE=4*n_.COUNT,n_.NAME="CCGlobal",n_.BINDING=qf.UBO_GLOBAL,n_.DESCRIPTOR=new Le(n_.BINDING,ze.UNIFORM_BUFFER,1,Fe.ALL),n_.LAYOUT=new Ue(Qf.GLOBAL,n_.BINDING,n_.NAME,[new Ge("cc_time",Be.FLOAT4,1),new Ge("cc_screenSize",Be.FLOAT4,1),new Ge("cc_nativeSize",Be.FLOAT4,1)],1),Wf.layouts[n_.NAME]=n_.LAYOUT,Wf.bindings[n_.BINDING]=n_.DESCRIPTOR;var i_=e("bS",(function(){}));i_.MAT_VIEW_OFFSET=0,i_.MAT_VIEW_INV_OFFSET=i_.MAT_VIEW_OFFSET+16,i_.MAT_PROJ_OFFSET=i_.MAT_VIEW_INV_OFFSET+16,i_.MAT_PROJ_INV_OFFSET=i_.MAT_PROJ_OFFSET+16,i_.MAT_VIEW_PROJ_OFFSET=i_.MAT_PROJ_INV_OFFSET+16,i_.MAT_VIEW_PROJ_INV_OFFSET=i_.MAT_VIEW_PROJ_OFFSET+16,i_.CAMERA_POS_OFFSET=i_.MAT_VIEW_PROJ_INV_OFFSET+16,i_.SCREEN_SCALE_OFFSET=i_.CAMERA_POS_OFFSET+4,i_.EXPOSURE_OFFSET=i_.SCREEN_SCALE_OFFSET+4,i_.MAIN_LIT_DIR_OFFSET=i_.EXPOSURE_OFFSET+4,i_.MAIN_LIT_COLOR_OFFSET=i_.MAIN_LIT_DIR_OFFSET+4,i_.AMBIENT_SKY_OFFSET=i_.MAIN_LIT_COLOR_OFFSET+4,i_.AMBIENT_GROUND_OFFSET=i_.AMBIENT_SKY_OFFSET+4,i_.GLOBAL_FOG_COLOR_OFFSET=i_.AMBIENT_GROUND_OFFSET+4,i_.GLOBAL_FOG_BASE_OFFSET=i_.GLOBAL_FOG_COLOR_OFFSET+4,i_.GLOBAL_FOG_ADD_OFFSET=i_.GLOBAL_FOG_BASE_OFFSET+4,i_.NEAR_FAR_OFFSET=i_.GLOBAL_FOG_ADD_OFFSET+4,i_.VIEW_PORT_OFFSET=i_.NEAR_FAR_OFFSET+4,i_.COUNT=i_.VIEW_PORT_OFFSET+4,i_.SIZE=4*i_.COUNT,i_.NAME="CCCamera",i_.BINDING=qf.UBO_CAMERA,i_.DESCRIPTOR=new Le(i_.BINDING,ze.UNIFORM_BUFFER,1,Fe.ALL),i_.LAYOUT=new Ue(Qf.GLOBAL,i_.BINDING,i_.NAME,[new Ge("cc_matView",Be.MAT4,1),new Ge("cc_matViewInv",Be.MAT4,1),new Ge("cc_matProj",Be.MAT4,1),new Ge("cc_matProjInv",Be.MAT4,1),new Ge("cc_matViewProj",Be.MAT4,1),new Ge("cc_matViewProjInv",Be.MAT4,1),new Ge("cc_cameraPos",Be.FLOAT4,1),new Ge("cc_screenScale",Be.FLOAT4,1),new Ge("cc_exposure",Be.FLOAT4,1),new Ge("cc_mainLitDir",Be.FLOAT4,1),new Ge("cc_mainLitColor",Be.FLOAT4,1),new Ge("cc_ambientSky",Be.FLOAT4,1),new Ge("cc_ambientGround",Be.FLOAT4,1),new Ge("cc_fogColor",Be.FLOAT4,1),new Ge("cc_fogBase",Be.FLOAT4,1),new Ge("cc_fogAdd",Be.FLOAT4,1),new Ge("cc_nearFar",Be.FLOAT4,1),new Ge("cc_viewPort",Be.FLOAT4,1)],1),Wf.layouts[i_.NAME]=i_.LAYOUT,Wf.bindings[i_.BINDING]=i_.DESCRIPTOR;var o_=e("bN",(function(){}));o_.MAT_LIGHT_PLANE_PROJ_OFFSET=0,o_.MAT_LIGHT_VIEW_OFFSET=o_.MAT_LIGHT_PLANE_PROJ_OFFSET+16,o_.MAT_LIGHT_VIEW_PROJ_OFFSET=o_.MAT_LIGHT_VIEW_OFFSET+16,o_.SHADOW_INV_PROJ_DEPTH_INFO_OFFSET=o_.MAT_LIGHT_VIEW_PROJ_OFFSET+16,o_.SHADOW_PROJ_DEPTH_INFO_OFFSET=o_.SHADOW_INV_PROJ_DEPTH_INFO_OFFSET+4,o_.SHADOW_PROJ_INFO_OFFSET=o_.SHADOW_PROJ_DEPTH_INFO_OFFSET+4,o_.SHADOW_NEAR_FAR_LINEAR_SATURATION_INFO_OFFSET=o_.SHADOW_PROJ_INFO_OFFSET+4,o_.SHADOW_WIDTH_HEIGHT_PCF_BIAS_INFO_OFFSET=o_.SHADOW_NEAR_FAR_LINEAR_SATURATION_INFO_OFFSET+4,o_.SHADOW_LIGHT_PACKING_NBIAS_NULL_INFO_OFFSET=o_.SHADOW_WIDTH_HEIGHT_PCF_BIAS_INFO_OFFSET+4,o_.SHADOW_COLOR_OFFSET=o_.SHADOW_LIGHT_PACKING_NBIAS_NULL_INFO_OFFSET+4,o_.PLANAR_NORMAL_DISTANCE_INFO_OFFSET=o_.SHADOW_COLOR_OFFSET+4,o_.COUNT=o_.PLANAR_NORMAL_DISTANCE_INFO_OFFSET+4,o_.SIZE=4*o_.COUNT,o_.NAME="CCShadow",o_.BINDING=qf.UBO_SHADOW,o_.DESCRIPTOR=new Le(o_.BINDING,ze.UNIFORM_BUFFER,1,Fe.ALL),o_.LAYOUT=new Ue(Qf.GLOBAL,o_.BINDING,o_.NAME,[new Ge("cc_matLightPlaneProj",Be.MAT4,1),new Ge("cc_matLightView",Be.MAT4,1),new Ge("cc_matLightViewProj",Be.MAT4,1),new Ge("cc_shadowInvProjDepthInfo",Be.FLOAT4,1),new Ge("cc_shadowProjDepthInfo",Be.FLOAT4,1),new Ge("cc_shadowProjInfo",Be.FLOAT4,1),new Ge("cc_shadowNFLSInfo",Be.FLOAT4,1),new Ge("cc_shadowWHPBInfo",Be.FLOAT4,1),new Ge("cc_shadowLPNNInfo",Be.FLOAT4,1),new Ge("cc_shadowColor",Be.FLOAT4,1),new Ge("cc_planarNDInfo",Be.FLOAT4,1)],1),Wf.layouts[o_.NAME]=o_.LAYOUT,Wf.bindings[o_.BINDING]=o_.DESCRIPTOR;var a_=e("bT",qf.SAMPLER_SHADOWMAP),r_=new Le(a_,ze.SAMPLER_TEXTURE,1,Fe.FRAGMENT),c_=new He(Qf.GLOBAL,a_,"cc_shadowMap",Be.SAMPLER2D,1);Wf.layouts.cc_shadowMap=c_,Wf.bindings[a_]=r_;var s_=qf.SAMPLER_ENVIRONMENT,l_=new Le(s_,ze.SAMPLER_TEXTURE,1,Fe.FRAGMENT),f_=new He(Qf.GLOBAL,s_,"cc_environment",Be.SAMPLER_CUBE,1);Wf.layouts.cc_environment=f_,Wf.bindings[s_]=l_;var __=qf.SAMPLER_DIFFUSEMAP,u_=new Le(__,ze.SAMPLER_TEXTURE,1,Fe.FRAGMENT),m_=new He(Qf.GLOBAL,__,"cc_diffuseMap",Be.SAMPLER_CUBE,1);Wf.layouts.cc_diffuseMap=m_,Wf.bindings[__]=u_;var d_=e("bU",qf.SAMPLER_SPOT_LIGHTING_MAP),p_=new Le(d_,ze.SAMPLER_TEXTURE,1,Fe.FRAGMENT),h_=new He(Qf.GLOBAL,d_,"cc_spotLightingMap",Be.SAMPLER2D,1);Wf.layouts.cc_spotLightingMap=h_,Wf.bindings[d_]=p_;var v_=e("c5",(function(){}));v_.MAT_WORLD_OFFSET=0,v_.MAT_WORLD_IT_OFFSET=v_.MAT_WORLD_OFFSET+16,v_.LIGHTINGMAP_UVPARAM=v_.MAT_WORLD_IT_OFFSET+16,v_.LOCAL_SHADOW_BIAS=v_.LIGHTINGMAP_UVPARAM+4,v_.COUNT=v_.LOCAL_SHADOW_BIAS+4,v_.SIZE=4*v_.COUNT,v_.NAME="CCLocal",v_.BINDING=Xf.UBO_LOCAL,v_.DESCRIPTOR=new Le(v_.BINDING,ze.UNIFORM_BUFFER,1,Fe.VERTEX|Fe.COMPUTE),v_.LAYOUT=new Ue(Qf.LOCAL,v_.BINDING,v_.NAME,[new Ge("cc_matWorld",Be.MAT4,1),new Ge("cc_matWorldIT",Be.MAT4,1),new Ge("cc_lightingMapUVParam",Be.FLOAT4,1),new Ge("cc_localShadowBias",Be.FLOAT4,1)],1),Yf.layouts[v_.NAME]=v_.LAYOUT,Yf.bindings[v_.BINDING]=v_.DESCRIPTOR;var g_=e("dd",(function(){}));g_.WORLD_BOUND_CENTER=0,g_.WORLD_BOUND_HALF_EXTENTS=g_.WORLD_BOUND_CENTER+4,g_.COUNT=g_.WORLD_BOUND_HALF_EXTENTS+4,g_.SIZE=4*g_.COUNT,g_.NAME="CCWorldBound",g_.BINDING=Xf.UBO_LOCAL,g_.DESCRIPTOR=new Le(g_.BINDING,ze.UNIFORM_BUFFER,1,Fe.VERTEX|Fe.COMPUTE),g_.LAYOUT=new Ue(Qf.LOCAL,g_.BINDING,g_.NAME,[new Ge("cc_worldBoundCenter",Be.FLOAT4,1),new Ge("cc_worldBoundHalfExtents",Be.FLOAT4,1)],1),Yf.layouts[g_.NAME]=g_.LAYOUT,Yf.bindings[g_.BINDING]=g_.DESCRIPTOR;var x_=e("dc","a_matWorld0"),y_=function(){};y_.BATCHING_COUNT=10,y_.MAT_WORLDS_OFFSET=0,y_.SIZE=4*(y_.COUNT=16*y_.BATCHING_COUNT),y_.NAME="CCLocalBatched",y_.BINDING=Xf.UBO_LOCAL,y_.DESCRIPTOR=new Le(y_.BINDING,ze.UNIFORM_BUFFER,1,Fe.VERTEX|Fe.COMPUTE),y_.LAYOUT=new Ue(Qf.LOCAL,y_.BINDING,y_.NAME,[new Ge("cc_matWorlds",Be.MAT4,y_.BATCHING_COUNT)],1),Yf.layouts[y_.NAME]=y_.LAYOUT,Yf.bindings[y_.BINDING]=y_.DESCRIPTOR;var C_=e("c0",(function(){}));C_.LIGHTS_PER_PASS=1,C_.LIGHT_POS_OFFSET=0,C_.LIGHT_COLOR_OFFSET=C_.LIGHT_POS_OFFSET+4*C_.LIGHTS_PER_PASS,C_.LIGHT_SIZE_RANGE_ANGLE_OFFSET=C_.LIGHT_COLOR_OFFSET+4*C_.LIGHTS_PER_PASS,C_.LIGHT_DIR_OFFSET=C_.LIGHT_SIZE_RANGE_ANGLE_OFFSET+4*C_.LIGHTS_PER_PASS,C_.COUNT=C_.LIGHT_DIR_OFFSET+4*C_.LIGHTS_PER_PASS,C_.SIZE=4*C_.COUNT,C_.NAME="CCForwardLight",C_.BINDING=Xf.UBO_FORWARD_LIGHTS,C_.DESCRIPTOR=new Le(C_.BINDING,ze.DYNAMIC_UNIFORM_BUFFER,1,Fe.FRAGMENT),C_.LAYOUT=new Ue(Qf.LOCAL,C_.BINDING,C_.NAME,[new Ge("cc_lightPos",Be.FLOAT4,C_.LIGHTS_PER_PASS),new Ge("cc_lightColor",Be.FLOAT4,C_.LIGHTS_PER_PASS),new Ge("cc_lightSizeRangeAngle",Be.FLOAT4,C_.LIGHTS_PER_PASS),new Ge("cc_lightDir",Be.FLOAT4,C_.LIGHTS_PER_PASS)],1),Yf.layouts[C_.NAME]=C_.LAYOUT,Yf.bindings[C_.BINDING]=C_.DESCRIPTOR;var S_=e("c6",(function(){}));S_.LIGHTS_PER_PASS=10;var E_=e("dv",(function(){}));E_.JOINTS_TEXTURE_INFO_OFFSET=0,E_.COUNT=E_.JOINTS_TEXTURE_INFO_OFFSET+4,E_.SIZE=4*E_.COUNT,E_.NAME="CCSkinningTexture",E_.BINDING=Xf.UBO_SKINNING_TEXTURE,E_.DESCRIPTOR=new Le(E_.BINDING,ze.UNIFORM_BUFFER,1,Fe.VERTEX),E_.LAYOUT=new Ue(Qf.LOCAL,E_.BINDING,E_.NAME,[new Ge("cc_jointTextureInfo",Be.FLOAT4,1)],1),Yf.layouts[E_.NAME]=E_.LAYOUT,Yf.bindings[E_.BINDING]=E_.DESCRIPTOR;var P_=e("dt",(function(){}));P_.JOINTS_ANIM_INFO_OFFSET=0,P_.COUNT=P_.JOINTS_ANIM_INFO_OFFSET+4,P_.SIZE=4*P_.COUNT,P_.NAME="CCSkinningAnimation",P_.BINDING=Xf.UBO_SKINNING_ANIMATION,P_.DESCRIPTOR=new Le(P_.BINDING,ze.UNIFORM_BUFFER,1,Fe.VERTEX),P_.LAYOUT=new Ue(Qf.LOCAL,P_.BINDING,P_.NAME,[new Ge("cc_jointAnimInfo",Be.FLOAT4,1)],1),Yf.layouts[P_.NAME]=P_.LAYOUT,Yf.bindings[P_.BINDING]=P_.DESCRIPTOR;var I_=e("dx","a_jointAnimInfo"),T_=e("du",(function(){}));T_.JOINTS_OFFSET=0,T_.COUNT=T_.JOINTS_OFFSET+360,T_.SIZE=4*T_.COUNT,T_.NAME="CCSkinning",T_.BINDING=Xf.UBO_SKINNING_TEXTURE,T_.DESCRIPTOR=new Le(T_.BINDING,ze.UNIFORM_BUFFER,1,Fe.VERTEX),T_.LAYOUT=new Ue(Qf.LOCAL,T_.BINDING,T_.NAME,[new Ge("cc_joints",Be.FLOAT4,90)],1),Yf.layouts[T_.NAME]=T_.LAYOUT,Yf.bindings[T_.BINDING]=T_.DESCRIPTOR;var b_=e("dm",(function(){}));b_.MAX_MORPH_TARGET_COUNT=60,b_.OFFSET_OF_WEIGHTS=0,b_.OFFSET_OF_DISPLACEMENT_TEXTURE_WIDTH=4*b_.MAX_MORPH_TARGET_COUNT,b_.OFFSET_OF_DISPLACEMENT_TEXTURE_HEIGHT=b_.OFFSET_OF_DISPLACEMENT_TEXTURE_WIDTH+4,b_.OFFSET_OF_VERTICES_COUNT=b_.OFFSET_OF_DISPLACEMENT_TEXTURE_HEIGHT+4,b_.COUNT_BASE_4_BYTES=4*Math.ceil(b_.MAX_MORPH_TARGET_COUNT/4)+4,b_.SIZE=4*b_.COUNT_BASE_4_BYTES,b_.NAME="CCMorph",b_.BINDING=Xf.UBO_MORPH,b_.DESCRIPTOR=new Le(b_.BINDING,ze.UNIFORM_BUFFER,1,Fe.VERTEX),b_.LAYOUT=new Ue(Qf.LOCAL,b_.BINDING,b_.NAME,[new Ge("cc_displacementWeights",Be.FLOAT4,b_.MAX_MORPH_TARGET_COUNT/4),new Ge("cc_displacementTextureInfo",Be.FLOAT4,1)],1),Yf.layouts[b_.NAME]=b_.LAYOUT,Yf.bindings[b_.BINDING]=b_.DESCRIPTOR;var A_=function(){};A_.NAME="CCUILocal",A_.BINDING=Xf.UBO_UI_LOCAL,A_.DESCRIPTOR=new Le(A_.BINDING,ze.DYNAMIC_UNIFORM_BUFFER,1,Fe.VERTEX),A_.LAYOUT=new Ue(Qf.LOCAL,A_.BINDING,A_.NAME,[new Ge("cc_local_data",Be.FLOAT4,1)],1),Yf.layouts[A_.NAME]=A_.LAYOUT,Yf.bindings[A_.BINDING]=A_.DESCRIPTOR;var w_=e("dw",Xf.SAMPLER_JOINTS),N_=new Le(w_,ze.SAMPLER_TEXTURE,1,Fe.VERTEX),D_=new He(Qf.LOCAL,w_,"cc_jointTexture",Be.SAMPLER2D,1);Yf.layouts.cc_jointTexture=D_,Yf.bindings[w_]=N_;var R_=e("dq",Xf.SAMPLER_MORPH_POSITION),M_=new Le(R_,ze.SAMPLER_TEXTURE,1,Fe.VERTEX),O_=new He(Qf.LOCAL,R_,"cc_PositionDisplacements",Be.SAMPLER2D,1);Yf.layouts.cc_PositionDisplacements=O_,Yf.bindings[R_]=M_;var L_=e("dp",Xf.SAMPLER_MORPH_NORMAL),z_=new Le(L_,ze.SAMPLER_TEXTURE,1,Fe.VERTEX),F_=new He(Qf.LOCAL,L_,"cc_NormalDisplacements",Be.SAMPLER2D,1);Yf.layouts.cc_NormalDisplacements=F_,Yf.bindings[L_]=z_;var U_=e("dn",Xf.SAMPLER_MORPH_TANGENT),G_=new Le(U_,ze.SAMPLER_TEXTURE,1,Fe.VERTEX),B_=new He(Qf.LOCAL,U_,"cc_TangentDisplacements",Be.SAMPLER2D,1);Yf.layouts.cc_TangentDisplacements=B_,Yf.bindings[U_]=G_;var H_=e("db",Xf.SAMPLER_LIGHTMAP),V_=new Le(H_,ze.SAMPLER_TEXTURE,1,Fe.FRAGMENT),k_=new He(Qf.LOCAL,H_,"cc_lightingMap",Be.SAMPLER2D,1);Yf.layouts.cc_lightingMap=k_,Yf.bindings[H_]=V_;var j_=Xf.SAMPLER_SPRITE,q_=new Le(j_,ze.SAMPLER_TEXTURE,1,Fe.FRAGMENT),W_=new He(Qf.LOCAL,j_,"cc_spriteTexture",Be.SAMPLER2D,1);Yf.layouts.cc_spriteTexture=W_,Yf.bindings[j_]=q_;var Y_=e("d9",Xf.SAMPLER_REFLECTION),X_=new Le(Y_,ze.SAMPLER_TEXTURE,1,Fe.FRAGMENT),K_=new He(Qf.LOCAL,Y_,"cc_reflectionTexture",Be.SAMPLER2D,1);Yf.layouts.cc_reflectionTexture=K_,Yf.bindings[Y_]=X_;var J_=e("da",Xf.STORAGE_REFLECTION),Q_=new Le(J_,ze.STORAGE_IMAGE,1,Fe.COMPUTE),Z_=new Ve(Qf.LOCAL,J_,"cc_reflectionStorage",Be.IMAGE2D,1);Yf.layouts.cc_reflectionStorage=Z_,Yf.bindings[J_]=Q_;var $_=e("cj",Gf.makeMaskExclude([Gf.BitMask.UI_2D,Gf.BitMask.GIZMOS,Gf.BitMask.EDITOR,Gf.BitMask.SCENE_GIZMO,Gf.BitMask.PROFILER])),eu=Gf.makeMaskExclude([Gf.BitMask.UI_2D,Gf.BitMask.PROFILER]),tu=Gf.Enum.ALL;function nu(e){return(e.getFormatFeatures(ke.R32F)&(je.RENDER_TARGET|je.SAMPLED_TEXTURE))==(je.RENDER_TARGET|je.SAMPLED_TEXTURE)}e("b1",Object.freeze({__proto__:null,PIPELINE_FLOW_MAIN:Vf,PIPELINE_FLOW_FORWARD:kf,PIPELINE_FLOW_SHADOW:jf,PIPELINE_FLOW_SMAA:"SMAAFlow",PIPELINE_FLOW_TONEMAP:"ToneMapFlow",get RenderPassStage(){return Bf},get RenderPriority(){return Hf},globalDescriptorSetLayout:Wf,localDescriptorSetLayout:Yf,get PipelineGlobalBindings(){return qf},get ModelLocalBindings(){return Xf},get SetIndex(){return Qf},bindingMappingInfo:t_,UBOGlobal:n_,UBOCamera:i_,UBOShadow:o_,UNIFORM_SHADOWMAP_BINDING:a_,UNIFORM_ENVIRONMENT_BINDING:s_,UNIFORM_DIFFUSEMAP_BINDING:__,UNIFORM_SPOT_LIGHTING_MAP_TEXTURE_BINDING:d_,UBOLocal:v_,UBOWorldBound:g_,INST_MAT_WORLD:x_,UBOLocalBatched:y_,UBOForwardLight:C_,UBODeferredLight:S_,JOINT_UNIFORM_CAPACITY:30,UBOSkinningTexture:E_,UBOSkinningAnimation:P_,INST_JOINT_ANIM_INFO:I_,UBOSkinning:T_,UBOMorph:b_,UBOUILocal:A_,UNIFORM_JOINT_TEXTURE_BINDING:w_,UNIFORM_POSITION_MORPH_TEXTURE_BINDING:R_,UNIFORM_NORMAL_MORPH_TEXTURE_BINDING:L_,UNIFORM_TANGENT_MORPH_TEXTURE_BINDING:U_,UNIFORM_LIGHTMAP_TEXTURE_BINDING:H_,UNIFORM_SPRITE_TEXTURE_BINDING:j_,UNIFORM_REFLECTION_TEXTURE_BINDING:Y_,UNIFORM_REFLECTION_STORAGE_BINDING:J_,CAMERA_DEFAULT_MASK:$_,CAMERA_EDITOR_MASK:eu,MODEL_ALWAYS_MASK:tu,supportsR16HalfFloatTexture:function(e){return(e.getFormatFeatures(ke.R16F)&(je.RENDER_TARGET|je.SAMPLED_TEXTURE))==(je.RENDER_TARGET|je.SAMPLED_TEXTURE)},supportsR32FloatTexture:nu}));var iu,ou,au,ru,cu,su,lu,fu=1024;function _u(e){return!!(s.sys.hasFeature(s.sys.Feature.IMAGE_BITMAP)&&e instanceof ImageBitmap)}!function(e){e[e.RGB565=ke.R5G6B5]="RGB565",e[e.RGB5A1=ke.RGB5A1]="RGB5A1",e[e.RGBA4444=ke.RGBA4]="RGBA4444",e[e.RGB888=ke.RGB8]="RGB888",e[e.RGB32F=ke.RGB32F]="RGB32F",e[e.RGBA8888=ke.RGBA8]="RGBA8888",e[e.RGBA32F=ke.RGBA32F]="RGBA32F",e[e.A8=ke.A8]="A8",e[e.I8=ke.L8]="I8",e[e.AI8=ke.LA8]="AI8",e[e.RGB_PVRTC_2BPPV1=ke.PVRTC_RGB2]="RGB_PVRTC_2BPPV1",e[e.RGBA_PVRTC_2BPPV1=ke.PVRTC_RGBA2]="RGBA_PVRTC_2BPPV1",e[e.RGB_A_PVRTC_2BPPV1=fu++]="RGB_A_PVRTC_2BPPV1",e[e.RGB_PVRTC_4BPPV1=ke.PVRTC_RGB4]="RGB_PVRTC_4BPPV1",e[e.RGBA_PVRTC_4BPPV1=ke.PVRTC_RGBA4]="RGBA_PVRTC_4BPPV1",e[e.RGB_A_PVRTC_4BPPV1=fu++]="RGB_A_PVRTC_4BPPV1",e[e.RGB_ETC1=ke.ETC_RGB8]="RGB_ETC1",e[e.RGBA_ETC1=fu++]="RGBA_ETC1",e[e.RGB_ETC2=ke.ETC2_RGB8]="RGB_ETC2",e[e.RGBA_ETC2=ke.ETC2_RGBA8]="RGBA_ETC2",e[e.RGBA_ASTC_4x4=ke.ASTC_RGBA_4X4]="RGBA_ASTC_4x4",e[e.RGBA_ASTC_5x4=ke.ASTC_RGBA_5X4]="RGBA_ASTC_5x4",e[e.RGBA_ASTC_5x5=ke.ASTC_RGBA_5X5]="RGBA_ASTC_5x5",e[e.RGBA_ASTC_6x5=ke.ASTC_RGBA_6X5]="RGBA_ASTC_6x5",e[e.RGBA_ASTC_6x6=ke.ASTC_RGBA_6X6]="RGBA_ASTC_6x6",e[e.RGBA_ASTC_8x5=ke.ASTC_RGBA_8X5]="RGBA_ASTC_8x5",e[e.RGBA_ASTC_8x6=ke.ASTC_RGBA_8X6]="RGBA_ASTC_8x6",e[e.RGBA_ASTC_8x8=ke.ASTC_RGBA_8X8]="RGBA_ASTC_8x8",e[e.RGBA_ASTC_10x5=ke.ASTC_RGBA_10X5]="RGBA_ASTC_10x5",e[e.RGBA_ASTC_10x6=ke.ASTC_RGBA_10X6]="RGBA_ASTC_10x6",e[e.RGBA_ASTC_10x8=ke.ASTC_RGBA_10X8]="RGBA_ASTC_10x8",e[e.RGBA_ASTC_10x10=ke.ASTC_RGBA_10X10]="RGBA_ASTC_10x10",e[e.RGBA_ASTC_12x10=ke.ASTC_RGBA_12X10]="RGBA_ASTC_12x10",e[e.RGBA_ASTC_12x12=ke.ASTC_RGBA_12X12]="RGBA_ASTC_12x12"}(iu||(iu=e("c_",{}))),function(e){e[e.REPEAT=qe.WRAP]="REPEAT",e[e.CLAMP_TO_EDGE=qe.CLAMP]="CLAMP_TO_EDGE",e[e.MIRRORED_REPEAT=qe.MIRROR]="MIRRORED_REPEAT",e[e.CLAMP_TO_BORDER=qe.BORDER]="CLAMP_TO_BORDER"}(ou||(ou=e("dT",{}))),function(e){e[e.NONE=We.NONE]="NONE",e[e.LINEAR=We.LINEAR]="LINEAR",e[e.NEAREST=We.POINT]="NEAREST"}(au||(au=e("dy",{})));var uu,mu,du,pu,hu,vu,gu,xu,yu,Cu,Su,Eu,Pu=e("aS",Ga("cc.ImageAsset")((lu=su=function(e){function t(t){var n;return(n=e.call(this)||this)._nativeData=void 0,n._exportedExts=void 0,n._format=iu.RGBA8888,n._width=0,n._height=0,n._nativeData={_data:null,width:0,height:0,format:0,_compressed:!1},void 0!==t&&n.reset(t),n}a(t,e);var n=t.prototype;return n.reset=function(e){_u(e)||e instanceof HTMLElement?this._nativeData=e:(this._nativeData=e,this._format=e.format)},n.destroy=function(){return this.data&&this.data instanceof HTMLImageElement?(this.data.src="",this._setRawAsset("")):_u(this.data)&&this.data.close&&this.data.close(),e.prototype.destroy.call(this)},n._serialize=function(){},n._deserialize=function(e){var n="";"string"==typeof e?n=e:(this._width=e.w,this._height=e.h,n=e.fmt);for(var i,o=s.director.root?s.director.root.device:null,a=n.split("_"),r=Number.MAX_VALUE,c=this._format,l="",f=s.macro.SUPPORT_TEXTURE_FORMATS,_=X(a);!(i=_()).done;){var u=i.value.split("@"),m=parseInt(u[0],void 0),d=t.extnames[m]||u[0],p=f.indexOf(d);if(-1!==p&&p<r){var h=u[1]?parseInt(u[1]):this._format;if(!(".astc"!==d||o&&o.getFormatFeatures(ke.ASTC_RGBA_4X4)&je.SAMPLED_TEXTURE))continue;if(!(".pvr"!==d||o&&o.getFormatFeatures(ke.PVRTC_RGBA4)&je.SAMPLED_TEXTURE))continue;if(!(h!==iu.RGB_ETC1&&h!==iu.RGBA_ETC1||o&&o.getFormatFeatures(ke.ETC_RGB8)&je.SAMPLED_TEXTURE))continue;if(!(h!==iu.RGB_ETC2&&h!==iu.RGBA_ETC2||o&&o.getFormatFeatures(ke.ETC2_RGB8)&je.SAMPLED_TEXTURE))continue;if(".webp"===d&&!s.sys.hasFeature(s.sys.Feature.WEBP))continue;r=p,l=d,c=h}}l?(this._setRawAsset(l),this._format=c):W(3121)},n.initDefault=function(n){if(e.prototype.initDefault.call(this,n),t._sharedPlaceHolderCanvas)this.reset(t._sharedPlaceHolderCanvas);else{var i=document.createElement("canvas"),o=i.getContext("2d"),a=i.width=i.height=2;o.fillStyle="#ff00ff",o.fillRect(0,0,a,a),this.reset(i),t._sharedPlaceHolderCanvas=i}},n.validate=function(){return!!this.data},r(t,[{key:"_nativeAsset",get:function(){return this._nativeData},set:function(e){e instanceof HTMLElement||_u(e)||(e.format=e.format||this._format),this.reset(e)}},{key:"data",get:function(){return this._nativeData&&((e=this._nativeData)instanceof HTMLImageElement||e instanceof HTMLCanvasElement||_u(e))?this._nativeData:this._nativeData&&this._nativeData._data;var e}},{key:"width",get:function(){return this._nativeData.width||this._width}},{key:"height",get:function(){return this._nativeData.height||this._height}},{key:"format",get:function(){return this._format}},{key:"isCompressed",get:function(){return this._format>=iu.RGB_ETC1&&this._format<=iu.RGBA_ASTC_12x12||this._format>=iu.RGB_A_PVRTC_2BPPV1&&this._format<=iu.RGBA_ETC1}},{key:"url",get:function(){return this.nativeUrl}}]),t}(ec),su.extnames=[".png",".jpg",".jpeg",".bmp",".webp",".pvr",".pkm",".astc"],su._sharedPlaceHolderCanvas=null,ee((cu=lu).prototype,"_nativeAsset",[yr],Object.getOwnPropertyDescriptor(cu.prototype,"_nativeAsset"),cu.prototype),ru=cu))||ru);s.ImageAsset=Pu,F(ke);var Iu=new ae("Tex"),Tu=e("dA",Ga("cc.TextureBase")((Eu=Su=function(e){function t(){var t;return t=e.call(this)||this,te(t,"_format",du,J(t)),te(t,"_minFilter",pu,J(t)),te(t,"_magFilter",hu,J(t)),te(t,"_mipFilter",vu,J(t)),te(t,"_wrapS",gu,J(t)),te(t,"_wrapT",xu,J(t)),te(t,"_wrapR",yu,J(t)),te(t,"_anisotropy",Cu,J(t)),t._width=1,t._height=1,t._id=void 0,t._samplerInfo=new Ye,t._gfxSampler=null,t._gfxDevice=null,t._textureHash=0,t._id=Iu.getNewId(),t._gfxDevice=t._getGFXDevice(),t._textureHash=Xe(t._id,666),t}a(t,e);var n=t.prototype;return n.getId=function(){return this._id},n.getPixelFormat=function(){return this._format},n.getAnisotropy=function(){return this._anisotropy},n.setWrapMode=function(e,t,n){void 0===n&&(n=e),this._wrapS=e,this._samplerInfo.addressU=e,this._wrapT=t,this._samplerInfo.addressV=t,this._wrapR=n,this._samplerInfo.addressW=n,this._gfxDevice&&(this._gfxSampler=this._gfxDevice.getSampler(this._samplerInfo))},n.setFilters=function(e,t){this._minFilter=e,this._samplerInfo.minFilter=e,this._magFilter=t,this._samplerInfo.magFilter=t,this._gfxDevice&&(this._gfxSampler=this._gfxDevice.getSampler(this._samplerInfo))},n.setMipFilter=function(e){this._mipFilter=e,this._samplerInfo.mipFilter=e,this._gfxDevice&&(this._gfxSampler=this._gfxDevice.getSampler(this._samplerInfo))},n.setAnisotropy=function(e){this._anisotropy=e,this._samplerInfo.maxAnisotropy=e,this._gfxDevice&&(this._gfxSampler=this._gfxDevice.getSampler(this._samplerInfo))},n.destroy=function(){var t,n=e.prototype.destroy.call(this);return n&&(null===(t=s.director.root)||void 0===t?void 0:t.batcher2D)&&s.director.root.batcher2D._releaseDescriptorSetCache(this._textureHash),n},n.getHash=function(){return this._textureHash},n.getGFXTexture=function(){return null},n.getSamplerInfo=function(){return this._samplerInfo},n.getGFXSampler=function(){return this._gfxSampler||(this._gfxDevice?this._gfxSampler=this._gfxDevice.getSampler(this._samplerInfo):Te(9302)),this._gfxSampler},n._serialize=function(){return""},n._deserialize=function(e){var t=e.split(",");t.unshift(""),t.length>=5&&(this.setFilters(parseInt(t[1]),parseInt(t[2])),this.setWrapMode(parseInt(t[3]),parseInt(t[4]))),t.length>=7&&(this.setMipFilter(parseInt(t[5])),this.setAnisotropy(parseInt(t[6])))},n._getGFXDevice=function(){return s.director.root?s.director.root.device:null},n._getGFXFormat=function(){return this._getGFXPixelFormat(this._format)},n._setGFXFormat=function(e){this._format=void 0===e?iu.RGBA8888:e},n._getGFXPixelFormat=function(e){return e===iu.RGBA_ETC1?e=iu.RGB_ETC1:e===iu.RGB_A_PVRTC_4BPPV1?e=iu.RGB_PVRTC_4BPPV1:e===iu.RGB_A_PVRTC_2BPPV1&&(e=iu.RGB_PVRTC_2BPPV1),e},r(t,[{key:"isCompressed",get:function(){return this._format>=iu.RGB_ETC1&&this._format<=iu.RGBA_ASTC_12x12||this._format>=iu.RGB_A_PVRTC_2BPPV1&&this._format<=iu.RGBA_ETC1}},{key:"width",get:function(){return this._width}},{key:"height",get:function(){return this._height}}]),t}(ec),Su.PixelFormat=iu,Su.WrapMode=ou,Su.Filter=au,du=ee((mu=Eu).prototype,"_format",[Ya],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return iu.RGBA8888}}),pu=ee(mu.prototype,"_minFilter",[Ya],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return au.LINEAR}}),hu=ee(mu.prototype,"_magFilter",[Ya],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return au.LINEAR}}),vu=ee(mu.prototype,"_mipFilter",[Ya],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return au.NONE}}),gu=ee(mu.prototype,"_wrapS",[Ya],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return ou.REPEAT}}),xu=ee(mu.prototype,"_wrapT",[Ya],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return ou.REPEAT}}),yu=ee(mu.prototype,"_wrapR",[Ya],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return ou.REPEAT}}),Cu=ee(mu.prototype,"_anisotropy",[Ya],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return 0}}),uu=mu))||uu);s.TextureBase=Tu;var bu=e("cK",new WeakMap),Au=e("cL",new WeakSet);function wu(e,t){var n;n=Ec.safeFindClass;var i,a=Qc.pool.get();try{i=ls(e,a,{classFinder:n,customEnv:t})}catch(e){throw o(e),Qc.pool.put(a),e}i._uuid=t.__uuid__||"";for(var r=a.uuidList,c=a.uuidObjList,s=a.uuidPropList,l=a.uuidTypeList||[],f=[],_=0;_<r.length;_++){var u=r[_];f[_]={uuid:zr(u),owner:c[_],prop:s[_],type:G._getClassById(l[_])}}return bu.set(i,f),i._native&&Au.add(i),Qc.pool.put(a),i}e("d0",new WeakSet);var Nu,Du=function(){function e(){this._depends=new Er}var t=e.prototype;return t.init=function(){this._depends.clear()},t.getNativeDep=function(e){var t=this._depends.get(e);return t&&t.nativeDep?Re({},t.nativeDep):null},t.getDeps=function(e){return this._depends.has(e)?this._depends.get(e).deps:[]},t.getDepsRecursively=function(e){var t=Object.create(null),n=[];return this._descend(e,t,n),n},t.remove=function(e){this._depends.remove(e)},t.parse=function(e,t){var n,i,o=null;if(Array.isArray(t)||t.__type__||t instanceof Mc){if(this._depends.has(e))return this._depends.get(e);if(!Array.isArray(t)||"number"==typeof(i=(n=t[5])[n.length-1])&&i<0)try{var a=wu(t,{__uuid__:e});(o=this._parseDepsFromAsset(a)).nativeDep&&(o.nativeDep.uuid=e),Ar.add(e+"@import",a)}catch(t){br.remove(e+"@import"),o={deps:[]}}else o={deps:this._parseDepsFromJson(t)}}else{if(this._depends.has(e)&&(o=this._depends.get(e)).parsedFromExistAsset)return o;o=this._parseDepsFromAsset(t)}return this._depends.add(e,o),o},t._parseDepsFromAsset=function(e){for(var t={deps:[],parsedFromExistAsset:!0},n=bu.get(e),i=0,o=n.length;i<o;i++)t.deps.push(n[i].uuid);return Au.has(e)&&(t.nativeDep=e._nativeDep),t},t._parseDepsFromJson=function(e){var t=function(e){return n=(t=e)[Wc],t[10].map((function(e){return n[e]}));var t,n}(e);return t.forEach((function(e,n){return t[n]=zr(e)})),t},t._descend=function(e,t,n){for(var i=this.getDeps(e),o=0;o<i.length;o++){var a=i[o];t[a]||(t[a]=!0,n.push(a),this._descend(a,t,n))}},e}(),Ru=e("cI",new Du),Mu=[new $e];function Ou(e){return e&&0==(e&e-1)}var Lu,zu,Fu,Uu,Gu,Bu,Hu=Ga("cc.SimpleTexture")(Nu=function(e){function t(){for(var t,n=arguments.length,i=new Array(n),o=0;o<n;o++)i[o]=arguments[o];return(t=e.call.apply(e,[this].concat(i))||this)._gfxTexture=null,t._gfxTextureView=null,t._mipmapLevel=1,t._textureWidth=0,t._textureHeight=0,t._baseLevel=0,t._maxLevel=1e3,t}a(t,e);var n=t.prototype;return n.getGFXTexture=function(){return this._gfxTextureView},n.destroy=function(){return this._tryDestroyTextureView(),this._tryDestroyTexture(),e.prototype.destroy.call(this)},n.updateImage=function(){this.updateMipmaps(0)},n.updateMipmaps=function(){},n.uploadData=function(e,t,n){if(void 0===t&&(t=0),void 0===n&&(n=0),this._gfxTexture&&!(this._mipmapLevel<=t)){var i=this._getGFXDevice();if(i){var o=Mu[0];o.texExtent.width=this._textureWidth>>t,o.texExtent.height=this._textureHeight>>t,o.texSubres.mipLevel=t,o.texSubres.baseArrayLayer=n,ArrayBuffer.isView(e)?i.copyBuffersToTexture([e],this._gfxTexture,Mu):i.copyTexImagesToTexture([e],this._gfxTexture,Mu)}}},n._assignImage=function(e,t,n){var i=e.data;if(i&&(this.uploadData(i,t,n),this._checkTextureLoaded(),Ke.CLEANUP_IMAGE_CACHE)){var o=Ru.getDeps(this._uuid),a=o.indexOf(e._uuid);-1!==a&&(Je(o,a),e.decRef())}},n._checkTextureLoaded=function(){this._textureReady()},n._textureReady=function(){this.loaded=!0,this.emit("load")},n._setMipmapLevel=function(e){this._mipmapLevel=e<1?1:e},n._setMipRange=function(e,t){this._baseLevel=e<1?0:e,this._maxLevel=t<1?0:t},n.setMipRange=function(e,t){ne(e<=t,3124),this._setMipRange(e,t);var n=this._getGFXDevice();if(n){var i=this._createTextureView(n);this._tryDestroyTextureView(),this._gfxTextureView=i}},n._getGfxTextureCreateInfo=function(){return null},n._getGfxTextureViewCreateInfo=function(){return null},n._tryReset=function(){if(this._tryDestroyTextureView(),this._tryDestroyTexture(),0!==this._mipmapLevel){var e=this._getGFXDevice();e&&(this._createTexture(e),this._gfxTextureView=this._createTextureView(e))}},n._createTexture=function(e){if(0!==this._width&&0!==this._height){var t=Qe.NONE;this._mipFilter!==au.NONE&&function(e,t,n){return!(e.gfxAPI===et.WEBGL)||Ou(t)&&Ou(n)}(e,this._width,this._height)&&(this._mipmapLevel=function(e,t){for(var n=Math.max(e,t),i=0;n;)n>>=1,i++;return i}(this._width,this._height),t=Qe.GEN_MIPMAP);var n=this._getGfxTextureCreateInfo({usage:Ze.SAMPLED|Ze.TRANSFER_DST,format:this._getGFXFormat(),levelCount:this._mipmapLevel,flags:t});if(n){var i=e.createTexture(n);this._textureWidth=n.width,this._textureHeight=n.height,this._gfxTexture=i}}},n._createTextureView=function(e){if(!this._gfxTexture)return null;var t=this._maxLevel<this._mipmapLevel?this._maxLevel:this._mipmapLevel-1,n=this._getGfxTextureViewCreateInfo({texture:this._gfxTexture,format:this._getGFXFormat(),baseLevel:this._baseLevel,levelCount:t-this._baseLevel+1});return n?e.createTexture(n):null},n._tryDestroyTexture=function(){this._gfxTexture&&(this._gfxTexture.destroy(),this._gfxTexture=null)},n._tryDestroyTextureView=function(){this._gfxTextureView&&(this._gfxTextureView.destroy(),this._gfxTextureView=null)},r(t,[{key:"mipmapLevel",get:function(){return this._mipmapLevel}}]),t}(Tu))||Nu;s.SimpleTexture=Hu;var Vu,ku,ju,qu,Wu,Yu,Xu,Ku=e("aT",(Lu=Ga("cc.Texture2D"),zu=xr([Pu]),Lu((Bu=function(e){function t(){for(var t,n=arguments.length,i=new Array(n),o=0;o<n;o++)i[o]=arguments[o];return t=e.call.apply(e,[this].concat(i))||this,te(t,"_mipmaps",Gu,J(t)),t}a(t,e);var n=t.prototype;return n.initialize=function(){this.mipmaps=this._mipmaps},n.onLoaded=function(){this.initialize()},n.reset=function(e){this._width=e.width,this._height=e.height,this._setGFXFormat(e.format);var t=void 0===e.mipmapLevel?1:e.mipmapLevel;this._setMipmapLevel(t);var n=void 0===e.baseLevel?0:e.baseLevel,i=void 0===e.maxLevel?1e3:e.maxLevel;this._setMipRange(n,i),this._tryReset()},n.create=function(e,t,n,i,o,a){void 0===n&&(n=iu.RGBA8888),void 0===i&&(i=1),void 0===o&&(o=0),void 0===a&&(a=1e3),this.reset({width:e,height:t,format:n,mipmapLevel:i,baseLevel:o,maxLevel:a})},n.toString=function(){return 0!==this._mipmaps.length?this._mipmaps[0].url:""},n.updateMipmaps=function(e,t){if(void 0===e&&(e=0),!(e>=this._mipmaps.length))for(var n=Math.min(void 0===t?this._mipmaps.length:t,this._mipmaps.length-e),i=0;i<n;++i){var o=e+i;this._assignImage(this._mipmaps[o],o)}},n.getHtmlElementObj=function(){return this._mipmaps[0]&&this._mipmaps[0].data instanceof HTMLElement?this._mipmaps[0].data:null},n.destroy=function(){return this._mipmaps=[],e.prototype.destroy.call(this)},n.description=function(){return"<cc.Texture2D | Name = "+(this._mipmaps[0]?this._mipmaps[0].url:"")+" | Dimension = "+this.width+" x "+this.height+">"},n.releaseTexture=function(){this.destroy()},n._serialize=function(){return null},n._deserialize=function(t,n){var i=t;e.prototype._deserialize.call(this,i.base,n),this._mipmaps=new Array(i.mipmaps.length);for(var o=0;o<i.mipmaps.length;++o)if(this._mipmaps[o]=new Pu,i.mipmaps[o]){var a=i.mipmaps[o];n.result.push(this._mipmaps,""+o,a,G._getClassId(Pu))}},n._getGfxTextureCreateInfo=function(e){var t=new tt(nt.TEX2D);return t.width=this._width,t.height=this._height,Object.assign(t,e),t},n._getGfxTextureViewCreateInfo=function(e){var t=new it;return t.type=nt.TEX2D,Object.assign(t,e),t},n.initDefault=function(t){e.prototype.initDefault.call(this,t);var n=new Pu;n.initDefault(),this.image=n},n.validate=function(){return this.mipmaps&&0!==this.mipmaps.length},r(t,[{key:"mipmaps",get:function(){return this._mipmaps},set:function(e){var t=this;if(this._mipmaps=e,this._setMipmapLevel(this._mipmaps.length),this._mipmaps.length>0){var n=this._mipmaps[0];this.reset({width:n.width,height:n.height,format:n.format,mipmapLevel:this._mipmaps.length,baseLevel:this._baseLevel,maxLevel:this._maxLevel}),this._mipmaps.forEach((function(e,n){t._assignImage(e,n)}))}else this.reset({width:0,height:0,mipmapLevel:this._mipmaps.length,baseLevel:this._baseLevel,maxLevel:this._maxLevel})}},{key:"image",get:function(){return 0===this._mipmaps.length?null:this._mipmaps[0]},set:function(e){this.mipmaps=e?[e]:[]}}]),t}(Hu),Gu=ee((Uu=Bu).prototype,"_mipmaps",[zu],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return[]}}),Fu=Uu))||Fu));s.Texture2D=Ku,function(e){e[e.right=0]="right",e[e.left=1]="left",e[e.top=2]="top",e[e.bottom=3]="bottom",e[e.front=4]="front",e[e.back=5]="back"}(Xu||(Xu={}));var Ju=e("aU",Ga("cc.TextureCube")((Yu=Wu=function(e){function t(){for(var t,n=arguments.length,i=new Array(n),o=0;o<n;o++)i[o]=arguments[o];return t=e.call.apply(e,[this].concat(i))||this,te(t,"isRGBE",ju,J(t)),te(t,"_mipmaps",qu,J(t)),t}a(t,e),t.fromTexture2DArray=function(e,n){for(var i=[],o=e.length/6,a=0;a<o;a++){var r=6*a;i.push({front:e[r+Xu.front].image,back:e[r+Xu.back].image,left:e[r+Xu.left].image,right:e[r+Xu.right].image,top:e[r+Xu.top].image,bottom:e[r+Xu.bottom].image})}return(n=n||new t).mipmaps=i,n};var n=t.prototype;return n.onLoaded=function(){this.mipmaps=this._mipmaps},n.reset=function(e){this._width=e.width,this._height=e.height,this._setGFXFormat(e.format);var t=void 0===e.mipmapLevel?1:e.mipmapLevel;this._setMipmapLevel(t);var n=void 0===e.baseLevel?0:e.baseLevel,i=void 0===e.maxLevel?1e3:e.maxLevel;this._setMipRange(n,i),this._tryReset()},n.updateMipmaps=function(e,t){var n=this;if(void 0===e&&(e=0),!(e>=this._mipmaps.length))for(var i=Math.min(void 0===t?this._mipmaps.length:t,this._mipmaps.length-e),o=function(t){var i=e+t;Qu(n._mipmaps[i],(function(e,t){n._assignImage(e,i,t)}))},a=0;a<i;++a)o(a)},n.destroy=function(){return this._mipmaps=[],e.prototype.destroy.call(this)},n.releaseTexture=function(){this.mipmaps=[]},n._serialize=function(){return null},n._deserialize=function(t,n){var i=t;e.prototype._deserialize.call(this,i.base,n),this.isRGBE=i.rgbe,this._mipmaps=new Array(i.mipmaps.length);for(var o=0;o<i.mipmaps.length;++o){this._mipmaps[o]={front:new Pu,back:new Pu,left:new Pu,right:new Pu,top:new Pu,bottom:new Pu};var a=i.mipmaps[o],r=G._getClassId(Pu);n.result.push(this._mipmaps[o],"front",a.front,r),n.result.push(this._mipmaps[o],"back",a.back,r),n.result.push(this._mipmaps[o],"left",a.left,r),n.result.push(this._mipmaps[o],"right",a.right,r),n.result.push(this._mipmaps[o],"top",a.top,r),n.result.push(this._mipmaps[o],"bottom",a.bottom,r)}},n._getGfxTextureCreateInfo=function(e){var t=new tt(nt.CUBE);return t.width=this._width,t.height=this._height,t.layerCount=6,Object.assign(t,e),t},n._getGfxTextureViewCreateInfo=function(e){var t=new it;return t.type=nt.CUBE,t.baseLayer=0,t.layerCount=6,Object.assign(t,e),t},n.initDefault=function(t){e.prototype.initDefault.call(this,t);var n=new Pu;n.initDefault(),this.mipmaps=[{front:n,back:n,top:n,bottom:n,left:n,right:n}]},n.validate=function(){return 0!==this._mipmaps.length&&!this._mipmaps.find((function(e){return!(e.top&&e.bottom&&e.front&&e.back&&e.left&&e.right)}))},r(t,[{key:"mipmaps",get:function(){return this._mipmaps},set:function(e){var t=this;if(this._mipmaps=e,this._setMipmapLevel(this._mipmaps.length),this._mipmaps.length>0){var n=this._mipmaps[0].front;this.reset({width:n.width,height:n.height,format:n.format,mipmapLevel:this._mipmaps.length,baseLevel:this._baseLevel,maxLevel:this._maxLevel}),this._mipmaps.forEach((function(e,n){Qu(e,(function(e,i){t._assignImage(e,n,i)}))}))}else this.reset({width:0,height:0,mipmapLevel:this._mipmaps.length,baseLevel:this._baseLevel,maxLevel:this._maxLevel})}},{key:"image",get:function(){return 0===this._mipmaps.length?null:this._mipmaps[0]},set:function(e){this.mipmaps=e?[e]:[]}}]),t}(Hu),Wu.FaceIndex=Xu,ju=ee((ku=Yu).prototype,"isRGBE",[Ya],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return!1}}),qu=ee(ku.prototype,"_mipmaps",[Ya],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return[]}}),Vu=ku))||Vu);function Qu(e,t){t(e.front,Xu.front),t(e.back,Xu.back),t(e.left,Xu.left),t(e.right,Xu.right),t(e.top,Xu.top),t(e.bottom,Xu.bottom)}s.TextureCube=Ju;var Zu,$u,em=e("bn",[{name:"billboard",techniques:[{name:"add",passes:[{rasterizerState:{cullMode:0},blendState:{targets:[{blend:!0,blendSrc:2,blendDst:1,blendSrcAlpha:2,blendDstAlpha:1}]},program:"billboard|vert:vs_main|tinted-fs:add",depthStencilState:{depthTest:!0,depthWrite:!1},properties:{mainTexture:{value:"grey",type:28},mainTiling_Offset:{value:[1,1,0,0],type:16},tintColor:{value:[.5,.5,.5,.5],type:16}}}]}],shaders:[{name:"billboard|vert:vs_main|tinted-fs:add",hash:3642336485,builtins:{statistics:{CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS:54,CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS:40},globals:{blocks:[{name:"CCGlobal",defines:[]},{name:"CCCamera",defines:[]}],samplerTextures:[],buffers:[],images:[]},locals:{blocks:[{name:"CCLocal",defines:[]}],samplerTextures:[],buffers:[],images:[]}},defines:[],attributes:[{name:"a_position",defines:[],format:32,location:0},{name:"a_texCoord",defines:[],format:21,location:1},{name:"a_color",defines:[],format:44,location:2}],blocks:[{name:"Constants",defines:[],binding:0,stageFlags:1,members:[{name:"mainTiling_Offset",type:16,count:1},{name:"frameTile_velLenScale",type:16,count:1},{name:"scale",type:16,count:1},{name:"nodeRotation",type:16,count:1}]},{name:"builtin",defines:[],binding:1,stageFlags:1,members:[{name:"cc_size_rotation",type:16,count:1}]},{name:"FragConstants",defines:[],binding:2,stageFlags:16,members:[{name:"tintColor",type:16,count:1}]}],samplerTextures:[{name:"mainTexture",type:28,count:1,defines:[],stageFlags:16,binding:3}],buffers:[],images:[],textures:[],samplers:[],subpassInputs:[]}]},{name:"clear-stencil",techniques:[{passes:[{blendState:{targets:[{blend:!0}]},rasterizerState:{cullMode:0},program:"clear-stencil|sprite-vs:vert|sprite-fs:frag",depthStencilState:{depthTest:!1,depthWrite:!1}}]}],shaders:[{name:"clear-stencil|sprite-vs:vert|sprite-fs:frag",hash:3507038093,builtins:{statistics:{CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS:0,CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS:0},globals:{blocks:[],samplerTextures:[],buffers:[],images:[]},locals:{blocks:[],samplerTextures:[],buffers:[],images:[]}},defines:[],attributes:[{name:"a_position",defines:[],format:32,location:0}],blocks:[],samplerTextures:[],buffers:[],images:[],textures:[],samplers:[],subpassInputs:[]}]},{name:"geometry-renderer",techniques:[{passes:[{primitive:1,blendState:{targets:[{blend:!0,blendSrc:2,blendDst:4,blendDstAlpha:4}]},program:"geometry-renderer|line-vs:vert|line-fs:front",priority:245,depthStencilState:{depthTest:!1,depthWrite:!1}}]},{passes:[{primitive:1,blendState:{targets:[{blend:!0,blendSrc:2,blendDst:4,blendDstAlpha:4}]},program:"geometry-renderer|line-vs:vert|line-fs:front",priority:245,depthStencilState:{depthTest:!0,depthWrite:!1}},{primitive:1,blendState:{targets:[{blend:!0,blendSrc:2,blendDst:4,blendDstAlpha:4}]},program:"geometry-renderer|line-vs:vert|line-fs:back",priority:245,depthStencilState:{depthTest:!0,depthWrite:!1,depthFunc:4}}]},{passes:[{primitive:1,blendState:{targets:[{blend:!0,blendSrc:2,blendDst:4,blendDstAlpha:4}]},program:"geometry-renderer|dashed-line-vs:vert|dashed-line-fs:front",priority:245,depthStencilState:{depthTest:!1,depthWrite:!1}}]},{passes:[{primitive:1,blendState:{targets:[{blend:!0,blendSrc:2,blendDst:4,blendDstAlpha:4}]},program:"geometry-renderer|dashed-line-vs:vert|dashed-line-fs:front",priority:245,depthStencilState:{depthTest:!0,depthWrite:!1}},{primitive:1,blendState:{targets:[{blend:!0,blendSrc:2,blendDst:4,blendDstAlpha:4}]},program:"geometry-renderer|dashed-line-vs:vert|dashed-line-fs:back",priority:245,depthStencilState:{depthTest:!0,depthWrite:!1,depthFunc:4}}]},{passes:[{rasterizerState:{cullMode:2},blendState:{targets:[{blend:!0,blendSrc:2,blendDst:4,blendDstAlpha:4}]},program:"geometry-renderer|triangle-vs:vert|triangle-fs:front",priority:245,depthStencilState:{depthTest:!1,depthWrite:!1}}]},{passes:[{rasterizerState:{cullMode:2},blendState:{targets:[{blend:!0,blendSrc:2,blendDst:4,blendDstAlpha:4}]},program:"geometry-renderer|triangle-vs:vert|triangle-fs:front",priority:245,depthStencilState:{depthTest:!0,depthWrite:!1}},{rasterizerState:{cullMode:2},blendState:{targets:[{blend:!0,blendSrc:2,blendDst:4,blendDstAlpha:4}]},program:"geometry-renderer|triangle-vs:vert|triangle-fs:back",priority:245,depthStencilState:{depthTest:!0,depthWrite:!1,depthFunc:4}}]}],shaders:[{name:"geometry-renderer|line-vs:vert|line-fs:front",hash:3617431e3,builtins:{statistics:{CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS:39,CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS:39},globals:{blocks:[{name:"CCGlobal",defines:[]},{name:"CCCamera",defines:[]}],samplerTextures:[],buffers:[],images:[]},locals:{blocks:[],samplerTextures:[],buffers:[],images:[]}},defines:[{name:"USE_FORWARD_PIPELINE",type:"boolean"}],attributes:[{name:"a_position",defines:[],format:32,location:0},{name:"a_color",defines:[],format:44,location:1}],blocks:[],samplerTextures:[],buffers:[],images:[],textures:[],samplers:[],subpassInputs:[]},{name:"geometry-renderer|line-vs:vert|line-fs:back",hash:4168905198,builtins:{statistics:{CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS:39,CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS:39},globals:{blocks:[{name:"CCGlobal",defines:[]},{name:"CCCamera",defines:[]}],samplerTextures:[],buffers:[],images:[]},locals:{blocks:[],samplerTextures:[],buffers:[],images:[]}},defines:[{name:"USE_FORWARD_PIPELINE",type:"boolean"}],attributes:[{name:"a_position",defines:[],format:32,location:0},{name:"a_color",defines:[],format:44,location:1}],blocks:[],samplerTextures:[],buffers:[],images:[],textures:[],samplers:[],subpassInputs:[]},{name:"geometry-renderer|dashed-line-vs:vert|dashed-line-fs:front",hash:4034582016,builtins:{statistics:{CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS:39,CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS:39},globals:{blocks:[{name:"CCGlobal",defines:[]},{name:"CCCamera",defines:[]}],samplerTextures:[],buffers:[],images:[]},locals:{blocks:[],samplerTextures:[],buffers:[],images:[]}},defines:[{name:"USE_FORWARD_PIPELINE",type:"boolean"}],attributes:[{name:"a_position",defines:[],format:32,location:0},{name:"a_color",defines:[],format:44,location:1}],blocks:[],samplerTextures:[],buffers:[],images:[],textures:[],samplers:[],subpassInputs:[]},{name:"geometry-renderer|dashed-line-vs:vert|dashed-line-fs:back",hash:1762165009,builtins:{statistics:{CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS:39,CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS:39},globals:{blocks:[{name:"CCGlobal",defines:[]},{name:"CCCamera",defines:[]}],samplerTextures:[],buffers:[],images:[]},locals:{blocks:[],samplerTextures:[],buffers:[],images:[]}},defines:[{name:"USE_FORWARD_PIPELINE",type:"boolean"}],attributes:[{name:"a_position",defines:[],format:32,location:0},{name:"a_color",defines:[],format:44,location:1}],blocks:[],samplerTextures:[],buffers:[],images:[],textures:[],samplers:[],subpassInputs:[]},{name:"geometry-renderer|triangle-vs:vert|triangle-fs:front",hash:4143142643,builtins:{statistics:{CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS:39,CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS:39},globals:{blocks:[{name:"CCGlobal",defines:[]},{name:"CCCamera",defines:[]}],samplerTextures:[],buffers:[],images:[]},locals:{blocks:[],samplerTextures:[],buffers:[],images:[]}},defines:[{name:"USE_FORWARD_PIPELINE",type:"boolean"}],attributes:[{name:"a_position",defines:[],format:32,location:0},{name:"a_normal",defines:[],format:44,location:1},{name:"a_color",defines:[],format:44,location:2}],blocks:[],samplerTextures:[],buffers:[],images:[],textures:[],samplers:[],subpassInputs:[]},{name:"geometry-renderer|triangle-vs:vert|triangle-fs:back",hash:826026446,builtins:{statistics:{CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS:39,CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS:39},globals:{blocks:[{name:"CCGlobal",defines:[]},{name:"CCCamera",defines:[]}],samplerTextures:[],buffers:[],images:[]},locals:{blocks:[],samplerTextures:[],buffers:[],images:[]}},defines:[{name:"USE_FORWARD_PIPELINE",type:"boolean"}],attributes:[{name:"a_position",defines:[],format:32,location:0},{name:"a_normal",defines:[],format:44,location:1},{name:"a_color",defines:[],format:44,location:2}],blocks:[],samplerTextures:[],buffers:[],images:[],textures:[],samplers:[],subpassInputs:[]}]},{name:"graphics",techniques:[{passes:[{blendState:{targets:[{blend:!0,blendSrc:1,blendDst:4,blendSrcAlpha:1,blendDstAlpha:4}]},rasterizerState:{cullMode:0},program:"graphics|vs:vert|fs:frag",depthStencilState:{depthTest:!1,depthWrite:!1}}]}],shaders:[{name:"graphics|vs:vert|fs:frag",hash:4284763886,builtins:{statistics:{CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS:49,CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS:0},globals:{blocks:[{name:"CCGlobal",defines:[]},{name:"CCCamera",defines:[]}],samplerTextures:[],buffers:[],images:[]},locals:{blocks:[{name:"CCLocal",defines:[]}],samplerTextures:[],buffers:[],images:[]}},defines:[],attributes:[{name:"a_position",defines:[],format:32,location:0},{name:"a_color",defines:[],format:44,location:1},{name:"a_dist",defines:[],format:11,location:2}],blocks:[],samplerTextures:[],buffers:[],images:[],textures:[],samplers:[],subpassInputs:[]}]},{name:"occlusion-query",techniques:[{passes:[{rasterizerState:{cullMode:2},blendState:{targets:[{blendColorMask:0}]},program:"occlusion-query|occlusion-query-vs:vert|occlusion-query-fs:frag",depthStencilState:{depthTest:!0,depthWrite:!1}}]}],shaders:[{name:"occlusion-query|occlusion-query-vs:vert|occlusion-query-fs:frag",hash:1571978323,builtins:{statistics:{CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS:41,CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS:0},globals:{blocks:[{name:"CCGlobal",defines:[]},{name:"CCCamera",defines:[]}],samplerTextures:[],buffers:[],images:[]},locals:{blocks:[{name:"CCWorldBound",defines:[]}],samplerTextures:[],buffers:[],images:[]}},defines:[],attributes:[{name:"a_position",defines:[],format:32,location:0}],blocks:[],samplerTextures:[],buffers:[],images:[],textures:[],samplers:[],subpassInputs:[]}]},{name:"particle-gpu",techniques:[{name:"add",passes:[{rasterizerState:{cullMode:0},blendState:{targets:[{blend:!0,blendSrc:2,blendDst:1,blendSrcAlpha:2,blendDstAlpha:1}]},program:"particle-gpu|particle-vs-gpu:gpvs_main|tinted-fs:add",depthStencilState:{depthTest:!0,depthWrite:!1},properties:{mainTexture:{value:"grey",type:28},mainTiling_Offset:{value:[1,1,0,0],type:16},tintColor:{value:[.5,.5,.5,.5],type:16}}}]}],shaders:[{name:"particle-gpu|particle-vs-gpu:gpvs_main|tinted-fs:add",hash:851293782,builtins:{statistics:{CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS:64,CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS:40},globals:{blocks:[{name:"CCGlobal",defines:[]},{name:"CCCamera",defines:[]}],samplerTextures:[],buffers:[],images:[]},locals:{blocks:[{name:"CCLocal",defines:[]}],samplerTextures:[],buffers:[],images:[]}},defines:[{name:"CC_RENDER_MODE",type:"number",range:[0,4]},{name:"USE_VK_SHADER",type:"boolean"},{name:"COLOR_OVER_TIME_MODULE_ENABLE",type:"boolean"},{name:"ROTATION_OVER_TIME_MODULE_ENABLE",type:"boolean"},{name:"SIZE_OVER_TIME_MODULE_ENABLE",type:"boolean"},{name:"FORCE_OVER_TIME_MODULE_ENABLE",type:"boolean"},{name:"VELOCITY_OVER_TIME_MODULE_ENABLE",type:"boolean"},{name:"TEXTURE_ANIMATION_MODULE_ENABLE",type:"boolean"},{name:"CC_USE_WORLD_SPACE",type:"boolean"}],attributes:[{name:"a_position_starttime",defines:[],format:44,location:0},{name:"a_size_uv",defines:[],format:44,location:1},{name:"a_rotation_uv",defines:[],format:44,location:2},{name:"a_color",defines:[],format:44,location:3},{name:"a_dir_life",defines:[],format:44,location:4},{name:"a_rndSeed",defines:[],format:11,location:5},{name:"a_texCoord",defines:["CC_RENDER_MODE"],format:32,location:6},{name:"a_texCoord3",defines:["CC_RENDER_MODE"],format:32,location:7},{name:"a_normal",defines:["CC_RENDER_MODE"],format:32,location:8},{name:"a_color1",defines:["CC_RENDER_MODE"],format:44,location:9}],blocks:[{name:"Constants",defines:[],binding:0,stageFlags:1,members:[{name:"mainTiling_Offset",type:16,count:1},{name:"frameTile_velLenScale",type:16,count:1},{name:"scale",type:16,count:1},{name:"nodeRotation",type:16,count:1}]},{name:"SampleConstants",defines:[],binding:1,stageFlags:1,members:[{name:"u_sampleInfo",type:16,count:1}]},{name:"TickConstants",defines:[],binding:2,stageFlags:1,members:[{name:"u_worldRot",type:16,count:1},{name:"u_timeDelta",type:16,count:1}]},{name:"ColorConstant",defines:["COLOR_OVER_TIME_MODULE_ENABLE"],binding:3,stageFlags:1,members:[{name:"u_color_mode",type:5,count:1}]},{name:"RotationConstant",defines:["ROTATION_OVER_TIME_MODULE_ENABLE"],binding:4,stageFlags:1,members:[{name:"u_rotation_mode",type:5,count:1}]},{name:"SizeConstant",defines:["SIZE_OVER_TIME_MODULE_ENABLE"],binding:5,stageFlags:1,members:[{name:"u_size_mode",type:5,count:1}]},{name:"ForceConstant",defines:["FORCE_OVER_TIME_MODULE_ENABLE"],binding:6,stageFlags:1,members:[{name:"u_force_mode",type:5,count:1},{name:"u_force_space",type:5,count:1}]},{name:"VelocityConstant",defines:["VELOCITY_OVER_TIME_MODULE_ENABLE"],binding:7,stageFlags:1,members:[{name:"u_velocity_mode",type:5,count:1},{name:"u_velocity_space",type:5,count:1}]},{name:"AnimationConstant",defines:["TEXTURE_ANIMATION_MODULE_ENABLE"],binding:8,stageFlags:1,members:[{name:"u_anim_info",type:16,count:1}]},{name:"FragConstants",defines:[],binding:9,stageFlags:16,members:[{name:"tintColor",type:16,count:1}]}],samplerTextures:[{name:"color_over_time_tex0",type:28,count:1,defines:["COLOR_OVER_TIME_MODULE_ENABLE"],stageFlags:1,binding:10},{name:"rotation_over_time_tex0",type:28,count:1,defines:["ROTATION_OVER_TIME_MODULE_ENABLE"],stageFlags:1,binding:11},{name:"size_over_time_tex0",type:28,count:1,defines:["SIZE_OVER_TIME_MODULE_ENABLE"],stageFlags:1,binding:12},{name:"force_over_time_tex0",type:28,count:1,defines:["FORCE_OVER_TIME_MODULE_ENABLE"],stageFlags:1,binding:13},{name:"velocity_over_time_tex0",type:28,count:1,defines:["VELOCITY_OVER_TIME_MODULE_ENABLE"],stageFlags:1,binding:14},{name:"texture_animation_tex0",type:28,count:1,defines:["TEXTURE_ANIMATION_MODULE_ENABLE"],stageFlags:1,binding:15},{name:"mainTexture",type:28,count:1,defines:[],stageFlags:16,binding:16}],buffers:[],images:[],textures:[],samplers:[],subpassInputs:[]}]},{name:"particle-trail",techniques:[{name:"add",passes:[{rasterizerState:{cullMode:0},blendState:{targets:[{blend:!0,blendSrc:2,blendDst:1,blendSrcAlpha:2,blendDstAlpha:1}]},program:"particle-trail|particle-trail:vs_main|tinted-fs:add",depthStencilState:{depthTest:!0,depthWrite:!1},properties:{mainTexture:{value:"grey",type:28},mainTiling_Offset:{value:[1,1,0,0],type:16},frameTile_velLenScale:{value:[1,1,0,0],type:16},tintColor:{value:[.5,.5,.5,.5],type:16}}}]}],shaders:[{name:"particle-trail|particle-trail:vs_main|tinted-fs:add",hash:2502358098,builtins:{statistics:{CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS:53,CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS:40},globals:{blocks:[{name:"CCGlobal",defines:[]},{name:"CCCamera",defines:[]}],samplerTextures:[],buffers:[],images:[]},locals:{blocks:[{name:"CCLocal",defines:[]}],samplerTextures:[],buffers:[],images:[]}},defines:[{name:"CC_RENDER_MODE",type:"number",range:[0,4]},{name:"CC_DRAW_WIRE_FRAME",type:"boolean"},{name:"CC_USE_WORLD_SPACE",type:"boolean"}],attributes:[{name:"a_position",defines:[],format:32,location:0},{name:"a_texCoord",defines:[],format:44,location:1},{name:"a_texCoord1",defines:[],format:32,location:2},{name:"a_texCoord2",defines:[],format:32,location:3},{name:"a_color",defines:[],format:44,location:4}],blocks:[{name:"Constants",defines:[],binding:0,stageFlags:1,members:[{name:"mainTiling_Offset",type:16,count:1},{name:"frameTile_velLenScale",type:16,count:1},{name:"scale",type:16,count:1},{name:"nodeRotation",type:16,count:1}]},{name:"FragConstants",defines:[],binding:1,stageFlags:16,members:[{name:"tintColor",type:16,count:1}]}],samplerTextures:[{name:"mainTexture",type:28,count:1,defines:[],stageFlags:16,binding:2}],buffers:[],images:[],textures:[],samplers:[],subpassInputs:[]}]},{name:"particle",techniques:[{name:"add",passes:[{rasterizerState:{cullMode:0},blendState:{targets:[{blend:!0,blendSrc:2,blendDst:1,blendSrcAlpha:2,blendDstAlpha:1}]},program:"particle|particle-vs-legacy:lpvs_main|tinted-fs:add",depthStencilState:{depthTest:!0,depthWrite:!1},properties:{mainTexture:{value:"grey",type:28},mainTiling_Offset:{value:[1,1,0,0],type:16},tintColor:{value:[.5,.5,.5,.5],type:16}}}]}],shaders:[{name:"particle|particle-vs-legacy:lpvs_main|tinted-fs:add",hash:585841727,builtins:{statistics:{CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS:53,CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS:40},globals:{blocks:[{name:"CCGlobal",defines:[]},{name:"CCCamera",defines:[]}],samplerTextures:[],buffers:[],images:[]},locals:{blocks:[{name:"CCLocal",defines:[]}],samplerTextures:[],buffers:[],images:[]}},defines:[{name:"CC_RENDER_MODE",type:"number",range:[0,4]},{name:"CC_USE_WORLD_SPACE",type:"boolean"},{name:"ROTATION_OVER_TIME_MODULE_ENABLE",type:"boolean"}],attributes:[{name:"a_position",defines:[],format:32,location:0},{name:"a_texCoord",defines:[],format:32,location:1},{name:"a_texCoord1",defines:[],format:32,location:2},{name:"a_texCoord2",defines:[],format:32,location:3},{name:"a_color",defines:[],format:44,location:4},{name:"a_color1",defines:["CC_RENDER_MODE"],format:32,location:8},{name:"a_texCoord3",defines:["CC_RENDER_MODE"],format:32,location:6},{name:"a_normal",defines:["CC_RENDER_MODE"],format:32,location:7}],blocks:[{name:"Constants",defines:[],binding:0,stageFlags:1,members:[{name:"mainTiling_Offset",type:16,count:1},{name:"frameTile_velLenScale",type:16,count:1},{name:"scale",type:16,count:1},{name:"nodeRotation",type:16,count:1}]},{name:"FragConstants",defines:[],binding:1,stageFlags:16,members:[{name:"tintColor",type:16,count:1}]}],samplerTextures:[{name:"mainTexture",type:28,count:1,defines:[],stageFlags:16,binding:2}],buffers:[],images:[],textures:[],samplers:[],subpassInputs:[]}]},{name:"spine",techniques:[{passes:[{blendState:{targets:[{blend:!0,blendSrc:2,blendDst:4,blendDstAlpha:4}]},rasterizerState:{cullMode:0},program:"spine|sprite-vs:vert|sprite-fs:frag",depthStencilState:{depthTest:!1,depthWrite:!1},properties:{alphaThreshold:{value:[.5],type:13}}}]}],shaders:[{name:"spine|sprite-vs:vert|sprite-fs:frag",hash:2499219289,builtins:{statistics:{CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS:49,CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS:1},globals:{blocks:[{name:"CCGlobal",defines:[]},{name:"CCCamera",defines:[]}],samplerTextures:[],buffers:[],images:[]},locals:{blocks:[{name:"CCLocal",defines:["USE_LOCAL"]}],samplerTextures:[{name:"cc_spriteTexture",defines:[]}],buffers:[],images:[]}},defines:[{name:"USE_LOCAL",type:"boolean"},{name:"TWO_COLORED",type:"boolean"},{name:"USE_ALPHA_TEST",type:"boolean"}],attributes:[{name:"a_position",defines:[],format:32,location:0},{name:"a_texCoord",defines:[],format:21,location:1},{name:"a_color",defines:[],format:44,location:2},{name:"a_color2",defines:["TWO_COLORED"],format:44,location:3}],blocks:[{name:"ALPHA_TEST_DATA",defines:["USE_ALPHA_TEST"],binding:0,stageFlags:16,members:[{name:"alphaThreshold",type:13,count:1}]}],samplerTextures:[],buffers:[],images:[],textures:[],samplers:[],subpassInputs:[]}]},{name:"sprite",techniques:[{passes:[{blendState:{targets:[{blend:!0,blendSrc:2,blendDst:4,blendDstAlpha:4}]},rasterizerState:{cullMode:0},program:"sprite|sprite-vs:vert|sprite-fs:frag",depthStencilState:{depthTest:!1,depthWrite:!1},properties:{alphaThreshold:{value:[.5],type:13}}}]}],shaders:[{name:"sprite|sprite-vs:vert|sprite-fs:frag",hash:67215139,builtins:{statistics:{CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS:49,CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS:1},globals:{blocks:[{name:"CCGlobal",defines:[]},{name:"CCCamera",defines:[]}],samplerTextures:[],buffers:[],images:[]},locals:{blocks:[{name:"CCLocal",defines:["USE_LOCAL"]}],samplerTextures:[{name:"cc_spriteTexture",defines:["USE_TEXTURE"]}],buffers:[],images:[]}},defines:[{name:"USE_LOCAL",type:"boolean"},{name:"SAMPLE_FROM_RT",type:"boolean"},{name:"USE_PIXEL_ALIGNMENT",type:"boolean"},{name:"CC_USE_EMBEDDED_ALPHA",type:"boolean"},{name:"USE_ALPHA_TEST",type:"boolean"},{name:"USE_TEXTURE",type:"boolean"},{name:"IS_GRAY",type:"boolean"}],attributes:[{name:"a_position",defines:[],format:32,location:0},{name:"a_texCoord",defines:[],format:21,location:1},{name:"a_color",defines:[],format:44,location:2}],blocks:[{name:"ALPHA_TEST_DATA",defines:["USE_ALPHA_TEST"],binding:0,stageFlags:16,members:[{name:"alphaThreshold",type:13,count:1}]}],samplerTextures:[],buffers:[],images:[],textures:[],samplers:[],subpassInputs:[]}]},{name:"standard",techniques:[{name:"opaque",passes:[{program:"standard|standard-vs|standard-fs",properties:{tilingOffset:{value:[1,1,0,0],type:16},mainColor:{value:[1,1,1,1],linear:!0,type:16,handleInfo:["albedo",0,16]},albedoScale:{value:[1,1,1],type:15,handleInfo:["albedoScaleAndCutoff",0,15]},alphaThreshold:{value:[.5],type:13,handleInfo:["albedoScaleAndCutoff",3,13]},occlusion:{value:[1],type:13,handleInfo:["pbrParams",0,13]},roughness:{value:[.8],type:13,handleInfo:["pbrParams",1,13]},metallic:{value:[.6],type:13,handleInfo:["pbrParams",2,13]},specularIntensity:{value:[.5],type:13,handleInfo:["pbrParams",3,13]},emissive:{value:[0,0,0,1],linear:!0,type:16},emissiveScale:{value:[1,1,1],type:15,handleInfo:["emissiveScaleParam",0,15]},normalStrength:{value:[1],type:13,handleInfo:["emissiveScaleParam",3,13]},mainTexture:{value:"grey",type:28,handleInfo:["albedoMap",0,28]},normalMap:{value:"normal",type:28},pbrMap:{value:"grey",type:28},metallicRoughnessMap:{value:"grey",type:28},occlusionMap:{value:"white",type:28},emissiveMap:{value:"grey",type:28},albedo:{type:16,value:[1,1,1,1]},albedoScaleAndCutoff:{type:16,value:[1,1,1,.5]},pbrParams:{type:16,value:[1,.8,.6,.5]},emissiveScaleParam:{type:16,value:[1,1,1,1]},albedoMap:{type:28,value:"grey"}}},{phase:"forward-add",propertyIndex:0,embeddedMacros:{CC_FORWARD_ADD:!0},blendState:{targets:[{blend:!0,blendSrc:1,blendDst:1,blendSrcAlpha:0,blendDstAlpha:1}]},program:"standard|standard-vs|standard-fs",depthStencilState:{depthFunc:2,depthTest:!0,depthWrite:!1}},{phase:"shadow-caster",propertyIndex:0,rasterizerState:{cullMode:1},program:"standard|shadow-caster-vs:vert|shadow-caster-fs:frag",properties:{tilingOffset:{value:[1,1,0,0],type:16},mainColor:{value:[1,1,1,1],type:16,handleInfo:["albedo",0,16]},albedoScale:{value:[1,1,1],type:15,handleInfo:["albedoScaleAndCutoff",0,15]},alphaThreshold:{value:[.5],type:13,handleInfo:["albedoScaleAndCutoff",3,13]},mainTexture:{value:"grey",type:28,handleInfo:["albedoMap",0,28]},albedo:{type:16,value:[1,1,1,1]},albedoScaleAndCutoff:{type:16,value:[1,1,1,.5]},albedoMap:{type:28,value:"grey"}}}]}],shaders:[{name:"standard|standard-vs|standard-fs",hash:4079105024,builtins:{statistics:{CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS:223,CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS:75},globals:{blocks:[{name:"CCGlobal",defines:[]},{name:"CCCamera",defines:[]},{name:"CCShadow",defines:[]}],samplerTextures:[{name:"cc_shadowMap",defines:["CC_RECEIVE_SHADOW"]},{name:"cc_spotLightingMap",defines:["CC_RECEIVE_SHADOW"]},{name:"cc_environment",defines:["CC_USE_IBL"]},{name:"cc_diffuseMap",defines:["CC_USE_DIFFUSEMAP"]}],buffers:[],images:[]},locals:{blocks:[{name:"CCMorph",defines:["CC_USE_MORPH"]},{name:"CCSkinningTexture",defines:["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{name:"CCSkinningAnimation",defines:["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{name:"CCSkinning",defines:["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION"]},{name:"CCLocalBatched",defines:["!USE_INSTANCING","USE_BATCHING"]},{name:"CCLocal",defines:["!USE_INSTANCING","!USE_BATCHING"]},{name:"CCForwardLight",defines:["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]}],samplerTextures:[{name:"cc_PositionDisplacements",defines:["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{name:"cc_NormalDisplacements",defines:["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{name:"cc_TangentDisplacements",defines:["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{name:"cc_jointTexture",defines:["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{name:"cc_lightingMap",defines:["CC_USE_LIGHTMAP","!USE_BATCHING","!CC_FORWARD_ADD"]}],buffers:[],images:[]}},defines:[{name:"USE_INSTANCING",type:"boolean"},{name:"USE_BATCHING",type:"boolean"},{name:"CC_USE_SKINNING",type:"boolean"},{name:"CC_USE_BAKED_ANIMATION",type:"boolean"},{name:"CC_USE_LIGHTMAP",type:"boolean"},{name:"CC_RECEIVE_SHADOW",type:"boolean"},{name:"CC_USE_MORPH",type:"boolean"},{name:"CC_MORPH_TARGET_COUNT",type:"number",range:[2,8]},{name:"CC_MORPH_PRECOMPUTED",type:"boolean"},{name:"CC_MORPH_TARGET_HAS_POSITION",type:"boolean"},{name:"CC_MORPH_TARGET_HAS_NORMAL",type:"boolean"},{name:"CC_MORPH_TARGET_HAS_TANGENT",type:"boolean"},{name:"CC_USE_FOG",type:"number",range:[0,4]},{name:"CC_USE_ACCURATE_FOG",type:"boolean"},{name:"USE_VERTEX_COLOR",type:"boolean"},{name:"HAS_SECOND_UV",type:"boolean"},{name:"USE_NORMAL_MAP",type:"boolean"},{name:"CC_FORWARD_ADD",type:"boolean"},{name:"USE_TWOSIDE",type:"boolean"},{name:"SAMPLE_FROM_RT",type:"boolean"},{name:"CC_USE_IBL",type:"number",range:[0,2]},{name:"CC_USE_DIFFUSEMAP",type:"number",range:[0,2]},{name:"USE_REFLECTION_DENOISE",type:"boolean"},{name:"CC_USE_HDR",type:"boolean"},{name:"USE_ALBEDO_MAP",type:"boolean"},{name:"ALBEDO_UV",type:"string",options:["v_uv","v_uv1"]},{name:"NORMAL_UV",type:"string",options:["v_uv","v_uv1"]},{name:"PBR_UV",type:"string",options:["v_uv","v_uv1"]},{name:"USE_PBR_MAP",type:"boolean"},{name:"USE_METALLIC_ROUGHNESS_MAP",type:"boolean"},{name:"USE_OCCLUSION_MAP",type:"boolean"},{name:"USE_EMISSIVE_MAP",type:"boolean"},{name:"EMISSIVE_UV",type:"string",options:["v_uv","v_uv1"]},{name:"USE_ALPHA_TEST",type:"boolean"},{name:"ALPHA_TEST_CHANNEL",type:"string",options:["a","r"]},{name:"CC_PIPELINE_TYPE",type:"number",range:[0,1]},{name:"CC_FORCE_FORWARD_SHADING",type:"boolean"}],attributes:[{name:"a_position",defines:[],format:32,location:0},{name:"a_normal",defines:[],format:32,location:1},{name:"a_texCoord",defines:[],format:21,location:2},{name:"a_tangent",defines:[],format:44,location:3},{name:"a_joints",defines:["CC_USE_SKINNING"],location:4},{name:"a_weights",defines:["CC_USE_SKINNING"],format:44,location:5},{name:"a_jointAnimInfo",defines:["USE_INSTANCING","CC_USE_BAKED_ANIMATION"],format:44,isInstanced:!0,location:6},{name:"a_matWorld0",defines:["USE_INSTANCING"],format:44,isInstanced:!0,location:7},{name:"a_matWorld1",defines:["USE_INSTANCING"],format:44,isInstanced:!0,location:8},{name:"a_matWorld2",defines:["USE_INSTANCING"],format:44,isInstanced:!0,location:9},{name:"a_lightingMapUVParam",defines:["USE_INSTANCING","CC_USE_LIGHTMAP"],format:44,isInstanced:!0,location:10},{name:"a_localShadowBias",defines:["USE_INSTANCING","CC_RECEIVE_SHADOW"],format:21,isInstanced:!0,location:11},{name:"a_dyn_batch_id",defines:["!USE_INSTANCING","USE_BATCHING"],format:11,location:12},{name:"a_vertexId",defines:["CC_USE_MORPH"],format:11,location:13},{name:"a_color",defines:["USE_VERTEX_COLOR"],format:44,location:14},{name:"a_texCoord1",defines:[],format:21,location:15}],blocks:[{name:"Constants",defines:[],binding:0,stageFlags:17,members:[{name:"tilingOffset",type:16,count:1},{name:"albedo",type:16,count:1},{name:"albedoScaleAndCutoff",type:16,count:1},{name:"pbrParams",type:16,count:1},{name:"emissive",type:16,count:1},{name:"emissiveScaleParam",type:16,count:1}]}],samplerTextures:[{name:"albedoMap",type:28,count:1,defines:["USE_ALBEDO_MAP"],stageFlags:16,binding:1},{name:"normalMap",type:28,count:1,defines:["USE_NORMAL_MAP"],stageFlags:16,binding:2},{name:"pbrMap",type:28,count:1,defines:["USE_PBR_MAP"],stageFlags:16,binding:3},{name:"metallicRoughnessMap",type:28,count:1,defines:["USE_METALLIC_ROUGHNESS_MAP"],stageFlags:16,binding:4},{name:"occlusionMap",type:28,count:1,defines:["USE_OCCLUSION_MAP"],stageFlags:16,binding:5},{name:"emissiveMap",type:28,count:1,defines:["USE_EMISSIVE_MAP"],stageFlags:16,binding:6}],buffers:[{name:"b_ccLightsBuffer",memoryAccess:1,defines:["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"],stageFlags:16,binding:7},{name:"b_clusterLightIndicesBuffer",memoryAccess:1,defines:["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"],stageFlags:16,binding:8},{name:"b_clusterLightGridBuffer",memoryAccess:1,defines:["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"],stageFlags:16,binding:9}],images:[],textures:[],samplers:[],subpassInputs:[]},{name:"standard|shadow-caster-vs:vert|shadow-caster-fs:frag",hash:3928335406,builtins:{statistics:{CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS:184,CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS:75},globals:{blocks:[{name:"CCShadow",defines:[]},{name:"CCGlobal",defines:[]},{name:"CCCamera",defines:[]}],samplerTextures:[{name:"cc_shadowMap",defines:["CC_RECEIVE_SHADOW"]},{name:"cc_spotLightingMap",defines:["CC_RECEIVE_SHADOW"]}],buffers:[],images:[]},locals:{blocks:[{name:"CCMorph",defines:["CC_USE_MORPH"]},{name:"CCSkinningTexture",defines:["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{name:"CCSkinningAnimation",defines:["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{name:"CCSkinning",defines:["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION"]},{name:"CCLocalBatched",defines:["!USE_INSTANCING","USE_BATCHING"]},{name:"CCLocal",defines:["!USE_INSTANCING","!USE_BATCHING"]}],samplerTextures:[{name:"cc_PositionDisplacements",defines:["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{name:"cc_NormalDisplacements",defines:["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{name:"cc_TangentDisplacements",defines:["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{name:"cc_jointTexture",defines:["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]}],buffers:[],images:[]}},defines:[{name:"USE_INSTANCING",type:"boolean"},{name:"USE_BATCHING",type:"boolean"},{name:"CC_USE_SKINNING",type:"boolean"},{name:"CC_USE_BAKED_ANIMATION",type:"boolean"},{name:"CC_USE_LIGHTMAP",type:"boolean"},{name:"CC_RECEIVE_SHADOW",type:"boolean"},{name:"CC_USE_MORPH",type:"boolean"},{name:"CC_MORPH_TARGET_COUNT",type:"number",range:[2,8]},{name:"CC_MORPH_PRECOMPUTED",type:"boolean"},{name:"CC_MORPH_TARGET_HAS_POSITION",type:"boolean"},{name:"CC_MORPH_TARGET_HAS_NORMAL",type:"boolean"},{name:"CC_MORPH_TARGET_HAS_TANGENT",type:"boolean"},{name:"HAS_SECOND_UV",type:"boolean"},{name:"USE_ALBEDO_MAP",type:"boolean"},{name:"ALBEDO_UV",type:"string",options:["v_uv","v_uv1"]},{name:"USE_ALPHA_TEST",type:"boolean"},{name:"ALPHA_TEST_CHANNEL",type:"string",options:["a","r"]}],attributes:[{name:"a_position",defines:[],format:32,location:0},{name:"a_normal",defines:[],format:32,location:1},{name:"a_texCoord",defines:[],format:21,location:2},{name:"a_tangent",defines:[],format:44,location:3},{name:"a_joints",defines:["CC_USE_SKINNING"],location:4},{name:"a_weights",defines:["CC_USE_SKINNING"],format:44,location:5},{name:"a_jointAnimInfo",defines:["USE_INSTANCING","CC_USE_BAKED_ANIMATION"],format:44,isInstanced:!0,location:6},{name:"a_matWorld0",defines:["USE_INSTANCING"],format:44,isInstanced:!0,location:7},{name:"a_matWorld1",defines:["USE_INSTANCING"],format:44,isInstanced:!0,location:8},{name:"a_matWorld2",defines:["USE_INSTANCING"],format:44,isInstanced:!0,location:9},{name:"a_lightingMapUVParam",defines:["USE_INSTANCING","CC_USE_LIGHTMAP"],format:44,isInstanced:!0,location:10},{name:"a_localShadowBias",defines:["USE_INSTANCING","CC_RECEIVE_SHADOW"],format:21,isInstanced:!0,location:11},{name:"a_dyn_batch_id",defines:["!USE_INSTANCING","USE_BATCHING"],format:11,location:12},{name:"a_vertexId",defines:["CC_USE_MORPH"],format:11,location:13},{name:"a_texCoord1",defines:[],format:21,location:14}],blocks:[{name:"Constants",defines:[],binding:0,stageFlags:17,members:[{name:"tilingOffset",type:16,count:1},{name:"albedo",type:16,count:1},{name:"albedoScaleAndCutoff",type:16,count:1},{name:"pbrParams",type:16,count:1},{name:"emissive",type:16,count:1},{name:"emissiveScaleParam",type:16,count:1}]}],samplerTextures:[{name:"albedoMap",type:28,count:1,defines:["USE_ALBEDO_MAP"],stageFlags:16,binding:1}],buffers:[],images:[],textures:[],samplers:[],subpassInputs:[]}]},{name:"terrain",techniques:[{name:"opaque",passes:[{program:"terrain|terrain-vs|terrain-fs",properties:{UVScale:{value:[1,1,1,1],type:16},lightMapUVParam:{value:[0,0,0,0],type:16},metallic:{value:[0,0,0,0],type:16},roughness:{value:[1,1,1,1],type:16},weightMap:{value:"black",type:28},detailMap0:{value:"grey",type:28},detailMap1:{value:"grey",type:28},detailMap2:{value:"grey",type:28},detailMap3:{value:"grey",type:28},normalMap0:{value:"normal",type:28},normalMap1:{value:"normal",type:28},normalMap2:{value:"normal",type:28},normalMap3:{value:"normal",type:28},lightMap:{value:"grey",type:28}}},{phase:"forward-add",propertyIndex:0,embeddedMacros:{CC_FORWARD_ADD:!0},blendState:{targets:[{blend:!0,blendSrc:1,blendDst:1,blendSrcAlpha:0,blendDstAlpha:1}]},program:"terrain|terrain-vs|terrain-fs",depthStencilState:{depthFunc:2,depthTest:!0,depthWrite:!1},properties:{UVScale:{value:[1,1,1,1],type:16},lightMapUVParam:{value:[0,0,0,0],type:16},metallic:{value:[0,0,0,0],type:16},roughness:{value:[1,1,1,1],type:16},weightMap:{value:"black",type:28},detailMap0:{value:"grey",type:28},detailMap1:{value:"grey",type:28},detailMap2:{value:"grey",type:28},detailMap3:{value:"grey",type:28},normalMap0:{value:"normal",type:28},normalMap1:{value:"normal",type:28},normalMap2:{value:"normal",type:28},normalMap3:{value:"normal",type:28},lightMap:{value:"grey",type:28}}},{phase:"shadow-add",propertyIndex:0,rasterizerState:{cullMode:2},program:"terrain|shadow-caster-vs:vert|shadow-caster-fs:frag"}]}],shaders:[{name:"terrain|terrain-vs|terrain-fs",hash:3669699677,builtins:{statistics:{CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS:71,CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS:71},globals:{blocks:[{name:"CCGlobal",defines:[]},{name:"CCCamera",defines:[]},{name:"CCShadow",defines:[]}],samplerTextures:[{name:"cc_shadowMap",defines:["CC_RECEIVE_SHADOW"]},{name:"cc_spotLightingMap",defines:["CC_RECEIVE_SHADOW"]},{name:"cc_environment",defines:["CC_USE_IBL"]},{name:"cc_diffuseMap",defines:["CC_USE_DIFFUSEMAP"]}],buffers:[],images:[]},locals:{blocks:[{name:"CCLocal",defines:[]},{name:"CCForwardLight",defines:["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]}],samplerTextures:[{name:"cc_lightingMap",defines:["CC_USE_LIGHTMAP","!USE_BATCHING","!CC_FORWARD_ADD"]}],buffers:[],images:[]}},defines:[{name:"CC_USE_FOG",type:"number",range:[0,4]},{name:"CC_USE_ACCURATE_FOG",type:"boolean"},{name:"CC_RECEIVE_SHADOW",type:"boolean"},{name:"CC_USE_LIGHTMAP",type:"boolean"},{name:"CC_USE_IBL",type:"number",range:[0,2]},{name:"CC_USE_DIFFUSEMAP",type:"number",range:[0,2]},{name:"USE_REFLECTION_DENOISE",type:"boolean"},{name:"USE_BATCHING",type:"boolean"},{name:"CC_FORWARD_ADD",type:"boolean"},{name:"CC_USE_HDR",type:"boolean"},{name:"LAYERS",type:"number",range:[0,4]},{name:"USE_NORMALMAP",type:"boolean"},{name:"USE_PBR",type:"boolean"},{name:"CC_PIPELINE_TYPE",type:"number",range:[0,1]},{name:"CC_FORCE_FORWARD_SHADING",type:"boolean"}],attributes:[{name:"a_position",defines:[],format:32,location:0},{name:"a_normal",defines:[],format:32,location:1},{name:"a_texCoord",defines:[],format:21,location:2}],blocks:[{name:"TexCoords",defines:[],binding:0,stageFlags:1,members:[{name:"UVScale",type:16,count:1},{name:"lightMapUVParam",type:16,count:1}]},{name:"PbrParams",defines:[],binding:1,stageFlags:16,members:[{name:"metallic",type:16,count:1},{name:"roughness",type:16,count:1}]}],samplerTextures:[{name:"weightMap",type:28,count:1,defines:[],stageFlags:16,binding:2},{name:"detailMap0",type:28,count:1,defines:[],stageFlags:16,binding:3},{name:"detailMap1",type:28,count:1,defines:[],stageFlags:16,binding:4},{name:"detailMap2",type:28,count:1,defines:[],stageFlags:16,binding:5},{name:"detailMap3",type:28,count:1,defines:[],stageFlags:16,binding:6},{name:"normalMap0",type:28,count:1,defines:[],stageFlags:16,binding:7},{name:"normalMap1",type:28,count:1,defines:[],stageFlags:16,binding:8},{name:"normalMap2",type:28,count:1,defines:[],stageFlags:16,binding:9},{name:"normalMap3",type:28,count:1,defines:[],stageFlags:16,binding:10},{name:"lightMap",type:28,count:1,defines:[],stageFlags:16,binding:11}],buffers:[{name:"b_ccLightsBuffer",memoryAccess:1,defines:["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"],stageFlags:16,binding:12},{name:"b_clusterLightIndicesBuffer",memoryAccess:1,defines:["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"],stageFlags:16,binding:13},{name:"b_clusterLightGridBuffer",memoryAccess:1,defines:["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"],stageFlags:16,binding:14}],images:[],textures:[],samplers:[],subpassInputs:[]},{name:"terrain|shadow-caster-vs:vert|shadow-caster-fs:frag",hash:2218105608,builtins:{statistics:{CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS:69,CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS:0},globals:{blocks:[{name:"CCGlobal",defines:[]},{name:"CCCamera",defines:[]},{name:"CCShadow",defines:[]}],samplerTextures:[],buffers:[],images:[]},locals:{blocks:[{name:"CCLocal",defines:[]}],samplerTextures:[],buffers:[],images:[]}},defines:[],attributes:[{name:"a_position",defines:[],format:32,location:0},{name:"a_normal",defines:[],format:32,location:1},{name:"a_texCoord",defines:[],format:21,location:2}],blocks:[],samplerTextures:[],buffers:[],images:[],textures:[],samplers:[],subpassInputs:[]}]},{name:"unlit",techniques:[{name:"opaque",passes:[{program:"unlit|unlit-vs:vert|unlit-fs:frag",properties:{mainTexture:{value:"grey",type:28},tilingOffset:{value:[1,1,0,0],type:16},mainColor:{value:[1,1,1,1],linear:!0,type:16},colorScale:{value:[1,1,1],type:15,handleInfo:["colorScaleAndCutoff",0,15]},alphaThreshold:{value:[.5],type:13,handleInfo:["colorScaleAndCutoff",3,13]},color:{linear:!0,type:16,handleInfo:["mainColor",0,16]},colorScaleAndCutoff:{type:16,value:[1,1,1,.5]}}}]}],shaders:[{name:"unlit|unlit-vs:vert|unlit-fs:frag",hash:3152709001,builtins:{statistics:{CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS:198,CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS:41},globals:{blocks:[{name:"CCGlobal",defines:[]},{name:"CCCamera",defines:[]}],samplerTextures:[],buffers:[],images:[]},locals:{blocks:[{name:"CCMorph",defines:["CC_USE_MORPH"]},{name:"CCSkinningTexture",defines:["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{name:"CCSkinningAnimation",defines:["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{name:"CCSkinning",defines:["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION"]},{name:"CCLocalBatched",defines:["!USE_INSTANCING","USE_BATCHING"]},{name:"CCLocal",defines:["!USE_INSTANCING","!USE_BATCHING"]}],samplerTextures:[{name:"cc_PositionDisplacements",defines:["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{name:"cc_NormalDisplacements",defines:["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{name:"cc_TangentDisplacements",defines:["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{name:"cc_jointTexture",defines:["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]}],buffers:[],images:[]}},defines:[{name:"USE_INSTANCING",type:"boolean"},{name:"USE_BATCHING",type:"boolean"},{name:"CC_USE_SKINNING",type:"boolean"},{name:"CC_USE_BAKED_ANIMATION",type:"boolean"},{name:"CC_USE_LIGHTMAP",type:"boolean"},{name:"CC_RECEIVE_SHADOW",type:"boolean"},{name:"CC_USE_MORPH",type:"boolean"},{name:"CC_MORPH_TARGET_COUNT",type:"number",range:[2,8]},{name:"CC_MORPH_PRECOMPUTED",type:"boolean"},{name:"CC_MORPH_TARGET_HAS_POSITION",type:"boolean"},{name:"CC_MORPH_TARGET_HAS_NORMAL",type:"boolean"},{name:"CC_MORPH_TARGET_HAS_TANGENT",type:"boolean"},{name:"CC_USE_FOG",type:"number",range:[0,4]},{name:"CC_USE_ACCURATE_FOG",type:"boolean"},{name:"USE_VERTEX_COLOR",type:"boolean"},{name:"USE_TEXTURE",type:"boolean"},{name:"SAMPLE_FROM_RT",type:"boolean"},{name:"CC_USE_HDR",type:"boolean"},{name:"USE_ALPHA_TEST",type:"boolean"},{name:"ALPHA_TEST_CHANNEL",type:"string",options:["a","r","g","b"]}],attributes:[{name:"a_position",defines:[],format:32,location:0},{name:"a_normal",defines:[],format:32,location:1},{name:"a_texCoord",defines:[],format:21,location:2},{name:"a_tangent",defines:[],format:44,location:3},{name:"a_joints",defines:["CC_USE_SKINNING"],location:4},{name:"a_weights",defines:["CC_USE_SKINNING"],format:44,location:5},{name:"a_jointAnimInfo",defines:["USE_INSTANCING","CC_USE_BAKED_ANIMATION"],format:44,isInstanced:!0,location:6},{name:"a_matWorld0",defines:["USE_INSTANCING"],format:44,isInstanced:!0,location:7},{name:"a_matWorld1",defines:["USE_INSTANCING"],format:44,isInstanced:!0,location:8},{name:"a_matWorld2",defines:["USE_INSTANCING"],format:44,isInstanced:!0,location:9},{name:"a_lightingMapUVParam",defines:["USE_INSTANCING","CC_USE_LIGHTMAP"],format:44,isInstanced:!0,location:10},{name:"a_localShadowBias",defines:["USE_INSTANCING","CC_RECEIVE_SHADOW"],format:21,isInstanced:!0,location:11},{name:"a_dyn_batch_id",defines:["!USE_INSTANCING","USE_BATCHING"],format:11,location:12},{name:"a_vertexId",defines:["CC_USE_MORPH"],format:11,location:13},{name:"a_color",defines:["USE_VERTEX_COLOR"],format:44,location:14}],blocks:[{name:"TexCoords",defines:["USE_TEXTURE"],binding:0,stageFlags:1,members:[{name:"tilingOffset",type:16,count:1}]},{name:"Constant",defines:[],binding:1,stageFlags:16,members:[{name:"mainColor",type:16,count:1},{name:"colorScaleAndCutoff",type:16,count:1}]}],samplerTextures:[{name:"mainTexture",type:28,count:1,defines:["USE_TEXTURE"],stageFlags:16,binding:2}],buffers:[],images:[],textures:[],samplers:[],subpassInputs:[]}]},{name:"bloom",techniques:[{passes:[{phase:"bloom-prefilter",program:"bloom|bloom-vs|prefilter-fs",depthStencilState:{depthTest:!1,depthWrite:!1}},{phase:"bloom-downsample",program:"bloom|bloom-vs|downsample-fs",depthStencilState:{depthTest:!1,depthWrite:!1}},{phase:"bloom-downsample",program:"bloom|bloom-vs|downsample-fs",depthStencilState:{depthTest:!1,depthWrite:!1}},{phase:"bloom-downsample",program:"bloom|bloom-vs|downsample-fs",depthStencilState:{depthTest:!1,depthWrite:!1}},{phase:"bloom-downsample",program:"bloom|bloom-vs|downsample-fs",depthStencilState:{depthTest:!1,depthWrite:!1}},{phase:"bloom-downsample",program:"bloom|bloom-vs|downsample-fs",depthStencilState:{depthTest:!1,depthWrite:!1}},{phase:"bloom-downsample",program:"bloom|bloom-vs|downsample-fs",depthStencilState:{depthTest:!1,depthWrite:!1}},{phase:"bloom-upsample",program:"bloom|bloom-vs|upsample-fs",depthStencilState:{depthTest:!1,depthWrite:!1}},{phase:"bloom-upsample",program:"bloom|bloom-vs|upsample-fs",depthStencilState:{depthTest:!1,depthWrite:!1}},{phase:"bloom-upsample",program:"bloom|bloom-vs|upsample-fs",depthStencilState:{depthTest:!1,depthWrite:!1}},{phase:"bloom-upsample",program:"bloom|bloom-vs|upsample-fs",depthStencilState:{depthTest:!1,depthWrite:!1}},{phase:"bloom-upsample",program:"bloom|bloom-vs|upsample-fs",depthStencilState:{depthTest:!1,depthWrite:!1}},{phase:"bloom-upsample",program:"bloom|bloom-vs|upsample-fs",depthStencilState:{depthTest:!1,depthWrite:!1}},{phase:"bloom-combine",program:"bloom|bloom-vs|combine-fs",depthStencilState:{depthTest:!1,depthWrite:!1}}]}],shaders:[{name:"bloom|bloom-vs|prefilter-fs",hash:837263906,builtins:{statistics:{CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS:147,CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS:40},globals:{blocks:[{name:"CCGlobal",defines:[]},{name:"CCCamera",defines:[]}],samplerTextures:[],buffers:[],images:[]},locals:{blocks:[{name:"CCMorph",defines:["CC_USE_MORPH"]},{name:"CCSkinningTexture",defines:["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{name:"CCSkinningAnimation",defines:["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{name:"CCSkinning",defines:["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION"]}],samplerTextures:[{name:"cc_PositionDisplacements",defines:["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{name:"cc_NormalDisplacements",defines:["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{name:"cc_TangentDisplacements",defines:["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{name:"cc_jointTexture",defines:["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]}],buffers:[],images:[]}},defines:[{name:"USE_INSTANCING",type:"boolean"},{name:"USE_BATCHING",type:"boolean"},{name:"CC_USE_SKINNING",type:"boolean"},{name:"CC_USE_BAKED_ANIMATION",type:"boolean"},{name:"CC_USE_LIGHTMAP",type:"boolean"},{name:"CC_RECEIVE_SHADOW",type:"boolean"},{name:"CC_USE_MORPH",type:"boolean"},{name:"CC_MORPH_TARGET_COUNT",type:"number",range:[2,8]},{name:"CC_MORPH_PRECOMPUTED",type:"boolean"},{name:"CC_MORPH_TARGET_HAS_POSITION",type:"boolean"},{name:"CC_MORPH_TARGET_HAS_NORMAL",type:"boolean"},{name:"CC_MORPH_TARGET_HAS_TANGENT",type:"boolean"}],attributes:[{name:"a_position",defines:[],format:32,location:0},{name:"a_normal",defines:[],format:32,location:1},{name:"a_texCoord",defines:[],format:21,location:2},{name:"a_tangent",defines:[],format:44,location:3},{name:"a_joints",defines:["CC_USE_SKINNING"],location:4},{name:"a_weights",defines:["CC_USE_SKINNING"],format:44,location:5},{name:"a_jointAnimInfo",defines:["USE_INSTANCING","CC_USE_BAKED_ANIMATION"],format:44,isInstanced:!0,location:6},{name:"a_matWorld0",defines:["USE_INSTANCING"],format:44,isInstanced:!0,location:7},{name:"a_matWorld1",defines:["USE_INSTANCING"],format:44,isInstanced:!0,location:8},{name:"a_matWorld2",defines:["USE_INSTANCING"],format:44,isInstanced:!0,location:9},{name:"a_lightingMapUVParam",defines:["USE_INSTANCING","CC_USE_LIGHTMAP"],format:44,isInstanced:!0,location:10},{name:"a_localShadowBias",defines:["USE_INSTANCING","CC_RECEIVE_SHADOW"],format:21,isInstanced:!0,location:11},{name:"a_dyn_batch_id",defines:["!USE_INSTANCING","USE_BATCHING"],format:11,location:12},{name:"a_vertexId",defines:["CC_USE_MORPH"],format:11,location:13}],blocks:[{name:"BloomUBO",defines:[],binding:0,stageFlags:16,members:[{name:"texSize",type:16,count:1}]}],samplerTextures:[{name:"outputResultMap",type:28,count:1,defines:[],stageFlags:16,binding:1}],buffers:[],images:[],textures:[],samplers:[],subpassInputs:[]},{name:"bloom|bloom-vs|downsample-fs",hash:682261797,builtins:{statistics:{CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS:147,CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS:40},globals:{blocks:[{name:"CCGlobal",defines:[]},{name:"CCCamera",defines:[]}],samplerTextures:[],buffers:[],images:[]},locals:{blocks:[{name:"CCMorph",defines:["CC_USE_MORPH"]},{name:"CCSkinningTexture",defines:["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{name:"CCSkinningAnimation",defines:["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{name:"CCSkinning",defines:["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION"]}],samplerTextures:[{name:"cc_PositionDisplacements",defines:["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{name:"cc_NormalDisplacements",defines:["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{name:"cc_TangentDisplacements",defines:["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{name:"cc_jointTexture",defines:["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]}],buffers:[],images:[]}},defines:[{name:"USE_INSTANCING",type:"boolean"},{name:"USE_BATCHING",type:"boolean"},{name:"CC_USE_SKINNING",type:"boolean"},{name:"CC_USE_BAKED_ANIMATION",type:"boolean"},{name:"CC_USE_LIGHTMAP",type:"boolean"},{name:"CC_RECEIVE_SHADOW",type:"boolean"},{name:"CC_USE_MORPH",type:"boolean"},{name:"CC_MORPH_TARGET_COUNT",type:"number",range:[2,8]},{name:"CC_MORPH_PRECOMPUTED",type:"boolean"},{name:"CC_MORPH_TARGET_HAS_POSITION",type:"boolean"},{name:"CC_MORPH_TARGET_HAS_NORMAL",type:"boolean"},{name:"CC_MORPH_TARGET_HAS_TANGENT",type:"boolean"}],attributes:[{name:"a_position",defines:[],format:32,location:0},{name:"a_normal",defines:[],format:32,location:1},{name:"a_texCoord",defines:[],format:21,location:2},{name:"a_tangent",defines:[],format:44,location:3},{name:"a_joints",defines:["CC_USE_SKINNING"],location:4},{name:"a_weights",defines:["CC_USE_SKINNING"],format:44,location:5},{name:"a_jointAnimInfo",defines:["USE_INSTANCING","CC_USE_BAKED_ANIMATION"],format:44,isInstanced:!0,location:6},{name:"a_matWorld0",defines:["USE_INSTANCING"],format:44,isInstanced:!0,location:7},{name:"a_matWorld1",defines:["USE_INSTANCING"],format:44,isInstanced:!0,location:8},{name:"a_matWorld2",defines:["USE_INSTANCING"],format:44,isInstanced:!0,location:9},{name:"a_lightingMapUVParam",defines:["USE_INSTANCING","CC_USE_LIGHTMAP"],format:44,isInstanced:!0,location:10},{name:"a_localShadowBias",defines:["USE_INSTANCING","CC_RECEIVE_SHADOW"],format:21,isInstanced:!0,location:11},{name:"a_dyn_batch_id",defines:["!USE_INSTANCING","USE_BATCHING"],format:11,location:12},{name:"a_vertexId",defines:["CC_USE_MORPH"],format:11,location:13}],blocks:[{name:"BloomUBO",defines:[],binding:0,stageFlags:16,members:[{name:"texSize",type:16,count:1}]}],samplerTextures:[{name:"bloomTexture",type:28,count:1,defines:[],stageFlags:16,binding:1}],buffers:[],images:[],textures:[],samplers:[],subpassInputs:[]},{name:"bloom|bloom-vs|upsample-fs",hash:3663548873,builtins:{statistics:{CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS:147,CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS:40},globals:{blocks:[{name:"CCGlobal",defines:[]},{name:"CCCamera",defines:[]}],samplerTextures:[],buffers:[],images:[]},locals:{blocks:[{name:"CCMorph",defines:["CC_USE_MORPH"]},{name:"CCSkinningTexture",defines:["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{name:"CCSkinningAnimation",defines:["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{name:"CCSkinning",defines:["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION"]}],samplerTextures:[{name:"cc_PositionDisplacements",defines:["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{name:"cc_NormalDisplacements",defines:["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{name:"cc_TangentDisplacements",defines:["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{name:"cc_jointTexture",defines:["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]}],buffers:[],images:[]}},defines:[{name:"USE_INSTANCING",type:"boolean"},{name:"USE_BATCHING",type:"boolean"},{name:"CC_USE_SKINNING",type:"boolean"},{name:"CC_USE_BAKED_ANIMATION",type:"boolean"},{name:"CC_USE_LIGHTMAP",type:"boolean"},{name:"CC_RECEIVE_SHADOW",type:"boolean"},{name:"CC_USE_MORPH",type:"boolean"},{name:"CC_MORPH_TARGET_COUNT",type:"number",range:[2,8]},{name:"CC_MORPH_PRECOMPUTED",type:"boolean"},{name:"CC_MORPH_TARGET_HAS_POSITION",type:"boolean"},{name:"CC_MORPH_TARGET_HAS_NORMAL",type:"boolean"},{name:"CC_MORPH_TARGET_HAS_TANGENT",type:"boolean"}],attributes:[{name:"a_position",defines:[],format:32,location:0},{name:"a_normal",defines:[],format:32,location:1},{name:"a_texCoord",defines:[],format:21,location:2},{name:"a_tangent",defines:[],format:44,location:3},{name:"a_joints",defines:["CC_USE_SKINNING"],location:4},{name:"a_weights",defines:["CC_USE_SKINNING"],format:44,location:5},{name:"a_jointAnimInfo",defines:["USE_INSTANCING","CC_USE_BAKED_ANIMATION"],format:44,isInstanced:!0,location:6},{name:"a_matWorld0",defines:["USE_INSTANCING"],format:44,isInstanced:!0,location:7},{name:"a_matWorld1",defines:["USE_INSTANCING"],format:44,isInstanced:!0,location:8},{name:"a_matWorld2",defines:["USE_INSTANCING"],format:44,isInstanced:!0,location:9},{name:"a_lightingMapUVParam",defines:["USE_INSTANCING","CC_USE_LIGHTMAP"],format:44,isInstanced:!0,location:10},{name:"a_localShadowBias",defines:["USE_INSTANCING","CC_RECEIVE_SHADOW"],format:21,isInstanced:!0,location:11},{name:"a_dyn_batch_id",defines:["!USE_INSTANCING","USE_BATCHING"],format:11,location:12},{name:"a_vertexId",defines:["CC_USE_MORPH"],format:11,location:13}],blocks:[{name:"BloomUBO",defines:[],binding:0,stageFlags:16,members:[{name:"texSize",type:16,count:1}]}],samplerTextures:[{name:"bloomTexture",type:28,count:1,defines:[],stageFlags:16,binding:1}],buffers:[],images:[],textures:[],samplers:[],subpassInputs:[]},{name:"bloom|bloom-vs|combine-fs",hash:670444562,builtins:{statistics:{CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS:147,CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS:40},globals:{blocks:[{name:"CCGlobal",defines:[]},{name:"CCCamera",defines:[]}],samplerTextures:[],buffers:[],images:[]},locals:{blocks:[{name:"CCMorph",defines:["CC_USE_MORPH"]},{name:"CCSkinningTexture",defines:["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{name:"CCSkinningAnimation",defines:["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{name:"CCSkinning",defines:["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION"]}],samplerTextures:[{name:"cc_PositionDisplacements",defines:["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{name:"cc_NormalDisplacements",defines:["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{name:"cc_TangentDisplacements",defines:["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{name:"cc_jointTexture",defines:["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]}],buffers:[],images:[]}},defines:[{name:"USE_INSTANCING",type:"boolean"},{name:"USE_BATCHING",type:"boolean"},{name:"CC_USE_SKINNING",type:"boolean"},{name:"CC_USE_BAKED_ANIMATION",type:"boolean"},{name:"CC_USE_LIGHTMAP",type:"boolean"},{name:"CC_RECEIVE_SHADOW",type:"boolean"},{name:"CC_USE_MORPH",type:"boolean"},{name:"CC_MORPH_TARGET_COUNT",type:"number",range:[2,8]},{name:"CC_MORPH_PRECOMPUTED",type:"boolean"},{name:"CC_MORPH_TARGET_HAS_POSITION",type:"boolean"},{name:"CC_MORPH_TARGET_HAS_NORMAL",type:"boolean"},{name:"CC_MORPH_TARGET_HAS_TANGENT",type:"boolean"}],attributes:[{name:"a_position",defines:[],format:32,location:0},{name:"a_normal",defines:[],format:32,location:1},{name:"a_texCoord",defines:[],format:21,location:2},{name:"a_tangent",defines:[],format:44,location:3},{name:"a_joints",defines:["CC_USE_SKINNING"],location:4},{name:"a_weights",defines:["CC_USE_SKINNING"],format:44,location:5},{name:"a_jointAnimInfo",defines:["USE_INSTANCING","CC_USE_BAKED_ANIMATION"],format:44,isInstanced:!0,location:6},{name:"a_matWorld0",defines:["USE_INSTANCING"],format:44,isInstanced:!0,location:7},{name:"a_matWorld1",defines:["USE_INSTANCING"],format:44,isInstanced:!0,location:8},{name:"a_matWorld2",defines:["USE_INSTANCING"],format:44,isInstanced:!0,location:9},{name:"a_lightingMapUVParam",defines:["USE_INSTANCING","CC_USE_LIGHTMAP"],format:44,isInstanced:!0,location:10},{name:"a_localShadowBias",defines:["USE_INSTANCING","CC_RECEIVE_SHADOW"],format:21,isInstanced:!0,location:11},{name:"a_dyn_batch_id",defines:["!USE_INSTANCING","USE_BATCHING"],format:11,location:12},{name:"a_vertexId",defines:["CC_USE_MORPH"],format:11,location:13}],blocks:[{name:"BloomUBO",defines:[],binding:0,stageFlags:16,members:[{name:"texSize",type:16,count:1}]}],samplerTextures:[{name:"outputResultMap",type:28,count:1,defines:[],stageFlags:16,binding:1},{name:"bloomTexture",type:28,count:1,defines:[],stageFlags:16,binding:2}],buffers:[],images:[],textures:[],samplers:[],subpassInputs:[]}]},{name:"deferred-lighting",techniques:[{passes:[{phase:"deferred-lighting",program:"deferred-lighting|lighting-vs|lighting-fs",depthStencilState:{depthFunc:4,depthTest:!0,depthWrite:!1}}]}],shaders:[{name:"deferred-lighting|lighting-vs|lighting-fs",hash:2587574837,builtins:{statistics:{CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS:39,CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS:69},globals:{blocks:[{name:"CCGlobal",defines:[]},{name:"CCCamera",defines:[]},{name:"CCShadow",defines:[]}],samplerTextures:[{name:"cc_shadowMap",defines:["CC_RECEIVE_SHADOW"]},{name:"cc_spotLightingMap",defines:["CC_RECEIVE_SHADOW"]},{name:"cc_environment",defines:["CC_USE_IBL"]},{name:"cc_diffuseMap",defines:["CC_USE_DIFFUSEMAP"]}],buffers:[],images:[]},locals:{blocks:[{name:"CCLocal",defines:[]},{name:"CCForwardLight",defines:["CC_ENABLE_CLUSTERED_LIGHT_CULLING"]}],samplerTextures:[],buffers:[],images:[]}},defines:[{name:"USE_INSTANCING",type:"boolean"},{name:"USE_BATCHING",type:"boolean"},{name:"CC_USE_SKINNING",type:"boolean"},{name:"CC_USE_BAKED_ANIMATION",type:"boolean"},{name:"CC_USE_LIGHTMAP",type:"boolean"},{name:"CC_RECEIVE_SHADOW",type:"boolean"},{name:"CC_USE_MORPH",type:"boolean"},{name:"CC_USE_IBL",type:"number",range:[0,2]},{name:"CC_USE_DIFFUSEMAP",type:"number",range:[0,2]},{name:"USE_REFLECTION_DENOISE",type:"boolean"},{name:"CC_FORWARD_ADD",type:"boolean"},{name:"CC_PIPELINE_TYPE",type:"number",range:[0,1]},{name:"CC_FORCE_FORWARD_SHADING",type:"boolean"},{name:"CC_USE_HDR",type:"boolean"},{name:"CC_USE_FOG",type:"number",range:[0,4]}],attributes:[{name:"a_position",defines:[],format:32,location:0},{name:"a_normal",defines:[],format:32,location:1},{name:"a_texCoord",defines:[],format:21,location:2},{name:"a_tangent",defines:[],format:44,location:3},{name:"a_joints",defines:["CC_USE_SKINNING"],location:4},{name:"a_weights",defines:["CC_USE_SKINNING"],format:44,location:5},{name:"a_jointAnimInfo",defines:["USE_INSTANCING","CC_USE_BAKED_ANIMATION"],format:44,isInstanced:!0,location:6},{name:"a_matWorld0",defines:["USE_INSTANCING"],format:44,isInstanced:!0,location:7},{name:"a_matWorld1",defines:["USE_INSTANCING"],format:44,isInstanced:!0,location:8},{name:"a_matWorld2",defines:["USE_INSTANCING"],format:44,isInstanced:!0,location:9},{name:"a_lightingMapUVParam",defines:["USE_INSTANCING","CC_USE_LIGHTMAP"],format:44,isInstanced:!0,location:10},{name:"a_localShadowBias",defines:["USE_INSTANCING","CC_RECEIVE_SHADOW"],format:21,isInstanced:!0,location:11},{name:"a_dyn_batch_id",defines:["!USE_INSTANCING","USE_BATCHING"],format:11,location:12},{name:"a_vertexId",defines:["CC_USE_MORPH"],format:11,location:13}],blocks:[],samplerTextures:[],buffers:[{name:"b_ccLightsBuffer",memoryAccess:1,defines:["CC_ENABLE_CLUSTERED_LIGHT_CULLING"],stageFlags:16,binding:4},{name:"b_clusterLightIndicesBuffer",memoryAccess:1,defines:["CC_ENABLE_CLUSTERED_LIGHT_CULLING"],stageFlags:16,binding:5},{name:"b_clusterLightGridBuffer",memoryAccess:1,defines:["CC_ENABLE_CLUSTERED_LIGHT_CULLING"],stageFlags:16,binding:6}],images:[],textures:[],samplers:[],subpassInputs:[{name:"gbuffer_albedoMap",count:1,defines:["CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT"],stageFlags:16,binding:0},{name:"gbuffer_normalMap",count:1,defines:["CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT"],stageFlags:16,binding:1},{name:"gbuffer_emissiveMap",count:1,defines:["CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT"],stageFlags:16,binding:2},{name:"depth_stencil",count:1,defines:["CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT"],stageFlags:16,binding:3}]}]},{name:"planar-shadow",techniques:[{passes:[{phase:"planarShadow",blendState:{targets:[{blend:!0,blendSrc:2,blendDst:4,blendDstAlpha:4}]},program:"planar-shadow|planar-shadow-vs:vert|planar-shadow-fs:frag",depthStencilState:{depthTest:!0,depthWrite:!1,stencilTestFront:!0,stencilFuncFront:5,stencilPassOpFront:2,stencilRefBack:128,stencilRefFront:128,stencilReadMaskBack:128,stencilReadMaskFront:128,stencilWriteMaskBack:128,stencilWriteMaskFront:128}}]}],shaders:[{name:"planar-shadow|planar-shadow-vs:vert|planar-shadow-fs:frag",hash:3542426468,builtins:{statistics:{CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS:217,CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS:59},globals:{blocks:[{name:"CCGlobal",defines:[]},{name:"CCCamera",defines:[]},{name:"CCShadow",defines:[]}],samplerTextures:[],buffers:[],images:[]},locals:{blocks:[{name:"CCMorph",defines:["CC_USE_MORPH"]},{name:"CCSkinningTexture",defines:["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{name:"CCSkinningAnimation",defines:["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{name:"CCSkinning",defines:["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION"]},{name:"CCLocalBatched",defines:["!USE_INSTANCING","USE_BATCHING"]},{name:"CCLocal",defines:["!USE_INSTANCING","!USE_BATCHING"]}],samplerTextures:[{name:"cc_PositionDisplacements",defines:["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{name:"cc_NormalDisplacements",defines:["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{name:"cc_TangentDisplacements",defines:["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{name:"cc_jointTexture",defines:["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]}],buffers:[],images:[]}},defines:[{name:"USE_INSTANCING",type:"boolean"},{name:"USE_BATCHING",type:"boolean"},{name:"CC_USE_SKINNING",type:"boolean"},{name:"CC_USE_BAKED_ANIMATION",type:"boolean"},{name:"CC_USE_LIGHTMAP",type:"boolean"},{name:"CC_RECEIVE_SHADOW",type:"boolean"},{name:"CC_USE_MORPH",type:"boolean"},{name:"CC_MORPH_TARGET_COUNT",type:"number",range:[2,8]},{name:"CC_MORPH_PRECOMPUTED",type:"boolean"},{name:"CC_MORPH_TARGET_HAS_POSITION",type:"boolean"},{name:"CC_MORPH_TARGET_HAS_NORMAL",type:"boolean"},{name:"CC_MORPH_TARGET_HAS_TANGENT",type:"boolean"}],attributes:[{name:"a_position",defines:[],format:32,location:0},{name:"a_normal",defines:[],format:32,location:1},{name:"a_texCoord",defines:[],format:21,location:2},{name:"a_tangent",defines:[],format:44,location:3},{name:"a_joints",defines:["CC_USE_SKINNING"],location:4},{name:"a_weights",defines:["CC_USE_SKINNING"],format:44,location:5},{name:"a_jointAnimInfo",defines:["USE_INSTANCING","CC_USE_BAKED_ANIMATION"],format:44,isInstanced:!0,location:6},{name:"a_matWorld0",defines:["USE_INSTANCING"],format:44,isInstanced:!0,location:7},{name:"a_matWorld1",defines:["USE_INSTANCING"],format:44,isInstanced:!0,location:8},{name:"a_matWorld2",defines:["USE_INSTANCING"],format:44,isInstanced:!0,location:9},{name:"a_lightingMapUVParam",defines:["USE_INSTANCING","CC_USE_LIGHTMAP"],format:44,isInstanced:!0,location:10},{name:"a_localShadowBias",defines:["USE_INSTANCING","CC_RECEIVE_SHADOW"],format:21,isInstanced:!0,location:11},{name:"a_dyn_batch_id",defines:["!USE_INSTANCING","USE_BATCHING"],format:11,location:12},{name:"a_vertexId",defines:["CC_USE_MORPH"],format:11,location:13}],blocks:[],samplerTextures:[],buffers:[],images:[],textures:[],samplers:[],subpassInputs:[]}]},{name:"post-process",techniques:[{passes:[{phase:"post-process",blendState:{targets:[{blend:!0,blendSrc:2,blendDst:4,blendSrcAlpha:2,blendDstAlpha:4}]},program:"post-process|post-process-vs|post-process-fs",depthStencilState:{depthTest:!1,depthWrite:!1}}]}],shaders:[{name:"post-process|post-process-vs|post-process-fs",hash:2960965003,builtins:{statistics:{CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS:147,CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS:39},globals:{blocks:[{name:"CCGlobal",defines:[]},{name:"CCCamera",defines:[]}],samplerTextures:[],buffers:[],images:[]},locals:{blocks:[{name:"CCMorph",defines:["CC_USE_MORPH"]},{name:"CCSkinningTexture",defines:["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{name:"CCSkinningAnimation",defines:["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{name:"CCSkinning",defines:["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION"]}],samplerTextures:[{name:"cc_PositionDisplacements",defines:["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{name:"cc_NormalDisplacements",defines:["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{name:"cc_TangentDisplacements",defines:["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{name:"cc_jointTexture",defines:["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]}],buffers:[],images:[]}},defines:[{name:"USE_INSTANCING",type:"boolean"},{name:"USE_BATCHING",type:"boolean"},{name:"CC_USE_SKINNING",type:"boolean"},{name:"CC_USE_BAKED_ANIMATION",type:"boolean"},{name:"CC_USE_LIGHTMAP",type:"boolean"},{name:"CC_RECEIVE_SHADOW",type:"boolean"},{name:"CC_USE_MORPH",type:"boolean"},{name:"CC_MORPH_TARGET_COUNT",type:"number",range:[2,8]},{name:"CC_MORPH_PRECOMPUTED",type:"boolean"},{name:"CC_MORPH_TARGET_HAS_POSITION",type:"boolean"},{name:"CC_MORPH_TARGET_HAS_NORMAL",type:"boolean"},{name:"CC_MORPH_TARGET_HAS_TANGENT",type:"boolean"},{name:"ANTIALIAS_TYPE",type:"number",range:[0,3]}],attributes:[{name:"a_position",defines:[],format:32,location:0},{name:"a_normal",defines:[],format:32,location:1},{name:"a_texCoord",defines:[],format:21,location:2},{name:"a_tangent",defines:[],format:44,location:3},{name:"a_joints",defines:["CC_USE_SKINNING"],location:4},{name:"a_weights",defines:["CC_USE_SKINNING"],format:44,location:5},{name:"a_jointAnimInfo",defines:["USE_INSTANCING","CC_USE_BAKED_ANIMATION"],format:44,isInstanced:!0,location:6},{name:"a_matWorld0",defines:["USE_INSTANCING"],format:44,isInstanced:!0,location:7},{name:"a_matWorld1",defines:["USE_INSTANCING"],format:44,isInstanced:!0,location:8},{name:"a_matWorld2",defines:["USE_INSTANCING"],format:44,isInstanced:!0,location:9},{name:"a_lightingMapUVParam",defines:["USE_INSTANCING","CC_USE_LIGHTMAP"],format:44,isInstanced:!0,location:10},{name:"a_localShadowBias",defines:["USE_INSTANCING","CC_RECEIVE_SHADOW"],format:21,isInstanced:!0,location:11},{name:"a_dyn_batch_id",defines:["!USE_INSTANCING","USE_BATCHING"],format:11,location:12},{name:"a_vertexId",defines:["CC_USE_MORPH"],format:11,location:13}],blocks:[],samplerTextures:[{name:"outputResultMap",type:28,count:1,defines:[],stageFlags:16,binding:0}],buffers:[],images:[],textures:[],samplers:[],subpassInputs:[]}]},{name:"skybox",techniques:[{passes:[{rasterizerState:{cullMode:0},program:"skybox|sky-vs:vert|sky-fs:frag",priority:245,depthStencilState:{depthTest:!0,depthWrite:!1}}]}],shaders:[{name:"skybox|sky-vs:vert|sky-fs:frag",hash:2207113861,builtins:{statistics:{CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS:39,CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS:39},globals:{blocks:[{name:"CCGlobal",defines:[]},{name:"CCCamera",defines:[]}],samplerTextures:[{name:"cc_environment",defines:[]}],buffers:[],images:[]},locals:{blocks:[],samplerTextures:[],buffers:[],images:[]}},defines:[{name:"USE_INSTANCING",type:"boolean"},{name:"USE_BATCHING",type:"boolean"},{name:"CC_USE_SKINNING",type:"boolean"},{name:"CC_USE_BAKED_ANIMATION",type:"boolean"},{name:"CC_USE_LIGHTMAP",type:"boolean"},{name:"CC_RECEIVE_SHADOW",type:"boolean"},{name:"CC_USE_MORPH",type:"boolean"},{name:"CC_USE_IBL",type:"number",range:[0,2]},{name:"CC_USE_HDR",type:"boolean"},{name:"USE_RGBE_CUBEMAP",type:"boolean"}],attributes:[{name:"a_position",defines:[],format:32,location:0},{name:"a_normal",defines:[],format:32,location:1},{name:"a_texCoord",defines:[],format:21,location:2},{name:"a_tangent",defines:[],format:44,location:3},{name:"a_joints",defines:["CC_USE_SKINNING"],location:4},{name:"a_weights",defines:["CC_USE_SKINNING"],format:44,location:5},{name:"a_jointAnimInfo",defines:["USE_INSTANCING","CC_USE_BAKED_ANIMATION"],format:44,isInstanced:!0,location:6},{name:"a_matWorld0",defines:["USE_INSTANCING"],format:44,isInstanced:!0,location:7},{name:"a_matWorld1",defines:["USE_INSTANCING"],format:44,isInstanced:!0,location:8},{name:"a_matWorld2",defines:["USE_INSTANCING"],format:44,isInstanced:!0,location:9},{name:"a_lightingMapUVParam",defines:["USE_INSTANCING","CC_USE_LIGHTMAP"],format:44,isInstanced:!0,location:10},{name:"a_localShadowBias",defines:["USE_INSTANCING","CC_RECEIVE_SHADOW"],format:21,isInstanced:!0,location:11},{name:"a_dyn_batch_id",defines:["!USE_INSTANCING","USE_BATCHING"],format:11,location:12},{name:"a_vertexId",defines:["CC_USE_MORPH"],format:11,location:13}],blocks:[],samplerTextures:[],buffers:[],images:[],textures:[],samplers:[],subpassInputs:[]}]},{name:"profiler",techniques:[{passes:[{blendState:{targets:[{blend:!0,blendSrc:2,blendDst:4,blendDstAlpha:4}]},rasterizerState:{cullMode:0},program:"profiler|profiler-vs:vert|profiler-fs:frag",priority:255,depthStencilState:{depthTest:!1,depthWrite:!1}}]}],shaders:[{name:"profiler|profiler-vs:vert|profiler-fs:frag",hash:179162168,builtins:{statistics:{CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS:60,CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS:39},globals:{blocks:[{name:"CCGlobal",defines:[]},{name:"CCCamera",defines:[]}],samplerTextures:[],buffers:[],images:[]},locals:{blocks:[],samplerTextures:[],buffers:[],images:[]}},defines:[],attributes:[{name:"a_position",defines:[],format:32,location:0},{name:"a_color",defines:[],format:44,location:1}],blocks:[{name:"Constants",defines:[],binding:0,stageFlags:1,members:[{name:"offset",type:16,count:1}]},{name:"PerFrameInfo",defines:[],binding:1,stageFlags:1,members:[{name:"digits",type:16,count:20}]}],samplerTextures:[{name:"mainTexture",type:28,count:1,defines:[],stageFlags:16,binding:2}],buffers:[],images:[],textures:[],samplers:[],subpassInputs:[]}]},{name:"splash-screen",techniques:[{name:"default",passes:[{blendState:{targets:[{blend:!0,blendSrc:2,blendDst:4,blendDstAlpha:4}]},rasterizerState:{cullMode:0},program:"splash-screen|splash-screen-vs:vert|splash-screen-fs:frag",depthStencilState:{depthTest:!1,depthWrite:!1},properties:{mainTexture:{value:"grey",type:28},resolution:{value:[640,960],type:14,handleInfo:["u_buffer0",0,14]},percent:{value:[.5],type:13,handleInfo:["u_percent",0,13]},scale:{value:[200,500],type:14,handleInfo:["u_buffer1",0,14]},translate:{value:[320,480],type:14,handleInfo:["u_buffer1",2,14]},u_buffer0:{type:16,value:[640,960,0,0]},u_percent:{type:13,value:[.5]},u_buffer1:{type:16,value:[200,500,320,480]}}}]}],shaders:[{name:"splash-screen|splash-screen-vs:vert|splash-screen-fs:frag",hash:3189094080,builtins:{statistics:{CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS:6,CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS:1},globals:{blocks:[],samplerTextures:[],buffers:[],images:[]},locals:{blocks:[],samplerTextures:[],buffers:[],images:[]}},defines:[],attributes:[{name:"a_position",defines:[],format:21,location:0},{name:"a_texCoord",defines:[],format:21,location:1}],blocks:[{name:"Constant",defines:[],binding:0,stageFlags:1,members:[{name:"u_buffer0",type:16,count:1},{name:"u_buffer1",type:16,count:1},{name:"u_projection",type:25,count:1}]},{name:"Factor",defines:[],binding:1,stageFlags:16,members:[{name:"u_percent",type:13,count:1}]}],samplerTextures:[{name:"mainTexture",type:28,count:1,defines:[],stageFlags:16,binding:2}],buffers:[],images:[],textures:[],samplers:[],subpassInputs:[]}]}]),tm=4227858432,nm=66060288,im=1044480,om=e("l",(function(e,t,n,i){return void 0===i&&(i=0),t<<26&tm|e<<20&nm|n<<12&im|4095&i})),am=e("n",(function(e){return(e&tm)>>>26})),rm=e("o",(function(e){return(e&nm)>>>20})),cm=e("p",(function(e){return(e&im)>>>12})),sm=e("q",(function(e){return 4095&e})),lm=e("r",(function(e,t){return 67108863&e|t<<26&tm})),fm=e("t",((Zu={})[Be.UNKNOWN]=function(){return console.warn("illegal uniform handle")},Zu[Be.INT]=function(e,t,n){return void 0===n&&(n=0),e[n]},Zu[Be.INT2]=function(e,t,n){return void 0===n&&(n=0),Xn.fromArray(t,e,n)},Zu[Be.INT3]=function(e,t,n){return void 0===n&&(n=0),wn.fromArray(t,e,n)},Zu[Be.INT4]=function(e,t,n){return void 0===n&&(n=0),Zn.fromArray(t,e,n)},Zu[Be.FLOAT]=function(e,t,n){return void 0===n&&(n=0),e[n]},Zu[Be.FLOAT2]=function(e,t,n){return void 0===n&&(n=0),Xn.fromArray(t,e,n)},Zu[Be.FLOAT3]=function(e,t,n){return void 0===n&&(n=0),wn.fromArray(t,e,n)},Zu[Be.FLOAT4]=function(e,t,n){return void 0===n&&(n=0),Zn.fromArray(t,e,n)},Zu[Be.MAT3]=function(e,t,n){return void 0===n&&(n=0),Mn.fromArray(t,e,n)},Zu[Be.MAT4]=function(e,t,n){return void 0===n&&(n=0),jn.fromArray(t,e,n)},Zu)),_m=e("u",(($u={})[Be.UNKNOWN]=function(){return console.warn("illegal uniform handle")},$u[Be.INT]=function(e,t,n){return void 0===n&&(n=0),e[n]=t},$u[Be.INT2]=function(e,t,n){return void 0===n&&(n=0),Xn.toArray(e,t,n)},$u[Be.INT3]=function(e,t,n){return void 0===n&&(n=0),wn.toArray(e,t,n)},$u[Be.INT4]=function(e,t,n){return void 0===n&&(n=0),Zn.toArray(e,t,n)},$u[Be.FLOAT]=function(e,t,n){return void 0===n&&(n=0),e[n]=t},$u[Be.FLOAT2]=function(e,t,n){return void 0===n&&(n=0),Xn.toArray(e,t,n)},$u[Be.FLOAT3]=function(e,t,n){return void 0===n&&(n=0),wn.toArray(e,t,n)},$u[Be.FLOAT4]=function(e,t,n){return void 0===n&&(n=0),Zn.toArray(e,t,n)},$u[Be.MAT3]=function(e,t,n){return void 0===n&&(n=0),Mn.toArray(e,t,n)},$u[Be.MAT4]=function(e,t,n){return void 0===n&&(n=0),jn.toArray(e,t,n)},$u)),um=[Object.freeze([0]),Object.freeze([0,0]),Object.freeze([0,0,0,0]),Object.freeze([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])];function mm(e){switch(e){case Be.BOOL:case Be.INT:case Be.UINT:case Be.FLOAT:return um[0];case Be.BOOL2:case Be.INT2:case Be.UINT2:case Be.FLOAT2:return um[1];case Be.BOOL4:case Be.INT4:case Be.UINT4:case Be.FLOAT4:return um[2];case Be.MAT4:return um[3];case Be.SAMPLER2D:return"default-texture";case Be.SAMPLER_CUBE:return"default-cube-texture"}return um[0]}function dm(e,t){for(var n=Object.entries(t),i=!1,o=0;o<n.length;o++)e[n[o][0]]!==n[o][1]&&(e[n[o][0]]=n[o][1],i=!0);return i}var pm=new ot;function hm(e){return Math.ceil(Math.log2(Math.max(e,2)))}function vm(e,t){switch(e.type){case"boolean":return"number"==typeof t?t.toString():t?"1":"0";case"string":return void 0!==t?t:e.options[0];case"number":return void 0!==t?t.toString():e.range[0].toString();default:return console.warn("unknown define type '"+e.type+"'"),"-1"}}function gm(e,t,n,i,o){for(var a=e.builtins[i],r=[],c=function(e){var t=a.blocks[e],i=n.layouts[t.name],c=i&&n.bindings.find((function(e){return e.binding===i.binding}));if(!(i&&c&&c.descriptorType&dt))return console.warn("builtin UBO '"+t.name+"' not available!"),"continue";r.push(i),o&&!o.includes(c)&&o.push(c)},s=0;s<a.blocks.length;s++)c(s);Array.prototype.unshift.apply(t.shaderInfo.blocks,r);for(var l=[],f=function(e){var t=a.samplerTextures[e],i=n.layouts[t.name],r=i&&n.bindings.find((function(e){return e.binding===i.binding}));if(!(i&&r&&r.descriptorType&pt))return console.warn("builtin samplerTexture '"+t.name+"' not available!"),"continue";l.push(i),o&&!o.includes(r)&&o.push(r)},_=0;_<a.samplerTextures.length;_++)f(_);Array.prototype.unshift.apply(t.shaderInfo.samplerTextures,l),o&&o.sort((function(e,t){return e.binding-t.binding}))}function xm(e){return e.members.reduce((function(e,t){return e+rt(t.type)*t.count}),0)}function ym(e,t){for(var n=0;n<e.length;n++){var i=e[n];if("!"===i[0]){if(t[i.slice(1)])return!1}else if(!t[i])return!1}return!0}var Cm=function(){function e(){this._templates={},this._cache={},this._templateInfos={}}var t=e.prototype;return t.register=function(e){for(var t=0;t<e.shaders.length;t++)this.define(e.shaders[t]).effectName=e.name;for(var n=0;n<e.techniques.length;n++)for(var i=e.techniques[n],o=0;o<i.passes.length;o++){var a=i.passes[o];void 0!==a.propertyIndex&&void 0===a.properties&&(a.properties=i.passes[a.propertyIndex].properties)}},t.define=function(e){var t=this._templates[e.name];if(t&&t.hash===e.hash)return t;for(var n=Re({},e),i=0,o=function(e){var t=n.defines[e],o=1;if("number"===t.type){var a=t.range;o=hm(a[1]-a[0]+1),t._map=function(e){return e-a[0]}}else"string"===t.type?(o=hm(t.options.length),t._map=function(e){return Math.max(0,t.options.findIndex((function(t){return t===e})))}):"boolean"===t.type&&(t._map=function(e){return e?1:0});t._offset=i,i+=o},a=0;a<n.defines.length;a++)o(a);for(var r in i>31&&(n.uber=!0),n.constantMacros="",n.builtins.statistics)n.constantMacros+="#define "+r+" "+n.builtins.statistics[r]+"\n";if(this._templates[e.name]=n,!this._templateInfos[n.hash]){var c={};c.samplerStartBinding=n.blocks.length,c.shaderInfo=new at,c.blockSizes=[],c.bindings=[];for(var s=0;s<n.blocks.length;s++){var l=n.blocks[s];c.blockSizes.push(xm(l)),c.bindings.push(new Le(l.binding,ze.UNIFORM_BUFFER,1,l.stageFlags)),c.shaderInfo.blocks.push(new Ue(Qf.MATERIAL,l.binding,l.name,l.members.map((function(e){return new Ge(e.name,e.type,e.count)})),1))}for(var f=0;f<n.samplerTextures.length;f++){var _=n.samplerTextures[f];c.bindings.push(new Le(_.binding,ze.SAMPLER_TEXTURE,_.count,_.stageFlags)),c.shaderInfo.samplerTextures.push(new He(Qf.MATERIAL,_.binding,_.name,_.type,_.count))}for(var u=0;u<n.samplers.length;u++){var m=n.samplers[u];c.bindings.push(new Le(m.binding,ze.SAMPLER,m.count,m.stageFlags)),c.shaderInfo.samplers.push(new ct(Qf.MATERIAL,m.binding,m.name,m.count))}for(var d=0;d<n.textures.length;d++){var p=n.textures[d];c.bindings.push(new Le(p.binding,ze.TEXTURE,p.count,p.stageFlags)),c.shaderInfo.textures.push(new st(Qf.MATERIAL,p.binding,p.name,p.type,p.count))}for(var h=0;h<n.buffers.length;h++){var v=n.buffers[h];c.bindings.push(new Le(v.binding,ze.STORAGE_BUFFER,1,v.stageFlags)),c.shaderInfo.buffers.push(new lt(Qf.MATERIAL,v.binding,v.name,1,v.memoryAccess))}for(var g=0;g<n.images.length;g++){var x=n.images[g];c.bindings.push(new Le(x.binding,ze.STORAGE_IMAGE,x.count,x.stageFlags)),c.shaderInfo.images.push(new Ve(Qf.MATERIAL,x.binding,x.name,x.type,x.count,x.memoryAccess))}for(var y=0;y<n.subpassInputs.length;y++){var C=n.subpassInputs[y];c.bindings.push(new Le(C.binding,ze.INPUT_ATTACHMENT,C.count,C.stageFlags)),c.shaderInfo.subpassInputs.push(new ft(Qf.MATERIAL,C.binding,C.name,C.count))}c.gfxAttributes=[];for(var S=0;S<n.attributes.length;S++){var E=n.attributes[S];c.gfxAttributes.push(new _t(E.name,E.format,E.isNormalized,0,E.isInstanced,E.location))}gm(n,c,Yf,"locals"),c.shaderInfo.stages.push(new ut(Fe.VERTEX,"")),c.shaderInfo.stages.push(new ut(Fe.FRAGMENT,"")),c.handleMap=function(e){for(var t={},n=0;n<e.blocks.length;n++)for(var i=e.blocks[n],o=i.members,a=0,r=0;r<o.length;r++){var c=o[r];t[c.name]=om(i.binding,c.type,c.count,a),a+=(rt(c.type)>>2)*c.count}for(var s=0;s<e.samplerTextures.length;s++){var l=e.samplerTextures[s];t[l.name]=om(l.binding,l.type,l.count)}return t}(n),c.setLayouts=[],this._templateInfos[n.hash]=c}return n},t.getTemplate=function(e){return this._templates[e]},t.getTemplateInfo=function(e){var t=this._templates[e].hash;return this._templateInfos[t]},t.getDescriptorSetLayout=function(e,t,n){void 0===n&&(n=!1);var i=this._templates[t],o=this._templateInfos[i.hash];return o.setLayouts.length||(pm.bindings=o.bindings,o.setLayouts[Qf.MATERIAL]=e.createDescriptorSetLayout(pm),pm.bindings=Yf.bindings,o.setLayouts[Qf.LOCAL]=e.createDescriptorSetLayout(pm)),o.setLayouts[n?Qf.LOCAL:Qf.MATERIAL]},t.hasProgram=function(e){return void 0!==this._templates[e]},t.getKey=function(e,t){var n=this._templates[e],i=n.defines;if(n.uber){for(var o="",a=0;a<i.length;a++){var r=i[a],c=t[r.name];if(c&&r._map){var s=r._map(c);o+=""+r._offset+s+"|"}}return""+o+n.hash}for(var l=0,f=0;f<i.length;f++){var _=i[f],u=t[_.name];u&&_._map&&(l|=_._map(u)<<_._offset)}return l.toString(16)+"|"+n.hash},t.destroyShaderByDefines=function(e){var t=this,n=Object.keys(e);if(n.length)for(var i=n.map((function(t){var n=e[t];return"boolean"==typeof n&&(n=n?"1":"0"),new RegExp(""+t+n)})),o=Object.keys(this._cache).filter((function(e){return i.every((function(n){return n.test(t._cache[e].name)}))})),a=0;a<o.length;a++){var r=o[a],c=this._cache[r];Q("destroyed shader "+c.name),c.destroy(),delete this._cache[r]}},t.getGFXShader=function(e,t,n,i,o){Object.assign(n,i.macros),o||(o=this.getKey(t,n));var a=this._cache[o];if(a)return a;var r=this._templates[t],c=this._templateInfos[r.hash];c.pipelineLayout||(this.getDescriptorSetLayout(e,t),gm(r,c,Wf,"globals"),c.setLayouts[Qf.GLOBAL]=i.descriptorSetLayout,c.pipelineLayout=e.createPipelineLayout(new mt(c.setLayouts)));var s=function(e,t){for(var n=[],i=0;i<t.length;i++){var o=t[i],a=o.name,r=e[a],c=vm(o,r),s=!r||"0"===r;n.push({name:a,value:c,isDefault:s})}return n}(n,r.defines),l=i.constantMacros+r.constantMacros+s.reduce((function(e,t){return e+"#define "+t.name+" "+t.value+"\n"}),""),f=r.glsl3,_=Sm(e);return _?f=r[_]:console.error("Invalid GFX API!"),c.shaderInfo.stages[0].source=l+f.vert,c.shaderInfo.stages[1].source=l+f.frag,c.shaderInfo.attributes=function(e,t,n){for(var i=[],o=e.attributes,a=t.gfxAttributes,r=0;r<o.length;r++)ym(o[r].defines,n)&&i.push(a[r]);return i}(r,c,n),c.shaderInfo.name=function(e,t){return e+t.reduce((function(e,t){return t.isDefault?e:e+"|"+t.name+t.value}),"")}(t,s),this._cache[o]=e.createShader(c.shaderInfo)},e}();function Sm(e){switch(e.gfxAPI){case et.GLES2:case et.WEBGL:return"glsl1";case et.GLES3:case et.WEBGL2:return"glsl3";default:return"glsl4"}}var Em=e("z",new Cm);s.programLib=Em;var Pm,Im,Tm,bm={glsl1:[[{vert:"\nprecision mediump float;\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matViewInv;\nuniform highp mat4 cc_matViewProj;\nuniform highp mat4 cc_matWorld;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\nmat3 m = mat3(xAxis,yAxis,zAxis);\nfloat trace = m[0][0] + m[1][1] + m[2][2];\nvec4 quat;\nif (trace > 0.) {\nfloat s = 0.5 / sqrt(trace + 1.0);\nquat.w = 0.25 / s;\nquat.x = (m[2][1] - m[1][2]) * s;\nquat.y = (m[0][2] - m[2][0]) * s;\nquat.z = (m[1][0] - m[0][1]) * s;\n} else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\nfloat s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\nquat.w = (m[2][1] - m[1][2]) / s;\nquat.x = 0.25 * s;\nquat.y = (m[0][1] + m[1][0]) / s;\nquat.z = (m[0][2] + m[2][0]) / s;\n} else if (m[1][1] > m[2][2]) {\nfloat s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\nquat.w = (m[0][2] - m[2][0]) / s;\nquat.x = (m[0][1] + m[1][0]) / s;\nquat.y = 0.25 * s;\nquat.z = (m[1][2] + m[2][1]) / s;\n} else {\nfloat s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\nquat.w = (m[1][0] - m[0][1]) / s;\nquat.x = (m[0][2] + m[2][0]) / s;\nquat.y = (m[1][2] + m[2][1]) / s;\nquat.z = 0.25 * s;\n}\nfloat len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\nif (len > 0.) {\nlen = 1. / sqrt(len);\nquat.x = quat.x * len;\nquat.y = quat.y * len;\nquat.z = quat.z * len;\nquat.w = quat.w * len;\n}\nreturn quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\nfloat x = angle.x / 2.;\nfloat y = angle.y / 2.;\nfloat z = angle.z / 2.;\nfloat sx = sin(x);\nfloat cx = cos(x);\nfloat sy = sin(y);\nfloat cy = cos(y);\nfloat sz = sin(z);\nfloat cz = cos(z);\nvec4 quat = vec4(0);\nquat.x = sx * cy * cz + cx * sy * sz;\nquat.y = cx * sy * cz + sx * cy * sz;\nquat.z = cx * cy * sz - sx * sy * cz;\nquat.w = cx * cy * cz - sx * sy * sz;\nreturn quat;\n}\nvec4 quatMultiply (vec4 a, vec4 b){\nvec4 quat;\nquat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\nquat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\nquat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\nquat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\nreturn quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\nfloat ix = q.w * v.x + q.y * v.z - q.z * v.y;\nfloat iy = q.w * v.y + q.z * v.x - q.x * v.z;\nfloat iz = q.w * v.z + q.x * v.y - q.y * v.x;\nfloat iw = -q.x * v.x - q.y * v.y - q.z * v.z;\nv.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\nv.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\nv.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\nvec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\nvec4 rotQuat = quatMultiply(viewQuat, q);\nrotateVecFromQuat(pos, rotQuat);\nreturn pos;\n}\nvarying mediump vec2 uv;\nvarying mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n, mat4 viewInv\n) {\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nvec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\nvec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\nvec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\npos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n}\nattribute vec3 a_position;\nattribute vec2 a_texCoord;\nattribute vec4 a_color;\nuniform vec4 cc_size_rotation;\nvec4 vs_main() {\nvec4 pos = vec4(a_position, 1);\npos = cc_matWorld * pos;\nvec2 vertOffset = a_texCoord.xy - 0.5;\ncomputeVertPos(pos, vertOffset, quaternionFromEuler(vec3(0., 0., cc_size_rotation.z)), vec3(cc_size_rotation.xy, 0.), cc_matViewInv);\npos = cc_matViewProj * pos;\nuv = a_texCoord.xy;\ncolor = a_color;\nreturn pos;\n}\nvoid main() { gl_Position = vs_main(); }",frag:"\nprecision mediump float;\nvec4 CCFragOutput (vec4 color) {\nreturn color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\nuniform vec4 tintColor;\nvec4 add () {\nvec4 col = 2.0 * color * tintColor * texture2D(mainTexture, uv);\nreturn CCFragOutput(col);\n}\nvoid main() { gl_FragColor = add(); }"}],[{vert:"\nprecision highp float;\nattribute vec3 a_position;\nvec4 vert () {\nvec4 pos = vec4(a_position, 1);\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",frag:"\nprecision highp float;\nvec4 frag () {\nvec4 o = vec4(1.0);\nreturn o;\n}\nvoid main() { gl_FragColor = frag(); }"}],[{vert:"\nprecision mediump float;\nuniform highp mat4 cc_matViewProj;\nattribute highp vec3 a_position;\nattribute vec4 a_color;\nvarying vec4 v_color;\nvec4 vert () {\nvec4 pos = cc_matViewProj * vec4(a_position, 1);\npos.z -= 0.000001;\nv_color = a_color;\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",frag:"\nprecision mediump float;\nvec4 CCFragOutput (vec4 color) {\nreturn color;\n}\nvarying vec4 v_color;\nvec4 front() {\n#if USE_FORWARD_PIPELINE\nreturn CCFragOutput(v_color);\n#else\nreturn v_color;\n#endif\n}\nvoid main() { gl_FragColor = front(); }"},{vert:"\nprecision mediump float;\nuniform highp mat4 cc_matViewProj;\nattribute highp vec3 a_position;\nattribute vec4 a_color;\nvarying vec4 v_color;\nvec4 vert () {\nvec4 pos = cc_matViewProj * vec4(a_position, 1);\npos.z -= 0.000001;\nv_color = a_color;\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",frag:"\nprecision mediump float;\nvec4 CCFragOutput (vec4 color) {\nreturn color;\n}\nvarying vec4 v_color;\nvec4 back() {\n#if USE_FORWARD_PIPELINE\nreturn CCFragOutput(vec4(v_color.rgb, v_color.a * 0.2));\n#else\nreturn vec4(v_color.rgb, v_color.a * 0.2);\n#endif\n}\nvoid main() { gl_FragColor = back(); }"},{vert:"\nprecision mediump float;\nuniform highp mat4 cc_matViewProj;\nattribute highp vec3 a_position;\nattribute vec4 a_color;\nvarying vec4 v_color;\nvarying float v_distance;\nvec4 vert () {\nvec4 pos = cc_matViewProj * vec4(a_position, 1);\npos.z -= 0.000001;\nv_color = a_color;\nv_distance = dot(a_position, vec3(1.0, 1.0, 1.0));\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",frag:"\nprecision mediump float;\nvec4 CCFragOutput (vec4 color) {\nreturn color;\n}\nvarying vec4 v_color;\nvarying float v_distance;\nvec4 front() {\nif (fract(v_distance) > 0.5) {\ndiscard;\n}\n#if USE_FORWARD_PIPELINE\nreturn CCFragOutput(v_color);\n#else\nreturn v_color;\n#endif\n}\nvoid main() { gl_FragColor = front(); }"},{vert:"\nprecision mediump float;\nuniform highp mat4 cc_matViewProj;\nattribute highp vec3 a_position;\nattribute vec4 a_color;\nvarying vec4 v_color;\nvarying float v_distance;\nvec4 vert () {\nvec4 pos = cc_matViewProj * vec4(a_position, 1);\npos.z -= 0.000001;\nv_color = a_color;\nv_distance = dot(a_position, vec3(1.0, 1.0, 1.0));\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",frag:"\nprecision mediump float;\nvec4 CCFragOutput (vec4 color) {\nreturn color;\n}\nvarying vec4 v_color;\nvarying float v_distance;\nvec4 back() {\nif (fract(v_distance) > 0.5) {\ndiscard;\n}\n#if USE_FORWARD_PIPELINE\nreturn CCFragOutput(vec4(v_color.rgb, v_color.a * 0.2));\n#else\nreturn vec4(v_color.rgb, v_color.a * 0.2);\n#endif\n}\nvoid main() { gl_FragColor = back(); }"},{vert:"\nprecision mediump float;\nuniform highp mat4 cc_matViewProj;\nattribute highp vec3 a_position;\nattribute vec4 a_normal;\nattribute vec4 a_color;\nvarying vec4 v_color;\nvec4 vert () {\nvec4 pos = cc_matViewProj * vec4(a_position, 1);\nv_color = a_color;\nfloat intensity = dot(vec3(1, 2, 4), a_normal.xyz);\nv_color.rgb -= a_normal.w * intensity * 0.1;\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",frag:"\nprecision mediump float;\nvec4 CCFragOutput (vec4 color) {\nreturn color;\n}\nvarying vec4 v_color;\nvec4 front() {\n#if USE_FORWARD_PIPELINE\nreturn CCFragOutput(v_color);\n#else\nreturn v_color;\n#endif\n}\nvoid main() { gl_FragColor = front(); }"},{vert:"\nprecision mediump float;\nuniform highp mat4 cc_matViewProj;\nattribute highp vec3 a_position;\nattribute vec4 a_normal;\nattribute vec4 a_color;\nvarying vec4 v_color;\nvec4 vert () {\nvec4 pos = cc_matViewProj * vec4(a_position, 1);\nv_color = a_color;\nfloat intensity = dot(vec3(1, 2, 4), a_normal.xyz);\nv_color.rgb -= a_normal.w * intensity * 0.1;\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",frag:"\nprecision mediump float;\nvec4 CCFragOutput (vec4 color) {\nreturn color;\n}\nvarying vec4 v_color;\nvec4 back() {\n#if USE_FORWARD_PIPELINE\nreturn CCFragOutput(vec4(v_color.rgb, v_color.a * 0.2));\n#else\nreturn vec4(v_color.rgb, v_color.a * 0.2);\n#endif\n}\nvoid main() { gl_FragColor = back(); }"}],[{vert:"\nprecision highp float;\nuniform highp mat4 cc_matViewProj;\nuniform highp mat4 cc_matWorld;\nattribute vec3 a_position;\nattribute vec4 a_color;\nvarying vec4 v_color;\nattribute float a_dist;\nvarying float v_dist;\nvec4 vert () {\nvec4 pos = vec4(a_position, 1);\npos = cc_matViewProj * cc_matWorld * pos;\nv_color = a_color;\nv_dist = a_dist;\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",frag:"\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives: enable\n#endif\nprecision highp float;\nvarying vec4 v_color;\nvarying float v_dist;\nvec4 frag () {\nvec4 o = v_color;\n#ifdef GL_OES_standard_derivatives\nfloat aa = fwidth(v_dist);\n#else\nfloat aa = 0.05;\n#endif\nfloat alpha = 1. - smoothstep(-aa, 0., abs(v_dist) - 1.0);\no.rgb *= o.a;\no *= alpha;\nreturn o;\n}\nvoid main() { gl_FragColor = frag(); }"}],[{vert:"\nprecision highp float;\nuniform highp mat4 cc_matViewProj;\nuniform highp vec4 cc_worldBoundCenter;\nuniform highp vec4 cc_worldBoundHalfExtents;\nattribute vec3 a_position;\nvec4 vert () {\nvec4 position;\nposition = vec4(a_position, 1.0);\nposition *= cc_worldBoundHalfExtents;\nposition += cc_worldBoundCenter;\nposition = cc_matViewProj * position;\nreturn position;\n}\nvoid main() { gl_Position = vert(); }",frag:"\nprecision mediump float;\nvec4 frag () {\nreturn vec4(1, 0, 0, 1);\n}\nvoid main() { gl_FragColor = frag(); }"}],[{vert:"\nprecision mediump float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\nmat3 m = mat3(xAxis,yAxis,zAxis);\nfloat trace = m[0][0] + m[1][1] + m[2][2];\nvec4 quat;\nif (trace > 0.) {\nfloat s = 0.5 / sqrt(trace + 1.0);\nquat.w = 0.25 / s;\nquat.x = (m[2][1] - m[1][2]) * s;\nquat.y = (m[0][2] - m[2][0]) * s;\nquat.z = (m[1][0] - m[0][1]) * s;\n} else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\nfloat s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\nquat.w = (m[2][1] - m[1][2]) / s;\nquat.x = 0.25 * s;\nquat.y = (m[0][1] + m[1][0]) / s;\nquat.z = (m[0][2] + m[2][0]) / s;\n} else if (m[1][1] > m[2][2]) {\nfloat s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\nquat.w = (m[0][2] - m[2][0]) / s;\nquat.x = (m[0][1] + m[1][0]) / s;\nquat.y = 0.25 * s;\nquat.z = (m[1][2] + m[2][1]) / s;\n} else {\nfloat s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\nquat.w = (m[1][0] - m[0][1]) / s;\nquat.x = (m[0][2] + m[2][0]) / s;\nquat.y = (m[1][2] + m[2][1]) / s;\nquat.z = 0.25 * s;\n}\nfloat len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\nif (len > 0.) {\nlen = 1. / sqrt(len);\nquat.x = quat.x * len;\nquat.y = quat.y * len;\nquat.z = quat.z * len;\nquat.w = quat.w * len;\n}\nreturn quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\nfloat x = angle.x / 2.;\nfloat y = angle.y / 2.;\nfloat z = angle.z / 2.;\nfloat sx = sin(x);\nfloat cx = cos(x);\nfloat sy = sin(y);\nfloat cy = cos(y);\nfloat sz = sin(z);\nfloat cz = cos(z);\nvec4 quat = vec4(0);\nquat.x = sx * cy * cz + cx * sy * sz;\nquat.y = cx * sy * cz + sx * cy * sz;\nquat.z = cx * cy * sz - sx * sy * cz;\nquat.w = cx * cy * cz - sx * sy * sz;\nreturn quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\nfloat x2 = q.x + q.x;\nfloat y2 = q.y + q.y;\nfloat z2 = q.z + q.z;\nfloat xx = q.x * x2;\nfloat xy = q.x * y2;\nfloat xz = q.x * z2;\nfloat yy = q.y * y2;\nfloat yz = q.y * z2;\nfloat zz = q.z * z2;\nfloat wx = q.w * x2;\nfloat wy = q.w * y2;\nfloat wz = q.w * z2;\nreturn mat4(\n1. - (yy + zz), xy + wz, xz - wy, 0,\nxy - wz, 1. - (xx + zz), yz + wx, 0,\nxz + wy, yz - wx, 1. - (xx + yy), 0,\np.x, p.y, p.z, 1\n);\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\nfloat x = q.x, y = q.y, z = q.z, w = q.w;\nfloat x2 = x + x;\nfloat y2 = y + y;\nfloat z2 = z + z;\nfloat xx = x * x2;\nfloat xy = x * y2;\nfloat xz = x * z2;\nfloat yy = y * y2;\nfloat yz = y * z2;\nfloat zz = z * z2;\nfloat wx = w * x2;\nfloat wy = w * y2;\nfloat wz = w * z2;\nfloat sx = s.x;\nfloat sy = s.y;\nfloat sz = s.z;\nreturn mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n(xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n(xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\nt.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\nvec4 quat;\nquat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\nquat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\nquat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\nquat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\nreturn quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\nfloat ix = q.w * v.x + q.y * v.z - q.z * v.y;\nfloat iy = q.w * v.y + q.z * v.x - q.x * v.z;\nfloat iz = q.w * v.z + q.x * v.y - q.y * v.x;\nfloat iw = -q.x * v.x - q.y * v.y - q.z * v.z;\nv.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\nv.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\nv.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\nvec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\nvec4 rotQuat = quatMultiply(viewQuat, q);\nrotateVecFromQuat(pos, rotQuat);\nreturn pos;\n}\nmat3 quatToMat3(vec4 q) {\nvec3 m0 = vec3(\n1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n2.0 * q.x * q.y + 2.0 * q.w * q.z,\n2.0 * q.x * q.z - 2.0 * q.w * q.y);\nvec3 m1 = vec3(\n2.0 * q.x * q.y - 2.0 * q.w * q.z,\n1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n2.0 * q.y * q.z + 2.0 * q.w * q.x);\nvec3 m2 = vec3(\n2.0 * q.x * q.z + 2.0 * q.w * q.y,\n2.0 * q.y * q.z - 2.0 * q.w * q.x,\n1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\nreturn mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\nfloat tr = mat[0][0] + mat[1][1] + mat[2][2];\nfloat qw, qx, qy, qz;\nif (tr > 0.0) {\nfloat S = sqrt(tr + 1.0) * 2.0;\nfloat invS = 1.0 / S;\nqw = 0.25 * S;\nqx = (mat[1][2] - mat[2][1]) * invS;\nqy = (mat[2][0] - mat[0][2]) * invS;\nqz = (mat[0][1] - mat[1][0]) * invS;\n} else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\nfloat S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\nfloat invS = 1.0 / S;\nqw = (mat[1][2] - mat[2][1]) * invS;\nqx = 0.25 * S;\nqy = (mat[1][0] + mat[0][1]) * invS;\nqz = (mat[2][0] + mat[0][2]) * invS;\n} else if (mat[1][1] > mat[2][2]) {\nfloat S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\nfloat invS = 1.0 / S;\nqw = (mat[2][0] - mat[0][2]) * invS;\nqx = (mat[1][0] + mat[0][1]) * invS;\nqy = 0.25 * S;\nqz = (mat[2][1] + mat[1][2]) * invS;\n} else {\nfloat S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\nfloat invS = 1.0 / S;\nqw = (mat[0][1] - mat[1][0]) * invS;\nqx = (mat[2][0] + mat[0][2]) * invS;\nqy = (mat[2][1] + mat[1][2]) * invS;\nqz = 0.25 * S;\n}\nreturn vec4(qx, qy, qz, qw);\n}\nvec4 eulerToQuat(vec3 euler) {\nvec3 er = euler * 0.5;\nfloat x = er.x, y = er.y, z = er.z;\nfloat sx = sin(x);\nfloat cx = cos(x);\nfloat sy = sin(y);\nfloat cy = cos(y);\nfloat sz = sin(z);\nfloat cz = cos(z);\nvec4 quat;\nquat.x = sx * cy * cz + cx * sy * sz;\nquat.y = cx * sy * cz + sx * cy * sz;\nquat.z = cx * cy * sz - sx * sy * cz;\nquat.w = cx * cy * cz - sx * sy * sz;\nreturn quat;\n}\nuniform vec4 mainTiling_Offset;\nuniform vec4 frameTile_velLenScale;\nuniform vec4 scale;\nuniform vec4 nodeRotation;\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matViewInv;\nuniform highp mat4 cc_matViewProj;\nuniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying mediump vec2 uv;\nvarying mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n, mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n, vec3 eye\n, vec4 velocity\n, float velocityScale\n, float lengthScale\n, float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nvec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\nvec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\nvec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\npos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\nvec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\nvec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\npos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nvec3 camX = vec3(1, 0, 0);\nvec3 camY = vec3(0, 0, -1);\npos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nrotateVecFromQuat(viewSpaceVert, q);\nvec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\nvec3 camY = vec3(0, 1, 0);\nvec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\npos.xyz += offset;\n#else\npos.x += vertOffset.x;\npos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\nvec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\naniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\nvertIndex.y = 1. - vertIndex.y;\n#endif\nreturn (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nuniform vec4 u_sampleInfo;\nuniform vec4 u_worldRot;\nuniform vec4 u_timeDelta;\nattribute vec4 a_position_starttime;\nattribute vec4 a_size_uv;\nattribute vec4 a_rotation_uv;\nattribute vec4 a_color;\nattribute vec4 a_dir_life;\nattribute float a_rndSeed;\n#if CC_RENDER_MODE == 4\nattribute vec3 a_texCoord;\nattribute vec3 a_texCoord3;\nattribute vec3 a_normal;\nattribute vec4 a_color1;\n#endif\nvec3 unpackCurveData (sampler2D tex, vec2 coord) {\nvec4 a = texture2D(tex, coord);\nvec4 b = texture2D(tex, coord + u_sampleInfo.y);\nfloat c = fract(coord.x * u_sampleInfo.x);\nreturn mix(a.xyz, b.xyz, c);\n}\nvec3 unpackCurveData (sampler2D tex, vec2 coord, out float w) {\nvec4 a = texture2D(tex, coord);\nvec4 b = texture2D(tex, coord + u_sampleInfo.y);\nfloat c = fract(coord.x * u_sampleInfo.x);\nw = mix(a.w, b.w, c);\nreturn mix(a.xyz, b.xyz, c);\n}\nfloat pseudoRandom(float x) {\n#if USE_VK_SHADER\nfloat o = x;\nx = mod(x - 1.0, 2.0) - 1.0;\nfloat freqVar = 10.16640753482;\nfloat y = sin(freqVar * floor(o * 0.5 - 0.5));\nfloat v = max(0.0, 1.0-abs(x));\nv *= 0.7071067812;\nv = y < 0.0 ? -v : v;\nreturn v;\n#else\nfloat seed = mod(x, 233280.);\nfloat q = (seed * 9301. + 49297.) / 233280.;\nreturn fract(q);\n#endif\n}\n#if COLOR_OVER_TIME_MODULE_ENABLE\nuniform sampler2D color_over_time_tex0;\nuniform int u_color_mode;\n#endif\n#if ROTATION_OVER_TIME_MODULE_ENABLE\nuniform sampler2D rotation_over_time_tex0;\nuniform int u_rotation_mode;\n#endif\n#if SIZE_OVER_TIME_MODULE_ENABLE\nuniform sampler2D size_over_time_tex0;\nuniform int u_size_mode;\n#endif\n#if FORCE_OVER_TIME_MODULE_ENABLE\nuniform sampler2D force_over_time_tex0;\nuniform int u_force_mode;\nuniform int u_force_space;\n#endif\n#if VELOCITY_OVER_TIME_MODULE_ENABLE\nuniform sampler2D velocity_over_time_tex0;\nuniform int u_velocity_mode;\nuniform int u_velocity_space;\n#endif\n#if TEXTURE_ANIMATION_MODULE_ENABLE\nuniform sampler2D texture_animation_tex0;\nuniform vec4 u_anim_info;\n#endif\nfloat repeat (float t, float length) {\nreturn t - floor(t / length) * length;\n}\nvec4 rotateQuat (vec4 p, vec4 q) {\nvec3 iv = cross(q.xyz, p.xyz) + q.w * p.xyz;\nvec3 res = p.xyz + 2.0 * cross(q.xyz, iv);\nreturn vec4(res.xyz, p.w);\n}\nvec4 gpvs_main () {\nfloat activeTime = u_timeDelta.x - a_position_starttime.w;\nfloat normalizedTime = clamp(activeTime / a_dir_life.w, 0.0, 1.0);\nvec2 timeCoord0 = vec2(normalizedTime, 0.);\nvec2 timeCoord1 = vec2(normalizedTime, 1.);\n#if CC_RENDER_MODE == 4\nvec2 vertIdx = vec2(a_texCoord.x, a_texCoord.y);\n#else\nvec2 vertIdx = vec2(a_size_uv.w, a_rotation_uv.w);\n#endif\nvec4 velocity = vec4(a_dir_life.xyz, 0.);\nvec4 pos = vec4(a_position_starttime.xyz, 1.);\nvec3 size = a_size_uv.xyz;\n#if SIZE_OVER_TIME_MODULE_ENABLE\nif (u_size_mode == 1) {\nsize *= unpackCurveData(size_over_time_tex0, timeCoord0);\n} else {\nvec3 size_0 = unpackCurveData(size_over_time_tex0, timeCoord0);\nvec3 size_1 = unpackCurveData(size_over_time_tex0, timeCoord1);\nfloat factor_s = pseudoRandom(a_rndSeed + 39825.);\nsize *= mix(size_0, size_1, factor_s);\n}\n#endif\nvec3 compScale = scale.xyz * size;\n#if FORCE_OVER_TIME_MODULE_ENABLE\nvec3 forceAnim = vec3(0.);\nif (u_force_mode == 1) {\nforceAnim = unpackCurveData(force_over_time_tex0, timeCoord0);\n} else {\nvec3 force_0 = unpackCurveData(force_over_time_tex0, timeCoord0);\nvec3 force_1 = unpackCurveData(force_over_time_tex0, timeCoord1);\nfloat factor_f =  pseudoRandom(a_rndSeed + 212165.);\nforceAnim = mix(force_0, force_1, factor_f);\n}\nvec4 forceTrack = vec4(forceAnim, 0.);\nif (u_force_space == 0) {\nforceTrack = rotateQuat(forceTrack, u_worldRot);\n}\nvelocity.xyz += forceTrack.xyz;\n#endif\n#if VELOCITY_OVER_TIME_MODULE_ENABLE\nfloat speedModifier0 = 1.;\nfloat speedModifier1 = 1.;\nvec3 velocityAnim = vec3(0.);\nif (u_velocity_mode == 1) {\nvelocityAnim = unpackCurveData(velocity_over_time_tex0, timeCoord0, speedModifier0);\n} else {\nvec3 vectory_0 = unpackCurveData(velocity_over_time_tex0, timeCoord0, speedModifier0);\nvec3 vectory_1 = unpackCurveData(velocity_over_time_tex0, timeCoord1, speedModifier1);\nfloat factor_v = pseudoRandom(a_rndSeed + 197866.);\nvelocityAnim = mix(vectory_0, vectory_1, factor_v);\nspeedModifier0 = mix(speedModifier0, speedModifier1, factor_v);\n}\nvec4 velocityTrack = vec4(velocityAnim, 0.);\nif (u_velocity_space == 0) {\nvelocityTrack = rotateQuat(velocityTrack, u_worldRot);\n}\nvelocity.xyz += velocityTrack.xyz;\nvelocity.xyz *= speedModifier0;\n#endif\npos.xyz += velocity.xyz * normalizedTime * a_dir_life.w;\n#if !CC_USE_WORLD_SPACE\npos = cc_matWorld * pos;\n#if CC_RENDER_MODE == 1\nvelocity = rotateQuat(velocity, u_worldRot);\n#endif\n#endif\nvec3 startRotation = a_rotation_uv.xyz;\n#if CC_RENDER_MODE != 4\n#if CC_RENDER_MODE == 0\nvec3 rotEuler = startRotation.xyz;\n#elif CC_RENDER_MODE == 1\nvec3 rotEuler = vec3(0.);\n#else\nvec3 rotEuler = vec3(0., 0., startRotation.z);\n#endif\nvec4 rot = quaternionFromEuler(rotEuler);\n#else\nvec4 rot = quaternionFromEuler(startRotation);\n#endif\n#if ROTATION_OVER_TIME_MODULE_ENABLE\nif (u_rotation_mode == 1) {\nvec3 euler = unpackCurveData(rotation_over_time_tex0, timeCoord0) * normalizedTime * a_dir_life.w;\nvec4 quat = eulerToQuat(euler);\nmat3 mLocal = quatToMat3(quat);\nmat3 mStart = quatToMat3(rot);\nrot = mat3ToQuat(mStart * mLocal);\n} else {\nvec3 rotation_0 = unpackCurveData(rotation_over_time_tex0, timeCoord0);\nvec3 rotation_1 = unpackCurveData(rotation_over_time_tex0, timeCoord1);\nfloat factor_r = pseudoRandom(a_rndSeed + 125292.);\nvec3 euler = mix(rotation_0, rotation_1, factor_r) * normalizedTime * a_dir_life.w;\n#if CC_RENDER_MODE == 3 || CC_RENDER_MODE == 2\neuler = vec3(0.0, 0.0, euler.z);\n#endif\nvec4 quat = eulerToQuat(euler);\nmat3 mLocal = quatToMat3(quat);\nmat3 mStart = quatToMat3(rot);\nrot = mat3ToQuat(mStart * mLocal);\n}\n#endif\n#if COLOR_OVER_TIME_MODULE_ENABLE\nif (u_color_mode == 1) {\ncolor = a_color * texture2D(color_over_time_tex0, timeCoord0);\n} else {\nvec4 color_0 = texture2D(color_over_time_tex0, timeCoord0);\nvec4 color_1 = texture2D(color_over_time_tex0, timeCoord1);\nfloat factor_c = pseudoRandom(a_rndSeed + 91041.);\ncolor = a_color * mix(color_0, color_1, factor_c);\n}\n#else\ncolor = a_color;\n#endif\n#if CC_RENDER_MODE != 4\nvec2 cornerOffset = vec2((vertIdx - 0.5));\n#if CC_RENDER_MODE == 1\nrot = vec4(0.0, 0.0, 0.0, 1.0);\n#endif\ncomputeVertPos(pos, cornerOffset, rot, compScale\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n, cc_matViewInv\n#endif\n#if CC_RENDER_MODE == 1\n, cc_cameraPos.xyz\n, velocity\n, frameTile_velLenScale.z\n, frameTile_velLenScale.w\n, a_size_uv.w\n#endif\n);\n#else\nmat3 rotMat = quatToMat3(rot);\nmat3 nodeMat = quatToMat3(nodeRotation);\nrotMat = nodeMat * rotMat;\nrot = mat3ToQuat(rotMat);\nmat4 xformNoScale = matrixFromRT(rot, pos.xyz);\nmat4 xform = matFromRTS(rot, pos.xyz, compScale);\npos = xform * vec4(a_texCoord3, 1);\nvec4 normal = xformNoScale * vec4(a_normal, 0);\ncolor *= a_color1;\n#endif\npos = cc_matViewProj * pos;\nfloat frameIndex = 0.;\n#if TEXTURE_ANIMATION_MODULE_ENABLE\nfloat startFrame = 0.;\nvec3 frameInfo = vec3(0.);\nif (int(u_anim_info.x) == 1) {\nframeInfo = unpackCurveData(texture_animation_tex0, timeCoord0);\n} else {\nvec3 frameInfo0 = unpackCurveData(texture_animation_tex0, timeCoord0);\nvec3 frameInfo1 = unpackCurveData(texture_animation_tex0, timeCoord1);\nfloat factor_t = pseudoRandom(a_rndSeed + 90794.);\nframeInfo = mix(frameInfo0, frameInfo1, factor_t);\n}\nstartFrame = frameInfo.x / u_anim_info.y;\nframeIndex = repeat(u_anim_info.z * (frameInfo.y + startFrame), 1.);\n#endif\nuv = computeUV(frameIndex, vertIdx, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\nreturn pos;\n}\nvoid main() { gl_Position = gpvs_main(); }",frag:"\nprecision mediump float;\nvec4 CCFragOutput (vec4 color) {\nreturn color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\nuniform vec4 tintColor;\nvec4 add () {\nvec4 col = 2.0 * color * tintColor * texture2D(mainTexture, uv);\nreturn CCFragOutput(col);\n}\nvoid main() { gl_FragColor = add(); }"}],[{vert:"\nprecision mediump float;\nuniform vec4 mainTiling_Offset;\nuniform highp mat4 cc_matViewProj;\nuniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying mediump vec2 uv;\nvarying mediump vec4 color;\nattribute vec3 a_position;\nattribute vec4 a_texCoord;\nattribute vec3 a_texCoord1;\nattribute vec3 a_texCoord2;\nattribute vec4 a_color;\n#if CC_DRAW_WIRE_FRAME\nvarying vec3 vBarycentric;\n#endif\nvec4 vs_main() {\nhighp vec4 pos = vec4(a_position, 1);\nvec4 velocity = vec4(a_texCoord1.xyz, 0);\n#if !CC_USE_WORLD_SPACE\npos = cc_matWorld * pos;\nvelocity = cc_matWorld * velocity;\n#endif\nfloat vertOffset = (a_texCoord.x - 0.5) * a_texCoord.y;\nvec3 camUp = normalize(cross(pos.xyz - cc_cameraPos.xyz, velocity.xyz));\npos.xyz += camUp * vertOffset;\npos = cc_matViewProj * pos;\nuv = a_texCoord.zw * mainTiling_Offset.xy + mainTiling_Offset.zw;;\ncolor = a_color;\n#if CC_DRAW_WIRE_FRAME\nvBarycentric = a_texCoord2;\n#endif\nreturn pos;\n}\nvoid main() { gl_Position = vs_main(); }",frag:"\nprecision mediump float;\nvec4 CCFragOutput (vec4 color) {\nreturn color;\n}\nvarying vec2 uv;\nvarying vec4 color;\n#if CC_DRAW_WIRE_FRAME\nvarying vec3 vBarycentric;\n#endif\nuniform sampler2D mainTexture;\nuniform vec4 tintColor;\nvec4 add () {\nvec4 col = 2.0 * color * tintColor * texture2D(mainTexture, uv);\n#if CC_DRAW_WIRE_FRAME\nif (any(lessThan(vBarycentric, vec3(0.02)))) {\ncol = vec4(0., 1., 1., 1.);\n}\n#endif\nreturn CCFragOutput(col);\n}\nvoid main() { gl_FragColor = add(); }"}],[{vert:"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\nmat3 m = mat3(xAxis,yAxis,zAxis);\nfloat trace = m[0][0] + m[1][1] + m[2][2];\nvec4 quat;\nif (trace > 0.) {\nfloat s = 0.5 / sqrt(trace + 1.0);\nquat.w = 0.25 / s;\nquat.x = (m[2][1] - m[1][2]) * s;\nquat.y = (m[0][2] - m[2][0]) * s;\nquat.z = (m[1][0] - m[0][1]) * s;\n} else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\nfloat s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\nquat.w = (m[2][1] - m[1][2]) / s;\nquat.x = 0.25 * s;\nquat.y = (m[0][1] + m[1][0]) / s;\nquat.z = (m[0][2] + m[2][0]) / s;\n} else if (m[1][1] > m[2][2]) {\nfloat s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\nquat.w = (m[0][2] - m[2][0]) / s;\nquat.x = (m[0][1] + m[1][0]) / s;\nquat.y = 0.25 * s;\nquat.z = (m[1][2] + m[2][1]) / s;\n} else {\nfloat s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\nquat.w = (m[1][0] - m[0][1]) / s;\nquat.x = (m[0][2] + m[2][0]) / s;\nquat.y = (m[1][2] + m[2][1]) / s;\nquat.z = 0.25 * s;\n}\nfloat len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\nif (len > 0.) {\nlen = 1. / sqrt(len);\nquat.x = quat.x * len;\nquat.y = quat.y * len;\nquat.z = quat.z * len;\nquat.w = quat.w * len;\n}\nreturn quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\nfloat x = angle.x / 2.;\nfloat y = angle.y / 2.;\nfloat z = angle.z / 2.;\nfloat sx = sin(x);\nfloat cx = cos(x);\nfloat sy = sin(y);\nfloat cy = cos(y);\nfloat sz = sin(z);\nfloat cz = cos(z);\nvec4 quat = vec4(0);\nquat.x = sx * cy * cz + cx * sy * sz;\nquat.y = cx * sy * cz + sx * cy * sz;\nquat.z = cx * cy * sz - sx * sy * cz;\nquat.w = cx * cy * cz - sx * sy * sz;\nreturn quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\nfloat x2 = q.x + q.x;\nfloat y2 = q.y + q.y;\nfloat z2 = q.z + q.z;\nfloat xx = q.x * x2;\nfloat xy = q.x * y2;\nfloat xz = q.x * z2;\nfloat yy = q.y * y2;\nfloat yz = q.y * z2;\nfloat zz = q.z * z2;\nfloat wx = q.w * x2;\nfloat wy = q.w * y2;\nfloat wz = q.w * z2;\nreturn mat4(\n1. - (yy + zz), xy + wz, xz - wy, 0,\nxy - wz, 1. - (xx + zz), yz + wx, 0,\nxz + wy, yz - wx, 1. - (xx + yy), 0,\np.x, p.y, p.z, 1\n);\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\nfloat x = q.x, y = q.y, z = q.z, w = q.w;\nfloat x2 = x + x;\nfloat y2 = y + y;\nfloat z2 = z + z;\nfloat xx = x * x2;\nfloat xy = x * y2;\nfloat xz = x * z2;\nfloat yy = y * y2;\nfloat yz = y * z2;\nfloat zz = z * z2;\nfloat wx = w * x2;\nfloat wy = w * y2;\nfloat wz = w * z2;\nfloat sx = s.x;\nfloat sy = s.y;\nfloat sz = s.z;\nreturn mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n(xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n(xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\nt.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\nvec4 quat;\nquat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\nquat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\nquat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\nquat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\nreturn quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\nfloat ix = q.w * v.x + q.y * v.z - q.z * v.y;\nfloat iy = q.w * v.y + q.z * v.x - q.x * v.z;\nfloat iz = q.w * v.z + q.x * v.y - q.y * v.x;\nfloat iw = -q.x * v.x - q.y * v.y - q.z * v.z;\nv.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\nv.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\nv.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\nvec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\nvec4 rotQuat = quatMultiply(viewQuat, q);\nrotateVecFromQuat(pos, rotQuat);\nreturn pos;\n}\nmat3 quatToMat3(vec4 q) {\nvec3 m0 = vec3(\n1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n2.0 * q.x * q.y + 2.0 * q.w * q.z,\n2.0 * q.x * q.z - 2.0 * q.w * q.y);\nvec3 m1 = vec3(\n2.0 * q.x * q.y - 2.0 * q.w * q.z,\n1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n2.0 * q.y * q.z + 2.0 * q.w * q.x);\nvec3 m2 = vec3(\n2.0 * q.x * q.z + 2.0 * q.w * q.y,\n2.0 * q.y * q.z - 2.0 * q.w * q.x,\n1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\nreturn mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\nfloat tr = mat[0][0] + mat[1][1] + mat[2][2];\nfloat qw, qx, qy, qz;\nif (tr > 0.0) {\nfloat S = sqrt(tr + 1.0) * 2.0;\nfloat invS = 1.0 / S;\nqw = 0.25 * S;\nqx = (mat[1][2] - mat[2][1]) * invS;\nqy = (mat[2][0] - mat[0][2]) * invS;\nqz = (mat[0][1] - mat[1][0]) * invS;\n} else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\nfloat S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\nfloat invS = 1.0 / S;\nqw = (mat[1][2] - mat[2][1]) * invS;\nqx = 0.25 * S;\nqy = (mat[1][0] + mat[0][1]) * invS;\nqz = (mat[2][0] + mat[0][2]) * invS;\n} else if (mat[1][1] > mat[2][2]) {\nfloat S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\nfloat invS = 1.0 / S;\nqw = (mat[2][0] - mat[0][2]) * invS;\nqx = (mat[1][0] + mat[0][1]) * invS;\nqy = 0.25 * S;\nqz = (mat[2][1] + mat[1][2]) * invS;\n} else {\nfloat S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\nfloat invS = 1.0 / S;\nqw = (mat[0][1] - mat[1][0]) * invS;\nqx = (mat[2][0] + mat[0][2]) * invS;\nqy = (mat[2][1] + mat[1][2]) * invS;\nqz = 0.25 * S;\n}\nreturn vec4(qx, qy, qz, qw);\n}\nuniform vec4 mainTiling_Offset;\nuniform vec4 frameTile_velLenScale;\nuniform vec4 scale;\nuniform vec4 nodeRotation;\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matViewInv;\nuniform highp mat4 cc_matViewProj;\nuniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying mediump vec2 uv;\nvarying mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n, mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n, vec3 eye\n, vec4 velocity\n, float velocityScale\n, float lengthScale\n, float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nvec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\nvec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\nvec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\npos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\nvec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\nvec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\npos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nvec3 camX = vec3(1, 0, 0);\nvec3 camY = vec3(0, 0, -1);\npos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nrotateVecFromQuat(viewSpaceVert, q);\nvec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\nvec3 camY = vec3(0, 1, 0);\nvec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\npos.xyz += offset;\n#else\npos.x += vertOffset.x;\npos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\nvec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\naniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\nvertIndex.y = 1. - vertIndex.y;\n#endif\nreturn (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nattribute vec3 a_position;\nattribute vec3 a_texCoord;\nattribute vec3 a_texCoord1;\nattribute vec3 a_texCoord2;\nattribute vec4 a_color;\n#if CC_RENDER_MODE == 1\nattribute vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\nattribute vec3 a_texCoord3;\nattribute vec3 a_normal;\nattribute vec4 a_color1;\n#endif\nvec4 lpvs_main () {\nvec3 compScale = scale.xyz * a_texCoord1;\nvec4 pos = vec4(a_position, 1);\n#if CC_RENDER_MODE == 1\nvec4 velocity = vec4(a_color1.xyz, 0);\n#endif\n#if !CC_USE_WORLD_SPACE\npos = cc_matWorld * pos;\n#if CC_RENDER_MODE == 1\nvelocity = cc_matWorld * velocity;\n#endif\n#endif\n#if ROTATION_OVER_TIME_MODULE_ENABLE\nvec3 rotTmp = a_texCoord2;\nfloat mulFactor = 1.0;\nif (rotTmp.x > 10.0 * 0.5) {\nrotTmp.x -= 10.0;\nmulFactor = -1.0;\n}\nvec4 rot = vec4(rotTmp, 0.0);\nrot.w = mulFactor * sqrt(abs(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z));\n#else\n#if CC_RENDER_MODE != 4\n#if CC_RENDER_MODE == 0\nvec3 rotEuler = a_texCoord2;\n#elif CC_RENDER_MODE == 1\nvec3 rotEuler = vec3(0.);\n#else\nvec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n#endif\nvec4 rot = quaternionFromEuler(rotEuler);\n#else\nvec4 rot = quaternionFromEuler(a_texCoord2);\n#endif\n#endif\n#if CC_RENDER_MODE != 4\nvec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\ncomputeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);\n#elif CC_RENDER_MODE == 1\ncomputeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_texCoord.x);\n#elif 2\ncomputeVertPos(pos, cornerOffset, rot, compScale);\n#endif\ncolor = a_color;\n#else\nmat3 rotMat = quatToMat3(rot);\nmat3 nodeMat = quatToMat3(nodeRotation);\nrotMat = nodeMat * rotMat;\nrot = mat3ToQuat(rotMat);\nmat4 xformNoScale = matrixFromRT(rot, pos.xyz);\nmat4 xform = matFromRTS(rot, pos.xyz, compScale);\npos = xform * vec4(a_texCoord3, 1);\nvec4 normal = xformNoScale * vec4(a_normal, 0);\ncolor = a_color * a_color1;\n#endif\nuv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\npos = cc_matViewProj * pos;\nreturn pos;\n}\nvoid main() { gl_Position = lpvs_main(); }",frag:"\nprecision mediump float;\nvec4 CCFragOutput (vec4 color) {\nreturn color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\nuniform vec4 tintColor;\nvec4 add () {\nvec4 col = 2.0 * color * tintColor * texture2D(mainTexture, uv);\nreturn CCFragOutput(col);\n}\nvoid main() { gl_FragColor = add(); }"}],[{vert:"\nprecision highp float;\nuniform highp mat4 cc_matViewProj;\n#if USE_LOCAL\nuniform highp mat4 cc_matWorld;\n#endif\nattribute vec3 a_position;\nattribute vec2 a_texCoord;\nattribute vec4 a_color;\nvarying vec4 v_light;\nvarying vec2 uv0;\n#if TWO_COLORED\nattribute vec4 a_color2;\nvarying vec4 v_dark;\n#endif\nvec4 vert () {\nvec4 pos = vec4(a_position, 1);\n#if USE_LOCAL\npos = cc_matWorld * pos;\n#endif\npos = cc_matViewProj * pos;\nuv0 = a_texCoord;\nv_light = a_color;\n#if TWO_COLORED\nv_dark = a_color2;\n#endif\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",frag:"\nprecision highp float;\n#if USE_ALPHA_TEST\nuniform float alphaThreshold;\n#endif\nvoid ALPHA_TEST (in vec4 color) {\n#if USE_ALPHA_TEST\nif (color.a < alphaThreshold) discard;\n#endif\n}\nvoid ALPHA_TEST (in float alpha) {\n#if USE_ALPHA_TEST\nif (alpha < alphaThreshold) discard;\n#endif\n}\nvarying vec4 v_light;\n#if TWO_COLORED\nvarying vec4 v_dark;\n#endif\nvarying vec2 uv0;\nuniform sampler2D cc_spriteTexture;\nvec4 frag () {\nvec4 o = vec4(1, 1, 1, 1);\n#if TWO_COLORED\nvec4 texColor = vec4(1, 1, 1, 1);\ntexColor *= texture2D(cc_spriteTexture, uv0);\no.a = texColor.a * v_light.a;\no.rgb = ((texColor.a - 1.0) * v_dark.a + 1.0 - texColor.rgb) * v_dark.rgb + texColor.rgb * v_light.rgb;\n#else\no *= texture2D(cc_spriteTexture, uv0);\no *= v_light;\n#endif\nALPHA_TEST(o);\nreturn o;\n}\nvoid main() { gl_FragColor = frag(); }"}],[{vert:"\nprecision highp float;\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matProj;\nuniform highp mat4 cc_matViewProj;\nuniform highp vec4 cc_cameraPos;\n#if USE_LOCAL\nuniform highp mat4 cc_matWorld;\n#endif\n#if SAMPLE_FROM_RT\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#endif\nattribute vec3 a_position;\nattribute vec2 a_texCoord;\nattribute vec4 a_color;\nvarying vec4 color;\nvarying vec2 uv0;\nvec4 vert () {\nvec4 pos = vec4(a_position, 1);\n#if USE_LOCAL\npos = cc_matWorld * pos;\n#endif\n#if USE_PIXEL_ALIGNMENT\npos = cc_matView * pos;\npos.xyz = floor(pos.xyz);\npos = cc_matProj * pos;\n#else\npos = cc_matViewProj * pos;\n#endif\nuv0 = a_texCoord;\n#if SAMPLE_FROM_RT\nuv0 = cc_cameraPos.w > 1.0 ? vec2(uv0.x, 1.0 - uv0.y) : uv0;\n#endif\ncolor = a_color;\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",frag:"\nprecision highp float;\nvec4 CCSampleWithAlphaSeparated(sampler2D tex, vec2 uv) {\n#if CC_USE_EMBEDDED_ALPHA\nreturn vec4(texture2D(tex, uv).rgb, texture2D(tex, uv + vec2(0.0, 0.5)).r);\n#else\nreturn texture2D(tex, uv);\n#endif\n}\n#if USE_ALPHA_TEST\nuniform float alphaThreshold;\n#endif\nvoid ALPHA_TEST (in vec4 color) {\n#if USE_ALPHA_TEST\nif (color.a < alphaThreshold) discard;\n#endif\n}\nvoid ALPHA_TEST (in float alpha) {\n#if USE_ALPHA_TEST\nif (alpha < alphaThreshold) discard;\n#endif\n}\nvarying vec4 color;\n#if USE_TEXTURE\nvarying vec2 uv0;\nuniform sampler2D cc_spriteTexture;\n#endif\nvec4 frag () {\nvec4 o = vec4(1, 1, 1, 1);\n#if USE_TEXTURE\no *= CCSampleWithAlphaSeparated(cc_spriteTexture, uv0);\n#if IS_GRAY\nfloat gray  = 0.2126 * o.r + 0.7152 * o.g + 0.0722 * o.b;\no.r = o.g = o.b = gray;\n#endif\n#endif\no *= color;\nALPHA_TEST(o);\nreturn o;\n}\nvoid main() { gl_FragColor = frag(); }"}],[{vert:"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_SKINNING\nattribute vec4 a_joints;\nattribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n#if CC_USE_BAKED_ANIMATION\nattribute highp vec4 a_jointAnimInfo;\n#endif\nattribute vec4 a_matWorld0;\nattribute vec4 a_matWorld1;\nattribute vec4 a_matWorld2;\n#if CC_USE_LIGHTMAP\nattribute vec4 a_lightingMapUVParam;\n#endif\n#if CC_RECEIVE_SHADOW\nattribute vec2 a_localShadowBias;\n#endif\n#elif USE_BATCHING\nattribute float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\nattribute float a_vertexId;\nint getVertexId() {\nreturn int(a_vertexId);\n}\n#endif\n#if CC_USE_MORPH\nuniform vec4 cc_displacementWeights[15];\nuniform vec4 cc_displacementTextureInfo;\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\nreturn texture2D(tex, uv);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture2D(tex, x)),\ndecode32(texture2D(tex, y)),\ndecode32(texture2D(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nuniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nuniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nuniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nnormal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\ntangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\n#if CC_USE_BAKED_ANIMATION\nuniform highp vec4 cc_jointTextureInfo;\nuniform highp vec4 cc_jointAnimInfo;\nuniform highp sampler2D cc_jointTexture;\nvoid CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n{\n#if USE_INSTANCING\nhighp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n#else\nhighp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n#endif\ninvSize = cc_jointTextureInfo.w;\nhighp float tempY = floor(temp * invSize);\nx = floor(temp - tempY * cc_jointTextureInfo.x);\ny = (tempY + 0.5) * invSize;\n}\n#else\nuniform highp vec4 cc_joints[90];\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(3.0, i, x, y, invSize);\nvec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(12.0, i, x, y, invSize);\nvec4 v1 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\nmat4 m = skinMatrix();\nposition = m * position;\nnormal = (m * vec4(normal, 0.0)).xyz;\ntangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n}\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\nIn.position = vec4(a_position, 1.0);\nIn.normal = a_normal;\nIn.tangent = a_tangent;\n#if CC_USE_MORPH\napplyMorph(In.position, In.normal, In.tangent);\n#endif\n#if CC_USE_SKINNING\nCCSkin(In.position, In.normal, In.tangent);\n#endif\n}\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matProj;\nuniform highp vec4 cc_cameraPos;\nuniform mediump vec4 cc_fogBase;\nuniform mediump vec4 cc_fogAdd;\n#if !USE_INSTANCING\n#if USE_BATCHING\nuniform highp mat4 cc_matWorlds[10];\n#else\nuniform highp mat4 cc_matWorld;\nuniform highp mat4 cc_matWorldIT;\nuniform highp vec4 cc_lightingMapUVParam;\nuniform highp vec4 cc_localShadowBias;\n#endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n#if USE_INSTANCING\nmatWorld = mat4(\nvec4(a_matWorld0.xyz, 0.0),\nvec4(a_matWorld1.xyz, 0.0),\nvec4(a_matWorld2.xyz, 0.0),\nvec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n);\nmatWorldIT = matWorld;\n#elif USE_BATCHING\nmatWorld = cc_matWorlds[int(a_dyn_batch_id)];\nmatWorldIT = matWorld;\n#else\nmatWorld = cc_matWorld;\nmatWorldIT = cc_matWorldIT;\n#endif\n}\nuniform vec4 tilingOffset;\nfloat LinearFog(vec4 pos) {\nvec4 wPos = pos;\nfloat cam_dis = distance(cc_cameraPos, wPos);\nfloat fogStart = cc_fogBase.x;\nfloat fogEnd = cc_fogBase.y;\nreturn clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * fogDensity);\nreturn f;\n}\nfloat ExpSquaredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\nreturn f;\n}\nfloat LayeredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat _FogTop = cc_fogAdd.x;\nfloat _FogRange = cc_fogAdd.y;\nvec3 camWorldProj = cc_cameraPos.xyz;\ncamWorldProj.y = 0.;\nvec3 worldPosProj = wPos.xyz;\nworldPosProj.y = 0.;\nfloat fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\nfloat fDeltaY, fDensityIntegral;\nif (cc_cameraPos.y > _FogTop) {\nif (wPos.y < _FogTop) {\nfDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\nfDensityIntegral = fDeltaY * fDeltaY * 0.5;\n} else {\nfDeltaY = 0.;\nfDensityIntegral = 0.;\n}\n} else {\nif (wPos.y < _FogTop) {\nfloat fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfloat fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\nfDeltaY = abs(fDeltaA - fDeltaB);\nfDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n} else {\nfDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n}\n}\nfloat fDensity;\nif (fDeltaY != 0.) {\nfDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n} else {\nfDensity = 0.;\n}\nfloat f = exp(-fDensity);\nreturn f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\nfactor = LinearFog(pos);\n#elif CC_USE_FOG == 1\nfactor = ExpFog(pos);\n#elif CC_USE_FOG == 2\nfactor = ExpSquaredFog(pos);\n#elif CC_USE_FOG == 3\nfactor = LayeredFog(pos);\n#else\nfactor = 1.0;\n#endif\n}\n#if !CC_USE_ACCURATE_FOG\nvarying float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\nCC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\nvarying highp vec4 v_shadowPos;\nuniform highp mat4 cc_matLightViewProj;\nuniform mediump vec4 cc_shadowWHPBInfo;\nuniform mediump vec4 cc_shadowLPNNInfo;\n#if CC_RECEIVE_SHADOW\nuniform highp sampler2D cc_shadowMap;\nuniform highp sampler2D cc_spotLightingMap;\n#endif\n#if CC_RECEIVE_SHADOW\nvec2 CCGetShadowBias()\n{\n#if USE_INSTANCING\nreturn vec2(a_localShadowBias.x + cc_shadowWHPBInfo.w, a_localShadowBias.y + cc_shadowLPNNInfo.z);\n#elif !USE_BATCHING\nreturn vec2(cc_localShadowBias.x + cc_shadowWHPBInfo.w, cc_localShadowBias.y + cc_shadowLPNNInfo.z);\n#else\nreturn vec2(cc_shadowWHPBInfo.w, cc_shadowLPNNInfo.z);\n#endif\n}\n#endif\n#if USE_VERTEX_COLOR\nattribute vec4 a_color;\nvarying lowp vec4 v_color;\n#endif\nvarying vec3 v_position;\nvarying mediump vec3 v_normal;\nvarying vec2 v_uv;\n#if HAS_SECOND_UV\nvarying mediump vec2 v_uv1;\n#endif\n#if CC_RECEIVE_SHADOW\nvarying mediump vec2 v_shadowBias;\n#endif\n#if USE_NORMAL_MAP\nvarying mediump vec4 v_tangent;\n#endif\n#if HAS_SECOND_UV || CC_USE_LIGHTMAP\nattribute vec2 a_texCoord1;\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nvarying vec3 v_luv;\nvoid CCLightingMapCaclUV()\n{\n#if !USE_INSTANCING\nv_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.z;\nv_luv.z = cc_lightingMapUVParam.w;\n#else\nv_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.z;\nv_luv.z = a_lightingMapUVParam.w;\n#endif\n}\n#endif\nvoid main () {\nStandardVertInput In;\nCCVertInput(In);\nmat4 matWorld, matWorldIT;\nCCGetWorldMatrixFull(matWorld, matWorldIT);\nvec4 pos = matWorld * In.position;\nv_position = pos.xyz;\nv_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n#if CC_RECEIVE_SHADOW\nv_shadowBias = CCGetShadowBias();\n#endif\n#if USE_TWOSIDE\nvec3 viewDirect = normalize(cc_cameraPos.xyz - v_position);\nv_normal *= dot(v_normal, viewDirect) < 0.0 ? -1.0 : 1.0;\n#endif\n#if USE_NORMAL_MAP\nv_tangent.xyz = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\nv_tangent.w = In.tangent.w;\n#endif\nv_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n#if SAMPLE_FROM_RT\nv_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n#endif\n#if HAS_SECOND_UV\nv_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n#if SAMPLE_FROM_RT\nv_uv1 = cc_cameraPos.w > 1.0 ? vec2(v_uv1.x, 1.0 - v_uv1.y) : v_uv1;\n#endif\n#endif\n#if USE_VERTEX_COLOR\nv_color = a_color;\n#endif\nCC_TRANSFER_FOG(pos);\nv_shadowPos = cc_matLightViewProj * pos;\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nCCLightingMapCaclUV();\n#endif\ngl_Position = cc_matProj * (cc_matView * matWorld) * In.position;\n}",frag:"\n#ifdef GL_EXT_draw_buffers\n#extension GL_EXT_draw_buffers: enable\n#endif\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives: enable\n#endif\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod: enable\n#endif\nprecision highp float;\nuniform highp mat4 cc_matView;\nuniform highp vec4 cc_cameraPos;\nuniform mediump vec4 cc_mainLitDir;\nuniform mediump vec4 cc_mainLitColor;\nuniform mediump vec4 cc_ambientSky;\nuniform mediump vec4 cc_ambientGround;\nuniform mediump vec4 cc_fogColor;\nuniform mediump vec4 cc_fogBase;\nuniform mediump vec4 cc_fogAdd;\nuniform mediump vec4 cc_nearFar;\nuniform mediump vec4 cc_viewPort;\nuniform vec4 albedo;\nuniform vec4 albedoScaleAndCutoff;\nuniform vec4 pbrParams;\nuniform vec4 emissive;\nuniform vec4 emissiveScaleParam;\nfloat LinearFog(vec4 pos) {\nvec4 wPos = pos;\nfloat cam_dis = distance(cc_cameraPos, wPos);\nfloat fogStart = cc_fogBase.x;\nfloat fogEnd = cc_fogBase.y;\nreturn clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * fogDensity);\nreturn f;\n}\nfloat ExpSquaredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\nreturn f;\n}\nfloat LayeredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat _FogTop = cc_fogAdd.x;\nfloat _FogRange = cc_fogAdd.y;\nvec3 camWorldProj = cc_cameraPos.xyz;\ncamWorldProj.y = 0.;\nvec3 worldPosProj = wPos.xyz;\nworldPosProj.y = 0.;\nfloat fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\nfloat fDeltaY, fDensityIntegral;\nif (cc_cameraPos.y > _FogTop) {\nif (wPos.y < _FogTop) {\nfDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\nfDensityIntegral = fDeltaY * fDeltaY * 0.5;\n} else {\nfDeltaY = 0.;\nfDensityIntegral = 0.;\n}\n} else {\nif (wPos.y < _FogTop) {\nfloat fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfloat fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\nfDeltaY = abs(fDeltaA - fDeltaB);\nfDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n} else {\nfDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n}\n}\nfloat fDensity;\nif (fDeltaY != 0.) {\nfDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n} else {\nfDensity = 0.;\n}\nfloat f = exp(-fDensity);\nreturn f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\nfactor = LinearFog(pos);\n#elif CC_USE_FOG == 1\nfactor = ExpFog(pos);\n#elif CC_USE_FOG == 2\nfactor = ExpSquaredFog(pos);\n#elif CC_USE_FOG == 3\nfactor = LayeredFog(pos);\n#else\nfactor = 1.0;\n#endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\ncolor = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if !CC_USE_ACCURATE_FOG\nvarying float v_fog_factor;\n#endif\nvoid CC_APPLY_FOG(inout vec4 color) {\n#if !CC_USE_ACCURATE_FOG\nCC_APPLY_FOG_BASE(color, v_fog_factor);\n#endif\n}\nvoid CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n#if CC_USE_ACCURATE_FOG\nfloat factor;\nCC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n#else\nfloat factor = v_fog_factor;\n#endif\nCC_APPLY_FOG_BASE(color, factor);\n}\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nuniform highp mat4 cc_matLightView;\nuniform highp vec4 cc_shadowInvProjDepthInfo;\nuniform highp vec4 cc_shadowProjDepthInfo;\nuniform highp vec4 cc_shadowProjInfo;\nuniform mediump vec4 cc_shadowNFLSInfo;\nuniform mediump vec4 cc_shadowWHPBInfo;\nuniform mediump vec4 cc_shadowLPNNInfo;\nhighp float unpackHighpData (float mainPart, float modPart) {\nhighp float data = mainPart;\nreturn data + modPart;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data) {\nmainPart = fract(data);\nmodPart = data - mainPart;\n}\nhighp float unpackHighpData (float mainPart, float modPart, const float modValue) {\nhighp float data = mainPart * modValue;\nreturn data + modPart * modValue;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\nhighp float divide = data / modValue;\nmainPart = floor(divide);\nmodPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\nhighp vec2 data = mainPart;\nreturn data + modPart;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\nmainPart = fract(data);\nmodPart = data - mainPart;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\nhighp vec2 data = mainPart * modValue;\nreturn data + modPart * modValue;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\nhighp vec2 divide = data / modValue;\nmainPart = floor(divide);\nmodPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\nhighp vec3 data = mainPart;\nreturn data + modPart;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\nmainPart = fract(data);\nmodPart = data - mainPart;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\nhighp vec3 data = mainPart * modValue;\nreturn data + modPart * modValue;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\nhighp vec3 divide = data / modValue;\nmainPart = floor(divide);\nmodPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\nhighp vec4 data = mainPart;\nreturn data + modPart;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\nmainPart = fract(data);\nmodPart = data - mainPart;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\nhighp vec4 data = mainPart * modValue;\nreturn data + modPart * modValue;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\nhighp vec4 divide = data / modValue;\nmainPart = floor(divide);\nmodPart = (data - mainPart * modValue) / modValue;\n}\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\nfloat dist = length(viewPos);\nreturn (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\nvec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\nreturn CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\nuniform highp sampler2D cc_shadowMap;\nuniform highp sampler2D cc_spotLightingMap;\nvec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias)\n{\nvec4 newShadowPos = shadowPos;\nif(normalBias > EPSILON_LOWP)\n{\nvec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);\nif(viewNormal.z < 0.1)\nnewShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n}\nreturn newShadowPos;\n}\nvec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n{\nvec3 viewSpacePos;\nviewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\nviewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;\nviewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\nvec4 clipSpacePos;\nclipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\nclipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\nif (cc_shadowNFLSInfo.z > EPSILON) {\nclipSpacePos.z = CCGetLinearDepthFromViewSpace(viewSpacePos.xyz);\nclipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n}\nreturn clipSpacePos;\n}\nvec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)\n{\nfloat coeffA = cc_shadowProjDepthInfo.x;\nfloat coeffB = cc_shadowProjDepthInfo.y;\nfloat viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\nviewSpacePos_z += viewspaceDepthBias;\nvec4 result = shadowPos;\nresult.z = viewSpacePos_z * coeffA + coeffB;\nreturn result;\n}\nfloat CCGetShadowFactorHard (vec4 shadowPos, float bias) {\nvec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nif (cc_shadowLPNNInfo.y > EPSILON) {\nclosestDepth = dot(texture2D(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n} else {\nclosestDepth = texture2D(cc_shadowMap, clipPos.xy).x;\n}\nshadow = step(clipPos.z, closestDepth);\nreturn shadow;\n}\nfloat CCGetShadowFactorSoft (vec4 shadowPos, float bias) {\nvec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetDepth = clipPos.z;\nvec2 mapSize = cc_shadowWHPBInfo.xy;\nvec2 oneTap = 1.0 / mapSize;\nvec2 clipPos_offset = clipPos.xy + oneTap;\nfloat block0, block1, block2, block3;\nif (cc_shadowLPNNInfo.y > EPSILON) {\nblock0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n} else {\nblock0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\nblock1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\nblock2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\nblock3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n}\nfloat coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block2, block3, coefX);\nfloat coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;\nreturn mix(resultX, resultY, coefY);\n}\nfloat CCGetShadowFactorSoft2X (vec4 shadowPos, float bias) {\nvec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetDepth = clipPos.z;\nvec2 mapSize = cc_shadowWHPBInfo.xy;\nvec2 oneTap = 1.0 / mapSize;\nfloat clipPos_offset_L = clipPos.x - oneTap.x;\nfloat clipPos_offset_R = clipPos.x + oneTap.x;\nfloat clipPos_offset_U = clipPos.y - oneTap.y;\nfloat clipPos_offset_D = clipPos.y + oneTap.y;\nfloat block0, block1, block2, block3, block4, block5, block6, block7, block8;\nif (cc_shadowLPNNInfo.y > EPSILON) {\nblock0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock4 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock5 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock6 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock7 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock8 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n} else {\nblock0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\nblock1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\nblock2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\nblock3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\nblock4 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\nblock5 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\nblock6 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\nblock7 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\nblock8 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n}\nfloat coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\nfloat coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\nfloat shadow = 0.0;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block3, block4, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block1, block2, coefX);\nresultY = mix(block4, block5, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block3, block4, coefX);\nresultY = mix(block6, block7, coefX);\nshadow += mix(resultX, resultY, coefY);\nresultX = mix(block4, block5, coefX);\nresultY = mix(block7, block8, coefX);\nshadow += mix(resultX, resultY, coefY);\nreturn shadow * 0.25;\n}\nfloat CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos, float bias) {\nvec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nfloat depth = clipPos.z;\nif (cc_shadowLPNNInfo.y > EPSILON) {\nclosestDepth = dot(texture2D(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n} else {\nclosestDepth = texture2D(cc_spotLightingMap, clipPos.xy).x;\n}\nshadow = step(depth, closestDepth);\nreturn shadow;\n}\nfloat CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos, float bias) {\nvec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > EPSILON) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nvec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\nvec2 clipPos_offset = clipPos.xy + oneTap;\nfloat block0, block1, block2, block3;\nif (cc_shadowLPNNInfo.y > EPSILON) {\nblock0 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock1 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock2 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock3 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n} else {\nblock0 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\nblock1 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)).x);\nblock2 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)).x);\nblock3 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n}\nfloat coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block2, block3, coefX);\nfloat coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\nreturn mix(resultX, resultY, coefY);\n}\nfloat CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos, float bias) {\nvec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > EPSILON) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nvec2 mapSize = cc_shadowWHPBInfo.xy;\nvec2 oneTap = 1.0 / mapSize;\nfloat clipPos_offset_L = clipPos.x - oneTap.x;\nfloat clipPos_offset_R = clipPos.x + oneTap.x;\nfloat clipPos_offset_U = clipPos.y - oneTap.y;\nfloat clipPos_offset_D = clipPos.y + oneTap.y;\nfloat block0, block1, block2, block3, block4, block5, block6, block7, block8;\nif (cc_shadowLPNNInfo.y > EPSILON) {\nblock0 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock1 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock2 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock3 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock4 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock5 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock6 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock7 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock8 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n} else {\nblock0 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\nblock1 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)).x);\nblock2 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\nblock3 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)).x);\nblock4 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\nblock5 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)).x);\nblock6 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\nblock7 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)).x);\nblock8 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n}\nfloat coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\nfloat coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\nfloat shadow = 0.0;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block3, block4, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block1, block2, coefX);\nresultY = mix(block4, block5, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block3, block4, coefX);\nresultY = mix(block6, block7, coefX);\nshadow += mix(resultX, resultY, coefY);\nresultX = mix(block4, block5, coefX);\nresultY = mix(block7, block8, coefX);\nshadow += mix(resultX, resultY, coefY);\nreturn shadow * 0.25;\n}\nfloat CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n{\nfloat pcf = cc_shadowWHPBInfo.z;\nif (pcf > 1.9) {\nreturn CCGetSpotLightShadowFactorSoft2X(shadowPos, worldPos, shadowBias.x);\n}else if (pcf > 0.9) {\nreturn CCGetSpotLightShadowFactorSoft(shadowPos, worldPos, shadowBias.x);\n}else {\nreturn CCGetSpotLightShadowFactorHard(shadowPos, worldPos, shadowBias.x);\n}\n}\nfloat CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias)\n{\nfloat realtimeShadow = 1.0;\nvec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y);\nfloat pcf = cc_shadowWHPBInfo.z;\nif (pcf > 1.9) {\nrealtimeShadow =  CCGetShadowFactorSoft2X(pos, shadowBias.x);\n}else if (pcf > 0.9) {\nrealtimeShadow = CCGetShadowFactorSoft(pos, shadowBias.x);\n}else {\nrealtimeShadow = CCGetShadowFactorHard(pos, shadowBias.x);\n}\nreturn mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n}\n#endif\n#if CC_USE_IBL\nuniform samplerCube cc_environment;\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n#ifdef GL_EXT_shader_texture_lod\nreturn texture2DLodEXT(tex, coord, lod);\n#else\nreturn texture2D(tex, coord, lod);\n#endif\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n#ifdef GL_EXT_shader_texture_lod\nreturn textureCubeLodEXT(tex, coord, lod);\n#else\nreturn textureCube(tex, coord, lod);\n#endif\n}\nvec3 unpackRGBE (vec4 rgbe) {\nreturn rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n}\n#if CC_USE_DIFFUSEMAP\nuniform samplerCube cc_diffuseMap;\n#endif\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\nvec3 NxH = cross(N, H);\nfloat OneMinusNoHSqr = dot(NxH, NxH);\nfloat a = roughness * roughness;\nfloat n = NoH * a;\nfloat p = a / (OneMinusNoHSqr + n * n);\nreturn p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\nreturn (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\nconst vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\nconst vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\nvec4 r = roughness * c0 + c1;\nfloat a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\nvec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\nAB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\nreturn specular * AB.x + AB.y;\n}\n#if USE_REFLECTION_DENOISE\nvec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n#if CC_USE_IBL\nfloat mip = roughness * mipCount;\nfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\nfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\nvec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);\nvec4 filtered = textureCube(cc_environment, R);\n#if CC_USE_IBL == 2\nbiased.rgb = unpackRGBE(biased);\nfiltered.rgb = unpackRGBE(filtered);\n#else\nbiased.rgb = SRGBToLinear(biased.rgb);\nfiltered.rgb = SRGBToLinear(filtered.rgb);\n#endif\nreturn mix(biased.rgb, filtered.rgb, denoiseIntensity);\n#else\nreturn vec3(0.0, 0.0, 0.0);\n#endif\n}\n#endif\nstruct StandardSurface {\nvec4 albedo;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nvec3 position, position_fract_part;\n#else\nvec3 position;\n#endif\nvec3 normal;\nvec3 emissive;\nvec3 lightmap;\nfloat lightmap_test;\nfloat roughness;\nfloat metallic;\nfloat occlusion;\nfloat specularIntensity;\n#if CC_RECEIVE_SHADOW\nvec2 shadowBias;\n#endif\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.08 * s.specularIntensity), s.albedo.rgb, s.metallic);\nvec3 position;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nposition = unpackHighpData(s.position, s.position_fract_part);\n#else\nposition = s.position;\n#endif\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - position);\nfloat NV = max(abs(dot(N, V)), 0.0);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 L = normalize(-cc_mainLitDir.xyz);\nvec3 H = normalize(L + V);\nfloat NH = max(dot(N, H), 0.0);\nfloat NL = max(dot(N, L), 0.0);\nvec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\nvec3 diffuseContrib = diffuse / PI;\nvec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\nvec3 dirlightContrib = (diffuseContrib + specularContrib);\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW\nif (NL > 0.0 && cc_mainLitDir.w > 0.0) {\nshadow = CCShadowFactorBase(shadowPos, N, s.shadowBias);\n}\n#endif\ndirlightContrib *= shadow;\nfinalColor *= dirlightContrib;\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nif (s.lightmap_test > EPSILON_LOWP) {\nfinalColor = diffuse * s.lightmap.rgb * shadow;\n}\n#endif\nfloat fAmb = 0.5 - N.y * 0.5;\nvec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n#if CC_USE_IBL\n#if CC_USE_DIFFUSEMAP\nvec4 diffuseMap = textureCube(cc_diffuseMap, N);\n#if CC_USE_DIFFUSEMAP == 2\nambDiff = unpackRGBE(diffuseMap);\n#else\nambDiff = SRGBToLinear(diffuseMap.rgb);\n#endif\n#endif\nvec3 R = normalize(reflect(-V, N));\n#if USE_REFLECTION_DENOISE\nvec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);\n#else\nvec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n#if CC_USE_IBL == 2\nvec3 env = unpackRGBE(envmap);\n#else\nvec3 env = SRGBToLinear(envmap.rgb);\n#endif\n#endif\nfinalColor += env * cc_ambientSky.w * specular * s.occlusion;\n#endif\nfinalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;\nfinalColor += s.emissive;\nreturn vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\ncolor = min(color, vec3(8.0));\nconst float A = 2.51;\nconst float B = 0.03;\nconst float C = 2.43;\nconst float D = 0.59;\nconst float E = 0.14;\nreturn (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n#if CC_USE_HDR\ncolor.rgb = ACESToneMap(color.rgb);\n#endif\ncolor.rgb = sqrt(color.rgb);\nreturn color;\n}\nvarying highp vec4 v_shadowPos;\n#if CC_RECEIVE_SHADOW\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nvarying vec3 v_luv;\nuniform sampler2D cc_lightingMap;\n#endif\nvarying vec3 v_position;\nvarying vec2 v_uv;\n#if HAS_SECOND_UV\nvarying mediump vec2 v_uv1;\n#endif\nvarying mediump vec3 v_normal;\n#if CC_RECEIVE_SHADOW\nvarying mediump vec2 v_shadowBias;\n#endif\n#if USE_VERTEX_COLOR\nvarying lowp vec4 v_color;\n#endif\n#if USE_ALBEDO_MAP\nuniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\nvarying mediump vec4 v_tangent;\nuniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\nuniform sampler2D pbrMap;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\nuniform sampler2D metallicRoughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\nuniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\nuniform sampler2D emissiveMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out StandardSurface s) {\nvec4 baseColor = albedo;\n#if USE_VERTEX_COLOR\nbaseColor.rgb *= SRGBToLinear(v_color.rgb);\nbaseColor.a *= v_color.a;\n#endif\n#if USE_ALBEDO_MAP\nvec4 texColor = texture2D(albedoMap, ALBEDO_UV);\ntexColor.rgb = SRGBToLinear(texColor.rgb);\nbaseColor *= texColor;\n#endif\ns.albedo = baseColor;\ns.albedo.rgb *= albedoScaleAndCutoff.xyz;\n#if USE_ALPHA_TEST\nif (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nvec4 lightColor = texture2D(cc_lightingMap, v_luv.xy);\ns.lightmap = lightColor.xyz * v_luv.z;\ns.lightmap_test = v_luv.z;\n#endif\ns.normal = v_normal;\n#if CC_RECEIVE_SHADOW\ns.shadowBias = v_shadowBias;\n#endif\n#if USE_NORMAL_MAP\nvec3 nmmp = texture2D(normalMap, NORMAL_UV).xyz - vec3(0.5);\nvec3 bitangent = cross(v_normal, v_tangent.xyz) * v_tangent.w;\ns.normal =\n(nmmp.x * emissiveScaleParam.w) * normalize(v_tangent.xyz) +\n(nmmp.y * emissiveScaleParam.w) * normalize(bitangent) +\nnmmp.z * normalize(s.normal);\n#endif\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\npackHighpData(s.position, s.position_fract_part, v_position);\n#else\ns.position = v_position;\n#endif\nvec4 pbr = pbrParams;\n#if USE_PBR_MAP\nvec4 res = texture2D(pbrMap, PBR_UV);\npbr.x *= res.r;\npbr.y *= res.g;\npbr.z *= res.b;\npbr.w *= res.a;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\nvec4 metallicRoughness = texture2D(metallicRoughnessMap, PBR_UV);\npbr.z *= metallicRoughness.b;\npbr.y *= metallicRoughness.g;\n#endif\n#if USE_OCCLUSION_MAP\npbr.x *= texture2D(occlusionMap, PBR_UV).r;\n#endif\ns.occlusion = pbr.x;\ns.roughness = pbr.y;\ns.specularIntensity = 0.5;\ns.metallic = pbr.z;\ns.emissive = emissive.rgb * emissiveScaleParam.xyz;\n#if USE_EMISSIVE_MAP\ns.emissive *= SRGBToLinear(texture2D(emissiveMap, EMISSIVE_UV).rgb);\n#endif\n}\n#if CC_FORWARD_ADD\n#if CC_PIPELINE_TYPE == 0\n#define LIGHTS_PER_PASS 1\n#else\n#define LIGHTS_PER_PASS 10\n#endif\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\nuniform highp vec4 cc_lightPos[LIGHTS_PER_PASS];\nuniform vec4 cc_lightColor[LIGHTS_PER_PASS];\nuniform vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\nuniform vec4 cc_lightDir[LIGHTS_PER_PASS];\n#endif\nfloat SmoothDistAtt (float distSqr, float invSqrAttRadius) {\nfloat factor = distSqr * invSqrAttRadius;\nfloat smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\nreturn smoothFactor * smoothFactor;\n}\nfloat GetDistAtt (float distSqr, float invSqrAttRadius) {\nfloat attenuation = 1.0 / max(distSqr, 0.01*0.01);\nattenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\nreturn attenuation;\n}\nfloat GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\nfloat cd = dot(litDir, L);\nfloat attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\nreturn (attenuation * attenuation);\n}\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\nvec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\nvec3 position;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nposition = unpackHighpData(s.position, s.position_fract_part);\n#else\nposition = s.position;\n#endif\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 diffuseContrib = diffuse / PI;\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - position);\nfloat NV = max(abs(dot(N, V)), 0.0);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 finalColor = vec3(0.0);\nint numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\nfor (int i = 0; i < LIGHTS_PER_PASS; i++) {\nif (i >= numLights) break;\nvec3 SLU = cc_lightPos[i].xyz - position;\nvec3 SL = normalize(SLU);\nvec3 SH = normalize(SL + V);\nfloat SNL = max(dot(N, SL), 0.0);\nfloat SNH = max(dot(N, SH), 0.0);\nfloat distSqr = dot(SLU, SLU);\nfloat litRadius = cc_lightSizeRangeAngle[i].x;\nfloat litRadiusSqr = litRadius * litRadius;\nfloat illum = litRadiusSqr / max(litRadiusSqr, distSqr);\nfloat attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\nattRadiusSqrInv *= attRadiusSqrInv;\nfloat att = GetDistAtt(distSqr, attRadiusSqrInv);\nvec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\nif (cc_lightPos[i].w > 0.0) {\nfloat cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\nfloat cosOuter = cc_lightSizeRangeAngle[i].z;\nfloat litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\nfloat litAngleOffset = -cosOuter * litAngleScale;\natt *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n}\nvec3 lightColor = cc_lightColor[i].rgb;\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW\nif (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\nshadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n}\n#endif\nlightColor *= shadow;\nfinalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n}\nreturn vec4(finalColor, 0.0);\n}\n#endif\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\nreadonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };\nreadonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };\nreadonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };\nstruct CCLight\n{\nvec4 cc_lightPos;\nvec4 cc_lightColor;\nvec4 cc_lightSizeRangeAngle;\nvec4 cc_lightDir;\n};\nstruct Cluster\n{\nvec3 minBounds;\nvec3 maxBounds;\n};\nstruct LightGrid\n{\nuint offset;\nuint ccLights;\n};\nCCLight getCCLight(uint i)\n{\nCCLight light;\nlight.cc_lightPos = b_ccLights[4u * i + 0u];\nlight.cc_lightColor = b_ccLights[4u * i + 1u];\nlight.cc_lightSizeRangeAngle = b_ccLights[4u * i + 2u];\nlight.cc_lightDir = b_ccLights[4u * i + 3u];\nreturn light;\n}\nLightGrid getLightGrid(uint cluster)\n{\nuvec4 gridvec = b_clusterLightGrid[cluster];\nLightGrid grid;\ngrid.offset = gridvec.x;\ngrid.ccLights = gridvec.y;\nreturn grid;\n}\nuint getGridLightIndex(uint start, uint offset)\n{\nreturn b_clusterLightIndices[start + offset];\n}\nuint getClusterZIndex(vec4 worldPos)\n{\nfloat scale = float(24) / log(cc_nearFar.y / cc_nearFar.x);\nfloat bias = -(float(24) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));\nfloat eyeDepth = -(cc_matView * worldPos).z;\nuint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));\nreturn zIndex;\n}\nuint getClusterIndex(vec4 fragCoord, vec4 worldPos)\n{\nuint zIndex = getClusterZIndex(worldPos);\nfloat clusterSizeX = ceil(cc_viewPort.z / float(16));\nfloat clusterSizeY = ceil(cc_viewPort.w / float(8));\nuvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);\nuint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;\nreturn cluster;\n}\nvec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 diffuseContrib = diffuse / PI;\nvec3 position;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nposition = unpackHighpData(s.position, s.position_fract_part);\n#else\nposition = s.position;\n#endif\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - position);\nfloat NV = max(abs(dot(N, V)), 0.001);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 finalColor = vec3(0.0);\nuint cluster = getClusterIndex(gl_FragCoord, vec4(position, 1.0));\nLightGrid grid = getLightGrid(cluster);\nuint numLights = grid.ccLights;\nfor (uint i = 0u; i < 100u; i++) {\nif (i >= numLights) break;\nuint lightIndex = getGridLightIndex(grid.offset, i);\nCCLight light = getCCLight(lightIndex);\nvec3 SLU = light.cc_lightPos.xyz - position;\nvec3 SL = normalize(SLU);\nvec3 SH = normalize(SL + V);\nfloat SNL = max(dot(N, SL), 0.001);\nfloat SNH = max(dot(N, SH), 0.0);\nfloat distSqr = dot(SLU, SLU);\nfloat litRadius = light.cc_lightSizeRangeAngle.x;\nfloat litRadiusSqr = litRadius * litRadius;\nfloat illum = PI * (litRadiusSqr / max(litRadiusSqr , distSqr));\nfloat attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);\nattRadiusSqrInv *= attRadiusSqrInv;\nfloat att = GetDistAtt(distSqr, attRadiusSqrInv);\nvec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\nif (light.cc_lightPos.w > 0.0) {\nfloat cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);\nfloat cosOuter = light.cc_lightSizeRangeAngle.z;\nfloat litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\nfloat litAngleOffset = -cosOuter * litAngleScale;\natt *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);\n}\nvec3 lightColor = light.cc_lightColor.rgb;\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW\nif (light.cc_lightPos.w > 0.0) {\nshadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n}\n#endif\nlightColor *= shadow;\nfinalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);\n}\nreturn vec4(finalColor, 0.0);\n}\n#endif\nvoid main () {\nStandardSurface s; surf(s);\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\nvec4 color = CCClusterShadingAdditive(s, v_shadowPos);\n#else\nvec4 color = CCStandardShadingAdditive(s, v_shadowPos);\n#endif\ngl_FragData[0] = CCFragOutput(color);\n}\n#elif (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\nvoid main () {\nStandardSurface s; surf(s);\nvec4 color = CCStandardShadingBase(s, v_shadowPos);\nCC_APPLY_FOG(color, s.position.xyz);\ngl_FragData[0] = CCFragOutput(color);\n}\n#elif CC_PIPELINE_TYPE == 1\nvec2 signNotZero(vec2 v) {\nreturn vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n}\nvec2 float32x3_to_oct(in vec3 v) {\nvec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));\nreturn (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;\n}\nvoid main () {\nStandardSurface s; surf(s);\ngl_FragData[0] = s.albedo;\ngl_FragData[1] = vec4(float32x3_to_oct(s.normal), s.roughness, s.metallic);\ngl_FragData[2] = vec4(s.emissive, s.occlusion);\n}\n#endif"},{vert:"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_SKINNING\nattribute vec4 a_joints;\nattribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n#if CC_USE_BAKED_ANIMATION\nattribute highp vec4 a_jointAnimInfo;\n#endif\nattribute vec4 a_matWorld0;\nattribute vec4 a_matWorld1;\nattribute vec4 a_matWorld2;\n#if CC_USE_LIGHTMAP\nattribute vec4 a_lightingMapUVParam;\n#endif\n#if CC_RECEIVE_SHADOW\nattribute vec2 a_localShadowBias;\n#endif\n#elif USE_BATCHING\nattribute float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\nattribute float a_vertexId;\nint getVertexId() {\nreturn int(a_vertexId);\n}\n#endif\n#if CC_USE_MORPH\nuniform vec4 cc_displacementWeights[15];\nuniform vec4 cc_displacementTextureInfo;\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\nreturn texture2D(tex, uv);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture2D(tex, x)),\ndecode32(texture2D(tex, y)),\ndecode32(texture2D(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nuniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nuniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nuniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nnormal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\ntangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\n#if CC_USE_BAKED_ANIMATION\nuniform highp vec4 cc_jointTextureInfo;\nuniform highp vec4 cc_jointAnimInfo;\nuniform highp sampler2D cc_jointTexture;\nvoid CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n{\n#if USE_INSTANCING\nhighp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n#else\nhighp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n#endif\ninvSize = cc_jointTextureInfo.w;\nhighp float tempY = floor(temp * invSize);\nx = floor(temp - tempY * cc_jointTextureInfo.x);\ny = (tempY + 0.5) * invSize;\n}\n#else\nuniform highp vec4 cc_joints[90];\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(3.0, i, x, y, invSize);\nvec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(12.0, i, x, y, invSize);\nvec4 v1 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\nmat4 m = skinMatrix();\nposition = m * position;\nnormal = (m * vec4(normal, 0.0)).xyz;\ntangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n}\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\nIn.position = vec4(a_position, 1.0);\nIn.normal = a_normal;\nIn.tangent = a_tangent;\n#if CC_USE_MORPH\napplyMorph(In.position, In.normal, In.tangent);\n#endif\n#if CC_USE_SKINNING\nCCSkin(In.position, In.normal, In.tangent);\n#endif\n}\n#if !USE_INSTANCING\n#if USE_BATCHING\nuniform highp mat4 cc_matWorlds[10];\n#else\nuniform highp mat4 cc_matWorld;\nuniform highp mat4 cc_matWorldIT;\n#endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n#if USE_INSTANCING\nmatWorld = mat4(\nvec4(a_matWorld0.xyz, 0.0),\nvec4(a_matWorld1.xyz, 0.0),\nvec4(a_matWorld2.xyz, 0.0),\nvec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n);\nmatWorldIT = matWorld;\n#elif USE_BATCHING\nmatWorld = cc_matWorlds[int(a_dyn_batch_id)];\nmatWorldIT = matWorld;\n#else\nmatWorld = cc_matWorld;\nmatWorldIT = cc_matWorldIT;\n#endif\n}\nuniform vec4 tilingOffset;\nuniform highp mat4 cc_matLightViewProj;\n#if HAS_SECOND_UV || CC_USE_LIGHTMAP\nattribute vec2 a_texCoord1;\n#endif\nvarying vec2 v_uv;\n#if HAS_SECOND_UV\nvarying vec2 v_uv1;\n#endif\nvarying vec4 v_worldPos;\nvarying float v_clip_depth;\nvec4 vert () {\nStandardVertInput In;\nCCVertInput(In);\nmat4 matWorld, matWorldIT;\nCCGetWorldMatrixFull(matWorld, matWorldIT);\nv_worldPos = matWorld * In.position;\nvec4 clipPos = cc_matLightViewProj * v_worldPos;\nv_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n#if HAS_SECOND_UV\nv_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n#endif\nv_clip_depth = clipPos.z / clipPos.w * 0.5 + 0.5;\nreturn clipPos;\n}\nvoid main() { gl_Position = vert(); }",frag:"\nprecision highp float;\nuniform vec4 albedo;\nuniform vec4 albedoScaleAndCutoff;\nvec4 packDepthToRGBA (float depth) {\nvec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\nret = fract(ret);\nret -= vec4(ret.yzw, 0.0) / 255.0;\nreturn ret;\n}\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nuniform highp mat4 cc_matLightView;\nuniform mediump vec4 cc_shadowNFLSInfo;\nuniform mediump vec4 cc_shadowLPNNInfo;\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\nfloat dist = length(viewPos);\nreturn (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\nvec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\nreturn CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\nuniform highp sampler2D cc_shadowMap;\nuniform highp sampler2D cc_spotLightingMap;\n#endif\nvarying vec2 v_uv;\n#if HAS_SECOND_UV\nvarying vec2 v_uv1;\n#endif\nvarying vec4 v_worldPos;\nvarying float v_clip_depth;\n#if USE_ALBEDO_MAP\nuniform sampler2D albedoMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvec4 frag () {\nvec4 baseColor = albedo;\n#if USE_ALBEDO_MAP\nbaseColor *= texture2D(albedoMap, ALBEDO_UV);\n#endif\n#if USE_ALPHA_TEST\nif (baseColor.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n#endif\nif(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {\nif (cc_shadowNFLSInfo.z > 0.000001) {\nreturn vec4(CCGetLinearDepth(v_worldPos.xyz), 1.0, 1.0, 1.0);\n}\n}\nif (cc_shadowLPNNInfo.y > 0.000001) {\nreturn packDepthToRGBA(v_clip_depth);\n}\nreturn vec4(v_clip_depth, 1.0, 1.0, 1.0);\n}\nvoid main() { gl_FragColor = frag(); }"}],[{vert:"\nprecision mediump float;\nuniform highp mat4 cc_matViewProj;\nuniform highp vec4 cc_cameraPos;\nuniform mediump vec4 cc_fogBase;\nuniform mediump vec4 cc_fogAdd;\nuniform highp mat4 cc_matWorld;\nfloat LinearFog(vec4 pos) {\nvec4 wPos = pos;\nfloat cam_dis = distance(cc_cameraPos, wPos);\nfloat fogStart = cc_fogBase.x;\nfloat fogEnd = cc_fogBase.y;\nreturn clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * fogDensity);\nreturn f;\n}\nfloat ExpSquaredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\nreturn f;\n}\nfloat LayeredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat _FogTop = cc_fogAdd.x;\nfloat _FogRange = cc_fogAdd.y;\nvec3 camWorldProj = cc_cameraPos.xyz;\ncamWorldProj.y = 0.;\nvec3 worldPosProj = wPos.xyz;\nworldPosProj.y = 0.;\nfloat fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\nfloat fDeltaY, fDensityIntegral;\nif (cc_cameraPos.y > _FogTop) {\nif (wPos.y < _FogTop) {\nfDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\nfDensityIntegral = fDeltaY * fDeltaY * 0.5;\n} else {\nfDeltaY = 0.;\nfDensityIntegral = 0.;\n}\n} else {\nif (wPos.y < _FogTop) {\nfloat fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfloat fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\nfDeltaY = abs(fDeltaA - fDeltaB);\nfDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n} else {\nfDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n}\n}\nfloat fDensity;\nif (fDeltaY != 0.) {\nfDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n} else {\nfDensity = 0.;\n}\nfloat f = exp(-fDensity);\nreturn f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\nfactor = LinearFog(pos);\n#elif CC_USE_FOG == 1\nfactor = ExpFog(pos);\n#elif CC_USE_FOG == 2\nfactor = ExpSquaredFog(pos);\n#elif CC_USE_FOG == 3\nfactor = LayeredFog(pos);\n#else\nfactor = 1.0;\n#endif\n}\n#if !CC_USE_ACCURATE_FOG\nvarying float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\nCC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\nvarying highp vec4 v_shadowPos;\nuniform highp mat4 cc_matLightViewProj;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#if CC_RECEIVE_SHADOW\nuniform highp sampler2D cc_shadowMap;\nuniform highp sampler2D cc_spotLightingMap;\n#endif\n#if CC_RECEIVE_SHADOW\n#endif\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\n#if CC_RECEIVE_SHADOW\nvarying vec2 v_shadowBias;\n#endif\nvarying highp vec3 v_position;\nvarying mediump vec3 v_normal;\nvarying mediump vec2 uvw;\nvarying mediump vec2 uv0;\nvarying mediump vec2 uv1;\nvarying mediump vec2 uv2;\nvarying mediump vec2 uv3;\nvarying mediump vec3 luv;\nvarying mediump vec3 diffuse;\nuniform vec4 UVScale;\nuniform vec4 lightMapUVParam;\nvoid main () {\nvec3 worldPos;\nworldPos.x = cc_matWorld[3][0] + a_position.x;\nworldPos.y = cc_matWorld[3][1] + a_position.y;\nworldPos.z = cc_matWorld[3][2] + a_position.z;\nvec4 pos = vec4(worldPos, 1.0);\npos = cc_matViewProj * pos;\nuvw = a_texCoord;\nuv0 = a_position.xz * UVScale.x;\nuv1 = a_position.xz * UVScale.y;\nuv2 = a_position.xz * UVScale.z;\nuv3 = a_position.xz * UVScale.w;\n#if CC_USE_LIGHTMAP\nluv.xy = lightMapUVParam.xy + a_texCoord * lightMapUVParam.z;\nluv.z = lightMapUVParam.w;\n#endif\nv_position = worldPos;\nv_normal = a_normal;\nCC_TRANSFER_FOG(vec4(worldPos, 1.0));\n#if CC_RECEIVE_SHADOW\nv_shadowBias = vec2(0.0, 0.0);\n#endif\nv_shadowPos = cc_matLightViewProj * vec4(worldPos, 1.0);\ngl_Position = pos;\n}",frag:"\n#ifdef GL_EXT_draw_buffers\n#extension GL_EXT_draw_buffers: enable\n#endif\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives: enable\n#endif\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod: enable\n#endif\nprecision highp float;\nuniform highp mat4 cc_matView;\nuniform highp vec4 cc_cameraPos;\nuniform mediump vec4 cc_mainLitDir;\nuniform mediump vec4 cc_mainLitColor;\nuniform mediump vec4 cc_ambientSky;\nuniform mediump vec4 cc_ambientGround;\nuniform mediump vec4 cc_fogColor;\nuniform mediump vec4 cc_fogBase;\nuniform mediump vec4 cc_fogAdd;\nuniform mediump vec4 cc_nearFar;\nuniform mediump vec4 cc_viewPort;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nuniform highp mat4 cc_matLightView;\nuniform highp vec4 cc_shadowInvProjDepthInfo;\nuniform highp vec4 cc_shadowProjDepthInfo;\nuniform highp vec4 cc_shadowProjInfo;\nuniform mediump vec4 cc_shadowNFLSInfo;\nuniform mediump vec4 cc_shadowWHPBInfo;\nuniform mediump vec4 cc_shadowLPNNInfo;\nhighp float unpackHighpData (float mainPart, float modPart) {\nhighp float data = mainPart;\nreturn data + modPart;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data) {\nmainPart = fract(data);\nmodPart = data - mainPart;\n}\nhighp float unpackHighpData (float mainPart, float modPart, const float modValue) {\nhighp float data = mainPart * modValue;\nreturn data + modPart * modValue;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\nhighp float divide = data / modValue;\nmainPart = floor(divide);\nmodPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\nhighp vec2 data = mainPart;\nreturn data + modPart;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\nmainPart = fract(data);\nmodPart = data - mainPart;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\nhighp vec2 data = mainPart * modValue;\nreturn data + modPart * modValue;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\nhighp vec2 divide = data / modValue;\nmainPart = floor(divide);\nmodPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\nhighp vec3 data = mainPart;\nreturn data + modPart;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\nmainPart = fract(data);\nmodPart = data - mainPart;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\nhighp vec3 data = mainPart * modValue;\nreturn data + modPart * modValue;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\nhighp vec3 divide = data / modValue;\nmainPart = floor(divide);\nmodPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\nhighp vec4 data = mainPart;\nreturn data + modPart;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\nmainPart = fract(data);\nmodPart = data - mainPart;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\nhighp vec4 data = mainPart * modValue;\nreturn data + modPart * modValue;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\nhighp vec4 divide = data / modValue;\nmainPart = floor(divide);\nmodPart = (data - mainPart * modValue) / modValue;\n}\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\nfloat dist = length(viewPos);\nreturn (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\nvec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\nreturn CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\nuniform highp sampler2D cc_shadowMap;\nuniform highp sampler2D cc_spotLightingMap;\nvec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias)\n{\nvec4 newShadowPos = shadowPos;\nif(normalBias > EPSILON_LOWP)\n{\nvec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);\nif(viewNormal.z < 0.1)\nnewShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n}\nreturn newShadowPos;\n}\nvec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n{\nvec3 viewSpacePos;\nviewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\nviewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;\nviewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\nvec4 clipSpacePos;\nclipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\nclipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\nif (cc_shadowNFLSInfo.z > EPSILON) {\nclipSpacePos.z = CCGetLinearDepthFromViewSpace(viewSpacePos.xyz);\nclipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n}\nreturn clipSpacePos;\n}\nvec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)\n{\nfloat coeffA = cc_shadowProjDepthInfo.x;\nfloat coeffB = cc_shadowProjDepthInfo.y;\nfloat viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\nviewSpacePos_z += viewspaceDepthBias;\nvec4 result = shadowPos;\nresult.z = viewSpacePos_z * coeffA + coeffB;\nreturn result;\n}\nfloat CCGetShadowFactorHard (vec4 shadowPos, float bias) {\nvec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nif (cc_shadowLPNNInfo.y > EPSILON) {\nclosestDepth = dot(texture2D(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n} else {\nclosestDepth = texture2D(cc_shadowMap, clipPos.xy).x;\n}\nshadow = step(clipPos.z, closestDepth);\nreturn shadow;\n}\nfloat CCGetShadowFactorSoft (vec4 shadowPos, float bias) {\nvec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetDepth = clipPos.z;\nvec2 mapSize = cc_shadowWHPBInfo.xy;\nvec2 oneTap = 1.0 / mapSize;\nvec2 clipPos_offset = clipPos.xy + oneTap;\nfloat block0, block1, block2, block3;\nif (cc_shadowLPNNInfo.y > EPSILON) {\nblock0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n} else {\nblock0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\nblock1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\nblock2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\nblock3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n}\nfloat coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block2, block3, coefX);\nfloat coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;\nreturn mix(resultX, resultY, coefY);\n}\nfloat CCGetShadowFactorSoft2X (vec4 shadowPos, float bias) {\nvec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetDepth = clipPos.z;\nvec2 mapSize = cc_shadowWHPBInfo.xy;\nvec2 oneTap = 1.0 / mapSize;\nfloat clipPos_offset_L = clipPos.x - oneTap.x;\nfloat clipPos_offset_R = clipPos.x + oneTap.x;\nfloat clipPos_offset_U = clipPos.y - oneTap.y;\nfloat clipPos_offset_D = clipPos.y + oneTap.y;\nfloat block0, block1, block2, block3, block4, block5, block6, block7, block8;\nif (cc_shadowLPNNInfo.y > EPSILON) {\nblock0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock4 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock5 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock6 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock7 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock8 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n} else {\nblock0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\nblock1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\nblock2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\nblock3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\nblock4 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\nblock5 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\nblock6 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\nblock7 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\nblock8 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n}\nfloat coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\nfloat coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\nfloat shadow = 0.0;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block3, block4, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block1, block2, coefX);\nresultY = mix(block4, block5, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block3, block4, coefX);\nresultY = mix(block6, block7, coefX);\nshadow += mix(resultX, resultY, coefY);\nresultX = mix(block4, block5, coefX);\nresultY = mix(block7, block8, coefX);\nshadow += mix(resultX, resultY, coefY);\nreturn shadow * 0.25;\n}\nfloat CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos, float bias) {\nvec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nfloat depth = clipPos.z;\nif (cc_shadowLPNNInfo.y > EPSILON) {\nclosestDepth = dot(texture2D(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n} else {\nclosestDepth = texture2D(cc_spotLightingMap, clipPos.xy).x;\n}\nshadow = step(depth, closestDepth);\nreturn shadow;\n}\nfloat CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos, float bias) {\nvec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > EPSILON) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nvec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\nvec2 clipPos_offset = clipPos.xy + oneTap;\nfloat block0, block1, block2, block3;\nif (cc_shadowLPNNInfo.y > EPSILON) {\nblock0 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock1 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock2 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock3 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n} else {\nblock0 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\nblock1 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)).x);\nblock2 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)).x);\nblock3 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n}\nfloat coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block2, block3, coefX);\nfloat coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\nreturn mix(resultX, resultY, coefY);\n}\nfloat CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos, float bias) {\nvec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > EPSILON) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nvec2 mapSize = cc_shadowWHPBInfo.xy;\nvec2 oneTap = 1.0 / mapSize;\nfloat clipPos_offset_L = clipPos.x - oneTap.x;\nfloat clipPos_offset_R = clipPos.x + oneTap.x;\nfloat clipPos_offset_U = clipPos.y - oneTap.y;\nfloat clipPos_offset_D = clipPos.y + oneTap.y;\nfloat block0, block1, block2, block3, block4, block5, block6, block7, block8;\nif (cc_shadowLPNNInfo.y > EPSILON) {\nblock0 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock1 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock2 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock3 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock4 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock5 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock6 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock7 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock8 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n} else {\nblock0 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\nblock1 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)).x);\nblock2 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\nblock3 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)).x);\nblock4 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\nblock5 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)).x);\nblock6 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\nblock7 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)).x);\nblock8 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n}\nfloat coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\nfloat coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\nfloat shadow = 0.0;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block3, block4, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block1, block2, coefX);\nresultY = mix(block4, block5, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block3, block4, coefX);\nresultY = mix(block6, block7, coefX);\nshadow += mix(resultX, resultY, coefY);\nresultX = mix(block4, block5, coefX);\nresultY = mix(block7, block8, coefX);\nshadow += mix(resultX, resultY, coefY);\nreturn shadow * 0.25;\n}\nfloat CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n{\nfloat pcf = cc_shadowWHPBInfo.z;\nif (pcf > 1.9) {\nreturn CCGetSpotLightShadowFactorSoft2X(shadowPos, worldPos, shadowBias.x);\n}else if (pcf > 0.9) {\nreturn CCGetSpotLightShadowFactorSoft(shadowPos, worldPos, shadowBias.x);\n}else {\nreturn CCGetSpotLightShadowFactorHard(shadowPos, worldPos, shadowBias.x);\n}\n}\nfloat CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias)\n{\nfloat realtimeShadow = 1.0;\nvec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y);\nfloat pcf = cc_shadowWHPBInfo.z;\nif (pcf > 1.9) {\nrealtimeShadow =  CCGetShadowFactorSoft2X(pos, shadowBias.x);\n}else if (pcf > 0.9) {\nrealtimeShadow = CCGetShadowFactorSoft(pos, shadowBias.x);\n}else {\nrealtimeShadow = CCGetShadowFactorHard(pos, shadowBias.x);\n}\nreturn mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n}\n#endif\n#if CC_USE_IBL\nuniform samplerCube cc_environment;\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n#ifdef GL_EXT_shader_texture_lod\nreturn texture2DLodEXT(tex, coord, lod);\n#else\nreturn texture2D(tex, coord, lod);\n#endif\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n#ifdef GL_EXT_shader_texture_lod\nreturn textureCubeLodEXT(tex, coord, lod);\n#else\nreturn textureCube(tex, coord, lod);\n#endif\n}\nvec3 unpackRGBE (vec4 rgbe) {\nreturn rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n}\n#if CC_USE_DIFFUSEMAP\nuniform samplerCube cc_diffuseMap;\n#endif\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\nvec3 NxH = cross(N, H);\nfloat OneMinusNoHSqr = dot(NxH, NxH);\nfloat a = roughness * roughness;\nfloat n = NoH * a;\nfloat p = a / (OneMinusNoHSqr + n * n);\nreturn p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\nreturn (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\nconst vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\nconst vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\nvec4 r = roughness * c0 + c1;\nfloat a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\nvec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\nAB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\nreturn specular * AB.x + AB.y;\n}\n#if USE_REFLECTION_DENOISE\nvec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n#if CC_USE_IBL\nfloat mip = roughness * mipCount;\nfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\nfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\nvec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);\nvec4 filtered = textureCube(cc_environment, R);\n#if CC_USE_IBL == 2\nbiased.rgb = unpackRGBE(biased);\nfiltered.rgb = unpackRGBE(filtered);\n#else\nbiased.rgb = SRGBToLinear(biased.rgb);\nfiltered.rgb = SRGBToLinear(filtered.rgb);\n#endif\nreturn mix(biased.rgb, filtered.rgb, denoiseIntensity);\n#else\nreturn vec3(0.0, 0.0, 0.0);\n#endif\n}\n#endif\nstruct StandardSurface {\nvec4 albedo;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nvec3 position, position_fract_part;\n#else\nvec3 position;\n#endif\nvec3 normal;\nvec3 emissive;\nvec3 lightmap;\nfloat lightmap_test;\nfloat roughness;\nfloat metallic;\nfloat occlusion;\nfloat specularIntensity;\n#if CC_RECEIVE_SHADOW\nvec2 shadowBias;\n#endif\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.08 * s.specularIntensity), s.albedo.rgb, s.metallic);\nvec3 position;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nposition = unpackHighpData(s.position, s.position_fract_part);\n#else\nposition = s.position;\n#endif\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - position);\nfloat NV = max(abs(dot(N, V)), 0.0);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 L = normalize(-cc_mainLitDir.xyz);\nvec3 H = normalize(L + V);\nfloat NH = max(dot(N, H), 0.0);\nfloat NL = max(dot(N, L), 0.0);\nvec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\nvec3 diffuseContrib = diffuse / PI;\nvec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\nvec3 dirlightContrib = (diffuseContrib + specularContrib);\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW\nif (NL > 0.0 && cc_mainLitDir.w > 0.0) {\nshadow = CCShadowFactorBase(shadowPos, N, s.shadowBias);\n}\n#endif\ndirlightContrib *= shadow;\nfinalColor *= dirlightContrib;\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nif (s.lightmap_test > EPSILON_LOWP) {\nfinalColor = diffuse * s.lightmap.rgb * shadow;\n}\n#endif\nfloat fAmb = 0.5 - N.y * 0.5;\nvec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n#if CC_USE_IBL\n#if CC_USE_DIFFUSEMAP\nvec4 diffuseMap = textureCube(cc_diffuseMap, N);\n#if CC_USE_DIFFUSEMAP == 2\nambDiff = unpackRGBE(diffuseMap);\n#else\nambDiff = SRGBToLinear(diffuseMap.rgb);\n#endif\n#endif\nvec3 R = normalize(reflect(-V, N));\n#if USE_REFLECTION_DENOISE\nvec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);\n#else\nvec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n#if CC_USE_IBL == 2\nvec3 env = unpackRGBE(envmap);\n#else\nvec3 env = SRGBToLinear(envmap.rgb);\n#endif\n#endif\nfinalColor += env * cc_ambientSky.w * specular * s.occlusion;\n#endif\nfinalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;\nfinalColor += s.emissive;\nreturn vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\ncolor = min(color, vec3(8.0));\nconst float A = 2.51;\nconst float B = 0.03;\nconst float C = 2.43;\nconst float D = 0.59;\nconst float E = 0.14;\nreturn (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n#if CC_USE_HDR\ncolor.rgb = ACESToneMap(color.rgb);\n#endif\ncolor.rgb = sqrt(color.rgb);\nreturn color;\n}\nfloat LinearFog(vec4 pos) {\nvec4 wPos = pos;\nfloat cam_dis = distance(cc_cameraPos, wPos);\nfloat fogStart = cc_fogBase.x;\nfloat fogEnd = cc_fogBase.y;\nreturn clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * fogDensity);\nreturn f;\n}\nfloat ExpSquaredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\nreturn f;\n}\nfloat LayeredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat _FogTop = cc_fogAdd.x;\nfloat _FogRange = cc_fogAdd.y;\nvec3 camWorldProj = cc_cameraPos.xyz;\ncamWorldProj.y = 0.;\nvec3 worldPosProj = wPos.xyz;\nworldPosProj.y = 0.;\nfloat fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\nfloat fDeltaY, fDensityIntegral;\nif (cc_cameraPos.y > _FogTop) {\nif (wPos.y < _FogTop) {\nfDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\nfDensityIntegral = fDeltaY * fDeltaY * 0.5;\n} else {\nfDeltaY = 0.;\nfDensityIntegral = 0.;\n}\n} else {\nif (wPos.y < _FogTop) {\nfloat fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfloat fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\nfDeltaY = abs(fDeltaA - fDeltaB);\nfDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n} else {\nfDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n}\n}\nfloat fDensity;\nif (fDeltaY != 0.) {\nfDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n} else {\nfDensity = 0.;\n}\nfloat f = exp(-fDensity);\nreturn f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\nfactor = LinearFog(pos);\n#elif CC_USE_FOG == 1\nfactor = ExpFog(pos);\n#elif CC_USE_FOG == 2\nfactor = ExpSquaredFog(pos);\n#elif CC_USE_FOG == 3\nfactor = LayeredFog(pos);\n#else\nfactor = 1.0;\n#endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\ncolor = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if !CC_USE_ACCURATE_FOG\nvarying float v_fog_factor;\n#endif\nvoid CC_APPLY_FOG(inout vec4 color) {\n#if !CC_USE_ACCURATE_FOG\nCC_APPLY_FOG_BASE(color, v_fog_factor);\n#endif\n}\nvoid CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n#if CC_USE_ACCURATE_FOG\nfloat factor;\nCC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n#else\nfloat factor = v_fog_factor;\n#endif\nCC_APPLY_FOG_BASE(color, factor);\n}\nvarying highp vec4 v_shadowPos;\n#if CC_RECEIVE_SHADOW\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nvarying vec3 v_luv;\nuniform sampler2D cc_lightingMap;\n#endif\nvarying highp vec3 v_position;\nvarying mediump vec3 v_normal;\n#if CC_RECEIVE_SHADOW\nvarying vec2 v_shadowBias;\n#endif\nvarying mediump vec2 uvw;\nvarying mediump vec2 uv0;\nvarying mediump vec2 uv1;\nvarying mediump vec2 uv2;\nvarying mediump vec2 uv3;\nvarying mediump vec3 diffuse;\nvarying mediump vec3 luv;\nuniform vec4 metallic;\nuniform vec4 roughness;\nuniform sampler2D weightMap;\nuniform sampler2D detailMap0;\nuniform sampler2D detailMap1;\nuniform sampler2D detailMap2;\nuniform sampler2D detailMap3;\nuniform sampler2D normalMap0;\nuniform sampler2D normalMap1;\nuniform sampler2D normalMap2;\nuniform sampler2D normalMap3;\nuniform sampler2D lightMap;\nvoid surf (out StandardSurface s) {\n#if LAYERS > 1\nvec4 w = texture2D(weightMap, uvw);\n#endif\nvec4 baseColor = vec4(0, 0, 0, 0);\n#if LAYERS == 1\nbaseColor = texture2D(detailMap0, uv0);\n#elif LAYERS == 2\nbaseColor += texture2D(detailMap0, uv0) * w.r;\nbaseColor += texture2D(detailMap1, uv1) * w.g;\n#elif LAYERS == 3\nbaseColor += texture2D(detailMap0, uv0) * w.r;\nbaseColor += texture2D(detailMap1, uv1) * w.g;\nbaseColor += texture2D(detailMap2, uv2) * w.b;\n#elif LAYERS == 4\nbaseColor += texture2D(detailMap0, uv0) * w.r;\nbaseColor += texture2D(detailMap1, uv1) * w.g;\nbaseColor += texture2D(detailMap2, uv2) * w.b;\nbaseColor += texture2D(detailMap3, uv3) * w.a;\n#else\nbaseColor = texture2D(detailMap0, uv0);\n#endif\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\npackHighpData(s.position, s.position_fract_part, v_position);\n#else\ns.position = v_position;\n#endif\n#if USE_NORMALMAP\nvec4 baseNormal = vec4(0, 0, 0, 0);\n#if LAYERS == 1\nbaseNormal = texture2D(normalMap0, uv0);\n#elif LAYERS == 2\nbaseNormal += texture2D(normalMap0, uv0) * w.r;\nbaseNormal += texture2D(normalMap1, uv1) * w.g;\n#elif LAYERS == 3\nbaseNormal += texture2D(normalMap0, uv0) * w.r;\nbaseNormal += texture2D(normalMap1, uv1) * w.g;\nbaseNormal += texture2D(normalMap2, uv2) * w.b;\n#elif LAYERS == 4\nbaseNormal += texture2D(normalMap0, uv0) * w.r;\nbaseNormal += texture2D(normalMap1, uv1) * w.g;\nbaseNormal += texture2D(normalMap2, uv2) * w.b;\nbaseNormal += texture2D(normalMap3, uv3) * w.a;\n#else\nbaseNormal = texture2D(normalMap0, uv0);\n#endif\nvec3 tangent = vec3(1.0, 0.0, 0.0);\nvec3 binormal = vec3(0.0, 0.0, 1.0);\nbinormal = cross(tangent, v_normal);\ntangent = cross(v_normal, binormal);\nvec3 nmmp = baseNormal.xyz - vec3(0.5);\ns.normal =\nnmmp.x * normalize(tangent) +\nnmmp.y * normalize(binormal) +\nnmmp.z * normalize(v_normal);\n#else\ns.normal = v_normal;\n#endif\n#if CC_RECEIVE_SHADOW\ns.shadowBias = v_shadowBias;\n#endif\ns.albedo = vec4(SRGBToLinear(baseColor.rgb), 1.0);\ns.occlusion = 1.0;\n#if USE_PBR\ns.roughness = 0.0;\n#if LAYERS == 1\ns.roughness = roughness.x;\n#elif LAYERS == 2\ns.roughness += roughness.x * w.r;\ns.roughness += roughness.y * w.g;\n#elif LAYERS == 3\ns.roughness += roughness.x * w.r;\ns.roughness += roughness.y * w.g;\ns.roughness += roughness.z * w.b;\n#elif LAYERS == 4\ns.roughness += roughness.x * w.r;\ns.roughness += roughness.y * w.g;\ns.roughness += roughness.z * w.b;\ns.roughness += roughness.w * w.a;\n#else\ns.roughness = 1.0;\n#endif\ns.specularIntensity = 0.5;\ns.metallic = 0.0;\n#if LAYERS == 1\ns.specularIntensity = 0.5;\ns.metallic = metallic.x;\n#elif LAYERS == 2\ns.metallic += metallic.x * w.r;\ns.metallic += metallic.y * w.g;\n#elif LAYERS == 3\ns.metallic += metallic.x * w.r;\ns.metallic += metallic.y * w.g;\ns.metallic += metallic.z * w.b;\n#elif LAYERS == 4\ns.metallic += metallic.x * w.r;\ns.metallic += metallic.y * w.g;\ns.metallic += metallic.z * w.b;\ns.metallic += metallic.w * w.a;\n#else\ns.specularIntensity = 0.5;\ns.metallic = 0.0;\n#endif\n#else\ns.roughness = 1.0;\ns.specularIntensity = 0.5;\ns.metallic = 0.0;\n#endif\ns.emissive = vec3(0.0, 0.0, 0.0);\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nvec4 lightColor = texture2D(lightMap, luv.xy);\ns.lightmap = lightColor.xyz * luv.z;\ns.lightmap_test = luv.z;\n#endif\n}\n#if CC_FORWARD_ADD\n#if CC_PIPELINE_TYPE == 0\n#define LIGHTS_PER_PASS 1\n#else\n#define LIGHTS_PER_PASS 10\n#endif\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\nuniform highp vec4 cc_lightPos[LIGHTS_PER_PASS];\nuniform vec4 cc_lightColor[LIGHTS_PER_PASS];\nuniform vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\nuniform vec4 cc_lightDir[LIGHTS_PER_PASS];\n#endif\nfloat SmoothDistAtt (float distSqr, float invSqrAttRadius) {\nfloat factor = distSqr * invSqrAttRadius;\nfloat smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\nreturn smoothFactor * smoothFactor;\n}\nfloat GetDistAtt (float distSqr, float invSqrAttRadius) {\nfloat attenuation = 1.0 / max(distSqr, 0.01*0.01);\nattenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\nreturn attenuation;\n}\nfloat GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\nfloat cd = dot(litDir, L);\nfloat attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\nreturn (attenuation * attenuation);\n}\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\nvec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\nvec3 position;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nposition = unpackHighpData(s.position, s.position_fract_part);\n#else\nposition = s.position;\n#endif\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 diffuseContrib = diffuse / PI;\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - position);\nfloat NV = max(abs(dot(N, V)), 0.0);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 finalColor = vec3(0.0);\nint numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\nfor (int i = 0; i < LIGHTS_PER_PASS; i++) {\nif (i >= numLights) break;\nvec3 SLU = cc_lightPos[i].xyz - position;\nvec3 SL = normalize(SLU);\nvec3 SH = normalize(SL + V);\nfloat SNL = max(dot(N, SL), 0.0);\nfloat SNH = max(dot(N, SH), 0.0);\nfloat distSqr = dot(SLU, SLU);\nfloat litRadius = cc_lightSizeRangeAngle[i].x;\nfloat litRadiusSqr = litRadius * litRadius;\nfloat illum = litRadiusSqr / max(litRadiusSqr, distSqr);\nfloat attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\nattRadiusSqrInv *= attRadiusSqrInv;\nfloat att = GetDistAtt(distSqr, attRadiusSqrInv);\nvec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\nif (cc_lightPos[i].w > 0.0) {\nfloat cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\nfloat cosOuter = cc_lightSizeRangeAngle[i].z;\nfloat litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\nfloat litAngleOffset = -cosOuter * litAngleScale;\natt *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n}\nvec3 lightColor = cc_lightColor[i].rgb;\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW\nif (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\nshadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n}\n#endif\nlightColor *= shadow;\nfinalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n}\nreturn vec4(finalColor, 0.0);\n}\n#endif\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\nreadonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };\nreadonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };\nreadonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };\nstruct CCLight\n{\nvec4 cc_lightPos;\nvec4 cc_lightColor;\nvec4 cc_lightSizeRangeAngle;\nvec4 cc_lightDir;\n};\nstruct Cluster\n{\nvec3 minBounds;\nvec3 maxBounds;\n};\nstruct LightGrid\n{\nuint offset;\nuint ccLights;\n};\nCCLight getCCLight(uint i)\n{\nCCLight light;\nlight.cc_lightPos = b_ccLights[4u * i + 0u];\nlight.cc_lightColor = b_ccLights[4u * i + 1u];\nlight.cc_lightSizeRangeAngle = b_ccLights[4u * i + 2u];\nlight.cc_lightDir = b_ccLights[4u * i + 3u];\nreturn light;\n}\nLightGrid getLightGrid(uint cluster)\n{\nuvec4 gridvec = b_clusterLightGrid[cluster];\nLightGrid grid;\ngrid.offset = gridvec.x;\ngrid.ccLights = gridvec.y;\nreturn grid;\n}\nuint getGridLightIndex(uint start, uint offset)\n{\nreturn b_clusterLightIndices[start + offset];\n}\nuint getClusterZIndex(vec4 worldPos)\n{\nfloat scale = float(24) / log(cc_nearFar.y / cc_nearFar.x);\nfloat bias = -(float(24) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));\nfloat eyeDepth = -(cc_matView * worldPos).z;\nuint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));\nreturn zIndex;\n}\nuint getClusterIndex(vec4 fragCoord, vec4 worldPos)\n{\nuint zIndex = getClusterZIndex(worldPos);\nfloat clusterSizeX = ceil(cc_viewPort.z / float(16));\nfloat clusterSizeY = ceil(cc_viewPort.w / float(8));\nuvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);\nuint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;\nreturn cluster;\n}\nvec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 diffuseContrib = diffuse / PI;\nvec3 position;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nposition = unpackHighpData(s.position, s.position_fract_part);\n#else\nposition = s.position;\n#endif\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - position);\nfloat NV = max(abs(dot(N, V)), 0.001);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 finalColor = vec3(0.0);\nuint cluster = getClusterIndex(gl_FragCoord, vec4(position, 1.0));\nLightGrid grid = getLightGrid(cluster);\nuint numLights = grid.ccLights;\nfor (uint i = 0u; i < 100u; i++) {\nif (i >= numLights) break;\nuint lightIndex = getGridLightIndex(grid.offset, i);\nCCLight light = getCCLight(lightIndex);\nvec3 SLU = light.cc_lightPos.xyz - position;\nvec3 SL = normalize(SLU);\nvec3 SH = normalize(SL + V);\nfloat SNL = max(dot(N, SL), 0.001);\nfloat SNH = max(dot(N, SH), 0.0);\nfloat distSqr = dot(SLU, SLU);\nfloat litRadius = light.cc_lightSizeRangeAngle.x;\nfloat litRadiusSqr = litRadius * litRadius;\nfloat illum = PI * (litRadiusSqr / max(litRadiusSqr , distSqr));\nfloat attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);\nattRadiusSqrInv *= attRadiusSqrInv;\nfloat att = GetDistAtt(distSqr, attRadiusSqrInv);\nvec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\nif (light.cc_lightPos.w > 0.0) {\nfloat cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);\nfloat cosOuter = light.cc_lightSizeRangeAngle.z;\nfloat litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\nfloat litAngleOffset = -cosOuter * litAngleScale;\natt *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);\n}\nvec3 lightColor = light.cc_lightColor.rgb;\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW\nif (light.cc_lightPos.w > 0.0) {\nshadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n}\n#endif\nlightColor *= shadow;\nfinalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);\n}\nreturn vec4(finalColor, 0.0);\n}\n#endif\nvoid main () {\nStandardSurface s; surf(s);\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\nvec4 color = CCClusterShadingAdditive(s, v_shadowPos);\n#else\nvec4 color = CCStandardShadingAdditive(s, v_shadowPos);\n#endif\ngl_FragData[0] = CCFragOutput(color);\n}\n#elif (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\nvoid main () {\nStandardSurface s; surf(s);\nvec4 color = CCStandardShadingBase(s, v_shadowPos);\nCC_APPLY_FOG(color, s.position.xyz);\ngl_FragData[0] = CCFragOutput(color);\n}\n#elif CC_PIPELINE_TYPE == 1\nvec2 signNotZero(vec2 v) {\nreturn vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n}\nvec2 float32x3_to_oct(in vec3 v) {\nvec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));\nreturn (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;\n}\nvoid main () {\nStandardSurface s; surf(s);\ngl_FragData[0] = s.albedo;\ngl_FragData[1] = vec4(float32x3_to_oct(s.normal), s.roughness, s.metallic);\ngl_FragData[2] = vec4(s.emissive, s.occlusion);\n}\n#endif"},{vert:"\nprecision highp float;\nuniform highp mat4 cc_matWorld;\nuniform highp mat4 cc_matLightViewProj;\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nvarying vec2 v_clip_depth;\nvec4 vert () {\nvec4 worldPos;\nworldPos.x = cc_matWorld[3][0] + a_position.x;\nworldPos.y = cc_matWorld[3][1] + a_position.y;\nworldPos.z = cc_matWorld[3][2] + a_position.z;\nworldPos.w = 1.0;\nvec4 clipPos = cc_matLightViewProj * worldPos;\nv_clip_depth = clipPos.zw;\nreturn clipPos;\n}\nvoid main() { gl_Position = vert(); }",frag:"\nprecision highp float;\nvec4 packDepthToRGBA (float depth) {\nvec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\nret = fract(ret);\nret -= vec4(ret.yzw, 0.0) / 255.0;\nreturn ret;\n}\nvarying vec2 v_clip_depth;\nvec4 frag () {\nreturn packDepthToRGBA(v_clip_depth.x / v_clip_depth.y * 0.5 + 0.5);\n}\nvoid main() { gl_FragColor = frag(); }"}],[{vert:"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_SKINNING\nattribute vec4 a_joints;\nattribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n#if CC_USE_BAKED_ANIMATION\nattribute highp vec4 a_jointAnimInfo;\n#endif\nattribute vec4 a_matWorld0;\nattribute vec4 a_matWorld1;\nattribute vec4 a_matWorld2;\n#if CC_USE_LIGHTMAP\nattribute vec4 a_lightingMapUVParam;\n#endif\n#if CC_RECEIVE_SHADOW\nattribute vec2 a_localShadowBias;\n#endif\n#elif USE_BATCHING\nattribute float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\nattribute float a_vertexId;\nint getVertexId() {\nreturn int(a_vertexId);\n}\n#endif\n#if CC_USE_MORPH\nuniform vec4 cc_displacementWeights[15];\nuniform vec4 cc_displacementTextureInfo;\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\nreturn texture2D(tex, uv);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture2D(tex, x)),\ndecode32(texture2D(tex, y)),\ndecode32(texture2D(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nuniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nuniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nuniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nnormal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\ntangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\n#if CC_USE_BAKED_ANIMATION\nuniform highp vec4 cc_jointTextureInfo;\nuniform highp vec4 cc_jointAnimInfo;\nuniform highp sampler2D cc_jointTexture;\nvoid CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n{\n#if USE_INSTANCING\nhighp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n#else\nhighp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n#endif\ninvSize = cc_jointTextureInfo.w;\nhighp float tempY = floor(temp * invSize);\nx = floor(temp - tempY * cc_jointTextureInfo.x);\ny = (tempY + 0.5) * invSize;\n}\n#else\nuniform highp vec4 cc_joints[90];\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(3.0, i, x, y, invSize);\nvec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(12.0, i, x, y, invSize);\nvec4 v1 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\nmat4 m = skinMatrix();\nposition = m * position;\nnormal = (m * vec4(normal, 0.0)).xyz;\ntangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n}\n#endif\nvoid CCVertInput(inout vec4 In)\n{\nIn = vec4(a_position, 1.0);\n#if CC_USE_MORPH\napplyMorph(In);\n#endif\n#if CC_USE_SKINNING\nCCSkin(In);\n#endif\n}\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matProj;\nuniform highp vec4 cc_cameraPos;\nuniform mediump vec4 cc_fogBase;\nuniform mediump vec4 cc_fogAdd;\n#if !USE_INSTANCING\n#if USE_BATCHING\nuniform highp mat4 cc_matWorlds[10];\n#else\nuniform highp mat4 cc_matWorld;\n#endif\n#endif\nvoid CCGetWorldMatrix(out mat4 matWorld)\n{\n#if USE_INSTANCING\nmatWorld = mat4(\nvec4(a_matWorld0.xyz, 0.0),\nvec4(a_matWorld1.xyz, 0.0),\nvec4(a_matWorld2.xyz, 0.0),\nvec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n);\n#elif USE_BATCHING\nmatWorld = cc_matWorlds[int(a_dyn_batch_id)];\n#else\nmatWorld = cc_matWorld;\n#endif\n}\nfloat LinearFog(vec4 pos) {\nvec4 wPos = pos;\nfloat cam_dis = distance(cc_cameraPos, wPos);\nfloat fogStart = cc_fogBase.x;\nfloat fogEnd = cc_fogBase.y;\nreturn clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * fogDensity);\nreturn f;\n}\nfloat ExpSquaredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\nreturn f;\n}\nfloat LayeredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat _FogTop = cc_fogAdd.x;\nfloat _FogRange = cc_fogAdd.y;\nvec3 camWorldProj = cc_cameraPos.xyz;\ncamWorldProj.y = 0.;\nvec3 worldPosProj = wPos.xyz;\nworldPosProj.y = 0.;\nfloat fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\nfloat fDeltaY, fDensityIntegral;\nif (cc_cameraPos.y > _FogTop) {\nif (wPos.y < _FogTop) {\nfDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\nfDensityIntegral = fDeltaY * fDeltaY * 0.5;\n} else {\nfDeltaY = 0.;\nfDensityIntegral = 0.;\n}\n} else {\nif (wPos.y < _FogTop) {\nfloat fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfloat fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\nfDeltaY = abs(fDeltaA - fDeltaB);\nfDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n} else {\nfDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n}\n}\nfloat fDensity;\nif (fDeltaY != 0.) {\nfDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n} else {\nfDensity = 0.;\n}\nfloat f = exp(-fDensity);\nreturn f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\nfactor = LinearFog(pos);\n#elif CC_USE_FOG == 1\nfactor = ExpFog(pos);\n#elif CC_USE_FOG == 2\nfactor = ExpSquaredFog(pos);\n#elif CC_USE_FOG == 3\nfactor = LayeredFog(pos);\n#else\nfactor = 1.0;\n#endif\n}\n#if !CC_USE_ACCURATE_FOG\nvarying float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\nCC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\n#if USE_VERTEX_COLOR\nattribute lowp vec4 a_color;\nvarying lowp vec4 v_color;\n#endif\n#if USE_TEXTURE\nvarying vec2 v_uv;\nuniform vec4 tilingOffset;\n#endif\nvec4 vert () {\nvec4 position;\nCCVertInput(position);\nmat4 matWorld;\nCCGetWorldMatrix(matWorld);\n#if USE_TEXTURE\nv_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n#if SAMPLE_FROM_RT\nv_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n#endif\n#endif\n#if USE_VERTEX_COLOR\nv_color = a_color;\n#endif\nCC_TRANSFER_FOG(matWorld * position);\nreturn cc_matProj * (cc_matView * matWorld) * position;\n}\nvoid main() { gl_Position = vert(); }",frag:"\nprecision highp float;\nvec3 ACESToneMap (vec3 color) {\ncolor = min(color, vec3(8.0));\nconst float A = 2.51;\nconst float B = 0.03;\nconst float C = 2.43;\nconst float D = 0.59;\nconst float E = 0.14;\nreturn (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n#if CC_USE_HDR\ncolor.rgb = ACESToneMap(color.rgb);\n#endif\ncolor.rgb = sqrt(color.rgb);\nreturn color;\n}\nuniform highp vec4 cc_cameraPos;\nuniform mediump vec4 cc_fogColor;\nuniform mediump vec4 cc_fogBase;\nuniform mediump vec4 cc_fogAdd;\nfloat LinearFog(vec4 pos) {\nvec4 wPos = pos;\nfloat cam_dis = distance(cc_cameraPos, wPos);\nfloat fogStart = cc_fogBase.x;\nfloat fogEnd = cc_fogBase.y;\nreturn clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * fogDensity);\nreturn f;\n}\nfloat ExpSquaredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\nreturn f;\n}\nfloat LayeredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat _FogTop = cc_fogAdd.x;\nfloat _FogRange = cc_fogAdd.y;\nvec3 camWorldProj = cc_cameraPos.xyz;\ncamWorldProj.y = 0.;\nvec3 worldPosProj = wPos.xyz;\nworldPosProj.y = 0.;\nfloat fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\nfloat fDeltaY, fDensityIntegral;\nif (cc_cameraPos.y > _FogTop) {\nif (wPos.y < _FogTop) {\nfDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\nfDensityIntegral = fDeltaY * fDeltaY * 0.5;\n} else {\nfDeltaY = 0.;\nfDensityIntegral = 0.;\n}\n} else {\nif (wPos.y < _FogTop) {\nfloat fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfloat fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\nfDeltaY = abs(fDeltaA - fDeltaB);\nfDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n} else {\nfDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n}\n}\nfloat fDensity;\nif (fDeltaY != 0.) {\nfDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n} else {\nfDensity = 0.;\n}\nfloat f = exp(-fDensity);\nreturn f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\nfactor = LinearFog(pos);\n#elif CC_USE_FOG == 1\nfactor = ExpFog(pos);\n#elif CC_USE_FOG == 2\nfactor = ExpSquaredFog(pos);\n#elif CC_USE_FOG == 3\nfactor = LayeredFog(pos);\n#else\nfactor = 1.0;\n#endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\ncolor = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if !CC_USE_ACCURATE_FOG\nvarying float v_fog_factor;\n#endif\nvoid CC_APPLY_FOG(inout vec4 color) {\n#if !CC_USE_ACCURATE_FOG\nCC_APPLY_FOG_BASE(color, v_fog_factor);\n#endif\n}\nvoid CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n#if CC_USE_ACCURATE_FOG\nfloat factor;\nCC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n#else\nfloat factor = v_fog_factor;\n#endif\nCC_APPLY_FOG_BASE(color, factor);\n}\n#if USE_ALPHA_TEST\n#endif\n#if USE_TEXTURE\nvarying vec2 v_uv;\nuniform sampler2D mainTexture;\n#endif\nuniform vec4 mainColor;\nuniform vec4 colorScaleAndCutoff;\n#if USE_VERTEX_COLOR\nvarying lowp vec4 v_color;\n#endif\nvec4 frag () {\nvec4 o = mainColor;\no.rgb *= colorScaleAndCutoff.xyz;\n#if USE_VERTEX_COLOR\no.rgb *= SRGBToLinear(v_color.rgb);\no.a *= v_color.a;\n#endif\n#if USE_TEXTURE\nvec4 texColor = texture2D(mainTexture, v_uv);\ntexColor.rgb = SRGBToLinear(texColor.rgb);\no *= texColor;\n#endif\n#if USE_ALPHA_TEST\nif (o.ALPHA_TEST_CHANNEL < colorScaleAndCutoff.w) discard;\n#endif\nCC_APPLY_FOG(o);\nreturn CCFragOutput(o);\n}\nvoid main() { gl_FragColor = frag(); }"}],[{vert:"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_SKINNING\nattribute vec4 a_joints;\nattribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n#if CC_USE_BAKED_ANIMATION\nattribute highp vec4 a_jointAnimInfo;\n#endif\nattribute vec4 a_matWorld0;\nattribute vec4 a_matWorld1;\nattribute vec4 a_matWorld2;\n#if CC_USE_LIGHTMAP\nattribute vec4 a_lightingMapUVParam;\n#endif\n#if CC_RECEIVE_SHADOW\nattribute vec2 a_localShadowBias;\n#endif\n#elif USE_BATCHING\nattribute float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\nattribute float a_vertexId;\nint getVertexId() {\nreturn int(a_vertexId);\n}\n#endif\n#if CC_USE_MORPH\nuniform vec4 cc_displacementWeights[15];\nuniform vec4 cc_displacementTextureInfo;\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\nreturn texture2D(tex, uv);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture2D(tex, x)),\ndecode32(texture2D(tex, y)),\ndecode32(texture2D(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nuniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nuniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nuniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nnormal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\ntangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\n#if CC_USE_BAKED_ANIMATION\nuniform highp vec4 cc_jointTextureInfo;\nuniform highp vec4 cc_jointAnimInfo;\nuniform highp sampler2D cc_jointTexture;\nvoid CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n{\n#if USE_INSTANCING\nhighp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n#else\nhighp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n#endif\ninvSize = cc_jointTextureInfo.w;\nhighp float tempY = floor(temp * invSize);\nx = floor(temp - tempY * cc_jointTextureInfo.x);\ny = (tempY + 0.5) * invSize;\n}\n#else\nuniform highp vec4 cc_joints[90];\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(3.0, i, x, y, invSize);\nvec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(12.0, i, x, y, invSize);\nvec4 v1 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\nmat4 m = skinMatrix();\nposition = m * position;\nnormal = (m * vec4(normal, 0.0)).xyz;\ntangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n}\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\nIn.position = vec4(a_position, 1.0);\nIn.normal = a_normal;\nIn.tangent = a_tangent;\n#if CC_USE_MORPH\napplyMorph(In.position, In.normal, In.tangent);\n#endif\n#if CC_USE_SKINNING\nCCSkin(In.position, In.normal, In.tangent);\n#endif\n}\nuniform highp vec4 cc_cameraPos;\nvarying vec2 v_uv;\nvoid main () {\nStandardVertInput In;\nCCVertInput(In);\nIn.position.xy = cc_cameraPos.w == 0.0 ? vec2(In.position.xy.x, -In.position.xy.y) : In.position.xy;\ngl_Position = In.position;\ngl_Position.y = gl_Position.y;\nv_uv = a_texCoord;\n}",frag:"\nprecision highp float;\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nvarying vec2 v_uv;\nuniform mediump vec4 texSize;\nuniform sampler2D outputResultMap;\nfloat luminance(vec3 color) {\nreturn dot(color, vec3(0.2126, 0.7152, 0.0722));\n}\nvoid main() {\nvec3 color = texture2D(outputResultMap, v_uv).xyz;\nif (luminance(SRGBToLinear(color)) > texSize.z) {\ngl_FragColor = vec4(color, 1.0);\n} else {\ngl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n}"},{vert:"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_SKINNING\nattribute vec4 a_joints;\nattribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n#if CC_USE_BAKED_ANIMATION\nattribute highp vec4 a_jointAnimInfo;\n#endif\nattribute vec4 a_matWorld0;\nattribute vec4 a_matWorld1;\nattribute vec4 a_matWorld2;\n#if CC_USE_LIGHTMAP\nattribute vec4 a_lightingMapUVParam;\n#endif\n#if CC_RECEIVE_SHADOW\nattribute vec2 a_localShadowBias;\n#endif\n#elif USE_BATCHING\nattribute float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\nattribute float a_vertexId;\nint getVertexId() {\nreturn int(a_vertexId);\n}\n#endif\n#if CC_USE_MORPH\nuniform vec4 cc_displacementWeights[15];\nuniform vec4 cc_displacementTextureInfo;\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\nreturn texture2D(tex, uv);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture2D(tex, x)),\ndecode32(texture2D(tex, y)),\ndecode32(texture2D(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nuniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nuniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nuniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nnormal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\ntangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\n#if CC_USE_BAKED_ANIMATION\nuniform highp vec4 cc_jointTextureInfo;\nuniform highp vec4 cc_jointAnimInfo;\nuniform highp sampler2D cc_jointTexture;\nvoid CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n{\n#if USE_INSTANCING\nhighp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n#else\nhighp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n#endif\ninvSize = cc_jointTextureInfo.w;\nhighp float tempY = floor(temp * invSize);\nx = floor(temp - tempY * cc_jointTextureInfo.x);\ny = (tempY + 0.5) * invSize;\n}\n#else\nuniform highp vec4 cc_joints[90];\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(3.0, i, x, y, invSize);\nvec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(12.0, i, x, y, invSize);\nvec4 v1 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\nmat4 m = skinMatrix();\nposition = m * position;\nnormal = (m * vec4(normal, 0.0)).xyz;\ntangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n}\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\nIn.position = vec4(a_position, 1.0);\nIn.normal = a_normal;\nIn.tangent = a_tangent;\n#if CC_USE_MORPH\napplyMorph(In.position, In.normal, In.tangent);\n#endif\n#if CC_USE_SKINNING\nCCSkin(In.position, In.normal, In.tangent);\n#endif\n}\nuniform highp vec4 cc_cameraPos;\nvarying vec2 v_uv;\nvoid main () {\nStandardVertInput In;\nCCVertInput(In);\nIn.position.xy = cc_cameraPos.w == 0.0 ? vec2(In.position.xy.x, -In.position.xy.y) : In.position.xy;\ngl_Position = In.position;\ngl_Position.y = gl_Position.y;\nv_uv = a_texCoord;\n}",frag:"\nprecision highp float;\nvarying vec2 v_uv;\nuniform mediump vec4 texSize;\nuniform sampler2D bloomTexture;\nvec3 downsample4taps(vec2 uv, vec2 halfpixel) {\nvec3 sum = texture2D(bloomTexture, uv + vec2(-halfpixel.x, halfpixel.y)).xyz;\nsum += texture2D(bloomTexture, uv + vec2(halfpixel.x, halfpixel.y)).xyz;\nsum += texture2D(bloomTexture, uv + vec2(halfpixel.x, -halfpixel.y)).xyz;\nsum += texture2D(bloomTexture, uv + vec2(-halfpixel.x, -halfpixel.y)).xyz;\nreturn sum / 4.0;\n}\nvoid main()\n{\nvec3 result = downsample4taps(v_uv, 1.0 / texSize.xy).rgb;\ngl_FragColor = vec4(result, 1.0);\n}"},{vert:"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_SKINNING\nattribute vec4 a_joints;\nattribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n#if CC_USE_BAKED_ANIMATION\nattribute highp vec4 a_jointAnimInfo;\n#endif\nattribute vec4 a_matWorld0;\nattribute vec4 a_matWorld1;\nattribute vec4 a_matWorld2;\n#if CC_USE_LIGHTMAP\nattribute vec4 a_lightingMapUVParam;\n#endif\n#if CC_RECEIVE_SHADOW\nattribute vec2 a_localShadowBias;\n#endif\n#elif USE_BATCHING\nattribute float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\nattribute float a_vertexId;\nint getVertexId() {\nreturn int(a_vertexId);\n}\n#endif\n#if CC_USE_MORPH\nuniform vec4 cc_displacementWeights[15];\nuniform vec4 cc_displacementTextureInfo;\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\nreturn texture2D(tex, uv);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture2D(tex, x)),\ndecode32(texture2D(tex, y)),\ndecode32(texture2D(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nuniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nuniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nuniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nnormal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\ntangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\n#if CC_USE_BAKED_ANIMATION\nuniform highp vec4 cc_jointTextureInfo;\nuniform highp vec4 cc_jointAnimInfo;\nuniform highp sampler2D cc_jointTexture;\nvoid CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n{\n#if USE_INSTANCING\nhighp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n#else\nhighp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n#endif\ninvSize = cc_jointTextureInfo.w;\nhighp float tempY = floor(temp * invSize);\nx = floor(temp - tempY * cc_jointTextureInfo.x);\ny = (tempY + 0.5) * invSize;\n}\n#else\nuniform highp vec4 cc_joints[90];\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(3.0, i, x, y, invSize);\nvec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(12.0, i, x, y, invSize);\nvec4 v1 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\nmat4 m = skinMatrix();\nposition = m * position;\nnormal = (m * vec4(normal, 0.0)).xyz;\ntangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n}\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\nIn.position = vec4(a_position, 1.0);\nIn.normal = a_normal;\nIn.tangent = a_tangent;\n#if CC_USE_MORPH\napplyMorph(In.position, In.normal, In.tangent);\n#endif\n#if CC_USE_SKINNING\nCCSkin(In.position, In.normal, In.tangent);\n#endif\n}\nuniform highp vec4 cc_cameraPos;\nvarying vec2 v_uv;\nvoid main () {\nStandardVertInput In;\nCCVertInput(In);\nIn.position.xy = cc_cameraPos.w == 0.0 ? vec2(In.position.xy.x, -In.position.xy.y) : In.position.xy;\ngl_Position = In.position;\ngl_Position.y = gl_Position.y;\nv_uv = a_texCoord;\n}",frag:"\nprecision highp float;\nvarying vec2 v_uv;\nuniform mediump vec4 texSize;\nuniform sampler2D bloomTexture;\nvec3 upsample4taps(vec2 uv, vec2 halfpixel) {\nvec3 sum = texture2D(bloomTexture, uv + vec2(-halfpixel.x, halfpixel.y)).xyz;\nsum += texture2D(bloomTexture, uv + vec2(halfpixel.x, halfpixel.y)).xyz;\nsum += texture2D(bloomTexture, uv + vec2(halfpixel.x, -halfpixel.y)).xyz;\nsum += texture2D(bloomTexture, uv + vec2(-halfpixel.x, -halfpixel.y)).xyz;\nreturn sum / 4.0;\n}\nvoid main() {\nvec3 result = upsample4taps(v_uv, 0.5 / texSize.xy).rgb;\ngl_FragColor = vec4(result, 1.0);\n}"},{vert:"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_SKINNING\nattribute vec4 a_joints;\nattribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n#if CC_USE_BAKED_ANIMATION\nattribute highp vec4 a_jointAnimInfo;\n#endif\nattribute vec4 a_matWorld0;\nattribute vec4 a_matWorld1;\nattribute vec4 a_matWorld2;\n#if CC_USE_LIGHTMAP\nattribute vec4 a_lightingMapUVParam;\n#endif\n#if CC_RECEIVE_SHADOW\nattribute vec2 a_localShadowBias;\n#endif\n#elif USE_BATCHING\nattribute float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\nattribute float a_vertexId;\nint getVertexId() {\nreturn int(a_vertexId);\n}\n#endif\n#if CC_USE_MORPH\nuniform vec4 cc_displacementWeights[15];\nuniform vec4 cc_displacementTextureInfo;\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\nreturn texture2D(tex, uv);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture2D(tex, x)),\ndecode32(texture2D(tex, y)),\ndecode32(texture2D(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nuniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nuniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nuniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nnormal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\ntangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\n#if CC_USE_BAKED_ANIMATION\nuniform highp vec4 cc_jointTextureInfo;\nuniform highp vec4 cc_jointAnimInfo;\nuniform highp sampler2D cc_jointTexture;\nvoid CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n{\n#if USE_INSTANCING\nhighp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n#else\nhighp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n#endif\ninvSize = cc_jointTextureInfo.w;\nhighp float tempY = floor(temp * invSize);\nx = floor(temp - tempY * cc_jointTextureInfo.x);\ny = (tempY + 0.5) * invSize;\n}\n#else\nuniform highp vec4 cc_joints[90];\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(3.0, i, x, y, invSize);\nvec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(12.0, i, x, y, invSize);\nvec4 v1 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\nmat4 m = skinMatrix();\nposition = m * position;\nnormal = (m * vec4(normal, 0.0)).xyz;\ntangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n}\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\nIn.position = vec4(a_position, 1.0);\nIn.normal = a_normal;\nIn.tangent = a_tangent;\n#if CC_USE_MORPH\napplyMorph(In.position, In.normal, In.tangent);\n#endif\n#if CC_USE_SKINNING\nCCSkin(In.position, In.normal, In.tangent);\n#endif\n}\nuniform highp vec4 cc_cameraPos;\nvarying vec2 v_uv;\nvoid main () {\nStandardVertInput In;\nCCVertInput(In);\nIn.position.xy = cc_cameraPos.w == 0.0 ? vec2(In.position.xy.x, -In.position.xy.y) : In.position.xy;\ngl_Position = In.position;\ngl_Position.y = gl_Position.y;\nv_uv = a_texCoord;\n}",frag:"\nprecision highp float;\nvarying vec2 v_uv;\nuniform mediump vec4 texSize;\nuniform sampler2D outputResultMap;\nuniform sampler2D bloomTexture;\nvoid main() {\nvec4 hdrColor = texture2D(outputResultMap, v_uv);\nvec3 bloomColor = texture2D(bloomTexture, v_uv).rgb;\nvec3 result = hdrColor.rgb + bloomColor * texSize.w * hdrColor.a;\ngl_FragColor = vec4(result, hdrColor.a);\n}"}],[{vert:"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_SKINNING\nattribute vec4 a_joints;\nattribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n#if CC_USE_BAKED_ANIMATION\nattribute highp vec4 a_jointAnimInfo;\n#endif\nattribute vec4 a_matWorld0;\nattribute vec4 a_matWorld1;\nattribute vec4 a_matWorld2;\n#if CC_USE_LIGHTMAP\nattribute vec4 a_lightingMapUVParam;\n#endif\n#if CC_RECEIVE_SHADOW\nattribute vec2 a_localShadowBias;\n#endif\n#elif USE_BATCHING\nattribute float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\nattribute float a_vertexId;\n#endif\nuniform highp vec4 cc_cameraPos;\nvarying vec2 v_uv;\nvoid main () {\nvec4 position;\nposition = vec4(a_position, 1.0);\nposition.xy = cc_cameraPos.w == 0.0 ? vec2(position.xy.x, -position.xy.y) : position.xy;\ngl_Position = vec4(position.x, position.y, 1.0, 1.0);\nv_uv = a_texCoord;\n}",frag:"\n#ifdef GL_EXT_shader_framebuffer_fetch\n#extension GL_EXT_shader_framebuffer_fetch: enable\n#endif\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives: enable\n#endif\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod: enable\n#endif\nprecision highp float;\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matViewProjInv;\nuniform highp vec4 cc_cameraPos;\nuniform mediump vec4 cc_mainLitDir;\nuniform mediump vec4 cc_mainLitColor;\nuniform mediump vec4 cc_ambientSky;\nuniform mediump vec4 cc_ambientGround;\nuniform mediump vec4 cc_fogColor;\nuniform mediump vec4 cc_fogBase;\nuniform mediump vec4 cc_fogAdd;\nuniform mediump vec4 cc_nearFar;\nuniform mediump vec4 cc_viewPort;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nuniform highp mat4 cc_matLightView;\nuniform highp mat4 cc_matLightViewProj;\nuniform highp vec4 cc_shadowInvProjDepthInfo;\nuniform highp vec4 cc_shadowProjDepthInfo;\nuniform highp vec4 cc_shadowProjInfo;\nuniform mediump vec4 cc_shadowNFLSInfo;\nuniform mediump vec4 cc_shadowWHPBInfo;\nuniform mediump vec4 cc_shadowLPNNInfo;\nhighp float unpackHighpData (float mainPart, float modPart) {\nhighp float data = mainPart;\nreturn data + modPart;\n}\nhighp float unpackHighpData (float mainPart, float modPart, const float modValue) {\nhighp float data = mainPart * modValue;\nreturn data + modPart * modValue;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\nhighp vec2 data = mainPart;\nreturn data + modPart;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\nhighp vec2 data = mainPart * modValue;\nreturn data + modPart * modValue;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\nhighp vec3 data = mainPart;\nreturn data + modPart;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\nhighp vec3 data = mainPart * modValue;\nreturn data + modPart * modValue;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\nhighp vec4 data = mainPart;\nreturn data + modPart;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\nhighp vec4 data = mainPart * modValue;\nreturn data + modPart * modValue;\n}\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\nfloat dist = length(viewPos);\nreturn (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\nvec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\nreturn CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\nuniform highp sampler2D cc_shadowMap;\nuniform highp sampler2D cc_spotLightingMap;\nvec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias)\n{\nvec4 newShadowPos = shadowPos;\nif(normalBias > EPSILON_LOWP)\n{\nvec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);\nif(viewNormal.z < 0.1)\nnewShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n}\nreturn newShadowPos;\n}\nvec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n{\nvec3 viewSpacePos;\nviewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\nviewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;\nviewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\nvec4 clipSpacePos;\nclipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\nclipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\nif (cc_shadowNFLSInfo.z > EPSILON) {\nclipSpacePos.z = CCGetLinearDepthFromViewSpace(viewSpacePos.xyz);\nclipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n}\nreturn clipSpacePos;\n}\nvec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)\n{\nfloat coeffA = cc_shadowProjDepthInfo.x;\nfloat coeffB = cc_shadowProjDepthInfo.y;\nfloat viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\nviewSpacePos_z += viewspaceDepthBias;\nvec4 result = shadowPos;\nresult.z = viewSpacePos_z * coeffA + coeffB;\nreturn result;\n}\nfloat CCGetShadowFactorHard (vec4 shadowPos, float bias) {\nvec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nif (cc_shadowLPNNInfo.y > EPSILON) {\nclosestDepth = dot(texture2D(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n} else {\nclosestDepth = texture2D(cc_shadowMap, clipPos.xy).x;\n}\nshadow = step(clipPos.z, closestDepth);\nreturn shadow;\n}\nfloat CCGetShadowFactorSoft (vec4 shadowPos, float bias) {\nvec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetDepth = clipPos.z;\nvec2 mapSize = cc_shadowWHPBInfo.xy;\nvec2 oneTap = 1.0 / mapSize;\nvec2 clipPos_offset = clipPos.xy + oneTap;\nfloat block0, block1, block2, block3;\nif (cc_shadowLPNNInfo.y > EPSILON) {\nblock0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n} else {\nblock0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\nblock1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\nblock2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\nblock3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n}\nfloat coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block2, block3, coefX);\nfloat coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;\nreturn mix(resultX, resultY, coefY);\n}\nfloat CCGetShadowFactorSoft2X (vec4 shadowPos, float bias) {\nvec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetDepth = clipPos.z;\nvec2 mapSize = cc_shadowWHPBInfo.xy;\nvec2 oneTap = 1.0 / mapSize;\nfloat clipPos_offset_L = clipPos.x - oneTap.x;\nfloat clipPos_offset_R = clipPos.x + oneTap.x;\nfloat clipPos_offset_U = clipPos.y - oneTap.y;\nfloat clipPos_offset_D = clipPos.y + oneTap.y;\nfloat block0, block1, block2, block3, block4, block5, block6, block7, block8;\nif (cc_shadowLPNNInfo.y > EPSILON) {\nblock0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock4 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock5 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock6 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock7 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock8 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n} else {\nblock0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\nblock1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\nblock2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\nblock3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\nblock4 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\nblock5 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\nblock6 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\nblock7 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\nblock8 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n}\nfloat coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\nfloat coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\nfloat shadow = 0.0;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block3, block4, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block1, block2, coefX);\nresultY = mix(block4, block5, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block3, block4, coefX);\nresultY = mix(block6, block7, coefX);\nshadow += mix(resultX, resultY, coefY);\nresultX = mix(block4, block5, coefX);\nresultY = mix(block7, block8, coefX);\nshadow += mix(resultX, resultY, coefY);\nreturn shadow * 0.25;\n}\nfloat CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos, float bias) {\nvec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nfloat depth = clipPos.z;\nif (cc_shadowLPNNInfo.y > EPSILON) {\nclosestDepth = dot(texture2D(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n} else {\nclosestDepth = texture2D(cc_spotLightingMap, clipPos.xy).x;\n}\nshadow = step(depth, closestDepth);\nreturn shadow;\n}\nfloat CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos, float bias) {\nvec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > EPSILON) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nvec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\nvec2 clipPos_offset = clipPos.xy + oneTap;\nfloat block0, block1, block2, block3;\nif (cc_shadowLPNNInfo.y > EPSILON) {\nblock0 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock1 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock2 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock3 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n} else {\nblock0 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\nblock1 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)).x);\nblock2 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)).x);\nblock3 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n}\nfloat coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block2, block3, coefX);\nfloat coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\nreturn mix(resultX, resultY, coefY);\n}\nfloat CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos, float bias) {\nvec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > EPSILON) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nvec2 mapSize = cc_shadowWHPBInfo.xy;\nvec2 oneTap = 1.0 / mapSize;\nfloat clipPos_offset_L = clipPos.x - oneTap.x;\nfloat clipPos_offset_R = clipPos.x + oneTap.x;\nfloat clipPos_offset_U = clipPos.y - oneTap.y;\nfloat clipPos_offset_D = clipPos.y + oneTap.y;\nfloat block0, block1, block2, block3, block4, block5, block6, block7, block8;\nif (cc_shadowLPNNInfo.y > EPSILON) {\nblock0 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock1 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock2 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock3 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock4 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock5 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock6 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock7 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock8 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n} else {\nblock0 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\nblock1 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)).x);\nblock2 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\nblock3 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)).x);\nblock4 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\nblock5 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)).x);\nblock6 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\nblock7 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)).x);\nblock8 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n}\nfloat coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\nfloat coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\nfloat shadow = 0.0;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block3, block4, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block1, block2, coefX);\nresultY = mix(block4, block5, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block3, block4, coefX);\nresultY = mix(block6, block7, coefX);\nshadow += mix(resultX, resultY, coefY);\nresultX = mix(block4, block5, coefX);\nresultY = mix(block7, block8, coefX);\nshadow += mix(resultX, resultY, coefY);\nreturn shadow * 0.25;\n}\nfloat CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n{\nfloat pcf = cc_shadowWHPBInfo.z;\nif (pcf > 1.9) {\nreturn CCGetSpotLightShadowFactorSoft2X(shadowPos, worldPos, shadowBias.x);\n}else if (pcf > 0.9) {\nreturn CCGetSpotLightShadowFactorSoft(shadowPos, worldPos, shadowBias.x);\n}else {\nreturn CCGetSpotLightShadowFactorHard(shadowPos, worldPos, shadowBias.x);\n}\n}\nfloat CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias)\n{\nfloat realtimeShadow = 1.0;\nvec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y);\nfloat pcf = cc_shadowWHPBInfo.z;\nif (pcf > 1.9) {\nrealtimeShadow =  CCGetShadowFactorSoft2X(pos, shadowBias.x);\n}else if (pcf > 0.9) {\nrealtimeShadow = CCGetShadowFactorSoft(pos, shadowBias.x);\n}else {\nrealtimeShadow = CCGetShadowFactorHard(pos, shadowBias.x);\n}\nreturn mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n}\n#endif\n#if CC_USE_IBL\nuniform samplerCube cc_environment;\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n#ifdef GL_EXT_shader_texture_lod\nreturn texture2DLodEXT(tex, coord, lod);\n#else\nreturn texture2D(tex, coord, lod);\n#endif\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n#ifdef GL_EXT_shader_texture_lod\nreturn textureCubeLodEXT(tex, coord, lod);\n#else\nreturn textureCube(tex, coord, lod);\n#endif\n}\nvec3 unpackRGBE (vec4 rgbe) {\nreturn rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n}\n#if CC_USE_DIFFUSEMAP\nuniform samplerCube cc_diffuseMap;\n#endif\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\nvec3 NxH = cross(N, H);\nfloat OneMinusNoHSqr = dot(NxH, NxH);\nfloat a = roughness * roughness;\nfloat n = NoH * a;\nfloat p = a / (OneMinusNoHSqr + n * n);\nreturn p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\nreturn (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\nconst vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\nconst vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\nvec4 r = roughness * c0 + c1;\nfloat a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\nvec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\nAB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\nreturn specular * AB.x + AB.y;\n}\n#if USE_REFLECTION_DENOISE\nvec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n#if CC_USE_IBL\nfloat mip = roughness * mipCount;\nfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\nfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\nvec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);\nvec4 filtered = textureCube(cc_environment, R);\n#if CC_USE_IBL == 2\nbiased.rgb = unpackRGBE(biased);\nfiltered.rgb = unpackRGBE(filtered);\n#else\nbiased.rgb = SRGBToLinear(biased.rgb);\nfiltered.rgb = SRGBToLinear(filtered.rgb);\n#endif\nreturn mix(biased.rgb, filtered.rgb, denoiseIntensity);\n#else\nreturn vec3(0.0, 0.0, 0.0);\n#endif\n}\n#endif\nstruct StandardSurface {\nvec4 albedo;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nvec3 position, position_fract_part;\n#else\nvec3 position;\n#endif\nvec3 normal;\nvec3 emissive;\nvec3 lightmap;\nfloat lightmap_test;\nfloat roughness;\nfloat metallic;\nfloat occlusion;\nfloat specularIntensity;\n#if CC_RECEIVE_SHADOW\nvec2 shadowBias;\n#endif\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.08 * s.specularIntensity), s.albedo.rgb, s.metallic);\nvec3 position;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nposition = unpackHighpData(s.position, s.position_fract_part);\n#else\nposition = s.position;\n#endif\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - position);\nfloat NV = max(abs(dot(N, V)), 0.0);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 L = normalize(-cc_mainLitDir.xyz);\nvec3 H = normalize(L + V);\nfloat NH = max(dot(N, H), 0.0);\nfloat NL = max(dot(N, L), 0.0);\nvec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\nvec3 diffuseContrib = diffuse / PI;\nvec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\nvec3 dirlightContrib = (diffuseContrib + specularContrib);\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW\nif (NL > 0.0 && cc_mainLitDir.w > 0.0) {\nshadow = CCShadowFactorBase(shadowPos, N, s.shadowBias);\n}\n#endif\ndirlightContrib *= shadow;\nfinalColor *= dirlightContrib;\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nif (s.lightmap_test > EPSILON_LOWP) {\nfinalColor = diffuse * s.lightmap.rgb * shadow;\n}\n#endif\nfloat fAmb = 0.5 - N.y * 0.5;\nvec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n#if CC_USE_IBL\n#if CC_USE_DIFFUSEMAP\nvec4 diffuseMap = textureCube(cc_diffuseMap, N);\n#if CC_USE_DIFFUSEMAP == 2\nambDiff = unpackRGBE(diffuseMap);\n#else\nambDiff = SRGBToLinear(diffuseMap.rgb);\n#endif\n#endif\nvec3 R = normalize(reflect(-V, N));\n#if USE_REFLECTION_DENOISE\nvec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);\n#else\nvec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n#if CC_USE_IBL == 2\nvec3 env = unpackRGBE(envmap);\n#else\nvec3 env = SRGBToLinear(envmap.rgb);\n#endif\n#endif\nfinalColor += env * cc_ambientSky.w * specular * s.occlusion;\n#endif\nfinalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;\nfinalColor += s.emissive;\nreturn vec4(finalColor, s.albedo.a);\n}\n#if CC_PIPELINE_TYPE == 0\n#define LIGHTS_PER_PASS 1\n#else\n#define LIGHTS_PER_PASS 10\n#endif\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\nuniform highp vec4 cc_lightPos[LIGHTS_PER_PASS];\nuniform vec4 cc_lightColor[LIGHTS_PER_PASS];\nuniform vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\nuniform vec4 cc_lightDir[LIGHTS_PER_PASS];\n#endif\nfloat SmoothDistAtt (float distSqr, float invSqrAttRadius) {\nfloat factor = distSqr * invSqrAttRadius;\nfloat smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\nreturn smoothFactor * smoothFactor;\n}\nfloat GetDistAtt (float distSqr, float invSqrAttRadius) {\nfloat attenuation = 1.0 / max(distSqr, 0.01*0.01);\nattenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\nreturn attenuation;\n}\nfloat GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\nfloat cd = dot(litDir, L);\nfloat attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\nreturn (attenuation * attenuation);\n}\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\nvec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\nvec3 position;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nposition = unpackHighpData(s.position, s.position_fract_part);\n#else\nposition = s.position;\n#endif\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 diffuseContrib = diffuse / PI;\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - position);\nfloat NV = max(abs(dot(N, V)), 0.0);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 finalColor = vec3(0.0);\nint numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\nfor (int i = 0; i < LIGHTS_PER_PASS; i++) {\nif (i >= numLights) break;\nvec3 SLU = cc_lightPos[i].xyz - position;\nvec3 SL = normalize(SLU);\nvec3 SH = normalize(SL + V);\nfloat SNL = max(dot(N, SL), 0.0);\nfloat SNH = max(dot(N, SH), 0.0);\nfloat distSqr = dot(SLU, SLU);\nfloat litRadius = cc_lightSizeRangeAngle[i].x;\nfloat litRadiusSqr = litRadius * litRadius;\nfloat illum = litRadiusSqr / max(litRadiusSqr, distSqr);\nfloat attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\nattRadiusSqrInv *= attRadiusSqrInv;\nfloat att = GetDistAtt(distSqr, attRadiusSqrInv);\nvec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\nif (cc_lightPos[i].w > 0.0) {\nfloat cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\nfloat cosOuter = cc_lightSizeRangeAngle[i].z;\nfloat litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\nfloat litAngleOffset = -cosOuter * litAngleScale;\natt *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n}\nvec3 lightColor = cc_lightColor[i].rgb;\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW\nif (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\nshadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n}\n#endif\nlightColor *= shadow;\nfinalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n}\nreturn vec4(finalColor, 0.0);\n}\n#endif\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\nreadonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };\nreadonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };\nreadonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };\nstruct CCLight\n{\nvec4 cc_lightPos;\nvec4 cc_lightColor;\nvec4 cc_lightSizeRangeAngle;\nvec4 cc_lightDir;\n};\nstruct Cluster\n{\nvec3 minBounds;\nvec3 maxBounds;\n};\nstruct LightGrid\n{\nuint offset;\nuint ccLights;\n};\nCCLight getCCLight(uint i)\n{\nCCLight light;\nlight.cc_lightPos = b_ccLights[4u * i + 0u];\nlight.cc_lightColor = b_ccLights[4u * i + 1u];\nlight.cc_lightSizeRangeAngle = b_ccLights[4u * i + 2u];\nlight.cc_lightDir = b_ccLights[4u * i + 3u];\nreturn light;\n}\nLightGrid getLightGrid(uint cluster)\n{\nuvec4 gridvec = b_clusterLightGrid[cluster];\nLightGrid grid;\ngrid.offset = gridvec.x;\ngrid.ccLights = gridvec.y;\nreturn grid;\n}\nuint getGridLightIndex(uint start, uint offset)\n{\nreturn b_clusterLightIndices[start + offset];\n}\nuint getClusterZIndex(vec4 worldPos)\n{\nfloat scale = float(24) / log(cc_nearFar.y / cc_nearFar.x);\nfloat bias = -(float(24) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));\nfloat eyeDepth = -(cc_matView * worldPos).z;\nuint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));\nreturn zIndex;\n}\nuint getClusterIndex(vec4 fragCoord, vec4 worldPos)\n{\nuint zIndex = getClusterZIndex(worldPos);\nfloat clusterSizeX = ceil(cc_viewPort.z / float(16));\nfloat clusterSizeY = ceil(cc_viewPort.w / float(8));\nuvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);\nuint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;\nreturn cluster;\n}\nvec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 diffuseContrib = diffuse / PI;\nvec3 position;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nposition = unpackHighpData(s.position, s.position_fract_part);\n#else\nposition = s.position;\n#endif\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - position);\nfloat NV = max(abs(dot(N, V)), 0.001);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 finalColor = vec3(0.0);\nuint cluster = getClusterIndex(gl_FragCoord, vec4(position, 1.0));\nLightGrid grid = getLightGrid(cluster);\nuint numLights = grid.ccLights;\nfor (uint i = 0u; i < 100u; i++) {\nif (i >= numLights) break;\nuint lightIndex = getGridLightIndex(grid.offset, i);\nCCLight light = getCCLight(lightIndex);\nvec3 SLU = light.cc_lightPos.xyz - position;\nvec3 SL = normalize(SLU);\nvec3 SH = normalize(SL + V);\nfloat SNL = max(dot(N, SL), 0.001);\nfloat SNH = max(dot(N, SH), 0.0);\nfloat distSqr = dot(SLU, SLU);\nfloat litRadius = light.cc_lightSizeRangeAngle.x;\nfloat litRadiusSqr = litRadius * litRadius;\nfloat illum = PI * (litRadiusSqr / max(litRadiusSqr , distSqr));\nfloat attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);\nattRadiusSqrInv *= attRadiusSqrInv;\nfloat att = GetDistAtt(distSqr, attRadiusSqrInv);\nvec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\nif (light.cc_lightPos.w > 0.0) {\nfloat cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);\nfloat cosOuter = light.cc_lightSizeRangeAngle.z;\nfloat litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\nfloat litAngleOffset = -cosOuter * litAngleScale;\natt *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);\n}\nvec3 lightColor = light.cc_lightColor.rgb;\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW\nif (light.cc_lightPos.w > 0.0) {\nshadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n}\n#endif\nlightColor *= shadow;\nfinalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);\n}\nreturn vec4(finalColor, 0.0);\n}\n#endif\nvec3 ACESToneMap (vec3 color) {\ncolor = min(color, vec3(8.0));\nconst float A = 2.51;\nconst float B = 0.03;\nconst float C = 2.43;\nconst float D = 0.59;\nconst float E = 0.14;\nreturn (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n#if CC_USE_HDR\ncolor.rgb = ACESToneMap(color.rgb);\n#endif\ncolor.rgb = sqrt(color.rgb);\nreturn color;\n}\nfloat LinearFog(vec4 pos) {\nvec4 wPos = pos;\nfloat cam_dis = distance(cc_cameraPos, wPos);\nfloat fogStart = cc_fogBase.x;\nfloat fogEnd = cc_fogBase.y;\nreturn clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * fogDensity);\nreturn f;\n}\nfloat ExpSquaredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\nreturn f;\n}\nfloat LayeredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat _FogTop = cc_fogAdd.x;\nfloat _FogRange = cc_fogAdd.y;\nvec3 camWorldProj = cc_cameraPos.xyz;\ncamWorldProj.y = 0.;\nvec3 worldPosProj = wPos.xyz;\nworldPosProj.y = 0.;\nfloat fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\nfloat fDeltaY, fDensityIntegral;\nif (cc_cameraPos.y > _FogTop) {\nif (wPos.y < _FogTop) {\nfDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\nfDensityIntegral = fDeltaY * fDeltaY * 0.5;\n} else {\nfDeltaY = 0.;\nfDensityIntegral = 0.;\n}\n} else {\nif (wPos.y < _FogTop) {\nfloat fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfloat fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\nfDeltaY = abs(fDeltaA - fDeltaB);\nfDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n} else {\nfDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n}\n}\nfloat fDensity;\nif (fDeltaY != 0.) {\nfDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n} else {\nfDensity = 0.;\n}\nfloat f = exp(-fDensity);\nreturn f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\nfactor = LinearFog(pos);\n#elif CC_USE_FOG == 1\nfactor = ExpFog(pos);\n#elif CC_USE_FOG == 2\nfactor = ExpSquaredFog(pos);\n#elif CC_USE_FOG == 3\nfactor = LayeredFog(pos);\n#else\nfactor = 1.0;\n#endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\ncolor = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\nvec2 signNotZero(vec2 v) {\nreturn vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n}\nvec3 oct_to_float32x3(vec2 e) {\nvec3 v = vec3(e.xy, 1.0 - abs(e.x) - abs(e.y));\nif (v.z < 0.0) v.xy = (1.0 - abs(v.yx)) * signNotZero(v.xy);\nreturn normalize(v);\n}\nvec4 screen2WS(vec3 coord) {\nvec3 ndc = vec3(\n2.0 * (coord.x - cc_viewPort.x) / cc_viewPort.z - 1.0,\n2.0 * (coord.y - cc_viewPort.y) / cc_viewPort.w - 1.0,\n2.0 * coord.z - 1.0);\nvec4 world = ((cc_matViewProjInv) * (vec4(ndc, 1.0)));\nworld      = world / world.w;\nreturn world;\n}\nvarying vec2 v_uv;\n#if CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT\nuniform sampler2D depth_stencil;\n#else\nuniform sampler2D gbuffer_albedoMap;\nuniform sampler2D gbuffer_normalMap;\nuniform sampler2D gbuffer_emissiveMap;\nuniform sampler2D depth_stencil;\n#endif\n#if !CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT || __VERSION__ >= 450\n#endif\nvoid main () {\nStandardSurface s;\n#if CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT\nvec4 albedoMap = gl_LastFragData[0];\nvec4 normalMap = gl_LastFragData[1];\nvec4 emissiveMap = gl_LastFragData[2];\nfloat depth = texture2D(depth_stencil, v_uv).x;\n#else\nvec4 albedoMap = texture2D(gbuffer_albedoMap,v_uv);\nvec4 normalMap = texture2D(gbuffer_normalMap,v_uv);\nvec4 emissiveMap = texture2D(gbuffer_emissiveMap,v_uv);\nfloat depth = texture2D(depth_stencil, v_uv).x;\n#endif\ns.albedo = albedoMap;\nvec3 position = screen2WS(vec3(gl_FragCoord.xy, depth)).xyz;\ns.position = position;\ns.roughness = normalMap.z;\ns.normal = oct_to_float32x3(normalMap.xy);\ns.specularIntensity = 0.5;\ns.metallic = normalMap.w;\ns.emissive = emissiveMap.xyz;\ns.occlusion = emissiveMap.w;\nfloat fogFactor;\nCC_TRANSFER_FOG_BASE(vec4(position, 1), fogFactor);\nvec4 shadowPos;\nshadowPos = cc_matLightViewProj * vec4(position, 1);\nvec4 color = CCStandardShadingBase(s, shadowPos) +\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\nCCClusterShadingAdditive(s, shadowPos);\n#else\nCCStandardShadingAdditive(s, shadowPos);\n#endif\nCC_APPLY_FOG_BASE(color, fogFactor);\ncolor = CCFragOutput(color);\n#if CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT\ngl_FragData[2] = color;\n#else\ngl_FragColor = color;\n#endif\n}"}],[{vert:"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_SKINNING\nattribute vec4 a_joints;\nattribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n#if CC_USE_BAKED_ANIMATION\nattribute highp vec4 a_jointAnimInfo;\n#endif\nattribute vec4 a_matWorld0;\nattribute vec4 a_matWorld1;\nattribute vec4 a_matWorld2;\n#if CC_USE_LIGHTMAP\nattribute vec4 a_lightingMapUVParam;\n#endif\n#if CC_RECEIVE_SHADOW\nattribute vec2 a_localShadowBias;\n#endif\n#elif USE_BATCHING\nattribute float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\nattribute float a_vertexId;\nint getVertexId() {\nreturn int(a_vertexId);\n}\n#endif\n#if CC_USE_MORPH\nuniform vec4 cc_displacementWeights[15];\nuniform vec4 cc_displacementTextureInfo;\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\nreturn texture2D(tex, uv);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture2D(tex, x)),\ndecode32(texture2D(tex, y)),\ndecode32(texture2D(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nuniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nuniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nuniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nnormal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\ntangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\n#if CC_USE_BAKED_ANIMATION\nuniform highp vec4 cc_jointTextureInfo;\nuniform highp vec4 cc_jointAnimInfo;\nuniform highp sampler2D cc_jointTexture;\nvoid CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n{\n#if USE_INSTANCING\nhighp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n#else\nhighp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n#endif\ninvSize = cc_jointTextureInfo.w;\nhighp float tempY = floor(temp * invSize);\nx = floor(temp - tempY * cc_jointTextureInfo.x);\ny = (tempY + 0.5) * invSize;\n}\n#else\nuniform highp vec4 cc_joints[90];\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(3.0, i, x, y, invSize);\nvec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(12.0, i, x, y, invSize);\nvec4 v1 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\nmat4 m = skinMatrix();\nposition = m * position;\nnormal = (m * vec4(normal, 0.0)).xyz;\ntangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n}\n#endif\nvoid CCVertInput(inout vec4 In)\n{\nIn = vec4(a_position, 1.0);\n#if CC_USE_MORPH\napplyMorph(In);\n#endif\n#if CC_USE_SKINNING\nCCSkin(In);\n#endif\n}\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matProj;\nuniform highp vec4 cc_cameraPos;\nuniform mediump vec4 cc_mainLitDir;\n#if !USE_INSTANCING\n#if USE_BATCHING\nuniform highp mat4 cc_matWorlds[10];\n#else\nuniform highp mat4 cc_matWorld;\n#endif\n#endif\nvoid CCGetWorldMatrix(out mat4 matWorld)\n{\n#if USE_INSTANCING\nmatWorld = mat4(\nvec4(a_matWorld0.xyz, 0.0),\nvec4(a_matWorld1.xyz, 0.0),\nvec4(a_matWorld2.xyz, 0.0),\nvec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n);\n#elif USE_BATCHING\nmatWorld = cc_matWorlds[int(a_dyn_batch_id)];\n#else\nmatWorld = cc_matWorld;\n#endif\n}\nuniform mediump vec4 cc_planarNDInfo;\nvarying float v_dist;\nvec4 vert () {\nvec4 position;\nCCVertInput(position);\nmat4 matWorld;\nCCGetWorldMatrix(matWorld);\nvec3 P = (matWorld * position).xyz;\nvec3 L = cc_mainLitDir.xyz;\nvec3 N = cc_planarNDInfo.xyz;\nfloat d = cc_planarNDInfo.w + 0.001;\nfloat dist = (-d - dot(P, N)) / (dot(L, N) + 0.0001);\nvec3 shadowPos = P + L * dist;\nvec3 view = normalize(cc_cameraPos.xyz - shadowPos);\nfloat viewLength = length(cc_cameraPos.xyz - shadowPos);\nshadowPos += view * min(1.0, 0.005 * viewLength);\nposition = cc_matProj * cc_matView * vec4(shadowPos, 1.0);\nv_dist = dist;\nreturn position;\n}\nvoid main() { gl_Position = vert(); }",frag:"\nprecision mediump float;\nuniform lowp vec4 cc_shadowColor;\nvec4 CCFragOutput (vec4 color) {\nreturn color;\n}\nvarying float v_dist;\nvec4 frag () {\nif(v_dist < 0.0)\ndiscard;\nreturn CCFragOutput(cc_shadowColor);\n}\nvoid main() { gl_FragColor = frag(); }"}],[{vert:"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_SKINNING\nattribute vec4 a_joints;\nattribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n#if CC_USE_BAKED_ANIMATION\nattribute highp vec4 a_jointAnimInfo;\n#endif\nattribute vec4 a_matWorld0;\nattribute vec4 a_matWorld1;\nattribute vec4 a_matWorld2;\n#if CC_USE_LIGHTMAP\nattribute vec4 a_lightingMapUVParam;\n#endif\n#if CC_RECEIVE_SHADOW\nattribute vec2 a_localShadowBias;\n#endif\n#elif USE_BATCHING\nattribute float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\nattribute float a_vertexId;\nint getVertexId() {\nreturn int(a_vertexId);\n}\n#endif\n#if CC_USE_MORPH\nuniform vec4 cc_displacementWeights[15];\nuniform vec4 cc_displacementTextureInfo;\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\nreturn texture2D(tex, uv);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture2D(tex, x)),\ndecode32(texture2D(tex, y)),\ndecode32(texture2D(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nuniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nuniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nuniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nnormal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\ntangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\n#if CC_USE_BAKED_ANIMATION\nuniform highp vec4 cc_jointTextureInfo;\nuniform highp vec4 cc_jointAnimInfo;\nuniform highp sampler2D cc_jointTexture;\nvoid CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n{\n#if USE_INSTANCING\nhighp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n#else\nhighp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n#endif\ninvSize = cc_jointTextureInfo.w;\nhighp float tempY = floor(temp * invSize);\nx = floor(temp - tempY * cc_jointTextureInfo.x);\ny = (tempY + 0.5) * invSize;\n}\n#else\nuniform highp vec4 cc_joints[90];\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(3.0, i, x, y, invSize);\nvec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(12.0, i, x, y, invSize);\nvec4 v1 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\nmat4 m = skinMatrix();\nposition = m * position;\nnormal = (m * vec4(normal, 0.0)).xyz;\ntangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n}\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\nIn.position = vec4(a_position, 1.0);\nIn.normal = a_normal;\nIn.tangent = a_tangent;\n#if CC_USE_MORPH\napplyMorph(In.position, In.normal, In.tangent);\n#endif\n#if CC_USE_SKINNING\nCCSkin(In.position, In.normal, In.tangent);\n#endif\n}\nuniform highp vec4 cc_cameraPos;\nvarying vec2 v_uv;\nvoid main () {\nStandardVertInput In;\nCCVertInput(In);\nIn.position.xy = cc_cameraPos.w == 0.0 ? vec2(In.position.xy.x, -In.position.xy.y) : In.position.xy;\ngl_Position = In.position;\ngl_Position.y = gl_Position.y;\nv_uv = a_texCoord;\n}",frag:"\nprecision highp float;\nuniform mediump vec4 cc_screenSize;\n#if ANTIALIAS_TYPE == 1\nvec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 resolution,\nvec2 v_rgbNW, vec2 v_rgbNE,\nvec2 v_rgbSW, vec2 v_rgbSE,\nvec2 v_rgbM) {\nvec4 color;\nmediump vec2 inverseVP = vec2(1.0 / resolution.x, 1.0 / resolution.y);\nvec3 rgbNW = texture2D(tex, v_rgbNW).xyz;\nvec3 rgbNE = texture2D(tex, v_rgbNE).xyz;\nvec3 rgbSW = texture2D(tex, v_rgbSW).xyz;\nvec3 rgbSE = texture2D(tex, v_rgbSE).xyz;\nvec4 texColor = texture2D(tex, v_rgbM);\nvec3 rgbM  = texColor.xyz;\nvec3 luma = vec3(0.299, 0.587, 0.114);\nfloat lumaNW = dot(rgbNW, luma);\nfloat lumaNE = dot(rgbNE, luma);\nfloat lumaSW = dot(rgbSW, luma);\nfloat lumaSE = dot(rgbSE, luma);\nfloat lumaM  = dot(rgbM,  luma);\nfloat lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\nfloat lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\nmediump vec2 dir;\ndir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\ndir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\nfloat dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n(0.25 * (1.0 / 8.0)), (1.0/ 128.0));\nfloat rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\ndir = min(vec2(8.0, 8.0),\nmax(vec2(-8.0, -8.0),\ndir * rcpDirMin)) * inverseVP;\nvec3 rgbA = 0.5 * (\ntexture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +\ntexture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\nvec3 rgbB = rgbA * 0.5 + 0.25 * (\ntexture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +\ntexture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);\nfloat lumaB = dot(rgbB, luma);\nif ((lumaB < lumaMin) || (lumaB > lumaMax))\ncolor = vec4(rgbA, texColor.a);\nelse\ncolor = vec4(rgbB, texColor.a);\nreturn color;\n}\n#endif\nvarying vec2 v_uv;\nuniform sampler2D outputResultMap;\nvoid texcoords(vec2 fragCoord, vec2 resolution,\nout vec2 v_rgbNW, out vec2 v_rgbNE,\nout vec2 v_rgbSW, out vec2 v_rgbSE,\nout vec2 v_rgbM) {\nvec2 inverseVP = 1.0 / resolution.xy;\nv_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\nv_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\nv_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\nv_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\nv_rgbM = vec2(fragCoord * inverseVP);\n}\nvoid main () {\nmediump vec2 v_rgbNW;\nmediump vec2 v_rgbNE;\nmediump vec2 v_rgbSW;\nmediump vec2 v_rgbSE;\nmediump vec2 v_rgbM;\n#if ANTIALIAS_TYPE == 1\nvec2 resolution = cc_screenSize.xy;\nvec2 fragCoord = v_uv * resolution;\ntexcoords(fragCoord, resolution, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\ngl_FragColor = fxaa(outputResultMap, fragCoord, resolution, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n#else\ngl_FragColor = texture2D(outputResultMap, v_uv);\n#endif\n}"}],[{vert:"\nprecision highp float;\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matProj;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_SKINNING\nattribute vec4 a_joints;\nattribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n#if CC_USE_BAKED_ANIMATION\nattribute highp vec4 a_jointAnimInfo;\n#endif\nattribute vec4 a_matWorld0;\nattribute vec4 a_matWorld1;\nattribute vec4 a_matWorld2;\n#if CC_USE_LIGHTMAP\nattribute vec4 a_lightingMapUVParam;\n#endif\n#if CC_RECEIVE_SHADOW\nattribute vec2 a_localShadowBias;\n#endif\n#elif USE_BATCHING\nattribute float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\nattribute float a_vertexId;\n#endif\nvarying mediump vec4 viewDir;\nvec4 vert () {\nviewDir = vec4(a_position, 1.0);\nmat4 matViewRotOnly = mat4(mat3(cc_matView));\nvec4 pos = matViewRotOnly * viewDir;\nif (cc_matProj[3].w > 0.0) {\nmat4 matProj = cc_matProj;\nmatProj[0].x = 5.2;\nmatProj[1].y = 2.6;\nmatProj[2].zw = vec2(-1.0);\nmatProj[3].zw = vec2(0.0);\npos = matProj * pos;\n} else {\npos = cc_matProj * pos;\n}\npos.z = 0.99999 * pos.w;\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",frag:"\nprecision mediump float;\nuniform mediump vec4 cc_ambientSky;\nuniform samplerCube cc_environment;\nvec3 unpackRGBE (vec4 rgbe) {\nreturn rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n}\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nvec3 ACESToneMap (vec3 color) {\ncolor = min(color, vec3(8.0));\nconst float A = 2.51;\nconst float B = 0.03;\nconst float C = 2.43;\nconst float D = 0.59;\nconst float E = 0.14;\nreturn (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n#if CC_USE_HDR\ncolor.rgb = ACESToneMap(color.rgb);\n#endif\ncolor.rgb = sqrt(color.rgb);\nreturn color;\n}\nvarying mediump vec4 viewDir;\nvec4 frag () {\n#if USE_RGBE_CUBEMAP\nvec3 c = unpackRGBE(textureCube(cc_environment, viewDir.xyz));\n#else\nvec3 c = SRGBToLinear(textureCube(cc_environment, viewDir.xyz).rgb);\n#endif\nreturn CCFragOutput(vec4(c * cc_ambientSky.w, 1.0));\n}\nvoid main() { gl_FragColor = frag(); }"}],[{vert:"\nprecision mediump float;\nuniform highp mat4 cc_matProj;\nattribute vec3 a_position;\nattribute vec4 a_color;\nvarying vec2 v_uv;\nuniform vec4 offset;\nuniform vec4 digits[20];\nfloat getComponent(vec4 v, float i) {\nif (i < 1.0) { return v.x; }\nelse if (i < 2.0) { return v.y; }\nelse if (i < 3.0) { return v.z; }\nelse { return v.w; }\n}\nvec4 vert () {\nmat2 proj = mat2(cc_matProj[0].xy, cc_matProj[1].xy);\nproj /= abs(proj[1].x + proj[1].y);\nvec2 position = proj * a_position.xy + offset.xy;\nv_uv = a_color.xy;\nif (a_color.z >= 0.0) {\nfloat n = getComponent(digits[int(a_color.z)], a_color.w);\nv_uv += vec2(offset.z * n, 0.0);\n}\nreturn vec4(position, 0.0, 1.0);\n}\nvoid main() { gl_Position = vert(); }",frag:"\nprecision mediump float;\nvec4 CCFragOutput (vec4 color) {\nreturn color;\n}\nvarying vec2 v_uv;\nuniform sampler2D mainTexture;\nvec4 frag () {\nreturn CCFragOutput(texture2D(mainTexture, v_uv));\n}\nvoid main() { gl_FragColor = frag(); }"}],[{vert:"\nprecision mediump float;\nattribute vec2 a_position;\nattribute vec2 a_texCoord;\nvarying vec2 v_uv;\nuniform vec4 u_buffer0;\nuniform vec4 u_buffer1;\nuniform mat4 u_projection;\nvec4 vert () {\nvec2 worldPos = a_position * u_buffer1.xy + u_buffer1.zw;\nvec2 clipSpace = worldPos / u_buffer0.xy * 2.0 - 1.0;\nvec4 screenPos = u_projection * vec4(clipSpace, 0.0, 1.0);\nv_uv = a_texCoord;\nreturn screenPos;\n}\nvoid main() { gl_Position = vert(); }",frag:"\nprecision mediump float;\nvarying vec2 v_uv;\nuniform float u_percent;\nuniform sampler2D mainTexture;\nvec4 frag () {\nvec4 color = texture2D(mainTexture, v_uv);\nfloat percent = clamp(u_percent, 0.0, 1.0);\ncolor.xyz *= percent;\nreturn color;\n}\nvoid main() { gl_FragColor = frag(); }"}]],glsl3:[[{vert:"\nprecision mediump float;\nlayout(std140) uniform Constants {\nvec4 mainTiling_Offset;\nvec4 frameTile_velLenScale;\nvec4 scale;\nvec4 nodeRotation;\n};\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\nhighp vec4 cc_localShadowBias;\n};\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\nmat3 m = mat3(xAxis,yAxis,zAxis);\nfloat trace = m[0][0] + m[1][1] + m[2][2];\nvec4 quat;\nif (trace > 0.) {\nfloat s = 0.5 / sqrt(trace + 1.0);\nquat.w = 0.25 / s;\nquat.x = (m[2][1] - m[1][2]) * s;\nquat.y = (m[0][2] - m[2][0]) * s;\nquat.z = (m[1][0] - m[0][1]) * s;\n} else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\nfloat s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\nquat.w = (m[2][1] - m[1][2]) / s;\nquat.x = 0.25 * s;\nquat.y = (m[0][1] + m[1][0]) / s;\nquat.z = (m[0][2] + m[2][0]) / s;\n} else if (m[1][1] > m[2][2]) {\nfloat s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\nquat.w = (m[0][2] - m[2][0]) / s;\nquat.x = (m[0][1] + m[1][0]) / s;\nquat.y = 0.25 * s;\nquat.z = (m[1][2] + m[2][1]) / s;\n} else {\nfloat s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\nquat.w = (m[1][0] - m[0][1]) / s;\nquat.x = (m[0][2] + m[2][0]) / s;\nquat.y = (m[1][2] + m[2][1]) / s;\nquat.z = 0.25 * s;\n}\nfloat len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\nif (len > 0.) {\nlen = 1. / sqrt(len);\nquat.x = quat.x * len;\nquat.y = quat.y * len;\nquat.z = quat.z * len;\nquat.w = quat.w * len;\n}\nreturn quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\nfloat x = angle.x / 2.;\nfloat y = angle.y / 2.;\nfloat z = angle.z / 2.;\nfloat sx = sin(x);\nfloat cx = cos(x);\nfloat sy = sin(y);\nfloat cy = cos(y);\nfloat sz = sin(z);\nfloat cz = cos(z);\nvec4 quat = vec4(0);\nquat.x = sx * cy * cz + cx * sy * sz;\nquat.y = cx * sy * cz + sx * cy * sz;\nquat.z = cx * cy * sz - sx * sy * cz;\nquat.w = cx * cy * cz - sx * sy * sz;\nreturn quat;\n}\nvec4 quatMultiply (vec4 a, vec4 b){\nvec4 quat;\nquat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\nquat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\nquat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\nquat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\nreturn quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\nfloat ix = q.w * v.x + q.y * v.z - q.z * v.y;\nfloat iy = q.w * v.y + q.z * v.x - q.x * v.z;\nfloat iz = q.w * v.z + q.x * v.y - q.y * v.x;\nfloat iw = -q.x * v.x - q.y * v.y - q.z * v.z;\nv.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\nv.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\nv.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\nvec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\nvec4 rotQuat = quatMultiply(viewQuat, q);\nrotateVecFromQuat(pos, rotQuat);\nreturn pos;\n}\nout mediump vec2 uv;\nout mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n, mat4 viewInv\n) {\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nvec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\nvec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\nvec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\npos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n}\nin vec3 a_position;\nin vec2 a_texCoord;\nin vec4 a_color;\nlayout(std140) uniform builtin {\nvec4 cc_size_rotation;\n};\nvec4 vs_main() {\nvec4 pos = vec4(a_position, 1);\npos = cc_matWorld * pos;\nvec2 vertOffset = a_texCoord.xy - 0.5;\ncomputeVertPos(pos, vertOffset, quaternionFromEuler(vec3(0., 0., cc_size_rotation.z)), vec3(cc_size_rotation.xy, 0.), cc_matViewInv);\npos = cc_matViewProj * pos;\nuv = a_texCoord.xy;\ncolor = a_color;\nreturn pos;\n}\nvoid main() { gl_Position = vs_main(); }",frag:"\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\nreturn color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nlayout(std140) uniform FragConstants {\nvec4 tintColor;\n};\nvec4 add () {\nvec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\nreturn CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }"}],[{vert:"\nprecision highp float;\nin vec3 a_position;\nvec4 vert () {\nvec4 pos = vec4(a_position, 1);\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",frag:"\nprecision highp float;\nvec4 frag () {\nvec4 o = vec4(1.0);\nreturn o;\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"}],[{vert:"\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nin highp vec3 a_position;\nin vec4 a_color;\nout vec4 v_color;\nvec4 vert () {\nvec4 pos = cc_matViewProj * vec4(a_position, 1);\npos.z -= 0.000001;\nv_color = a_color;\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",frag:"\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\nreturn color;\n}\nin vec4 v_color;\nvec4 front() {\n#if USE_FORWARD_PIPELINE\nreturn CCFragOutput(v_color);\n#else\nreturn v_color;\n#endif\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = front(); }"},{vert:"\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nin highp vec3 a_position;\nin vec4 a_color;\nout vec4 v_color;\nvec4 vert () {\nvec4 pos = cc_matViewProj * vec4(a_position, 1);\npos.z -= 0.000001;\nv_color = a_color;\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",frag:"\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\nreturn color;\n}\nin vec4 v_color;\nvec4 back() {\n#if USE_FORWARD_PIPELINE\nreturn CCFragOutput(vec4(v_color.rgb, v_color.a * 0.2));\n#else\nreturn vec4(v_color.rgb, v_color.a * 0.2);\n#endif\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = back(); }"},{vert:"\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nin highp vec3 a_position;\nin vec4 a_color;\nout vec4 v_color;\nout float v_distance;\nvec4 vert () {\nvec4 pos = cc_matViewProj * vec4(a_position, 1);\npos.z -= 0.000001;\nv_color = a_color;\nv_distance = dot(a_position, vec3(1.0, 1.0, 1.0));\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",frag:"\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\nreturn color;\n}\nin vec4 v_color;\nin float v_distance;\nvec4 front() {\nif (fract(v_distance) > 0.5) {\ndiscard;\n}\n#if USE_FORWARD_PIPELINE\nreturn CCFragOutput(v_color);\n#else\nreturn v_color;\n#endif\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = front(); }"},{vert:"\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nin highp vec3 a_position;\nin vec4 a_color;\nout vec4 v_color;\nout float v_distance;\nvec4 vert () {\nvec4 pos = cc_matViewProj * vec4(a_position, 1);\npos.z -= 0.000001;\nv_color = a_color;\nv_distance = dot(a_position, vec3(1.0, 1.0, 1.0));\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",frag:"\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\nreturn color;\n}\nin vec4 v_color;\nin float v_distance;\nvec4 back() {\nif (fract(v_distance) > 0.5) {\ndiscard;\n}\n#if USE_FORWARD_PIPELINE\nreturn CCFragOutput(vec4(v_color.rgb, v_color.a * 0.2));\n#else\nreturn vec4(v_color.rgb, v_color.a * 0.2);\n#endif\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = back(); }"},{vert:"\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nin highp vec3 a_position;\nin vec4 a_normal;\nin vec4 a_color;\nout vec4 v_color;\nvec4 vert () {\nvec4 pos = cc_matViewProj * vec4(a_position, 1);\nv_color = a_color;\nfloat intensity = dot(vec3(1, 2, 4), a_normal.xyz);\nv_color.rgb -= a_normal.w * intensity * 0.1;\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",frag:"\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\nreturn color;\n}\nin vec4 v_color;\nvec4 front() {\n#if USE_FORWARD_PIPELINE\nreturn CCFragOutput(v_color);\n#else\nreturn v_color;\n#endif\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = front(); }"},{vert:"\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nin highp vec3 a_position;\nin vec4 a_normal;\nin vec4 a_color;\nout vec4 v_color;\nvec4 vert () {\nvec4 pos = cc_matViewProj * vec4(a_position, 1);\nv_color = a_color;\nfloat intensity = dot(vec3(1, 2, 4), a_normal.xyz);\nv_color.rgb -= a_normal.w * intensity * 0.1;\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",frag:"\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\nreturn color;\n}\nin vec4 v_color;\nvec4 back() {\n#if USE_FORWARD_PIPELINE\nreturn CCFragOutput(vec4(v_color.rgb, v_color.a * 0.2));\n#else\nreturn vec4(v_color.rgb, v_color.a * 0.2);\n#endif\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = back(); }"}],[{vert:"\nprecision highp float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\nhighp vec4 cc_localShadowBias;\n};\nin vec3 a_position;\nin vec4 a_color;\nout vec4 v_color;\nin float a_dist;\nout float v_dist;\nvec4 vert () {\nvec4 pos = vec4(a_position, 1);\npos = cc_matViewProj * cc_matWorld * pos;\nv_color = a_color;\nv_dist = a_dist;\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",frag:"\nprecision highp float;\nin vec4 v_color;\nin float v_dist;\nvec4 frag () {\nvec4 o = v_color;\nfloat aa = fwidth(v_dist);\nfloat alpha = 1. - smoothstep(-aa, 0., abs(v_dist) - 1.0);\no.rgb *= o.a;\no *= alpha;\nreturn o;\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"}],[{vert:"\nprecision highp float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCWorldBound {\nhighp vec4 cc_worldBoundCenter;\nhighp vec4 cc_worldBoundHalfExtents;\n};\nin vec3 a_position;\nvec4 vert () {\nvec4 position;\nposition = vec4(a_position, 1.0);\nposition *= cc_worldBoundHalfExtents;\nposition += cc_worldBoundCenter;\nposition = cc_matViewProj * position;\nreturn position;\n}\nvoid main() { gl_Position = vert(); }",frag:"\nprecision mediump float;\nvec4 frag () {\nreturn vec4(1, 0, 0, 1);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"}],[{vert:"\nprecision mediump float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\nmat3 m = mat3(xAxis,yAxis,zAxis);\nfloat trace = m[0][0] + m[1][1] + m[2][2];\nvec4 quat;\nif (trace > 0.) {\nfloat s = 0.5 / sqrt(trace + 1.0);\nquat.w = 0.25 / s;\nquat.x = (m[2][1] - m[1][2]) * s;\nquat.y = (m[0][2] - m[2][0]) * s;\nquat.z = (m[1][0] - m[0][1]) * s;\n} else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\nfloat s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\nquat.w = (m[2][1] - m[1][2]) / s;\nquat.x = 0.25 * s;\nquat.y = (m[0][1] + m[1][0]) / s;\nquat.z = (m[0][2] + m[2][0]) / s;\n} else if (m[1][1] > m[2][2]) {\nfloat s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\nquat.w = (m[0][2] - m[2][0]) / s;\nquat.x = (m[0][1] + m[1][0]) / s;\nquat.y = 0.25 * s;\nquat.z = (m[1][2] + m[2][1]) / s;\n} else {\nfloat s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\nquat.w = (m[1][0] - m[0][1]) / s;\nquat.x = (m[0][2] + m[2][0]) / s;\nquat.y = (m[1][2] + m[2][1]) / s;\nquat.z = 0.25 * s;\n}\nfloat len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\nif (len > 0.) {\nlen = 1. / sqrt(len);\nquat.x = quat.x * len;\nquat.y = quat.y * len;\nquat.z = quat.z * len;\nquat.w = quat.w * len;\n}\nreturn quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\nfloat x = angle.x / 2.;\nfloat y = angle.y / 2.;\nfloat z = angle.z / 2.;\nfloat sx = sin(x);\nfloat cx = cos(x);\nfloat sy = sin(y);\nfloat cy = cos(y);\nfloat sz = sin(z);\nfloat cz = cos(z);\nvec4 quat = vec4(0);\nquat.x = sx * cy * cz + cx * sy * sz;\nquat.y = cx * sy * cz + sx * cy * sz;\nquat.z = cx * cy * sz - sx * sy * cz;\nquat.w = cx * cy * cz - sx * sy * sz;\nreturn quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\nfloat x2 = q.x + q.x;\nfloat y2 = q.y + q.y;\nfloat z2 = q.z + q.z;\nfloat xx = q.x * x2;\nfloat xy = q.x * y2;\nfloat xz = q.x * z2;\nfloat yy = q.y * y2;\nfloat yz = q.y * z2;\nfloat zz = q.z * z2;\nfloat wx = q.w * x2;\nfloat wy = q.w * y2;\nfloat wz = q.w * z2;\nreturn mat4(\n1. - (yy + zz), xy + wz, xz - wy, 0,\nxy - wz, 1. - (xx + zz), yz + wx, 0,\nxz + wy, yz - wx, 1. - (xx + yy), 0,\np.x, p.y, p.z, 1\n);\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\nfloat x = q.x, y = q.y, z = q.z, w = q.w;\nfloat x2 = x + x;\nfloat y2 = y + y;\nfloat z2 = z + z;\nfloat xx = x * x2;\nfloat xy = x * y2;\nfloat xz = x * z2;\nfloat yy = y * y2;\nfloat yz = y * z2;\nfloat zz = z * z2;\nfloat wx = w * x2;\nfloat wy = w * y2;\nfloat wz = w * z2;\nfloat sx = s.x;\nfloat sy = s.y;\nfloat sz = s.z;\nreturn mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n(xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n(xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\nt.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\nvec4 quat;\nquat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\nquat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\nquat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\nquat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\nreturn quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\nfloat ix = q.w * v.x + q.y * v.z - q.z * v.y;\nfloat iy = q.w * v.y + q.z * v.x - q.x * v.z;\nfloat iz = q.w * v.z + q.x * v.y - q.y * v.x;\nfloat iw = -q.x * v.x - q.y * v.y - q.z * v.z;\nv.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\nv.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\nv.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\nvec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\nvec4 rotQuat = quatMultiply(viewQuat, q);\nrotateVecFromQuat(pos, rotQuat);\nreturn pos;\n}\nmat3 quatToMat3(vec4 q) {\nvec3 m0 = vec3(\n1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n2.0 * q.x * q.y + 2.0 * q.w * q.z,\n2.0 * q.x * q.z - 2.0 * q.w * q.y);\nvec3 m1 = vec3(\n2.0 * q.x * q.y - 2.0 * q.w * q.z,\n1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n2.0 * q.y * q.z + 2.0 * q.w * q.x);\nvec3 m2 = vec3(\n2.0 * q.x * q.z + 2.0 * q.w * q.y,\n2.0 * q.y * q.z - 2.0 * q.w * q.x,\n1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\nreturn mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\nfloat tr = mat[0][0] + mat[1][1] + mat[2][2];\nfloat qw, qx, qy, qz;\nif (tr > 0.0) {\nfloat S = sqrt(tr + 1.0) * 2.0;\nfloat invS = 1.0 / S;\nqw = 0.25 * S;\nqx = (mat[1][2] - mat[2][1]) * invS;\nqy = (mat[2][0] - mat[0][2]) * invS;\nqz = (mat[0][1] - mat[1][0]) * invS;\n} else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\nfloat S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\nfloat invS = 1.0 / S;\nqw = (mat[1][2] - mat[2][1]) * invS;\nqx = 0.25 * S;\nqy = (mat[1][0] + mat[0][1]) * invS;\nqz = (mat[2][0] + mat[0][2]) * invS;\n} else if (mat[1][1] > mat[2][2]) {\nfloat S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\nfloat invS = 1.0 / S;\nqw = (mat[2][0] - mat[0][2]) * invS;\nqx = (mat[1][0] + mat[0][1]) * invS;\nqy = 0.25 * S;\nqz = (mat[2][1] + mat[1][2]) * invS;\n} else {\nfloat S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\nfloat invS = 1.0 / S;\nqw = (mat[0][1] - mat[1][0]) * invS;\nqx = (mat[2][0] + mat[0][2]) * invS;\nqy = (mat[2][1] + mat[1][2]) * invS;\nqz = 0.25 * S;\n}\nreturn vec4(qx, qy, qz, qw);\n}\nvec4 eulerToQuat(vec3 euler) {\nvec3 er = euler * 0.5;\nfloat x = er.x, y = er.y, z = er.z;\nfloat sx = sin(x);\nfloat cx = cos(x);\nfloat sy = sin(y);\nfloat cy = cos(y);\nfloat sz = sin(z);\nfloat cz = cos(z);\nvec4 quat;\nquat.x = sx * cy * cz + cx * sy * sz;\nquat.y = cx * sy * cz + sx * cy * sz;\nquat.z = cx * cy * sz - sx * sy * cz;\nquat.w = cx * cy * cz - sx * sy * sz;\nreturn quat;\n}\nlayout(std140) uniform Constants {\nvec4 mainTiling_Offset;\nvec4 frameTile_velLenScale;\nvec4 scale;\nvec4 nodeRotation;\n};\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\nhighp vec4 cc_localShadowBias;\n};\nout mediump vec2 uv;\nout mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n, mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n, vec3 eye\n, vec4 velocity\n, float velocityScale\n, float lengthScale\n, float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nvec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\nvec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\nvec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\npos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\nvec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\nvec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\npos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nvec3 camX = vec3(1, 0, 0);\nvec3 camY = vec3(0, 0, -1);\npos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nrotateVecFromQuat(viewSpaceVert, q);\nvec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\nvec3 camY = vec3(0, 1, 0);\nvec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\npos.xyz += offset;\n#else\npos.x += vertOffset.x;\npos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\nvec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\naniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\nvertIndex.y = 1. - vertIndex.y;\n#endif\nreturn (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nlayout(std140) uniform SampleConstants {\nvec4 u_sampleInfo;\n};\nlayout(std140) uniform TickConstants {\nvec4 u_worldRot;\nvec4 u_timeDelta;\n};\nin vec4 a_position_starttime;\nin vec4 a_size_uv;\nin vec4 a_rotation_uv;\nin vec4 a_color;\nin vec4 a_dir_life;\nin float a_rndSeed;\n#if CC_RENDER_MODE == 4\nin vec3 a_texCoord;\nin vec3 a_texCoord3;\nin vec3 a_normal;\nin vec4 a_color1;\n#endif\nvec3 unpackCurveData (sampler2D tex, vec2 coord) {\nvec4 a = texture(tex, coord);\nvec4 b = texture(tex, coord + u_sampleInfo.y);\nfloat c = fract(coord.x * u_sampleInfo.x);\nreturn mix(a.xyz, b.xyz, c);\n}\nvec3 unpackCurveData (sampler2D tex, vec2 coord, out float w) {\nvec4 a = texture(tex, coord);\nvec4 b = texture(tex, coord + u_sampleInfo.y);\nfloat c = fract(coord.x * u_sampleInfo.x);\nw = mix(a.w, b.w, c);\nreturn mix(a.xyz, b.xyz, c);\n}\nfloat pseudoRandom(float x) {\n#if USE_VK_SHADER\nfloat o = x;\nx = mod(x - 1.0, 2.0) - 1.0;\nfloat freqVar = 10.16640753482;\nfloat y = sin(freqVar * floor(o * 0.5 - 0.5));\nfloat v = max(0.0, 1.0-abs(x));\nv *= 0.7071067812;\nv = y < 0.0 ? -v : v;\nreturn v;\n#else\nfloat seed = mod(x, 233280.);\nfloat q = (seed * 9301. + 49297.) / 233280.;\nreturn fract(q);\n#endif\n}\n#if COLOR_OVER_TIME_MODULE_ENABLE\nuniform sampler2D color_over_time_tex0;\nlayout(std140) uniform ColorConstant {\nint u_color_mode;\n};\n#endif\n#if ROTATION_OVER_TIME_MODULE_ENABLE\nuniform sampler2D rotation_over_time_tex0;\nlayout(std140) uniform RotationConstant {\nint u_rotation_mode;\n};\n#endif\n#if SIZE_OVER_TIME_MODULE_ENABLE\nuniform sampler2D size_over_time_tex0;\nlayout(std140) uniform SizeConstant {\nint u_size_mode;\n};\n#endif\n#if FORCE_OVER_TIME_MODULE_ENABLE\nuniform sampler2D force_over_time_tex0;\nlayout(std140) uniform ForceConstant {\nint u_force_mode;\nint u_force_space;\n};\n#endif\n#if VELOCITY_OVER_TIME_MODULE_ENABLE\nuniform sampler2D velocity_over_time_tex0;\nlayout(std140) uniform VelocityConstant {\nint u_velocity_mode;\nint u_velocity_space;\n};\n#endif\n#if TEXTURE_ANIMATION_MODULE_ENABLE\nuniform sampler2D texture_animation_tex0;\nlayout(std140) uniform AnimationConstant {\nvec4 u_anim_info;\n};\n#endif\nfloat repeat (float t, float length) {\nreturn t - floor(t / length) * length;\n}\nvec4 rotateQuat (vec4 p, vec4 q) {\nvec3 iv = cross(q.xyz, p.xyz) + q.w * p.xyz;\nvec3 res = p.xyz + 2.0 * cross(q.xyz, iv);\nreturn vec4(res.xyz, p.w);\n}\nvec4 gpvs_main () {\nfloat activeTime = u_timeDelta.x - a_position_starttime.w;\nfloat normalizedTime = clamp(activeTime / a_dir_life.w, 0.0, 1.0);\nvec2 timeCoord0 = vec2(normalizedTime, 0.);\nvec2 timeCoord1 = vec2(normalizedTime, 1.);\n#if CC_RENDER_MODE == 4\nvec2 vertIdx = vec2(a_texCoord.x, a_texCoord.y);\n#else\nvec2 vertIdx = vec2(a_size_uv.w, a_rotation_uv.w);\n#endif\nvec4 velocity = vec4(a_dir_life.xyz, 0.);\nvec4 pos = vec4(a_position_starttime.xyz, 1.);\nvec3 size = a_size_uv.xyz;\n#if SIZE_OVER_TIME_MODULE_ENABLE\nif (u_size_mode == 1) {\nsize *= unpackCurveData(size_over_time_tex0, timeCoord0);\n} else {\nvec3 size_0 = unpackCurveData(size_over_time_tex0, timeCoord0);\nvec3 size_1 = unpackCurveData(size_over_time_tex0, timeCoord1);\nfloat factor_s = pseudoRandom(a_rndSeed + 39825.);\nsize *= mix(size_0, size_1, factor_s);\n}\n#endif\nvec3 compScale = scale.xyz * size;\n#if FORCE_OVER_TIME_MODULE_ENABLE\nvec3 forceAnim = vec3(0.);\nif (u_force_mode == 1) {\nforceAnim = unpackCurveData(force_over_time_tex0, timeCoord0);\n} else {\nvec3 force_0 = unpackCurveData(force_over_time_tex0, timeCoord0);\nvec3 force_1 = unpackCurveData(force_over_time_tex0, timeCoord1);\nfloat factor_f =  pseudoRandom(a_rndSeed + 212165.);\nforceAnim = mix(force_0, force_1, factor_f);\n}\nvec4 forceTrack = vec4(forceAnim, 0.);\nif (u_force_space == 0) {\nforceTrack = rotateQuat(forceTrack, u_worldRot);\n}\nvelocity.xyz += forceTrack.xyz;\n#endif\n#if VELOCITY_OVER_TIME_MODULE_ENABLE\nfloat speedModifier0 = 1.;\nfloat speedModifier1 = 1.;\nvec3 velocityAnim = vec3(0.);\nif (u_velocity_mode == 1) {\nvelocityAnim = unpackCurveData(velocity_over_time_tex0, timeCoord0, speedModifier0);\n} else {\nvec3 vectory_0 = unpackCurveData(velocity_over_time_tex0, timeCoord0, speedModifier0);\nvec3 vectory_1 = unpackCurveData(velocity_over_time_tex0, timeCoord1, speedModifier1);\nfloat factor_v = pseudoRandom(a_rndSeed + 197866.);\nvelocityAnim = mix(vectory_0, vectory_1, factor_v);\nspeedModifier0 = mix(speedModifier0, speedModifier1, factor_v);\n}\nvec4 velocityTrack = vec4(velocityAnim, 0.);\nif (u_velocity_space == 0) {\nvelocityTrack = rotateQuat(velocityTrack, u_worldRot);\n}\nvelocity.xyz += velocityTrack.xyz;\nvelocity.xyz *= speedModifier0;\n#endif\npos.xyz += velocity.xyz * normalizedTime * a_dir_life.w;\n#if !CC_USE_WORLD_SPACE\npos = cc_matWorld * pos;\n#if CC_RENDER_MODE == 1\nvelocity = rotateQuat(velocity, u_worldRot);\n#endif\n#endif\nvec3 startRotation = a_rotation_uv.xyz;\n#if CC_RENDER_MODE != 4\n#if CC_RENDER_MODE == 0\nvec3 rotEuler = startRotation.xyz;\n#elif CC_RENDER_MODE == 1\nvec3 rotEuler = vec3(0.);\n#else\nvec3 rotEuler = vec3(0., 0., startRotation.z);\n#endif\nvec4 rot = quaternionFromEuler(rotEuler);\n#else\nvec4 rot = quaternionFromEuler(startRotation);\n#endif\n#if ROTATION_OVER_TIME_MODULE_ENABLE\nif (u_rotation_mode == 1) {\nvec3 euler = unpackCurveData(rotation_over_time_tex0, timeCoord0) * normalizedTime * a_dir_life.w;\nvec4 quat = eulerToQuat(euler);\nmat3 mLocal = quatToMat3(quat);\nmat3 mStart = quatToMat3(rot);\nrot = mat3ToQuat(mStart * mLocal);\n} else {\nvec3 rotation_0 = unpackCurveData(rotation_over_time_tex0, timeCoord0);\nvec3 rotation_1 = unpackCurveData(rotation_over_time_tex0, timeCoord1);\nfloat factor_r = pseudoRandom(a_rndSeed + 125292.);\nvec3 euler = mix(rotation_0, rotation_1, factor_r) * normalizedTime * a_dir_life.w;\n#if CC_RENDER_MODE == 3 || CC_RENDER_MODE == 2\neuler = vec3(0.0, 0.0, euler.z);\n#endif\nvec4 quat = eulerToQuat(euler);\nmat3 mLocal = quatToMat3(quat);\nmat3 mStart = quatToMat3(rot);\nrot = mat3ToQuat(mStart * mLocal);\n}\n#endif\n#if COLOR_OVER_TIME_MODULE_ENABLE\nif (u_color_mode == 1) {\ncolor = a_color * texture(color_over_time_tex0, timeCoord0);\n} else {\nvec4 color_0 = texture(color_over_time_tex0, timeCoord0);\nvec4 color_1 = texture(color_over_time_tex0, timeCoord1);\nfloat factor_c = pseudoRandom(a_rndSeed + 91041.);\ncolor = a_color * mix(color_0, color_1, factor_c);\n}\n#else\ncolor = a_color;\n#endif\n#if CC_RENDER_MODE != 4\nvec2 cornerOffset = vec2((vertIdx - 0.5));\n#if CC_RENDER_MODE == 1\nrot = vec4(0.0, 0.0, 0.0, 1.0);\n#endif\ncomputeVertPos(pos, cornerOffset, rot, compScale\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n, cc_matViewInv\n#endif\n#if CC_RENDER_MODE == 1\n, cc_cameraPos.xyz\n, velocity\n, frameTile_velLenScale.z\n, frameTile_velLenScale.w\n, a_size_uv.w\n#endif\n);\n#else\nmat3 rotMat = quatToMat3(rot);\nmat3 nodeMat = quatToMat3(nodeRotation);\nrotMat = nodeMat * rotMat;\nrot = mat3ToQuat(rotMat);\nmat4 xformNoScale = matrixFromRT(rot, pos.xyz);\nmat4 xform = matFromRTS(rot, pos.xyz, compScale);\npos = xform * vec4(a_texCoord3, 1);\nvec4 normal = xformNoScale * vec4(a_normal, 0);\ncolor *= a_color1;\n#endif\npos = cc_matViewProj * pos;\nfloat frameIndex = 0.;\n#if TEXTURE_ANIMATION_MODULE_ENABLE\nfloat startFrame = 0.;\nvec3 frameInfo = vec3(0.);\nif (int(u_anim_info.x) == 1) {\nframeInfo = unpackCurveData(texture_animation_tex0, timeCoord0);\n} else {\nvec3 frameInfo0 = unpackCurveData(texture_animation_tex0, timeCoord0);\nvec3 frameInfo1 = unpackCurveData(texture_animation_tex0, timeCoord1);\nfloat factor_t = pseudoRandom(a_rndSeed + 90794.);\nframeInfo = mix(frameInfo0, frameInfo1, factor_t);\n}\nstartFrame = frameInfo.x / u_anim_info.y;\nframeIndex = repeat(u_anim_info.z * (frameInfo.y + startFrame), 1.);\n#endif\nuv = computeUV(frameIndex, vertIdx, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\nreturn pos;\n}\nvoid main() { gl_Position = gpvs_main(); }",frag:"\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\nreturn color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nlayout(std140) uniform FragConstants {\nvec4 tintColor;\n};\nvec4 add () {\nvec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\nreturn CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }"}],[{vert:"\nprecision mediump float;\nlayout(std140) uniform Constants {\nvec4 mainTiling_Offset;\nvec4 frameTile_velLenScale;\nvec4 scale;\nvec4 nodeRotation;\n};\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\nhighp vec4 cc_localShadowBias;\n};\nout mediump vec2 uv;\nout mediump vec4 color;\nin vec3 a_position;\nin vec4 a_texCoord;\nin vec3 a_texCoord1;\nin vec3 a_texCoord2;\nin vec4 a_color;\n#if CC_DRAW_WIRE_FRAME\nout vec3 vBarycentric;\n#endif\nvec4 vs_main() {\nhighp vec4 pos = vec4(a_position, 1);\nvec4 velocity = vec4(a_texCoord1.xyz, 0);\n#if !CC_USE_WORLD_SPACE\npos = cc_matWorld * pos;\nvelocity = cc_matWorld * velocity;\n#endif\nfloat vertOffset = (a_texCoord.x - 0.5) * a_texCoord.y;\nvec3 camUp = normalize(cross(pos.xyz - cc_cameraPos.xyz, velocity.xyz));\npos.xyz += camUp * vertOffset;\npos = cc_matViewProj * pos;\nuv = a_texCoord.zw * mainTiling_Offset.xy + mainTiling_Offset.zw;;\ncolor = a_color;\n#if CC_DRAW_WIRE_FRAME\nvBarycentric = a_texCoord2;\n#endif\nreturn pos;\n}\nvoid main() { gl_Position = vs_main(); }",frag:"\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\nreturn color;\n}\nin vec2 uv;\nin vec4 color;\n#if CC_DRAW_WIRE_FRAME\nin vec3 vBarycentric;\n#endif\nuniform sampler2D mainTexture;\nlayout(std140) uniform FragConstants {\nvec4 tintColor;\n};\nvec4 add () {\nvec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\n#if CC_DRAW_WIRE_FRAME\nif (any(lessThan(vBarycentric, vec3(0.02)))) {\ncol = vec4(0., 1., 1., 1.);\n}\n#endif\nreturn CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }"}],[{vert:"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\nmat3 m = mat3(xAxis,yAxis,zAxis);\nfloat trace = m[0][0] + m[1][1] + m[2][2];\nvec4 quat;\nif (trace > 0.) {\nfloat s = 0.5 / sqrt(trace + 1.0);\nquat.w = 0.25 / s;\nquat.x = (m[2][1] - m[1][2]) * s;\nquat.y = (m[0][2] - m[2][0]) * s;\nquat.z = (m[1][0] - m[0][1]) * s;\n} else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\nfloat s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\nquat.w = (m[2][1] - m[1][2]) / s;\nquat.x = 0.25 * s;\nquat.y = (m[0][1] + m[1][0]) / s;\nquat.z = (m[0][2] + m[2][0]) / s;\n} else if (m[1][1] > m[2][2]) {\nfloat s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\nquat.w = (m[0][2] - m[2][0]) / s;\nquat.x = (m[0][1] + m[1][0]) / s;\nquat.y = 0.25 * s;\nquat.z = (m[1][2] + m[2][1]) / s;\n} else {\nfloat s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\nquat.w = (m[1][0] - m[0][1]) / s;\nquat.x = (m[0][2] + m[2][0]) / s;\nquat.y = (m[1][2] + m[2][1]) / s;\nquat.z = 0.25 * s;\n}\nfloat len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\nif (len > 0.) {\nlen = 1. / sqrt(len);\nquat.x = quat.x * len;\nquat.y = quat.y * len;\nquat.z = quat.z * len;\nquat.w = quat.w * len;\n}\nreturn quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\nfloat x = angle.x / 2.;\nfloat y = angle.y / 2.;\nfloat z = angle.z / 2.;\nfloat sx = sin(x);\nfloat cx = cos(x);\nfloat sy = sin(y);\nfloat cy = cos(y);\nfloat sz = sin(z);\nfloat cz = cos(z);\nvec4 quat = vec4(0);\nquat.x = sx * cy * cz + cx * sy * sz;\nquat.y = cx * sy * cz + sx * cy * sz;\nquat.z = cx * cy * sz - sx * sy * cz;\nquat.w = cx * cy * cz - sx * sy * sz;\nreturn quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\nfloat x2 = q.x + q.x;\nfloat y2 = q.y + q.y;\nfloat z2 = q.z + q.z;\nfloat xx = q.x * x2;\nfloat xy = q.x * y2;\nfloat xz = q.x * z2;\nfloat yy = q.y * y2;\nfloat yz = q.y * z2;\nfloat zz = q.z * z2;\nfloat wx = q.w * x2;\nfloat wy = q.w * y2;\nfloat wz = q.w * z2;\nreturn mat4(\n1. - (yy + zz), xy + wz, xz - wy, 0,\nxy - wz, 1. - (xx + zz), yz + wx, 0,\nxz + wy, yz - wx, 1. - (xx + yy), 0,\np.x, p.y, p.z, 1\n);\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\nfloat x = q.x, y = q.y, z = q.z, w = q.w;\nfloat x2 = x + x;\nfloat y2 = y + y;\nfloat z2 = z + z;\nfloat xx = x * x2;\nfloat xy = x * y2;\nfloat xz = x * z2;\nfloat yy = y * y2;\nfloat yz = y * z2;\nfloat zz = z * z2;\nfloat wx = w * x2;\nfloat wy = w * y2;\nfloat wz = w * z2;\nfloat sx = s.x;\nfloat sy = s.y;\nfloat sz = s.z;\nreturn mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n(xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n(xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\nt.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\nvec4 quat;\nquat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\nquat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\nquat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\nquat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\nreturn quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\nfloat ix = q.w * v.x + q.y * v.z - q.z * v.y;\nfloat iy = q.w * v.y + q.z * v.x - q.x * v.z;\nfloat iz = q.w * v.z + q.x * v.y - q.y * v.x;\nfloat iw = -q.x * v.x - q.y * v.y - q.z * v.z;\nv.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\nv.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\nv.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\nvec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\nvec4 rotQuat = quatMultiply(viewQuat, q);\nrotateVecFromQuat(pos, rotQuat);\nreturn pos;\n}\nmat3 quatToMat3(vec4 q) {\nvec3 m0 = vec3(\n1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n2.0 * q.x * q.y + 2.0 * q.w * q.z,\n2.0 * q.x * q.z - 2.0 * q.w * q.y);\nvec3 m1 = vec3(\n2.0 * q.x * q.y - 2.0 * q.w * q.z,\n1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n2.0 * q.y * q.z + 2.0 * q.w * q.x);\nvec3 m2 = vec3(\n2.0 * q.x * q.z + 2.0 * q.w * q.y,\n2.0 * q.y * q.z - 2.0 * q.w * q.x,\n1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\nreturn mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\nfloat tr = mat[0][0] + mat[1][1] + mat[2][2];\nfloat qw, qx, qy, qz;\nif (tr > 0.0) {\nfloat S = sqrt(tr + 1.0) * 2.0;\nfloat invS = 1.0 / S;\nqw = 0.25 * S;\nqx = (mat[1][2] - mat[2][1]) * invS;\nqy = (mat[2][0] - mat[0][2]) * invS;\nqz = (mat[0][1] - mat[1][0]) * invS;\n} else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\nfloat S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\nfloat invS = 1.0 / S;\nqw = (mat[1][2] - mat[2][1]) * invS;\nqx = 0.25 * S;\nqy = (mat[1][0] + mat[0][1]) * invS;\nqz = (mat[2][0] + mat[0][2]) * invS;\n} else if (mat[1][1] > mat[2][2]) {\nfloat S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\nfloat invS = 1.0 / S;\nqw = (mat[2][0] - mat[0][2]) * invS;\nqx = (mat[1][0] + mat[0][1]) * invS;\nqy = 0.25 * S;\nqz = (mat[2][1] + mat[1][2]) * invS;\n} else {\nfloat S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\nfloat invS = 1.0 / S;\nqw = (mat[0][1] - mat[1][0]) * invS;\nqx = (mat[2][0] + mat[0][2]) * invS;\nqy = (mat[2][1] + mat[1][2]) * invS;\nqz = 0.25 * S;\n}\nreturn vec4(qx, qy, qz, qw);\n}\nlayout(std140) uniform Constants {\nvec4 mainTiling_Offset;\nvec4 frameTile_velLenScale;\nvec4 scale;\nvec4 nodeRotation;\n};\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\nhighp vec4 cc_localShadowBias;\n};\nout mediump vec2 uv;\nout mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n, mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n, vec3 eye\n, vec4 velocity\n, float velocityScale\n, float lengthScale\n, float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nvec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\nvec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\nvec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\npos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\nvec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\nvec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\npos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nvec3 camX = vec3(1, 0, 0);\nvec3 camY = vec3(0, 0, -1);\npos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nrotateVecFromQuat(viewSpaceVert, q);\nvec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\nvec3 camY = vec3(0, 1, 0);\nvec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\npos.xyz += offset;\n#else\npos.x += vertOffset.x;\npos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\nvec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\naniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\nvertIndex.y = 1. - vertIndex.y;\n#endif\nreturn (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nin vec3 a_position;\nin vec3 a_texCoord;\nin vec3 a_texCoord1;\nin vec3 a_texCoord2;\nin vec4 a_color;\n#if CC_RENDER_MODE == 1\nin vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\nin vec3 a_texCoord3;\nin vec3 a_normal;\nin vec4 a_color1;\n#endif\nvec4 lpvs_main () {\nvec3 compScale = scale.xyz * a_texCoord1;\nvec4 pos = vec4(a_position, 1);\n#if CC_RENDER_MODE == 1\nvec4 velocity = vec4(a_color1.xyz, 0);\n#endif\n#if !CC_USE_WORLD_SPACE\npos = cc_matWorld * pos;\n#if CC_RENDER_MODE == 1\nvelocity = cc_matWorld * velocity;\n#endif\n#endif\n#if ROTATION_OVER_TIME_MODULE_ENABLE\nvec3 rotTmp = a_texCoord2;\nfloat mulFactor = 1.0;\nif (rotTmp.x > 10.0 * 0.5) {\nrotTmp.x -= 10.0;\nmulFactor = -1.0;\n}\nvec4 rot = vec4(rotTmp, 0.0);\nrot.w = mulFactor * sqrt(abs(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z));\n#else\n#if CC_RENDER_MODE != 4\n#if CC_RENDER_MODE == 0\nvec3 rotEuler = a_texCoord2;\n#elif CC_RENDER_MODE == 1\nvec3 rotEuler = vec3(0.);\n#else\nvec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n#endif\nvec4 rot = quaternionFromEuler(rotEuler);\n#else\nvec4 rot = quaternionFromEuler(a_texCoord2);\n#endif\n#endif\n#if CC_RENDER_MODE != 4\nvec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\ncomputeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);\n#elif CC_RENDER_MODE == 1\ncomputeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_texCoord.x);\n#elif 2\ncomputeVertPos(pos, cornerOffset, rot, compScale);\n#endif\ncolor = a_color;\n#else\nmat3 rotMat = quatToMat3(rot);\nmat3 nodeMat = quatToMat3(nodeRotation);\nrotMat = nodeMat * rotMat;\nrot = mat3ToQuat(rotMat);\nmat4 xformNoScale = matrixFromRT(rot, pos.xyz);\nmat4 xform = matFromRTS(rot, pos.xyz, compScale);\npos = xform * vec4(a_texCoord3, 1);\nvec4 normal = xformNoScale * vec4(a_normal, 0);\ncolor = a_color * a_color1;\n#endif\nuv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\npos = cc_matViewProj * pos;\nreturn pos;\n}\nvoid main() { gl_Position = lpvs_main(); }",frag:"\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\nreturn color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nlayout(std140) uniform FragConstants {\nvec4 tintColor;\n};\nvec4 add () {\nvec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\nreturn CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }"}],[{vert:"\nprecision highp float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\n#if USE_LOCAL\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\nhighp vec4 cc_localShadowBias;\n};\n#endif\nin vec3 a_position;\nin vec2 a_texCoord;\nin vec4 a_color;\nout vec4 v_light;\nout vec2 uv0;\n#if TWO_COLORED\nin vec4 a_color2;\nout vec4 v_dark;\n#endif\nvec4 vert () {\nvec4 pos = vec4(a_position, 1);\n#if USE_LOCAL\npos = cc_matWorld * pos;\n#endif\npos = cc_matViewProj * pos;\nuv0 = a_texCoord;\nv_light = a_color;\n#if TWO_COLORED\nv_dark = a_color2;\n#endif\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",frag:"\nprecision highp float;\n#if USE_ALPHA_TEST\nlayout(std140) uniform ALPHA_TEST_DATA {\nfloat alphaThreshold;\n};\n#endif\nvoid ALPHA_TEST (in vec4 color) {\n#if USE_ALPHA_TEST\nif (color.a < alphaThreshold) discard;\n#endif\n}\nvoid ALPHA_TEST (in float alpha) {\n#if USE_ALPHA_TEST\nif (alpha < alphaThreshold) discard;\n#endif\n}\nin vec4 v_light;\n#if TWO_COLORED\nin vec4 v_dark;\n#endif\nin vec2 uv0;\nuniform sampler2D cc_spriteTexture;\nvec4 frag () {\nvec4 o = vec4(1, 1, 1, 1);\n#if TWO_COLORED\nvec4 texColor = vec4(1, 1, 1, 1);\ntexColor *= texture(cc_spriteTexture, uv0);\no.a = texColor.a * v_light.a;\no.rgb = ((texColor.a - 1.0) * v_dark.a + 1.0 - texColor.rgb) * v_dark.rgb + texColor.rgb * v_light.rgb;\n#else\no *= texture(cc_spriteTexture, uv0);\no *= v_light;\n#endif\nALPHA_TEST(o);\nreturn o;\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"}],[{vert:"\nprecision highp float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\n#if USE_LOCAL\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\nhighp vec4 cc_localShadowBias;\n};\n#endif\n#if SAMPLE_FROM_RT\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#endif\nin vec3 a_position;\nin vec2 a_texCoord;\nin vec4 a_color;\nout vec4 color;\nout vec2 uv0;\nvec4 vert () {\nvec4 pos = vec4(a_position, 1);\n#if USE_LOCAL\npos = cc_matWorld * pos;\n#endif\n#if USE_PIXEL_ALIGNMENT\npos = cc_matView * pos;\npos.xyz = floor(pos.xyz);\npos = cc_matProj * pos;\n#else\npos = cc_matViewProj * pos;\n#endif\nuv0 = a_texCoord;\n#if SAMPLE_FROM_RT\nuv0 = cc_cameraPos.w > 1.0 ? vec2(uv0.x, 1.0 - uv0.y) : uv0;\n#endif\ncolor = a_color;\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",frag:"\nprecision highp float;\nvec4 CCSampleWithAlphaSeparated(sampler2D tex, vec2 uv) {\n#if CC_USE_EMBEDDED_ALPHA\nreturn vec4(texture(tex, uv).rgb, texture(tex, uv + vec2(0.0, 0.5)).r);\n#else\nreturn texture(tex, uv);\n#endif\n}\n#if USE_ALPHA_TEST\nlayout(std140) uniform ALPHA_TEST_DATA {\nfloat alphaThreshold;\n};\n#endif\nvoid ALPHA_TEST (in vec4 color) {\n#if USE_ALPHA_TEST\nif (color.a < alphaThreshold) discard;\n#endif\n}\nvoid ALPHA_TEST (in float alpha) {\n#if USE_ALPHA_TEST\nif (alpha < alphaThreshold) discard;\n#endif\n}\nin vec4 color;\n#if USE_TEXTURE\nin vec2 uv0;\nuniform sampler2D cc_spriteTexture;\n#endif\nvec4 frag () {\nvec4 o = vec4(1, 1, 1, 1);\n#if USE_TEXTURE\no *= CCSampleWithAlphaSeparated(cc_spriteTexture, uv0);\n#if IS_GRAY\nfloat gray  = 0.2126 * o.r + 0.7152 * o.g + 0.0722 * o.b;\no.r = o.g = o.b = gray;\n#endif\n#endif\no *= color;\nALPHA_TEST(o);\nreturn o;\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"}],[{vert:"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_SKINNING\nin vec4 a_joints;\nin vec4 a_weights;\n#endif\n#if USE_INSTANCING\n#if CC_USE_BAKED_ANIMATION\nin highp vec4 a_jointAnimInfo;\n#endif\nin vec4 a_matWorld0;\nin vec4 a_matWorld1;\nin vec4 a_matWorld2;\n#if CC_USE_LIGHTMAP\nin vec4 a_lightingMapUVParam;\n#endif\n#if CC_RECEIVE_SHADOW\nin vec2 a_localShadowBias;\n#endif\n#elif USE_BATCHING\nin float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\nin float a_vertexId;\nint getVertexId() {\nreturn int(a_vertexId);\n}\n#endif\n#if CC_USE_MORPH\nlayout(std140) uniform CCMorph {\nvec4 cc_displacementWeights[15];\nvec4 cc_displacementTextureInfo;\n};\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\nivec2 texSize = textureSize(tex, 0);\nreturn texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture(tex, x)),\ndecode32(texture(tex, y)),\ndecode32(texture(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nuniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nuniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nuniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nnormal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\ntangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\n#if CC_USE_BAKED_ANIMATION\nlayout(std140) uniform CCSkinningTexture {\nhighp vec4 cc_jointTextureInfo;\n};\nlayout(std140) uniform CCSkinningAnimation {\nhighp vec4 cc_jointAnimInfo;\n};\nuniform highp sampler2D cc_jointTexture;\nvoid CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n{\n#if USE_INSTANCING\nhighp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n#else\nhighp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n#endif\ninvSize = cc_jointTextureInfo.w;\nhighp float tempY = floor(temp * invSize);\nx = floor(temp - tempY * cc_jointTextureInfo.x);\ny = (tempY + 0.5) * invSize;\n}\n#else\nlayout(std140) uniform CCSkinning {\nhighp vec4 cc_joints[30 * 3];\n};\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(3.0, i, x, y, invSize);\nvec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(12.0, i, x, y, invSize);\nvec4 v1 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\nmat4 m = skinMatrix();\nposition = m * position;\nnormal = (m * vec4(normal, 0.0)).xyz;\ntangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n}\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\nIn.position = vec4(a_position, 1.0);\nIn.normal = a_normal;\nIn.tangent = a_tangent;\n#if CC_USE_MORPH\napplyMorph(In.position, In.normal, In.tangent);\n#endif\n#if CC_USE_SKINNING\nCCSkin(In.position, In.normal, In.tangent);\n#endif\n}\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\n#if !USE_INSTANCING\n#if USE_BATCHING\nlayout(std140) uniform CCLocalBatched {\nhighp mat4 cc_matWorlds[10];\n};\n#else\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\nhighp vec4 cc_localShadowBias;\n};\n#endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n#if USE_INSTANCING\nmatWorld = mat4(\nvec4(a_matWorld0.xyz, 0.0),\nvec4(a_matWorld1.xyz, 0.0),\nvec4(a_matWorld2.xyz, 0.0),\nvec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n);\nmatWorldIT = matWorld;\n#elif USE_BATCHING\nmatWorld = cc_matWorlds[int(a_dyn_batch_id)];\nmatWorldIT = matWorld;\n#else\nmatWorld = cc_matWorld;\nmatWorldIT = cc_matWorldIT;\n#endif\n}\nlayout(std140) uniform Constants {\nvec4 tilingOffset;\nvec4 albedo;\nvec4 albedoScaleAndCutoff;\nvec4 pbrParams;\nvec4 emissive;\nvec4 emissiveScaleParam;\n};\nfloat LinearFog(vec4 pos) {\nvec4 wPos = pos;\nfloat cam_dis = distance(cc_cameraPos, wPos);\nfloat fogStart = cc_fogBase.x;\nfloat fogEnd = cc_fogBase.y;\nreturn clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * fogDensity);\nreturn f;\n}\nfloat ExpSquaredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\nreturn f;\n}\nfloat LayeredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat _FogTop = cc_fogAdd.x;\nfloat _FogRange = cc_fogAdd.y;\nvec3 camWorldProj = cc_cameraPos.xyz;\ncamWorldProj.y = 0.;\nvec3 worldPosProj = wPos.xyz;\nworldPosProj.y = 0.;\nfloat fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\nfloat fDeltaY, fDensityIntegral;\nif (cc_cameraPos.y > _FogTop) {\nif (wPos.y < _FogTop) {\nfDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\nfDensityIntegral = fDeltaY * fDeltaY * 0.5;\n} else {\nfDeltaY = 0.;\nfDensityIntegral = 0.;\n}\n} else {\nif (wPos.y < _FogTop) {\nfloat fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfloat fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\nfDeltaY = abs(fDeltaA - fDeltaB);\nfDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n} else {\nfDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n}\n}\nfloat fDensity;\nif (fDeltaY != 0.) {\nfDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n} else {\nfDensity = 0.;\n}\nfloat f = exp(-fDensity);\nreturn f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\nfactor = LinearFog(pos);\n#elif CC_USE_FOG == 1\nfactor = ExpFog(pos);\n#elif CC_USE_FOG == 2\nfactor = ExpSquaredFog(pos);\n#elif CC_USE_FOG == 3\nfactor = LayeredFog(pos);\n#else\nfactor = 1.0;\n#endif\n}\n#if !CC_USE_ACCURATE_FOG\nout float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\nCC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\nout highp vec4 v_shadowPos;\nlayout(std140) uniform CCShadow {\nhighp mat4 cc_matLightPlaneProj;\nhighp mat4 cc_matLightView;\nhighp mat4 cc_matLightViewProj;\nhighp vec4 cc_shadowInvProjDepthInfo;\nhighp vec4 cc_shadowProjDepthInfo;\nhighp vec4 cc_shadowProjInfo;\nmediump vec4 cc_shadowNFLSInfo;\nmediump vec4 cc_shadowWHPBInfo;\nmediump vec4 cc_shadowLPNNInfo;\nlowp vec4 cc_shadowColor;\nmediump vec4 cc_planarNDInfo;\n};\n#if CC_RECEIVE_SHADOW\nuniform highp sampler2D cc_shadowMap;\nuniform highp sampler2D cc_spotLightingMap;\n#endif\n#if CC_RECEIVE_SHADOW\nvec2 CCGetShadowBias()\n{\n#if USE_INSTANCING\nreturn vec2(a_localShadowBias.x + cc_shadowWHPBInfo.w, a_localShadowBias.y + cc_shadowLPNNInfo.z);\n#elif !USE_BATCHING\nreturn vec2(cc_localShadowBias.x + cc_shadowWHPBInfo.w, cc_localShadowBias.y + cc_shadowLPNNInfo.z);\n#else\nreturn vec2(cc_shadowWHPBInfo.w, cc_shadowLPNNInfo.z);\n#endif\n}\n#endif\n#if USE_VERTEX_COLOR\nin vec4 a_color;\nout lowp vec4 v_color;\n#endif\nout vec3 v_position;\nout mediump vec3 v_normal;\nout vec2 v_uv;\n#if HAS_SECOND_UV\nout mediump vec2 v_uv1;\n#endif\n#if CC_RECEIVE_SHADOW\nout mediump vec2 v_shadowBias;\n#endif\n#if USE_NORMAL_MAP\nout mediump vec4 v_tangent;\n#endif\n#if HAS_SECOND_UV || CC_USE_LIGHTMAP\nin vec2 a_texCoord1;\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nout vec3 v_luv;\nvoid CCLightingMapCaclUV()\n{\n#if !USE_INSTANCING\nv_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.z;\nv_luv.z = cc_lightingMapUVParam.w;\n#else\nv_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.z;\nv_luv.z = a_lightingMapUVParam.w;\n#endif\n}\n#endif\nvoid main () {\nStandardVertInput In;\nCCVertInput(In);\nmat4 matWorld, matWorldIT;\nCCGetWorldMatrixFull(matWorld, matWorldIT);\nvec4 pos = matWorld * In.position;\nv_position = pos.xyz;\nv_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n#if CC_RECEIVE_SHADOW\nv_shadowBias = CCGetShadowBias();\n#endif\n#if USE_TWOSIDE\nvec3 viewDirect = normalize(cc_cameraPos.xyz - v_position);\nv_normal *= dot(v_normal, viewDirect) < 0.0 ? -1.0 : 1.0;\n#endif\n#if USE_NORMAL_MAP\nv_tangent.xyz = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\nv_tangent.w = In.tangent.w;\n#endif\nv_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n#if SAMPLE_FROM_RT\nv_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n#endif\n#if HAS_SECOND_UV\nv_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n#if SAMPLE_FROM_RT\nv_uv1 = cc_cameraPos.w > 1.0 ? vec2(v_uv1.x, 1.0 - v_uv1.y) : v_uv1;\n#endif\n#endif\n#if USE_VERTEX_COLOR\nv_color = a_color;\n#endif\nCC_TRANSFER_FOG(pos);\nv_shadowPos = cc_matLightViewProj * pos;\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nCCLightingMapCaclUV();\n#endif\ngl_Position = cc_matProj * (cc_matView * matWorld) * In.position;\n}",frag:"\nprecision highp float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nlayout(std140) uniform Constants {\nvec4 tilingOffset;\nvec4 albedo;\nvec4 albedoScaleAndCutoff;\nvec4 pbrParams;\nvec4 emissive;\nvec4 emissiveScaleParam;\n};\nfloat LinearFog(vec4 pos) {\nvec4 wPos = pos;\nfloat cam_dis = distance(cc_cameraPos, wPos);\nfloat fogStart = cc_fogBase.x;\nfloat fogEnd = cc_fogBase.y;\nreturn clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * fogDensity);\nreturn f;\n}\nfloat ExpSquaredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\nreturn f;\n}\nfloat LayeredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat _FogTop = cc_fogAdd.x;\nfloat _FogRange = cc_fogAdd.y;\nvec3 camWorldProj = cc_cameraPos.xyz;\ncamWorldProj.y = 0.;\nvec3 worldPosProj = wPos.xyz;\nworldPosProj.y = 0.;\nfloat fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\nfloat fDeltaY, fDensityIntegral;\nif (cc_cameraPos.y > _FogTop) {\nif (wPos.y < _FogTop) {\nfDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\nfDensityIntegral = fDeltaY * fDeltaY * 0.5;\n} else {\nfDeltaY = 0.;\nfDensityIntegral = 0.;\n}\n} else {\nif (wPos.y < _FogTop) {\nfloat fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfloat fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\nfDeltaY = abs(fDeltaA - fDeltaB);\nfDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n} else {\nfDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n}\n}\nfloat fDensity;\nif (fDeltaY != 0.) {\nfDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n} else {\nfDensity = 0.;\n}\nfloat f = exp(-fDensity);\nreturn f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\nfactor = LinearFog(pos);\n#elif CC_USE_FOG == 1\nfactor = ExpFog(pos);\n#elif CC_USE_FOG == 2\nfactor = ExpSquaredFog(pos);\n#elif CC_USE_FOG == 3\nfactor = LayeredFog(pos);\n#else\nfactor = 1.0;\n#endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\ncolor = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if !CC_USE_ACCURATE_FOG\nin float v_fog_factor;\n#endif\nvoid CC_APPLY_FOG(inout vec4 color) {\n#if !CC_USE_ACCURATE_FOG\nCC_APPLY_FOG_BASE(color, v_fog_factor);\n#endif\n}\nvoid CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n#if CC_USE_ACCURATE_FOG\nfloat factor;\nCC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n#else\nfloat factor = v_fog_factor;\n#endif\nCC_APPLY_FOG_BASE(color, factor);\n}\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nlayout(std140) uniform CCShadow {\nhighp mat4 cc_matLightPlaneProj;\nhighp mat4 cc_matLightView;\nhighp mat4 cc_matLightViewProj;\nhighp vec4 cc_shadowInvProjDepthInfo;\nhighp vec4 cc_shadowProjDepthInfo;\nhighp vec4 cc_shadowProjInfo;\nmediump vec4 cc_shadowNFLSInfo;\nmediump vec4 cc_shadowWHPBInfo;\nmediump vec4 cc_shadowLPNNInfo;\nlowp vec4 cc_shadowColor;\nmediump vec4 cc_planarNDInfo;\n};\nhighp float unpackHighpData (float mainPart, float modPart) {\nhighp float data = mainPart;\nreturn data + modPart;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data) {\nmainPart = fract(data);\nmodPart = data - mainPart;\n}\nhighp float unpackHighpData (float mainPart, float modPart, const float modValue) {\nhighp float data = mainPart * modValue;\nreturn data + modPart * modValue;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\nhighp float divide = data / modValue;\nmainPart = floor(divide);\nmodPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\nhighp vec2 data = mainPart;\nreturn data + modPart;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\nmainPart = fract(data);\nmodPart = data - mainPart;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\nhighp vec2 data = mainPart * modValue;\nreturn data + modPart * modValue;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\nhighp vec2 divide = data / modValue;\nmainPart = floor(divide);\nmodPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\nhighp vec3 data = mainPart;\nreturn data + modPart;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\nmainPart = fract(data);\nmodPart = data - mainPart;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\nhighp vec3 data = mainPart * modValue;\nreturn data + modPart * modValue;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\nhighp vec3 divide = data / modValue;\nmainPart = floor(divide);\nmodPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\nhighp vec4 data = mainPart;\nreturn data + modPart;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\nmainPart = fract(data);\nmodPart = data - mainPart;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\nhighp vec4 data = mainPart * modValue;\nreturn data + modPart * modValue;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\nhighp vec4 divide = data / modValue;\nmainPart = floor(divide);\nmodPart = (data - mainPart * modValue) / modValue;\n}\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\nhighp vec4 cc_localShadowBias;\n};\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\nfloat dist = length(viewPos);\nreturn (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\nvec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\nreturn CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\nuniform highp sampler2D cc_shadowMap;\nuniform highp sampler2D cc_spotLightingMap;\nvec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias)\n{\nvec4 newShadowPos = shadowPos;\nif(normalBias > EPSILON_LOWP)\n{\nvec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);\nif(viewNormal.z < 0.1)\nnewShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n}\nreturn newShadowPos;\n}\nvec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n{\nvec3 viewSpacePos;\nviewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\nviewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;\nviewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\nvec4 clipSpacePos;\nclipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\nclipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\nif (cc_shadowNFLSInfo.z > EPSILON) {\nclipSpacePos.z = CCGetLinearDepthFromViewSpace(viewSpacePos.xyz);\nclipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n}\nreturn clipSpacePos;\n}\nvec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)\n{\nfloat coeffA = cc_shadowProjDepthInfo.x;\nfloat coeffB = cc_shadowProjDepthInfo.y;\nfloat viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\nviewSpacePos_z += viewspaceDepthBias;\nvec4 result = shadowPos;\nresult.z = viewSpacePos_z * coeffA + coeffB;\nreturn result;\n}\nfloat CCGetShadowFactorHard (vec4 shadowPos, float bias) {\nvec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nif (cc_shadowLPNNInfo.y > EPSILON) {\nclosestDepth = dot(texture(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n} else {\nclosestDepth = texture(cc_shadowMap, clipPos.xy).x;\n}\nshadow = step(clipPos.z, closestDepth);\nreturn shadow;\n}\nfloat CCGetShadowFactorSoft (vec4 shadowPos, float bias) {\nvec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetDepth = clipPos.z;\nvec2 mapSize = cc_shadowWHPBInfo.xy;\nvec2 oneTap = 1.0 / mapSize;\nvec2 clipPos_offset = clipPos.xy + oneTap;\nfloat block0, block1, block2, block3;\nif (cc_shadowLPNNInfo.y > EPSILON) {\nblock0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n} else {\nblock0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\nblock1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\nblock2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\nblock3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n}\nfloat coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block2, block3, coefX);\nfloat coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;\nreturn mix(resultX, resultY, coefY);\n}\nfloat CCGetShadowFactorSoft2X (vec4 shadowPos, float bias) {\nvec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetDepth = clipPos.z;\nvec2 mapSize = cc_shadowWHPBInfo.xy;\nvec2 oneTap = 1.0 / mapSize;\nfloat clipPos_offset_L = clipPos.x - oneTap.x;\nfloat clipPos_offset_R = clipPos.x + oneTap.x;\nfloat clipPos_offset_U = clipPos.y - oneTap.y;\nfloat clipPos_offset_D = clipPos.y + oneTap.y;\nfloat block0, block1, block2, block3, block4, block5, block6, block7, block8;\nif (cc_shadowLPNNInfo.y > EPSILON) {\nblock0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock4 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock5 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock6 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock7 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock8 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n} else {\nblock0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\nblock1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\nblock2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\nblock3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\nblock4 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\nblock5 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\nblock6 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\nblock7 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\nblock8 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n}\nfloat coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\nfloat coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\nfloat shadow = 0.0;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block3, block4, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block1, block2, coefX);\nresultY = mix(block4, block5, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block3, block4, coefX);\nresultY = mix(block6, block7, coefX);\nshadow += mix(resultX, resultY, coefY);\nresultX = mix(block4, block5, coefX);\nresultY = mix(block7, block8, coefX);\nshadow += mix(resultX, resultY, coefY);\nreturn shadow * 0.25;\n}\nfloat CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos, float bias) {\nvec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nfloat depth = clipPos.z;\nif (cc_shadowLPNNInfo.y > EPSILON) {\nclosestDepth = dot(texture(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n} else {\nclosestDepth = texture(cc_spotLightingMap, clipPos.xy).x;\n}\nshadow = step(depth, closestDepth);\nreturn shadow;\n}\nfloat CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos, float bias) {\nvec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > EPSILON) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nvec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\nvec2 clipPos_offset = clipPos.xy + oneTap;\nfloat block0, block1, block2, block3;\nif (cc_shadowLPNNInfo.y > EPSILON) {\nblock0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n} else {\nblock0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\nblock1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)).x);\nblock2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)).x);\nblock3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n}\nfloat coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block2, block3, coefX);\nfloat coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\nreturn mix(resultX, resultY, coefY);\n}\nfloat CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos, float bias) {\nvec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > EPSILON) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nvec2 mapSize = cc_shadowWHPBInfo.xy;\nvec2 oneTap = 1.0 / mapSize;\nfloat clipPos_offset_L = clipPos.x - oneTap.x;\nfloat clipPos_offset_R = clipPos.x + oneTap.x;\nfloat clipPos_offset_U = clipPos.y - oneTap.y;\nfloat clipPos_offset_D = clipPos.y + oneTap.y;\nfloat block0, block1, block2, block3, block4, block5, block6, block7, block8;\nif (cc_shadowLPNNInfo.y > EPSILON) {\nblock0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock4 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock5 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock6 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock7 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock8 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n} else {\nblock0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\nblock1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)).x);\nblock2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\nblock3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)).x);\nblock4 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\nblock5 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)).x);\nblock6 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\nblock7 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)).x);\nblock8 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n}\nfloat coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\nfloat coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\nfloat shadow = 0.0;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block3, block4, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block1, block2, coefX);\nresultY = mix(block4, block5, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block3, block4, coefX);\nresultY = mix(block6, block7, coefX);\nshadow += mix(resultX, resultY, coefY);\nresultX = mix(block4, block5, coefX);\nresultY = mix(block7, block8, coefX);\nshadow += mix(resultX, resultY, coefY);\nreturn shadow * 0.25;\n}\nfloat CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n{\nfloat pcf = cc_shadowWHPBInfo.z;\nif (pcf > 1.9) {\nreturn CCGetSpotLightShadowFactorSoft2X(shadowPos, worldPos, shadowBias.x);\n}else if (pcf > 0.9) {\nreturn CCGetSpotLightShadowFactorSoft(shadowPos, worldPos, shadowBias.x);\n}else {\nreturn CCGetSpotLightShadowFactorHard(shadowPos, worldPos, shadowBias.x);\n}\n}\nfloat CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias)\n{\nfloat realtimeShadow = 1.0;\nvec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y);\nfloat pcf = cc_shadowWHPBInfo.z;\nif (pcf > 1.9) {\nrealtimeShadow =  CCGetShadowFactorSoft2X(pos, shadowBias.x);\n}else if (pcf > 0.9) {\nrealtimeShadow = CCGetShadowFactorSoft(pos, shadowBias.x);\n}else {\nrealtimeShadow = CCGetShadowFactorHard(pos, shadowBias.x);\n}\nreturn mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n}\n#endif\n#if CC_USE_IBL\nuniform samplerCube cc_environment;\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\nreturn textureLod(tex, coord, lod);\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\nreturn textureLod(tex, coord, lod);\n}\nvec3 unpackRGBE (vec4 rgbe) {\nreturn rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n}\n#if CC_USE_DIFFUSEMAP\nuniform samplerCube cc_diffuseMap;\n#endif\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\nvec3 NxH = cross(N, H);\nfloat OneMinusNoHSqr = dot(NxH, NxH);\nfloat a = roughness * roughness;\nfloat n = NoH * a;\nfloat p = a / (OneMinusNoHSqr + n * n);\nreturn p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\nreturn (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\nconst vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\nconst vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\nvec4 r = roughness * c0 + c1;\nfloat a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\nvec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\nAB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\nreturn specular * AB.x + AB.y;\n}\n#if USE_REFLECTION_DENOISE\nvec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n#if CC_USE_IBL\nfloat mip = roughness * mipCount;\nfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\nfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\nvec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);\nvec4 filtered = texture(cc_environment, R);\n#if CC_USE_IBL == 2\nbiased.rgb = unpackRGBE(biased);\nfiltered.rgb = unpackRGBE(filtered);\n#else\nbiased.rgb = SRGBToLinear(biased.rgb);\nfiltered.rgb = SRGBToLinear(filtered.rgb);\n#endif\nreturn mix(biased.rgb, filtered.rgb, denoiseIntensity);\n#else\nreturn vec3(0.0, 0.0, 0.0);\n#endif\n}\n#endif\nstruct StandardSurface {\nvec4 albedo;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nvec3 position, position_fract_part;\n#else\nvec3 position;\n#endif\nvec3 normal;\nvec3 emissive;\nvec3 lightmap;\nfloat lightmap_test;\nfloat roughness;\nfloat metallic;\nfloat occlusion;\nfloat specularIntensity;\n#if CC_RECEIVE_SHADOW\nvec2 shadowBias;\n#endif\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.08 * s.specularIntensity), s.albedo.rgb, s.metallic);\nvec3 position;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nposition = unpackHighpData(s.position, s.position_fract_part);\n#else\nposition = s.position;\n#endif\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - position);\nfloat NV = max(abs(dot(N, V)), 0.0);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 L = normalize(-cc_mainLitDir.xyz);\nvec3 H = normalize(L + V);\nfloat NH = max(dot(N, H), 0.0);\nfloat NL = max(dot(N, L), 0.0);\nvec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\nvec3 diffuseContrib = diffuse / PI;\nvec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\nvec3 dirlightContrib = (diffuseContrib + specularContrib);\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW\nif (NL > 0.0 && cc_mainLitDir.w > 0.0) {\nshadow = CCShadowFactorBase(shadowPos, N, s.shadowBias);\n}\n#endif\ndirlightContrib *= shadow;\nfinalColor *= dirlightContrib;\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nif (s.lightmap_test > EPSILON_LOWP) {\nfinalColor = diffuse * s.lightmap.rgb * shadow;\n}\n#endif\nfloat fAmb = 0.5 - N.y * 0.5;\nvec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n#if CC_USE_IBL\n#if CC_USE_DIFFUSEMAP\nvec4 diffuseMap = texture(cc_diffuseMap, N);\n#if CC_USE_DIFFUSEMAP == 2\nambDiff = unpackRGBE(diffuseMap);\n#else\nambDiff = SRGBToLinear(diffuseMap.rgb);\n#endif\n#endif\nvec3 R = normalize(reflect(-V, N));\n#if USE_REFLECTION_DENOISE\nvec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);\n#else\nvec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n#if CC_USE_IBL == 2\nvec3 env = unpackRGBE(envmap);\n#else\nvec3 env = SRGBToLinear(envmap.rgb);\n#endif\n#endif\nfinalColor += env * cc_ambientSky.w * specular * s.occlusion;\n#endif\nfinalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;\nfinalColor += s.emissive;\nreturn vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\ncolor = min(color, vec3(8.0));\nconst float A = 2.51;\nconst float B = 0.03;\nconst float C = 2.43;\nconst float D = 0.59;\nconst float E = 0.14;\nreturn (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n#if CC_USE_HDR\ncolor.rgb = ACESToneMap(color.rgb);\n#endif\ncolor.rgb = sqrt(color.rgb);\nreturn color;\n}\nin highp vec4 v_shadowPos;\n#if CC_RECEIVE_SHADOW\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nin vec3 v_luv;\nuniform sampler2D cc_lightingMap;\n#endif\nin vec3 v_position;\nin vec2 v_uv;\n#if HAS_SECOND_UV\nin mediump vec2 v_uv1;\n#endif\nin mediump vec3 v_normal;\n#if CC_RECEIVE_SHADOW\nin mediump vec2 v_shadowBias;\n#endif\n#if USE_VERTEX_COLOR\nin lowp vec4 v_color;\n#endif\n#if USE_ALBEDO_MAP\nuniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\nin mediump vec4 v_tangent;\nuniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\nuniform sampler2D pbrMap;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\nuniform sampler2D metallicRoughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\nuniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\nuniform sampler2D emissiveMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out StandardSurface s) {\nvec4 baseColor = albedo;\n#if USE_VERTEX_COLOR\nbaseColor.rgb *= SRGBToLinear(v_color.rgb);\nbaseColor.a *= v_color.a;\n#endif\n#if USE_ALBEDO_MAP\nvec4 texColor = texture(albedoMap, ALBEDO_UV);\ntexColor.rgb = SRGBToLinear(texColor.rgb);\nbaseColor *= texColor;\n#endif\ns.albedo = baseColor;\ns.albedo.rgb *= albedoScaleAndCutoff.xyz;\n#if USE_ALPHA_TEST\nif (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nvec4 lightColor = texture(cc_lightingMap, v_luv.xy);\ns.lightmap = lightColor.xyz * v_luv.z;\ns.lightmap_test = v_luv.z;\n#endif\ns.normal = v_normal;\n#if CC_RECEIVE_SHADOW\ns.shadowBias = v_shadowBias;\n#endif\n#if USE_NORMAL_MAP\nvec3 nmmp = texture(normalMap, NORMAL_UV).xyz - vec3(0.5);\nvec3 bitangent = cross(v_normal, v_tangent.xyz) * v_tangent.w;\ns.normal =\n(nmmp.x * emissiveScaleParam.w) * normalize(v_tangent.xyz) +\n(nmmp.y * emissiveScaleParam.w) * normalize(bitangent) +\nnmmp.z * normalize(s.normal);\n#endif\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\npackHighpData(s.position, s.position_fract_part, v_position);\n#else\ns.position = v_position;\n#endif\nvec4 pbr = pbrParams;\n#if USE_PBR_MAP\nvec4 res = texture(pbrMap, PBR_UV);\npbr.x *= res.r;\npbr.y *= res.g;\npbr.z *= res.b;\npbr.w *= res.a;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\nvec4 metallicRoughness = texture(metallicRoughnessMap, PBR_UV);\npbr.z *= metallicRoughness.b;\npbr.y *= metallicRoughness.g;\n#endif\n#if USE_OCCLUSION_MAP\npbr.x *= texture(occlusionMap, PBR_UV).r;\n#endif\ns.occlusion = pbr.x;\ns.roughness = pbr.y;\ns.specularIntensity = 0.5;\ns.metallic = pbr.z;\ns.emissive = emissive.rgb * emissiveScaleParam.xyz;\n#if USE_EMISSIVE_MAP\ns.emissive *= SRGBToLinear(texture(emissiveMap, EMISSIVE_UV).rgb);\n#endif\n}\n#if CC_FORWARD_ADD\n#if CC_PIPELINE_TYPE == 0\n#define LIGHTS_PER_PASS 1\n#else\n#define LIGHTS_PER_PASS 10\n#endif\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\nlayout(std140) uniform CCForwardLight {\nhighp vec4 cc_lightPos[LIGHTS_PER_PASS];\nvec4 cc_lightColor[LIGHTS_PER_PASS];\nvec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\nvec4 cc_lightDir[LIGHTS_PER_PASS];\n};\n#endif\nfloat SmoothDistAtt (float distSqr, float invSqrAttRadius) {\nfloat factor = distSqr * invSqrAttRadius;\nfloat smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\nreturn smoothFactor * smoothFactor;\n}\nfloat GetDistAtt (float distSqr, float invSqrAttRadius) {\nfloat attenuation = 1.0 / max(distSqr, 0.01*0.01);\nattenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\nreturn attenuation;\n}\nfloat GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\nfloat cd = dot(litDir, L);\nfloat attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\nreturn (attenuation * attenuation);\n}\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\nvec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\nvec3 position;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nposition = unpackHighpData(s.position, s.position_fract_part);\n#else\nposition = s.position;\n#endif\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 diffuseContrib = diffuse / PI;\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - position);\nfloat NV = max(abs(dot(N, V)), 0.0);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 finalColor = vec3(0.0);\nint numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\nfor (int i = 0; i < LIGHTS_PER_PASS; i++) {\nif (i >= numLights) break;\nvec3 SLU = cc_lightPos[i].xyz - position;\nvec3 SL = normalize(SLU);\nvec3 SH = normalize(SL + V);\nfloat SNL = max(dot(N, SL), 0.0);\nfloat SNH = max(dot(N, SH), 0.0);\nfloat distSqr = dot(SLU, SLU);\nfloat litRadius = cc_lightSizeRangeAngle[i].x;\nfloat litRadiusSqr = litRadius * litRadius;\nfloat illum = litRadiusSqr / max(litRadiusSqr, distSqr);\nfloat attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\nattRadiusSqrInv *= attRadiusSqrInv;\nfloat att = GetDistAtt(distSqr, attRadiusSqrInv);\nvec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\nif (cc_lightPos[i].w > 0.0) {\nfloat cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\nfloat cosOuter = cc_lightSizeRangeAngle[i].z;\nfloat litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\nfloat litAngleOffset = -cosOuter * litAngleScale;\natt *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n}\nvec3 lightColor = cc_lightColor[i].rgb;\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW\nif (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\nshadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n}\n#endif\nlightColor *= shadow;\nfinalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n}\nreturn vec4(finalColor, 0.0);\n}\n#endif\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\nlayout(std430, binding = 4) readonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };\nlayout(std430, binding = 5) readonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };\nlayout(std430, binding = 6) readonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };\nstruct CCLight\n{\nvec4 cc_lightPos;\nvec4 cc_lightColor;\nvec4 cc_lightSizeRangeAngle;\nvec4 cc_lightDir;\n};\nstruct Cluster\n{\nvec3 minBounds;\nvec3 maxBounds;\n};\nstruct LightGrid\n{\nuint offset;\nuint ccLights;\n};\nCCLight getCCLight(uint i)\n{\nCCLight light;\nlight.cc_lightPos = b_ccLights[4u * i + 0u];\nlight.cc_lightColor = b_ccLights[4u * i + 1u];\nlight.cc_lightSizeRangeAngle = b_ccLights[4u * i + 2u];\nlight.cc_lightDir = b_ccLights[4u * i + 3u];\nreturn light;\n}\nLightGrid getLightGrid(uint cluster)\n{\nuvec4 gridvec = b_clusterLightGrid[cluster];\nLightGrid grid;\ngrid.offset = gridvec.x;\ngrid.ccLights = gridvec.y;\nreturn grid;\n}\nuint getGridLightIndex(uint start, uint offset)\n{\nreturn b_clusterLightIndices[start + offset];\n}\nuint getClusterZIndex(vec4 worldPos)\n{\nfloat scale = float(24) / log(cc_nearFar.y / cc_nearFar.x);\nfloat bias = -(float(24) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));\nfloat eyeDepth = -(cc_matView * worldPos).z;\nuint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));\nreturn zIndex;\n}\nuint getClusterIndex(vec4 fragCoord, vec4 worldPos)\n{\nuint zIndex = getClusterZIndex(worldPos);\nfloat clusterSizeX = ceil(cc_viewPort.z / float(16));\nfloat clusterSizeY = ceil(cc_viewPort.w / float(8));\nuvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);\nuint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;\nreturn cluster;\n}\nvec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 diffuseContrib = diffuse / PI;\nvec3 position;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nposition = unpackHighpData(s.position, s.position_fract_part);\n#else\nposition = s.position;\n#endif\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - position);\nfloat NV = max(abs(dot(N, V)), 0.001);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 finalColor = vec3(0.0);\nuint cluster = getClusterIndex(gl_FragCoord, vec4(position, 1.0));\nLightGrid grid = getLightGrid(cluster);\nuint numLights = grid.ccLights;\nfor (uint i = 0u; i < 100u; i++) {\nif (i >= numLights) break;\nuint lightIndex = getGridLightIndex(grid.offset, i);\nCCLight light = getCCLight(lightIndex);\nvec3 SLU = light.cc_lightPos.xyz - position;\nvec3 SL = normalize(SLU);\nvec3 SH = normalize(SL + V);\nfloat SNL = max(dot(N, SL), 0.001);\nfloat SNH = max(dot(N, SH), 0.0);\nfloat distSqr = dot(SLU, SLU);\nfloat litRadius = light.cc_lightSizeRangeAngle.x;\nfloat litRadiusSqr = litRadius * litRadius;\nfloat illum = PI * (litRadiusSqr / max(litRadiusSqr , distSqr));\nfloat attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);\nattRadiusSqrInv *= attRadiusSqrInv;\nfloat att = GetDistAtt(distSqr, attRadiusSqrInv);\nvec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\nif (light.cc_lightPos.w > 0.0) {\nfloat cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);\nfloat cosOuter = light.cc_lightSizeRangeAngle.z;\nfloat litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\nfloat litAngleOffset = -cosOuter * litAngleScale;\natt *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);\n}\nvec3 lightColor = light.cc_lightColor.rgb;\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW\nif (light.cc_lightPos.w > 0.0) {\nshadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n}\n#endif\nlightColor *= shadow;\nfinalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);\n}\nreturn vec4(finalColor, 0.0);\n}\n#endif\nlayout(location = 0) out vec4 fragColorX;\nvoid main () {\nStandardSurface s; surf(s);\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\nvec4 color = CCClusterShadingAdditive(s, v_shadowPos);\n#else\nvec4 color = CCStandardShadingAdditive(s, v_shadowPos);\n#endif\nfragColorX = CCFragOutput(color);\n}\n#elif (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\nlayout(location = 0) out vec4 fragColorX;\nvoid main () {\nStandardSurface s; surf(s);\nvec4 color = CCStandardShadingBase(s, v_shadowPos);\nCC_APPLY_FOG(color, s.position.xyz);\nfragColorX = CCFragOutput(color);\n}\n#elif CC_PIPELINE_TYPE == 1\nvec2 signNotZero(vec2 v) {\nreturn vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n}\nvec2 float32x3_to_oct(in vec3 v) {\nvec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));\nreturn (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;\n}\nlayout(location = 0) out vec4 fragColor0;\nlayout(location = 1) out vec4 fragColor1;\nlayout(location = 2) out vec4 fragColor2;\nvoid main () {\nStandardSurface s; surf(s);\nfragColor0 = s.albedo;\nfragColor1 = vec4(float32x3_to_oct(s.normal), s.roughness, s.metallic);\nfragColor2 = vec4(s.emissive, s.occlusion);\n}\n#endif"},{vert:"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_SKINNING\nin vec4 a_joints;\nin vec4 a_weights;\n#endif\n#if USE_INSTANCING\n#if CC_USE_BAKED_ANIMATION\nin highp vec4 a_jointAnimInfo;\n#endif\nin vec4 a_matWorld0;\nin vec4 a_matWorld1;\nin vec4 a_matWorld2;\n#if CC_USE_LIGHTMAP\nin vec4 a_lightingMapUVParam;\n#endif\n#if CC_RECEIVE_SHADOW\nin vec2 a_localShadowBias;\n#endif\n#elif USE_BATCHING\nin float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\nin float a_vertexId;\nint getVertexId() {\nreturn int(a_vertexId);\n}\n#endif\n#if CC_USE_MORPH\nlayout(std140) uniform CCMorph {\nvec4 cc_displacementWeights[15];\nvec4 cc_displacementTextureInfo;\n};\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\nivec2 texSize = textureSize(tex, 0);\nreturn texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture(tex, x)),\ndecode32(texture(tex, y)),\ndecode32(texture(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nuniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nuniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nuniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nnormal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\ntangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\n#if CC_USE_BAKED_ANIMATION\nlayout(std140) uniform CCSkinningTexture {\nhighp vec4 cc_jointTextureInfo;\n};\nlayout(std140) uniform CCSkinningAnimation {\nhighp vec4 cc_jointAnimInfo;\n};\nuniform highp sampler2D cc_jointTexture;\nvoid CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n{\n#if USE_INSTANCING\nhighp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n#else\nhighp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n#endif\ninvSize = cc_jointTextureInfo.w;\nhighp float tempY = floor(temp * invSize);\nx = floor(temp - tempY * cc_jointTextureInfo.x);\ny = (tempY + 0.5) * invSize;\n}\n#else\nlayout(std140) uniform CCSkinning {\nhighp vec4 cc_joints[30 * 3];\n};\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(3.0, i, x, y, invSize);\nvec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(12.0, i, x, y, invSize);\nvec4 v1 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\nmat4 m = skinMatrix();\nposition = m * position;\nnormal = (m * vec4(normal, 0.0)).xyz;\ntangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n}\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\nIn.position = vec4(a_position, 1.0);\nIn.normal = a_normal;\nIn.tangent = a_tangent;\n#if CC_USE_MORPH\napplyMorph(In.position, In.normal, In.tangent);\n#endif\n#if CC_USE_SKINNING\nCCSkin(In.position, In.normal, In.tangent);\n#endif\n}\n#if !USE_INSTANCING\n#if USE_BATCHING\nlayout(std140) uniform CCLocalBatched {\nhighp mat4 cc_matWorlds[10];\n};\n#else\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\nhighp vec4 cc_localShadowBias;\n};\n#endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n#if USE_INSTANCING\nmatWorld = mat4(\nvec4(a_matWorld0.xyz, 0.0),\nvec4(a_matWorld1.xyz, 0.0),\nvec4(a_matWorld2.xyz, 0.0),\nvec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n);\nmatWorldIT = matWorld;\n#elif USE_BATCHING\nmatWorld = cc_matWorlds[int(a_dyn_batch_id)];\nmatWorldIT = matWorld;\n#else\nmatWorld = cc_matWorld;\nmatWorldIT = cc_matWorldIT;\n#endif\n}\nlayout(std140) uniform Constants {\nvec4 tilingOffset;\nvec4 albedo;\nvec4 albedoScaleAndCutoff;\nvec4 pbrParams;\nvec4 emissive;\nvec4 emissiveScaleParam;\n};\nlayout(std140) uniform CCShadow {\nhighp mat4 cc_matLightPlaneProj;\nhighp mat4 cc_matLightView;\nhighp mat4 cc_matLightViewProj;\nhighp vec4 cc_shadowInvProjDepthInfo;\nhighp vec4 cc_shadowProjDepthInfo;\nhighp vec4 cc_shadowProjInfo;\nmediump vec4 cc_shadowNFLSInfo;\nmediump vec4 cc_shadowWHPBInfo;\nmediump vec4 cc_shadowLPNNInfo;\nlowp vec4 cc_shadowColor;\nmediump vec4 cc_planarNDInfo;\n};\n#if HAS_SECOND_UV || CC_USE_LIGHTMAP\nin vec2 a_texCoord1;\n#endif\nout vec2 v_uv;\n#if HAS_SECOND_UV\nout vec2 v_uv1;\n#endif\nout vec4 v_worldPos;\nout float v_clip_depth;\nvec4 vert () {\nStandardVertInput In;\nCCVertInput(In);\nmat4 matWorld, matWorldIT;\nCCGetWorldMatrixFull(matWorld, matWorldIT);\nv_worldPos = matWorld * In.position;\nvec4 clipPos = cc_matLightViewProj * v_worldPos;\nv_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n#if HAS_SECOND_UV\nv_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n#endif\nv_clip_depth = clipPos.z / clipPos.w * 0.5 + 0.5;\nreturn clipPos;\n}\nvoid main() { gl_Position = vert(); }",frag:"\nprecision highp float;\nlayout(std140) uniform Constants {\nvec4 tilingOffset;\nvec4 albedo;\nvec4 albedoScaleAndCutoff;\nvec4 pbrParams;\nvec4 emissive;\nvec4 emissiveScaleParam;\n};\nvec4 packDepthToRGBA (float depth) {\nvec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\nret = fract(ret);\nret -= vec4(ret.yzw, 0.0) / 255.0;\nreturn ret;\n}\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCShadow {\nhighp mat4 cc_matLightPlaneProj;\nhighp mat4 cc_matLightView;\nhighp mat4 cc_matLightViewProj;\nhighp vec4 cc_shadowInvProjDepthInfo;\nhighp vec4 cc_shadowProjDepthInfo;\nhighp vec4 cc_shadowProjInfo;\nmediump vec4 cc_shadowNFLSInfo;\nmediump vec4 cc_shadowWHPBInfo;\nmediump vec4 cc_shadowLPNNInfo;\nlowp vec4 cc_shadowColor;\nmediump vec4 cc_planarNDInfo;\n};\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\nhighp vec4 cc_localShadowBias;\n};\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\nfloat dist = length(viewPos);\nreturn (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\nvec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\nreturn CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\nuniform highp sampler2D cc_shadowMap;\nuniform highp sampler2D cc_spotLightingMap;\n#endif\nin vec2 v_uv;\n#if HAS_SECOND_UV\nin vec2 v_uv1;\n#endif\nin vec4 v_worldPos;\nin float v_clip_depth;\n#if USE_ALBEDO_MAP\nuniform sampler2D albedoMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvec4 frag () {\nvec4 baseColor = albedo;\n#if USE_ALBEDO_MAP\nbaseColor *= texture(albedoMap, ALBEDO_UV);\n#endif\n#if USE_ALPHA_TEST\nif (baseColor.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n#endif\nif(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {\nif (cc_shadowNFLSInfo.z > 0.000001) {\nreturn vec4(CCGetLinearDepth(v_worldPos.xyz), 1.0, 1.0, 1.0);\n}\n}\nif (cc_shadowLPNNInfo.y > 0.000001) {\nreturn packDepthToRGBA(v_clip_depth);\n}\nreturn vec4(v_clip_depth, 1.0, 1.0, 1.0);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"}],[{vert:"\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\nhighp vec4 cc_localShadowBias;\n};\nfloat LinearFog(vec4 pos) {\nvec4 wPos = pos;\nfloat cam_dis = distance(cc_cameraPos, wPos);\nfloat fogStart = cc_fogBase.x;\nfloat fogEnd = cc_fogBase.y;\nreturn clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * fogDensity);\nreturn f;\n}\nfloat ExpSquaredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\nreturn f;\n}\nfloat LayeredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat _FogTop = cc_fogAdd.x;\nfloat _FogRange = cc_fogAdd.y;\nvec3 camWorldProj = cc_cameraPos.xyz;\ncamWorldProj.y = 0.;\nvec3 worldPosProj = wPos.xyz;\nworldPosProj.y = 0.;\nfloat fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\nfloat fDeltaY, fDensityIntegral;\nif (cc_cameraPos.y > _FogTop) {\nif (wPos.y < _FogTop) {\nfDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\nfDensityIntegral = fDeltaY * fDeltaY * 0.5;\n} else {\nfDeltaY = 0.;\nfDensityIntegral = 0.;\n}\n} else {\nif (wPos.y < _FogTop) {\nfloat fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfloat fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\nfDeltaY = abs(fDeltaA - fDeltaB);\nfDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n} else {\nfDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n}\n}\nfloat fDensity;\nif (fDeltaY != 0.) {\nfDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n} else {\nfDensity = 0.;\n}\nfloat f = exp(-fDensity);\nreturn f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\nfactor = LinearFog(pos);\n#elif CC_USE_FOG == 1\nfactor = ExpFog(pos);\n#elif CC_USE_FOG == 2\nfactor = ExpSquaredFog(pos);\n#elif CC_USE_FOG == 3\nfactor = LayeredFog(pos);\n#else\nfactor = 1.0;\n#endif\n}\n#if !CC_USE_ACCURATE_FOG\nout float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\nCC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\nout highp vec4 v_shadowPos;\nlayout(std140) uniform CCShadow {\nhighp mat4 cc_matLightPlaneProj;\nhighp mat4 cc_matLightView;\nhighp mat4 cc_matLightViewProj;\nhighp vec4 cc_shadowInvProjDepthInfo;\nhighp vec4 cc_shadowProjDepthInfo;\nhighp vec4 cc_shadowProjInfo;\nmediump vec4 cc_shadowNFLSInfo;\nmediump vec4 cc_shadowWHPBInfo;\nmediump vec4 cc_shadowLPNNInfo;\nlowp vec4 cc_shadowColor;\nmediump vec4 cc_planarNDInfo;\n};\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#if CC_RECEIVE_SHADOW\nuniform highp sampler2D cc_shadowMap;\nuniform highp sampler2D cc_spotLightingMap;\n#endif\n#if CC_RECEIVE_SHADOW\n#endif\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\n#if CC_RECEIVE_SHADOW\nout vec2 v_shadowBias;\n#endif\nout highp vec3 v_position;\nout mediump vec3 v_normal;\nout mediump vec2 uvw;\nout mediump vec2 uv0;\nout mediump vec2 uv1;\nout mediump vec2 uv2;\nout mediump vec2 uv3;\nout mediump vec3 luv;\nout mediump vec3 diffuse;\nlayout(std140) uniform TexCoords {\nvec4 UVScale;\nvec4 lightMapUVParam;\n};\nvoid main () {\nvec3 worldPos;\nworldPos.x = cc_matWorld[3][0] + a_position.x;\nworldPos.y = cc_matWorld[3][1] + a_position.y;\nworldPos.z = cc_matWorld[3][2] + a_position.z;\nvec4 pos = vec4(worldPos, 1.0);\npos = cc_matViewProj * pos;\nuvw = a_texCoord;\nuv0 = a_position.xz * UVScale.x;\nuv1 = a_position.xz * UVScale.y;\nuv2 = a_position.xz * UVScale.z;\nuv3 = a_position.xz * UVScale.w;\n#if CC_USE_LIGHTMAP\nluv.xy = lightMapUVParam.xy + a_texCoord * lightMapUVParam.z;\nluv.z = lightMapUVParam.w;\n#endif\nv_position = worldPos;\nv_normal = a_normal;\nCC_TRANSFER_FOG(vec4(worldPos, 1.0));\n#if CC_RECEIVE_SHADOW\nv_shadowBias = vec2(0.0, 0.0);\n#endif\nv_shadowPos = cc_matLightViewProj * vec4(worldPos, 1.0);\ngl_Position = pos;\n}",frag:"\nprecision highp float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nlayout(std140) uniform CCShadow {\nhighp mat4 cc_matLightPlaneProj;\nhighp mat4 cc_matLightView;\nhighp mat4 cc_matLightViewProj;\nhighp vec4 cc_shadowInvProjDepthInfo;\nhighp vec4 cc_shadowProjDepthInfo;\nhighp vec4 cc_shadowProjInfo;\nmediump vec4 cc_shadowNFLSInfo;\nmediump vec4 cc_shadowWHPBInfo;\nmediump vec4 cc_shadowLPNNInfo;\nlowp vec4 cc_shadowColor;\nmediump vec4 cc_planarNDInfo;\n};\nhighp float unpackHighpData (float mainPart, float modPart) {\nhighp float data = mainPart;\nreturn data + modPart;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data) {\nmainPart = fract(data);\nmodPart = data - mainPart;\n}\nhighp float unpackHighpData (float mainPart, float modPart, const float modValue) {\nhighp float data = mainPart * modValue;\nreturn data + modPart * modValue;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\nhighp float divide = data / modValue;\nmainPart = floor(divide);\nmodPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\nhighp vec2 data = mainPart;\nreturn data + modPart;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\nmainPart = fract(data);\nmodPart = data - mainPart;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\nhighp vec2 data = mainPart * modValue;\nreturn data + modPart * modValue;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\nhighp vec2 divide = data / modValue;\nmainPart = floor(divide);\nmodPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\nhighp vec3 data = mainPart;\nreturn data + modPart;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\nmainPart = fract(data);\nmodPart = data - mainPart;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\nhighp vec3 data = mainPart * modValue;\nreturn data + modPart * modValue;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\nhighp vec3 divide = data / modValue;\nmainPart = floor(divide);\nmodPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\nhighp vec4 data = mainPart;\nreturn data + modPart;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\nmainPart = fract(data);\nmodPart = data - mainPart;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\nhighp vec4 data = mainPart * modValue;\nreturn data + modPart * modValue;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\nhighp vec4 divide = data / modValue;\nmainPart = floor(divide);\nmodPart = (data - mainPart * modValue) / modValue;\n}\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\nhighp vec4 cc_localShadowBias;\n};\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\nfloat dist = length(viewPos);\nreturn (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\nvec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\nreturn CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\nuniform highp sampler2D cc_shadowMap;\nuniform highp sampler2D cc_spotLightingMap;\nvec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias)\n{\nvec4 newShadowPos = shadowPos;\nif(normalBias > EPSILON_LOWP)\n{\nvec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);\nif(viewNormal.z < 0.1)\nnewShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n}\nreturn newShadowPos;\n}\nvec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n{\nvec3 viewSpacePos;\nviewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\nviewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;\nviewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\nvec4 clipSpacePos;\nclipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\nclipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\nif (cc_shadowNFLSInfo.z > EPSILON) {\nclipSpacePos.z = CCGetLinearDepthFromViewSpace(viewSpacePos.xyz);\nclipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n}\nreturn clipSpacePos;\n}\nvec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)\n{\nfloat coeffA = cc_shadowProjDepthInfo.x;\nfloat coeffB = cc_shadowProjDepthInfo.y;\nfloat viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\nviewSpacePos_z += viewspaceDepthBias;\nvec4 result = shadowPos;\nresult.z = viewSpacePos_z * coeffA + coeffB;\nreturn result;\n}\nfloat CCGetShadowFactorHard (vec4 shadowPos, float bias) {\nvec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nif (cc_shadowLPNNInfo.y > EPSILON) {\nclosestDepth = dot(texture(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n} else {\nclosestDepth = texture(cc_shadowMap, clipPos.xy).x;\n}\nshadow = step(clipPos.z, closestDepth);\nreturn shadow;\n}\nfloat CCGetShadowFactorSoft (vec4 shadowPos, float bias) {\nvec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetDepth = clipPos.z;\nvec2 mapSize = cc_shadowWHPBInfo.xy;\nvec2 oneTap = 1.0 / mapSize;\nvec2 clipPos_offset = clipPos.xy + oneTap;\nfloat block0, block1, block2, block3;\nif (cc_shadowLPNNInfo.y > EPSILON) {\nblock0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n} else {\nblock0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\nblock1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\nblock2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\nblock3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n}\nfloat coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block2, block3, coefX);\nfloat coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;\nreturn mix(resultX, resultY, coefY);\n}\nfloat CCGetShadowFactorSoft2X (vec4 shadowPos, float bias) {\nvec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetDepth = clipPos.z;\nvec2 mapSize = cc_shadowWHPBInfo.xy;\nvec2 oneTap = 1.0 / mapSize;\nfloat clipPos_offset_L = clipPos.x - oneTap.x;\nfloat clipPos_offset_R = clipPos.x + oneTap.x;\nfloat clipPos_offset_U = clipPos.y - oneTap.y;\nfloat clipPos_offset_D = clipPos.y + oneTap.y;\nfloat block0, block1, block2, block3, block4, block5, block6, block7, block8;\nif (cc_shadowLPNNInfo.y > EPSILON) {\nblock0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock4 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock5 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock6 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock7 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock8 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n} else {\nblock0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\nblock1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\nblock2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\nblock3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\nblock4 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\nblock5 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\nblock6 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\nblock7 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\nblock8 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n}\nfloat coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\nfloat coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\nfloat shadow = 0.0;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block3, block4, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block1, block2, coefX);\nresultY = mix(block4, block5, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block3, block4, coefX);\nresultY = mix(block6, block7, coefX);\nshadow += mix(resultX, resultY, coefY);\nresultX = mix(block4, block5, coefX);\nresultY = mix(block7, block8, coefX);\nshadow += mix(resultX, resultY, coefY);\nreturn shadow * 0.25;\n}\nfloat CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos, float bias) {\nvec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nfloat depth = clipPos.z;\nif (cc_shadowLPNNInfo.y > EPSILON) {\nclosestDepth = dot(texture(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n} else {\nclosestDepth = texture(cc_spotLightingMap, clipPos.xy).x;\n}\nshadow = step(depth, closestDepth);\nreturn shadow;\n}\nfloat CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos, float bias) {\nvec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > EPSILON) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nvec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\nvec2 clipPos_offset = clipPos.xy + oneTap;\nfloat block0, block1, block2, block3;\nif (cc_shadowLPNNInfo.y > EPSILON) {\nblock0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n} else {\nblock0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\nblock1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)).x);\nblock2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)).x);\nblock3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n}\nfloat coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block2, block3, coefX);\nfloat coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\nreturn mix(resultX, resultY, coefY);\n}\nfloat CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos, float bias) {\nvec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > EPSILON) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nvec2 mapSize = cc_shadowWHPBInfo.xy;\nvec2 oneTap = 1.0 / mapSize;\nfloat clipPos_offset_L = clipPos.x - oneTap.x;\nfloat clipPos_offset_R = clipPos.x + oneTap.x;\nfloat clipPos_offset_U = clipPos.y - oneTap.y;\nfloat clipPos_offset_D = clipPos.y + oneTap.y;\nfloat block0, block1, block2, block3, block4, block5, block6, block7, block8;\nif (cc_shadowLPNNInfo.y > EPSILON) {\nblock0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock4 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock5 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock6 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock7 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock8 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n} else {\nblock0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\nblock1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)).x);\nblock2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\nblock3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)).x);\nblock4 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\nblock5 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)).x);\nblock6 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\nblock7 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)).x);\nblock8 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n}\nfloat coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\nfloat coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\nfloat shadow = 0.0;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block3, block4, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block1, block2, coefX);\nresultY = mix(block4, block5, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block3, block4, coefX);\nresultY = mix(block6, block7, coefX);\nshadow += mix(resultX, resultY, coefY);\nresultX = mix(block4, block5, coefX);\nresultY = mix(block7, block8, coefX);\nshadow += mix(resultX, resultY, coefY);\nreturn shadow * 0.25;\n}\nfloat CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n{\nfloat pcf = cc_shadowWHPBInfo.z;\nif (pcf > 1.9) {\nreturn CCGetSpotLightShadowFactorSoft2X(shadowPos, worldPos, shadowBias.x);\n}else if (pcf > 0.9) {\nreturn CCGetSpotLightShadowFactorSoft(shadowPos, worldPos, shadowBias.x);\n}else {\nreturn CCGetSpotLightShadowFactorHard(shadowPos, worldPos, shadowBias.x);\n}\n}\nfloat CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias)\n{\nfloat realtimeShadow = 1.0;\nvec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y);\nfloat pcf = cc_shadowWHPBInfo.z;\nif (pcf > 1.9) {\nrealtimeShadow =  CCGetShadowFactorSoft2X(pos, shadowBias.x);\n}else if (pcf > 0.9) {\nrealtimeShadow = CCGetShadowFactorSoft(pos, shadowBias.x);\n}else {\nrealtimeShadow = CCGetShadowFactorHard(pos, shadowBias.x);\n}\nreturn mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n}\n#endif\n#if CC_USE_IBL\nuniform samplerCube cc_environment;\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\nreturn textureLod(tex, coord, lod);\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\nreturn textureLod(tex, coord, lod);\n}\nvec3 unpackRGBE (vec4 rgbe) {\nreturn rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n}\n#if CC_USE_DIFFUSEMAP\nuniform samplerCube cc_diffuseMap;\n#endif\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\nvec3 NxH = cross(N, H);\nfloat OneMinusNoHSqr = dot(NxH, NxH);\nfloat a = roughness * roughness;\nfloat n = NoH * a;\nfloat p = a / (OneMinusNoHSqr + n * n);\nreturn p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\nreturn (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\nconst vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\nconst vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\nvec4 r = roughness * c0 + c1;\nfloat a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\nvec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\nAB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\nreturn specular * AB.x + AB.y;\n}\n#if USE_REFLECTION_DENOISE\nvec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n#if CC_USE_IBL\nfloat mip = roughness * mipCount;\nfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\nfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\nvec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);\nvec4 filtered = texture(cc_environment, R);\n#if CC_USE_IBL == 2\nbiased.rgb = unpackRGBE(biased);\nfiltered.rgb = unpackRGBE(filtered);\n#else\nbiased.rgb = SRGBToLinear(biased.rgb);\nfiltered.rgb = SRGBToLinear(filtered.rgb);\n#endif\nreturn mix(biased.rgb, filtered.rgb, denoiseIntensity);\n#else\nreturn vec3(0.0, 0.0, 0.0);\n#endif\n}\n#endif\nstruct StandardSurface {\nvec4 albedo;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nvec3 position, position_fract_part;\n#else\nvec3 position;\n#endif\nvec3 normal;\nvec3 emissive;\nvec3 lightmap;\nfloat lightmap_test;\nfloat roughness;\nfloat metallic;\nfloat occlusion;\nfloat specularIntensity;\n#if CC_RECEIVE_SHADOW\nvec2 shadowBias;\n#endif\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.08 * s.specularIntensity), s.albedo.rgb, s.metallic);\nvec3 position;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nposition = unpackHighpData(s.position, s.position_fract_part);\n#else\nposition = s.position;\n#endif\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - position);\nfloat NV = max(abs(dot(N, V)), 0.0);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 L = normalize(-cc_mainLitDir.xyz);\nvec3 H = normalize(L + V);\nfloat NH = max(dot(N, H), 0.0);\nfloat NL = max(dot(N, L), 0.0);\nvec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\nvec3 diffuseContrib = diffuse / PI;\nvec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\nvec3 dirlightContrib = (diffuseContrib + specularContrib);\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW\nif (NL > 0.0 && cc_mainLitDir.w > 0.0) {\nshadow = CCShadowFactorBase(shadowPos, N, s.shadowBias);\n}\n#endif\ndirlightContrib *= shadow;\nfinalColor *= dirlightContrib;\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nif (s.lightmap_test > EPSILON_LOWP) {\nfinalColor = diffuse * s.lightmap.rgb * shadow;\n}\n#endif\nfloat fAmb = 0.5 - N.y * 0.5;\nvec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n#if CC_USE_IBL\n#if CC_USE_DIFFUSEMAP\nvec4 diffuseMap = texture(cc_diffuseMap, N);\n#if CC_USE_DIFFUSEMAP == 2\nambDiff = unpackRGBE(diffuseMap);\n#else\nambDiff = SRGBToLinear(diffuseMap.rgb);\n#endif\n#endif\nvec3 R = normalize(reflect(-V, N));\n#if USE_REFLECTION_DENOISE\nvec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);\n#else\nvec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n#if CC_USE_IBL == 2\nvec3 env = unpackRGBE(envmap);\n#else\nvec3 env = SRGBToLinear(envmap.rgb);\n#endif\n#endif\nfinalColor += env * cc_ambientSky.w * specular * s.occlusion;\n#endif\nfinalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;\nfinalColor += s.emissive;\nreturn vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\ncolor = min(color, vec3(8.0));\nconst float A = 2.51;\nconst float B = 0.03;\nconst float C = 2.43;\nconst float D = 0.59;\nconst float E = 0.14;\nreturn (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n#if CC_USE_HDR\ncolor.rgb = ACESToneMap(color.rgb);\n#endif\ncolor.rgb = sqrt(color.rgb);\nreturn color;\n}\nfloat LinearFog(vec4 pos) {\nvec4 wPos = pos;\nfloat cam_dis = distance(cc_cameraPos, wPos);\nfloat fogStart = cc_fogBase.x;\nfloat fogEnd = cc_fogBase.y;\nreturn clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * fogDensity);\nreturn f;\n}\nfloat ExpSquaredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\nreturn f;\n}\nfloat LayeredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat _FogTop = cc_fogAdd.x;\nfloat _FogRange = cc_fogAdd.y;\nvec3 camWorldProj = cc_cameraPos.xyz;\ncamWorldProj.y = 0.;\nvec3 worldPosProj = wPos.xyz;\nworldPosProj.y = 0.;\nfloat fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\nfloat fDeltaY, fDensityIntegral;\nif (cc_cameraPos.y > _FogTop) {\nif (wPos.y < _FogTop) {\nfDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\nfDensityIntegral = fDeltaY * fDeltaY * 0.5;\n} else {\nfDeltaY = 0.;\nfDensityIntegral = 0.;\n}\n} else {\nif (wPos.y < _FogTop) {\nfloat fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfloat fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\nfDeltaY = abs(fDeltaA - fDeltaB);\nfDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n} else {\nfDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n}\n}\nfloat fDensity;\nif (fDeltaY != 0.) {\nfDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n} else {\nfDensity = 0.;\n}\nfloat f = exp(-fDensity);\nreturn f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\nfactor = LinearFog(pos);\n#elif CC_USE_FOG == 1\nfactor = ExpFog(pos);\n#elif CC_USE_FOG == 2\nfactor = ExpSquaredFog(pos);\n#elif CC_USE_FOG == 3\nfactor = LayeredFog(pos);\n#else\nfactor = 1.0;\n#endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\ncolor = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if !CC_USE_ACCURATE_FOG\nin float v_fog_factor;\n#endif\nvoid CC_APPLY_FOG(inout vec4 color) {\n#if !CC_USE_ACCURATE_FOG\nCC_APPLY_FOG_BASE(color, v_fog_factor);\n#endif\n}\nvoid CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n#if CC_USE_ACCURATE_FOG\nfloat factor;\nCC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n#else\nfloat factor = v_fog_factor;\n#endif\nCC_APPLY_FOG_BASE(color, factor);\n}\nin highp vec4 v_shadowPos;\n#if CC_RECEIVE_SHADOW\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nin vec3 v_luv;\nuniform sampler2D cc_lightingMap;\n#endif\nin highp vec3 v_position;\nin mediump vec3 v_normal;\n#if CC_RECEIVE_SHADOW\nin vec2 v_shadowBias;\n#endif\nin mediump vec2 uvw;\nin mediump vec2 uv0;\nin mediump vec2 uv1;\nin mediump vec2 uv2;\nin mediump vec2 uv3;\nin mediump vec3 diffuse;\nin mediump vec3 luv;\nlayout(std140) uniform PbrParams {\nvec4 metallic;\nvec4 roughness;\n};\nuniform sampler2D weightMap;\nuniform sampler2D detailMap0;\nuniform sampler2D detailMap1;\nuniform sampler2D detailMap2;\nuniform sampler2D detailMap3;\nuniform sampler2D normalMap0;\nuniform sampler2D normalMap1;\nuniform sampler2D normalMap2;\nuniform sampler2D normalMap3;\nuniform sampler2D lightMap;\nvoid surf (out StandardSurface s) {\n#if LAYERS > 1\nvec4 w = texture(weightMap, uvw);\n#endif\nvec4 baseColor = vec4(0, 0, 0, 0);\n#if LAYERS == 1\nbaseColor = texture(detailMap0, uv0);\n#elif LAYERS == 2\nbaseColor += texture(detailMap0, uv0) * w.r;\nbaseColor += texture(detailMap1, uv1) * w.g;\n#elif LAYERS == 3\nbaseColor += texture(detailMap0, uv0) * w.r;\nbaseColor += texture(detailMap1, uv1) * w.g;\nbaseColor += texture(detailMap2, uv2) * w.b;\n#elif LAYERS == 4\nbaseColor += texture(detailMap0, uv0) * w.r;\nbaseColor += texture(detailMap1, uv1) * w.g;\nbaseColor += texture(detailMap2, uv2) * w.b;\nbaseColor += texture(detailMap3, uv3) * w.a;\n#else\nbaseColor = texture(detailMap0, uv0);\n#endif\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\npackHighpData(s.position, s.position_fract_part, v_position);\n#else\ns.position = v_position;\n#endif\n#if USE_NORMALMAP\nvec4 baseNormal = vec4(0, 0, 0, 0);\n#if LAYERS == 1\nbaseNormal = texture(normalMap0, uv0);\n#elif LAYERS == 2\nbaseNormal += texture(normalMap0, uv0) * w.r;\nbaseNormal += texture(normalMap1, uv1) * w.g;\n#elif LAYERS == 3\nbaseNormal += texture(normalMap0, uv0) * w.r;\nbaseNormal += texture(normalMap1, uv1) * w.g;\nbaseNormal += texture(normalMap2, uv2) * w.b;\n#elif LAYERS == 4\nbaseNormal += texture(normalMap0, uv0) * w.r;\nbaseNormal += texture(normalMap1, uv1) * w.g;\nbaseNormal += texture(normalMap2, uv2) * w.b;\nbaseNormal += texture(normalMap3, uv3) * w.a;\n#else\nbaseNormal = texture(normalMap0, uv0);\n#endif\nvec3 tangent = vec3(1.0, 0.0, 0.0);\nvec3 binormal = vec3(0.0, 0.0, 1.0);\nbinormal = cross(tangent, v_normal);\ntangent = cross(v_normal, binormal);\nvec3 nmmp = baseNormal.xyz - vec3(0.5);\ns.normal =\nnmmp.x * normalize(tangent) +\nnmmp.y * normalize(binormal) +\nnmmp.z * normalize(v_normal);\n#else\ns.normal = v_normal;\n#endif\n#if CC_RECEIVE_SHADOW\ns.shadowBias = v_shadowBias;\n#endif\ns.albedo = vec4(SRGBToLinear(baseColor.rgb), 1.0);\ns.occlusion = 1.0;\n#if USE_PBR\ns.roughness = 0.0;\n#if LAYERS == 1\ns.roughness = roughness.x;\n#elif LAYERS == 2\ns.roughness += roughness.x * w.r;\ns.roughness += roughness.y * w.g;\n#elif LAYERS == 3\ns.roughness += roughness.x * w.r;\ns.roughness += roughness.y * w.g;\ns.roughness += roughness.z * w.b;\n#elif LAYERS == 4\ns.roughness += roughness.x * w.r;\ns.roughness += roughness.y * w.g;\ns.roughness += roughness.z * w.b;\ns.roughness += roughness.w * w.a;\n#else\ns.roughness = 1.0;\n#endif\ns.specularIntensity = 0.5;\ns.metallic = 0.0;\n#if LAYERS == 1\ns.specularIntensity = 0.5;\ns.metallic = metallic.x;\n#elif LAYERS == 2\ns.metallic += metallic.x * w.r;\ns.metallic += metallic.y * w.g;\n#elif LAYERS == 3\ns.metallic += metallic.x * w.r;\ns.metallic += metallic.y * w.g;\ns.metallic += metallic.z * w.b;\n#elif LAYERS == 4\ns.metallic += metallic.x * w.r;\ns.metallic += metallic.y * w.g;\ns.metallic += metallic.z * w.b;\ns.metallic += metallic.w * w.a;\n#else\ns.specularIntensity = 0.5;\ns.metallic = 0.0;\n#endif\n#else\ns.roughness = 1.0;\ns.specularIntensity = 0.5;\ns.metallic = 0.0;\n#endif\ns.emissive = vec3(0.0, 0.0, 0.0);\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nvec4 lightColor = texture(lightMap, luv.xy);\ns.lightmap = lightColor.xyz * luv.z;\ns.lightmap_test = luv.z;\n#endif\n}\n#if CC_FORWARD_ADD\n#if CC_PIPELINE_TYPE == 0\n#define LIGHTS_PER_PASS 1\n#else\n#define LIGHTS_PER_PASS 10\n#endif\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\nlayout(std140) uniform CCForwardLight {\nhighp vec4 cc_lightPos[LIGHTS_PER_PASS];\nvec4 cc_lightColor[LIGHTS_PER_PASS];\nvec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\nvec4 cc_lightDir[LIGHTS_PER_PASS];\n};\n#endif\nfloat SmoothDistAtt (float distSqr, float invSqrAttRadius) {\nfloat factor = distSqr * invSqrAttRadius;\nfloat smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\nreturn smoothFactor * smoothFactor;\n}\nfloat GetDistAtt (float distSqr, float invSqrAttRadius) {\nfloat attenuation = 1.0 / max(distSqr, 0.01*0.01);\nattenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\nreturn attenuation;\n}\nfloat GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\nfloat cd = dot(litDir, L);\nfloat attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\nreturn (attenuation * attenuation);\n}\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\nvec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\nvec3 position;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nposition = unpackHighpData(s.position, s.position_fract_part);\n#else\nposition = s.position;\n#endif\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 diffuseContrib = diffuse / PI;\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - position);\nfloat NV = max(abs(dot(N, V)), 0.0);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 finalColor = vec3(0.0);\nint numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\nfor (int i = 0; i < LIGHTS_PER_PASS; i++) {\nif (i >= numLights) break;\nvec3 SLU = cc_lightPos[i].xyz - position;\nvec3 SL = normalize(SLU);\nvec3 SH = normalize(SL + V);\nfloat SNL = max(dot(N, SL), 0.0);\nfloat SNH = max(dot(N, SH), 0.0);\nfloat distSqr = dot(SLU, SLU);\nfloat litRadius = cc_lightSizeRangeAngle[i].x;\nfloat litRadiusSqr = litRadius * litRadius;\nfloat illum = litRadiusSqr / max(litRadiusSqr, distSqr);\nfloat attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\nattRadiusSqrInv *= attRadiusSqrInv;\nfloat att = GetDistAtt(distSqr, attRadiusSqrInv);\nvec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\nif (cc_lightPos[i].w > 0.0) {\nfloat cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\nfloat cosOuter = cc_lightSizeRangeAngle[i].z;\nfloat litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\nfloat litAngleOffset = -cosOuter * litAngleScale;\natt *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n}\nvec3 lightColor = cc_lightColor[i].rgb;\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW\nif (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\nshadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n}\n#endif\nlightColor *= shadow;\nfinalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n}\nreturn vec4(finalColor, 0.0);\n}\n#endif\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\nlayout(std430, binding = 4) readonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };\nlayout(std430, binding = 5) readonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };\nlayout(std430, binding = 6) readonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };\nstruct CCLight\n{\nvec4 cc_lightPos;\nvec4 cc_lightColor;\nvec4 cc_lightSizeRangeAngle;\nvec4 cc_lightDir;\n};\nstruct Cluster\n{\nvec3 minBounds;\nvec3 maxBounds;\n};\nstruct LightGrid\n{\nuint offset;\nuint ccLights;\n};\nCCLight getCCLight(uint i)\n{\nCCLight light;\nlight.cc_lightPos = b_ccLights[4u * i + 0u];\nlight.cc_lightColor = b_ccLights[4u * i + 1u];\nlight.cc_lightSizeRangeAngle = b_ccLights[4u * i + 2u];\nlight.cc_lightDir = b_ccLights[4u * i + 3u];\nreturn light;\n}\nLightGrid getLightGrid(uint cluster)\n{\nuvec4 gridvec = b_clusterLightGrid[cluster];\nLightGrid grid;\ngrid.offset = gridvec.x;\ngrid.ccLights = gridvec.y;\nreturn grid;\n}\nuint getGridLightIndex(uint start, uint offset)\n{\nreturn b_clusterLightIndices[start + offset];\n}\nuint getClusterZIndex(vec4 worldPos)\n{\nfloat scale = float(24) / log(cc_nearFar.y / cc_nearFar.x);\nfloat bias = -(float(24) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));\nfloat eyeDepth = -(cc_matView * worldPos).z;\nuint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));\nreturn zIndex;\n}\nuint getClusterIndex(vec4 fragCoord, vec4 worldPos)\n{\nuint zIndex = getClusterZIndex(worldPos);\nfloat clusterSizeX = ceil(cc_viewPort.z / float(16));\nfloat clusterSizeY = ceil(cc_viewPort.w / float(8));\nuvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);\nuint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;\nreturn cluster;\n}\nvec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 diffuseContrib = diffuse / PI;\nvec3 position;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nposition = unpackHighpData(s.position, s.position_fract_part);\n#else\nposition = s.position;\n#endif\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - position);\nfloat NV = max(abs(dot(N, V)), 0.001);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 finalColor = vec3(0.0);\nuint cluster = getClusterIndex(gl_FragCoord, vec4(position, 1.0));\nLightGrid grid = getLightGrid(cluster);\nuint numLights = grid.ccLights;\nfor (uint i = 0u; i < 100u; i++) {\nif (i >= numLights) break;\nuint lightIndex = getGridLightIndex(grid.offset, i);\nCCLight light = getCCLight(lightIndex);\nvec3 SLU = light.cc_lightPos.xyz - position;\nvec3 SL = normalize(SLU);\nvec3 SH = normalize(SL + V);\nfloat SNL = max(dot(N, SL), 0.001);\nfloat SNH = max(dot(N, SH), 0.0);\nfloat distSqr = dot(SLU, SLU);\nfloat litRadius = light.cc_lightSizeRangeAngle.x;\nfloat litRadiusSqr = litRadius * litRadius;\nfloat illum = PI * (litRadiusSqr / max(litRadiusSqr , distSqr));\nfloat attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);\nattRadiusSqrInv *= attRadiusSqrInv;\nfloat att = GetDistAtt(distSqr, attRadiusSqrInv);\nvec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\nif (light.cc_lightPos.w > 0.0) {\nfloat cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);\nfloat cosOuter = light.cc_lightSizeRangeAngle.z;\nfloat litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\nfloat litAngleOffset = -cosOuter * litAngleScale;\natt *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);\n}\nvec3 lightColor = light.cc_lightColor.rgb;\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW\nif (light.cc_lightPos.w > 0.0) {\nshadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n}\n#endif\nlightColor *= shadow;\nfinalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);\n}\nreturn vec4(finalColor, 0.0);\n}\n#endif\nlayout(location = 0) out vec4 fragColorX;\nvoid main () {\nStandardSurface s; surf(s);\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\nvec4 color = CCClusterShadingAdditive(s, v_shadowPos);\n#else\nvec4 color = CCStandardShadingAdditive(s, v_shadowPos);\n#endif\nfragColorX = CCFragOutput(color);\n}\n#elif (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\nlayout(location = 0) out vec4 fragColorX;\nvoid main () {\nStandardSurface s; surf(s);\nvec4 color = CCStandardShadingBase(s, v_shadowPos);\nCC_APPLY_FOG(color, s.position.xyz);\nfragColorX = CCFragOutput(color);\n}\n#elif CC_PIPELINE_TYPE == 1\nvec2 signNotZero(vec2 v) {\nreturn vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n}\nvec2 float32x3_to_oct(in vec3 v) {\nvec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));\nreturn (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;\n}\nlayout(location = 0) out vec4 fragColor0;\nlayout(location = 1) out vec4 fragColor1;\nlayout(location = 2) out vec4 fragColor2;\nvoid main () {\nStandardSurface s; surf(s);\nfragColor0 = s.albedo;\nfragColor1 = vec4(float32x3_to_oct(s.normal), s.roughness, s.metallic);\nfragColor2 = vec4(s.emissive, s.occlusion);\n}\n#endif"},{vert:"\nprecision highp float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\nhighp vec4 cc_localShadowBias;\n};\nlayout(std140) uniform CCShadow {\nhighp mat4 cc_matLightPlaneProj;\nhighp mat4 cc_matLightView;\nhighp mat4 cc_matLightViewProj;\nhighp vec4 cc_shadowInvProjDepthInfo;\nhighp vec4 cc_shadowProjDepthInfo;\nhighp vec4 cc_shadowProjInfo;\nmediump vec4 cc_shadowNFLSInfo;\nmediump vec4 cc_shadowWHPBInfo;\nmediump vec4 cc_shadowLPNNInfo;\nlowp vec4 cc_shadowColor;\nmediump vec4 cc_planarNDInfo;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nout vec2 v_clip_depth;\nvec4 vert () {\nvec4 worldPos;\nworldPos.x = cc_matWorld[3][0] + a_position.x;\nworldPos.y = cc_matWorld[3][1] + a_position.y;\nworldPos.z = cc_matWorld[3][2] + a_position.z;\nworldPos.w = 1.0;\nvec4 clipPos = cc_matLightViewProj * worldPos;\nv_clip_depth = clipPos.zw;\nreturn clipPos;\n}\nvoid main() { gl_Position = vert(); }",frag:"\nprecision highp float;\nvec4 packDepthToRGBA (float depth) {\nvec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\nret = fract(ret);\nret -= vec4(ret.yzw, 0.0) / 255.0;\nreturn ret;\n}\nin vec2 v_clip_depth;\nvec4 frag () {\nreturn packDepthToRGBA(v_clip_depth.x / v_clip_depth.y * 0.5 + 0.5);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"}],[{vert:"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_SKINNING\nin vec4 a_joints;\nin vec4 a_weights;\n#endif\n#if USE_INSTANCING\n#if CC_USE_BAKED_ANIMATION\nin highp vec4 a_jointAnimInfo;\n#endif\nin vec4 a_matWorld0;\nin vec4 a_matWorld1;\nin vec4 a_matWorld2;\n#if CC_USE_LIGHTMAP\nin vec4 a_lightingMapUVParam;\n#endif\n#if CC_RECEIVE_SHADOW\nin vec2 a_localShadowBias;\n#endif\n#elif USE_BATCHING\nin float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\nin float a_vertexId;\nint getVertexId() {\nreturn int(a_vertexId);\n}\n#endif\n#if CC_USE_MORPH\nlayout(std140) uniform CCMorph {\nvec4 cc_displacementWeights[15];\nvec4 cc_displacementTextureInfo;\n};\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\nivec2 texSize = textureSize(tex, 0);\nreturn texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture(tex, x)),\ndecode32(texture(tex, y)),\ndecode32(texture(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nuniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nuniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nuniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nnormal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\ntangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\n#if CC_USE_BAKED_ANIMATION\nlayout(std140) uniform CCSkinningTexture {\nhighp vec4 cc_jointTextureInfo;\n};\nlayout(std140) uniform CCSkinningAnimation {\nhighp vec4 cc_jointAnimInfo;\n};\nuniform highp sampler2D cc_jointTexture;\nvoid CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n{\n#if USE_INSTANCING\nhighp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n#else\nhighp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n#endif\ninvSize = cc_jointTextureInfo.w;\nhighp float tempY = floor(temp * invSize);\nx = floor(temp - tempY * cc_jointTextureInfo.x);\ny = (tempY + 0.5) * invSize;\n}\n#else\nlayout(std140) uniform CCSkinning {\nhighp vec4 cc_joints[30 * 3];\n};\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(3.0, i, x, y, invSize);\nvec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(12.0, i, x, y, invSize);\nvec4 v1 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\nmat4 m = skinMatrix();\nposition = m * position;\nnormal = (m * vec4(normal, 0.0)).xyz;\ntangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n}\n#endif\nvoid CCVertInput(inout vec4 In)\n{\nIn = vec4(a_position, 1.0);\n#if CC_USE_MORPH\napplyMorph(In);\n#endif\n#if CC_USE_SKINNING\nCCSkin(In);\n#endif\n}\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\n#if !USE_INSTANCING\n#if USE_BATCHING\nlayout(std140) uniform CCLocalBatched {\nhighp mat4 cc_matWorlds[10];\n};\n#else\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\nhighp vec4 cc_localShadowBias;\n};\n#endif\n#endif\nvoid CCGetWorldMatrix(out mat4 matWorld)\n{\n#if USE_INSTANCING\nmatWorld = mat4(\nvec4(a_matWorld0.xyz, 0.0),\nvec4(a_matWorld1.xyz, 0.0),\nvec4(a_matWorld2.xyz, 0.0),\nvec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n);\n#elif USE_BATCHING\nmatWorld = cc_matWorlds[int(a_dyn_batch_id)];\n#else\nmatWorld = cc_matWorld;\n#endif\n}\nfloat LinearFog(vec4 pos) {\nvec4 wPos = pos;\nfloat cam_dis = distance(cc_cameraPos, wPos);\nfloat fogStart = cc_fogBase.x;\nfloat fogEnd = cc_fogBase.y;\nreturn clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * fogDensity);\nreturn f;\n}\nfloat ExpSquaredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\nreturn f;\n}\nfloat LayeredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat _FogTop = cc_fogAdd.x;\nfloat _FogRange = cc_fogAdd.y;\nvec3 camWorldProj = cc_cameraPos.xyz;\ncamWorldProj.y = 0.;\nvec3 worldPosProj = wPos.xyz;\nworldPosProj.y = 0.;\nfloat fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\nfloat fDeltaY, fDensityIntegral;\nif (cc_cameraPos.y > _FogTop) {\nif (wPos.y < _FogTop) {\nfDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\nfDensityIntegral = fDeltaY * fDeltaY * 0.5;\n} else {\nfDeltaY = 0.;\nfDensityIntegral = 0.;\n}\n} else {\nif (wPos.y < _FogTop) {\nfloat fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfloat fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\nfDeltaY = abs(fDeltaA - fDeltaB);\nfDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n} else {\nfDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n}\n}\nfloat fDensity;\nif (fDeltaY != 0.) {\nfDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n} else {\nfDensity = 0.;\n}\nfloat f = exp(-fDensity);\nreturn f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\nfactor = LinearFog(pos);\n#elif CC_USE_FOG == 1\nfactor = ExpFog(pos);\n#elif CC_USE_FOG == 2\nfactor = ExpSquaredFog(pos);\n#elif CC_USE_FOG == 3\nfactor = LayeredFog(pos);\n#else\nfactor = 1.0;\n#endif\n}\n#if !CC_USE_ACCURATE_FOG\nout float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\nCC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\n#if USE_VERTEX_COLOR\nin lowp vec4 a_color;\nout lowp vec4 v_color;\n#endif\n#if USE_TEXTURE\nout vec2 v_uv;\nlayout(std140) uniform TexCoords {\nvec4 tilingOffset;\n};\n#endif\nvec4 vert () {\nvec4 position;\nCCVertInput(position);\nmat4 matWorld;\nCCGetWorldMatrix(matWorld);\n#if USE_TEXTURE\nv_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n#if SAMPLE_FROM_RT\nv_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n#endif\n#endif\n#if USE_VERTEX_COLOR\nv_color = a_color;\n#endif\nCC_TRANSFER_FOG(matWorld * position);\nreturn cc_matProj * (cc_matView * matWorld) * position;\n}\nvoid main() { gl_Position = vert(); }",frag:"\nprecision highp float;\nvec3 ACESToneMap (vec3 color) {\ncolor = min(color, vec3(8.0));\nconst float A = 2.51;\nconst float B = 0.03;\nconst float C = 2.43;\nconst float D = 0.59;\nconst float E = 0.14;\nreturn (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n#if CC_USE_HDR\ncolor.rgb = ACESToneMap(color.rgb);\n#endif\ncolor.rgb = sqrt(color.rgb);\nreturn color;\n}\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nfloat LinearFog(vec4 pos) {\nvec4 wPos = pos;\nfloat cam_dis = distance(cc_cameraPos, wPos);\nfloat fogStart = cc_fogBase.x;\nfloat fogEnd = cc_fogBase.y;\nreturn clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * fogDensity);\nreturn f;\n}\nfloat ExpSquaredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\nreturn f;\n}\nfloat LayeredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat _FogTop = cc_fogAdd.x;\nfloat _FogRange = cc_fogAdd.y;\nvec3 camWorldProj = cc_cameraPos.xyz;\ncamWorldProj.y = 0.;\nvec3 worldPosProj = wPos.xyz;\nworldPosProj.y = 0.;\nfloat fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\nfloat fDeltaY, fDensityIntegral;\nif (cc_cameraPos.y > _FogTop) {\nif (wPos.y < _FogTop) {\nfDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\nfDensityIntegral = fDeltaY * fDeltaY * 0.5;\n} else {\nfDeltaY = 0.;\nfDensityIntegral = 0.;\n}\n} else {\nif (wPos.y < _FogTop) {\nfloat fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfloat fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\nfDeltaY = abs(fDeltaA - fDeltaB);\nfDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n} else {\nfDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n}\n}\nfloat fDensity;\nif (fDeltaY != 0.) {\nfDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n} else {\nfDensity = 0.;\n}\nfloat f = exp(-fDensity);\nreturn f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\nfactor = LinearFog(pos);\n#elif CC_USE_FOG == 1\nfactor = ExpFog(pos);\n#elif CC_USE_FOG == 2\nfactor = ExpSquaredFog(pos);\n#elif CC_USE_FOG == 3\nfactor = LayeredFog(pos);\n#else\nfactor = 1.0;\n#endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\ncolor = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if !CC_USE_ACCURATE_FOG\nin float v_fog_factor;\n#endif\nvoid CC_APPLY_FOG(inout vec4 color) {\n#if !CC_USE_ACCURATE_FOG\nCC_APPLY_FOG_BASE(color, v_fog_factor);\n#endif\n}\nvoid CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n#if CC_USE_ACCURATE_FOG\nfloat factor;\nCC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n#else\nfloat factor = v_fog_factor;\n#endif\nCC_APPLY_FOG_BASE(color, factor);\n}\n#if USE_ALPHA_TEST\n#endif\n#if USE_TEXTURE\nin vec2 v_uv;\nuniform sampler2D mainTexture;\n#endif\nlayout(std140) uniform Constant {\nvec4 mainColor;\nvec4 colorScaleAndCutoff;\n};\n#if USE_VERTEX_COLOR\nin lowp vec4 v_color;\n#endif\nvec4 frag () {\nvec4 o = mainColor;\no.rgb *= colorScaleAndCutoff.xyz;\n#if USE_VERTEX_COLOR\no.rgb *= SRGBToLinear(v_color.rgb);\no.a *= v_color.a;\n#endif\n#if USE_TEXTURE\nvec4 texColor = texture(mainTexture, v_uv);\ntexColor.rgb = SRGBToLinear(texColor.rgb);\no *= texColor;\n#endif\n#if USE_ALPHA_TEST\nif (o.ALPHA_TEST_CHANNEL < colorScaleAndCutoff.w) discard;\n#endif\nCC_APPLY_FOG(o);\nreturn CCFragOutput(o);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"}],[{vert:"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_SKINNING\nin vec4 a_joints;\nin vec4 a_weights;\n#endif\n#if USE_INSTANCING\n#if CC_USE_BAKED_ANIMATION\nin highp vec4 a_jointAnimInfo;\n#endif\nin vec4 a_matWorld0;\nin vec4 a_matWorld1;\nin vec4 a_matWorld2;\n#if CC_USE_LIGHTMAP\nin vec4 a_lightingMapUVParam;\n#endif\n#if CC_RECEIVE_SHADOW\nin vec2 a_localShadowBias;\n#endif\n#elif USE_BATCHING\nin float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\nin float a_vertexId;\nint getVertexId() {\nreturn int(a_vertexId);\n}\n#endif\n#if CC_USE_MORPH\nlayout(std140) uniform CCMorph {\nvec4 cc_displacementWeights[15];\nvec4 cc_displacementTextureInfo;\n};\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\nivec2 texSize = textureSize(tex, 0);\nreturn texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture(tex, x)),\ndecode32(texture(tex, y)),\ndecode32(texture(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nuniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nuniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nuniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nnormal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\ntangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\n#if CC_USE_BAKED_ANIMATION\nlayout(std140) uniform CCSkinningTexture {\nhighp vec4 cc_jointTextureInfo;\n};\nlayout(std140) uniform CCSkinningAnimation {\nhighp vec4 cc_jointAnimInfo;\n};\nuniform highp sampler2D cc_jointTexture;\nvoid CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n{\n#if USE_INSTANCING\nhighp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n#else\nhighp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n#endif\ninvSize = cc_jointTextureInfo.w;\nhighp float tempY = floor(temp * invSize);\nx = floor(temp - tempY * cc_jointTextureInfo.x);\ny = (tempY + 0.5) * invSize;\n}\n#else\nlayout(std140) uniform CCSkinning {\nhighp vec4 cc_joints[30 * 3];\n};\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(3.0, i, x, y, invSize);\nvec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(12.0, i, x, y, invSize);\nvec4 v1 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\nmat4 m = skinMatrix();\nposition = m * position;\nnormal = (m * vec4(normal, 0.0)).xyz;\ntangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n}\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\nIn.position = vec4(a_position, 1.0);\nIn.normal = a_normal;\nIn.tangent = a_tangent;\n#if CC_USE_MORPH\napplyMorph(In.position, In.normal, In.tangent);\n#endif\n#if CC_USE_SKINNING\nCCSkin(In.position, In.normal, In.tangent);\n#endif\n}\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nout vec2 v_uv;\nvoid main () {\nStandardVertInput In;\nCCVertInput(In);\nIn.position.xy = cc_cameraPos.w == 0.0 ? vec2(In.position.xy.x, -In.position.xy.y) : In.position.xy;\ngl_Position = In.position;\ngl_Position.y = gl_Position.y;\nv_uv = a_texCoord;\n}",frag:"\nprecision highp float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nin vec2 v_uv;\nlayout(std140) uniform BloomUBO {\nmediump vec4 texSize;\n};\nuniform sampler2D outputResultMap;\nlayout(location = 0) out vec4 fragColor;\nfloat luminance(vec3 color) {\nreturn dot(color, vec3(0.2126, 0.7152, 0.0722));\n}\nvoid main() {\nvec3 color = texture(outputResultMap, v_uv).xyz;\nif (luminance(SRGBToLinear(color)) > texSize.z) {\nfragColor = vec4(color, 1.0);\n} else {\nfragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n}"},{vert:"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_SKINNING\nin vec4 a_joints;\nin vec4 a_weights;\n#endif\n#if USE_INSTANCING\n#if CC_USE_BAKED_ANIMATION\nin highp vec4 a_jointAnimInfo;\n#endif\nin vec4 a_matWorld0;\nin vec4 a_matWorld1;\nin vec4 a_matWorld2;\n#if CC_USE_LIGHTMAP\nin vec4 a_lightingMapUVParam;\n#endif\n#if CC_RECEIVE_SHADOW\nin vec2 a_localShadowBias;\n#endif\n#elif USE_BATCHING\nin float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\nin float a_vertexId;\nint getVertexId() {\nreturn int(a_vertexId);\n}\n#endif\n#if CC_USE_MORPH\nlayout(std140) uniform CCMorph {\nvec4 cc_displacementWeights[15];\nvec4 cc_displacementTextureInfo;\n};\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\nivec2 texSize = textureSize(tex, 0);\nreturn texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture(tex, x)),\ndecode32(texture(tex, y)),\ndecode32(texture(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nuniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nuniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nuniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nnormal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\ntangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\n#if CC_USE_BAKED_ANIMATION\nlayout(std140) uniform CCSkinningTexture {\nhighp vec4 cc_jointTextureInfo;\n};\nlayout(std140) uniform CCSkinningAnimation {\nhighp vec4 cc_jointAnimInfo;\n};\nuniform highp sampler2D cc_jointTexture;\nvoid CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n{\n#if USE_INSTANCING\nhighp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n#else\nhighp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n#endif\ninvSize = cc_jointTextureInfo.w;\nhighp float tempY = floor(temp * invSize);\nx = floor(temp - tempY * cc_jointTextureInfo.x);\ny = (tempY + 0.5) * invSize;\n}\n#else\nlayout(std140) uniform CCSkinning {\nhighp vec4 cc_joints[30 * 3];\n};\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(3.0, i, x, y, invSize);\nvec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(12.0, i, x, y, invSize);\nvec4 v1 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\nmat4 m = skinMatrix();\nposition = m * position;\nnormal = (m * vec4(normal, 0.0)).xyz;\ntangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n}\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\nIn.position = vec4(a_position, 1.0);\nIn.normal = a_normal;\nIn.tangent = a_tangent;\n#if CC_USE_MORPH\napplyMorph(In.position, In.normal, In.tangent);\n#endif\n#if CC_USE_SKINNING\nCCSkin(In.position, In.normal, In.tangent);\n#endif\n}\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nout vec2 v_uv;\nvoid main () {\nStandardVertInput In;\nCCVertInput(In);\nIn.position.xy = cc_cameraPos.w == 0.0 ? vec2(In.position.xy.x, -In.position.xy.y) : In.position.xy;\ngl_Position = In.position;\ngl_Position.y = gl_Position.y;\nv_uv = a_texCoord;\n}",frag:"\nprecision highp float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nin vec2 v_uv;\nlayout(std140) uniform BloomUBO {\nmediump vec4 texSize;\n};\nuniform sampler2D bloomTexture;\nlayout(location = 0) out vec4 fragColor;\nvec3 downsample4taps(vec2 uv, vec2 halfpixel) {\nvec3 sum = texture(bloomTexture, uv + vec2(-halfpixel.x, halfpixel.y)).xyz;\nsum += texture(bloomTexture, uv + vec2(halfpixel.x, halfpixel.y)).xyz;\nsum += texture(bloomTexture, uv + vec2(halfpixel.x, -halfpixel.y)).xyz;\nsum += texture(bloomTexture, uv + vec2(-halfpixel.x, -halfpixel.y)).xyz;\nreturn sum / 4.0;\n}\nvoid main()\n{\nvec3 result = downsample4taps(v_uv, 1.0 / texSize.xy).rgb;\nfragColor = vec4(result, 1.0);\n}"},{vert:"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_SKINNING\nin vec4 a_joints;\nin vec4 a_weights;\n#endif\n#if USE_INSTANCING\n#if CC_USE_BAKED_ANIMATION\nin highp vec4 a_jointAnimInfo;\n#endif\nin vec4 a_matWorld0;\nin vec4 a_matWorld1;\nin vec4 a_matWorld2;\n#if CC_USE_LIGHTMAP\nin vec4 a_lightingMapUVParam;\n#endif\n#if CC_RECEIVE_SHADOW\nin vec2 a_localShadowBias;\n#endif\n#elif USE_BATCHING\nin float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\nin float a_vertexId;\nint getVertexId() {\nreturn int(a_vertexId);\n}\n#endif\n#if CC_USE_MORPH\nlayout(std140) uniform CCMorph {\nvec4 cc_displacementWeights[15];\nvec4 cc_displacementTextureInfo;\n};\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\nivec2 texSize = textureSize(tex, 0);\nreturn texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture(tex, x)),\ndecode32(texture(tex, y)),\ndecode32(texture(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nuniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nuniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nuniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nnormal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\ntangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\n#if CC_USE_BAKED_ANIMATION\nlayout(std140) uniform CCSkinningTexture {\nhighp vec4 cc_jointTextureInfo;\n};\nlayout(std140) uniform CCSkinningAnimation {\nhighp vec4 cc_jointAnimInfo;\n};\nuniform highp sampler2D cc_jointTexture;\nvoid CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n{\n#if USE_INSTANCING\nhighp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n#else\nhighp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n#endif\ninvSize = cc_jointTextureInfo.w;\nhighp float tempY = floor(temp * invSize);\nx = floor(temp - tempY * cc_jointTextureInfo.x);\ny = (tempY + 0.5) * invSize;\n}\n#else\nlayout(std140) uniform CCSkinning {\nhighp vec4 cc_joints[30 * 3];\n};\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(3.0, i, x, y, invSize);\nvec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(12.0, i, x, y, invSize);\nvec4 v1 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\nmat4 m = skinMatrix();\nposition = m * position;\nnormal = (m * vec4(normal, 0.0)).xyz;\ntangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n}\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\nIn.position = vec4(a_position, 1.0);\nIn.normal = a_normal;\nIn.tangent = a_tangent;\n#if CC_USE_MORPH\napplyMorph(In.position, In.normal, In.tangent);\n#endif\n#if CC_USE_SKINNING\nCCSkin(In.position, In.normal, In.tangent);\n#endif\n}\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nout vec2 v_uv;\nvoid main () {\nStandardVertInput In;\nCCVertInput(In);\nIn.position.xy = cc_cameraPos.w == 0.0 ? vec2(In.position.xy.x, -In.position.xy.y) : In.position.xy;\ngl_Position = In.position;\ngl_Position.y = gl_Position.y;\nv_uv = a_texCoord;\n}",frag:"\nprecision highp float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nin vec2 v_uv;\nlayout(std140) uniform BloomUBO {\nmediump vec4 texSize;\n};\nuniform sampler2D bloomTexture;\nlayout(location = 0) out vec4 fragColor;\nvec3 upsample4taps(vec2 uv, vec2 halfpixel) {\nvec3 sum = texture(bloomTexture, uv + vec2(-halfpixel.x, halfpixel.y)).xyz;\nsum += texture(bloomTexture, uv + vec2(halfpixel.x, halfpixel.y)).xyz;\nsum += texture(bloomTexture, uv + vec2(halfpixel.x, -halfpixel.y)).xyz;\nsum += texture(bloomTexture, uv + vec2(-halfpixel.x, -halfpixel.y)).xyz;\nreturn sum / 4.0;\n}\nvoid main() {\nvec3 result = upsample4taps(v_uv, 0.5 / texSize.xy).rgb;\nfragColor = vec4(result, 1.0);\n}"},{vert:"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_SKINNING\nin vec4 a_joints;\nin vec4 a_weights;\n#endif\n#if USE_INSTANCING\n#if CC_USE_BAKED_ANIMATION\nin highp vec4 a_jointAnimInfo;\n#endif\nin vec4 a_matWorld0;\nin vec4 a_matWorld1;\nin vec4 a_matWorld2;\n#if CC_USE_LIGHTMAP\nin vec4 a_lightingMapUVParam;\n#endif\n#if CC_RECEIVE_SHADOW\nin vec2 a_localShadowBias;\n#endif\n#elif USE_BATCHING\nin float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\nin float a_vertexId;\nint getVertexId() {\nreturn int(a_vertexId);\n}\n#endif\n#if CC_USE_MORPH\nlayout(std140) uniform CCMorph {\nvec4 cc_displacementWeights[15];\nvec4 cc_displacementTextureInfo;\n};\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\nivec2 texSize = textureSize(tex, 0);\nreturn texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture(tex, x)),\ndecode32(texture(tex, y)),\ndecode32(texture(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nuniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nuniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nuniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nnormal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\ntangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\n#if CC_USE_BAKED_ANIMATION\nlayout(std140) uniform CCSkinningTexture {\nhighp vec4 cc_jointTextureInfo;\n};\nlayout(std140) uniform CCSkinningAnimation {\nhighp vec4 cc_jointAnimInfo;\n};\nuniform highp sampler2D cc_jointTexture;\nvoid CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n{\n#if USE_INSTANCING\nhighp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n#else\nhighp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n#endif\ninvSize = cc_jointTextureInfo.w;\nhighp float tempY = floor(temp * invSize);\nx = floor(temp - tempY * cc_jointTextureInfo.x);\ny = (tempY + 0.5) * invSize;\n}\n#else\nlayout(std140) uniform CCSkinning {\nhighp vec4 cc_joints[30 * 3];\n};\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(3.0, i, x, y, invSize);\nvec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(12.0, i, x, y, invSize);\nvec4 v1 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\nmat4 m = skinMatrix();\nposition = m * position;\nnormal = (m * vec4(normal, 0.0)).xyz;\ntangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n}\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\nIn.position = vec4(a_position, 1.0);\nIn.normal = a_normal;\nIn.tangent = a_tangent;\n#if CC_USE_MORPH\napplyMorph(In.position, In.normal, In.tangent);\n#endif\n#if CC_USE_SKINNING\nCCSkin(In.position, In.normal, In.tangent);\n#endif\n}\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nout vec2 v_uv;\nvoid main () {\nStandardVertInput In;\nCCVertInput(In);\nIn.position.xy = cc_cameraPos.w == 0.0 ? vec2(In.position.xy.x, -In.position.xy.y) : In.position.xy;\ngl_Position = In.position;\ngl_Position.y = gl_Position.y;\nv_uv = a_texCoord;\n}",frag:"\nprecision highp float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nin vec2 v_uv;\nlayout(std140) uniform BloomUBO {\nmediump vec4 texSize;\n};\nuniform sampler2D outputResultMap;\nuniform sampler2D bloomTexture;\nlayout(location = 0) out vec4 fragColor;\nvoid main() {\nvec4 hdrColor = texture(outputResultMap, v_uv);\nvec3 bloomColor = texture(bloomTexture, v_uv).rgb;\nvec3 result = hdrColor.rgb + bloomColor * texSize.w * hdrColor.a;\nfragColor = vec4(result, hdrColor.a);\n}"}],[{vert:"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_SKINNING\nin vec4 a_joints;\nin vec4 a_weights;\n#endif\n#if USE_INSTANCING\n#if CC_USE_BAKED_ANIMATION\nin highp vec4 a_jointAnimInfo;\n#endif\nin vec4 a_matWorld0;\nin vec4 a_matWorld1;\nin vec4 a_matWorld2;\n#if CC_USE_LIGHTMAP\nin vec4 a_lightingMapUVParam;\n#endif\n#if CC_RECEIVE_SHADOW\nin vec2 a_localShadowBias;\n#endif\n#elif USE_BATCHING\nin float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\nin float a_vertexId;\n#endif\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nout vec2 v_uv;\nvoid main () {\nvec4 position;\nposition = vec4(a_position, 1.0);\nposition.xy = cc_cameraPos.w == 0.0 ? vec2(position.xy.x, -position.xy.y) : position.xy;\ngl_Position = vec4(position.x, position.y, 1.0, 1.0);\nv_uv = a_texCoord;\n}",frag:"\n#ifdef GL_EXT_shader_framebuffer_fetch\n#extension GL_EXT_shader_framebuffer_fetch: enable\n#endif\nprecision highp float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nlayout(std140) uniform CCShadow {\nhighp mat4 cc_matLightPlaneProj;\nhighp mat4 cc_matLightView;\nhighp mat4 cc_matLightViewProj;\nhighp vec4 cc_shadowInvProjDepthInfo;\nhighp vec4 cc_shadowProjDepthInfo;\nhighp vec4 cc_shadowProjInfo;\nmediump vec4 cc_shadowNFLSInfo;\nmediump vec4 cc_shadowWHPBInfo;\nmediump vec4 cc_shadowLPNNInfo;\nlowp vec4 cc_shadowColor;\nmediump vec4 cc_planarNDInfo;\n};\nhighp float unpackHighpData (float mainPart, float modPart) {\nhighp float data = mainPart;\nreturn data + modPart;\n}\nhighp float unpackHighpData (float mainPart, float modPart, const float modValue) {\nhighp float data = mainPart * modValue;\nreturn data + modPart * modValue;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\nhighp vec2 data = mainPart;\nreturn data + modPart;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\nhighp vec2 data = mainPart * modValue;\nreturn data + modPart * modValue;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\nhighp vec3 data = mainPart;\nreturn data + modPart;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\nhighp vec3 data = mainPart * modValue;\nreturn data + modPart * modValue;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\nhighp vec4 data = mainPart;\nreturn data + modPart;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\nhighp vec4 data = mainPart * modValue;\nreturn data + modPart * modValue;\n}\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\nhighp vec4 cc_localShadowBias;\n};\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\nfloat dist = length(viewPos);\nreturn (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\nvec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\nreturn CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\nuniform highp sampler2D cc_shadowMap;\nuniform highp sampler2D cc_spotLightingMap;\nvec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias)\n{\nvec4 newShadowPos = shadowPos;\nif(normalBias > EPSILON_LOWP)\n{\nvec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);\nif(viewNormal.z < 0.1)\nnewShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n}\nreturn newShadowPos;\n}\nvec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n{\nvec3 viewSpacePos;\nviewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\nviewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;\nviewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\nvec4 clipSpacePos;\nclipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\nclipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\nif (cc_shadowNFLSInfo.z > EPSILON) {\nclipSpacePos.z = CCGetLinearDepthFromViewSpace(viewSpacePos.xyz);\nclipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n}\nreturn clipSpacePos;\n}\nvec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)\n{\nfloat coeffA = cc_shadowProjDepthInfo.x;\nfloat coeffB = cc_shadowProjDepthInfo.y;\nfloat viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\nviewSpacePos_z += viewspaceDepthBias;\nvec4 result = shadowPos;\nresult.z = viewSpacePos_z * coeffA + coeffB;\nreturn result;\n}\nfloat CCGetShadowFactorHard (vec4 shadowPos, float bias) {\nvec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nif (cc_shadowLPNNInfo.y > EPSILON) {\nclosestDepth = dot(texture(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n} else {\nclosestDepth = texture(cc_shadowMap, clipPos.xy).x;\n}\nshadow = step(clipPos.z, closestDepth);\nreturn shadow;\n}\nfloat CCGetShadowFactorSoft (vec4 shadowPos, float bias) {\nvec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetDepth = clipPos.z;\nvec2 mapSize = cc_shadowWHPBInfo.xy;\nvec2 oneTap = 1.0 / mapSize;\nvec2 clipPos_offset = clipPos.xy + oneTap;\nfloat block0, block1, block2, block3;\nif (cc_shadowLPNNInfo.y > EPSILON) {\nblock0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n} else {\nblock0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\nblock1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\nblock2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\nblock3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n}\nfloat coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block2, block3, coefX);\nfloat coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;\nreturn mix(resultX, resultY, coefY);\n}\nfloat CCGetShadowFactorSoft2X (vec4 shadowPos, float bias) {\nvec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat offsetDepth = clipPos.z;\nvec2 mapSize = cc_shadowWHPBInfo.xy;\nvec2 oneTap = 1.0 / mapSize;\nfloat clipPos_offset_L = clipPos.x - oneTap.x;\nfloat clipPos_offset_R = clipPos.x + oneTap.x;\nfloat clipPos_offset_U = clipPos.y - oneTap.y;\nfloat clipPos_offset_D = clipPos.y + oneTap.y;\nfloat block0, block1, block2, block3, block4, block5, block6, block7, block8;\nif (cc_shadowLPNNInfo.y > EPSILON) {\nblock0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock4 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock5 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock6 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock7 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock8 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n} else {\nblock0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\nblock1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\nblock2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\nblock3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\nblock4 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\nblock5 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\nblock6 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\nblock7 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\nblock8 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n}\nfloat coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\nfloat coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\nfloat shadow = 0.0;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block3, block4, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block1, block2, coefX);\nresultY = mix(block4, block5, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block3, block4, coefX);\nresultY = mix(block6, block7, coefX);\nshadow += mix(resultX, resultY, coefY);\nresultX = mix(block4, block5, coefX);\nresultY = mix(block7, block8, coefX);\nshadow += mix(resultX, resultY, coefY);\nreturn shadow * 0.25;\n}\nfloat CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos, float bias) {\nvec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nfloat depth = clipPos.z;\nif (cc_shadowLPNNInfo.y > EPSILON) {\nclosestDepth = dot(texture(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n} else {\nclosestDepth = texture(cc_spotLightingMap, clipPos.xy).x;\n}\nshadow = step(depth, closestDepth);\nreturn shadow;\n}\nfloat CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos, float bias) {\nvec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > EPSILON) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nvec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\nvec2 clipPos_offset = clipPos.xy + oneTap;\nfloat block0, block1, block2, block3;\nif (cc_shadowLPNNInfo.y > EPSILON) {\nblock0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n} else {\nblock0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\nblock1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)).x);\nblock2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)).x);\nblock3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n}\nfloat coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block2, block3, coefX);\nfloat coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\nreturn mix(resultX, resultY, coefY);\n}\nfloat CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos, float bias) {\nvec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\nvec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > EPSILON) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nvec2 mapSize = cc_shadowWHPBInfo.xy;\nvec2 oneTap = 1.0 / mapSize;\nfloat clipPos_offset_L = clipPos.x - oneTap.x;\nfloat clipPos_offset_R = clipPos.x + oneTap.x;\nfloat clipPos_offset_U = clipPos.y - oneTap.y;\nfloat clipPos_offset_D = clipPos.y + oneTap.y;\nfloat block0, block1, block2, block3, block4, block5, block6, block7, block8;\nif (cc_shadowLPNNInfo.y > EPSILON) {\nblock0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock4 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock5 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock6 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock7 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\nblock8 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n} else {\nblock0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\nblock1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)).x);\nblock2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\nblock3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)).x);\nblock4 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\nblock5 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)).x);\nblock6 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\nblock7 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)).x);\nblock8 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n}\nfloat coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\nfloat coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\nfloat shadow = 0.0;\nfloat resultX = mix(block0, block1, coefX);\nfloat resultY = mix(block3, block4, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block1, block2, coefX);\nresultY = mix(block4, block5, coefX);\nshadow += mix(resultX , resultY, coefY);\nresultX = mix(block3, block4, coefX);\nresultY = mix(block6, block7, coefX);\nshadow += mix(resultX, resultY, coefY);\nresultX = mix(block4, block5, coefX);\nresultY = mix(block7, block8, coefX);\nshadow += mix(resultX, resultY, coefY);\nreturn shadow * 0.25;\n}\nfloat CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n{\nfloat pcf = cc_shadowWHPBInfo.z;\nif (pcf > 1.9) {\nreturn CCGetSpotLightShadowFactorSoft2X(shadowPos, worldPos, shadowBias.x);\n}else if (pcf > 0.9) {\nreturn CCGetSpotLightShadowFactorSoft(shadowPos, worldPos, shadowBias.x);\n}else {\nreturn CCGetSpotLightShadowFactorHard(shadowPos, worldPos, shadowBias.x);\n}\n}\nfloat CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias)\n{\nfloat realtimeShadow = 1.0;\nvec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y);\nfloat pcf = cc_shadowWHPBInfo.z;\nif (pcf > 1.9) {\nrealtimeShadow =  CCGetShadowFactorSoft2X(pos, shadowBias.x);\n}else if (pcf > 0.9) {\nrealtimeShadow = CCGetShadowFactorSoft(pos, shadowBias.x);\n}else {\nrealtimeShadow = CCGetShadowFactorHard(pos, shadowBias.x);\n}\nreturn mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n}\n#endif\n#if CC_USE_IBL\nuniform samplerCube cc_environment;\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\nreturn textureLod(tex, coord, lod);\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\nreturn textureLod(tex, coord, lod);\n}\nvec3 unpackRGBE (vec4 rgbe) {\nreturn rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n}\n#if CC_USE_DIFFUSEMAP\nuniform samplerCube cc_diffuseMap;\n#endif\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\nvec3 NxH = cross(N, H);\nfloat OneMinusNoHSqr = dot(NxH, NxH);\nfloat a = roughness * roughness;\nfloat n = NoH * a;\nfloat p = a / (OneMinusNoHSqr + n * n);\nreturn p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\nreturn (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\nconst vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\nconst vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\nvec4 r = roughness * c0 + c1;\nfloat a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\nvec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\nAB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\nreturn specular * AB.x + AB.y;\n}\n#if USE_REFLECTION_DENOISE\nvec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n#if CC_USE_IBL\nfloat mip = roughness * mipCount;\nfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\nfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\nvec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);\nvec4 filtered = texture(cc_environment, R);\n#if CC_USE_IBL == 2\nbiased.rgb = unpackRGBE(biased);\nfiltered.rgb = unpackRGBE(filtered);\n#else\nbiased.rgb = SRGBToLinear(biased.rgb);\nfiltered.rgb = SRGBToLinear(filtered.rgb);\n#endif\nreturn mix(biased.rgb, filtered.rgb, denoiseIntensity);\n#else\nreturn vec3(0.0, 0.0, 0.0);\n#endif\n}\n#endif\nstruct StandardSurface {\nvec4 albedo;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nvec3 position, position_fract_part;\n#else\nvec3 position;\n#endif\nvec3 normal;\nvec3 emissive;\nvec3 lightmap;\nfloat lightmap_test;\nfloat roughness;\nfloat metallic;\nfloat occlusion;\nfloat specularIntensity;\n#if CC_RECEIVE_SHADOW\nvec2 shadowBias;\n#endif\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.08 * s.specularIntensity), s.albedo.rgb, s.metallic);\nvec3 position;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nposition = unpackHighpData(s.position, s.position_fract_part);\n#else\nposition = s.position;\n#endif\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - position);\nfloat NV = max(abs(dot(N, V)), 0.0);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 L = normalize(-cc_mainLitDir.xyz);\nvec3 H = normalize(L + V);\nfloat NH = max(dot(N, H), 0.0);\nfloat NL = max(dot(N, L), 0.0);\nvec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\nvec3 diffuseContrib = diffuse / PI;\nvec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\nvec3 dirlightContrib = (diffuseContrib + specularContrib);\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW\nif (NL > 0.0 && cc_mainLitDir.w > 0.0) {\nshadow = CCShadowFactorBase(shadowPos, N, s.shadowBias);\n}\n#endif\ndirlightContrib *= shadow;\nfinalColor *= dirlightContrib;\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nif (s.lightmap_test > EPSILON_LOWP) {\nfinalColor = diffuse * s.lightmap.rgb * shadow;\n}\n#endif\nfloat fAmb = 0.5 - N.y * 0.5;\nvec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n#if CC_USE_IBL\n#if CC_USE_DIFFUSEMAP\nvec4 diffuseMap = texture(cc_diffuseMap, N);\n#if CC_USE_DIFFUSEMAP == 2\nambDiff = unpackRGBE(diffuseMap);\n#else\nambDiff = SRGBToLinear(diffuseMap.rgb);\n#endif\n#endif\nvec3 R = normalize(reflect(-V, N));\n#if USE_REFLECTION_DENOISE\nvec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);\n#else\nvec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n#if CC_USE_IBL == 2\nvec3 env = unpackRGBE(envmap);\n#else\nvec3 env = SRGBToLinear(envmap.rgb);\n#endif\n#endif\nfinalColor += env * cc_ambientSky.w * specular * s.occlusion;\n#endif\nfinalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;\nfinalColor += s.emissive;\nreturn vec4(finalColor, s.albedo.a);\n}\n#if CC_PIPELINE_TYPE == 0\n#define LIGHTS_PER_PASS 1\n#else\n#define LIGHTS_PER_PASS 10\n#endif\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\nlayout(std140) uniform CCForwardLight {\nhighp vec4 cc_lightPos[LIGHTS_PER_PASS];\nvec4 cc_lightColor[LIGHTS_PER_PASS];\nvec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\nvec4 cc_lightDir[LIGHTS_PER_PASS];\n};\n#endif\nfloat SmoothDistAtt (float distSqr, float invSqrAttRadius) {\nfloat factor = distSqr * invSqrAttRadius;\nfloat smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\nreturn smoothFactor * smoothFactor;\n}\nfloat GetDistAtt (float distSqr, float invSqrAttRadius) {\nfloat attenuation = 1.0 / max(distSqr, 0.01*0.01);\nattenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\nreturn attenuation;\n}\nfloat GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\nfloat cd = dot(litDir, L);\nfloat attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\nreturn (attenuation * attenuation);\n}\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\nvec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\nvec3 position;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nposition = unpackHighpData(s.position, s.position_fract_part);\n#else\nposition = s.position;\n#endif\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 diffuseContrib = diffuse / PI;\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - position);\nfloat NV = max(abs(dot(N, V)), 0.0);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 finalColor = vec3(0.0);\nint numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\nfor (int i = 0; i < LIGHTS_PER_PASS; i++) {\nif (i >= numLights) break;\nvec3 SLU = cc_lightPos[i].xyz - position;\nvec3 SL = normalize(SLU);\nvec3 SH = normalize(SL + V);\nfloat SNL = max(dot(N, SL), 0.0);\nfloat SNH = max(dot(N, SH), 0.0);\nfloat distSqr = dot(SLU, SLU);\nfloat litRadius = cc_lightSizeRangeAngle[i].x;\nfloat litRadiusSqr = litRadius * litRadius;\nfloat illum = litRadiusSqr / max(litRadiusSqr, distSqr);\nfloat attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\nattRadiusSqrInv *= attRadiusSqrInv;\nfloat att = GetDistAtt(distSqr, attRadiusSqrInv);\nvec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\nif (cc_lightPos[i].w > 0.0) {\nfloat cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\nfloat cosOuter = cc_lightSizeRangeAngle[i].z;\nfloat litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\nfloat litAngleOffset = -cosOuter * litAngleScale;\natt *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n}\nvec3 lightColor = cc_lightColor[i].rgb;\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW\nif (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\nshadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n}\n#endif\nlightColor *= shadow;\nfinalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n}\nreturn vec4(finalColor, 0.0);\n}\n#endif\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\nlayout(std430, binding = 4) readonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };\nlayout(std430, binding = 5) readonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };\nlayout(std430, binding = 6) readonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };\nstruct CCLight\n{\nvec4 cc_lightPos;\nvec4 cc_lightColor;\nvec4 cc_lightSizeRangeAngle;\nvec4 cc_lightDir;\n};\nstruct Cluster\n{\nvec3 minBounds;\nvec3 maxBounds;\n};\nstruct LightGrid\n{\nuint offset;\nuint ccLights;\n};\nCCLight getCCLight(uint i)\n{\nCCLight light;\nlight.cc_lightPos = b_ccLights[4u * i + 0u];\nlight.cc_lightColor = b_ccLights[4u * i + 1u];\nlight.cc_lightSizeRangeAngle = b_ccLights[4u * i + 2u];\nlight.cc_lightDir = b_ccLights[4u * i + 3u];\nreturn light;\n}\nLightGrid getLightGrid(uint cluster)\n{\nuvec4 gridvec = b_clusterLightGrid[cluster];\nLightGrid grid;\ngrid.offset = gridvec.x;\ngrid.ccLights = gridvec.y;\nreturn grid;\n}\nuint getGridLightIndex(uint start, uint offset)\n{\nreturn b_clusterLightIndices[start + offset];\n}\nuint getClusterZIndex(vec4 worldPos)\n{\nfloat scale = float(24) / log(cc_nearFar.y / cc_nearFar.x);\nfloat bias = -(float(24) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));\nfloat eyeDepth = -(cc_matView * worldPos).z;\nuint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));\nreturn zIndex;\n}\nuint getClusterIndex(vec4 fragCoord, vec4 worldPos)\n{\nuint zIndex = getClusterZIndex(worldPos);\nfloat clusterSizeX = ceil(cc_viewPort.z / float(16));\nfloat clusterSizeY = ceil(cc_viewPort.w / float(8));\nuvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);\nuint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;\nreturn cluster;\n}\nvec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 diffuseContrib = diffuse / PI;\nvec3 position;\n#if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\nposition = unpackHighpData(s.position, s.position_fract_part);\n#else\nposition = s.position;\n#endif\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - position);\nfloat NV = max(abs(dot(N, V)), 0.001);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 finalColor = vec3(0.0);\nuint cluster = getClusterIndex(gl_FragCoord, vec4(position, 1.0));\nLightGrid grid = getLightGrid(cluster);\nuint numLights = grid.ccLights;\nfor (uint i = 0u; i < 100u; i++) {\nif (i >= numLights) break;\nuint lightIndex = getGridLightIndex(grid.offset, i);\nCCLight light = getCCLight(lightIndex);\nvec3 SLU = light.cc_lightPos.xyz - position;\nvec3 SL = normalize(SLU);\nvec3 SH = normalize(SL + V);\nfloat SNL = max(dot(N, SL), 0.001);\nfloat SNH = max(dot(N, SH), 0.0);\nfloat distSqr = dot(SLU, SLU);\nfloat litRadius = light.cc_lightSizeRangeAngle.x;\nfloat litRadiusSqr = litRadius * litRadius;\nfloat illum = PI * (litRadiusSqr / max(litRadiusSqr , distSqr));\nfloat attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);\nattRadiusSqrInv *= attRadiusSqrInv;\nfloat att = GetDistAtt(distSqr, attRadiusSqrInv);\nvec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\nif (light.cc_lightPos.w > 0.0) {\nfloat cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);\nfloat cosOuter = light.cc_lightSizeRangeAngle.z;\nfloat litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\nfloat litAngleOffset = -cosOuter * litAngleScale;\natt *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);\n}\nvec3 lightColor = light.cc_lightColor.rgb;\nfloat shadow = 1.0;\n#if CC_RECEIVE_SHADOW\nif (light.cc_lightPos.w > 0.0) {\nshadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n}\n#endif\nlightColor *= shadow;\nfinalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);\n}\nreturn vec4(finalColor, 0.0);\n}\n#endif\nvec3 ACESToneMap (vec3 color) {\ncolor = min(color, vec3(8.0));\nconst float A = 2.51;\nconst float B = 0.03;\nconst float C = 2.43;\nconst float D = 0.59;\nconst float E = 0.14;\nreturn (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n#if CC_USE_HDR\ncolor.rgb = ACESToneMap(color.rgb);\n#endif\ncolor.rgb = sqrt(color.rgb);\nreturn color;\n}\nfloat LinearFog(vec4 pos) {\nvec4 wPos = pos;\nfloat cam_dis = distance(cc_cameraPos, wPos);\nfloat fogStart = cc_fogBase.x;\nfloat fogEnd = cc_fogBase.y;\nreturn clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * fogDensity);\nreturn f;\n}\nfloat ExpSquaredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogStart = cc_fogBase.x;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\nfloat f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\nreturn f;\n}\nfloat LayeredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat _FogTop = cc_fogAdd.x;\nfloat _FogRange = cc_fogAdd.y;\nvec3 camWorldProj = cc_cameraPos.xyz;\ncamWorldProj.y = 0.;\nvec3 worldPosProj = wPos.xyz;\nworldPosProj.y = 0.;\nfloat fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\nfloat fDeltaY, fDensityIntegral;\nif (cc_cameraPos.y > _FogTop) {\nif (wPos.y < _FogTop) {\nfDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\nfDensityIntegral = fDeltaY * fDeltaY * 0.5;\n} else {\nfDeltaY = 0.;\nfDensityIntegral = 0.;\n}\n} else {\nif (wPos.y < _FogTop) {\nfloat fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfloat fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\nfDeltaY = abs(fDeltaA - fDeltaB);\nfDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n} else {\nfDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n}\n}\nfloat fDensity;\nif (fDeltaY != 0.) {\nfDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n} else {\nfDensity = 0.;\n}\nfloat f = exp(-fDensity);\nreturn f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\nfactor = LinearFog(pos);\n#elif CC_USE_FOG == 1\nfactor = ExpFog(pos);\n#elif CC_USE_FOG == 2\nfactor = ExpSquaredFog(pos);\n#elif CC_USE_FOG == 3\nfactor = LayeredFog(pos);\n#else\nfactor = 1.0;\n#endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\ncolor = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\nvec2 signNotZero(vec2 v) {\nreturn vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n}\nvec3 oct_to_float32x3(vec2 e) {\nvec3 v = vec3(e.xy, 1.0 - abs(e.x) - abs(e.y));\nif (v.z < 0.0) v.xy = (1.0 - abs(v.yx)) * signNotZero(v.xy);\nreturn normalize(v);\n}\nvec4 screen2WS(vec3 coord) {\nvec3 ndc = vec3(\n2.0 * (coord.x - cc_viewPort.x) / cc_viewPort.z - 1.0,\n2.0 * (coord.y - cc_viewPort.y) / cc_viewPort.w - 1.0,\n2.0 * coord.z - 1.0);\nvec4 world = ((cc_matViewProjInv) * (vec4(ndc, 1.0)));\nworld      = world / world.w;\nreturn world;\n}\nin vec2 v_uv;\n#if CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT\nlayout(location = 0) inout vec4 gbuffer_albedoMap;\nlayout(location = 1) inout vec4 gbuffer_normalMap;\nlayout(location = 2) inout vec4 gbuffer_emissiveMap;\nuniform sampler2D depth_stencil;\n#else\nuniform sampler2D gbuffer_albedoMap;\nuniform sampler2D gbuffer_normalMap;\nuniform sampler2D gbuffer_emissiveMap;\nuniform sampler2D depth_stencil;\n#endif\n#if !CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT || __VERSION__ >= 450\nlayout(location = 0) out vec4 fragColor;\n#endif\nvoid main () {\nStandardSurface s;\n#if CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT\nvec4 albedoMap = gbuffer_albedoMap;\nvec4 normalMap = gbuffer_normalMap;\nvec4 emissiveMap = gbuffer_emissiveMap;\nfloat depth = texture(depth_stencil, v_uv).x;\n#else\nvec4 albedoMap = texture(gbuffer_albedoMap,v_uv);\nvec4 normalMap = texture(gbuffer_normalMap,v_uv);\nvec4 emissiveMap = texture(gbuffer_emissiveMap,v_uv);\nfloat depth = texture(depth_stencil, v_uv).x;\n#endif\ns.albedo = albedoMap;\nvec3 position = screen2WS(vec3(gl_FragCoord.xy, depth)).xyz;\ns.position = position;\ns.roughness = normalMap.z;\ns.normal = oct_to_float32x3(normalMap.xy);\ns.specularIntensity = 0.5;\ns.metallic = normalMap.w;\ns.emissive = emissiveMap.xyz;\ns.occlusion = emissiveMap.w;\nfloat fogFactor;\nCC_TRANSFER_FOG_BASE(vec4(position, 1), fogFactor);\nvec4 shadowPos;\nshadowPos = cc_matLightViewProj * vec4(position, 1);\nvec4 color = CCStandardShadingBase(s, shadowPos) +\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\nCCClusterShadingAdditive(s, shadowPos);\n#else\nCCStandardShadingAdditive(s, shadowPos);\n#endif\nCC_APPLY_FOG_BASE(color, fogFactor);\ncolor = CCFragOutput(color);\n#if CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT\ngbuffer_emissiveMap = color;\n#else\nfragColor = color;\n#endif\n}"}],[{vert:"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_SKINNING\nin vec4 a_joints;\nin vec4 a_weights;\n#endif\n#if USE_INSTANCING\n#if CC_USE_BAKED_ANIMATION\nin highp vec4 a_jointAnimInfo;\n#endif\nin vec4 a_matWorld0;\nin vec4 a_matWorld1;\nin vec4 a_matWorld2;\n#if CC_USE_LIGHTMAP\nin vec4 a_lightingMapUVParam;\n#endif\n#if CC_RECEIVE_SHADOW\nin vec2 a_localShadowBias;\n#endif\n#elif USE_BATCHING\nin float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\nin float a_vertexId;\nint getVertexId() {\nreturn int(a_vertexId);\n}\n#endif\n#if CC_USE_MORPH\nlayout(std140) uniform CCMorph {\nvec4 cc_displacementWeights[15];\nvec4 cc_displacementTextureInfo;\n};\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\nivec2 texSize = textureSize(tex, 0);\nreturn texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture(tex, x)),\ndecode32(texture(tex, y)),\ndecode32(texture(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nuniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nuniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nuniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nnormal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\ntangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\n#if CC_USE_BAKED_ANIMATION\nlayout(std140) uniform CCSkinningTexture {\nhighp vec4 cc_jointTextureInfo;\n};\nlayout(std140) uniform CCSkinningAnimation {\nhighp vec4 cc_jointAnimInfo;\n};\nuniform highp sampler2D cc_jointTexture;\nvoid CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n{\n#if USE_INSTANCING\nhighp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n#else\nhighp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n#endif\ninvSize = cc_jointTextureInfo.w;\nhighp float tempY = floor(temp * invSize);\nx = floor(temp - tempY * cc_jointTextureInfo.x);\ny = (tempY + 0.5) * invSize;\n}\n#else\nlayout(std140) uniform CCSkinning {\nhighp vec4 cc_joints[30 * 3];\n};\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(3.0, i, x, y, invSize);\nvec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(12.0, i, x, y, invSize);\nvec4 v1 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\nmat4 m = skinMatrix();\nposition = m * position;\nnormal = (m * vec4(normal, 0.0)).xyz;\ntangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n}\n#endif\nvoid CCVertInput(inout vec4 In)\n{\nIn = vec4(a_position, 1.0);\n#if CC_USE_MORPH\napplyMorph(In);\n#endif\n#if CC_USE_SKINNING\nCCSkin(In);\n#endif\n}\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\n#if !USE_INSTANCING\n#if USE_BATCHING\nlayout(std140) uniform CCLocalBatched {\nhighp mat4 cc_matWorlds[10];\n};\n#else\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\nhighp vec4 cc_localShadowBias;\n};\n#endif\n#endif\nvoid CCGetWorldMatrix(out mat4 matWorld)\n{\n#if USE_INSTANCING\nmatWorld = mat4(\nvec4(a_matWorld0.xyz, 0.0),\nvec4(a_matWorld1.xyz, 0.0),\nvec4(a_matWorld2.xyz, 0.0),\nvec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n);\n#elif USE_BATCHING\nmatWorld = cc_matWorlds[int(a_dyn_batch_id)];\n#else\nmatWorld = cc_matWorld;\n#endif\n}\nlayout(std140) uniform CCShadow {\nhighp mat4 cc_matLightPlaneProj;\nhighp mat4 cc_matLightView;\nhighp mat4 cc_matLightViewProj;\nhighp vec4 cc_shadowInvProjDepthInfo;\nhighp vec4 cc_shadowProjDepthInfo;\nhighp vec4 cc_shadowProjInfo;\nmediump vec4 cc_shadowNFLSInfo;\nmediump vec4 cc_shadowWHPBInfo;\nmediump vec4 cc_shadowLPNNInfo;\nlowp vec4 cc_shadowColor;\nmediump vec4 cc_planarNDInfo;\n};\nout float v_dist;\nvec4 vert () {\nvec4 position;\nCCVertInput(position);\nmat4 matWorld;\nCCGetWorldMatrix(matWorld);\nvec3 P = (matWorld * position).xyz;\nvec3 L = cc_mainLitDir.xyz;\nvec3 N = cc_planarNDInfo.xyz;\nfloat d = cc_planarNDInfo.w + 0.001;\nfloat dist = (-d - dot(P, N)) / (dot(L, N) + 0.0001);\nvec3 shadowPos = P + L * dist;\nvec3 view = normalize(cc_cameraPos.xyz - shadowPos);\nfloat viewLength = length(cc_cameraPos.xyz - shadowPos);\nshadowPos += view * min(1.0, 0.005 * viewLength);\nposition = cc_matProj * cc_matView * vec4(shadowPos, 1.0);\nv_dist = dist;\nreturn position;\n}\nvoid main() { gl_Position = vert(); }",frag:"\nprecision mediump float;\nlayout(std140) uniform CCShadow {\nhighp mat4 cc_matLightPlaneProj;\nhighp mat4 cc_matLightView;\nhighp mat4 cc_matLightViewProj;\nhighp vec4 cc_shadowInvProjDepthInfo;\nhighp vec4 cc_shadowProjDepthInfo;\nhighp vec4 cc_shadowProjInfo;\nmediump vec4 cc_shadowNFLSInfo;\nmediump vec4 cc_shadowWHPBInfo;\nmediump vec4 cc_shadowLPNNInfo;\nlowp vec4 cc_shadowColor;\nmediump vec4 cc_planarNDInfo;\n};\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\nreturn color;\n}\nin float v_dist;\nvec4 frag () {\nif(v_dist < 0.0)\ndiscard;\nreturn CCFragOutput(cc_shadowColor);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"}],[{vert:"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_SKINNING\nin vec4 a_joints;\nin vec4 a_weights;\n#endif\n#if USE_INSTANCING\n#if CC_USE_BAKED_ANIMATION\nin highp vec4 a_jointAnimInfo;\n#endif\nin vec4 a_matWorld0;\nin vec4 a_matWorld1;\nin vec4 a_matWorld2;\n#if CC_USE_LIGHTMAP\nin vec4 a_lightingMapUVParam;\n#endif\n#if CC_RECEIVE_SHADOW\nin vec2 a_localShadowBias;\n#endif\n#elif USE_BATCHING\nin float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\nin float a_vertexId;\nint getVertexId() {\nreturn int(a_vertexId);\n}\n#endif\n#if CC_USE_MORPH\nlayout(std140) uniform CCMorph {\nvec4 cc_displacementWeights[15];\nvec4 cc_displacementTextureInfo;\n};\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\nivec2 texSize = textureSize(tex, 0);\nreturn texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture(tex, x)),\ndecode32(texture(tex, y)),\ndecode32(texture(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nuniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nuniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nuniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nnormal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\ntangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\n#if CC_USE_BAKED_ANIMATION\nlayout(std140) uniform CCSkinningTexture {\nhighp vec4 cc_jointTextureInfo;\n};\nlayout(std140) uniform CCSkinningAnimation {\nhighp vec4 cc_jointAnimInfo;\n};\nuniform highp sampler2D cc_jointTexture;\nvoid CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n{\n#if USE_INSTANCING\nhighp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n#else\nhighp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n#endif\ninvSize = cc_jointTextureInfo.w;\nhighp float tempY = floor(temp * invSize);\nx = floor(temp - tempY * cc_jointTextureInfo.x);\ny = (tempY + 0.5) * invSize;\n}\n#else\nlayout(std140) uniform CCSkinning {\nhighp vec4 cc_joints[30 * 3];\n};\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(3.0, i, x, y, invSize);\nvec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\nhighp float x, y, invSize;\nCCGetJointTextureCoords(12.0, i, x, y, invSize);\nvec4 v1 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\nmat4 m = skinMatrix();\nposition = m * position;\nnormal = (m * vec4(normal, 0.0)).xyz;\ntangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n}\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\nIn.position = vec4(a_position, 1.0);\nIn.normal = a_normal;\nIn.tangent = a_tangent;\n#if CC_USE_MORPH\napplyMorph(In.position, In.normal, In.tangent);\n#endif\n#if CC_USE_SKINNING\nCCSkin(In.position, In.normal, In.tangent);\n#endif\n}\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nout vec2 v_uv;\nvoid main () {\nStandardVertInput In;\nCCVertInput(In);\nIn.position.xy = cc_cameraPos.w == 0.0 ? vec2(In.position.xy.x, -In.position.xy.y) : In.position.xy;\ngl_Position = In.position;\ngl_Position.y = gl_Position.y;\nv_uv = a_texCoord;\n}",frag:"\nprecision highp float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\n#if ANTIALIAS_TYPE == 1\nvec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 resolution,\nvec2 v_rgbNW, vec2 v_rgbNE,\nvec2 v_rgbSW, vec2 v_rgbSE,\nvec2 v_rgbM) {\nvec4 color;\nmediump vec2 inverseVP = vec2(1.0 / resolution.x, 1.0 / resolution.y);\nvec3 rgbNW = texture(tex, v_rgbNW).xyz;\nvec3 rgbNE = texture(tex, v_rgbNE).xyz;\nvec3 rgbSW = texture(tex, v_rgbSW).xyz;\nvec3 rgbSE = texture(tex, v_rgbSE).xyz;\nvec4 texColor = texture(tex, v_rgbM);\nvec3 rgbM  = texColor.xyz;\nvec3 luma = vec3(0.299, 0.587, 0.114);\nfloat lumaNW = dot(rgbNW, luma);\nfloat lumaNE = dot(rgbNE, luma);\nfloat lumaSW = dot(rgbSW, luma);\nfloat lumaSE = dot(rgbSE, luma);\nfloat lumaM  = dot(rgbM,  luma);\nfloat lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\nfloat lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\nmediump vec2 dir;\ndir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\ndir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\nfloat dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n(0.25 * (1.0 / 8.0)), (1.0/ 128.0));\nfloat rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\ndir = min(vec2(8.0, 8.0),\nmax(vec2(-8.0, -8.0),\ndir * rcpDirMin)) * inverseVP;\nvec3 rgbA = 0.5 * (\ntexture(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +\ntexture(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\nvec3 rgbB = rgbA * 0.5 + 0.25 * (\ntexture(tex, fragCoord * inverseVP + dir * -0.5).xyz +\ntexture(tex, fragCoord * inverseVP + dir * 0.5).xyz);\nfloat lumaB = dot(rgbB, luma);\nif ((lumaB < lumaMin) || (lumaB > lumaMax))\ncolor = vec4(rgbA, texColor.a);\nelse\ncolor = vec4(rgbB, texColor.a);\nreturn color;\n}\n#endif\nin vec2 v_uv;\nuniform sampler2D outputResultMap;\nlayout(location = 0) out vec4 fragColor;\nvoid texcoords(vec2 fragCoord, vec2 resolution,\nout vec2 v_rgbNW, out vec2 v_rgbNE,\nout vec2 v_rgbSW, out vec2 v_rgbSE,\nout vec2 v_rgbM) {\nvec2 inverseVP = 1.0 / resolution.xy;\nv_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\nv_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\nv_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\nv_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\nv_rgbM = vec2(fragCoord * inverseVP);\n}\nvoid main () {\nmediump vec2 v_rgbNW;\nmediump vec2 v_rgbNE;\nmediump vec2 v_rgbSW;\nmediump vec2 v_rgbSE;\nmediump vec2 v_rgbM;\n#if ANTIALIAS_TYPE == 1\nvec2 resolution = cc_screenSize.xy;\nvec2 fragCoord = v_uv * resolution;\ntexcoords(fragCoord, resolution, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\nfragColor = fxaa(outputResultMap, fragCoord, resolution, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n#else\nfragColor = texture(outputResultMap, v_uv);\n#endif\n}"}],[{vert:"\nprecision highp float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_SKINNING\nin vec4 a_joints;\nin vec4 a_weights;\n#endif\n#if USE_INSTANCING\n#if CC_USE_BAKED_ANIMATION\nin highp vec4 a_jointAnimInfo;\n#endif\nin vec4 a_matWorld0;\nin vec4 a_matWorld1;\nin vec4 a_matWorld2;\n#if CC_USE_LIGHTMAP\nin vec4 a_lightingMapUVParam;\n#endif\n#if CC_RECEIVE_SHADOW\nin vec2 a_localShadowBias;\n#endif\n#elif USE_BATCHING\nin float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\nin float a_vertexId;\n#endif\nout mediump vec4 viewDir;\nvec4 vert () {\nviewDir = vec4(a_position, 1.0);\nmat4 matViewRotOnly = mat4(mat3(cc_matView));\nvec4 pos = matViewRotOnly * viewDir;\nif (cc_matProj[3].w > 0.0) {\nmat4 matProj = cc_matProj;\nmatProj[0].x = 5.2;\nmatProj[1].y = 2.6;\nmatProj[2].zw = vec2(-1.0);\nmatProj[3].zw = vec2(0.0);\npos = matProj * pos;\n} else {\npos = cc_matProj * pos;\n}\npos.z = 0.99999 * pos.w;\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",frag:"\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nuniform samplerCube cc_environment;\nvec3 unpackRGBE (vec4 rgbe) {\nreturn rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n}\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nvec3 ACESToneMap (vec3 color) {\ncolor = min(color, vec3(8.0));\nconst float A = 2.51;\nconst float B = 0.03;\nconst float C = 2.43;\nconst float D = 0.59;\nconst float E = 0.14;\nreturn (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n#if CC_USE_HDR\ncolor.rgb = ACESToneMap(color.rgb);\n#endif\ncolor.rgb = sqrt(color.rgb);\nreturn color;\n}\nin mediump vec4 viewDir;\nvec4 frag () {\n#if USE_RGBE_CUBEMAP\nvec3 c = unpackRGBE(texture(cc_environment, viewDir.xyz));\n#else\nvec3 c = SRGBToLinear(texture(cc_environment, viewDir.xyz).rgb);\n#endif\nreturn CCFragOutput(vec4(c * cc_ambientSky.w, 1.0));\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"}],[{vert:"\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nin vec3 a_position;\nin vec4 a_color;\nout vec2 v_uv;\nlayout(std140) uniform Constants {\nvec4 offset;\n};\nlayout(std140) uniform PerFrameInfo {\nvec4 digits[8 * 10 / 4];\n};\nfloat getComponent(vec4 v, float i) {\nif (i < 1.0) { return v.x; }\nelse if (i < 2.0) { return v.y; }\nelse if (i < 3.0) { return v.z; }\nelse { return v.w; }\n}\nvec4 vert () {\nmat2 proj = mat2(cc_matProj[0].xy, cc_matProj[1].xy);\nproj /= abs(proj[1].x + proj[1].y);\nvec2 position = proj * a_position.xy + offset.xy;\nv_uv = a_color.xy;\nif (a_color.z >= 0.0) {\nfloat n = getComponent(digits[int(a_color.z)], a_color.w);\nv_uv += vec2(offset.z * n, 0.0);\n}\nreturn vec4(position, 0.0, 1.0);\n}\nvoid main() { gl_Position = vert(); }",frag:"\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\nmediump vec4 cc_nearFar;\nmediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\nreturn color;\n}\nin vec2 v_uv;\nuniform sampler2D mainTexture;\nvec4 frag () {\nreturn CCFragOutput(texture(mainTexture, v_uv));\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"}],[{vert:"\nprecision mediump float;\nin vec2 a_position;\nin vec2 a_texCoord;\nout vec2 v_uv;\nlayout(std140) uniform Constant {\nvec4 u_buffer0;\nvec4 u_buffer1;\nmat4 u_projection;\n};\nvec4 vert () {\nvec2 worldPos = a_position * u_buffer1.xy + u_buffer1.zw;\nvec2 clipSpace = worldPos / u_buffer0.xy * 2.0 - 1.0;\nvec4 screenPos = u_projection * vec4(clipSpace, 0.0, 1.0);\nv_uv = a_texCoord;\nreturn screenPos;\n}\nvoid main() { gl_Position = vert(); }",frag:"\nprecision mediump float;\nin vec2 v_uv;\nlayout(std140) uniform Factor {\nfloat u_percent;\n};\nuniform sampler2D mainTexture;\nvec4 frag () {\nvec4 color = texture(mainTexture, v_uv);\nfloat percent = clamp(u_percent, 0.0, 1.0);\ncolor.xyz *= percent;\nreturn color;\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"}]]},Am=function(){function e(){this._device=null,this._resources={}}var t=e.prototype;return t.initBuiltinRes=function(e){var t=this;this._device=e;for(var n=this._resources,i=new Uint8Array(16),o=new Uint8Array(16),a=new Uint8Array(16),r=new Uint8Array(16),c=new Uint8Array(16),l=0,f=0;f<4;f++)i[l]=0,i[l+1]=0,i[l+2]=0,i[l+3]=255,o[l]=0,o[l+1]=0,o[l+2]=0,o[l+3]=0,a[l]=119,a[l+1]=119,a[l+2]=119,a[l+3]=255,r[l]=255,r[l+1]=255,r[l+2]=255,r[l+3]=255,c[l]=127,c[l+1]=127,c[l+2]=255,c[l+3]=255,l+=4;var _=new Uint8Array(1024);l=0;for(var u=0;u<256;u++)_[l]=221,_[l+1]=221,_[l+2]=221,_[l+3]=255,l+=4;l=0;for(var m=0;m<8;m++){for(var d=0;d<8;d++)_[l]=85,_[l+1]=85,_[l+2]=85,_[l+3]=255,l+=4;l+=32}l+=32;for(var p=0;p<8;p++){for(var h=0;h<8;h++)_[l]=85,_[l+1]=85,_[l+2]=85,_[l+3]=255,l+=4;l+=32}var v={width:2,height:2,_data:i,_compressed:!1,format:Ku.PixelFormat.RGBA8888},g={width:2,height:2,_data:o,_compressed:!1,format:Ku.PixelFormat.RGBA8888},x={width:2,height:2,_data:a,_compressed:!1,format:Ku.PixelFormat.RGBA8888},y={width:2,height:2,_data:r,_compressed:!1,format:Ku.PixelFormat.RGBA8888},C={width:2,height:2,_data:c,_compressed:!1,format:Ku.PixelFormat.RGBA8888},S={width:16,height:16,_data:_,_compressed:!1,format:Ku.PixelFormat.RGBA8888},E=new Pu(v),P=new Ku;P._uuid="black-texture",P.image=E,n[P._uuid]=P;var I=new Pu(g),T=new Ku;T._uuid="empty-texture",T.image=I,n[T._uuid]=T;var b=new Ju;b._uuid="black-cube-texture",b.setMipFilter(Ju.Filter.NEAREST),b.image={front:new Pu(v),back:new Pu(v),left:new Pu(v),right:new Pu(v),top:new Pu(v),bottom:new Pu(v)},n[b._uuid]=b;var A=new Pu(x),w=new Ku;w._uuid="grey-texture",w.image=A,n[w._uuid]=w;var N=new Pu(y),D=new Ku;D._uuid="white-texture",D.image=N,n[D._uuid]=D;var R=new Ju;R._uuid="white-cube-texture",R.setMipFilter(Ju.Filter.NEAREST),R.image={front:new Pu(y),back:new Pu(y),left:new Pu(y),right:new Pu(y),top:new Pu(y),bottom:new Pu(y)},n[R._uuid]=R;var M=new Pu(C),O=new Ku;O._uuid="normal-texture",O.image=M,n[O._uuid]=O;var L=new Pu(S),z=new Ku;z._uuid="default-texture",z.image=L,n[z._uuid]=z;var F=new Ju;if(F.setMipFilter(Ju.Filter.NEAREST),F._uuid="default-cube-texture",F.image={front:new Pu(S),back:new Pu(S),left:new Pu(S),right:new Pu(S),top:new Pu(S),bottom:new Pu(S)},n[F._uuid]=F,s.SpriteFrame){var U=new s.SpriteFrame,G=E,B=new Ku;B.image=G,U.texture=B,U._uuid="default-spriteframe",n[U._uuid]=U}var H=Sm(e);if(!H)return Promise.reject(Error("Failed to initialize builtin shaders: unknown device."));var V=bm[H];return V?Promise.resolve().then((function(){em.forEach((function(e,t){var n=Object.assign(new s.EffectAsset,e);n.shaders.forEach((function(e,n){var i=V[t][n];i&&(e[H]=i)})),n.hideInEditor=!0,n.onLoaded()})),t._initMaterials()})):Promise.reject(Error("Current device is requiring builtin shaders of version "+H+" but shaders of that version are not assembled in this build."))},t.get=function(e){return this._resources[e]},t._initMaterials=function(){var e=this._resources,t=[],n=new s.Material;n._uuid="standard-material",n.initialize({effectName:"standard"}),e[n._uuid]=n,t.push(n);var i=new s.Material;i._uuid="missing-effect-material",i.initialize({effectName:"unlit",defines:{USE_COLOR:!0}}),i.setProperty("mainColor",s.color("#ffff00")),e[i._uuid]=i,t.push(i);var o=new s.Material;o._uuid="missing-material",o.initialize({effectName:"unlit",defines:{USE_COLOR:!0}}),o.setProperty("mainColor",s.color("#ff00ff")),e[o._uuid]=o,t.push(o);var a=new s.Material;a._uuid="default-clear-stencil",a.initialize({defines:{USE_TEXTURE:!1},effectName:"clear-stencil"}),e[a._uuid]=a,t.push(a);var r=new s.Material;r._uuid="ui-base-material",r.initialize({defines:{USE_TEXTURE:!1},effectName:"sprite"}),e[r._uuid]=r,t.push(r);var c=new s.Material;c._uuid="ui-sprite-material",c.initialize({defines:{USE_TEXTURE:!0,CC_USE_EMBEDDED_ALPHA:!1,IS_GRAY:!1},effectName:"sprite"}),e[c._uuid]=c,t.push(c);var l=new s.Material;l._uuid="ui-alpha-test-material",l.initialize({defines:{USE_TEXTURE:!0,USE_ALPHA_TEST:!0,CC_USE_EMBEDDED_ALPHA:!1,IS_GRAY:!1},effectName:"sprite"}),e[l._uuid]=l,t.push(l);var f=new s.Material;f._uuid="ui-sprite-gray-material",f.initialize({defines:{USE_TEXTURE:!0,CC_USE_EMBEDDED_ALPHA:!1,IS_GRAY:!0},effectName:"sprite"}),e[f._uuid]=f,t.push(f);var _=new s.Material;_._uuid="ui-sprite-alpha-sep-material",_.initialize({defines:{USE_TEXTURE:!0,CC_USE_EMBEDDED_ALPHA:!0,IS_GRAY:!1},effectName:"sprite"}),e[_._uuid]=_,t.push(_);var u=new s.Material;u._uuid="ui-sprite-gray-alpha-sep-material",u.initialize({defines:{USE_TEXTURE:!0,CC_USE_EMBEDDED_ALPHA:!0,IS_GRAY:!0},effectName:"sprite"}),e[u._uuid]=u,t.push(u);var m=new s.Material;m._uuid="ui-graphics-material",m.initialize({effectName:"graphics"}),e[m._uuid]=m,t.push(m);var d=new s.Material;d._uuid="default-particle-material",d.initialize({effectName:"particle"}),e[d._uuid]=d,t.push(d);var p=new s.Material;p._uuid="default-particle-gpu-material",p.initialize({effectName:"particle-gpu"}),e[p._uuid]=p,t.push(p);var h=new s.Material;h._uuid="default-trail-material",h.initialize({effectName:"particle-trail"}),e[h._uuid]=h,t.push(h);var v=new s.Material;v._uuid="default-billboard-material",v.initialize({effectName:"billboard"}),e[v._uuid]=v,t.push(v);var g=new s.Material;g._uuid="default-spine-material",g.initialize({defines:{USE_TEXTURE:!0,CC_USE_EMBEDDED_ALPHA:!1,IS_GRAY:!1},effectName:"spine"}),e[g._uuid]=g,t.push(g),s.game.on(s.Game.EVENT_GAME_INITED,(function(){for(var e=0;e<t.length;++e)for(var n=t[e],i=0;i<n.passes.length;++i)n.passes[i].tryCompile()}))},e}(),wm=e("bo",s.builtinResMgr=new Am),Nm=e("b4",(Pm=new Map,Im=0,function(e){return"number"==typeof e?e:(Pm.has(e)||(Pm.set(e,1<<Im),Im++),Pm.get(e))})),Dm=e("b2",function(){function e(e){this.instances=[],this.pass=void 0,this.hasPendingModels=!1,this.dynamicOffsets=[],this._device=void 0,this._device=e.device,this.pass=e}var t=e.prototype;return t.destroy=function(){for(var e=0;e<this.instances.length;++e){var t=this.instances[e];t.vb.destroy(),t.ia.destroy()}this.instances.length=0},t.merge=function(e,t,n,i){void 0===i&&(i=null);var o=t.buffer.length;if(o){var a=e.inputAssembler,r=e.descriptorSet.getTexture(H_),c=i;c||(c=e.shaders[n]);for(var s=e.descriptorSet,l=0;l<this.instances.length;++l){var f=this.instances[l];if(!(f.ia.indexBuffer!==a.indexBuffer||f.count>=1024)&&f.lightingMap===r&&f.stride===o){if(f.count>=f.capacity){f.capacity<<=1;var _=f.stride*f.capacity,u=f.data;f.data=new Uint8Array(_),f.data.set(u),f.vb.resize(_)}return f.shader!==c&&(f.shader=c),f.descriptorSet!==s&&(f.descriptorSet=s),f.data.set(t.buffer,f.stride*f.count++),void(this.hasPendingModels=!0)}}for(var m=this._device.createBuffer(new ht(vt.VERTEX|vt.TRANSFER_DST,gt.HOST|gt.DEVICE,32*o,o)),d=new Uint8Array(32*o),p=a.vertexBuffers.slice(),h=a.attributes.slice(),v=a.indexBuffer,g=0;g<t.attributes.length;g++){var x=t.attributes[g],y=new _t(x.name,x.format,x.isNormalized,p.length,!0);h.push(y)}d.set(t.buffer),p.push(m);var C=new xt(h,p,v),S=this._device.createInputAssembler(C);this.instances.push({count:1,capacity:32,vb:m,data:d,ia:S,stride:o,shader:c,descriptorSet:s,lightingMap:r}),this.hasPendingModels=!0}},t.uploadBuffers=function(e){for(var t=0;t<this.instances.length;++t){var n=this.instances[t];n.count&&(n.ia.instanceCount=n.count,e.updateBuffer(n.vb,n.data))}},t.clear=function(){for(var e=0;e<this.instances.length;++e)this.instances[e].count=0;this.hasPendingModels=!1},e}()),Rm=function(){function e(e){this.batches=[],this.dynamicOffsets=[],this._device=void 0,this._device=e.device}var t=e.prototype;return t.destroy=function(){for(var e=0;e<this.batches.length;++e){for(var t=this.batches[e],n=0;n<t.vbs.length;++n)t.vbs[n].destroy();t.vbIdx.destroy(),t.ia.destroy(),t.ubo.destroy()}this.batches.length=0},t.merge=function(e,t,n){var i=e.subMesh.flatBuffers;if(0!==i.length){for(var o=0,a=0,r=i[0].count,c=e.passes[t],s=e.shaders[t],l=e.descriptorSet,f=!1,_=0;_<this.batches.length;++_){var u=this.batches[_];if(u.vbs.length===i.length&&u.mergeCount<y_.BATCHING_COUNT){f=!0;for(var m=0;m<u.vbs.length;++m)if(u.vbs[m].stride!==i[m].stride){f=!1;break}if(f){for(var d=0;d<u.vbs.length;++d){var p=i[d],h=u.vbs[d],v=u.vbDatas[d];(o=(r+u.vbCount)*p.stride)>h.size&&(h.resize(o),u.vbDatas[d]=new Uint8Array(o),u.vbDatas[d].set(v)),u.vbDatas[d].set(p.buffer,u.vbCount*p.stride)}var g=u.vbIdxData;(a=4*(r+u.vbCount))>u.vbIdx.size&&(u.vbIdx.resize(a),u.vbIdxData=new Float32Array(a/Float32Array.BYTES_PER_ELEMENT),u.vbIdxData.set(g),g=u.vbIdxData);var x=u.vbCount,y=x+r,C=u.mergeCount;if(g[x]!==C||g[y-1]!==C)for(var S=x;S<y;S++)g[S]=C+.1;return jn.toArray(u.uboData,n.transform.worldMatrix,y_.MAT_WORLDS_OFFSET+16*u.mergeCount),u.mergeCount||(l.bindBuffer(y_.BINDING,u.ubo),l.update(),u.pass=c,u.shader=s,u.descriptorSet=l),++u.mergeCount,u.vbCount+=r,void(u.ia.vertexCount+=r)}}}for(var E=[],P=[],I=[],T=0;T<i.length;++T){var b=i[T],A=this._device.createBuffer(new ht(vt.VERTEX|vt.TRANSFER_DST,gt.HOST|gt.DEVICE,b.count*b.stride,b.stride));A.update(b.buffer.buffer),E.push(A),P.push(new Uint8Array(A.size)),I.push(A)}var w=this._device.createBuffer(new ht(vt.VERTEX|vt.TRANSFER_DST,gt.HOST|gt.DEVICE,4*r,4)),N=new Float32Array(r);N.fill(0),w.update(N),I.push(w);for(var D=e.inputAssembler.attributes,R=new Array(D.length+1),M=0;M<D.length;++M)R[M]=D[M];R[D.length]=new _t("a_dyn_batch_id",ke.R32F,!1,i.length);var O=new xt(R,I),L=this._device.createInputAssembler(O),z=this._device.createBuffer(new ht(vt.UNIFORM|vt.TRANSFER_DST,gt.HOST|gt.DEVICE,y_.SIZE,y_.SIZE));l.bindBuffer(y_.BINDING,z),l.update();var F=new Float32Array(y_.COUNT);jn.toArray(F,n.transform.worldMatrix,y_.MAT_WORLDS_OFFSET),this.batches.push({mergeCount:1,vbs:E,vbDatas:P,vbIdx:w,vbIdxData:N,vbCount:r,ia:L,ubo:z,uboData:F,pass:c,shader:s,descriptorSet:l})}},t.clear=function(){for(var e=0;e<this.batches.length;++e){var t=this.batches[e];t.vbCount=0,t.mergeCount=0,t.ia.vertexCount=0}},e}(),Mm=new ht(vt.UNIFORM|vt.TRANSFER_DST,gt.DEVICE),Om=new yt(null),Lm=new Ct(null);!function(e){e[e.NONE=0]="NONE",e[e.INSTANCING=1]="INSTANCING",e[e.VB_MERGING=2]="VB_MERGING"}(Tm||(Tm=e("B",{})));var zm=e("x",function(){function e(e){this._rootBuffer=null,this._buffers=[],this._descriptorSet=null,this._pipelineLayout=null,this._passIndex=0,this._propertyIndex=0,this._programName="",this._dynamics={},this._propertyHandleMap={},this._rootBlock=null,this._blocksInt=[],this._blocks=[],this._shaderInfo=null,this._defines={},this._properties={},this._shader=null,this._bs=new w,this._dss=new D,this._rs=new A,this._priority=Hf.DEFAULT,this._stage=Bf.DEFAULT,this._phase=Nm("default"),this._primitive=z.TRIANGLE_LIST,this._batchingScheme=Tm.NONE,this._dynamicStates=St.NONE,this._instancedBuffers={},this._batchedBuffers={},this._hash=0,this._root=void 0,this._device=void 0,this._passHandle=Jo,this._rootBufferDirty=!1,this._root=e,this._device=e.device}e.fillPipelineInfo=function(e,t){void 0!==t.priority&&e._setPriority(t.priority),void 0!==t.primitive&&e._setPrimitive(t.primitive),void 0!==t.stage&&e._setStage(t.stage),void 0!==t.dynamicStates&&e._setDynamicState(t.dynamicStates),void 0!==t.phase&&e._setPhase(Nm(t.phase));var n=e._bs;if(t.blendState){var i=t.blendState,o=i.targets;o&&o.forEach((function(e,t){n.setTarget(t,e)})),void 0!==i.isA2C&&(n.isA2C=i.isA2C),void 0!==i.isIndepend&&(n.isIndepend=i.isIndepend),void 0!==i.blendColor&&(n.blendColor=i.blendColor)}e._rs.assign(t.rasterizerState),e._dss.assign(t.depthStencilState)},e.getPassHash=function(e){var t,n=Em.getKey(e.program,e.defines)+","+e._primitive+","+e._dynamicStates;return n+=function(e){for(var t,n=",bs,"+e.isA2C,i=X(e.targets);!(t=i()).done;){var o=t.value;n+=",bt,"+o.blend+","+o.blendEq+","+o.blendAlphaEq+","+o.blendColorMask,n+=","+o.blendSrc+","+o.blendDst+","+o.blendSrcAlpha+","+o.blendDstAlpha}return n}(e._bs),n+=function(e){var t=",dss,"+e.depthTest+","+e.depthWrite+","+e.depthFunc;return t+=","+e.stencilTestFront+","+e.stencilFuncFront+","+e.stencilRefFront+","+e.stencilReadMaskFront,t+=","+e.stencilFailOpFront+","+e.stencilZFailOpFront+","+e.stencilPassOpFront+","+e.stencilWriteMaskFront,(t+=","+e.stencilTestBack+","+e.stencilFuncBack+","+e.stencilRefBack+","+e.stencilReadMaskBack)+","+e.stencilFailOpBack+","+e.stencilZFailOpBack+","+e.stencilPassOpBack+","+e.stencilWriteMaskBack}(e._dss),n+=",rs,"+(t=e._rs).cullMode+","+t.depthBias+","+t.isFrontFaceCCW,Xe(n,666)};var t=e.prototype;return t.initialize=function(e){this._doInit(e),this.resetUBOs(),this.resetTextures(),this.tryCompile()},t.getHandle=function(e,t,n){void 0===t&&(t=0),void 0===n&&(n=Be.UNKNOWN);var i=this._propertyHandleMap[e];return i?(n?i=lm(i,n):t&&(i=lm(i,am(i)-t)),i+t):0},t.getBinding=function(t){var n=this.getHandle(t);return n?e.getBindingFromHandle(n):-1},t.setUniform=function(t,n){var i=e.getBindingFromHandle(t),o=e.getTypeFromHandle(t),a=e.getOffsetFromHandle(t),r=this._getBlockView(o,i);_m[o](r,n,a),this._setRootBufferDirty(!0)},t.getUniform=function(t,n){var i=e.getBindingFromHandle(t),o=e.getTypeFromHandle(t),a=e.getOffsetFromHandle(t),r=this._getBlockView(o,i);return fm[o](r,n,a)},t.setUniformArray=function(t,n){for(var i=e.getBindingFromHandle(t),o=e.getTypeFromHandle(t),a=rt(o)>>2,r=this._getBlockView(o,i),c=e.getOffsetFromHandle(t),s=0;s<n.length;s++,c+=a)null!==n[s]&&_m[o](r,n[s],c);this._setRootBufferDirty(!0)},t.bindTexture=function(e,t,n){this._descriptorSet.bindTexture(e,t,n||0)},t.bindSampler=function(e,t,n){this._descriptorSet.bindSampler(e,t,n||0)},t.setDynamicState=function(e,t){var n=this._dynamics[e];n&&n.value===t||(n.value=t,n.dirty=!0)},t.overridePipelineStates=function(){console.warn("base pass cannot override states, please use pass instance instead.")},t._setRootBufferDirty=function(e){this._rootBufferDirty=e},t.update=function(){this._descriptorSet?(this._rootBuffer&&this._rootBufferDirty&&(this._rootBuffer.update(this._rootBlock),this._setRootBufferDirty(!1)),this._descriptorSet.update()):Te(12006)},t.getInstancedBuffer=function(e){return void 0===e&&(e=0),this._instancedBuffers[e]||(this._instancedBuffers[e]=new Dm(this))},t.getBatchedBuffer=function(e){return void 0===e&&(e=0),this._batchedBuffers[e]||(this._batchedBuffers[e]=new Rm(this))},t._initNative=function(){},t._destroy=function(){},t.destroy=function(){for(var e=0;e<this._shaderInfo.blocks.length;e++){var t=this._shaderInfo.blocks[e];this._buffers[t.binding].destroy()}for(var n in this._buffers=[],this._rootBuffer&&(this._rootBuffer.destroy(),this._rootBuffer=null),this._instancedBuffers)this._instancedBuffers[n].destroy();for(var i in this._batchedBuffers)this._batchedBuffers[i].destroy();this._descriptorSet.destroy(),this._rs.destroy(),this._dss.destroy(),this._bs.destroy(),this._destroy()},t.resetUniform=function(t){var n=this.getHandle(t);if(n){for(var i=e.getTypeFromHandle(n),o=e.getBindingFromHandle(n),a=e.getOffsetFromHandle(n),r=e.getCountFromHandle(n),c=this._getBlockView(i,o),s=this._properties[t],l=s&&s.value||mm(i),f=(rt(i)>>2)*r,_=0;_+l.length<=f;_+=l.length)c.set(l,a+_);this._setRootBufferDirty(!0)}},t.resetTexture=function(t,n){var i=this.getHandle(t);if(i){var o=e.getTypeFromHandle(i),a=e.getBindingFromHandle(i),r=this._properties[t],c=r&&r.value,s=c?c+"-texture":mm(o),l=wm.get(s),f=l&&l.getGFXTexture(),_=r&&void 0!==r.samplerHash?p.unpackFromHash(r.samplerHash):l&&l.getSamplerInfo(),u=this._device.getSampler(_);this._descriptorSet.bindSampler(a,u,n),this._descriptorSet.bindTexture(a,f,n)}},t.resetUBOs=function(){for(var e=0;e<this._shaderInfo.blocks.length;e++)for(var t=this._shaderInfo.blocks[e],n=0,i=0;i<t.members.length;i++){for(var o=t.members[i],a=this._getBlockView(o.type,t.binding),r=this._properties[o.name],c=r&&r.value||mm(o.type),s=(rt(o.type)>>2)*o.count,l=0;l+c.length<=s;l+=c.length)a.set(c,n+l);n+=s}this._setRootBufferDirty(!0)},t.resetTextures=function(){for(var e=0;e<this._shaderInfo.samplerTextures.length;e++)for(var t=this._shaderInfo.samplerTextures[e],n=0;n<t.count;n++)this.resetTexture(t.name,n)},t.tryCompile=function(){var t=this._root.pipeline;if(!t)return!1;this._syncBatchingScheme();var n=Em.getGFXShader(this._device,this._programName,this._defines,t);return n?(this._shader=n,this._setPipelineLayout(Em.getTemplateInfo(this._programName).pipelineLayout),this._setHash(e.getPassHash(this)),!0):(console.warn("create shader "+this._programName+" failed"),!1)},t.getShaderVariant=function(e){if(void 0===e&&(e=null),!this._shader&&!this.tryCompile())return console.warn("pass resources incomplete"),null;if(!e)return this._shader;for(var t=this._root.pipeline,n=0;n<e.length;n++){var i=e[n];this._defines[i.name]=i.value}for(var o=Em.getGFXShader(this._device,this._programName,this._defines,t),a=0;a<e.length;a++){var r=e[a];delete this._defines[r.name]}return o},t.beginChangeStatesSilently=function(){},t.endChangeStatesSilently=function(){},t._setPriority=function(e){this._priority=e},t._setStage=function(e){this._stage=e},t._setPhase=function(e){this._phase=e},t._setPrimitive=function(e){this._primitive=e},t._setState=function(e,t,n,i){this._bs=e,this._dss=t,this._rs=n,this._descriptorSet=i},t._doInit=function(t,n){void 0===n&&(n=!1),this._initNative(),this._setPriority(Hf.DEFAULT),this._setStage(Bf.DEFAULT),this._setPhase(Nm("default")),this._setPrimitive(z.TRIANGLE_LIST),this._passIndex=t.passIndex,this._propertyIndex=void 0!==t.propertyIndex?t.propertyIndex:t.passIndex,this._programName=t.program,this._defines=n?Re({},t.defines):t.defines,this._shaderInfo=Em.getTemplate(t.program),this._properties=t.properties||this._properties;var i=this._device;e.fillPipelineInfo(this,t),t.stateOverrides&&e.fillPipelineInfo(this,t.stateOverrides),Lm.layout=Em.getDescriptorSetLayout(this._device,t.program),this._descriptorSet=this._device.createDescriptorSet(Lm),this._setState(this._bs,this._dss,this._rs,this._descriptorSet);for(var o=this._shaderInfo.blocks,a=Em.getTemplateInfo(t.program),r=a.blockSizes,c=a.handleMap,s=i.capabilities.uboOffsetAlignment,l=[],f=0,_=0,u=0;u<o.length;u++){var m=r[u];l.push(_),_+=Math.ceil(m/s)*s,f=m}var d=l[l.length-1]+f;d&&(Mm.size=16*Math.ceil(d/16),this._rootBuffer=i.createBuffer(Mm),this._rootBlock=new ArrayBuffer(d));for(var p=0,h=0;p<o.length;p++){var v=o[p].binding,g=r[p];Om.buffer=this._rootBuffer,Om.offset=l[h++],Om.range=16*Math.ceil(g/16);var x=this._buffers[v]=i.createBuffer(Om);this._blocks[v]=new Float32Array(this._rootBlock,Om.offset,g/Float32Array.BYTES_PER_ELEMENT),this._blocksInt[v]=new Int32Array(this._blocks[v].buffer,this._blocks[v].byteOffset,this._blocks[v].length),this._descriptorSet.bindBuffer(v,x)}var y=this._propertyHandleMap=c,C={};for(var S in this._properties){var E=this._properties[S];E.handleInfo&&(C[S]=this.getHandle.apply(this,E.handleInfo))}Object.assign(y,C)},t._syncBatchingScheme=function(){this._defines.USE_INSTANCING?this._device.hasFeature(M.INSTANCED_ARRAYS)?this._setBatchingScheme(Tm.INSTANCING):(this._defines.USE_INSTANCING=!1,this._setBatchingScheme(Tm.NONE)):this._defines.USE_BATCHING?this._setBatchingScheme(Tm.VB_MERGING):this._setBatchingScheme(Tm.NONE)},t._setBatchingScheme=function(e){this._batchingScheme=e},t._setDynamicState=function(e){this._dynamicStates=e},t._setHash=function(e){this._hash=e},t._getBlockView=function(e,t){return e<Be.FLOAT?this._blocksInt[t]:this._blocks[t]},t._setPipelineLayout=function(e){this._pipelineLayout=e},t._initPassFromTarget=function(e,t,n,i){this._initNative(),this._setPriority(e.priority),this._setStage(e.stage),this._setPhase(e.phase),this._setBatchingScheme(e.batchingScheme),this._setPrimitive(e.primitive),this._setDynamicState(e.dynamicStates),this._setState(n,t,e.rasterizerState,e.descriptorSet),this._passIndex=e.passIndex,this._propertyIndex=e.propertyIndex,this._programName=e.program,this._defines=e.defines,this._shaderInfo=e._shaderInfo,this._properties=e._properties,this._blocks=e._blocks,this._blocksInt=e._blocksInt,this._dynamics=e._dynamics,this._shader=e._shader,this._setPipelineLayout(Em.getTemplateInfo(this._programName).pipelineLayout),this._setHash(e._hash^i)},r(e,[{key:"native",get:function(){return this._nativeObj}},{key:"root",get:function(){return this._root}},{key:"device",get:function(){return this._device}},{key:"shaderInfo",get:function(){return this._shaderInfo}},{key:"localSetLayout",get:function(){return Em.getDescriptorSetLayout(this._device,this._programName,!0)}},{key:"program",get:function(){return this._programName}},{key:"properties",get:function(){return this._properties}},{key:"defines",get:function(){return this._defines}},{key:"passIndex",get:function(){return this._passIndex}},{key:"propertyIndex",get:function(){return this._propertyIndex}},{key:"dynamics",get:function(){return this._dynamics}},{key:"blocks",get:function(){return this._blocks}},{key:"blocksInt",get:function(){return this._blocksInt}},{key:"rootBufferDirty",get:function(){return this._rootBufferDirty}},{key:"priority",get:function(){return this._priority}},{key:"primitive",get:function(){return this._primitive}},{key:"stage",get:function(){return this._stage}},{key:"phase",get:function(){return this._phase}},{key:"rasterizerState",get:function(){return this._rs}},{key:"depthStencilState",get:function(){return this._dss}},{key:"blendState",get:function(){return this._bs}},{key:"dynamicStates",get:function(){return this._dynamicStates}},{key:"batchingScheme",get:function(){return this._batchingScheme}},{key:"descriptorSet",get:function(){return this._descriptorSet}},{key:"hash",get:function(){return this._hash}},{key:"pipelineLayout",get:function(){return this._pipelineLayout}}]),e}());zm.getTypeFromHandle=am,zm.getBindingFromHandle=rm,zm.getCountFromHandle=cm,zm.getOffsetFromHandle=sm;var Fm,Um,Gm,Bm,Hm,Vm,km,jm,qm=e("A",function(){function e(){this._groundAlbedoHDR=new Zn(.2,.2,.2,1),this._skyColorHDR=new Zn(.2,.5,.8,1),this._skyIllumHDR=0,this._groundAlbedoLDR=new Zn(.2,.2,.2,1),this._skyColorLDR=new Zn(.2,.5,.8,1),this._skyIllumLDR=0,this._enabled=!1}var t=e.prototype;return t.initialize=function(e){this._skyColorHDR=e.skyColorHDR,this._groundAlbedoHDR.set(e.groundAlbedoHDR),this._skyIllumHDR=e.skyIllumHDR,this._skyColorLDR=e.skyColorLDR,this._groundAlbedoLDR.set(e.groundAlbedoLDR),this._skyIllumLDR=e.skyIllumLDR},t._destroy=function(){},t.destroy=function(){this._destroy()},r(e,[{key:"enabled",get:function(){return this._enabled},set:function(e){this._enabled=e}},{key:"skyColor",get:function(){return s.director.root.pipeline.pipelineSceneData.isHDR?this._skyColorHDR:this._skyColorLDR},set:function(e){s.director.root.pipeline.pipelineSceneData.isHDR?this._skyColorHDR.set(e):this._skyColorLDR.set(e)}},{key:"skyIllum",get:function(){return s.director.root.pipeline.pipelineSceneData.isHDR?this._skyIllumHDR:this._skyIllumLDR},set:function(e){s.director.root.pipeline.pipelineSceneData.isHDR?this._skyIllumHDR=e:this._skyIllumLDR=e}},{key:"groundAlbedo",get:function(){return s.director.root.pipeline.pipelineSceneData.isHDR?this._groundAlbedoHDR:this._groundAlbedoLDR},set:function(e){s.director.root.pipeline.pipelineSceneData.isHDR?this._groundAlbedoHDR.set(e):this._groundAlbedoLDR.set(e)}},{key:"native",get:function(){return this._nativeObj}}]),e}());qm.SUN_ILLUM=65e3,qm.SKY_ILLUM=2e4,s.Ambient=qm;var Wm=e("aV",Ga("cc.EffectAsset")((jm=km=function(e){function t(){for(var t,n=arguments.length,i=new Array(n),o=0;o<n;o++)i[o]=arguments[o];return t=e.call.apply(e,[this].concat(i))||this,te(t,"techniques",Gm,J(t)),te(t,"shaders",Bm,J(t)),te(t,"combinations",Hm,J(t)),te(t,"hideInEditor",Vm,J(t)),t}a(t,e),t.register=function(e){t._effects[e.name]=e},t.remove=function(e){if("string"!=typeof e)t._effects[e.name]&&t._effects[e.name].equals(e)&&delete t._effects[e.name];else{if(t._effects[e])return void delete t._effects[e];for(var n in t._effects)if(t._effects[n]._uuid===e)return void delete t._effects[n]}},t.get=function(e){if(t._effects[e])return t._effects[e];for(var n in t._effects)if(t._effects[n]._uuid===e)return t._effects[n];return null},t.getAll=function(){return t._effects};var n=t.prototype;return n.onLoaded=function(){Em.register(this),t.register(this),s.game.once(s.Game.EVENT_ENGINE_INITED,this._precompile,this)},n._precompile=function(){for(var e=this,t=s.director.root,n=function(n){var i=e.shaders[n],o=e.combinations[n];if(!o)return"continue";Object.keys(o).reduce((function(e,t){return e.reduce((function(e,n){for(var i=o[t],a=0;a<i.length;++a){var r=Re({},n);r[t]=i[a],e.push(r)}return e}),[])}),[{}]).forEach((function(e){return Em.getGFXShader(t.device,i.name,e,t.pipeline)}))},i=0;i<this.shaders.length;i++)n(i)},n.destroy=function(){return t.remove(this),e.prototype.destroy.call(this)},n.initDefault=function(n){e.prototype.initDefault.call(this,n);var i=t.get("unlit");this.name="unlit",this.shaders=i.shaders,this.combinations=i.combinations,this.techniques=i.techniques},n.validate=function(){return this.techniques.length>0&&this.shaders.length>0},t}(ec),km._effects={},Gm=ee((Um=jm).prototype,"techniques",[Ya,or],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return[]}}),Bm=ee(Um.prototype,"shaders",[Ya,or],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return[]}}),Hm=ee(Um.prototype,"combinations",[Ya,or],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return[]}}),Vm=ee(Um.prototype,"hideInEditor",[Ya,Ka],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return!1}}),Fm=Um))||Fm);s.EffectAsset=Wm;var Ym=e("b3",function(){function e(){}return e.getOrCreatePipelineState=function(e,t,n,i,o){var a=t.hash^i.hash^o.attributesHash^n.typedID,r=this._PSOHashMap.get(a);if(!r){var c=t.pipelineLayout,s=new Et(o.attributes),l=new R(n,c,i,s,t.rasterizerState,t.depthStencilState,t.blendState,t.primitive,t.dynamicStates);r=e.createPipelineState(l),this._PSOHashMap.set(a,r)}return r},e}());Ym._PSOHashMap=new Map;var Xm=new Pt,Km=new It;function Jm(e,t){e.x=t.x*t.x,e.y=t.y*t.y,e.z=t.z*t.z}var Qm,Zm,$m,ed,td,nd,id,od,ad,rd,cd=null,sd=new Zn,ld=e("aW",(Qm=Ga("cc.Material"),Zm=xr(Wm),Qm((rd=function(e){function t(){var t;return t=e.call(this)||this,te(t,"_effectAsset",td,J(t)),te(t,"_techIdx",nd,J(t)),te(t,"_defines",id,J(t)),te(t,"_states",od,J(t)),te(t,"_props",ad,J(t)),t._passes=[],t._hash=0,t}a(t,e),t.getHash=function(e){for(var t,n=0,i=X(e.passes);!(t=i()).done;)n^=t.value.hash;return n};var n=t.prototype;return n.initialize=function(e){this._passes.length?W(12005):(this._defines||(this._defines=[]),this._states||(this._states=[]),this._props||(this._props=[]),this._fillInfo(e),this._update())},n.reset=function(e){this.initialize(e)},n.destroy=function(){return this._doDestroy(),e.prototype.destroy.call(this)},n.recompileShaders=function(){console.warn("Shaders in material asset '"+this.name+"' cannot be modified at runtime, please instantiate the material first.")},n.overridePipelineStates=function(){console.warn("Pipeline states in material asset '"+this.name+"' cannot be modified at runtime, please instantiate the material first.")},n.onLoaded=function(){this._update()},n.resetUniforms=function(e){void 0===e&&(e=!0),this._props.length=this._passes.length;for(var t=0;t<this._props.length;t++)this._props[t]={};if(e)for(var n,i=X(this._passes);!(n=i()).done;){var o=n.value;o.resetUBOs(),o.resetTextures()}},n.setProperty=function(e,t,n){var i=!1;if(void 0===n)for(var o=this._passes,a=o.length,r=0;r<a;r++){var c=o[r];this._uploadProperty(c,e,t)&&(this._props[c.propertyIndex][e]=t,i=!0)}else{if(n>=this._passes.length)return void console.warn("illegal pass index: "+n+".");var s=this._passes[n];this._uploadProperty(s,e,t)&&(this._props[s.propertyIndex][e]=t,i=!0)}i||console.warn("illegal property name: "+e+".")},n.getProperty=function(e,t){if(void 0===t)for(var n=this._props,i=n.length,o=0;o<i;o++){var a=n[o];if(e in a)return a[e]}else{if(t>=this._props.length)return console.warn("illegal pass index: "+t+"."),null;var r=this._props[this._passes[t].propertyIndex];if(e in r)return r[e]}return null},n.copy=function(e,t){this._techIdx=e._techIdx,this._props.length=e._props.length;for(var n=0;n<e._props.length;n++)this._props[n]=Re({},e._props[n]);this._defines.length=e._defines.length;for(var i=0;i<e._defines.length;i++)this._defines[i]=Re({},e._defines[i]);this._states.length=e._states.length;for(var o=0;o<e._states.length;o++)this._states[o]=Re({},e._states[o]);this._effectAsset=e._effectAsset,t&&this._fillInfo(t),this._update()},n._fillInfo=function(e){void 0!==e.technique&&(this._techIdx=e.technique),e.effectAsset?this._effectAsset=e.effectAsset:e.effectName&&(this._effectAsset=Wm.get(e.effectName)),e.defines&&this._prepareInfo(e.defines,this._defines),e.states&&this._prepareInfo(e.states,this._states)},n._prepareInfo=function(e,t){var n=e;if(!Array.isArray(n)){var i=this._effectAsset?this._effectAsset.techniques[this._techIdx].passes.length:1;n=Array(i).fill(n)}for(var o=0;o<n.length;++o)Object.assign(t[o]||(t[o]={}),n[o])},n._createPasses=function(){var e=this._effectAsset.techniques[this._techIdx||0];if(!e)return[];for(var t=e.passes.length,n=[],i=0;i<t;++i){var o=e.passes[i],a=o.passIndex=i,r=o.defines=this._defines[a]||(this._defines[a]={});if(o.stateOverrides=this._states[a]||(this._states[a]={}),void 0!==o.propertyIndex&&Object.assign(r,this._defines[o.propertyIndex]),void 0!==o.embeddedMacros&&Object.assign(r,o.embeddedMacros),!o.switch||r[o.switch]){var c=new zm(s.director.root);c.initialize(o),n.push(c)}}return n},n._update=function(e){var n=this;if(void 0===e&&(e=!0),this._effectAsset){this._passes=this._createPasses();var i=this._effectAsset.techniques[this._techIdx].passes.length;if(this._props.length=i,e)this._passes.forEach((function(e,t){var i=n._props[t];for(var o in i||(i=n._props[t]={}),void 0!==e.propertyIndex&&Object.assign(i,n._props[e.propertyIndex]),i)n._uploadProperty(e,o,i[o])}));else for(var o=0;o<this._props.length;o++)this._props[o]={}}this._hash=t.getHash(this)},n._uploadProperty=function(e,t,n){var i=e.getHandle(t);if(!i)return!1;if(zm.getTypeFromHandle(i)<Be.SAMPLER1D)if(Array.isArray(n))e.setUniformArray(i,n);else if(null!==n){var o;if(null===(o=e.properties[t])||void 0===o?void 0:o.linear){var a=n;Jm(sd,a),sd.w=a.w,n=sd}e.setUniform(i,n)}else e.resetUniform(t);else if(Array.isArray(n))for(var r=0;r<n.length;r++)this._bindTexture(e,i,n[r],r);else n?this._bindTexture(e,i,n):e.resetTexture(t);return!0},n._bindTexture=function(e,t,n,i){var o=zm.getBindingFromHandle(t);if(n instanceof d)e.bindTexture(o,n,i);else if(n instanceof Tu){var a=n.getGFXTexture();if(!a||!a.width||!a.height)return;e.bindTexture(o,a,i),e.bindSampler(o,n.getGFXSampler(),i)}},n._doDestroy=function(){if(this._passes&&this._passes.length)for(var e,t=X(this._passes);!(e=t()).done;)e.value.destroy();this._passes.length=0},n.initDefault=function(t){e.prototype.initDefault.call(this,t),this.initialize({effectName:"unlit",defines:{USE_COLOR:!0},technique:0}),this.setProperty("mainColor",new bn("#ff00ff"))},n.validate=function(){return!!this._effectAsset&&!this._effectAsset.isDefault&&this.passes.length>0},r(t,[{key:"effectAsset",get:function(){return this._effectAsset}},{key:"effectName",get:function(){return this._effectAsset?this._effectAsset.name:""}},{key:"technique",get:function(){return this._techIdx}},{key:"passes",get:function(){return this._passes}},{key:"hash",get:function(){return this._hash}},{key:"parent",get:function(){return null}},{key:"owner",get:function(){return null}}]),t}(ec),td=ee((ed=rd).prototype,"_effectAsset",[Zm],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return null}}),nd=ee(ed.prototype,"_techIdx",[Ya],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return 0}}),id=ee(ed.prototype,"_defines",[Ya],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return[]}}),od=ee(ed.prototype,"_states",[Ya],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return[]}}),ad=ee(ed.prototype,"_props",[Ya],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return[]}}),$m=ed))||$m));s.Material=ld;var fd=e("C",function(e){function t(t,n){var i;(i=e.call(this,t.root)||this)._parent=void 0,i._owner=void 0,i._dontNotify=!1,i._parent=t,i._owner=n,i._doInit(i._parent,!0);for(var o=0;o<i._shaderInfo.blocks.length;o++){var a=i._shaderInfo.blocks[o],r=i._blocks[a.binding],c=i._parent.blocks[a.binding];r.set(c)}i._setRootBufferDirty(!0);for(var s=i._parent,l=0;l<i._shaderInfo.samplerTextures.length;l++)for(var f=i._shaderInfo.samplerTextures[l],_=0;_<f.count;_++){var u=s._descriptorSet.getSampler(f.binding,_),m=s._descriptorSet.getTexture(f.binding,_);i._descriptorSet.bindSampler(f.binding,u,_),i._descriptorSet.bindTexture(f.binding,m,_)}return e.prototype.tryCompile.call(J(i)),i}a(t,e);var n=t.prototype;return n.overridePipelineStates=function(e,t){this._bs.reset(),this._rs.reset(),this._dss.reset(),zm.fillPipelineInfo(this,e),zm.fillPipelineInfo(this,t),this._onStateChange()},n.tryCompile=function(t){if(t&&!dm(this._defines,t))return!1;var n=e.prototype.tryCompile.call(this);return this._onStateChange(),n},n.beginChangeStatesSilently=function(){this._dontNotify=!0},n.endChangeStatesSilently=function(){this._dontNotify=!1},n._syncBatchingScheme=function(){this._defines.USE_BATCHING=this._defines.USE_INSTANCING=!1,this._setBatchingScheme(Tm.NONE)},n._onStateChange=function(){this._setHash(zm.getPassHash(this)),this._owner.onPassStateChange(this._dontNotify)},r(t,[{key:"parent",get:function(){return this._parent}}]),t}(zm)),_d=e("M",function(e){function t(t){var n;return(n=e.call(this)||this)._passes=[],n._parent=void 0,n._owner=void 0,n._subModelIdx=0,n._parent=t.parent,n._owner=t.owner||null,n._subModelIdx=t.subModelIdx||0,n.copy(n._parent),n}a(t,e);var n=t.prototype;return n.recompileShaders=function(e,t){if(this._passes&&this.effectAsset)if(void 0===t)for(var n,i=X(this._passes);!(n=i()).done;)n.value.tryCompile(e);else this._passes[t].tryCompile(e)},n.overridePipelineStates=function(e,t){if(this._passes&&this.effectAsset){var n=this.effectAsset.techniques[this.technique].passes;if(void 0===t)for(var i=0;i<this._passes.length;i++){var o=this._passes[i],a=this._states[i]||(this._states[i]={});for(var r in e)a[r]=e[r];o.overridePipelineStates(n[o.passIndex],a)}else{var c=this._states[t]||(this._states[t]={});for(var s in e)c[s]=e[s];this._passes[t].overridePipelineStates(n[t],c)}}},n.destroy=function(){return this._doDestroy(),!0},n.onPassStateChange=function(e){this._hash=ld.getHash(this),!e&&this._owner&&this._owner._onRebuildPSO(this._subModelIdx,this)},n._createPasses=function(){var e=[],t=this._parent.passes;if(!t)return e;for(var n=0;n<t.length;++n)e.push(new fd(t[n],this));return e},r(t,[{key:"parent",get:function(){return this._parent}},{key:"owner",get:function(){return this._owner}}]),t}(ld)),ud=null,md=null,dd=e("E",Ne({HEMISPHERE_DIFFUSE:0,AUTOGEN_HEMISPHERE_DIFFUSE_WITH_REFLECTION:1,DIFFUSEMAP_WITH_REFLECTION:2})),pd=e("S",function(){function e(){this._envmapLDR=null,this._envmapHDR=null,this._diffuseMapLDR=null,this._diffuseMapHDR=null,this._globalDSManager=null,this._model=null,this._default=null,this._enabled=!1,this._useIBL=!1,this._useHDR=!0,this._useDiffuseMap=!1}var t=e.prototype;return t._setEnabled=function(e){this._enabled=e},t._setUseIBL=function(e){this._useIBL=e},t._setUseHDR=function(e){this._useHDR=e},t._setUseDiffuseMap=function(e){this._useDiffuseMap=e},t.initialize=function(e){this._setEnabled(e.enabled),this._setUseIBL(e.useIBL),this._setUseDiffuseMap(e.applyDiffuseMap),this._setUseHDR(e.useHDR)},t.setEnvMaps=function(e,t){this._envmapHDR=e,this._envmapLDR=t,this._updateGlobalBinding(),this._updatePipeline()},t.setDiffuseMaps=function(e,t){this._diffuseMapHDR=e,this._diffuseMapLDR=t,this._updateGlobalBinding(),this._updatePipeline()},t.activate=function(){var e=s.director.root.pipeline;this._globalDSManager=e.globalDSManager,this._default=wm.get("default-cube-texture"),this._model||(this._model=s.director.root.createModel(s.renderer.scene.Model),this._model._initLocalDescriptors=function(){},this._model._initWorldBoundDescriptors=function(){});var t=this._default.isRGBE;if(this.envmap&&(t=this.envmap.isRGBE),!md){var n=new ld;n.initialize({effectName:"skybox",defines:{USE_RGBE_CUBEMAP:t}}),md=new _d({parent:n})}this.enabled&&(ud||(ud=s.utils.createMesh(s.primitives.box({width:2,height:2,length:2}))),this._model.initSubModel(0,ud.renderingSubMeshes[0],md)),this.envmap||(this.envmap=this._default),this.diffuseMap||(this.diffuseMap=this._default),this._updateGlobalBinding(),this._updatePipeline()},t._updatePipeline=function(){var e=s.director.root,t=e.pipeline,n=this.useIBL?this.isRGBE?2:1:0,i=this.useIBL&&this.useDiffuseMap&&this.diffuseMap?this.isRGBE?2:1:0,o=this.useHDR;t.macros.CC_USE_IBL===n&&t.macros.CC_USE_DIFFUSEMAP===i&&t.macros.CC_USE_HDR===o||(t.macros.CC_USE_IBL=n,t.macros.CC_USE_DIFFUSEMAP=i,t.macros.CC_USE_HDR=o,e.onGlobalPipelineStateChanged()),this.enabled&&md&&md.recompileShaders({USE_RGBE_CUBEMAP:this.isRGBE}),this._model&&this._model.setSubModelMaterial(0,md)},t._updateGlobalBinding=function(){if(this._globalDSManager){var e=s.director.root.device,t=this.envmap?this.envmap:this._default;if(t){var n=t.getGFXTexture(),i=e.getSampler(t.getSamplerInfo());this._globalDSManager.bindSampler(s_,i),this._globalDSManager.bindTexture(s_,n)}var o=this.diffuseMap?this.diffuseMap:this._default;if(o){var a=o.getGFXTexture(),r=e.getSampler(o.getSamplerInfo());this._globalDSManager.bindSampler(__,r),this._globalDSManager.bindTexture(__,a)}this._globalDSManager.update()}},t._destroy=function(){},t.destroy=function(){this._destroy()},r(e,[{key:"model",get:function(){return this._model}},{key:"enabled",get:function(){return this._enabled},set:function(e){this._setEnabled(e),e?this.activate():this._updatePipeline()}},{key:"useHDR",get:function(){return this._useHDR},set:function(e){this._setUseHDR(e),this.setEnvMaps(this._envmapHDR,this._envmapLDR)}},{key:"useIBL",get:function(){return this._useIBL},set:function(e){this._setUseIBL(e),this._updatePipeline()}},{key:"useDiffuseMap",get:function(){return this._useDiffuseMap},set:function(e){this._useDiffuseMap=e,this._updatePipeline()}},{key:"isRGBE",get:function(){return!!this.envmap&&this.envmap.isRGBE}},{key:"envmap",get:function(){return s.director.root.pipeline.pipelineSceneData.isHDR?this._envmapHDR:this._envmapLDR},set:function(e){s.director.root.pipeline.pipelineSceneData.isHDR?this.setEnvMaps(e,this._envmapLDR):this.setEnvMaps(this._envmapHDR,e)}},{key:"diffuseMap",get:function(){return s.director.root.pipeline.pipelineSceneData.isHDR?this._diffuseMapHDR:this._diffuseMapLDR},set:function(e){s.director.root.pipeline.pipelineSceneData.isHDR?this.setDiffuseMaps(e,this._diffuseMapLDR):this.setDiffuseMaps(this._diffuseMapHDR,e)}},{key:"native",get:function(){return this._nativeObj}}]),e}());s.Skybox=pd;var hd=e("f",Ne({Low_256x256:256,Medium_512x512:512,High_1024x1024:1024,Ultra_2048x2048:2048})),vd=e("h",Ne({Planar:0,ShadowMap:1})),gd=(e("P",Ne({HARD:0,SOFT:1,SOFT_2X:2})),vd.ShadowMap+1),xd=e("i",function(){function e(){this.fixedSphere=new Ii(0,0,0,.01),this.maxReceived=4,this.firstSetCSM=!1,this.shadowCameraFar=0,this.matShadowView=new jn,this.matShadowProj=new jn,this.matShadowViewProj=new jn,this._enabled=!1,this._type=gd,this._distance=0,this._normal=new wn(0,1,0),this._shadowColor=new bn(0,0,0,76),this._size=new Xn(512,512),this._shadowMapDirty=!1,this._matLight=new jn,this._material=null,this._instancingMaterial=null}var t=e.prototype;return t.getPlanarShader=function(e){return this._material||(this._material=new ld,this._material.initialize({effectName:"planar-shadow"})),this._material.passes[0].getShaderVariant(e)},t.getPlanarInstanceShader=function(e){return this._instancingMaterial||(this._instancingMaterial=new ld,this._instancingMaterial.initialize({effectName:"planar-shadow",defines:{USE_INSTANCING:!0}})),this._instancingMaterial.passes[0].getShaderVariant(e)},t._setEnable=function(e){this._enabled=e},t._setType=function(e){this._type=this.enabled?e:gd},t.initialize=function(e){this._setEnable(e.enabled),this._setType(e.type),this.normal=e.planeDirection,this.distance=e.planeHeight,this.shadowColor=e.shadowColor,this.maxReceived=e.maxReceived,this.size=e.size},t.activate=function(){this.enabled&&this.type===vd.Planar&&this._updatePlanarInfo()},t._updatePlanarInfo=function(){this._material||(this._material=new ld,this._material.initialize({effectName:"planar-shadow"})),this._instancingMaterial||(this._instancingMaterial=new ld,this._instancingMaterial.initialize({effectName:"planar-shadow",defines:{USE_INSTANCING:!0}}))},t._destroy=function(){},t.destroy=function(){this._destroy(),this._material&&this._material.destroy(),this._instancingMaterial&&this._instancingMaterial.destroy(),this.fixedSphere.destroy()},r(e,[{key:"enabled",get:function(){return this._enabled},set:function(e){this._setEnable(e),this.activate()}},{key:"type",get:function(){return this._type},set:function(e){this._setType(e),this.activate()}},{key:"normal",get:function(){return this._normal},set:function(e){wn.copy(this._normal,e)}},{key:"distance",get:function(){return this._distance},set:function(e){this._distance=e}},{key:"shadowColor",get:function(){return this._shadowColor},set:function(e){this._shadowColor=e}},{key:"size",get:function(){return this._size},set:function(e){this._size.set(e)}},{key:"shadowMapDirty",get:function(){return this._shadowMapDirty},set:function(e){this._shadowMapDirty=e}},{key:"matLight",get:function(){return this._matLight}},{key:"material",get:function(){return this._material}},{key:"instancingMaterial",get:function(){return this._instancingMaterial}},{key:"native",get:function(){return this._nativeObj}}]),e}());xd.MAX_FAR=2e3,xd.COEFFICIENT_OF_EXPANSION=2*Math.sqrt(3),s.Shadows=xd;var yd,Cd,Sd,Ed=new Zn,Pd=e("F",Ne({LINEAR:0,EXP:1,EXP_SQUARED:2,LAYERED:3})),Id=Pd.LAYERED+1,Td=e("k",function(){function e(){this._fogColor=new bn("#C8C8C8"),this._colorArray=new Zn(.2,.2,.2,1),this._enabled=!1,this._accurate=!1,this._type=0,this._fogDensity=.3,this._fogStart=.5,this._fogEnd=300,this._fogAtten=5,this._fogTop=1.5,this._fogRange=1.2}var t=e.prototype;return t._setType=function(e){this._type=this.enabled?e:Id},t._setEnable=function(e){this._enabled=e},t._setAccurate=function(e){this._accurate=e},t.initialize=function(e){this.fogColor=e.fogColor,this._setEnable(e.enabled),this._setAccurate(e.accurate),this._setType(e.type),this.fogDensity=e.fogDensity,this.fogStart=e.fogStart,this.fogEnd=e.fogEnd,this.fogAtten=e.fogAtten,this.fogTop=e.fogTop,this.fogRange=e.fogRange},t.activate=function(){this._updatePipeline()},t._updatePipeline=function(){var e=s.director.root,t=this.enabled?this.type:Id,n=this.accurate?1:0,i=e.pipeline;i.macros.CC_USE_FOG===t&&i.macros.CC_USE_ACCURATE_FOG===n||(i.macros.CC_USE_FOG=t,i.macros.CC_USE_ACCURATE_FOG=n,e.onGlobalPipelineStateChanged())},t._destroy=function(){},t.destroy=function(){this._destroy()},r(e,[{key:"enabled",get:function(){return this._enabled},set:function(e){this._setEnable(e),e?this.activate():(this._type=Id,this._updatePipeline())}},{key:"accurate",get:function(){return this._accurate},set:function(e){this._setAccurate(e),this._updatePipeline()}},{key:"fogColor",get:function(){return this._fogColor},set:function(e){this._fogColor.set(e),Ed.set(e.x,e.y,e.z,e.w),Jm(this._colorArray,Ed)}},{key:"type",get:function(){return this._type},set:function(e){this._setType(e),this.enabled&&this._updatePipeline()}},{key:"fogDensity",get:function(){return this._fogDensity},set:function(e){this._fogDensity=e}},{key:"fogStart",get:function(){return this._fogStart},set:function(e){this._fogStart=e}},{key:"fogEnd",get:function(){return this._fogEnd},set:function(e){this._fogEnd=e}},{key:"fogAtten",get:function(){return this._fogAtten},set:function(e){this._fogAtten=e}},{key:"fogTop",get:function(){return this._fogTop},set:function(e){this._fogTop=e}},{key:"fogRange",get:function(){return this._fogRange},set:function(e){this._fogRange=e}},{key:"colorArray",get:function(){return this._colorArray}},{key:"native",get:function(){return this._nativeObj}}]),e}());s.Fog=Td,function(e){e[e.LOCAL=0]="LOCAL",e[e.WORLD=1]="WORLD"}(yd||(yd={})),function(e){e[e.NONE=0]="NONE",e[e.POSITION=1]="POSITION",e[e.ROTATION=2]="ROTATION",e[e.SCALE=4]="SCALE",e[e.RS=e.ROTATION|e.SCALE]="RS",e[e.TRS=e.POSITION|e.ROTATION|e.SCALE]="TRS",e[e.TRS_MASK=~e.TRS]="TRS_MASK"}(Cd||(Cd=e("ce",{}))),s.internal.TransformBit=Cd;var bd=new O;bd.format=ke.RGBA8;var Ad=new L;Ad.format=ke.DEPTH_STENCIL;var wd=new Tt([bd],Ad),Nd={width:1,height:1,renderPassInfo:wd},Dd=e("aX",Ga("cc.RenderTexture")(Sd=function(e){function t(){for(var t,n=arguments.length,i=new Array(n),o=0;o<n;o++)i[o]=arguments[o];return(t=e.call.apply(e,[this].concat(i))||this)._window=null,t}a(t,e);var n=t.prototype;return n.initialize=function(e){this._name=e.name||"",this._width=e.width,this._height=e.height,this._initWindow(e)},n.reset=function(e){this.initialize(e)},n.destroy=function(){if(this._window){var t=s.director.root;null==t||t.destroyWindow(this._window),this._window=null}return e.prototype.destroy.call(this)},n.resize=function(e,t){this._width=Math.floor(hn(e,1,2048)),this._height=Math.floor(hn(t,1,2048)),this._window&&this._window.resize(this._width,this._height),this.emit("resize",this._window)},n._serialize=function(){return{}},n._deserialize=function(t,n){var i=t;this._width=i.w,this._height=i.h,this._name=i.n,e.prototype._deserialize.call(this,i.base,n)},n.getGFXTexture=function(){return this._window&&this._window.framebuffer.colorTextures[0]},n.onLoaded=function(){this._initWindow()},n._initWindow=function(e){var t=s.director.root;Nd.title=this._name,Nd.width=this._width,Nd.height=this._height,Nd.renderPassInfo=e&&e.passInfo?e.passInfo:wd,bd.barrier=t.device.getGeneralBarrier(new bt(At.FRAGMENT_SHADER_READ_TEXTURE,At.FRAGMENT_SHADER_READ_TEXTURE)),this._window?(this._window.destroy(),this._window.initialize(t.device,Nd)):this._window=t.createWindow(Nd)},n.initDefault=function(t){e.prototype.initDefault.call(this,t),this._width=this._height=1,this._initWindow()},n.validate=function(){return this.width>=1&&this.width<=2048&&this.height>=1&&this.height<=2048},n.readPixels=function(e,t,n,i,o){void 0===e&&(e=0),void 0===t&&(t=0),n=n||this.width,i=i||this.height;var a=this.getGFXTexture();if(!a)return Te(7606),null;var r=4*n*i;if(void 0===o)o=new Uint8Array(r);else if(o.length<r)return Te(7607,r),null;var c=this._getGFXDevice(),s=[],l=[],f=new $e;return f.texOffset.x=e,f.texOffset.y=t,f.texExtent.width=n,f.texExtent.height=i,l.push(f),s.push(o),null==c||c.copyTextureToBuffers(a,s,l),o},r(t,[{key:"window",get:function(){return this._window}}]),t}(Tu))||Sd);function Rd(e,t){for(var n,i=X(t);!(n=i()).done;){var o=n.value;Array.isArray(o)?Rd(e,o):e.push(o)}}function Md(e){var t=[];return Rd(t,e),t.join("")}s.RenderTexture=Dd;var Od=K.Flags.Destroyed,Ld=K.Flags.PersistentMask,zd=Pe+"default",Fd=c.IDENTIFIER_RE,Ud="var ",Gd="o",Bd={"cc.ClickEvent":!1,"cc.PrefabInfo":!1},Hd=c.escapeForJS,Vd=function(){function e(e,t){this.varName=void 0,this.expression=void 0,this.varName=e,this.expression=t}return e.prototype.toString=function(){return Ud+this.varName+"="+this.expression+";"},e}();function kd(e,t){return t instanceof Vd?new Vd(t.varName,e+t.expression):e+t}function jd(e,t,n){Array.isArray(n)?(n[0]=kd(t,n[0]),e.push(n)):e.push(kd(t,n)+";")}var qd=function(){function e(e){this._exps=void 0,this._targetExp=void 0,this._exps=[],this._targetExp=e}var t=e.prototype;return t.append=function(e,t){this._exps.push([e,t])},t.writeCode=function(e){var t;if(this._exps.length>1)e.push("t="+this._targetExp+";"),t="t";else{if(1!==this._exps.length)return;t=this._targetExp}for(var n=0;n<this._exps.length;n++){var i=this._exps[n];jd(e,t+Wd(i[0])+"=",i[1])}},e}();function Wd(e){return Fd.test(e)?"."+e:"["+Hd(e)+"]"}qd.pool=void 0,qd.pool=new ge((function(e){e._exps.length=0,e._targetExp=null}),1),qd.pool.get=function(e){var t=this._get()||new qd;return t._targetExp=e,t};var Yd=function(){function e(e,t){var n;this.parent=void 0,this.objsToClear_iN$t=void 0,this.codeArray=void 0,this.objs=void 0,this.funcs=void 0,this.funcModuleCache=void 0,this.globalVariables=void 0,this.globalVariableId=void 0,this.localVariableId=void 0,this.result=void 0,this.parent=t,this.objsToClear_iN$t=[],this.codeArray=[],this.objs=[],this.funcs=[],this.funcModuleCache=wt(),Nt(this.funcModuleCache,Bd),this.globalVariables=[],this.globalVariableId=0,this.localVariableId=0,this.codeArray.push("var o,t;","if(R){","o=R;","}else{","o=R=new "+this.getFuncModule(e.constructor,!0)+"();","}"),e._iN$t={globalVar:"R"},this.objsToClear_iN$t.push(e),this.enumerateObject(this.codeArray,e),this.globalVariables.length>0&&(n=Ud+this.globalVariables.join(",")+";");var i=Md(["return (function(R){",n||[],this.codeArray,"return o;","})"]);this.result=Function("O","F",i)(this.objs,this.funcs);for(var o=0,a=this.objsToClear_iN$t.length;o<a;++o)this.objsToClear_iN$t[o]._iN$t=null;this.objsToClear_iN$t.length=0}var t=e.prototype;return t.getFuncModule=function(e,t){var n=oe(e);if(n){var i=this.funcModuleCache[n];if(i)return i;if(void 0===i){var o=-1!==n.indexOf(".");if(o)try{if(o=e===Function("return "+n)())return this.funcModuleCache[n]=n,n}catch(e){}}}var a=this.funcs.indexOf(e);a<0&&(a=this.funcs.length,this.funcs.push(e));var r="F["+a+"]";return t&&(r="("+r+")"),this.funcModuleCache[n]=r,r},t.getObjRef=function(e){var t=this.objs.indexOf(e);return t<0&&(t=this.objs.length,this.objs.push(e)),"O["+t+"]"},t.setValueType=function(e,t,n,i){var o=qd.pool.get(i),a=t.constructor.__props__;a||(a=Object.keys(t));for(var r=0;r<a.length;r++){var c=a[r],s=n[c];if(t[c]!==s){var l=this.enumerateField(n,c,s);o.append(c,l)}}o.writeCode(e),qd.pool.put(o)},t.enumerateCCClass=function(e,t,n){for(var i=n.__values__,o=xe(n),a=0;a<i.length;a++){var r=i[a],l=t[r],f=o[r+zd];if(!Xd(f,l))if("object"==typeof l&&l instanceof s.ValueType&&(f=c.getDefault(f))&&f.constructor===l.constructor){var _=Gd+Wd(r);this.setValueType(e,f,l,_)}else this.setObjProp(e,t,r,l)}},t.instantiateArray=function(e){if(0===e.length)return"[]";var t="a"+ ++this.localVariableId,n=[new Vd(t,"new Array("+e.length+")")];e._iN$t={globalVar:"",source:n},this.objsToClear_iN$t.push(e);for(var i=0;i<e.length;++i)jd(n,t+"["+i+"]=",this.enumerateField(e,i,e[i]));return n},t.instantiateTypedArray=function(e){var t=e.constructor.name;if(0===e.length)return"new "+t;var n="a"+ ++this.localVariableId,i=[new Vd(n,"new "+t+"("+e.length+")")];e._iN$t={globalVar:"",source:i},this.objsToClear_iN$t.push(e);for(var o=0;o<e.length;++o)0!==e[o]&&jd(i,n+"["+o+"]=",e[o]);return i},t.enumerateField=function(e,t,n){if("object"==typeof n&&n){var i=n._iN$t;if(i){var o=i.globalVar;if(!o){o=i.globalVar="v"+ ++this.globalVariableId,this.globalVariables.push(o);var a=i.source[0];i.source[0]=kd(o+"=",a)}return o}return ArrayBuffer.isView(n)?this.instantiateTypedArray(n):Array.isArray(n)?this.instantiateArray(n):this.instantiateObj(n)}return"function"==typeof n?this.getFuncModule(n):"string"==typeof n?Hd(n):("_objFlags"===t&&e instanceof K&&(n&=Ld),n)},t.setObjProp=function(e,t,n,i){jd(e,Gd+Wd(n)+"=",this.enumerateField(t,n,i))},t.enumerateObject=function(e,t){var n=t.constructor;if(be(n))this.enumerateCCClass(e,t,n);else for(var i in t)if(t.hasOwnProperty(i)&&(95!==i.charCodeAt(0)||95!==i.charCodeAt(1)||"__type__"===i)){var o=t[i];"object"==typeof o&&o&&o===t._iN$t||this.setObjProp(e,t,i,o)}},t.instantiateObj=function(e){if(e instanceof s.ValueType)return c.getNewValueTypeCode(e);if(e instanceof s.Asset)return this.getObjRef(e);if(e._objFlags&Od)return null;var t,n=e.constructor;if(be(n)){if(this.parent)if(this.parent instanceof s.Component){if(e instanceof s._BaseNode||e instanceof s.Component)return this.getObjRef(e)}else if(this.parent instanceof s._BaseNode)if(e instanceof s._BaseNode){if(!e.isChildOf(this.parent))return this.getObjRef(e)}else if(e instanceof s.Component){var i;if(!(null===(i=e.node)||void 0===i?void 0:i.isChildOf(this.parent)))return this.getObjRef(e)}t=new Vd(Gd,"new "+this.getFuncModule(n,!0)+"()")}else if(n===Object)t=new Vd(Gd,"{}");else{if(n)return this.getObjRef(e);t=new Vd(Gd,"Object.create(null)")}var o=[t];return e._iN$t={globalVar:"",source:o},this.objsToClear_iN$t.push(e),this.enumerateObject(o,e),["(function(){",o,"return o;})();"]},e}();function Xd(e,t){if("function"==typeof e)try{e=e()}catch(e){return!1}if(e===t)return!0;if(e&&t&&"object"==typeof e&&"object"==typeof t&&e.constructor===t.constructor)if(e instanceof s.ValueType){if(e.equals(t))return!0}else{if(Array.isArray(e))return 0===e.length&&0===t.length;if(e.constructor===Object)return Dt(e)&&Dt(t)}return!1}var Kd,Jd,Qd,Zd,$d,ep,tp,np,ip,op,ap=function(){function e(e){this._uiComp=null,this._opacity=1,this._localOpacity=1,this.colorDirty=!0,this._uiTransformComp=null,this._node=void 0,this._node=e}return e.prototype.applyOpacity=function(e){this._opacity=this._localOpacity*e},e.markOpacityTree=function(){},r(e,[{key:"uiTransformComp",get:function(){return this._uiTransformComp||(this._uiTransformComp=this._node.getComponent("cc.UITransform")),this._uiTransformComp},set:function(e){this._uiTransformComp=e}},{key:"uiComp",get:function(){return this._uiComp},set:function(e){this._uiComp&&e?W(12002):this._uiComp=e}},{key:"opacity",get:function(){return this._opacity}},{key:"localOpacity",get:function(){return this._localOpacity},set:function(e){this._localOpacity=e,this.colorDirty=!0}}]),e}();K.Flags.Destroying,function(e){e.TOUCH_START="touch-start",e.TOUCH_MOVE="touch-move",e.TOUCH_END="touch-end",e.TOUCH_CANCEL="touch-cancel",e.MOUSE_DOWN="mouse-down",e.MOUSE_MOVE="mouse-move",e.MOUSE_UP="mouse-up",e.MOUSE_WHEEL="mouse-wheel",e.MOUSE_ENTER="mouse-enter",e.MOUSE_LEAVE="mouse-leave",e.KEY_DOWN="keydown",e.KEY_UP="keyup",e.DEVICEMOTION="devicemotion",e.TRANSFORM_CHANGED="transform-changed",e.SCENE_CHANGED_FOR_PERSISTS="scene-changed-for-persists",e.SIZE_CHANGED="size-changed",e.ANCHOR_CHANGED="anchor-changed",e.COLOR_CHANGED="color-changed",e.CHILD_ADDED="child-added",e.CHILD_REMOVED="child-removed",e.PARENT_CHANGED="parent-changed",e.NODE_DESTROYED="node-destroyed",e.LAYER_CHANGED="layer-changed",e.SIBLING_ORDER_CHANGED="sibling-order-changed",e.ACTIVE_IN_HIERARCHY_CHANGED="active-in-hierarchy-changed"}(Kd||(Kd=e("dR",{})));var rp=K.Flags.Destroying,cp=K.Flags.DontDestroy,sp=K.Flags.Deactivating,lp=new ae("Node");function fp(e){return e?"string"==typeof e?Rt(e):e:(Te(3804),null)}var _p,up,mp,dp,pp,hp,vp,gp,xp,yp,Cp,Sp=e("b5",Ga("cc.BaseNode")((op=ip=function(e){a(n,e),n._setScene=function(e){e._updateScene()},n._findComponent=function(e,t){var n=t,i=e._components;if(n._sealed)for(var o=0;o<i.length;++o){var a=i[o];if(a.constructor===t)return a}else for(var r=0;r<i.length;++r){var c=i[r];if(c instanceof t)return c}return null},n._findComponents=function(e,t,n){var i=t,o=e._components;if(i._sealed)for(var a=0;a<o.length;++a){var r=o[a];r.constructor===t&&n.push(r)}else for(var c=0;c<o.length;++c){var s=o[c];s instanceof t&&n.push(s)}},n._findChildComponent=function(e,t){for(var i=0;i<e.length;++i){var o=e[i],a=n._findComponent(o,t);if(a)return a;if(o._children.length>0&&(a=n._findChildComponent(o._children,t)))return a}return null},n._findChildComponents=function(e,t,i){for(var o=0;o<e.length;++o){var a=e[o];n._findComponents(a,t,i),a._children.length>0&&n._findChildComponents(a._children,t,i)}};var t=n.prototype;function n(t){var n;return n=e.call(this,t)||this,te(n,"_parent",Zd,J(n)),te(n,"_children",$d,J(n)),te(n,"_active",ep,J(n)),te(n,"_components",tp,J(n)),te(n,"_prefab",np,J(n)),n._scene=null,n._activeInHierarchy=!1,n._id=lp.getNewId(),n._name=void 0,n._eventProcessor=new s.NodeEventProcessor(J(n)),n._eventMask=0,n._siblingIndex=0,n._originalSceneId="",n._registerIfAttached=void 0,n._name=void 0!==t?t:"New Node",n}return t._updateScene=function(){null==this._parent?o("Node %s(%s) has not attached to a scene.",this.name,this.uuid):this._scene=this._parent._scene},t.attr=function(e){Nt(this,e)},t.getParent=function(){return this._parent},t.setParent=function(e,t){if(void 0===t&&(t=!1),this._parent!==e){var n=this._parent,i=e;if(this._parent=i,this._siblingIndex=0,this._onSetParent(n,t),this.emit&&this.emit(Kd.PARENT_CHANGED,n),n&&!(n._objFlags&rp)){var o=n._children.indexOf(this);n._children.splice(o,1),n._updateSiblingIndex(),n.emit&&n.emit(Kd.CHILD_REMOVED,this)}i&&(i._children.push(this),this._siblingIndex=i._children.length-1,i.emit&&i.emit(Kd.CHILD_ADDED,this)),this._onHierarchyChanged(n)}},t.getChildByUuid=function(e){if(!e)return he("Invalid uuid"),null;for(var t=this._children,n=0,i=t.length;n<i;n++)if(t[n]._id===e)return t[n];return null},t.getChildByName=function(e){if(!e)return he("Invalid name"),null;for(var t=this._children,n=0,i=t.length;n<i;n++)if(t[n]._name===e)return t[n];return null},t.getChildByPath=function(e){for(var t=e.split("/"),n=this,i=function(e){var i=t[e];if(0===i.length)return"continue";var o=n.children.find((function(e){return e.name===i}));if(!o)return{v:null};n=o},o=0;o<t.length;++o){var a=i(o);if("continue"!==a&&"object"==typeof a)return a.v}return n},t.addChild=function(e){e.setParent(this)},t.insertChild=function(e,t){e.parent=this,e.setSiblingIndex(t)},t.getSiblingIndex=function(){return this._siblingIndex},t.setSiblingIndex=function(e){if(this._parent)if(this._parent._objFlags&sp)Te(3821);else{var t=this._parent._children;e=-1!==e?e:t.length-1;var n=t.indexOf(this);e!==n&&(t.splice(n,1),e<t.length?t.splice(e,0,this):t.push(this),this._parent._updateSiblingIndex(),this._onSiblingIndexChanged&&this._onSiblingIndexChanged(e))}},t.walk=function(e,t){var i=1,o=null,a=null,r=0,c=n._stacks[n._stackId];c||(c=[],n._stacks.push(c)),n._stackId++,c.length=0,c[0]=this;for(var s=null,l=!1;i;)if(a=c[--i])if(!l&&e?e(a):l&&t&&t(a),c[i]=null,l){if(s===this._parent)break;if(l=!1,o)if(o[++r])c[i]=o[r],i++;else if(s&&(c[i]=s,i++,l=!0,s._parent?(r=(o=s._parent._children).indexOf(s),s=s._parent):(s=null,o=null),r<0))break}else a._children.length>0?(s=a,o=a._children,r=0,c[i]=o[r],i++):(c[i]=a,i++,l=!0);c.length=0,n._stackId--},t.removeFromParent=function(){this._parent&&this._parent.removeChild(this)},t.removeChild=function(e){this._children.indexOf(e)>-1&&(e.parent=null)},t.removeAllChildren=function(){for(var e=this._children,t=e.length-1;t>=0;t--){var n=e[t];n&&(n.parent=null)}this._children.length=0},t.isChildOf=function(e){var t=this;do{if(t===e)return!0;t=t._parent}while(t);return!1},t.getComponent=function(e){var t=fp(e);return t?n._findComponent(this,t):null},t.getComponents=function(e){var t=fp(e),i=[];return t&&n._findComponents(this,t,i),i},t.getComponentInChildren=function(e){var t=fp(e);return t?n._findChildComponent(this._children,t):null},t.getComponentsInChildren=function(e){var t=fp(e),i=[];return t&&(n._findComponents(this,t,i),n._findChildComponents(this._children,t,i)),i},t.addComponent=function(e){var t;if("string"==typeof e){if(!(t=Rt(e)))throw s._RF.peek()&&Te(3808,e),TypeError(Z(3807,e))}else{if(!e)throw TypeError(Z(3804));t=e}if("function"!=typeof t)throw TypeError(Z(3809));if(!Se(t,s.Component))throw TypeError(Z(3810));var n=t._requireComponent;if(n)if(Array.isArray(n))for(var i=0;i<n.length;i++){var o=n[i];this.getComponent(o)||this.addComponent(o)}else{var a=n;this.getComponent(a)||this.addComponent(a)}var r=new t;return r.node=this,this._components.push(r),this._activeInHierarchy&&s.director._nodeActivator.activateComp(r),r},t.removeComponent=function(e){if(e){var t=null;(t=e instanceof Cc?e:this.getComponent(e))&&t.destroy()}else Te(3813)},t.on=function(e,t,n,i){switch(void 0===i&&(i=!1),e){case Kd.TRANSFORM_CHANGED:this._eventMask|=1}this._eventProcessor.on(e,t,n,i)},t.off=function(e,t,n,i){if(void 0===i&&(i=!1),this._eventProcessor.off(e,t,n,i),!this._eventProcessor.hasEventListener(e))switch(e){case Kd.TRANSFORM_CHANGED:this._eventMask&=-2}},t.once=function(e,t,n,i){this._eventProcessor.once(e,t,n,i)},t.emit=function(e,t,n,i,o,a){this._eventProcessor.emit(e,t,n,i,o,a)},t.dispatchEvent=function(e){this._eventProcessor.dispatchEvent(e)},t.hasEventListener=function(e,t,n){return this._eventProcessor.hasEventListener(e,t,n)},t.targetOff=function(e){this._eventProcessor.targetOff(e),1&this._eventMask&&!this._eventProcessor.hasEventListener(Kd.TRANSFORM_CHANGED)&&(this._eventMask&=-2)},t.destroy=function(){return!!e.prototype.destroy.call(this)&&(this.active=!1,!0)},t.destroyAllChildren=function(){for(var e=this._children,t=0;t<e.length;++t)e[t].destroy()},t._removeComponent=function(e){if(e){if(!(this._objFlags&rp)){var t=this._components.indexOf(e);-1!==t?this._components.splice(t,1):e.node!==this&&Te(3815)}}else Te(3814)},t._updateSiblingIndex=function(){for(var e=0;e<this._children.length;++e)this._children[e]._siblingIndex=e;this.emit(Kd.SIBLING_ORDER_CHANGED)},t._onSetParent=function(e){this._parent&&(null!=e&&e._scene===this._parent._scene||null==this._parent._scene||this.walk(n._setScene))},t._onPostActivated=function(){},t._onBatchCreated=function(){this._parent&&(this._siblingIndex=this._parent.children.indexOf(this))},t._onPreDestroy=function(){this._onPreDestroyBase()},t._onHierarchyChanged=function(e){return this._onHierarchyChangedBase(e)},t._instantiate=function(e,t){return e||(e=s.instantiate._clone(this,this)),e._prefab,e._parent=null,e._onBatchCreated(t),e},t._onHierarchyChangedBase=function(){var e=this._parent;!this._persistNode||e instanceof s.Scene||s.game.removePersistRootNode(this);var t=this._active&&!(!e||!e._activeInHierarchy);this._activeInHierarchy!==t&&s.director._nodeActivator.activateNode(this,t)},t._onPreDestroyBase=function(){this._objFlags|=rp;var e=this._parent,t=!!e&&0!=(e._objFlags&rp);if(!t&&Mt&&this._registerIfAttached(!1),this._persistNode&&s.game.removePersistRootNode(this),!t&&e){this.emit(Kd.PARENT_CHANGED,this);var n=e._children.indexOf(this);e._children.splice(n,1),this._siblingIndex=0,e._updateSiblingIndex(),e.emit&&e.emit(Kd.CHILD_REMOVED,this)}this.emit(Kd.NODE_DESTROYED,this),this._eventProcessor.destroy();for(var i=this._children,o=0;o<i.length;++o)i[o]._destroyImmediate();for(var a=this._components,r=0;r<a.length;++r)a[r]._destroyImmediate();return t},r(n,[{key:"components",get:function(){return this._components}},{key:"_persistNode",get:function(){return(this._objFlags&cp)>0},set:function(e){e?this._objFlags|=cp:this._objFlags&=~cp}},{key:"name",get:function(){return this._name},set:function(e){this._name=e}},{key:"uuid",get:function(){return this._id}},{key:"children",get:function(){return this._children}},{key:"active",get:function(){return this._active},set:function(e){if(e=!!e,this._active!==e){this._active=e;var t=this._parent;t&&t._activeInHierarchy&&s.director._nodeActivator.activateNode(this,e)}}},{key:"activeInHierarchy",get:function(){return this._activeInHierarchy}},{key:"parent",get:function(){return this._parent},set:function(e){this.setParent(e)}},{key:"scene",get:function(){return this._scene}},{key:"eventProcessor",get:function(){return this._eventProcessor}}]),n}(K),ip.idGenerator=lp,ip._stacks=[[]],ip._stackId=0,ee((Qd=op).prototype,"_persistNode",[ka],Object.getOwnPropertyDescriptor(Qd.prototype,"_persistNode"),Qd.prototype),ee(Qd.prototype,"name",[or],Object.getOwnPropertyDescriptor(Qd.prototype,"name"),Qd.prototype),ee(Qd.prototype,"children",[or],Object.getOwnPropertyDescriptor(Qd.prototype,"children"),Qd.prototype),ee(Qd.prototype,"active",[or],Object.getOwnPropertyDescriptor(Qd.prototype,"active"),Qd.prototype),ee(Qd.prototype,"activeInHierarchy",[or],Object.getOwnPropertyDescriptor(Qd.prototype,"activeInHierarchy"),Qd.prototype),ee(Qd.prototype,"parent",[or],Object.getOwnPropertyDescriptor(Qd.prototype,"parent"),Qd.prototype),Zd=ee(Qd.prototype,"_parent",[Ya],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return null}}),$d=ee(Qd.prototype,"_children",[Ya],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return[]}}),ep=ee(Qd.prototype,"_active",[Ya],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return!0}}),tp=ee(Qd.prototype,"_components",[Ya],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return[]}}),np=ee(Qd.prototype,"_prefab",[Ya],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return null}}),Jd=Qd))||Jd);s._BaseNode=Sp;var Ep=new wn,Pp=new zn,Ip=new zn,Tp=new zn,bp=new Mn,Ap=new Mn,wp=new jn,Np=[],Dp=[],Rp=[],Mp=function(){function e(){this._chunks=[],this._freelists=[],this._createChunk()}var t=e.prototype;return t.alloc=function(){for(var e=this._freelists.length,t=0;t<e;++t)if(this._freelists[t].length)return this._createView(t);return this._createChunk(),this._createView(e)},t.free=function(e,t){for(var n=this._freelists.length,i=0;i<n;++i)if(this._chunks[i]===e)return void this._freelists[i].push(t)},t.clear=function(){for(var e=this._chunks.length,t=0;t<e;++t)this._chunks[t].fill(0)},t._createChunk=function(){this._chunks.push(new Uint32Array(e.CAPACITY_PER_CHUNK));for(var t=[],n=e.CAPACITY_PER_CHUNK-1;n>=0;n--)t.push(n);this._freelists.push(t)},t._createView=function(e){return Rp[0]=this._chunks[e],Rp[1]=this._freelists[e].pop(),Rp},e}();Mp.CAPACITY_PER_CHUNK=256;var Op,Lp,zp,Fp,Up,Gp,Bp,Hp,Vp,kp,jp,qp,Wp,Yp,Xp,Kp,Jp,Qp,Zp,$p,eh,th,nh,ih,oh,ah,rh,ch,sh,lh,fh,_h,uh,mh,dh,ph,hh,vh,gh,xh,yh,Ch,Sh,Eh,Ph,Ih,Th,bh,Ah,wh,Nh,Dh,Rh,Mh,Oh,Lh,zh,Fh,Uh,Gh,Bh,Hh,Vh,kh,jh,qh,Wh,Yh,Xh,Kh=new Mp,Jh=Symbol("ReserveContentsForAllSyncablePrefab"),Qh=e("b6",(_p=Ga("cc.Node"),up=xr(wn),_p((Cp=yp=function(e){a(n,e);var t=n.prototype;function n(t){var n;return(n=e.call(this,t)||this)._uiProps=new ap(J(n)),n._static=!1,te(n,"_lpos",pp,J(n)),te(n,"_lrot",hp,J(n)),te(n,"_lscale",vp,J(n)),te(n,"_layer",gp,J(n)),te(n,"_euler",xp,J(n)),n._dirtyFlagsPri=Cd.NONE,n._eulerDirty=!1,n._nodeHandle=Jo,n._init(),n}return t._init=function(){var e=Kh.alloc(),t=e[0],n=e[1];this._hasChangedFlagsChunk=t,this._hasChangedFlagsOffset=n;var i=new Uint32Array(t.buffer,t.byteOffset+4*n,1);this._hasChangedFlags=i,this._pos=new wn,this._rot=new zn,this._scale=new wn(1,1,1),this._mat=new jn},n.isNode=function(e){return e instanceof n&&(e.constructor===n||!(e instanceof s.Scene))},t._onPreDestroy=function(){var e=this._onPreDestroyBase();return Kh.free(this._hasChangedFlagsChunk,this._hasChangedFlagsOffset),e},t[Dc]=function(e){e.writeThis()},t.setParent=function(t,n){void 0===n&&(n=!1),n&&this.updateWorldTransform(),e.prototype.setParent.call(this,t,n)},t._onSetParent=function(t,n){if(e.prototype._onSetParent.call(this,t,n),n){var i=this._parent;i?(i.updateWorldTransform(),pn(jn.determinant(i._mat),0,dn)?(W(14200),this._dirtyFlags|=Cd.TRS,this.updateWorldTransform()):(jn.multiply(wp,jn.invert(wp,i._mat),this._mat),jn.toRTS(wp,this._lrot,this._lpos,this._lscale))):(wn.copy(this._lpos,this._pos),zn.copy(this._lrot,this._rot),wn.copy(this._lscale,this._scale)),this._eulerDirty=!0}this.invalidateChildren(Cd.TRS)},t._onHierarchyChanged=function(t){this.eventProcessor.reattach(),e.prototype._onHierarchyChangedBase.call(this,t)},t._onBatchCreated=function(e){this.hasChangedFlags=Cd.TRS,this._dirtyFlags|=Cd.TRS;for(var t=this._children.length,n=0;n<t;++n)this._children[n]._siblingIndex=n,this._children[n]._onBatchCreated(e)},t._onBeforeSerialize=function(){this.eulerAngles},t._onPostActivated=function(e){e?(this._eventProcessor.setEnabled(!0),this.invalidateChildren(Cd.TRS),this._uiProps&&this._uiProps.uiComp&&(this._uiProps.uiComp.setNodeDirty(),this._uiProps.uiComp.setTextureDirty(),this._uiProps.uiComp.markForUpdateRenderData())):this._eventProcessor.setEnabled(!1)},t.translate=function(e,t){var n=t||yd.LOCAL;if(n===yd.LOCAL)wn.transformQuat(Ep,e,this._lrot),this._lpos.x+=Ep.x,this._lpos.y+=Ep.y,this._lpos.z+=Ep.z;else if(n===yd.WORLD)if(this._parent){zn.invert(Pp,this._parent.worldRotation),wn.transformQuat(Ep,e,Pp);var i=this.worldScale;this._lpos.x+=Ep.x/i.x,this._lpos.y+=Ep.y/i.y,this._lpos.z+=Ep.z/i.z}else this._lpos.x+=e.x,this._lpos.y+=e.y,this._lpos.z+=e.z;this.invalidateChildren(Cd.POSITION),1&this._eventMask&&this.emit(Kd.TRANSFORM_CHANGED,Cd.POSITION)},t.rotate=function(e,t){var n=t||yd.LOCAL;if(zn.normalize(Pp,e),n===yd.LOCAL)zn.multiply(this._lrot,this._lrot,Pp);else if(n===yd.WORLD){var i=this.worldRotation;zn.multiply(Ip,Pp,i),zn.invert(Pp,i),zn.multiply(Ip,Pp,Ip),zn.multiply(this._lrot,this._lrot,Ip)}this._eulerDirty=!0,this.invalidateChildren(Cd.ROTATION),1&this._eventMask&&this.emit(Kd.TRANSFORM_CHANGED,Cd.ROTATION)},t.lookAt=function(e,t){this.getWorldPosition(Ep),wn.subtract(Ep,Ep,e),wn.normalize(Ep,Ep),zn.fromViewUp(Pp,Ep,t),this.setWorldRotation(Pp)},t._setDirtyNode=function(e,t){Np[e]=t},t.invalidateChildren=function(e){var t,n,i,o=0,a=0,r=0,c=0,s=0,l=e|Cd.POSITION;for(Np[0]=this;o>=0;){if(s=(t=Np[o--])._hasChangedFlags[0],c=t._dirtyFlagsPri,t.isValid&&(c&s&e)!==e)for(c|=e,t._dirtyFlagsPri=c,t._hasChangedFlags[0]=s|e,r=(i=t._children).length,a=0;a<r;a++)n=i[a],Np[++o]=n;e=l}},t.updateWorldTransform=function(){if(this._dirtyFlags){for(var e,t=this,n=0;t&&t._dirtyFlags;)this._setDirtyNode(n++,t),t=t._parent;for(var i=0;n;)i|=(e=Np[--n])._dirtyFlags,t?(i&Cd.POSITION&&(wn.transformMat4(e._pos,e._lpos,t._mat),e._mat.m12=e._pos.x,e._mat.m13=e._pos.y,e._mat.m14=e._pos.z),i&Cd.RS&&(jn.fromRTS(e._mat,e._lrot,e._lpos,e._lscale),jn.multiply(e._mat,t._mat,e._mat),i&Cd.ROTATION&&zn.multiply(e._rot,t._rot,e._lrot),Mn.fromQuat(bp,zn.conjugate(Tp,e._rot)),Mn.multiplyMat4(bp,bp,e._mat),e._scale.x=bp.m00,e._scale.y=bp.m04,e._scale.z=bp.m08)):(i&Cd.POSITION&&(wn.copy(e._pos,e._lpos),e._mat.m12=e._pos.x,e._mat.m13=e._pos.y,e._mat.m14=e._pos.z),i&Cd.RS&&(i&Cd.ROTATION&&zn.copy(e._rot,e._lrot),i&Cd.SCALE&&(wn.copy(e._scale,e._lscale),jn.fromRTS(e._mat,e._rot,e._pos,e._scale)))),e._dirtyFlags=Cd.NONE,t=e}},t.setPosition=function(e,t,n){void 0===t&&void 0===n?wn.copy(this._lpos,e):void 0===n?wn.set(this._lpos,e,t,this._lpos.z):wn.set(this._lpos,e,t,n),this.invalidateChildren(Cd.POSITION),1&this._eventMask&&this.emit(Kd.TRANSFORM_CHANGED,Cd.POSITION)},t.getPosition=function(e){return e?wn.set(e,this._lpos.x,this._lpos.y,this._lpos.z):wn.copy(new wn,this._lpos)},t.setRotation=function(e,t,n,i){void 0===t||void 0===n||void 0===i?zn.copy(this._lrot,e):zn.set(this._lrot,e,t,n,i),this._eulerDirty=!0,this.invalidateChildren(Cd.ROTATION),1&this._eventMask&&this.emit(Kd.TRANSFORM_CHANGED,Cd.ROTATION)},t.setRotationFromEuler=function(e,t,n){var i=void 0===n?this._euler.z:n;void 0===t?(wn.copy(this._euler,e),zn.fromEuler(this._lrot,e.x,e.y,e.z)):(wn.set(this._euler,e,t,i),zn.fromEuler(this._lrot,e,t,i)),this._eulerDirty=!1,this.invalidateChildren(Cd.ROTATION),1&this._eventMask&&this.emit(Kd.TRANSFORM_CHANGED,Cd.ROTATION)},t.getRotation=function(e){return e?zn.set(e,this._lrot.x,this._lrot.y,this._lrot.z,this._lrot.w):zn.copy(new zn,this._lrot)},t.setScale=function(e,t,n){void 0===t&&void 0===n?wn.copy(this._lscale,e):void 0===n?wn.set(this._lscale,e,t,this._lscale.z):wn.set(this._lscale,e,t,n),this.invalidateChildren(Cd.SCALE),1&this._eventMask&&this.emit(Kd.TRANSFORM_CHANGED,Cd.SCALE)},t.getScale=function(e){return e?wn.set(e,this._lscale.x,this._lscale.y,this._lscale.z):wn.copy(new wn,this._lscale)},t.inverseTransformPoint=function(e,t){wn.copy(e,t);for(var n=this,i=0;n._parent;)this._setDirtyNode(i++,n),n=n._parent;for(;i>=0;)wn.transformInverseRTS(e,e,n._lrot,n._lpos,n._lscale),n=Np[--i];return e},t.setWorldPosition=function(e,t,n){void 0===t||void 0===n?wn.copy(this._pos,e):wn.set(this._pos,e,t,n);var i=this._parent,o=this._lpos;i?(i.updateWorldTransform(),wn.transformMat4(o,this._pos,jn.invert(wp,i._mat))):wn.copy(o,this._pos),this.invalidateChildren(Cd.POSITION),1&this._eventMask&&this.emit(Kd.TRANSFORM_CHANGED,Cd.POSITION)},t.getWorldPosition=function(e){return this.updateWorldTransform(),e?wn.copy(e,this._pos):wn.copy(new wn,this._pos)},t.setWorldRotation=function(e,t,n,i){void 0===t||void 0===n||void 0===i?zn.copy(this._rot,e):zn.set(this._rot,e,t,n,i),this._parent?(this._parent.updateWorldTransform(),zn.multiply(this._lrot,zn.conjugate(this._lrot,this._parent._rot),this._rot)):zn.copy(this._lrot,this._rot),this._eulerDirty=!0,this.invalidateChildren(Cd.ROTATION),1&this._eventMask&&this.emit(Kd.TRANSFORM_CHANGED,Cd.ROTATION)},t.setWorldRotationFromEuler=function(e,t,n){zn.fromEuler(this._rot,e,t,n),this._parent?(this._parent.updateWorldTransform(),zn.multiply(this._lrot,zn.conjugate(this._lrot,this._parent._rot),this._rot)):zn.copy(this._lrot,this._rot),this._eulerDirty=!0,this.invalidateChildren(Cd.ROTATION),1&this._eventMask&&this.emit(Kd.TRANSFORM_CHANGED,Cd.ROTATION)},t.getWorldRotation=function(e){return this.updateWorldTransform(),e?zn.copy(e,this._rot):zn.copy(new zn,this._rot)},t.setWorldScale=function(e,t,n){void 0===t||void 0===n?wn.copy(this._scale,e):wn.set(this._scale,e,t,n);var i=this._parent;i?(i.updateWorldTransform(),Mn.fromQuat(bp,zn.conjugate(Tp,i._rot)),Mn.multiplyMat4(bp,bp,i._mat),Ap.m00=this._scale.x,Ap.m04=this._scale.y,Ap.m08=this._scale.z,Mn.multiply(bp,Ap,Mn.invert(bp,bp)),this._lscale.x=wn.set(Ep,bp.m00,bp.m01,bp.m02).length(),this._lscale.y=wn.set(Ep,bp.m03,bp.m04,bp.m05).length(),this._lscale.z=wn.set(Ep,bp.m06,bp.m07,bp.m08).length()):wn.copy(this._lscale,this._scale),this.invalidateChildren(Cd.SCALE),1&this._eventMask&&this.emit(Kd.TRANSFORM_CHANGED,Cd.SCALE)},t.getWorldScale=function(e){return this.updateWorldTransform(),e?wn.copy(e,this._scale):wn.copy(new wn,this._scale)},t.getWorldMatrix=function(e){this.updateWorldTransform();var t=e||new jn;return jn.copy(t,this._mat)},t.getWorldRS=function(e){this.updateWorldTransform();var t=e||new jn;return jn.copy(t,this._mat),t.m12=0,t.m13=0,t.m14=0,t},t.getWorldRT=function(e){this.updateWorldTransform();var t=e||new jn;return jn.fromRT(t,this._rot,this._pos)},t.setRTS=function(e,t,n){var i=0;e&&(i|=Cd.ROTATION,void 0!==e.w?(zn.copy(this._lrot,e),this._eulerDirty=!0):(wn.copy(this._euler,e),zn.fromEuler(this._lrot,e.x,e.y,e.z),this._eulerDirty=!1)),t&&(wn.copy(this._lpos,t),i|=Cd.POSITION),n&&(wn.copy(this._lscale,n),i|=Cd.SCALE),i&&(this.invalidateChildren(i),1&this._eventMask&&this.emit(Kd.TRANSFORM_CHANGED,i))},t.pauseSystemEvents=function(e){this._eventProcessor.setEnabled(!1,e)},t.resumeSystemEvents=function(e){this._eventProcessor.setEnabled(!0,e)},n.resetHasChangedFlags=function(){Kh.clear()},n.clearNodeArray=function(){n.ClearFrame<n.ClearRound&&!Mt?n.ClearFrame++:(n.ClearFrame=0,Np.length=0,Dp.length=0)},t.getPathInHierarchy=function(){for(var e=this.name,t=this.parent;t&&t instanceof n;)e=t.name+"/"+e,t=t.parent;return e},r(n,[{key:"_dirtyFlags",get:function(){return this._dirtyFlagsPri},set:function(e){this._dirtyFlagsPri=e}},{key:"native",get:function(){return this._nativeObj}},{key:"position",get:function(){return this._lpos},set:function(e){this.setPosition(e)}},{key:"worldPosition",get:function(){return this.updateWorldTransform(),this._pos},set:function(e){this.setWorldPosition(e)}},{key:"rotation",get:function(){return this._lrot},set:function(e){this.setRotation(e)}},{key:"eulerAngles",get:function(){return this._eulerDirty&&(zn.toEuler(this._euler,this._lrot),this._eulerDirty=!1),this._euler},set:function(e){this.setRotationFromEuler(e.x,e.y,e.z)}},{key:"angle",get:function(){return this._euler.z},set:function(e){wn.set(this._euler,0,0,e),zn.fromAngleZ(this._lrot,e),this._eulerDirty=!1,this.invalidateChildren(Cd.ROTATION),1&this._eventMask&&this.emit(Kd.TRANSFORM_CHANGED,Cd.ROTATION)}},{key:"worldRotation",get:function(){return this.updateWorldTransform(),this._rot},set:function(e){this.setWorldRotation(e)}},{key:"scale",get:function(){return this._lscale},set:function(e){this.setScale(e)}},{key:"worldScale",get:function(){return this.updateWorldTransform(),this._scale},set:function(e){this.setWorldScale(e)}},{key:"matrix",set:function(e){jn.toRTS(e,this._lrot,this._lpos,this._lscale),this.invalidateChildren(Cd.TRS),this._eulerDirty=!0,1&this._eventMask&&this.emit(Kd.TRANSFORM_CHANGED,Cd.TRS)}},{key:"worldMatrix",get:function(){return this.updateWorldTransform(),this._mat}},{key:"forward",get:function(){return wn.transformQuat(new wn,wn.FORWARD,this.worldRotation)},set:function(e){var t=e.length();wn.multiplyScalar(Ep,e,-1/t),zn.fromViewUp(Pp,Ep),this.setWorldRotation(Pp)}},{key:"up",get:function(){return wn.transformQuat(new wn,wn.UP,this.worldRotation)}},{key:"right",get:function(){return wn.transformQuat(new wn,wn.RIGHT,this.worldRotation)}},{key:"layer",get:function(){return this._layer},set:function(e){this._layer=e,this._uiProps&&this._uiProps.uiComp&&(this._uiProps.uiComp.setNodeDirty(),this._uiProps.uiComp.markForUpdateRenderData()),this.emit(Kd.LAYER_CHANGED,this._layer)}},{key:"hasChangedFlags",get:function(){return this._hasChangedFlagsChunk[this._hasChangedFlagsOffset]},set:function(e){this._hasChangedFlagsChunk[this._hasChangedFlagsOffset]=e}}]),n}(Sp),yp.EventType=Kd,yp.NodeSpace=yd,yp.TransformDirtyBit=Cd,yp.TransformBit=Cd,yp.reserveContentsForAllSyncablePrefabTag=Jh,yp.ClearFrame=0,yp.ClearRound=1e3,pp=ee((dp=Cp).prototype,"_lpos",[Ya],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return new wn}}),hp=ee(dp.prototype,"_lrot",[Ya],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return new zn}}),vp=ee(dp.prototype,"_lscale",[Ya],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return new wn(1,1,1)}}),gp=ee(dp.prototype,"_layer",[Ya],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return Gf.Enum.DEFAULT}}),xp=ee(dp.prototype,"_euler",[Ya],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return new wn}}),ee(dp.prototype,"eulerAngles",[up],Object.getOwnPropertyDescriptor(dp.prototype,"eulerAngles"),dp.prototype),ee(dp.prototype,"angle",[or],Object.getOwnPropertyDescriptor(dp.prototype,"angle"),dp.prototype),ee(dp.prototype,"layer",[or],Object.getOwnPropertyDescriptor(dp.prototype,"layer"),dp.prototype),mp=dp))||mp));s.Node=Qh;var Zh=Ga("cc.TargetInfo")((zp=ee((Lp=function(){te(this,"localID",zp,this)}).prototype,"localID",[Ya],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return[]}}),Op=Lp))||Op,$h=(Fp=Ga("cc.TargetOverrideInfo"),Up=xr(K),Gp=xr(Zh),Bp=xr(Qh),Hp=xr(Zh),Fp((jp=ee((kp=function(){te(this,"source",jp,this),te(this,"sourceInfo",qp,this),te(this,"propertyPath",Wp,this),te(this,"target",Yp,this),te(this,"targetInfo",Xp,this)}).prototype,"source",[Ya,Up],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return null}}),qp=ee(kp.prototype,"sourceInfo",[Ya,Gp],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return null}}),Wp=ee(kp.prototype,"propertyPath",[Ya],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return[]}}),Yp=ee(kp.prototype,"target",[Ya,Bp],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return null}}),Xp=ee(kp.prototype,"targetInfo",[Ya,Hp],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return null}}),Vp=kp))||Vp),ev=Ga("cc.CompPrefabInfo")((Qp=ee((Jp=function(){te(this,"fileId",Qp,this)}).prototype,"fileId",[Ya,or],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return""}}),Kp=Jp))||Kp,tv=(Zp=Ga("CCPropertyOverrideInfo"),$p=xr(Zh),Zp((ah=function(){function e(){te(this,"targetInfo",nh,this),te(this,"propertyPath",ih,this),te(this,"value",oh,this)}return e.prototype.isTarget=function(){},e}(),nh=ee((th=ah).prototype,"targetInfo",[Ya,$p],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return null}}),ih=ee(th.prototype,"propertyPath",[Ya],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return[]}}),oh=ee(th.prototype,"value",[Ya],{configurable:!0,enumerable:!0,writable:!0,initializer:null}),eh=th))||eh),nv=(rh=Ga("cc.MountedChildrenInfo"),ch=xr(Zh),sh=xr([Qh]),rh((mh=function(){function e(){te(this,"targetInfo",_h,this),te(this,"nodes",uh,this)}return e.prototype.isTarget=function(){},e}(),_h=ee((fh=mh).prototype,"targetInfo",[Ya,ch],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return null}}),uh=ee(fh.prototype,"nodes",[Ya,sh],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return[]}}),lh=fh))||lh),iv=(dh=Ga("cc.MountedComponentsInfo"),ph=xr(Zh),hh=xr([Cc]),dh((Ch=function(){function e(){te(this,"targetInfo",xh,this),te(this,"components",yh,this)}return e.prototype.isTarget=function(){},e}(),xh=ee((gh=Ch).prototype,"targetInfo",[Ya,ph],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return null}}),yh=ee(gh.prototype,"components",[Ya,hh],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return[]}}),vh=gh))||vh),ov=(Sh=Ga("cc.PrefabInstance"),Eh=xr(Qh),Ph=xr([nv]),Ih=xr([iv]),Th=xr([tv]),bh=xr([Zh]),Sh((zh=function(){function e(){te(this,"fileId",Nh,this),te(this,"prefabRootNode",Dh,this),te(this,"mountedChildren",Rh,this),te(this,"mountedComponents",Mh,this),te(this,"propertyOverrides",Oh,this),te(this,"removedComponents",Lh,this),this.targetMap={}}var t=e.prototype;return t.findPropertyOverride=function(){},t.removePropertyOverride=function(){},e}(),Nh=ee((wh=zh).prototype,"fileId",[Ya],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return""}}),Dh=ee(wh.prototype,"prefabRootNode",[Ya,Eh],{configurable:!0,enumerable:!0,writable:!0,initializer:null}),Rh=ee(wh.prototype,"mountedChildren",[Ya,Ph],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return[]}}),Mh=ee(wh.prototype,"mountedComponents",[Ya,Ih],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return[]}}),Oh=ee(wh.prototype,"propertyOverrides",[Ya,Th],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return[]}}),Lh=ee(wh.prototype,"removedComponents",[Ya,bh],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return[]}}),Ah=wh))||Ah),av=(Fh=Ga("cc.PrefabInfo"),Uh=xr(Qh),Gh=xr(ov),Bh=xr([$h]),Fh((kh=ee((Vh=function(){te(this,"root",kh,this),te(this,"asset",jh,this),te(this,"fileId",qh,this),te(this,"instance",Wh,this),te(this,"targetOverrides",Yh,this),te(this,"nestedPrefabInstanceRoots",Xh,this)}).prototype,"root",[Ya,Uh],{configurable:!0,enumerable:!0,writable:!0,initializer:null}),jh=ee(Vh.prototype,"asset",[Ya],{configurable:!0,enumerable:!0,writable:!0,initializer:null}),qh=ee(Vh.prototype,"fileId",[Ya,or],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return""}}),Wh=ee(Vh.prototype,"instance",[Ya,Gh],{configurable:!0,enumerable:!0,writable:!0,initializer:null}),Yh=ee(Vh.prototype,"targetOverrides",[Ya,Bh],{configurable:!0,enumerable:!0,writable:!0,initializer:null}),Xh=ee(Vh.prototype,"nestedPrefabInstanceRoots",[Ya],{configurable:!0,enumerable:!0,writable:!0,initializer:null}),Hh=Vh))||Hh);function rv(e){var t=e._prefab;if(t&&t.instance){if(!t.asset)return Te(3701,e.name),void(t.instance=void 0);var n=e._objFlags,i=e._parent,o=e._id,a=e._prefab;e[we],s.game._isCloning=!0;var r=t.asset.data;r._iN$t=e,s.instantiate._clone(r,r),s.game._isCloning=!1,e._objFlags=n,e._parent=i,e._id=o,e._prefab&&(e._prefab.instance=null==a?void 0:a.instance)}}function cv(e,t,n){var i;if(t&&e){var o=t,a=null===(i=e._prefab)||void 0===i?void 0:i.instance;!n&&a&&(t[a.fileId]={},o=t[a.fileId]);var r=e._prefab;r&&(o[r.fileId]=e);for(var c=e.components,s=0;s<c.length;s++){var l=c[s];l.__prefab&&(o[l.__prefab.fileId]=l)}for(var f=0;f<e.children.length;f++)cv(e.children[f],o,!1)}}function sv(e,t){if(!e)return null;for(var n=t,i=0;i<e.length;i++){if(!n)return null;n=n[e[i]]}return n}function lv(e,t,n){if(t)for(var i=0;i<t.length;i++){var o=t[i];if(o&&o.targetInfo){var a=sv(o.targetInfo.localID,n);if(!a)continue;var r=n,c=o.targetInfo.localID;if(c.length>0)for(var s=0;s<c.length-1;s++)r=r[c[s]];if(o.nodes)for(var l=0;l<o.nodes.length;l++){var f=o.nodes[l];f&&!a._children.includes(f)&&(a._children.push(f),f._parent=a,cv(f,r,!1),f._siblingIndex=a._children.length-1,dv(f,!0))}}}}function fv(e,t,n){if(t)for(var i=0;i<t.length;i++){var o=t[i];if(o&&o.targetInfo){var a=sv(o.targetInfo.localID,n);if(!a)continue;if(o.components)for(var r=0;r<o.components.length;r++){var c=o.components[r];c&&(c.node=a,a._components.push(c))}}}}function _v(e,t,n){if(t)for(var i=0;i<t.length;i++){var o=t[i];if(o){var a=sv(o.localID,n);if(!a||!a.node)continue;var r=a.node.components.indexOf(a);r>=0&&a.node._components.splice(r,1)}}}function uv(e,t,n){if(!(t.length<=0))for(var i=null,o=0;o<t.length;o++){var a=t[o];if(a&&a.targetInfo){if(!(i=sv(a.targetInfo.localID,n)))continue;var r=i,c=a.propertyPath.slice();if(c.length>0){var s=c.pop();if(!s)continue;for(var f=0;f<c.length&&(r=r[c[f]]);f++);if(!r)continue;if(Array.isArray(r))if("length"===s)r[s]=a.value;else{var _=Number.parseInt(s);Number.isInteger(_)&&_<r.length&&(r[s]=a.value)}else r[s]instanceof l?r[s].set(a.value):r[s]=a.value}}}}function mv(e){var t,n=null===(t=e._prefab)||void 0===t?void 0:t.targetOverrides;if(n)for(var i=0;i<n.length;i++){var o,a,r=n[i],c=r.source,s=r.sourceInfo;if(s){var l,f,_=null===(l=r.source)||void 0===l||null===(f=l._prefab)||void 0===f?void 0:f.instance;_&&_.targetMap&&(c=sv(s.localID,_.targetMap))}if(c){var u,m=r.targetInfo;if(m){var d=null===(o=r.target)||void 0===o||null===(a=o._prefab)||void 0===a?void 0:a.instance;if(d&&d.targetMap&&(u=sv(m.localID,d.targetMap))){var p=r.propertyPath.slice(),h=c;if(p.length>0){var v=p.pop();if(!v)return;for(var g=0;g<p.length&&(h=h[p[g]]);g++);if(!h)continue;h[v]=u}}}}}}function dv(e,t){void 0===t&&(t=!1);var n=e._prefab,i=null==n?void 0:n.instance;if(i){rv(e);var o={};i.targetMap=o,cv(e,o,!0),lv(0,i.mountedChildren,o),_v(0,i.removedComponents,o),fv(0,i.mountedComponents,o),uv(0,i.propertyOverrides,o)}t&&e&&e.children&&e.children.forEach((function(e){dv(e,!0)}))}function pv(e){var t=e._prefab;t&&t.nestedPrefabInstanceRoots&&t.nestedPrefabInstanceRoots.forEach((function(e){dv(e)}))}s._PrefabInfo=av;var hv,vv,gv,xv,yv,Cv,Sv,Ev,Pv,Iv,Tv,bv,Av,wv,Nv=Object.freeze({__proto__:null,TargetInfo:Zh,TargetOverrideInfo:$h,CompPrefabInfo:ev,PropertyOverrideInfo:tv,MountedChildrenInfo:nv,MountedComponentsInfo:iv,PrefabInstance:ov,PrefabInfo:av,createNodeWithPrefab:rv,generateTargetMap:cv,getTarget:sv,applyMountedChildren:lv,applyMountedComponents:fv,applyRemovedComponents:_v,applyPropertyOverrides:uv,applyTargetOverrides:mv,expandPrefabInstanceNode:dv,expandNestedPrefabInstanceNode:pv}),Dv=Ne({AUTO:0,SINGLE_INSTANCE:1,MULTI_INSTANCE:2}),Rv=e("aN",Ga("cc.Prefab")((Sv=Cv=function(e){function t(){var t;return t=e.call(this)||this,te(t,"data",gv,J(t)),te(t,"optimizationPolicy",xv,J(t)),te(t,"persistent",yv,J(t)),t._createFunction=void 0,t._instantiatedTimes=void 0,t._createFunction=null,t._instantiatedTimes=0,t}a(t,e);var n=t.prototype;return n.createNode=function(e){var t=s.instantiate(this);t.name=this.name,e(null,t)},n.compileCreateFunction=function(){var e,t;this._createFunction=(t=(e=this.data)instanceof s._BaseNode&&e,new Yd(e,t).result)},n._doInstantiate=function(e){return this.data._prefab||W(3700),this._createFunction||this.compileCreateFunction(),this._createFunction(e)},n._instantiate=function(){var e;return e=this.data._instantiate(),++this._instantiatedTimes,e},n.initDefault=function(t){e.prototype.initDefault.call(this,t),this.data=new Qh,this.data.name="(Missing Node)";var n=new s._PrefabInfo;n.asset=this,n.root=this.data,this.data._prefab=n},n.validate=function(){return!!this.data},n.onLoaded=function(){var e=this.data;pv(e),mv(e)},t}(ec),Cv.OptimizationPolicy=Dv,Cv.OptimizationPolicyThreshold=3,gv=ee((vv=Sv).prototype,"data",[Ya,or],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return null}}),xv=ee(vv.prototype,"optimizationPolicy",[Ya,or],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return Dv.AUTO}}),yv=ee(vv.prototype,"persistent",[Ya,or],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return!1}}),hv=vv))||hv);G.value(Rv,"_utils",Nv),s.Prefab=Rv,Ot(s,"cc._Prefab","Prefab"),e("av",(Ev=Ga("cc.PrefabLink"),Pv=xr(Rv),Iv=ar(),Ev((wv=function(e){function t(){for(var t,n=arguments.length,i=new Array(n),o=0;o<n;o++)i[o]=arguments[o];return t=e.call.apply(e,[this].concat(i))||this,te(t,"prefab",Av,J(t)),t}return a(t,e),t}(Cc),Av=ee((bv=wv).prototype,"prefab",[Pv,Ya,Iv],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return null}}),Tv=bv))||Tv));var Mv=new wn;function Ov(e,t,n,i){i||(i=new wn),e.convertToUINode(t,n,i);var o=n.position;return i.add(o),i}function Lv(e,t,n){return n||(n=new wn),e.worldToScreen(t,n),n.x/=s.view.getScaleX(),n.y/=s.view.getScaleY(),n}var zv,Fv,Uv,Gv=e("aC",{WorldNode3DToLocalNodeUI:Ov,WorldNode3DToWorldNodeUI:Lv});s.pipelineUtils=Gv,nn(s.pipelineUtils,"cc.pipelineUtils",[{name:"WorldNode3DToLocalNodeUI",newName:"convertToUINode",targetName:"cc.Camera.prototype",customFunction:function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];var i=t[0],o=t[3]||Mv;return i.convertToUINode(t[1],t[2],o),o.add(t[2].position),t[3]||o.clone()}}]),on(Tu.prototype,"TextureBase.prototype",[{name:"hasPremultipliedAlpha"},{name:"setPremultiplyAlpha"},{name:"setFlipY"}]),nn(Dd.prototype,"RenderTexture.prototype",[{name:"getGFXWindow",customFunction:function(){return this._window}}]);var Bv,Hv=e("aM",Ga("cc.BufferAsset")((Uv=function(e){function t(){for(var t,n=arguments.length,i=new Array(n),o=0;o<n;o++)i[o]=arguments[o];return(t=e.call.apply(e,[this].concat(i))||this)._buffer=null,t}a(t,e);var n=t.prototype;return n.buffer=function(){return this._buffer},n.validate=function(){return!!this.buffer},r(t,[{key:"_nativeAsset",get:function(){return this._buffer},set:function(e){e instanceof ArrayBuffer?this._buffer=e:this._buffer=e.buffer}}]),t}(ec),ee((Fv=Uv).prototype,"_nativeAsset",[yr],Object.getOwnPropertyDescriptor(Fv.prototype,"_nativeAsset"),Fv.prototype),zv=Fv))||zv);s.BufferAsset=Hv;var Vv,kv,jv=((Bv={})[Lt.UNORM]="Uint",Bv[Lt.SNORM]="Int",Bv[Lt.UINT]="Uint",Bv[Lt.INT]="Int",Bv[Lt.UFLOAT]="Float",Bv[Lt.FLOAT]="Float",Bv.default="Uint",Bv);function qv(e){return""+(jv[e.type]||jv.default)+e.size/e.count*8}function Wv(e,t,n,i,o,a,r){void 0===n&&(n=ke.R32F),void 0===i&&(i=0),void 0===o&&(o=e.byteLength-i),void 0===a&&(a=0),r||(r=new DataView(e.buffer.slice(e.byteOffset,e.byteOffset+e.byteLength)));var c=zt[n];a||(a=c.size);for(var s="set"+qv(c),l="get"+qv(c),f=c.size/c.count,_=Math.floor(o/a),u=Nc.isLittleEndian,m=0;m<_;++m)for(var d=i+a*m,p=0;p<c.count;++p){var h=d+f*p,v=e[l](h,u);r[s](h,t(v,p,e),u)}return r}e("aO",function(){var e=t.prototype;function t(e,t,n,i,o,a){void 0===i&&(i=null),void 0===o&&(o=null),void 0===a&&(a=!0),this.mesh=void 0,this.subMeshIdx=void 0,this._flatBuffers=[],this._jointMappedBuffers=void 0,this._jointMappedBufferIndices=void 0,this._vertexIdChannel=void 0,this._geometricInfo=void 0,this._vertexBuffers=void 0,this._attributes=void 0,this._indexBuffer=null,this._indirectBuffer=null,this._primitiveMode=void 0,this._iaInfo=void 0,this._isOwnerOfIndexBuffer=!0,this._attributes=t,this._vertexBuffers=e,this._indexBuffer=i,this._indirectBuffer=o,this._primitiveMode=n,this._iaInfo=new xt(t,e,i,o),this._isOwnerOfIndexBuffer=a,this._init()}return e._init=function(){},e.genFlatBuffers=function(){if(!this._flatBuffers.length&&this.mesh&&void 0!==this.subMeshIdx){var e=this.mesh,t=0,n=e.struct.primitives[this.subMeshIdx];n.indexView&&(t=n.indexView.count);for(var i=0;i<n.vertexBundelIndices.length;i++){var o=n.vertexBundelIndices[i],a=e.struct.vertexBundles[o],r=n.indexView?n.indexView.count:a.view.count,c=a.view.stride,s=c*r,l=new Uint8Array(e.data.buffer,a.view.offset,a.view.length),f=new Uint8Array(n.indexView?s:a.view.length);if(n.indexView){for(var _=e.readIndices(this.subMeshIdx),u=0;u<t;++u)for(var m=u*c,d=_[u]*c,p=0;p<c;++p)f[m+p]=l[d+p];this._flatBuffers.push({stride:c,count:r,buffer:f})}else f.set(e.data.subarray(a.view.offset,a.view.offset+a.view.length)),this._flatBuffers.push({stride:c,count:r,buffer:f})}}},e.destroy=function(){for(var e=0;e<this.vertexBuffers.length;e++)this.vertexBuffers[e].destroy();if(this.vertexBuffers.length=0,this._indexBuffer&&(this._isOwnerOfIndexBuffer&&this._indexBuffer.destroy(),this._indexBuffer=null),this._jointMappedBuffers&&this._jointMappedBufferIndices){for(var t=0;t<this._jointMappedBufferIndices.length;t++)this._jointMappedBuffers[this._jointMappedBufferIndices[t]].destroy();this._jointMappedBuffers=void 0,this._jointMappedBufferIndices=void 0}this._indirectBuffer&&(this._indirectBuffer.destroy(),this._indirectBuffer=null)},e.enableVertexIdChannel=function(e){if(!this._vertexIdChannel){var t=this.vertexBuffers.length,n=this.attributes.length,i=this._allocVertexIdBuffer(e);this._vertexBuffers.push(i),this._attributes.push(new _t("a_vertexId",ke.R32F,!1,t)),this._iaInfo.attributes=this._attributes,this._iaInfo.vertexBuffers=this._vertexBuffers,this._vertexIdChannel={stream:t,index:n}}},e._allocVertexIdBuffer=function(e){for(var t=0===this.vertexBuffers.length||0===this.vertexBuffers[0].stride?0:this.vertexBuffers[0].size/this.vertexBuffers[0].stride,n=new Float32Array(t),i=0;i<t;++i)n[i]=i+.5;var o=e.createBuffer(new ht(vt.VERTEX|vt.TRANSFER_DST,gt.DEVICE,n.byteLength,n.BYTES_PER_ELEMENT));return o.update(n),o},r(t,[{key:"attributes",get:function(){return this._attributes}},{key:"vertexBuffers",get:function(){return this._vertexBuffers}},{key:"indexBuffer",get:function(){return this._indexBuffer}},{key:"indirectBuffer",get:function(){return this._indirectBuffer}},{key:"primitiveMode",get:function(){return this._primitiveMode}},{key:"geometricInfo",get:function(){if(this._geometricInfo)return this._geometricInfo;if(void 0===this.mesh)return{positions:new Float32Array,indices:new Uint8Array,boundingBox:{min:wn.ZERO,max:wn.ZERO}};if(void 0===this.subMeshIdx)return{positions:new Float32Array,indices:new Uint8Array,boundingBox:{min:wn.ZERO,max:wn.ZERO}};var e=this.mesh,t=this.subMeshIdx,n=e.readAttribute(t,Ft.ATTR_POSITION),i=e.readIndices(t),o=new wn,a=new wn,r=this.attributes.find((function(e){return e.name===Ft.ATTR_POSITION}));if(r){var c=zt[r.format].count;2===c?(o.set(n[0],n[1],0),a.set(n[0],n[1],0)):(o.set(n[0],n[1],n[2]),a.set(n[0],n[1],n[2]));for(var s=0;s<n.length;s+=c)2===c?(o.x=n[s]>o.x?n[s]:o.x,o.y=n[s+1]>o.y?n[s+1]:o.y,a.x=n[s]<a.x?n[s]:a.x,a.y=n[s+1]<a.y?n[s+1]:a.y):(o.x=n[s]>o.x?n[s]:o.x,o.y=n[s+1]>o.y?n[s+1]:o.y,o.z=n[s+2]>o.z?n[s+2]:o.z,a.x=n[s]<a.x?n[s]:a.x,a.y=n[s+1]<a.y?n[s+1]:a.y,a.z=n[s+2]<a.z?n[s+2]:a.z)}return this._geometricInfo={positions:n,indices:i,boundingBox:{max:o,min:a}},this._geometricInfo}},{key:"flatBuffers",get:function(){return this._flatBuffers}},{key:"jointMappedBuffers",get:function(){var e=this;if(this._jointMappedBuffers)return this._jointMappedBuffers;var t=this._jointMappedBuffers=[],n=this._jointMappedBufferIndices=[];if(!this.mesh||void 0===this.subMeshIdx)return this._jointMappedBuffers=this.vertexBuffers;var i,o,a=this.mesh.struct,r=a.primitives[this.subMeshIdx];if(!a.jointMaps||void 0===r.jointMapIndex||!a.jointMaps[r.jointMapIndex])return this._jointMappedBuffers=this.vertexBuffers;for(var c=s.director.root.device,l=0;l<r.vertexBundelIndices.length;l++){var f=a.vertexBundles[r.vertexBundelIndices[l]];o=0,i=ke.UNKNOWN;for(var _=0;_<f.attributes.length;_++){var u=f.attributes[_];if(u.name===Ft.ATTR_JOINTS){i=u.format;break}o+=zt[u.format].size}i?function(){var s=new Uint8Array(e.mesh.data.buffer,f.view.offset,f.view.length),_=new DataView(s.slice().buffer),u=a.jointMaps[r.jointMapIndex];Wv(_,(function(e){return u.indexOf(e)}),i,o,f.view.length,f.view.stride,_);var m=c.createBuffer(new ht(vt.VERTEX|vt.TRANSFER_DST,gt.DEVICE,f.view.length,f.view.stride));m.update(_.buffer),t.push(m),n.push(l)}():t.push(this.vertexBuffers[r.vertexBundelIndices[l]])}return this._vertexIdChannel&&t.push(this._allocVertexIdBuffer(c)),t}},{key:"iaInfo",get:function(){return this._iaInfo}}]),t}()),function(e){e.TOUCH_START="touch-start",e.TOUCH_MOVE="touch-move",e.TOUCH_END="touch-end",e.TOUCH_CANCEL="touch-cancel",e.MOUSE_DOWN="mouse-down",e.MOUSE_MOVE="mouse-move",e.MOUSE_UP="mouse-up",e.MOUSE_WHEEL="mouse-wheel",e.MOUSE_ENTER="mouse-enter",e.MOUSE_LEAVE="mouse-leave",e.KEY_DOWN="keydown",e.KEY_UP="keyup",e.DEVICEMOTION="devicemotion",e.TRANSFORM_CHANGED="transform-changed",e.SCENE_CHANGED_FOR_PERSISTS="scene-changed-for-persists",e.SIZE_CHANGED="size-changed",e.ANCHOR_CHANGED="anchor-changed",e.COLOR_CHANGED="color-changed",e.CHILD_ADDED="child-added",e.CHILD_REMOVED="child-removed",e.PARENT_CHANGED="parent-changed",e.NODE_DESTROYED="node-destroyed",e.LAYER_CHANGED="layer-changed",e.SIBLING_ORDER_CHANGED="sibling-order-changed"}(Vv||(Vv=e("bw",{}))),function(e){e.TOUCH_START="touch-start",e.TOUCH_MOVE="touch-move",e.TOUCH_END="touch-end",e.TOUCH_CANCEL="touch-cancel",e.MOUSE_DOWN="mouse-down",e.MOUSE_MOVE="mouse-move",e.MOUSE_UP="mouse-up",e.MOUSE_WHEEL="mouse-wheel",e.KEY_DOWN="keydown",e.KEY_PRESSING="key-pressing",e.KEY_UP="keyup",e.DEVICEMOTION="devicemotion"}(kv||(kv=e("dW",{}))),s.SystemEventType=Vv;var Yv,Xv=new Array(16),Kv=null,Jv=new Xn,Qv=[Kd.TOUCH_START,Kd.TOUCH_MOVE,Kd.TOUCH_END,Kd.TOUCH_CANCEL],Zv=[Kd.MOUSE_DOWN,Kd.MOUSE_ENTER,Kd.MOUSE_MOVE,Kd.MOUSE_LEAVE,Kd.MOUSE_UP,Kd.MOUSE_WHEEL];!function(e){e[e.ADD_POINTER_EVENT_PROCESSOR=0]="ADD_POINTER_EVENT_PROCESSOR",e[e.REMOVE_POINTER_EVENT_PROCESSOR=1]="REMOVE_POINTER_EVENT_PROCESSOR",e[e.MARK_LIST_DIRTY=2]="MARK_LIST_DIRTY"}(Yv||(Yv=e("dV",{})));var $v,eg,tg,ng,ig,og,ag,rg,cg,sg,lg,fg,_g,ug,mg,dg,pg,hg,vg,gg,xg,yg,Cg,Sg,Eg,Pg,Ig,Tg,bg,Ag,wg,Ng,Dg,Rg,Mg,Og,Lg,zg,Fg,Ug,Gg,Bg,Hg,Vg,kg,jg,qg,Wg,Yg,Xg,Kg,Jg,Qg,Zg,$g,ex,tx,nx,ix,ox,ax,rx,cx,sx,lx,fx,_x,ux,mx,dx,px,hx,vx,gx,xx,yx,Cx,Sx,Ex,Px,Ix,Tx,bx,Ax,wx,Nx,Dx,Rx,Mx,Ox,Lx,zx,Fx,Ux,Gx,Bx,Hx,Vx,kx,jx,qx,Wx,Yx,Xx,Kx,Jx,Qx,Zx,$x,ey,ty,ny,iy,oy,ay,ry,cy,sy,ly,fy,_y,uy,dy,py,hy,vy,gy,xy,yy,Cy,Sy,Ey,Py,Iy,Ty,by,Ay,wy,Ny,Dy,Ry,My,Oy,Ly,zy=e("dS",function(){var e=t.prototype;function t(e){this._isEnabled=!1,this.claimedTouchIdList=[],this.maskList=null,this.cachedCameraPriority=0,this.previousMouseIn=!1,this.bubblingTarget=null,this.capturingTarget=null,this.shouldHandleEventMouse=!1,this.shouldHandleEventTouch=!1,this._node=void 0,this._node=e}return e.setEnabled=function(e,n){if(void 0===n&&(n=!1),this._isEnabled!==e){this._isEnabled=e;var i=this.node.children;if(e&&this._attachMask(),t.callbacksInvoker.emit(Yv.MARK_LIST_DIRTY),n&&i.length>0)for(var o=0;o<i.length;++o)i[o]._eventProcessor.setEnabled(e,!0)}},e._searchComponentsInParent=function(e){var t=this.node;if(e){for(var n=0,i=[],o=t;o&&Qh.isNode(o);o=o.parent,++n){var a=o.getComponent(e);if(a){var r={index:n,comp:a};i?i.push(r):i=[r]}}return i.length>0?i:null}return null},e._attachMask=function(){this.maskList=this._searchComponentsInParent(t._maskComp)},e.reattach=function(){var e,n=this;this.node.walk((function(i){e||(e=n._searchComponentsInParent(t._maskComp)),i.eventProcessor.maskList=e}))},e.destroy=function(){Kv===this._node&&(Kv=null),this.capturingTarget&&this.capturingTarget.clear(),this.bubblingTarget&&this.bubblingTarget.clear(),t.callbacksInvoker.emit(Yv.REMOVE_POINTER_EVENT_PROCESSOR,this)},e._isTouchEvent=function(e){return-1!==Qv.indexOf(e)},e._isMouseEvent=function(e){return-1!==Zv.indexOf(e)},e._hasTouchListeners=function(){for(var e=0;e<Qv.length;++e){var t=Qv[e];if(this.hasEventListener(t))return!0}return!1},e._hasMouseListeners=function(){for(var e=0;e<Zv.length;++e){var t=Zv[e];if(this.hasEventListener(t))return!0}return!1},e._hasPointerListeners=function(){return!!this._hasTouchListeners()||this._hasMouseListeners()},e._tryEmittingAddEvent=function(e){var n=this._isTouchEvent(e),i=this._isMouseEvent(e);n?this.shouldHandleEventTouch=!0:i&&(this.shouldHandleEventMouse=!0),!n&&!i||this._hasPointerListeners()||t.callbacksInvoker.emit(Yv.ADD_POINTER_EVENT_PROCESSOR,this)},e._newCallbacksInvoker=function(){var e=this,n=new Ut;return n._registerOffCallback((function(){e.shouldHandleEventTouch&&!e._hasTouchListeners()&&(e.shouldHandleEventTouch=!1),e.shouldHandleEventMouse&&!e._hasMouseListeners()&&(e.shouldHandleEventMouse=!1),e._hasPointerListeners()||t.callbacksInvoker.emit(Yv.REMOVE_POINTER_EVENT_PROCESSOR,e)})),n},e.on=function(e,t,n,i){var o,a;return this._tryEmittingAddEvent(e),((i=!!i)?null!==(o=this.capturingTarget)&&void 0!==o?o:this.capturingTarget=this._newCallbacksInvoker():null!==(a=this.bubblingTarget)&&void 0!==a?a:this.bubblingTarget=this._newCallbacksInvoker()).on(e,t,n),t},e.once=function(e,t,n,i){var o,a;return this._tryEmittingAddEvent(e),((i=!!i)?null!==(o=this.capturingTarget)&&void 0!==o?o:this.capturingTarget=this._newCallbacksInvoker():null!==(a=this.bubblingTarget)&&void 0!==a?a:this.bubblingTarget=this._newCallbacksInvoker()).on(e,t,n,!0),t},e.off=function(e,t,n,i){var o;null===(o=(i=!!i)?this.capturingTarget:this.bubblingTarget)||void 0===o||o.off(e,t,n)},e.targetOff=function(e){var n,i;null===(n=this.capturingTarget)||void 0===n||n.removeAll(e),null===(i=this.bubblingTarget)||void 0===i||i.removeAll(e),this.shouldHandleEventTouch&&!this._hasTouchListeners()&&(this.shouldHandleEventTouch=!1),this.shouldHandleEventMouse&&!this._hasMouseListeners()&&(this.shouldHandleEventMouse=!1),this._hasPointerListeners()||t.callbacksInvoker.emit(Yv.REMOVE_POINTER_EVENT_PROCESSOR,this)},e.emit=function(e,t,n,i,o,a){var r;null===(r=this.bubblingTarget)||void 0===r||r.emit(e,t,n,i,o,a)},e.dispatchEvent=function(e){var t,n=this.node,i=0;for(e.target=n,Xv.length=0,this.getCapturingTargets(e.type,Xv),e.eventPhase=1,i=Xv.length-1;i>=0;--i)if((t=Xv[i]).eventProcessor.capturingTarget&&(e.currentTarget=t,t.eventProcessor.capturingTarget.emit(e.type,e,Xv),e.propagationStopped))return void(Xv.length=0);if(Xv.length=0,e.eventPhase=2,e.currentTarget=n,this.capturingTarget&&this.capturingTarget.emit(e.type,e),!e.propagationImmediateStopped&&this.bubblingTarget&&this.bubblingTarget.emit(e.type,e),!e.propagationStopped&&e.bubbles)for(this.getBubblingTargets(e.type,Xv),e.eventPhase=3,i=0;i<Xv.length;++i)if((t=Xv[i]).eventProcessor.bubblingTarget&&(e.currentTarget=t,t.eventProcessor.bubblingTarget.emit(e.type,e),e.propagationStopped))return void(Xv.length=0);Xv.length=0},e.hasEventListener=function(e,t,n){var i=!1;return this.bubblingTarget&&(i=this.bubblingTarget.hasEventListener(e,t,n)),!i&&this.capturingTarget&&(i=this.capturingTarget.hasEventListener(e,t,n)),i},e.getCapturingTargets=function(e,t){for(var n=this._node.parent;n;){var i;(null===(i=n.eventProcessor.capturingTarget)||void 0===i?void 0:i.hasEventListener(e))&&t.push(n),n=n.parent}},e.getBubblingTargets=function(e,t){for(var n=this._node.parent;n;){var i;(null===(i=n.eventProcessor.bubblingTarget)||void 0===i?void 0:i.hasEventListener(e))&&t.push(n),n=n.parent}},e._handleEventMouse=function(e){switch(e.type){case kv.MOUSE_DOWN:return this._handleMouseDown(e);case kv.MOUSE_MOVE:return this._handleMouseMove(e);case kv.MOUSE_UP:return this._handleMouseUp(e);case kv.MOUSE_WHEEL:return this._handleMouseWheel(e);default:return!1}},e._handleMouseDown=function(e){var t=this._node;return!(!t||!t._uiProps.uiTransformComp||(e.getLocation(Jv),!t._uiProps.uiTransformComp.hitTest(Jv)||(e.type=Kd.MOUSE_DOWN,e.bubbles=!0,t.dispatchEvent(e),e.propagationStopped=!0,0)))},e._handleMouseMove=function(e){var t=this._node;return!(!t||!t._uiProps.uiTransformComp||(e.getLocation(Jv),t._uiProps.uiTransformComp.hitTest(Jv)?(this.previousMouseIn||(Kv&&Kv!==t&&(e.type=Kd.MOUSE_LEAVE,Kv.dispatchEvent(e),Kv.eventProcessor.previousMouseIn=!1),Kv=t,e.type=Kd.MOUSE_ENTER,t.dispatchEvent(e),this.previousMouseIn=!0),e.type=Kd.MOUSE_MOVE,e.bubbles=!0,t.dispatchEvent(e),e.propagationStopped=!0,0):(this.previousMouseIn&&(e.type=Kd.MOUSE_LEAVE,t.dispatchEvent(e),this.previousMouseIn=!1,Kv=null),1)))},e._handleMouseUp=function(e){var t=this._node;return!(!t||!t._uiProps.uiTransformComp||(e.getLocation(Jv),!t._uiProps.uiTransformComp.hitTest(Jv)||(e.type=Kd.MOUSE_UP,e.bubbles=!0,t.dispatchEvent(e),e.propagationStopped=!0,0)))},e._handleMouseWheel=function(e){var t=this._node;return!(!t||!t._uiProps.uiTransformComp||(e.getLocation(Jv),!t._uiProps.uiTransformComp.hitTest(Jv)||(e.type=Kd.MOUSE_WHEEL,e.bubbles=!0,t.dispatchEvent(e),e.propagationStopped=!0,0)))},e._handleEventTouch=function(e){switch(e.type){case kv.TOUCH_START:return this._handleTouchStart(e);case kv.TOUCH_MOVE:return this._handleTouchMove(e);case kv.TOUCH_END:return this._handleTouchEnd(e);case kv.TOUCH_CANCEL:return this._handleTouchCancel(e);default:return!1}},e._handleTouchStart=function(e){var t=this.node;return!(!t||!t._uiProps.uiTransformComp||(e.getLocation(Jv),!t._uiProps.uiTransformComp.hitTest(Jv)||(e.type=Kd.TOUCH_START,e.bubbles=!0,t.dispatchEvent(e),0)))},e._handleTouchMove=function(e){var t=this.node;return!(!t||!t._uiProps.uiTransformComp||(e.type=Kd.TOUCH_MOVE,e.bubbles=!0,t.dispatchEvent(e),0))},e._handleTouchEnd=function(e){var t=this.node;t&&t._uiProps.uiTransformComp&&(e.getLocation(Jv),t._uiProps.uiTransformComp.hitTest(Jv)?e.type=Kd.TOUCH_END:e.type=Kd.TOUCH_CANCEL,e.bubbles=!0,t.dispatchEvent(e))},e._handleTouchCancel=function(e){var t=this.node;t&&t._uiProps.uiTransformComp&&(e.type=Kd.TOUCH_CANCEL,e.bubbles=!0,t.dispatchEvent(e))},r(t,[{key:"isEnabled",get:function(){return this._isEnabled}},{key:"node",get:function(){return this._node}}]),t}());zy._maskComp=null,zy.callbacksInvoker=new Ut,s.NodeEventProcessor=zy;var Fy=new wn(0,1,0),Uy=new wn,Gy=new Zn,By=new bn,Hy=new zn,Vy=function(e){var t=1/Math.max(Math.max(Math.max(e.x,e.y),e.z),1e-4);t<1&&(e.x*=t,e.y*=t,e.z*=t)},ky=e("bb",($v=Ga("cc.AmbientInfo"),eg=Xa("_skyColor"),tg=Xa("_skyIllum"),ng=Xa("_groundAlbedo"),ig=ar(),og=sr(),ag=xr(V),rg=sr(),cg=ar(),sg=sr(),$v((vg=function(){function e(){te(this,"_skyColorHDR",_g,this),te(this,"_skyIllumHDR",ug,this),te(this,"_groundAlbedoHDR",mg,this),te(this,"_skyColorLDR",dg,this),te(this,"_skyIllumLDR",pg,this),te(this,"_groundAlbedoLDR",hg,this),this._resource=null}return e.prototype.activate=function(e){this._resource=e,this._resource.initialize(this)},r(e,[{key:"skyColorHDR",get:function(){return this._skyColorHDR}},{key:"groundAlbedoHDR",get:function(){return this._groundAlbedoHDR}},{key:"skyIllumHDR",get:function(){return this._skyIllumHDR}},{key:"skyColorLDR",get:function(){return this._skyColorLDR}},{key:"groundAlbedoLDR",get:function(){return this._groundAlbedoLDR}},{key:"skyIllumLDR",get:function(){return this._skyIllumLDR}},{key:"skyLightingColor",get:function(){var e=s.director.root.pipeline.pipelineSceneData.isHDR;return Gy.set(e?this._skyColorHDR:this._skyColorLDR),Vy(Gy),By.set(255*Gy.x,255*Gy.y,255*Gy.z,255)},set:function(e){Gy.set(e.x,e.y,e.z,e.w),s.director.root.pipeline.pipelineSceneData.isHDR?this._skyColorHDR.set(Gy):this._skyColorLDR.set(Gy),this._resource&&this._resource.skyColor.set(Gy)}},{key:"skyColor",set:function(e){s.director.root.pipeline.pipelineSceneData.isHDR?this._skyColorHDR.set(e):this._skyColorLDR.set(e),this._resource&&this._resource.skyColor.set(e)}},{key:"skyIllum",get:function(){return s.director.root.pipeline.pipelineSceneData.isHDR?this._skyIllumHDR:this._skyIllumLDR},set:function(e){s.director.root.pipeline.pipelineSceneData.isHDR?this._skyIllumHDR=e:this._skyIllumLDR=e,this._resource&&(this._resource.skyIllum=e)}},{key:"groundLightingColor",get:function(){var e=s.director.root.pipeline.pipelineSceneData.isHDR;return Gy.set(e?this._groundAlbedoHDR:this._groundAlbedoLDR),Vy(Gy),By.set(255*Gy.x,255*Gy.y,255*Gy.z,255)},set:function(e){Gy.set(e.x,e.y,e.z,e.w),s.director.root.pipeline.pipelineSceneData.isHDR?this._groundAlbedoHDR.set(Gy):this._groundAlbedoLDR.set(Gy),this._resource&&this._resource.groundAlbedo.set(Gy)}},{key:"groundAlbedo",set:function(e){s.director.root.pipeline.pipelineSceneData.isHDR?this._groundAlbedoHDR.set(e):this._groundAlbedoLDR.set(e),this._resource&&this._resource.groundAlbedo.set(e)}}]),e}(),_g=ee((fg=vg).prototype,"_skyColorHDR",[Ya,eg],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return new Zn(.2,.5,.8,1)}}),ug=ee(fg.prototype,"_skyIllumHDR",[Ya,tg],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return qm.SKY_ILLUM}}),mg=ee(fg.prototype,"_groundAlbedoHDR",[Ya,ng],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return new Zn(.2,.2,.2,1)}}),dg=ee(fg.prototype,"_skyColorLDR",[Ya],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return new Zn(.2,.5,.8,1)}}),pg=ee(fg.prototype,"_skyIllumLDR",[Ya],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return qm.SKY_ILLUM}}),hg=ee(fg.prototype,"_groundAlbedoLDR",[Ya],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return new Zn(.2,.2,.2,1)}}),ee(fg.prototype,"skyLightingColor",[ig,or,og],Object.getOwnPropertyDescriptor(fg.prototype,"skyLightingColor"),fg.prototype),ee(fg.prototype,"skyIllum",[or,ag,rg],Object.getOwnPropertyDescriptor(fg.prototype,"skyIllum"),fg.prototype),ee(fg.prototype,"groundLightingColor",[cg,or,sg],Object.getOwnPropertyDescriptor(fg.prototype,"groundLightingColor"),fg.prototype),lg=fg))||lg));s.AmbientInfo=ky;var jy=e("bc",(gg=Ga("cc.SkyboxInfo"),xg=xr(Ju),yg=Xa("_envmap"),Cg=xr(Ju),Sg=xr(Ju),Eg=xr(Ju),Pg=sr(),Ig=xr(dd),Tg=sr(),bg=sr(),Ag=xr(Ju),wg=sr(),Ng=ar(),Dg=xr(Ju),Rg=mr(),gg((Vg=function(){function e(){te(this,"_envLightingType",Lg,this),te(this,"_envmapHDR",zg,this),te(this,"_envmapLDR",Fg,this),te(this,"_diffuseMapHDR",Ug,this),te(this,"_diffuseMapLDR",Gg,this),te(this,"_enabled",Bg,this),te(this,"_useHDR",Hg,this),this._resource=null}return e.prototype.activate=function(e){this.envLightingType=this._envLightingType,this._resource=e,this._resource.initialize(this),this._resource.setEnvMaps(this._envmapHDR,this._envmapLDR),this._resource.setDiffuseMaps(this._diffuseMapHDR,this._diffuseMapLDR),this._resource.activate()},r(e,[{key:"applyDiffuseMap",get:function(){return dd.DIFFUSEMAP_WITH_REFLECTION===this._envLightingType},set:function(e){this._resource&&(this._resource.useDiffuseMap=e)}},{key:"enabled",get:function(){return this._enabled},set:function(e){this._enabled!==e&&(this._enabled=e,this._resource&&(this._resource.enabled=this._enabled))}},{key:"envLightingType",get:function(){return this._envLightingType},set:function(e){this.envmap||dd.HEMISPHERE_DIFFUSE===e?(dd.HEMISPHERE_DIFFUSE===e?(this.useIBL=!1,this.applyDiffuseMap=!1):dd.AUTOGEN_HEMISPHERE_DIFFUSE_WITH_REFLECTION===e?(this.useIBL=!0,this.applyDiffuseMap=!1):dd.DIFFUSEMAP_WITH_REFLECTION===e&&(this.useIBL=!0,this.applyDiffuseMap=!0),this._envLightingType=e):(this.useIBL=!1,this.applyDiffuseMap=!1,this._envLightingType=dd.HEMISPHERE_DIFFUSE,W(15001))}},{key:"useIBL",get:function(){return dd.HEMISPHERE_DIFFUSE!==this._envLightingType},set:function(e){this._resource&&(this._resource.useIBL=e)}},{key:"useHDR",get:function(){return s.director.root.pipeline.pipelineSceneData.isHDR=this._useHDR,this._useHDR},set:function(e){s.director.root.pipeline.pipelineSceneData.isHDR=e,this._useHDR=e,this._resource&&(this.envmap=this._resource.envmap,this.diffuseMap=this._resource.diffuseMap,this.envLightingType===dd.DIFFUSEMAP_WITH_REFLECTION&&(null===this.diffuseMap?(this.envLightingType=dd.AUTOGEN_HEMISPHERE_DIFFUSE_WITH_REFLECTION,W(15e3)):this.diffuseMap.isDefault&&W(15002))),this._resource&&(this._resource.useHDR=this._useHDR)}},{key:"envmap",get:function(){return s.director.root.pipeline.pipelineSceneData.isHDR?this._envmapHDR:this._envmapLDR},set:function(e){var t=s.director.root.pipeline.pipelineSceneData.isHDR;t?this._envmapHDR=e:this._envmapLDR=e,e||(t?this._diffuseMapHDR=null:this._diffuseMapLDR=null,this.applyDiffuseMap=!1,this.useIBL=!1,this.envLightingType=dd.HEMISPHERE_DIFFUSE,W(15001)),this._resource&&(this._resource.setEnvMaps(this._envmapHDR,this._envmapLDR),this._resource.setDiffuseMaps(this._diffuseMapHDR,this._diffuseMapLDR),this._resource.useDiffuseMap=this.applyDiffuseMap,this._resource.envmap=e)}},{key:"diffuseMap",get:function(){return s.director.root.pipeline.pipelineSceneData.isHDR?this._diffuseMapHDR:this._diffuseMapLDR},set:function(e){s.director.root.pipeline.pipelineSceneData.isHDR?this._diffuseMapHDR=e:this._diffuseMapLDR=e,this._resource&&this._resource.setDiffuseMaps(this._diffuseMapHDR,this._diffuseMapLDR)}}]),e}(),Lg=ee((Og=Vg).prototype,"_envLightingType",[Ya],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return dd.HEMISPHERE_DIFFUSE}}),zg=ee(Og.prototype,"_envmapHDR",[Ya,xg,yg],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return null}}),Fg=ee(Og.prototype,"_envmapLDR",[Ya,Cg],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return null}}),Ug=ee(Og.prototype,"_diffuseMapHDR",[Ya,Sg],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return null}}),Gg=ee(Og.prototype,"_diffuseMapLDR",[Ya,Eg],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return null}}),Bg=ee(Og.prototype,"_enabled",[Ya],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return!1}}),Hg=ee(Og.prototype,"_useHDR",[Ya],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return!0}}),ee(Og.prototype,"enabled",[or,Pg],Object.getOwnPropertyDescriptor(Og.prototype,"enabled"),Og.prototype),ee(Og.prototype,"envLightingType",[or,Ig,Tg],Object.getOwnPropertyDescriptor(Og.prototype,"envLightingType"),Og.prototype),ee(Og.prototype,"useHDR",[or,bg],Object.getOwnPropertyDescriptor(Og.prototype,"useHDR"),Og.prototype),ee(Og.prototype,"envmap",[or,Ag,wg],Object.getOwnPropertyDescriptor(Og.prototype,"envmap"),Og.prototype),ee(Og.prototype,"diffuseMap",[Ng,or,rr,Dg,Rg],Object.getOwnPropertyDescriptor(Og.prototype,"diffuseMap"),Og.prototype),Mg=Og))||Mg));s.SkyboxInfo=jy;var qy=e("bd",(kg=Ga("cc.FogInfo"),jg=sr(),qg=mr(),Wg=sr(),Yg=mr(),Xg=sr(),Kg=xr(Pd),Jg=mr(),Qg=sr(),Zg=ar(),$g=xr(V),ex=lr(),tx=_r(),nx=sr(),ix=ar(),ox=xr(V),ax=_r(),rx=sr(),cx=ar(),sx=xr(V),lx=_r(),fx=sr(),_x=ar(),ux=xr(V),mx=fr(),dx=_r(),px=sr(),hx=ar(),vx=xr(V),gx=_r(),xx=sr(),yx=ar(),Cx=xr(V),Sx=_r(),Ex=sr(),kg((Fx=zx=function(){function e(){te(this,"_type",Tx,this),te(this,"_fogColor",bx,this),te(this,"_enabled",Ax,this),te(this,"_fogDensity",wx,this),te(this,"_fogStart",Nx,this),te(this,"_fogEnd",Dx,this),te(this,"_fogAtten",Rx,this),te(this,"_fogTop",Mx,this),te(this,"_fogRange",Ox,this),te(this,"_accurate",Lx,this),this._resource=null}return e.prototype.activate=function(e){this._resource=e,this._resource.initialize(this),this._resource.activate()},r(e,[{key:"enabled",get:function(){return this._enabled},set:function(e){this._enabled!==e&&(this._enabled=e,this._resource&&(this._resource.enabled=e,e&&(this._resource.type=this._type)))}},{key:"accurate",get:function(){return this._accurate},set:function(e){this._accurate!==e&&(this._accurate=e,this._resource&&(this._resource.accurate=e,e&&(this._resource.type=this._type)))}},{key:"fogColor",get:function(){return this._fogColor},set:function(e){this._fogColor.set(e),this._resource&&(this._resource.fogColor=this._fogColor)}},{key:"type",get:function(){return this._type},set:function(e){this._type=e,this._resource&&(this._resource.type=e)}},{key:"fogDensity",get:function(){return this._fogDensity},set:function(e){this._fogDensity=e,this._resource&&(this._resource.fogDensity=e)}},{key:"fogStart",get:function(){return this._fogStart},set:function(e){this._fogStart=e,this._resource&&(this._resource.fogStart=e)}},{key:"fogEnd",get:function(){return this._fogEnd},set:function(e){this._fogEnd=e,this._resource&&(this._resource.fogEnd=e)}},{key:"fogAtten",get:function(){return this._fogAtten},set:function(e){this._fogAtten=e,this._resource&&(this._resource.fogAtten=e)}},{key:"fogTop",get:function(){return this._fogTop},set:function(e){this._fogTop=e,this._resource&&(this._resource.fogTop=e)}},{key:"fogRange",get:function(){return this._fogRange},set:function(e){this._fogRange=e,this._resource&&(this._resource.fogRange=e)}}]),e}(),zx.FogType=Pd,Tx=ee((Ix=Fx).prototype,"_type",[Ya],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return Pd.LINEAR}}),bx=ee(Ix.prototype,"_fogColor",[Ya],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return new bn("#C8C8C8")}}),Ax=ee(Ix.prototype,"_enabled",[Ya],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return!1}}),wx=ee(Ix.prototype,"_fogDensity",[Ya],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return.3}}),Nx=ee(Ix.prototype,"_fogStart",[Ya],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return.5}}),Dx=ee(Ix.prototype,"_fogEnd",[Ya],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return 300}}),Rx=ee(Ix.prototype,"_fogAtten",[Ya],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return 5}}),Mx=ee(Ix.prototype,"_fogTop",[Ya],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return 1.5}}),Ox=ee(Ix.prototype,"_fogRange",[Ya],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return 1.2}}),Lx=ee(Ix.prototype,"_accurate",[Ya],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return!1}}),ee(Ix.prototype,"enabled",[or,jg,qg],Object.getOwnPropertyDescriptor(Ix.prototype,"enabled"),Ix.prototype),ee(Ix.prototype,"accurate",[or,Wg,Yg],Object.getOwnPropertyDescriptor(Ix.prototype,"accurate"),Ix.prototype),ee(Ix.prototype,"fogColor",[or,Xg],Object.getOwnPropertyDescriptor(Ix.prototype,"fogColor"),Ix.prototype),ee(Ix.prototype,"type",[or,Kg,Jg,Qg],Object.getOwnPropertyDescriptor(Ix.prototype,"type"),Ix.prototype),ee(Ix.prototype,"fogDensity",[Zg,$g,ex,tx,ur,nx],Object.getOwnPropertyDescriptor(Ix.prototype,"fogDensity"),Ix.prototype),ee(Ix.prototype,"fogStart",[ix,ox,ax,rx],Object.getOwnPropertyDescriptor(Ix.prototype,"fogStart"),Ix.prototype),ee(Ix.prototype,"fogEnd",[cx,sx,lx,fx],Object.getOwnPropertyDescriptor(Ix.prototype,"fogEnd"),Ix.prototype),ee(Ix.prototype,"fogAtten",[_x,ux,mx,dx,px],Object.getOwnPropertyDescriptor(Ix.prototype,"fogAtten"),Ix.prototype),ee(Ix.prototype,"fogTop",[hx,vx,gx,xx],Object.getOwnPropertyDescriptor(Ix.prototype,"fogTop"),Ix.prototype),ee(Ix.prototype,"fogRange",[yx,Cx,Sx,Ex],Object.getOwnPropertyDescriptor(Ix.prototype,"fogRange"),Ix.prototype),Px=Ix))||Px)),Wy=e("be",(Ux=Ga("cc.ShadowsInfo"),Gx=sr(),Bx=xr(vd),Hx=ar(),Vx=ar(),kx=sr(),jx=xr(V),qx=ar(),Wx=sr(),Yx=xr(q),Xx=sr(),Kx=ar(),Jx=xr(hd),Qx=sr(),Zx=ar(),Ux((sy=function(){function e(){te(this,"_enabled",ty,this),te(this,"_type",ny,this),te(this,"_normal",iy,this),te(this,"_distance",oy,this),te(this,"_shadowColor",ay,this),te(this,"_maxReceived",ry,this),te(this,"_size",cy,this),this._resource=null}var t=e.prototype;return t.setPlaneFromNode=function(e){e.getWorldRotation(Hy),this.planeDirection=wn.transformQuat(Uy,Fy,Hy),e.getWorldPosition(Uy),this.planeHeight=wn.dot(this._normal,Uy)},t.activate=function(e){this._resource=e,this._resource.initialize(this),this._resource.activate()},r(e,[{key:"enabled",get:function(){return this._enabled},set:function(e){this._enabled!==e&&(this._enabled=e,this._resource&&(this._resource.enabled=e,e&&(this._resource.type=this._type)))}},{key:"type",get:function(){return this._type},set:function(e){this._type=e,this._resource&&(this._resource.type=e)}},{key:"shadowColor",get:function(){return this._shadowColor},set:function(e){this._shadowColor.set(e),this._resource&&(this._resource.shadowColor=e)}},{key:"planeDirection",get:function(){return this._normal},set:function(e){wn.copy(this._normal,e),this._resource&&(this._resource.normal=e)}},{key:"planeHeight",get:function(){return this._distance},set:function(e){this._distance=e,this._resource&&(this._resource.distance=-e)}},{key:"maxReceived",get:function(){return this._maxReceived},set:function(e){this._maxReceived=e,this._resource&&(this._resource.maxReceived=e)}},{key:"shadowMapSize",get:function(){return this._size.x},set:function(e){this._size.set(e,e),this._resource&&(this._resource.size.set(e,e),this._resource.shadowMapDirty=!0)}},{key:"size",get:function(){return this._size}}]),e}(),ty=ee((ey=sy).prototype,"_enabled",[Ya],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return!1}}),ny=ee(ey.prototype,"_type",[Ya],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return vd.Planar}}),iy=ee(ey.prototype,"_normal",[Ya],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return new wn(0,1,0)}}),oy=ee(ey.prototype,"_distance",[Ya],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return 0}}),ay=ee(ey.prototype,"_shadowColor",[Ya],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return new bn(0,0,0,76)}}),ry=ee(ey.prototype,"_maxReceived",[Ya],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return 4}}),cy=ee(ey.prototype,"_size",[Ya],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return new Xn(512,512)}}),ee(ey.prototype,"enabled",[or,Gx],Object.getOwnPropertyDescriptor(ey.prototype,"enabled"),ey.prototype),ee(ey.prototype,"type",[or,Bx],Object.getOwnPropertyDescriptor(ey.prototype,"type"),ey.prototype),ee(ey.prototype,"shadowColor",[Hx],Object.getOwnPropertyDescriptor(ey.prototype,"shadowColor"),ey.prototype),ee(ey.prototype,"planeDirection",[Vx,kx],Object.getOwnPropertyDescriptor(ey.prototype,"planeDirection"),ey.prototype),ee(ey.prototype,"planeHeight",[or,jx,qx,Wx],Object.getOwnPropertyDescriptor(ey.prototype,"planeHeight"),ey.prototype),ee(ey.prototype,"maxReceived",[Yx,Xx,Kx],Object.getOwnPropertyDescriptor(ey.prototype,"maxReceived"),ey.prototype),ee(ey.prototype,"shadowMapSize",[Jx,Qx,Zx],Object.getOwnPropertyDescriptor(ey.prototype,"shadowMapSize"),ey.prototype),$x=ey))||$x));s.ShadowsInfo=Wy;var Yy=e("bf",new wn(-1024,-1024,-1024)),Xy=e("bg",new wn(1024,1024,1024)),Ky=e("bh",8),Jy=e("bi",(ly=Ga("cc.OctreeInfo"),fy=sr(),_y=sr(),uy=cr(),dy=sr(),py=cr(),hy=lr(),vy=xr(q),gy=sr(),ly((Iy=function(){function e(){te(this,"_enabled",Cy,this),te(this,"_minPos",Sy,this),te(this,"_maxPos",Ey,this),te(this,"_depth",Py,this),this._resource=null}return e.prototype.activate=function(e){this._resource=e,this._resource.initialize(this)},r(e,[{key:"enabled",get:function(){return this._enabled},set:function(e){this._enabled!==e&&(this._enabled=e,this._resource&&(this._resource.enabled=e))}},{key:"minPos",get:function(){return this._minPos},set:function(e){this._minPos=e,this._resource&&(this._resource.minPos=e)}},{key:"maxPos",get:function(){return this._maxPos},set:function(e){this._maxPos=e,this._resource&&(this._resource.maxPos=e)}},{key:"depth",get:function(){return this._depth},set:function(e){this._depth=e,this._resource&&(this._resource.depth=e)}}]),e}(),Cy=ee((yy=Iy).prototype,"_enabled",[Ya],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return!1}}),Sy=ee(yy.prototype,"_minPos",[Ya],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return new wn(Yy)}}),Ey=ee(yy.prototype,"_maxPos",[Ya],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return new wn(Xy)}}),Py=ee(yy.prototype,"_depth",[Ya],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return Ky}}),ee(yy.prototype,"enabled",[or,fy],Object.getOwnPropertyDescriptor(yy.prototype,"enabled"),yy.prototype),ee(yy.prototype,"minPos",[or,_y,uy],Object.getOwnPropertyDescriptor(yy.prototype,"minPos"),yy.prototype),ee(yy.prototype,"maxPos",[or,dy,py],Object.getOwnPropertyDescriptor(yy.prototype,"maxPos"),yy.prototype),ee(yy.prototype,"depth",[or,hy,ur,vy,gy],Object.getOwnPropertyDescriptor(yy.prototype,"depth"),yy.prototype),xy=yy))||xy)),Qy=e("bj",(Ty=Ga("cc.SceneGlobals"),by=xr(jy),Ty((Ly=function(){function e(){te(this,"ambient",Ny,this),te(this,"shadows",Dy,this),te(this,"_skybox",Ry,this),te(this,"fog",My,this),te(this,"octree",Oy,this)}return e.prototype.activate=function(){var e=s.director.root.pipeline.pipelineSceneData;this.skybox.activate(e.skybox),this.ambient.activate(e.ambient),this.shadows.activate(e.shadows),this.fog.activate(e.fog),this.octree.activate(e.octree)},r(e,[{key:"skybox",get:function(){return this._skybox},set:function(e){this._skybox=e}}]),e}(),Ny=ee((wy=Ly).prototype,"ambient",[Ya,or],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return new ky}}),Dy=ee(wy.prototype,"shadows",[Ya,or],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return new Wy}}),Ry=ee(wy.prototype,"_skybox",[Ya],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return new jy}}),My=ee(wy.prototype,"fog",[or,Ya],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return new qy}}),ee(wy.prototype,"skybox",[or,by],Object.getOwnPropertyDescriptor(wy.prototype,"skybox"),wy.prototype),Oy=ee(wy.prototype,"octree",[or,Ya],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return new Jy}}),Ay=wy))||Ay));s.SceneGlobals=Qy;var Zy=e("bx",function(){function e(e,t){this.type=void 0,this.bubbles=void 0,this.target=null,this.currentTarget=null,this.eventPhase=0,this.propagationStopped=!1,this.propagationImmediateStopped=!1,this.type=e,this.bubbles=!!t}var t=e.prototype;return t.unuse=function(){this.type=e.NO_TYPE,this.target=null,this.currentTarget=null,this.eventPhase=e.NONE,this.propagationStopped=!1,this.propagationImmediateStopped=!1},t.reuse=function(e,t){this.type=e,this.bubbles=t||!1},t.isStopped=function(){return this.propagationStopped||this.propagationImmediateStopped},t.getCurrentTarget=function(){return this.currentTarget},t.getType=function(){return this.type},e}());Zy.NO_TYPE="no_type",Zy.TOUCH="touch",Zy.MOUSE="mouse",Zy.KEYBOARD="keyboard",Zy.ACCELERATION="acceleration",Zy.NONE=0,Zy.CAPTURING_PHASE=1,Zy.AT_TARGET=2,Zy.BUBBLING_PHASE=3,s.Event=Zy;var $y=e("by",function(e){function t(t,n){var i;return(i=e.call(this,Vv.DEVICEMOTION,n)||this).acc=void 0,i.acc=t,i}return a(t,e),t}(Zy));Zy.EventAcceleration=$y;var eC=e("bz",function(e){function t(t,n,i){var o;return"boolean"==typeof n&&(n=n?Vv.KEY_DOWN:Vv.KEY_UP),(o=e.call(this,n,i)||this).keyCode=void 0,o.rawEvent=void 0,o._isPressed=void 0,o._isPressed=n!==Vv.KEY_UP,"number"==typeof t?o.keyCode=t:(o.keyCode=t.keyCode,o.rawEvent=t),o}return a(t,e),r(t,[{key:"isPressed",get:function(){return this._isPressed}}]),t}(Zy));Zy.EventKeyboard=eC;var tC=e("bA",function(e){function t(n,i,o){var a;return(a=e.call(this,n,i)||this).movementX=0,a.movementY=0,a.preventSwallow=!1,a._eventType=void 0,a._button=t.BUTTON_MISSING,a._x=0,a._y=0,a._prevX=0,a._prevY=0,a._scrollX=0,a._scrollY=0,a._eventType=n,o&&(a._prevX=o.x,a._prevY=o.y),a}a(t,e);var n=t.prototype;return n.setScrollData=function(e,t){this._scrollX=e,this._scrollY=t},n.getScrollX=function(){return this._scrollX},n.getScrollY=function(){return this._scrollY},n.setLocation=function(e,t){this._x=e,this._y=t},n.getLocation=function(e){return e||(e=new Xn),Xn.set(e,this._x,this._y),e},n.getLocationInView=function(e){return e||(e=new Xn),Xn.set(e,this._x,s.view._designResolutionSize.height-this._y),e},n.getUILocation=function(e){return e||(e=new Xn),Xn.set(e,this._x,this._y),s.view._convertToUISpace(e),e},n.getPreviousLocation=function(e){return e||(e=new Xn),Xn.set(e,this._prevX,this._prevY),e},n.getUIPreviousLocation=function(e){return e||(e=new Xn),Xn.set(e,this._prevX,this._prevY),s.view._convertToUISpace(e),e},n.getDelta=function(e){return e||(e=new Xn),Xn.set(e,this._x-this._prevX,this._y-this._prevY),e},n.getDeltaX=function(){return this._x-this._prevX},n.getDeltaY=function(){return this._y-this._prevY},n.getUIDelta=function(e){return e||(e=new Xn),Xn.set(e,(this._x-this._prevX)/s.view.getScaleX(),(this._y-this._prevY)/s.view.getScaleY()),e},n.getUIDeltaX=function(){return(this._x-this._prevX)/s.view.getScaleX()},n.getUIDeltaY=function(){return(this._y-this._prevY)/s.view.getScaleY()},n.setButton=function(e){this._button=e},n.getButton=function(){return this._button},n.getLocationX=function(){return this._x},n.getLocationY=function(){return this._y},n.getUILocationX=function(){var e=s.view.getViewportRect();return(this._x-e.x)/s.view.getScaleX()},n.getUILocationY=function(){var e=s.view.getViewportRect();return(this._y-e.y)/s.view.getScaleY()},r(t,[{key:"eventType",get:function(){return this._eventType}}]),t}(Zy));tC.BUTTON_MISSING=-1,tC.BUTTON_LEFT=0,tC.BUTTON_RIGHT=2,tC.BUTTON_MIDDLE=1,tC.BUTTON_4=3,tC.BUTTON_5=4,tC.BUTTON_6=5,tC.BUTTON_7=6,tC.BUTTON_8=7,Zy.EventMouse=tC;var nC=new Xn,iC=e("bB",function(e){function t(t,n,i,o){var a;return void 0===o&&(o=[]),(a=e.call(this,i,n)||this).touch=null,a.simulate=!1,a.preventSwallow=!1,a._eventCode=void 0,a._touches=void 0,a._allTouches=void 0,a._eventCode=i,a._touches=t||[],a._allTouches=o,a}a(t,e);var n=t.prototype;return n.getEventCode=function(){return this._eventCode},n.getTouches=function(){return this._touches},n.getAllTouches=function(){return this._allTouches},n.setLocation=function(e,t){this.touch&&this.touch.setTouchInfo(this.touch.getID(),e,t)},n.getLocation=function(e){return this.touch?this.touch.getLocation(e):new Xn},n.getUILocation=function(e){return this.touch?this.touch.getUILocation(e):new Xn},n.getLocationInView=function(e){return this.touch?this.touch.getLocationInView(e):new Xn},n.getPreviousLocation=function(e){return this.touch?this.touch.getPreviousLocation(e):new Xn},n.getStartLocation=function(e){return this.touch?this.touch.getStartLocation(e):new Xn},n.getUIStartLocation=function(e){return this.touch?this.touch.getUIStartLocation(e):new Xn},n.getID=function(){return this.touch?this.touch.getID():null},n.getDelta=function(e){return this.touch?this.touch.getDelta(e):new Xn},n.getUIDelta=function(e){return this.touch?this.touch.getUIDelta(e):new Xn},n.getDeltaX=function(){return this.touch?this.touch.getDelta(nC).x:0},n.getDeltaY=function(){return this.touch?this.touch.getDelta(nC).y:0},n.getLocationX=function(){return this.touch?this.touch.getLocationX():0},n.getLocationY=function(){return this.touch?this.touch.getLocationY():0},t}(Zy));iC.MAX_TOUCHES=5,Zy.EventTouch=iC;var oC,aC=e("bC",(function(e,t,n,i){void 0===e&&(e=0),void 0===t&&(t=0),void 0===n&&(n=0),void 0===i&&(i=0),this.x=void 0,this.y=void 0,this.z=void 0,this.timestamp=void 0,this.x=e,this.y=t,this.z=n,this.timestamp=i}));!function(e){e[e.NONE=0]="NONE",e[e.MOBILE_BACK=6]="MOBILE_BACK",e[e.BACKSPACE=8]="BACKSPACE",e[e.TAB=9]="TAB",e[e.ENTER=13]="ENTER",e[e.SHIFT_LEFT=16]="SHIFT_LEFT",e[e.CTRL_LEFT=17]="CTRL_LEFT",e[e.ALT_LEFT=18]="ALT_LEFT",e[e.PAUSE=19]="PAUSE",e[e.CAPS_LOCK=20]="CAPS_LOCK",e[e.ESCAPE=27]="ESCAPE",e[e.SPACE=32]="SPACE",e[e.PAGE_UP=33]="PAGE_UP",e[e.PAGE_DOWN=34]="PAGE_DOWN",e[e.END=35]="END",e[e.HOME=36]="HOME",e[e.ARROW_LEFT=37]="ARROW_LEFT",e[e.ARROW_UP=38]="ARROW_UP",e[e.ARROW_RIGHT=39]="ARROW_RIGHT",e[e.ARROW_DOWN=40]="ARROW_DOWN",e[e.INSERT=45]="INSERT",e[e.DELETE=46]="DELETE",e[e.DIGIT_0=48]="DIGIT_0",e[e.DIGIT_1=49]="DIGIT_1",e[e.DIGIT_2=50]="DIGIT_2",e[e.DIGIT_3=51]="DIGIT_3",e[e.DIGIT_4=52]="DIGIT_4",e[e.DIGIT_5=53]="DIGIT_5",e[e.DIGIT_6=54]="DIGIT_6",e[e.DIGIT_7=55]="DIGIT_7",e[e.DIGIT_8=56]="DIGIT_8",e[e.DIGIT_9=57]="DIGIT_9",e[e.KEY_A=65]="KEY_A",e[e.KEY_B=66]="KEY_B",e[e.KEY_C=67]="KEY_C",e[e.KEY_D=68]="KEY_D",e[e.KEY_E=69]="KEY_E",e[e.KEY_F=70]="KEY_F",e[e.KEY_G=71]="KEY_G",e[e.KEY_H=72]="KEY_H",e[e.KEY_I=73]="KEY_I",e[e.KEY_J=74]="KEY_J",e[e.KEY_K=75]="KEY_K",e[e.KEY_L=76]="KEY_L",e[e.KEY_M=77]="KEY_M",e[e.KEY_N=78]="KEY_N",e[e.KEY_O=79]="KEY_O",e[e.KEY_P=80]="KEY_P",e[e.KEY_Q=81]="KEY_Q",e[e.KEY_R=82]="KEY_R",e[e.KEY_S=83]="KEY_S",e[e.KEY_T=84]="KEY_T",e[e.KEY_U=85]="KEY_U",e[e.KEY_V=86]="KEY_V",e[e.KEY_W=87]="KEY_W",e[e.KEY_X=88]="KEY_X",e[e.KEY_Y=89]="KEY_Y",e[e.KEY_Z=90]="KEY_Z",e[e.NUM_0=96]="NUM_0",e[e.NUM_1=97]="NUM_1",e[e.NUM_2=98]="NUM_2",e[e.NUM_3=99]="NUM_3",e[e.NUM_4=100]="NUM_4",e[e.NUM_5=101]="NUM_5",e[e.NUM_6=102]="NUM_6",e[e.NUM_7=103]="NUM_7",e[e.NUM_8=104]="NUM_8",e[e.NUM_9=105]="NUM_9",e[e.NUM_MULTIPLY=106]="NUM_MULTIPLY",e[e.NUM_PLUS=107]="NUM_PLUS",e[e.NUM_SUBTRACT=109]="NUM_SUBTRACT",e[e.NUM_DECIMAL=110]="NUM_DECIMAL",e[e.NUM_DIVIDE=111]="NUM_DIVIDE",e[e.F1=112]="F1",e[e.F2=113]="F2",e[e.F3=114]="F3",e[e.F4=115]="F4",e[e.F5=116]="F5",e[e.F6=117]="F6",e[e.F7=118]="F7",e[e.F8=119]="F8",e[e.F9=120]="F9",e[e.F10=121]="F10",e[e.F11=122]="F11",e[e.F12=123]="F12",e[e.NUM_LOCK=144]="NUM_LOCK",e[e.SCROLL_LOCK=145]="SCROLL_LOCK",e[e.SEMICOLON=186]="SEMICOLON",e[e.EQUAL=187]="EQUAL",e[e.COMMA=188]="COMMA",e[e.DASH=189]="DASH",e[e.PERIOD=190]="PERIOD",e[e.SLASH=191]="SLASH",e[e.BACK_QUOTE=192]="BACK_QUOTE",e[e.BRACKET_LEFT=219]="BRACKET_LEFT",e[e.BACKSLASH=220]="BACKSLASH",e[e.BRACKET_RIGHT=221]="BRACKET_RIGHT",e[e.QUOTE=222]="QUOTE",e[e.SHIFT_RIGHT=2e3]="SHIFT_RIGHT",e[e.CTRL_RIGHT=2001]="CTRL_RIGHT",e[e.ALT_RIGHT=2002]="ALT_RIGHT",e[e.NUM_ENTER=2003]="NUM_ENTER"}(oC||(oC=e("bD",{})));var rC=new Xn,cC=e("bE",function(){function e(e,t,n){void 0===n&&(n=0),this._point=new Xn,this._prevPoint=new Xn,this._lastModified=0,this._id=0,this._startPoint=new Xn,this._startPointCaptured=!1,this.setTouchInfo(n,e,t)}var t=e.prototype;return t.getLocation=function(e){return e||(e=new Xn),e.set(this._point.x,this._point.y),e},t.getLocationX=function(){return this._point.x},t.getLocationY=function(){return this._point.y},t.getUILocation=function(e){return e||(e=new Xn),e.set(this._point.x,this._point.y),s.view._convertToUISpace(e),e},t.getUILocationX=function(){var e=s.view.getViewportRect();return(this._point.x-e.x)/s.view.getScaleX()},t.getUILocationY=function(){var e=s.view.getViewportRect();return(this._point.y-e.y)/s.view.getScaleY()},t.getPreviousLocation=function(e){return e||(e=new Xn),e.set(this._prevPoint.x,this._prevPoint.y),e},t.getUIPreviousLocation=function(e){return e||(e=new Xn),e.set(this._prevPoint.x,this._prevPoint.y),s.view._convertToUISpace(e),e},t.getStartLocation=function(e){return e||(e=new Xn),e.set(this._startPoint.x,this._startPoint.y),e},t.getUIStartLocation=function(e){return e||(e=new Xn),e.set(this._startPoint.x,this._startPoint.y),s.view._convertToUISpace(e),e},t.getDelta=function(e){return e||(e=new Xn),e.set(this._point),e.subtract(this._prevPoint),e},t.getUIDelta=function(e){return e||(e=new Xn),rC.set(this._point),rC.subtract(this._prevPoint),e.set(s.view.getScaleX(),s.view.getScaleY()),Xn.divide(e,rC,e),e},t.getLocationInView=function(e){return e||(e=new Xn),e.set(this._point.x,s.view._designResolutionSize.height-this._point.y),e},t.getPreviousLocationInView=function(e){return e||(e=new Xn),e.set(this._prevPoint.x,s.view._designResolutionSize.height-this._prevPoint.y),e},t.getStartLocationInView=function(e){return e||(e=new Xn),e.set(this._startPoint.x,s.view._designResolutionSize.height-this._startPoint.y),e},t.getID=function(){return this._id},t.setTouchInfo=function(e,t,n){void 0===e&&(e=0),this._prevPoint=this._point,this._point=new Xn(t||0,n||0),this._id=e,this._startPointCaptured||(this._startPoint=new Xn(this._point),this._startPointCaptured=!0)},t.setPoint=function(e,t){"object"==typeof e?(this._point.x=e.x,this._point.y=e.y):(this._point.x=e||0,this._point.y=t||0),this._lastModified=s.game.frameStartTime},t.setPrevPoint=function(e,t){this._prevPoint="object"==typeof e?new Xn(e.x,e.y):new Xn(e||0,t||0),this._lastModified=s.game.frameStartTime},r(e,[{key:"lastModified",get:function(){return this._lastModified}}]),e}());s.Touch=cC;var sC=function(){function e(){this._isStarted=!1,this._accelMode="normal",this._eventTarget=new fe,this._didAccelerateFunc=void 0,this._didAccelerateFunc=this._didAccelerate.bind(this)}var t=e.prototype;return t._registerEvent=function(){se.onAccelerometerChange(this._didAccelerateFunc)},t._unregisterEvent=function(){se.offAccelerometerChange(this._didAccelerateFunc)},t._didAccelerate=function(e){var t=performance.now(),n=new aC(e.x,e.y,e.z,t),i=new $y(n);this._eventTarget.emit(kv.DEVICEMOTION,i)},t.start=function(){var e=this;this._registerEvent(),se.startAccelerometer({interval:this._accelMode,success:function(){e._isStarted=!0}})},t.stop=function(){var e=this;se.stopAccelerometer({success:function(){e._isStarted=!1},fail:function(){console.error("failed to stop accelerometer")}}),this._unregisterEvent()},t.setInterval=function(e){this._accelMode=e>=200?"normal":e>=60?"ui":"game",this._isStarted&&(this.stop(),this.start())},t.on=function(e,t,n){this._eventTarget.on(e,t,n)},e}(),lC={Backspace:oC.BACKSPACE,Tab:oC.TAB,Enter:oC.ENTER,ShiftLeft:oC.SHIFT_LEFT,ControlLeft:oC.CTRL_LEFT,AltLeft:oC.ALT_LEFT,ShiftRight:oC.SHIFT_RIGHT,ControlRight:oC.CTRL_RIGHT,AltRight:oC.ALT_RIGHT,Pause:oC.PAUSE,CapsLock:oC.CAPS_LOCK,Escape:oC.ESCAPE,Space:oC.SPACE,PageUp:oC.PAGE_UP,PageDown:oC.PAGE_DOWN,End:oC.END,Home:oC.HOME,ArrowLeft:oC.ARROW_LEFT,ArrowUp:oC.ARROW_UP,ArrowRight:oC.ARROW_RIGHT,ArrowDown:oC.ARROW_DOWN,Insert:oC.INSERT,Delete:oC.DELETE,Digit0:oC.DIGIT_0,Digit1:oC.DIGIT_1,Digit2:oC.DIGIT_2,Digit3:oC.DIGIT_3,Digit4:oC.DIGIT_4,Digit5:oC.DIGIT_5,Digit6:oC.DIGIT_6,Digit7:oC.DIGIT_7,Digit8:oC.DIGIT_8,Digit9:oC.DIGIT_9,KeyA:oC.KEY_A,KeyB:oC.KEY_B,KeyC:oC.KEY_C,KeyD:oC.KEY_D,KeyE:oC.KEY_E,KeyF:oC.KEY_F,KeyG:oC.KEY_G,KeyH:oC.KEY_H,KeyI:oC.KEY_I,KeyJ:oC.KEY_J,KeyK:oC.KEY_K,KeyL:oC.KEY_L,KeyM:oC.KEY_M,KeyN:oC.KEY_N,KeyO:oC.KEY_O,KeyP:oC.KEY_P,KeyQ:oC.KEY_Q,KeyR:oC.KEY_R,KeyS:oC.KEY_S,KeyT:oC.KEY_T,KeyU:oC.KEY_U,KeyV:oC.KEY_V,KeyW:oC.KEY_W,KeyX:oC.KEY_X,KeyY:oC.KEY_Y,KeyZ:oC.KEY_Z,Numpad0:oC.NUM_0,Numpad1:oC.NUM_1,Numpad2:oC.NUM_2,Numpad3:oC.NUM_3,Numpad4:oC.NUM_4,Numpad5:oC.NUM_5,Numpad6:oC.NUM_6,Numpad7:oC.NUM_7,Numpad8:oC.NUM_8,Numpad9:oC.NUM_9,NumpadMultiply:oC.NUM_MULTIPLY,NumpadAdd:oC.NUM_PLUS,NumpadSubtract:oC.NUM_SUBTRACT,NumpadDecimal:oC.NUM_DECIMAL,NumpadDivide:oC.NUM_DIVIDE,NumpadEnter:oC.NUM_ENTER,F1:oC.F1,F2:oC.F2,F3:oC.F3,F4:oC.F4,F5:oC.F5,F6:oC.F6,F7:oC.F7,F8:oC.F8,F9:oC.F9,F10:oC.F10,F11:oC.F11,F12:oC.F12,NumLock:oC.NUM_LOCK,ScrollLock:oC.SCROLL_LOCK,Semicolon:oC.SEMICOLON,Equal:oC.EQUAL,Comma:oC.COMMA,Minus:oC.DASH,Period:oC.PERIOD,Slash:oC.SLASH,Backquote:oC.BACK_QUOTE,BracketLeft:oC.BRACKET_LEFT,Backslash:oC.BACKSLASH,BracketRight:oC.BRACKET_RIGHT,Quote:oC.QUOTE};function fC(e){return lC[e]||oC.NONE}var _C,uC,mC=function(){function e(){this._eventTarget=new fe,this._keyStateMap={},t.hasFeature(_e.EVENT_KEYBOARD)&&this._registerEvent()}var n=e.prototype;return n._registerEvent=function(){var e,t,n,i,o=this;null===(e=se.wx)||void 0===e||null===(t=e.onKeyDown)||void 0===t||t.call(e,(function(e){var t=fC(e.code);if(o._keyStateMap[t]){var n=o._getInputEvent(e,kv.KEY_PRESSING);o._eventTarget.emit(kv.KEY_PRESSING,n)}else{var i=o._getInputEvent(e,kv.KEY_DOWN);o._eventTarget.emit(kv.KEY_DOWN,i)}o._keyStateMap[t]=!0})),null===(n=se.wx)||void 0===n||null===(i=n.onKeyUp)||void 0===i||i.call(n,(function(e){var t=fC(e.code),n=o._getInputEvent(e,kv.KEY_UP);o._keyStateMap[t]=!1,o._eventTarget.emit(kv.KEY_UP,n)}))},n._getInputEvent=function(e,t){var n=fC(e.code);return new eC(n,t)},n.on=function(e,t,n){this._eventTarget.on(e,t,n)},e}(),dC=function(){function e(){this._eventTarget=new fe,this._isPressed=!1,this._preMousePos=new Xn,t.hasFeature(_e.EVENT_MOUSE)&&this._registerEvent()}var n=e.prototype;return n._getLocation=function(e){var t=bc.windowSize,n=bc.devicePixelRatio,i=e.x*n,o=t.height-e.y*n;return new Xn(i,o)},n._registerEvent=function(){var e,t,n,i,o,a,r,c;null===(e=se.wx)||void 0===e||null===(t=e.onMouseDown)||void 0===t||t.call(e,this._createCallback(kv.MOUSE_DOWN)),null===(n=se.wx)||void 0===n||null===(i=n.onMouseMove)||void 0===i||i.call(n,this._createCallback(kv.MOUSE_MOVE)),null===(o=se.wx)||void 0===o||null===(a=o.onMouseUp)||void 0===a||a.call(o,this._createCallback(kv.MOUSE_UP)),null===(r=se.wx)||void 0===r||null===(c=r.onWheel)||void 0===c||c.call(r,this._handleMouseWheel.bind(this))},n._createCallback=function(e){var t=this;return function(n){var i=t._getLocation(n),o=n.button;switch(e){case kv.MOUSE_DOWN:t._isPressed=!0;break;case kv.MOUSE_UP:t._isPressed=!1;break;case kv.MOUSE_MOVE:t._isPressed||(o=tC.BUTTON_MISSING)}var a=new tC(e,!1,t._preMousePos);a.setLocation(i.x,i.y),a.setButton(o),a.movementX=i.x-t._preMousePos.x,a.movementY=t._preMousePos.y-i.y,t._preMousePos.set(i.x,i.y),t._eventTarget.emit(e,a)}},n._handleMouseWheel=function(e){var t=kv.MOUSE_WHEEL,n=this._getLocation(e),i=e.button,o=new tC(t,!1,this._preMousePos);o.setLocation(n.x,n.y),o.setButton(i),o.movementX=n.x-this._preMousePos.x,o.movementY=this._preMousePos.y-n.y,o.setScrollData(e.deltaX,e.deltaY),this._preMousePos.set(n.x,n.y),this._eventTarget.emit(kv.MOUSE_WHEEL,o)},n.on=function(e,t,n){this._eventTarget.on(e,t,n)},e}(),pC=new Xn,hC=new(function(){function e(){this._touchMap=void 0,this._maxTouches=8,this._touchMap=new Map}var t=e.prototype;return t._cloneTouch=function(e){var t=e.getID();e.getStartLocation(pC);var n=new cC(pC.x,pC.y,t);return e.getLocation(pC),n.setPoint(pC.x,pC.y),e.getPreviousLocation(pC),n.setPrevPoint(pC),n},t._createTouch=function(e,t,n){if(this._touchMap.has(e))console.log("Cannot create the same touch object.");else{if(!this._checkTouchMapSizeMoreThanMax(e)){var i=new cC(t,n,e);return this._touchMap.set(e,i),this._updateTouch(i,t,n),this._cloneTouch(i)}console.log("The touches is more than MAX_TOUCHES.")}},t.releaseTouch=function(e){this._touchMap.has(e)&&this._touchMap.delete(e)},t.getTouch=function(e,t,n){var i=this._touchMap.get(e);return i?this._updateTouch(i,t,n):i=this._createTouch(e,t,n),i?this._cloneTouch(i):void 0},t.getAllTouches=function(){var e=this,t=[];return this._touchMap.forEach((function(n){if(n){var i=e._cloneTouch(n);t.push(i)}})),t},t._updateTouch=function(e,t,n){e.getLocation(pC),e.setPrevPoint(pC),e.setPoint(t,n)},t._checkTouchMapSizeMoreThanMax=function(e){var t=this;if(this._touchMap.has(e))return!1;var n=Ke.ENABLE_MULTI_TOUCH?this._maxTouches:1;if(this._touchMap.size<n)return!1;var i=performance.now();return this._touchMap.forEach((function(e){i-e.lastModified>Ke.TOUCH_TIMEOUT&&(console.log("The touches is more than MAX_TOUCHES, release touch id "+e.getID()+"."),t.releaseTouch(e.getID()))})),n>=this._touchMap.size},e}()),vC=function(){function e(){this._eventTarget=new fe,this._registerEvent()}var t=e.prototype;return t._registerEvent=function(){se.onTouchStart(this._createCallback(kv.TOUCH_START)),se.onTouchMove(this._createCallback(kv.TOUCH_MOVE)),se.onTouchEnd(this._createCallback(kv.TOUCH_END)),se.onTouchCancel(this._createCallback(kv.TOUCH_CANCEL))},t._createCallback=function(e){var t=this;return function(n){for(var i=[],o=bc.windowSize,a=bc.devicePixelRatio,r=n.changedTouches.length,c=0;c<r;++c){var s=n.changedTouches[c],l=s.identifier;if(null!==l){var f=t._getLocation(s,o,a),_=hC.getTouch(l,f.x,f.y);_&&(e!==kv.TOUCH_END&&e!==kv.TOUCH_CANCEL||hC.releaseTouch(l),i.push(_))}}if(i.length>0){var u=new iC(i,!1,e,Ke.ENABLE_MULTI_TOUCH?hC.getAllTouches():i);t._eventTarget.emit(e,u)}}},t._getLocation=function(e,t,n){var i=e.clientX*n,o=t.height-e.clientY*n;return new Xn(i,o)},t.on=function(e,t,n){this._eventTarget.on(e,t,n)},e}();!function(e){e[e.GLOBAL=0]="GLOBAL",e[e.UI=1]="UI"}(uC||(uC=e("dU",{})));var gC=function(){function e(e){this.priority=uC.GLOBAL,this._inputEventTarget=void 0,this._inputEventTarget=e}return e.prototype.dispatchEvent=function(e){return this._inputEventTarget.emit(e.type,e),!0},e}(),xC=((_C={})[kv.MOUSE_DOWN]=kv.TOUCH_START,_C[kv.MOUSE_MOVE]=kv.TOUCH_MOVE,_C[kv.MOUSE_UP]=kv.TOUCH_END,_C),yC=e("bG",function(){function e(){this._dispatchImmediately=!Gt,this._eventTarget=new fe,this._touchInput=new vC,this._mouseInput=new dC,this._keyboardInput=new mC,this._accelerometerInput=new sC,this._eventTouchList=[],this._eventMouseList=[],this._eventKeyboardList=[],this._eventAccelerationList=[],this._needSimulateTouchMoveEvent=!1,this._inputEventDispatcher=void 0,this._eventDispatcherList=[],this._registerEvent(),this._inputEventDispatcher=new gC(this._eventTarget),this._registerEventDispatcher(this._inputEventDispatcher)}var t=e.prototype;return t.on=function(e,t,n){return this._eventTarget.on(e,t,n),t},t.once=function(e,t,n){return this._eventTarget.once(e,t,n),t},t.off=function(e,t,n){this._eventTarget.off(e,t,n)},t.setAccelerometerEnabled=function(e){e?this._accelerometerInput.start():this._accelerometerInput.stop()},t.setAccelerometerInterval=function(e){this._accelerometerInput.setInterval(e)},t._simulateEventTouch=function(e){var t=xC[e.type],n=hC.getTouch(0,e.getLocationX(),e.getLocationY());if(n){var i=[n],o=new iC(i,!1,t,i);t===kv.TOUCH_END&&hC.releaseTouch(0),this._dispatchOrPushEventTouch(o,this._eventTouchList)}},t._registerEventDispatcher=function(e){this._eventDispatcherList.push(e),this._eventDispatcherList.sort((function(e,t){return t.priority-e.priority}))},t._emitEvent=function(e){for(var t=this._eventDispatcherList.length,n=0;n<t&&this._eventDispatcherList[n].dispatchEvent(e);++n);},t._registerEvent=function(){var e=this;if(Nc.hasFeature(Nc.Feature.INPUT_TOUCH)){var t=this._eventTouchList;this._touchInput.on(kv.TOUCH_START,(function(n){e._dispatchOrPushEventTouch(n,t)})),this._touchInput.on(kv.TOUCH_MOVE,(function(n){e._dispatchOrPushEventTouch(n,t)})),this._touchInput.on(kv.TOUCH_END,(function(n){e._dispatchOrPushEventTouch(n,t)})),this._touchInput.on(kv.TOUCH_CANCEL,(function(n){e._dispatchOrPushEventTouch(n,t)}))}if(Nc.hasFeature(Nc.Feature.EVENT_MOUSE)){var n=this._eventMouseList;this._mouseInput.on(kv.MOUSE_DOWN,(function(t){e._needSimulateTouchMoveEvent=!0,e._simulateEventTouch(t),e._dispatchOrPushEvent(t,n)})),this._mouseInput.on(kv.MOUSE_MOVE,(function(t){e._needSimulateTouchMoveEvent&&e._simulateEventTouch(t),e._dispatchOrPushEvent(t,n)})),this._mouseInput.on(kv.MOUSE_UP,(function(t){e._needSimulateTouchMoveEvent=!1,e._simulateEventTouch(t),e._dispatchOrPushEvent(t,n)})),this._mouseInput.on(kv.MOUSE_WHEEL,(function(t){e._dispatchOrPushEvent(t,n)}))}if(Nc.hasFeature(Nc.Feature.EVENT_KEYBOARD)){var i=this._eventKeyboardList;this._keyboardInput.on(kv.KEY_DOWN,(function(t){e._dispatchOrPushEvent(t,i)})),this._keyboardInput.on(kv.KEY_PRESSING,(function(t){e._dispatchOrPushEvent(t,i)})),this._keyboardInput.on(kv.KEY_UP,(function(t){e._dispatchOrPushEvent(t,i)}))}if(Nc.hasFeature(Nc.Feature.EVENT_ACCELEROMETER)){var o=this._eventAccelerationList;this._accelerometerInput.on(kv.DEVICEMOTION,(function(t){e._dispatchOrPushEvent(t,o)}))}},t._clearEvents=function(){this._eventMouseList.length=0,this._eventTouchList.length=0,this._eventKeyboardList.length=0,this._eventAccelerationList.length=0},t._dispatchOrPushEvent=function(e,t){this._dispatchImmediately?this._emitEvent(e):t.push(e)},t._dispatchOrPushEventTouch=function(e,t){if(this._dispatchImmediately)for(var n=e.getTouches(),i=n.length,o=0;o<i;++o)e.touch=n[o],e.propagationStopped=e.propagationImmediateStopped=!1,this._emitEvent(e);else t.push(e)},t._frameDispatchEvents=function(){for(var e=this._eventMouseList,t=0,n=e.length;t<n;++t){var i=e[t];this._emitEvent(i)}for(var o=this._eventTouchList,a=0,r=o.length;a<r;++a)for(var c=o[a],s=c.getTouches(),l=s.length,f=0;f<l;++f)c.touch=s[f],c.propagationStopped=c.propagationImmediateStopped=!1,this._emitEvent(c);for(var _=this._eventKeyboardList,u=0,m=_.length;u<m;++u){var d=_[u];this._emitEvent(d)}for(var p=this._eventAccelerationList,h=0,v=p.length;h<v;++h){var g=p[h];this._emitEvent(g)}this._clearEvents()},e}());yC.EventType=kv;var CC=e("bF",new yC),SC=e("bI",function(e){function t(){var t;return t=e.call(this)||this,CC.on(kv.MOUSE_DOWN,(function(e){t.emit(Vv.MOUSE_DOWN,e)})),CC.on(kv.MOUSE_MOVE,(function(e){t.emit(Vv.MOUSE_MOVE,e)})),CC.on(kv.MOUSE_UP,(function(e){t.emit(Vv.MOUSE_UP,e)})),CC.on(kv.MOUSE_WHEEL,(function(e){t.emit(Vv.MOUSE_WHEEL,e)})),CC.on(kv.TOUCH_START,(function(e){t.emit(Vv.TOUCH_START,e.touch,e)})),CC.on(kv.TOUCH_MOVE,(function(e){t.emit(Vv.TOUCH_MOVE,e.touch,e)})),CC.on(kv.TOUCH_END,(function(e){t.emit(Vv.TOUCH_END,e.touch,e)})),CC.on(kv.TOUCH_CANCEL,(function(e){t.emit(Vv.TOUCH_CANCEL,e.touch,e)})),CC.on(kv.KEY_DOWN,(function(e){t.emit(Vv.KEY_DOWN,e)})),CC.on(kv.KEY_PRESSING,(function(e){t.emit(Vv.KEY_DOWN,e)})),CC.on(kv.KEY_UP,(function(e){t.emit(Vv.KEY_UP,e)})),CC.on(kv.DEVICEMOTION,(function(e){t.emit(Vv.DEVICEMOTION,e)})),t}a(t,e);var n=t.prototype;return n.setAccelerometerEnabled=function(e){CC.setAccelerometerEnabled(e)},n.setAccelerometerInterval=function(e){CC.setAccelerometerInterval(e)},n.on=function(t,n,i,o){return e.prototype.on.call(this,t,n,i,o),n},n.off=function(t,n,i){e.prototype.off.call(this,t,n,i)},t}(fe));SC.EventType=Vv,s.SystemEvent=SC;var EC,PC=e("bH",new SC);s.systemEvent=PC,nn(Vv,"Node.EventType",[{name:"POSITION_PART",newName:"TRANSFORM_CHANGED"},{name:"ROTATION_PART",newName:"TRANSFORM_CHANGED"},{name:"SCALE_PART",newName:"TRANSFORM_CHANGED"}]),nn(Zy,"Event",[{name:"ACCELERATION",newName:"DEVICEMOTION",target:SC.EventType,targetName:"SystemEvent.EventType"}]),an(Zy,"Event",[{name:"TOUCH",suggest:"please use SystemEvent.EventType.TOUCH_START, SystemEvent.EventType.TOUCH_MOVE, SystemEvent.EventType.TOUCH_END and SystemEvent.EventType.TOUCH_CANCEL instead"},{name:"MOUSE",suggest:"please use SystemEvent.EventType.MOUSE_DOWN, SystemEvent.EventType.MOUSE_MOVE, SystemEvent.EventType.MOUSE_UP, SystemEvent.EventType.MOUSE_WHEEL, Node.EventType.MOUSE_ENTER and Node.EventType.MOUSE_LEAVE instead"},{name:"KEYBOARD",suggest:"please use SystemEvent.EventType.KEY_DOWN and SystemEvent.EventType.KEY_UP instead"}]),nn(tC,"EventMouse",["DOWN","UP","MOVE"].map((function(e){return{name:e,newName:"MOUSE_"+e,target:SC.EventType,targetName:"SystemEvent.EventType"}}))),nn(tC,"EventMouse",[{name:"SCROLL",newName:"MOUSE_WHEEL",target:SC.EventType,targetName:"SystemEvent.EventType"}]),an(tC.prototype,"EventMouse.prototype",[{name:"eventType",suggest:"please use EventMouse.prototype.type instead"}]),nn(iC,"EventTouch",[{name:"BEGAN",newName:"TOUCH_START",target:SC.EventType,targetName:"SystemEvent.EventType"}]),nn(iC,"EventTouch",[{name:"MOVED",newName:"TOUCH_MOVE",target:SC.EventType,targetName:"SystemEvent.EventType"}]),nn(iC,"EventTouch",[{name:"ENDED",newName:"TOUCH_END",target:SC.EventType,targetName:"SystemEvent.EventType"}]),nn(iC,"EventTouch",[{name:"CANCELLED",newName:"TOUCH_CANCEL",target:SC.EventType,targetName:"SystemEvent.EventType"}]),an(iC.prototype,"EventTouch.prototype",[{name:"getEventCode",suggest:"please use EventTouch.prototype.type instead"}]),nn(iC.prototype,"EventTouch.prototype",[{name:"getUILocationInView",newName:"getLocationInView",target:iC,targetName:"EventTouch"}]),an(Ke.KEY,"macro.KEY",["back","menu","0","1","2","3","4","5","6","7","8","9","0","*","+","-","/",";","=",",",".","[","]","dpadLeft","dpadRight","dpadUp","dpadDown","dpadCenter"].map((function(e){return{name:e}}))),an(Ke.KEY,"macro.KEY",[{name:"shift",suggest:"please use KeyCode.SHIFT_LEFT instead"}]),an(Ke.KEY,"macro.KEY",[{name:"ctrl",suggest:"please use KeyCode.CTRL_LEFT instead"}]),an(Ke.KEY,"macro.KEY",[{name:"alt",suggest:"please use KeyCode.ALT_LEFT instead"}]),an(Ke,"macro",[{name:"KEY",suggest:"please use KeyCode instead"}]),nn(Sp.prototype,"BaseNode",[{name:"childrenCount",newName:"children.length",customGetter:function(){return this.children.length}}]),nn(Qh.prototype,"Node",[{name:"width",targetName:"node.getComponent(UITransform)",customGetter:function(){return this._uiProps.uiTransformComp.width},customSetter:function(e){this._uiProps.uiTransformComp.width=e}},{name:"height",targetName:"node.getComponent(UITransform)",customGetter:function(){return this._uiProps.uiTransformComp.height},customSetter:function(e){this._uiProps.uiTransformComp.height=e}},{name:"anchorX",targetName:"node.getComponent(UITransform)",customGetter:function(){return this._uiProps.uiTransformComp.anchorX},customSetter:function(e){this._uiProps.uiTransformComp.anchorX=e}},{name:"anchorY",targetName:"node.getComponent(UITransform)",customGetter:function(){return this._uiProps.uiTransformComp.anchorY},customSetter:function(e){this._uiProps.uiTransformComp.anchorY=e}},{name:"getAnchorPoint",targetName:"node.getComponent(UITransform)",customFunction:function(e){return e||(e=new Xn),e.set(this._uiProps.uiTransformComp.anchorPoint),e}},{name:"setAnchorPoint",targetName:"node.getComponent(UITransform)",customFunction:function(e,t){this._uiProps.uiTransformComp.setAnchorPoint(e,t)}},{name:"getContentSize",targetName:"node.getComponent(UITransform)",customFunction:function(e){return e||(e=new ti),e.set(this._uiProps.uiTransformComp.contentSize),e}},{name:"setContentSize",targetName:"node.getComponent(UITransform)",customFunction:function(e,t){"number"==typeof e?this._uiProps.uiTransformComp.setContentSize(e,t):this._uiProps.uiTransformComp.setContentSize(e)}}]),on(Qy.prototype,"SceneGlobals.prototype",[{name:"aspect"},{name:"selfShadow"},{name:"linear"},{name:"packing"},{name:"autoAdapt"},{name:"fixedArea"},{name:"pcf"},{name:"bias"},{name:"normalBias"},{name:"near"},{name:"far"},{name:"shadowDistance"},{name:"invisibleOcclusionRange"},{name:"orthoSize"},{name:"saturation"}]),nn(Qy.prototype,"SceneGlobals.prototype",[{name:"distance",newName:"planeHeight"},{name:"normal",newName:"planeDirection"}]),on(Qh.prototype,"Node.prototype",[{name:"addLayer"},{name:"removeLayer"}]),nn(ap.prototype,"NodeUIProperties",[{name:"opacityDirty",newName:"colorDirty"}]),on(Gf,"Layers",[{name:"All"},{name:"RaycastMask"},{name:"check"}]),nn(Gf,"Layers",[{name:"Default",newName:"DEFAULT",target:Gf.Enum,targetName:"Layers.Enum"},{name:"Always",newName:"ALWAYS",target:Gf.Enum,targetName:"Layers.Enum"},{name:"IgnoreRaycast",newName:"IGNORE_RAYCAST",target:Gf.Enum,targetName:"Layers.Enum"},{name:"Gizmos",newName:"GIZMOS",target:Gf.Enum,targetName:"Layers.Enum"},{name:"Editor",newName:"EDITOR",target:Gf.Enum,targetName:"Layers.Enum"},{name:"UI",newName:"UI_3D",target:Gf.Enum,targetName:"Layers.Enum"},{name:"UI2D",newName:"UI_2D",target:Gf.Enum,targetName:"Layers.Enum"},{name:"SceneGizmo",newName:"SCENE_GIZMO",target:Gf.Enum,targetName:"Layers.Enum"},{name:"makeInclusiveMask",newName:"makeMaskInclude",target:Gf,targetName:"Layers"},{name:"makeExclusiveMask",newName:"makeMaskExclude",target:Gf,targetName:"Layers"}]),on(Gf.Enum,"Layers.Enum",[{name:"ALWAYS"}]),on(Gf.BitMask,"Layers.BitMask",[{name:"ALWAYS"}]);var IC,TC,bC,AC,wC,NC=K.Flags.HideInHierarchy,DC=K.Flags.DontSave,RC=e("bk",Ga("cc.PrivateNode")(EC=function(e){function t(t){var n;return n=e.call(this,t)||this,W(12003,n.name),n.hideFlags|=DC|NC,n}return a(t,e),t}(Qh))||EC);nn(Vv,"SystemEventType",["MOUSE_ENTER","MOUSE_LEAVE","TRANSFORM_CHANGED","SCENE_CHANGED_FOR_PERSISTS","SIZE_CHANGED","ANCHOR_CHANGED","COLOR_CHANGED","CHILD_ADDED","CHILD_REMOVED","PARENT_CHANGED","NODE_DESTROYED","LAYER_CHANGED","SIBLING_ORDER_CHANGED"].map((function(e){return{name:e,target:Qh.EventType,targetName:"Node.EventType"}}))),nn(Qh.EventType,"Node.EventType",[{name:"DEVICEMOTION",target:SC.EventType,targetName:"SystemEvent.EventType"},{name:"KEY_DOWN",target:SC.EventType,targetName:"SystemEvent.EventType"},{name:"KEY_UP",target:SC.EventType,targetName:"SystemEvent.EventType"}]),s.PrivateNode=RC;var MC=e("b7",Ga("cc.Scene")((wC=function(e){a(n,e);var t=n.prototype;function n(t){var n;return n=e.call(this,t)||this,te(n,"autoReleaseAssets",bC,J(n)),te(n,"_globals",AC,J(n)),n.dependAssets=null,n._renderScene=null,n._inited=void 0,n._prefabSyncedInLiveReload=!1,n._pos=wn.ZERO,n._rot=zn.IDENTITY,n._scale=wn.ONE,n._mat=jn.IDENTITY,n._dirtyFlags=0,n._lpos=wn.ZERO,n._lrot=zn.IDENTITY,n._lscale=wn.ONE,n._activeInHierarchy=!1,s.director&&s.director.root&&(n._renderScene=s.director.root.createScene({})),n._inited=!s.game||!s.game._isCloning,n._init(),n}return t._updateScene=function(){this._scene=this},t._init=function(){},t.destroy=function(){var e=K.prototype.destroy.call(this);if(e)for(var t=this._children,n=0;n<t.length;++n)t[n].active=!1;return this._renderScene&&s.director.root.destroyScene(this._renderScene),this._active=!1,this._activeInHierarchy=!1,e},t.addComponent=function(){throw new Error(Z(3822))},t._onHierarchyChanged=function(){},t._onBatchCreated=function(t){e.prototype._onBatchCreated.call(this,t);for(var n=this._children.length,i=0;i<n;++i)this.children[i]._siblingIndex=i,this._children[i]._onBatchCreated(t)},t.getPosition=function(e){return wn.copy(e||new wn,wn.ZERO)},t.getRotation=function(e){return zn.copy(e||new zn,zn.IDENTITY)},t.getScale=function(e){return wn.copy(e||new wn,wn.ONE)},t.getWorldPosition=function(e){return wn.copy(e||new wn,wn.ZERO)},t.getWorldRotation=function(e){return zn.copy(e||new zn,zn.IDENTITY)},t.getWorldScale=function(e){return wn.copy(e||new wn,wn.ONE)},t.getWorldMatrix=function(e){return jn.copy(e||new jn,jn.IDENTITY)},t.getWorldRS=function(e){return jn.copy(e||new jn,jn.IDENTITY)},t.getWorldRT=function(e){return jn.copy(e||new jn,jn.IDENTITY)},t.updateWorldTransform=function(){},t._instantiate=function(){},t._load=function(){this._inited||(pv(this),mv(this),this._onBatchCreated(Mt),this._inited=!0),this.walk(Sp._setScene)},t._activate=function(e){e=!1!==e,s.director._nodeActivator.activateNode(this,e),this._globals.activate(),this._renderScene&&this._renderScene.activate()},r(n,[{key:"renderScene",get:function(){return this._renderScene}},{key:"globals",get:function(){return this._globals}},{key:"native",get:function(){return this._nativeObj}},{key:"position",get:function(){return wn.ZERO}},{key:"worldPosition",get:function(){return wn.ZERO}},{key:"rotation",get:function(){return zn.IDENTITY}},{key:"worldRotation",get:function(){return zn.IDENTITY}},{key:"scale",get:function(){return wn.ONE}},{key:"worldScale",get:function(){return wn.ONE}},{key:"eulerAngles",get:function(){return wn.ZERO}},{key:"worldMatrix",get:function(){return jn.IDENTITY}}]),n}(Sp),ee((TC=wC).prototype,"globals",[or],Object.getOwnPropertyDescriptor(TC.prototype,"globals"),TC.prototype),bC=ee(TC.prototype,"autoReleaseAssets",[Ya,or],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return!1}}),AC=ee(TC.prototype,"_globals",[Ya],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return new Qy}}),IC=TC))||IC);function OC(e,t){if(!t){var n=s.director.getScene();if(!n)return null;t=n}return t.getChildByPath(e)}s.Scene=MC,s.find=OC;var LC=Bt.fastRemoveAt,zC=K.Flags.IsStartCalled,FC=K.Flags.IsOnEnableCalled;function UC(e,t){for(var n=t.constructor._executionOrder,i=t._id,o=0,a=e.length-1,r=a>>>1;o<=a;r=o+a>>>1){var c=e[r],s=c.constructor._executionOrder;if(s>n)a=r-1;else if(s<n)o=r+1;else{var l=c._id;if(l>i)a=r-1;else{if(!(l<i))return r;o=r+1}}}return~o}function GC(e,t){for(var n=e.array,i=e.i+1;i<n.length;){var o=n[i];o.node._activeInHierarchy?++i:(e.removeAt(i),t&&(o._objFlags&=~t))}}K.Flags.IsEditorOnEnableCalled;var BC=function(e){this._zero=void 0,this._neg=void 0,this._pos=void 0,this._invoke=void 0;var t=Ht;this._zero=new t([]),this._neg=new t([]),this._pos=new t([]),this._invoke=e};function HC(e,t){return e.constructor._executionOrder-t.constructor._executionOrder}BC.stableRemoveInactive=GC;var VC=function(e){function t(){return e.apply(this,arguments)||this}a(t,e);var n=t.prototype;return n.add=function(e){var t=e.constructor._executionOrder;(0===t?this._zero:t<0?this._neg:this._pos).array.push(e)},n.remove=function(e){var t=e.constructor._executionOrder;(0===t?this._zero:t<0?this._neg:this._pos).fastRemove(e)},n.cancelInactive=function(e){GC(this._zero,e),GC(this._neg,e),GC(this._pos,e)},n.invoke=function(){var e=this._neg;e.array.length>0&&(e.array.sort(HC),this._invoke(e),e.array.length=0),this._invoke(this._zero),this._zero.array.length=0;var t=this._pos;t.array.length>0&&(t.array.sort(HC),this._invoke(t),t.array.length=0)},t}(BC),kC=function(e){function t(){return e.apply(this,arguments)||this}a(t,e);var n=t.prototype;return n.add=function(e){var t=e.constructor._executionOrder;if(0===t)this._zero.array.push(e);else{var n=t<0?this._neg.array:this._pos.array,i=UC(n,e);i<0&&n.splice(~i,0,e)}},n.remove=function(e){var t=e.constructor._executionOrder;if(0===t)this._zero.fastRemove(e);else{var n=t<0?this._neg:this._pos,i=UC(n.array,e);i>=0&&n.removeAt(i)}},n.invoke=function(e){this._neg.array.length>0&&this._invoke(this._neg,e),this._invoke(this._zero,e),this._pos.array.length>0&&this._invoke(this._pos,e)},t}(BC);function jC(e,t,n){return function(i,o){try{t(i,o)}catch(t){s._throw(t);var a=i.array;for(n&&(a[i.i]._objFlags|=n),++i.i;i.i<a.length;++i.i)try{e(a[i.i],o)}catch(e){s._throw(e),n&&(a[i.i]._objFlags|=n)}}}}var qC=jC((function(e){e.start(),e._objFlags|=zC}),(function(e){var t=e.array;for(e.i=0;e.i<t.length;++e.i){var n=t[e.i];n.start(),n._objFlags|=zC}}),zC),WC=jC((function(e,t){e.update(t)}),(function(e,t){var n=e.array;for(e.i=0;e.i<n.length;++e.i)n[e.i].update(t)})),YC=jC((function(e,t){e.lateUpdate(t)}),(function(e,t){var n=e.array;for(e.i=0;e.i<n.length;++e.i)n[e.i].lateUpdate(t)})),XC=function(e){var t=s.director._compScheduler,n=e.array;for(e.i=0;e.i<n.length;++e.i){var i=n[e.i];i._enabled&&(i.onEnable(),!i.node._activeInHierarchy||t._onEnabled(i))}},KC=(e("cb",function(){function e(){this._deferredComps=[],this.unscheduleAll()}var t=e.prototype;return t.unscheduleAll=function(){this.startInvoker=new VC(qC),this.updateInvoker=new kC(WC),this.lateUpdateInvoker=new kC(YC),this._updating=!1},t._onEnabled=function(e){s.director.getScheduler().resumeTarget(e),e._objFlags|=FC,this._updating?this._deferredComps.push(e):this._scheduleImmediate(e)},t._onDisabled=function(e){s.director.getScheduler().pauseTarget(e),e._objFlags&=~FC;var t=this._deferredComps.indexOf(e);t>=0?LC(this._deferredComps,t):(!e.start||e._objFlags&zC||this.startInvoker.remove(e),e.update&&this.updateInvoker.remove(e),e.lateUpdate&&this.lateUpdateInvoker.remove(e))},t.enableComp=function(e,t){if(!(e._objFlags&FC)){if(e.onEnable){if(t)return void t.add(e);if(e.onEnable(),!e.node._activeInHierarchy)return}this._onEnabled(e)}},t.disableComp=function(e){e._objFlags&FC&&(e.onDisable&&e.onDisable(),this._onDisabled(e))},t.startPhase=function(){this._updating=!0,this.startInvoker.invoke(),this._startForNewComps()},t.updatePhase=function(e){this.updateInvoker.invoke(e)},t.lateUpdatePhase=function(e){this.lateUpdateInvoker.invoke(e),this._updating=!1,this._startForNewComps()},t._startForNewComps=function(){this._deferredComps.length>0&&(this._deferredSchedule(),this.startInvoker.invoke())},t._scheduleImmediate=function(e){"function"!=typeof e.start||e._objFlags&zC||this.startInvoker.add(e),"function"==typeof e.update&&this.updateInvoker.add(e),"function"==typeof e.lateUpdate&&this.lateUpdateInvoker.add(e)},t._deferredSchedule=function(){for(var e=this._deferredComps,t=0,n=e.length;t<n;t++)this._scheduleImmediate(e[t]);e.length=0},e}()),K.Flags.IsPreloadStarted),JC=K.Flags.IsOnLoadStarted,QC=K.Flags.IsOnLoadCalled,ZC=K.Flags.Deactivating,$C=function(e){function t(){return e.apply(this,arguments)||this}a(t,e);var n=t.prototype;return n.add=function(e){this._zero.array.push(e)},n.remove=function(e){this._zero.fastRemove(e)},n.cancelInactive=function(e){BC.stableRemoveInactive(this._zero,e)},n.invoke=function(){this._invoke(this._zero),this._zero.array.length=0},t}(BC),eS=jC((function(e){e.__preload()}),(function(e){var t=e.array;for(e.i=0;e.i<t.length;++e.i)t[e.i].__preload()})),tS=jC((function(e){e.onLoad(),e._objFlags|=QC}),(function(e){var t=e.array;for(e.i=0;e.i<t.length;++e.i){var n=t[e.i];n.onLoad(),n._objFlags|=QC}}),QC),nS=new ge(4);function iS(e,t,n){Te(3817,e.name,n),console.log("Corrupted component value:",t),t?e._removeComponent(t):Bt.removeAt(e._components,n)}nS.get=function(){var e=this._get()||{preload:new $C(eS),onLoad:new VC(tS),onEnable:new VC(XC)};e.preload._zero.i=-1;var t=e.onLoad;return t._zero.i=-1,t._neg.i=-1,t._pos.i=-1,(t=e.onEnable)._zero.i=-1,t._neg.i=-1,t._pos.i=-1,e},e("ba",function(){function e(){this.resetComp=void 0,this.reset()}var t=e.prototype;return t.reset=function(){this._activatingStack=[]},t.activateNode=function(e,t){if(t){var n=nS.get();this._activatingStack.push(n),this._activateNodeRecursively(e,n.preload,n.onLoad,n.onEnable),n.preload.invoke(),n.onLoad.invoke(),n.onEnable.invoke(),this._activatingStack.pop(),nS.put(n)}else{this._deactivateNodeRecursively(e);for(var i,o=this._activatingStack,a=X(o);!(i=a()).done;){var r=i.value;r.preload.cancelInactive(KC),r.onLoad.cancelInactive(JC),r.onEnable.cancelInactive()}}e.emit(Kd.ACTIVE_IN_HIERARCHY_CHANGED,e)},t.activateComp=function(e,t,n,i){if(Vt(e,!0)&&(e._objFlags&KC||(e._objFlags|=KC,e.__preload&&(t?t.add(e):e.__preload())),e._objFlags&JC||(e._objFlags|=JC,e.onLoad?n?n.add(e):(e.onLoad(),e._objFlags|=QC):e._objFlags|=QC),e._enabled)){if(!e.node._activeInHierarchy)return;s.director._compScheduler.enableComp(e,i)}},t.destroyComp=function(e){s.director._compScheduler.disableComp(e),e.onDestroy&&e._objFlags&QC&&e.onDestroy()},t._activateNodeRecursively=function(e,t,n,i){if(e._objFlags&ZC)Te(3816,e.name);else{e._activeInHierarchy=!0;for(var o=e._components.length,a=0;a<o;++a){var r=e._components[a];r instanceof s.Component?this.activateComp(r,t,n,i):(iS(e,r,a),--a,--o)}for(var c=0,l=e._children.length;c<l;++c){var f=e._children[c];f._active&&this._activateNodeRecursively(f,t,n,i)}e._onPostActivated(!0)}},t._deactivateNodeRecursively=function(e){e._objFlags|=ZC,e._activeInHierarchy=!1;for(var t=e._components.length,n=0;n<t;++n){var i=e._components[n];if(i._enabled&&(s.director._compScheduler.disableComp(i),e._activeInHierarchy))return void(e._objFlags&=~ZC)}for(var o=0,a=e._children.length;o<a;++o){var r=e._children[o];if(r._activeInHierarchy&&(this._deactivateNodeRecursively(r),e._activeInHierarchy))return void(e._objFlags&=~ZC)}e._onPostActivated(!1),e._objFlags&=~ZC},e}());var oS,aS,rS,cS,sS,lS,fS,_S,uS=e("aP",Ga("cc.SceneAsset")((cS=function(e){function t(){for(var t,n=arguments.length,i=new Array(n),o=0;o<n;o++)i[o]=arguments[o];return t=e.call.apply(e,[this].concat(i))||this,te(t,"scene",rS,J(t)),t}a(t,e);var n=t.prototype;return n.initDefault=function(t){e.prototype.initDefault.call(this,t),this.scene=new MC("New Scene")},n.validate=function(){return!!this.scene},t}(ec),rS=ee((aS=cS).prototype,"scene",[or,Ya],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return null}}),oS=aS))||oS);s.SceneAsset=uS;var mS,dS,pS,hS,vS=e("aQ",Ga("cc.TextAsset")((_S=function(e){function t(){for(var t,n=arguments.length,i=new Array(n),o=0;o<n;o++)i[o]=arguments[o];return t=e.call.apply(e,[this].concat(i))||this,te(t,"text",fS,J(t)),t}return a(t,e),t.prototype.toString=function(){return this.text},t}(ec),fS=ee((lS=_S).prototype,"text",[Ya,or],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return""}}),sS=lS))||sS);s.TextAsset=vS;var gS=e("aR",Ga("cc.JsonAsset")((hS=function(e){function t(){for(var t,n=arguments.length,i=new Array(n),o=0;o<n;o++)i[o]=arguments[o];return t=e.call.apply(e,[this].concat(i))||this,te(t,"json",pS,J(t)),t}return a(t,e),t}(ec),pS=ee((dS=hS).prototype,"json",[Ya,or],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return null}}),mS=dS))||mS);s.JsonAsset=gS}}}));
 
 			}); 
		define("__plugin__/wx0446ba2621dda60a/mesh-f5415e9d.js", function(require, module, exports){ 			
"use strict";

System.register(["./texture-barrier-60b5983b.js", "./json-asset-933a1d4c.js"], function (t) {
  "use strict";

  var e, r, i, n, s, a, u, o, h, f, c, d, l, v, _, m, g, p, b, w, x, T, y, A, E, I, M, B, P, R, O, S, U, N, V, F, C, L, D;

  return {
    setters: [function (t) {
      e = t.bU, r = t.bW, i = t.l, n = t.w, s = t.i, a = t.a_, u = t.al, o = t.o, h = t.q, f = t.m, c = t.u, d = t.cH, l = t.cq, v = t.cI, _ = t.bT, m = t.F, g = t.d, p = t.aC, b = t.a$, w = t.b8, x = t.c0, T = t.n, y = t.c1, A = t.b$, E = t.bA;
    }, function (t) {
      I = t.dm, M = t.aS, B = t.aT, P = t.dn, R = t.dp, O = t.dq, S = t.Q, U = t.bW, N = t.aO, V = t.bJ, F = t.W, C = t.aL, L = t.bX, D = t.b0;
    }],
    execute: function execute() {
      var k,
          G,
          z,
          H,
          W,
          X = t("B", function () {
        function t() {
          this._arrayBufferOrPaddings = [], this._length = 0;
        }

        var e = t.prototype;
        return e.setNextAlignment = function (t) {
          if (0 !== t) {
            var e = this._length % t;

            if (0 !== e) {
              var r = t - e;
              this._arrayBufferOrPaddings.push(r), this._length += r;
            }
          }
        }, e.addBuffer = function (t) {
          var e = this._length;
          return this._arrayBufferOrPaddings.push(t), this._length += t.byteLength, e;
        }, e.getLength = function () {
          return this._length;
        }, e.getCombined = function () {
          var t = new Uint8Array(this._length),
              e = 0;
          return this._arrayBufferOrPaddings.forEach(function (r) {
            "number" == typeof r ? e += r : (t.set(new Uint8Array(r), e), e += r.byteLength);
          }), t.buffer;
        }, t;
      }()),
          j = function () {
        function t(t, e) {
          if (this._mesh = void 0, this._subMeshRenderings = [], this._mesh = t, this._mesh.struct.morph) {
            var r = this._mesh.struct.primitives.length;
            this._subMeshRenderings = new Array(r).fill(null);

            for (var i = 0; i < r; ++i) {
              var n = this._mesh.struct.morph.subMeshMorphs[i];
              n && (n.targets.length > I.MAX_MORPH_TARGET_COUNT ? this._subMeshRenderings[i] = new J(this._mesh, i, this._mesh.struct.morph, e) : this._subMeshRenderings[i] = new q(this._mesh, i, this._mesh.struct.morph, e));
            }
          }
        }

        return t.prototype.createInstance = function () {
          for (var t = this, e = this._mesh.struct.primitives.length, r = new Array(e), i = 0; i < e; ++i) {
            var n, u;
            r[i] = null !== (n = null === (u = this._subMeshRenderings[i]) || void 0 === u ? void 0 : u.createInstance()) && void 0 !== n ? n : null;
          }

          return {
            setWeights: function setWeights(t, e) {
              var i;
              null === (i = r[t]) || void 0 === i || i.setWeights(e);
            },
            requiredPatches: function requiredPatches(e) {
              v(t._mesh.struct.morph);
              var i = t._mesh.struct.morph.subMeshMorphs[e],
                  n = r[e];
              if (null === n) return null;
              var s = [{
                name: "CC_USE_MORPH",
                value: !0
              }, {
                name: "CC_MORPH_TARGET_COUNT",
                value: i.targets.length
              }];
              return i.attributes.includes(a.ATTR_POSITION) && s.push({
                name: "CC_MORPH_TARGET_HAS_POSITION",
                value: !0
              }), i.attributes.includes(a.ATTR_NORMAL) && s.push({
                name: "CC_MORPH_TARGET_HAS_NORMAL",
                value: !0
              }), i.attributes.includes(a.ATTR_TANGENT) && s.push({
                name: "CC_MORPH_TARGET_HAS_TANGENT",
                value: !0
              }), s.push.apply(s, n.requiredPatches()), s;
            },
            adaptPipelineState: function adaptPipelineState(t, e) {
              var i;
              null === (i = r[t]) || void 0 === i || i.adaptPipelineState(e);
            },
            destroy: function destroy() {
              for (var t, e = s(r); !(t = e()).done;) {
                var i = t.value;
                null == i || i.destroy();
              }
            }
          };
        }, t;
      }(),
          q = function () {
        function t(t, e, r, i) {
          this._gfxDevice = void 0, this._subMeshMorph = void 0, this._textureInfo = void 0, this._attributes = void 0, this._verticesCount = void 0, this._gfxDevice = i;
          var n = r.subMeshMorphs[e];
          this._subMeshMorph = n, Y(t, e, i);
          var s = t.struct.vertexBundles[t.struct.primitives[e].vertexBundelIndices[0]].view.count;
          this._verticesCount = s;
          var a = n.targets.length,
              u = $(i, s * a);
          this._textureInfo = {
            width: u.width,
            height: u.height
          }, this._attributes = n.attributes.map(function (e, r) {
            var i = u.create(),
                a = i.valueView;
            return n.targets.forEach(function (e, i) {
              for (var n = e.displacements[r], u = new Float32Array(t.data.buffer, t.data.byteOffset + n.offset, n.count), o = s * i * 4, h = 0; h < s; ++h) {
                a[o + 4 * h + 0] = u[3 * h + 0], a[o + 4 * h + 1] = u[3 * h + 1], a[o + 4 * h + 2] = u[3 * h + 2];
              }
            }), i.updatePixels(), {
              name: e,
              morphTexture: i
            };
          });
        }

        var e = t.prototype;
        return e.destroy = function () {
          for (var t, e = s(this._attributes); !(t = e()).done;) {
            t.value.morphTexture.destroy();
          }
        }, e.createInstance = function () {
          var t = this,
              e = new Z(this._gfxDevice, this._subMeshMorph.targets.length);
          return e.setMorphTextureInfo(this._textureInfo.width, this._textureInfo.height), e.setVerticesCount(this._verticesCount), e.commit(), {
            setWeights: function setWeights(t) {
              e.setWeights(t), e.commit();
            },
            requiredPatches: function requiredPatches() {
              return [{
                name: "CC_MORPH_TARGET_USE_TEXTURE",
                value: !0
              }];
            },
            adaptPipelineState: function adaptPipelineState(r) {
              for (var i, u = s(t._attributes); !(i = u()).done;) {
                var o = i.value,
                    h = void 0;

                switch (o.name) {
                  case a.ATTR_POSITION:
                    h = O;
                    break;

                  case a.ATTR_NORMAL:
                    h = R;
                    break;

                  case a.ATTR_TANGENT:
                    h = P;
                    break;

                  default:
                    n("Unexpected attribute!");
                }

                void 0 !== h && (r.bindSampler(h, o.morphTexture.sampler), r.bindTexture(h, o.morphTexture.texture));
              }

              r.bindBuffer(I.BINDING, e.buffer), r.update();
            },
            destroy: function destroy() {}
          };
        }, t;
      }(),
          J = function () {
        function t(t, e, r, i) {
          this._gfxDevice = void 0, this._attributes = [], this._gfxDevice = i;
          var n = r.subMeshMorphs[e];
          Y(t, e, i), this._attributes = n.attributes.map(function (e, r) {
            return {
              name: e,
              targets: n.targets.map(function (e) {
                return {
                  displacements: new Float32Array(t.data.buffer, t.data.byteOffset + e.displacements[r].offset, e.displacements[r].count)
                };
              })
            };
          });
        }

        return t.prototype.createInstance = function () {
          return new Q(this, this._attributes[0].targets[0].displacements.length / 3, this._gfxDevice);
        }, e(t, [{
          key: "data",
          get: function get() {
            return this._attributes;
          }
        }]), t;
      }(),
          Q = function () {
        function t(t, e, r) {
          this._attributes = void 0, this._owner = void 0, this._morphUniforms = void 0, this._owner = t, this._morphUniforms = new Z(r, 0);
          var i = $(r, e);
          this._morphUniforms.setMorphTextureInfo(i.width, i.height), this._morphUniforms.commit(), this._attributes = this._owner.data.map(function (t) {
            var e = i.create();
            return {
              attributeName: t.name,
              morphTexture: e
            };
          });
        }

        var e = t.prototype;
        return e.setWeights = function (t) {
          for (var e = 0; e < this._attributes.length; ++e) {
            var i = this._attributes[e],
                n = i.morphTexture.valueView,
                s = this._owner.data[e];
            r(t.length === s.targets.length);

            for (var a = 0; a < s.targets.length; ++a) {
              var u = s.targets[a].displacements,
                  o = t[a],
                  h = u.length / 3;
              if (0 === a) for (var f = 0; f < h; ++f) {
                n[4 * f + 0] = u[3 * f + 0] * o, n[4 * f + 1] = u[3 * f + 1] * o, n[4 * f + 2] = u[3 * f + 2] * o;
              } else if (0 !== o) for (var c = 0; c < h; ++c) {
                n[4 * c + 0] += u[3 * c + 0] * o, n[4 * c + 1] += u[3 * c + 1] * o, n[4 * c + 2] += u[3 * c + 2] * o;
              }
            }

            i.morphTexture.updatePixels();
          }
        }, e.requiredPatches = function () {
          return [{
            name: "CC_MORPH_TARGET_USE_TEXTURE",
            value: !0
          }, {
            name: "CC_MORPH_PRECOMPUTED",
            value: !0
          }];
        }, e.adaptPipelineState = function (t) {
          for (var e, r = s(this._attributes); !(e = r()).done;) {
            var i = e.value,
                u = void 0;

            switch (i.attributeName) {
              case a.ATTR_POSITION:
                u = O;
                break;

              case a.ATTR_NORMAL:
                u = R;
                break;

              case a.ATTR_TANGENT:
                u = P;
                break;

              default:
                n("Unexpected attribute!");
            }

            void 0 !== u && (t.bindSampler(u, i.morphTexture.sampler), t.bindTexture(u, i.morphTexture.texture));
          }

          t.bindBuffer(I.BINDING, this._morphUniforms.buffer), t.update();
        }, e.destroy = function () {
          this._morphUniforms.destroy();

          for (var t = 0; t < this._attributes.length; ++t) {
            this._attributes[t].morphTexture.destroy();
          }
        }, t;
      }(),
          Z = function () {
        function t(t, e) {
          this._targetCount = void 0, this._localBuffer = void 0, this._remoteBuffer = void 0, this._targetCount = e, this._localBuffer = new DataView(new ArrayBuffer(I.SIZE)), this._remoteBuffer = t.createBuffer(new u(o.UNIFORM | o.TRANSFER_DST, h.HOST | h.DEVICE, I.SIZE, I.SIZE));
        }

        var n = t.prototype;
        return n.destroy = function () {
          this._remoteBuffer.destroy();
        }, n.setWeights = function (t) {
          r(t.length === this._targetCount);

          for (var e = 0; e < t.length; ++e) {
            this._localBuffer.setFloat32(I.OFFSET_OF_WEIGHTS + 4 * e, t[e], i.sys.isLittleEndian);
          }
        }, n.setMorphTextureInfo = function (t, e) {
          this._localBuffer.setFloat32(I.OFFSET_OF_DISPLACEMENT_TEXTURE_WIDTH, t, i.sys.isLittleEndian), this._localBuffer.setFloat32(I.OFFSET_OF_DISPLACEMENT_TEXTURE_HEIGHT, e, i.sys.isLittleEndian);
        }, n.setVerticesCount = function (t) {
          this._localBuffer.setFloat32(I.OFFSET_OF_VERTICES_COUNT, t, i.sys.isLittleEndian);
        }, n.commit = function () {
          this._remoteBuffer.update(this._localBuffer.buffer);
        }, e(t, [{
          key: "buffer",
          get: function get() {
            return this._remoteBuffer;
          }
        }]), t;
      }();

      function $(t, e) {
        var r, i, s, a;
        t.getFormatFeatures(f.RGBA32F) & c.SAMPLED_TEXTURE ? (r = e, s = 16, i = B.PixelFormat.RGBA32F, a = Float32Array) : (r = 4 * e, s = 4, i = B.PixelFormat.RGBA8888, a = Uint8Array);

        var u = function (t) {
          t < 5 && (t = 5);
          var e = d(t),
              r = l(e),
              i = r >> 1;
          return {
            width: 1 << (1 & r ? i + 1 : i),
            height: 1 << i
          };
        }(r),
            o = u.width,
            h = u.height;

        return {
          width: o,
          height: h,
          create: function create() {
            var e = new ArrayBuffer(o * h * s),
                r = new Float32Array(e),
                u = a === Float32Array ? r : new a(e),
                f = new M({
              width: o,
              height: h,
              _data: u,
              _compressed: !1,
              format: i
            }),
                c = new B();
            c.setFilters(B.Filter.NEAREST, B.Filter.NEAREST), c.setMipFilter(B.Filter.NONE), c.setWrapMode(B.WrapMode.CLAMP_TO_EDGE, B.WrapMode.CLAMP_TO_EDGE, B.WrapMode.CLAMP_TO_EDGE), c.image = f, c.getGFXTexture() || n("Unexpected: failed to create morph texture?");
            var d = t.getSampler(c.getSamplerInfo());
            return {
              get texture() {
                return c.getGFXTexture();
              },

              get sampler() {
                return d;
              },

              get valueView() {
                return r;
              },

              destroy: function destroy() {
                c.destroy();
              },
              updatePixels: function updatePixels() {
                c.uploadData(u);
              }
            };
          }
        };
      }

      function Y(t, e, r) {
        t.renderingSubMeshes[e].enableVertexIdChannel(r);
      }

      function K(t) {
        switch (t) {
          case 1:
            return Uint8Array;

          case 2:
            return Uint16Array;

          case 4:
            return Uint32Array;

          default:
            return Uint8Array;
        }
      }

      var tt = new S(),
          et = new S(),
          rt = new Uint8Array(),
          it = t("M", U("cc.Mesh")((W = function (t) {
        function r() {
          var e;
          return (e = t.call(this) || this).morphRendering = null, y(e, "_struct", z, A(e)), y(e, "_hash", H, A(e)), e._data = rt, e._initialized = !1, e._renderingSubMeshes = null, e._boneSpaceBounds = new Map(), e._jointBufferIndices = null, e;
        }

        _(r, t);

        var n = r.prototype;
        return n.onLoaded = function () {
          this.initialize();
        }, n.initialize = function () {
          if (!this._initialized) {
            this._initialized = !0;

            for (var t = this._data.buffer, e = i.director.root.device, r = this._createVertexBuffers(e, t), n = [], s = 0; s < this._struct.primitives.length; s++) {
              var a = this._struct.primitives[s];

              if (0 !== a.vertexBundelIndices.length) {
                var f = null,
                    c = null;

                if (a.indexView) {
                  var d = a.indexView,
                      l = d.stride,
                      v = d.length;

                  if (4 === l && !e.hasFeature(m.ELEMENT_INDEX_UINT)) {
                    var _ = this._struct.vertexBundles[a.vertexBundelIndices[0]].view.count;

                    if (_ >= 65536) {
                      g(10001, _, 65536);
                      continue;
                    }

                    l >>= 1, v >>= 1;
                  }

                  f = e.createBuffer(new u(o.INDEX, h.DEVICE, v, l)), c = new (K(d.stride))(t, d.offset, d.count), d.stride !== l && (c = K(l).from(c)), f.update(c);
                }

                var b = a.vertexBundelIndices.map(function (t) {
                  return r[t];
                }),
                    w = [];
                if (a.vertexBundelIndices.length > 0) for (var x = a.vertexBundelIndices[0], T = this._struct.vertexBundles[x].attributes, y = 0; y < T.length; ++y) {
                  var A = T[y];
                  w[y] = new p(A.name, A.format, A.isNormalized, A.stream, A.isInstanced, A.location);
                }
                var E = new N(b, w, a.primitiveMode, f);
                E.mesh = this, E.subMeshIdx = s, n.push(E);
              }
            }

            this._renderingSubMeshes = n, this._struct.morph && (this.morphRendering = function (t, e) {
              return new j(t, e);
            }(this, e));
          }
        }, n.destroy = function () {
          return this.destroyRenderingMesh(), t.prototype.destroy.call(this);
        }, n.destroyRenderingMesh = function () {
          if (this._renderingSubMeshes) {
            for (var t = 0; t < this._renderingSubMeshes.length; t++) {
              this._renderingSubMeshes[t].destroy();
            }

            this._renderingSubMeshes = null, this._initialized = !1;
          }
        }, n.assign = function (t, e) {
          this.reset({
            struct: t,
            data: e
          });
        }, n.reset = function (t) {
          this.destroyRenderingMesh(), this._struct = t.struct, this._data = t.data, this._hash = 0;
        }, n.getBoneSpaceBounds = function (t) {
          if (this._boneSpaceBounds.has(t.hash)) return this._boneSpaceBounds.get(t.hash);
          var e = [];

          this._boneSpaceBounds.set(t.hash, e);

          for (var r = [], i = t.bindposes, n = 0; n < i.length; n++) {
            e.push(new V(1 / 0, 1 / 0, 1 / 0, -1 / 0, -1 / 0, -1 / 0)), r.push(!1);
          }

          for (var s = this._struct.primitives, u = 0; u < s.length; u++) {
            var o = this.readAttribute(u, a.ATTR_JOINTS),
                h = this.readAttribute(u, a.ATTR_WEIGHTS),
                f = this.readAttribute(u, a.ATTR_POSITION);
            if (o && h && f) for (var c = Math.min(o.length / 4, h.length / 4, f.length / 3), d = 0; d < c; d++) {
              S.set(tt, f[3 * d + 0], f[3 * d + 1], f[3 * d + 2]);

              for (var l = 0; l < 4; ++l) {
                var v = 4 * d + l,
                    _ = o[v];

                if (!(0 === h[v] || _ >= i.length)) {
                  S.transformMat4(et, tt, i[_]), r[_] = !0;
                  var m = e[_];
                  S.min(m.center, m.center, et), S.max(m.halfExtents, m.halfExtents, et);
                }
              }
            }
          }

          for (var g = 0; g < i.length; g++) {
            var p = e[g];
            r[g] ? V.fromPoints(p, p.center, p.halfExtents) : e[g] = null;
          }

          return e;
        }, n.merge = function (t, e, r) {
          if (r && !this.validateMergingMesh(t)) return !1;
          var i = new S(),
              n = e && new F(),
              u = e && new V();

          if (n && e.getRotation(n), !this._initialized) {
            var o = JSON.parse(JSON.stringify(t._struct)),
                h = t._data.slice();

            if (e) {
              o.maxPosition && o.minPosition && (S.add(u.center, o.maxPosition, o.minPosition), S.multiplyScalar(u.center, u.center, .5), S.subtract(u.halfExtents, o.maxPosition, o.minPosition), S.multiplyScalar(u.halfExtents, u.halfExtents, .5), V.transform(u, u, e), S.add(o.maxPosition, u.center, u.halfExtents), S.subtract(o.minPosition, u.center, u.halfExtents));

              for (var f = 0; f < o.vertexBundles.length; f++) {
                for (var c = o.vertexBundles[f], d = 0; d < c.attributes.length; d++) {
                  if (c.attributes[d].name === a.ATTR_POSITION || c.attributes[d].name === a.ATTR_NORMAL) {
                    var l = c.attributes[d].format,
                        v = new DataView(h.buffer, c.view.offset + nt(c.attributes, d)),
                        _ = ut(v, l),
                        m = ot(v, l);

                    if (!_ || !m) continue;

                    for (var g = c.view.count, p = c.view.stride, w = at(l), x = 0; x < g; x++) {
                      var T = x * p,
                          y = T + w,
                          A = y + w;

                      switch (i.set(_(T), _(y), _(A)), c.attributes[d].name) {
                        case a.ATTR_POSITION:
                          i.transformMat4(e);
                          break;

                        case a.ATTR_NORMAL:
                          S.transformQuat(i, i, n);
                      }

                      m(T, i.x), m(y, i.y), m(A, i.z);
                    }
                  }
                }
              }
            }

            return this.reset({
              struct: o,
              data: h
            }), this.initialize(), !0;
          }

          for (var E, I, M, B, P, R = new X(), O = 0, U = 0, N = 0, C = 0, L = 0, D = 0, k = 0, G = 0, z = !1, H = new Array(this._struct.vertexBundles.length), W = 0; W < this._struct.vertexBundles.length; ++W) {
            var j = this._struct.vertexBundles[W],
                q = t._struct.vertexBundles[W];
            N = j.view.offset, C = q.view.offset, U = j.view.stride, O = j.view.count + q.view.count, E = new ArrayBuffer(O * U), I = new Uint8Array(E), N += (M = this._data.subarray(N, N + j.view.length)).length, C += (B = t._data.subarray(C, C + q.view.length)).length, I.set(M), L = 0;

            for (var J, Q = s(j.attributes); !(J = Q()).done;) {
              var Z = J.value;
              k = 0, z = !1;

              for (var $, Y = s(q.attributes); !($ = Y()).done;) {
                var K = $.value;

                if (Z.name === K.name && Z.format === K.format) {
                  z = !0;
                  break;
                }

                k += b[K.format].size;
              }

              if (z) {
                G = b[Z.format].size, D = j.view.length + L;

                for (var tt = 0; tt < q.view.count; ++tt) {
                  if (P = B.subarray(k, k + G), I.set(P, D), (Z.name === a.ATTR_POSITION || Z.name === a.ATTR_NORMAL) && e) {
                    var et = new Float32Array(I.buffer, D, 3);

                    switch (i.set(et[0], et[1], et[2]), Z.name) {
                      case a.ATTR_POSITION:
                        i.transformMat4(e);
                        break;

                      case a.ATTR_NORMAL:
                        S.transformQuat(i, i, n);
                    }

                    et[0] = i.x, et[1] = i.y, et[2] = i.z;
                  }

                  D += j.view.stride, k += q.view.stride;
                }
              }

              L += b[Z.format].size;
            }

            H[W] = {
              attributes: j.attributes,
              view: {
                offset: R.getLength(),
                length: E.byteLength,
                count: O,
                stride: U
              }
            }, R.addBuffer(E);
          }

          for (var rt, it, st, ht = 0, ft = 2, ct = 0, dt = new Array(this._struct.primitives.length), lt = 0; lt < this._struct.primitives.length; ++lt) {
            var vt = this._struct.primitives[lt],
                _t = t._struct.primitives[lt];
            dt[lt] = {
              primitiveMode: vt.primitiveMode,
              vertexBundelIndices: vt.vertexBundelIndices
            };

            for (var mt, gt = s(vt.vertexBundelIndices); !(mt = gt()).done;) {
              var pt = mt.value;
              ct = Math.max(ct, this._struct.vertexBundles[pt].view.count);
            }

            if (vt.indexView && _t.indexView) {
              ht = vt.indexView.count, ht += _t.indexView.count, N = vt.indexView.offset, C = _t.indexView.offset, ft = ht < 256 ? 1 : ht < 65536 ? 2 : 4;
              var bt = new ArrayBuffer(ht * ft);
              if (rt = 2 === ft ? new Uint16Array(bt) : 1 === ft ? new Uint8Array(bt) : new Uint32Array(bt), it = 2 === vt.indexView.stride ? new Uint16Array(this._data.buffer, N, vt.indexView.count) : 1 === vt.indexView.stride ? new Uint8Array(this._data.buffer, N, vt.indexView.count) : new Uint32Array(this._data.buffer, N, vt.indexView.count), ft === vt.indexView.stride) rt.set(it);else for (var wt = 0; wt < vt.indexView.count; ++wt) {
                rt[wt] = it[wt];
              }
              N += vt.indexView.length, st = 2 === _t.indexView.stride ? new Uint16Array(t._data.buffer, C, _t.indexView.count) : 1 === _t.indexView.stride ? new Uint8Array(t._data.buffer, C, _t.indexView.count) : new Uint32Array(t._data.buffer, C, _t.indexView.count);

              for (var xt = 0; xt < _t.indexView.count; ++xt) {
                rt[vt.indexView.count + xt] = ct + st[xt];
              }

              C += _t.indexView.length, dt[lt].indexView = {
                offset: R.getLength(),
                length: bt.byteLength,
                count: ht,
                stride: ft
              }, R.setNextAlignment(ft), R.addBuffer(bt);
            }
          }

          var Tt = {
            vertexBundles: H,
            primitives: dt,
            minPosition: this._struct.minPosition,
            maxPosition: this._struct.maxPosition
          };
          return Tt.minPosition && t._struct.minPosition && Tt.maxPosition && t._struct.maxPosition && (e ? (S.add(u.center, t._struct.maxPosition, t._struct.minPosition), S.multiplyScalar(u.center, u.center, .5), S.subtract(u.halfExtents, t._struct.maxPosition, t._struct.minPosition), S.multiplyScalar(u.halfExtents, u.halfExtents, .5), V.transform(u, u, e), S.add(i, u.center, u.halfExtents), S.max(Tt.maxPosition, Tt.maxPosition, i), S.subtract(i, u.center, u.halfExtents), S.min(Tt.minPosition, Tt.minPosition, i)) : (S.min(Tt.minPosition, Tt.minPosition, t._struct.minPosition), S.max(Tt.maxPosition, Tt.maxPosition, t._struct.maxPosition))), this.reset({
            struct: Tt,
            data: new Uint8Array(R.getCombined())
          }), this.initialize(), !0;
        }, n.validateMergingMesh = function (t) {
          if (this._struct.vertexBundles.length !== t._struct.vertexBundles.length) return !1;

          for (var e = 0; e < this._struct.vertexBundles.length; ++e) {
            var r = this._struct.vertexBundles[e],
                i = t._struct.vertexBundles[e];
            if (r.attributes.length !== i.attributes.length) return !1;

            for (var n = 0; n < r.attributes.length; ++n) {
              if (r.attributes[n].format !== i.attributes[n].format) return !1;
            }
          }

          if (this._struct.primitives.length !== t._struct.primitives.length) return !1;

          for (var s = 0; s < this._struct.primitives.length; ++s) {
            var a = this._struct.primitives[s],
                u = t._struct.primitives[s];
            if (a.vertexBundelIndices.length !== u.vertexBundelIndices.length) return !1;

            for (var o = 0; o < a.vertexBundelIndices.length; ++o) {
              if (a.vertexBundelIndices[o] !== u.vertexBundelIndices[o]) return !1;
            }

            if (a.primitiveMode !== u.primitiveMode) return !1;

            if (a.indexView) {
              if (void 0 === u.indexView) return !1;
            } else if (u.indexView) return !1;
          }

          return !0;
        }, n.readAttribute = function (t, e) {
          var r = this,
              i = null;
          return this._accessAttribute(t, e, function (t, e) {
            var n = t.view.count,
                s = t.attributes[e].format,
                a = w(b[s]);

            if (0 !== n) {
              var u = new DataView(r._data.buffer, t.view.offset + nt(t.attributes, e)),
                  o = b[s],
                  h = ut(u, s);

              if (a && h) {
                for (var f = o.count, c = new a(n * f), d = t.view.stride, l = 0; l < n; ++l) {
                  for (var v = 0; v < f; ++v) {
                    c[f * l + v] = h(d * l + c.BYTES_PER_ELEMENT * v);
                  }
                }

                i = c;
              }
            }
          }), i;
        }, n.copyAttribute = function (t, e, r, i, n) {
          var s = this,
              a = !1;
          return this._accessAttribute(t, e, function (t, e) {
            var u = t.view.count;

            if (0 !== u) {
              var o = t.attributes[e].format,
                  h = new DataView(s._data.buffer, t.view.offset + nt(t.attributes, e)),
                  f = new DataView(r, n),
                  c = b[o],
                  d = ut(h, o),
                  l = ot(f, o);

              if (d && l) {
                for (var v = c.count, _ = t.view.stride, m = at(o), g = i, p = m, w = 0; w < u; ++w) {
                  for (var x = 0; x < v; ++x) {
                    l(g * w + p * x, d(_ * w + m * x));
                  }
                }

                a = !0;
              }
            } else a = !0;
          }), a;
        }, n.readIndices = function (t) {
          if (t >= this._struct.primitives.length) return null;
          var e = this._struct.primitives[t];
          if (!e.indexView) return null;
          var r = e.indexView.stride;
          return new (1 === r ? Uint8Array : 2 === r ? Uint16Array : Uint32Array)(this._data.buffer, e.indexView.offset, e.indexView.count);
        }, n.copyIndices = function (t, e) {
          if (t >= this._struct.primitives.length) return !1;
          var r = this._struct.primitives[t];
          if (!r.indexView) return !1;

          for (var i = r.indexView.count, n = 1 === r.indexView.stride ? f.R8UI : 2 === r.indexView.stride ? f.R16UI : f.R32UI, s = ut(new DataView(this._data.buffer), n), a = 0; a < i; ++a) {
            e[a] = s(r.indexView.offset + b[n].size * a);
          }

          return !0;
        }, n._accessAttribute = function (t, e, r) {
          if (!(t >= this._struct.primitives.length)) for (var i, n = this._struct.primitives[t], a = s(n.vertexBundelIndices); !(i = a()).done;) {
            var u = i.value,
                o = this._struct.vertexBundles[u],
                h = o.attributes.findIndex(function (t) {
              return t.name === e;
            });

            if (!(h < 0)) {
              r(o, h);
              break;
            }
          }
        }, n._createVertexBuffers = function (t, e) {
          return this._struct.vertexBundles.map(function (r) {
            var i = t.createBuffer(new u(o.VERTEX, h.DEVICE, r.view.length, r.view.stride)),
                n = new Uint8Array(e, r.view.offset, r.view.length);
            return i.update(n), i;
          });
        }, n.initDefault = function (e) {
          t.prototype.initDefault.call(this, e), this.reset({
            struct: {
              vertexBundles: [],
              primitives: []
            },
            data: rt
          });
        }, e(r, [{
          key: "_nativeAsset",
          get: function get() {
            return this._data.buffer;
          },
          set: function set(t) {
            this._data = new Uint8Array(t);
          }
        }, {
          key: "subMeshCount",
          get: function get() {
            var t = this.renderingSubMeshes;
            return t ? t.length : 0;
          }
        }, {
          key: "minPosition",
          get: function get() {
            return this.struct.minPosition;
          }
        }, {
          key: "maxPosition",
          get: function get() {
            return this.struct.maxPosition;
          }
        }, {
          key: "struct",
          get: function get() {
            return this._struct;
          }
        }, {
          key: "data",
          get: function get() {
            return this._data;
          }
        }, {
          key: "hash",
          get: function get() {
            return this._hash || (this._hash = E(this._data, 666)), this._hash;
          }
        }, {
          key: "jointBufferIndices",
          get: function get() {
            return this._jointBufferIndices ? this._jointBufferIndices : this._jointBufferIndices = this._struct.primitives.map(function (t) {
              return t.jointMapIndex || 0;
            });
          }
        }, {
          key: "renderingSubMeshes",
          get: function get() {
            return this.initialize(), this._renderingSubMeshes;
          }
        }]), r;
      }(C), z = x((G = W).prototype, "_struct", [L], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return {
            vertexBundles: [],
            primitives: []
          };
        }
      }), H = x(G.prototype, "_hash", [L], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 0;
        }
      }), k = G)) || k);

      function nt(t, e) {
        for (var r = 0, i = 0; i < e; ++i) {
          var n = t[i];
          r += b[n.format].size;
        }

        return r;
      }

      i.Mesh = it;
      var st = D.isLittleEndian;

      function at(t) {
        var e = b[t];
        return e.size / e.count;
      }

      function ut(t, e) {
        var r = b[e],
            i = r.size / r.count;

        switch (r.type) {
          case T.UNORM:
            switch (i) {
              case 1:
                return function (e) {
                  return t.getUint8(e);
                };

              case 2:
                return function (e) {
                  return t.getUint16(e, st);
                };

              case 4:
                return function (e) {
                  return t.getUint32(e, st);
                };
            }

            break;

          case T.SNORM:
          case T.INT:
            switch (i) {
              case 1:
                return function (e) {
                  return t.getInt8(e);
                };

              case 2:
                return function (e) {
                  return t.getInt16(e, st);
                };

              case 4:
                return function (e) {
                  return t.getInt32(e, st);
                };
            }

            break;

          case T.UINT:
            switch (i) {
              case 1:
                return function (e) {
                  return t.getUint8(e);
                };

              case 2:
                return function (e) {
                  return t.getUint16(e, st);
                };

              case 4:
                return function (e) {
                  return t.getUint32(e, st);
                };
            }

            break;

          case T.FLOAT:
            return function (e) {
              return t.getFloat32(e, st);
            };
        }

        return null;
      }

      function ot(t, e) {
        var r = b[e],
            i = r.size / r.count;

        switch (r.type) {
          case T.UNORM:
            switch (i) {
              case 1:
                return function (e, r) {
                  return t.setUint8(e, r);
                };

              case 2:
                return function (e, r) {
                  return t.setUint16(e, r, st);
                };

              case 4:
                return function (e, r) {
                  return t.setUint32(e, r, st);
                };
            }

            break;

          case T.SNORM:
          case T.INT:
            switch (i) {
              case 1:
                return function (e, r) {
                  return t.setInt8(e, r);
                };

              case 2:
                return function (e, r) {
                  return t.setInt16(e, r, st);
                };

              case 4:
                return function (e, r) {
                  return t.setInt32(e, r, st);
                };
            }

            break;

          case T.UINT:
            switch (i) {
              case 1:
                return function (e, r) {
                  return t.setUint8(e, r);
                };

              case 2:
                return function (e, r) {
                  return t.setUint16(e, r, st);
                };

              case 4:
                return function (e, r) {
                  return t.setUint32(e, r, st);
                };
            }

            break;

          case T.FLOAT:
            return function (e, r) {
              return t.setFloat32(e, r, st);
            };
        }

        return null;
      }
    }
  };
}); 
 			}); 
		define("__plugin__/wx0446ba2621dda60a/mesh-renderer-fb3b7695.js", function(require, module, exports){ 			
"use strict";

System.register(["./texture-barrier-60b5983b.js", "./json-asset-933a1d4c.js", "./renderable-component-7c6600ed.js", "./mesh-f5415e9d.js"], function (t) {
  "use strict";

  var e, i, s, a, o, n, h, r, l, d, u, p, c, _, m, g, b, S, f, w, y, M, v, B, O, P, I, R;

  return {
    setters: [function (t) {
      e = t.bT, i = t.bv, s = t.bU, a = t.c0, o = t.bF, n = t.l, h = t.bW, r = t.c1, l = t.b$;
    }, function (t) {
      d = t.bW, u = t.b$, p = t.bZ, c = t.dk, _ = t.cd, m = t.ce, g = t.bo, b = t.dr, S = t.bX, f = t.T, w = t.cg, y = t.ds, M = t.ch, v = t.cc, B = t.ci, O = t.dl;
    }, function (t) {
      P = t.f, I = t.p;
    }, function (t) {
      R = t.M;
    }],
    execute: function execute() {
      var z,
          W,
          C,
          N,
          k,
          D,
          F,
          L,
          j,
          T,
          U,
          x,
          A,
          E,
          H,
          V,
          $,
          q,
          X,
          Z,
          G,
          J,
          K,
          Q,
          Y,
          tt,
          et,
          it,
          st,
          at,
          ot,
          nt,
          ht,
          rt,
          lt,
          dt,
          ut,
          pt,
          ct,
          _t,
          mt,
          gt = t("a", function (t) {
        function i() {
          for (var e, i = arguments.length, s = new Array(i), a = 0; a < i; a++) {
            s[a] = arguments[a];
          }

          return (e = t.call.apply(t, [this].concat(s)) || this)._morphRenderingInstance = null, e._usedMaterials = new Set(), e;
        }

        e(i, t);
        var s = i.prototype;
        return s.getMacroPatches = function (e) {
          var i = t.prototype.getMacroPatches.call(this, e);

          if (this._morphRenderingInstance) {
            var s = this._morphRenderingInstance.requiredPatches(e);

            if (s) return s.concat(null != i ? i : []);
          }

          return i;
        }, s.initSubModel = function (e, i, s) {
          return t.prototype.initSubModel.call(this, e, i, this._launderMaterial(s));
        }, s.destroy = function () {
          t.prototype.destroy.call(this), this._morphRenderingInstance = null;
        }, s.setSubModelMaterial = function (e, i) {
          return t.prototype.setSubModelMaterial.call(this, e, this._launderMaterial(i));
        }, s.setMorphRendering = function (t) {
          this._morphRenderingInstance = t;
        }, s._updateLocalDescriptors = function (e, i) {
          t.prototype._updateLocalDescriptors.call(this, e, i), this._morphRenderingInstance && this._morphRenderingInstance.adaptPipelineState(e, i);
        }, s._launderMaterial = function (t) {
          return t;
        }, i;
      }(P)),
          bt = i({
        OFF: 0,
        ON: 1
      }),
          St = i({
        OFF: 0,
        ON: 1
      }),
          ft = (z = d("cc.ModelLightmapSettings"), W = O("_recieveShadow"), z((U = function () {
        function t() {
          r(this, "texture", k, this), r(this, "uvParam", D, this), r(this, "_bakeable", F, this), r(this, "_castShadow", L, this), r(this, "_receiveShadow", j, this), r(this, "_lightmapSize", T, this);
        }

        return s(t, [{
          key: "bakeable",
          get: function get() {
            return this._bakeable;
          },
          set: function set(t) {
            this._bakeable = t;
          }
        }, {
          key: "castShadow",
          get: function get() {
            return this._castShadow;
          },
          set: function set(t) {
            this._castShadow = t;
          }
        }, {
          key: "receiveShadow",
          get: function get() {
            return this._receiveShadow;
          },
          set: function set(t) {
            this._receiveShadow = t;
          }
        }, {
          key: "lightmapSize",
          get: function get() {
            return this._lightmapSize;
          },
          set: function set(t) {
            this._lightmapSize = t;
          }
        }]), t;
      }(), k = a((N = U).prototype, "texture", [S], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return null;
        }
      }), D = a(N.prototype, "uvParam", [S], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return new f();
        }
      }), F = a(N.prototype, "_bakeable", [S], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !1;
        }
      }), L = a(N.prototype, "_castShadow", [S], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !1;
        }
      }), j = a(N.prototype, "_receiveShadow", [W], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !1;
        }
      }), T = a(N.prototype, "_lightmapSize", [S], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 64;
        }
      }), a(N.prototype, "bakeable", [u], Object.getOwnPropertyDescriptor(N.prototype, "bakeable"), N.prototype), a(N.prototype, "castShadow", [u], Object.getOwnPropertyDescriptor(N.prototype, "castShadow"), N.prototype), a(N.prototype, "receiveShadow", [u], Object.getOwnPropertyDescriptor(N.prototype, "receiveShadow"), N.prototype), a(N.prototype, "lightmapSize", [u], Object.getOwnPropertyDescriptor(N.prototype, "lightmapSize"), N.prototype), C = N)) || C);

      t("M", (x = d("cc.MeshRenderer"), A = w(), E = y(100), H = M(), V = p(o), $ = v(), q = c({
        group: {
          name: "DynamicShadowSettings",
          displayOrder: 0
        }
      }), X = p(o), Z = v(), G = c({
        group: {
          name: "DynamicShadowSettings",
          displayOrder: 1
        }
      }), J = p(bt), K = v(), Q = c({
        group: {
          name: "DynamicShadowSettings",
          displayOrder: 2
        }
      }), Y = p(St), tt = v(), et = c({
        group: {
          name: "DynamicShadowSettings",
          displayOrder: 3
        }
      }), it = p(R), st = v(), at = B(), x(ot = A(ot = E(ot = H(ot = _((mt = _t = function (t) {
        function i() {
          var e;
          return e = t.call(this) || this, r(e, "lightmapSettings", ht, l(e)), r(e, "_mesh", rt, l(e)), r(e, "_shadowCastingMode", lt, l(e)), r(e, "_shadowReceivingMode", dt, l(e)), r(e, "_shadowBias", ut, l(e)), r(e, "_shadowNormalBias", pt, l(e)), e._subMeshShapesWeights = [], e._modelType = void 0, e._model = null, e._morphInstance = null, r(e, "_enableMorph", ct, l(e)), e._modelType = P, e;
        }

        e(i, t);
        var a = i.prototype;
        return a.onLoad = function () {
          this._mesh && this._mesh.initialize(), this._validateShapeWeights() || this._initSubMeshShapesWeights(), this._watchMorphInMesh(), this._updateModels(), this._updateCastShadow(), this._updateReceiveShadow(), this._updateShadowBias(), this._updateShadowNormalBias();
        }, a.onRestore = function () {
          this._updateModels(), this.enabledInHierarchy && this._attachToScene(), this._updateCastShadow(), this._updateReceiveShadow(), this._updateShadowBias(), this._updateShadowNormalBias();
        }, a.onEnable = function () {
          this._model || this._updateModels(), this._updateCastShadow(), this._updateReceiveShadow(), this._updateShadowBias(), this._updateShadowNormalBias(), this._onUpdateLocalShadowBias(), this._attachToScene();
        }, a.onDisable = function () {
          this._model && this._detachFromScene();
        }, a.onDestroy = function () {
          this._model && (n.director.root.destroyModel(this._model), this._model = null, this._models.length = 0), this._morphInstance && this._morphInstance.destroy();
        }, a.getWeight = function (t, e) {
          var i = this._subMeshShapesWeights;
          h(t < i.length);
          var s = this._subMeshShapesWeights[t];
          return h(e < s.length), s[e];
        }, a.setWeights = function (t, e) {
          var i = this._subMeshShapesWeights;
          e >= i.length || i[e].length === t.length && (i[e] = t.slice(0), this._uploadSubMeshShapesWeights(e));
        }, a.setWeight = function (t, e, i) {
          var s = this._subMeshShapesWeights;

          if (!(e >= s.length)) {
            var a = s[e];
            i >= a.length || (a[i] = t, this._uploadSubMeshShapesWeights(e));
          }
        }, a.setInstancedAttribute = function (t, e) {
          if (this.model) for (var i = this.model.instancedAttributes, s = i.attributes, a = i.views, o = 0; o < s.length; o++) {
            if (s[o].name === t) {
              a[o].set(e);
              break;
            }
          }
        }, a._updateLightmap = function (t, e, i, s, a) {
          this.lightmapSettings.texture = t, this.lightmapSettings.uvParam.x = e, this.lightmapSettings.uvParam.y = i, this.lightmapSettings.uvParam.z = s, this.lightmapSettings.uvParam.w = a, this._onUpdateLightingmap();
        }, a._updateModels = function () {
          if (this.enabledInHierarchy) {
            var t = this._model;
            t ? (t.destroy(), t.initialize(), t.node = t.transform = this.node) : this._createModel(), this._model && (this._mesh && this._model.createBoundingShape(this._mesh.struct.minPosition, this._mesh.struct.maxPosition), this._updateModelParams(), this._onUpdateLightingmap(), this._onUpdateLocalShadowBias());
          }
        }, a._createModel = function () {
          var t = this._morphInstance && this._modelType === P ? gt : this._modelType,
              e = this._model = n.director.root.createModel(t);
          e.visFlags = this.visibility, e.node = e.transform = this.node, this._models.length = 0, this._models.push(this._model), this._morphInstance && e instanceof gt && e.setMorphRendering(this._morphInstance);
        }, a._attachToScene = function () {
          if (this.node.scene && this._model) {
            var t = this._getRenderScene();

            null !== this._model.scene && this._detachFromScene(), t.addModel(this._model);
          }
        }, a._detachFromScene = function () {
          this._model && this._model.scene && this._model.scene.removeModel(this._model);
        }, a._updateModelParams = function () {
          if (this._mesh && this._model) {
            this.node.hasChangedFlags |= m.POSITION, this._model.transform.hasChangedFlags |= m.POSITION, this._model.isDynamicBatching = this._isBatchingEnabled();
            var t = this._mesh ? this._mesh.renderingSubMeshes.length : 0,
                e = this._mesh.renderingSubMeshes;
            if (e) for (var i = 0; i < t; ++i) {
              var s = this.getRenderMaterial(i);
              s && !s.isValid && (s = null);
              var a = e[i];
              a && this._model.initSubModel(i, a, s || this._getBuiltinMaterial());
            }
            this._model.enabled = !0;
          }
        }, a._onUpdateLightingmap = function () {
          null !== this.model && this.model.updateLightingmap(this.lightmapSettings.texture, this.lightmapSettings.uvParam), this.setInstancedAttribute("a_lightingMapUVParam", [this.lightmapSettings.uvParam.x, this.lightmapSettings.uvParam.y, this.lightmapSettings.uvParam.z, this.lightmapSettings.uvParam.w]);
        }, a._onUpdateLocalShadowBias = function () {
          null !== this.model && this.model.updateLocalShadowBias(), this.setInstancedAttribute("a_localShadowBias", [this._shadowBias, this._shadowNormalBias]);
        }, a._onMaterialModified = function (t, e) {
          this._model && this._model.inited && this._onRebuildPSO(t, e || this._getBuiltinMaterial());
        }, a._onRebuildPSO = function (t, e) {
          this._model && this._model.inited && (this._model.isDynamicBatching = this._isBatchingEnabled(), this._model.setSubModelMaterial(t, e), this._onUpdateLightingmap(), this._onUpdateLocalShadowBias());
        }, a._onMeshChanged = function () {}, a._clearMaterials = function () {
          if (this._model) for (var t = this._model.subModels, e = 0; e < t.length; ++e) {
            this._onMaterialModified(e, null);
          }
        }, a._getBuiltinMaterial = function () {
          return g.get("missing-material");
        }, a._onVisibilityChange = function (t) {
          this._model && (this._model.visFlags = t);
        }, a._updateShadowBias = function () {
          this._model && (this._model.shadowBias = this._shadowBias);
        }, a._updateShadowNormalBias = function () {
          this._model && (this._model.shadowNormalBias = this._shadowNormalBias);
        }, a._updateCastShadow = function () {
          this._model && (this._shadowCastingMode === bt.OFF ? this._model.castShadow = !1 : (h(this._shadowCastingMode === bt.ON, "ShadowCastingMode " + this._shadowCastingMode + " is not supported."), this._model.castShadow = !0));
        }, a._updateReceiveShadow = function () {
          this._model && (this._shadowReceivingMode === St.OFF ? this._model.receiveShadow = !1 : this._model.receiveShadow = !0);
        }, a._isBatchingEnabled = function () {
          for (var t = 0; t < this._materials.length; ++t) {
            var e = this._materials[t];
            if (e) for (var i = 0; i < e.passes.length; ++i) {
              if (e.passes[i].batchingScheme) return !0;
            }
          }

          return !1;
        }, a._watchMorphInMesh = function () {
          if (this._morphInstance && (this._morphInstance.destroy(), this._morphInstance = null), this._enableMorph && this._mesh && this._mesh.struct.morph && this._mesh.morphRendering) {
            this._morphInstance = this._mesh.morphRendering.createInstance();

            for (var t = this._mesh.struct.primitives.length, e = 0; e < t; ++e) {
              this._uploadSubMeshShapesWeights(e);
            }

            this._model && this._model instanceof gt && this._model.setMorphRendering(this._morphInstance);
          }
        }, a._initSubMeshShapesWeights = function () {
          var t = this._mesh;

          if (this._subMeshShapesWeights.length = 0, t) {
            var e = t.struct.morph;

            if (e) {
              var i = e.weights;
              this._subMeshShapesWeights = e.subMeshMorphs.map(function (t) {
                return t ? t.weights ? t.weights.slice(0) : i ? (h(i.length === t.targets.length), i.slice(0)) : new Array(t.targets.length).fill(0) : [];
              });
            }
          }
        }, a._validateShapeWeights = function () {
          var t = this._mesh,
              e = this._subMeshShapesWeights;
          if (!t || !t.struct.morph) return 0 === e.length;
          var i = t.struct.morph;
          return i.subMeshMorphs.length === e.length && e.every(function (t, e) {
            var s,
                a,
                o = t.length;
            return (null !== (s = null === (a = i.subMeshMorphs[e]) || void 0 === a ? void 0 : a.targets.length) && void 0 !== s ? s : 0) === o;
          });
        }, a._uploadSubMeshShapesWeights = function (t) {
          var e;
          null === (e = this._morphInstance) || void 0 === e || e.setWeights(t, this._subMeshShapesWeights[t]);
        }, s(i, [{
          key: "shadowBias",
          get: function get() {
            return this._shadowBias;
          },
          set: function set(t) {
            this._shadowBias = t, this._updateShadowBias(), this._onUpdateLocalShadowBias();
          }
        }, {
          key: "shadowNormalBias",
          get: function get() {
            return this._shadowNormalBias;
          },
          set: function set(t) {
            this._shadowNormalBias = t, this._updateShadowNormalBias(), this._onUpdateLocalShadowBias();
          }
        }, {
          key: "shadowCastingMode",
          get: function get() {
            return this._shadowCastingMode;
          },
          set: function set(t) {
            this._shadowCastingMode = t, this._updateCastShadow();
          }
        }, {
          key: "receiveShadow",
          get: function get() {
            return this._shadowReceivingMode;
          },
          set: function set(t) {
            this._shadowReceivingMode = t, this._updateReceiveShadow();
          }
        }, {
          key: "mesh",
          get: function get() {
            return this._mesh;
          },
          set: function set(t) {
            var e = this._mesh,
                i = this._mesh = t;
            null == i || i.initialize(), this._initSubMeshShapesWeights(), this._watchMorphInMesh(), this._onMeshChanged(e), this._updateModels(), this.enabledInHierarchy && this._attachToScene(), this._updateCastShadow(), this._updateReceiveShadow();
          }
        }, {
          key: "model",
          get: function get() {
            return this._model;
          }
        }, {
          key: "enableMorph",
          get: function get() {
            return this._enableMorph;
          },
          set: function set(t) {
            this._enableMorph = t;
          }
        }]), i;
      }(I), _t.ShadowCastingMode = bt, _t.ShadowReceivingMode = St, ht = a((nt = mt).prototype, "lightmapSettings", [S, u, b], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return new ft();
        }
      }), rt = a(nt.prototype, "_mesh", [S], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return null;
        }
      }), lt = a(nt.prototype, "_shadowCastingMode", [S], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return bt.OFF;
        }
      }), dt = a(nt.prototype, "_shadowReceivingMode", [S], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return St.ON;
        }
      }), ut = a(nt.prototype, "_shadowBias", [S], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 0;
        }
      }), pt = a(nt.prototype, "_shadowNormalBias", [S], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 0;
        }
      }), a(nt.prototype, "shadowBias", [V, $, q, b], Object.getOwnPropertyDescriptor(nt.prototype, "shadowBias"), nt.prototype), a(nt.prototype, "shadowNormalBias", [X, Z, G, b], Object.getOwnPropertyDescriptor(nt.prototype, "shadowNormalBias"), nt.prototype), a(nt.prototype, "shadowCastingMode", [J, K, Q, b], Object.getOwnPropertyDescriptor(nt.prototype, "shadowCastingMode"), nt.prototype), a(nt.prototype, "receiveShadow", [Y, tt, et, b], Object.getOwnPropertyDescriptor(nt.prototype, "receiveShadow"), nt.prototype), a(nt.prototype, "mesh", [it, st], Object.getOwnPropertyDescriptor(nt.prototype, "mesh"), nt.prototype), a(nt.prototype, "enableMorph", [at, b], Object.getOwnPropertyDescriptor(nt.prototype, "enableMorph"), nt.prototype), ct = a(nt.prototype, "_enableMorph", [S], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !0;
        }
      }), ot = nt)) || ot) || ot) || ot) || ot) || ot));
    }
  };
}); 
 			}); 
		define("__plugin__/wx0446ba2621dda60a/particle-2d.js", function(require, module, exports){ 			
"use strict";

System.register(["./texture-barrier-60b5983b.js", "./json-asset-933a1d4c.js", "./index-f2b92470.js", "./renderable-component-7c6600ed.js", "./deprecated-26630860.js", "./deprecated-ef6bb945.js", "./sprite-frame-1edab3eb.js", "./renderable-2d-e2838949.js", "./deprecated-5f7f37d5.js", "./ZipUtils-3ae2be0b.js"], function (t) {
  "use strict";

  var e, r, i, a, n, s, o, l, h, p, u, c, d, f, m, y, g, b, _, v, S, w, C, F, P, D, T, A, R, x, V, I, O, z, E, M, U, k, L, N, B, G, j, W;

  return {
    setters: [function (t) {
      e = t.bv, r = t.bT, i = t.cf, a = t.cN, n = t.cU, s = t.cV, o = t.c0, l = t.l, h = t.c1, p = t.b$, u = t.bO, c = t.c, d = t.f, f = t.e, m = t.d, y = t.G, g = t.bU;
    }, function (t) {
      b = t.V, _ = t.a5, v = t.bW, S = t.aL, w = t.bX, C = t.b$, F = t.bZ, P = t.e1, D = t.cd, T = t.a, A = t.bo, R = t.aS, x = t.ch, V = t.bY, I = t.cc, O = t.ci, z = t.dl, E = t.aT, M = t.cg;
    }, function (t) {
      U = t.a;
    }, function () {}, function () {}, function () {}, function (t) {
      k = t.S;
    }, function (t) {
      L = t.e, N = t.f, B = t.R, G = t.M;
    }, function () {}, function (t) {
      j = t._, W = t.c;
    }],
    execute: function execute() {
      var Y,
          H,
          X,
          Z,
          q = e({
        GRAVITY: 0,
        RADIUS: 1
      }),
          J = e({
        FREE: 0,
        RELATIVE: 1,
        GROUPED: 2
      }),
          K = new b(0, 0),
          Q = new b(),
          $ = new b(),
          tt = new b(),
          et = new b(),
          rt = L(N),
          it = function it() {
        this.pos = new b(0, 0), this.startPos = new b(0, 0), this.color = new _(0, 0, 0, 255), this.deltaColor = {
          r: 0,
          g: 0,
          b: 0,
          a: 255
        }, this.size = 0, this.deltaSize = 0, this.rotation = 0, this.deltaRotation = 0, this.timeToLive = 0, this.drawPos = new b(0, 0), this.aspectRatio = 1, this.dir = new b(0, 0), this.radialAccel = 0, this.tangentialAccel = 0, this.angle = 0, this.degreesPerSecond = 0, this.radius = 0, this.deltaRadius = 0;
      },
          at = new (function (t) {
        function e() {
          return t.apply(this, arguments) || this;
        }

        return r(e, t), e.prototype.get = function () {
          return this._get() || new it();
        }, e;
      }(i))(function (t) {
        t.pos.set(K), t.startPos.set(K), t.color._val = 4278190080, t.deltaColor.r = t.deltaColor.g = t.deltaColor.b = 0, t.deltaColor.a = 255, t.size = 0, t.deltaSize = 0, t.rotation = 0, t.deltaRotation = 0, t.timeToLive = 0, t.drawPos.set(K), t.aspectRatio = 1, t.dir.set(K), t.radialAccel = 0, t.tangentialAccel = 0, t.angle = 0, t.degreesPerSecond = 0, t.radius = 0, t.deltaRadius = 0;
      }, 1024),
          nt = function () {
        function t(t) {
          this.particles = [], this.active = !1, this.uvFilled = 0, this.finished = !1, this.readyToPlay = !0, this.elapsed = 0, this.emitCounter = 0, this._worldRotation = 0, this.sys = t, this.particles = [], this.active = !1, this.readyToPlay = !0, this.finished = !1, this.elapsed = 0, this.emitCounter = 0, this.uvFilled = 0, this._worldRotation = 0;
        }

        var e = t.prototype;
        return e.stop = function () {
          this.active = !1, this.readyToPlay = !1, this.elapsed = this.sys.duration, this.emitCounter = 0;
        }, e.reset = function () {
          this.active = !0, this.readyToPlay = !0, this.elapsed = 0, this.emitCounter = 0, this.finished = !1;

          for (var t = this.particles, e = 0; e < t.length; ++e) {
            at.put(t[e]);
          }

          t.length = 0;
        }, e.emitParticle = function (t) {
          var e = this.sys,
              r = at.get();
          this.particles.push(r), r.timeToLive = e.life + e.lifeVar * (Math.random() - .5) * 2;
          var i = r.timeToLive = Math.max(0, r.timeToLive);
          r.pos.x = e.sourcePos.x + e.posVar.x * (Math.random() - .5) * 2, r.pos.y = e.sourcePos.y + e.posVar.y * (Math.random() - .5) * 2;
          var o,
              l,
              h,
              p,
              u = e.startColor,
              c = e.startColorVar,
              d = e.endColor,
              f = e.endColorVar;
          r.color.r = o = a(u.r + c.r * (Math.random() - .5) * 2, 0, 255), r.color.g = l = a(u.g + c.g * (Math.random() - .5) * 2, 0, 255), r.color.b = h = a(u.b + c.b * (Math.random() - .5) * 2, 0, 255), r.color.a = p = a(u.a + c.a * (Math.random() - .5) * 2, 0, 255), r.deltaColor.r = (a(d.r + f.r * (Math.random() - .5) * 2, 0, 255) - o) / i, r.deltaColor.g = (a(d.g + f.g * (Math.random() - .5) * 2, 0, 255) - l) / i, r.deltaColor.b = (a(d.b + f.b * (Math.random() - .5) * 2, 0, 255) - h) / i, r.deltaColor.a = (a(d.a + f.a * (Math.random() - .5) * 2, 0, 255) - p) / i;
          var m = e.startSize + e.startSizeVar * (Math.random() - .5) * 2;
          if (m = Math.max(0, m), r.size = m, -1 === e.endSize) r.deltaSize = 0;else {
            var y = e.endSize + e.endSizeVar * (Math.random() - .5) * 2;
            y = Math.max(0, y), r.deltaSize = (y - m) / i;
          }
          var g = e.startSpin + e.startSpinVar * (Math.random() - .5) * 2,
              b = e.endSpin + e.endSpinVar * (Math.random() - .5) * 2;
          r.rotation = g, r.deltaRotation = (b - g) / i, r.startPos.x = t.x, r.startPos.y = t.y, r.aspectRatio = e.aspectRatio || 1;

          var _ = n(e.angle + this._worldRotation + e.angleVar * (Math.random() - .5) * 2);

          if (e.emitterMode === q.GRAVITY) {
            var v = e.speed + e.speedVar * (Math.random() - .5) * 2;
            r.dir.x = Math.cos(_), r.dir.y = Math.sin(_), r.dir.multiplyScalar(v), r.radialAccel = e.radialAccel + e.radialAccelVar * (Math.random() - .5) * 2, r.tangentialAccel = e.tangentialAccel + e.tangentialAccelVar * (Math.random() - .5) * 2, e.rotationIsDir && (r.rotation = -s(Math.atan2(r.dir.y, r.dir.x)));
          } else {
            var S = e.startRadius + e.startRadiusVar * (Math.random() - .5) * 2,
                w = e.endRadius + e.endRadiusVar * (Math.random() - .5) * 2;
            r.radius = S, r.deltaRadius = -1 === e.endRadius ? 0 : (w - S) / i, r.angle = _, r.degreesPerSecond = n(e.rotatePerS + e.rotatePerSVar * (Math.random() - .5) * 2);
          }
        }, e.updateUVs = function (t) {
          var e = this.renderData;

          if (e && this.sys._renderSpriteFrame) {
            for (var r = e.vData, i = this.sys._renderSpriteFrame.uv, a = t ? 0 : this.uvFilled, n = this.particles.length, s = a; s < n; s++) {
              var o = s * rt * 4;
              r[o + 3] = i[0], r[o + 4] = i[1], r[o + 12] = i[2], r[o + 13] = i[3], r[o + 21] = i[4], r[o + 22] = i[5], r[o + 30] = i[6], r[o + 31] = i[7];
            }

            this.uvFilled = n;
          }
        }, e.updateParticleBuffer = function (t, e, r, i) {
          var a = r.vData,
              s = e.x,
              o = e.y,
              l = t.size,
              h = l,
              p = t.aspectRatio;
          p > 1 ? h = l / p : l = h * p;
          var u = l / 2,
              c = h / 2;

          if (t.rotation) {
            var d = -u,
                f = -c,
                m = u,
                y = c,
                g = -n(t.rotation),
                b = Math.cos(g),
                v = Math.sin(g);
            a[i] = d * b - f * v + s, a[i + 1] = d * v + f * b + o, a[i + 2] = 0, a[i + 9] = m * b - f * v + s, a[i + 10] = m * v + f * b + o, a[i + 11] = 0, a[i + 18] = d * b - y * v + s, a[i + 19] = d * v + y * b + o, a[i + 20] = 0, a[i + 27] = m * b - y * v + s, a[i + 28] = m * v + y * b + o, a[i + 29] = 0;
          } else a[i] = s - u, a[i + 1] = o - c, a[i + 2] = 0, a[i + 9] = s + u, a[i + 10] = o - c, a[i + 11] = 0, a[i + 18] = s - u, a[i + 19] = o + c, a[i + 20] = 0, a[i + 27] = s + u, a[i + 28] = o + c, a[i + 29] = 0;

          _.toArray(a, t.color, i + 5), _.toArray(a, t.color, i + 14), _.toArray(a, t.color, i + 23), _.toArray(a, t.color, i + 32);
        }, e.step = function (t) {
          var e = this.sys.assembler,
              r = this.sys,
              i = r.node,
              a = this.particles;

          if (t = t > e.maxParticleDeltaTime ? e.maxParticleDeltaTime : t, i.updateWorldTransform(), r.positionType === J.FREE) {
            this._worldRotation = function (t) {
              for (var e = 0, r = t; r;) {
                e += r.eulerAngles.z, r = r.parent;
              }

              return e;
            }(i);

            var n = i.worldMatrix;
            Q.x = n.m12, Q.y = n.m13;
          } else r.positionType === J.RELATIVE ? (this._worldRotation = i.eulerAngles.z, Q.x = i.position.x, Q.y = i.position.y) : this._worldRotation = 0;

          if (this.active && r.emissionRate) {
            var s = 1 / r.emissionRate;

            for (a.length < r.totalParticles && (this.emitCounter += t); a.length < r.totalParticles && this.emitCounter > s;) {
              this.emitParticle(Q), this.emitCounter -= s;
            }

            this.elapsed += t, -1 !== r.duration && r.duration < this.elapsed && r.stopSystem();
          }

          var o = this.renderData,
              l = a.length;
          o.reset(), this.requestData(4 * l, 6 * l), l > this.uvFilled && this.updateUVs();

          for (var h = 0; h < a.length;) {
            $.x = $.y = tt.x = tt.y = et.x = et.y = 0;
            var p = a[h];

            if (p.timeToLive -= t, p.timeToLive > 0) {
              if (r.emitterMode === q.GRAVITY) {
                var u = et,
                    c = $,
                    d = tt;
                (p.pos.x || p.pos.y) && (c.set(p.pos), c.normalize()), d.set(c), c.multiplyScalar(p.radialAccel);
                var f = d.x;
                d.x = -d.y, d.y = f, d.multiplyScalar(p.tangentialAccel), u.set(c), u.add(d), u.add(r.gravity), u.multiplyScalar(t), p.dir.add(u), u.set(p.dir), u.multiplyScalar(t), p.pos.add(u);
              } else p.angle += p.degreesPerSecond * t, p.radius += p.deltaRadius * t, p.pos.x = -Math.cos(p.angle) * p.radius, p.pos.y = -Math.sin(p.angle) * p.radius;

              p.color.r += p.deltaColor.r * t, p.color.g += p.deltaColor.g * t, p.color.b += p.deltaColor.b * t, p.color.a += p.deltaColor.a * t, p.size += p.deltaSize * t, p.size < 0 && (p.size = 0), p.rotation += p.deltaRotation * t;
              var m = $;
              m.set(p.pos), r.positionType !== J.GROUPED && m.add(p.startPos);
              var y = rt * h * 4;
              this.updateParticleBuffer(p, m, o, y), ++h;
            } else {
              var g = a[h];
              h !== a.length - 1 && (a[h] = a[a.length - 1]), at.put(g), a.length--, o.resize(o.vertexCount - 4, o.indexCount - 6);
            }
          }

          0 !== a.length || this.active || this.readyToPlay || (this.finished = !0, r._finishedSimulation());
        }, e.requestData = function (t, e) {
          var r = this.renderData.indexCount;
          this.renderData.request(t, e);

          for (var i = this.renderData.indexCount / 6, a = this.renderData.iData, n = r; n < i; n++) {
            var s = 4 * n;
            a[r++] = s, a[r++] = s + 1, a[r++] = s + 2, a[r++] = s + 1, a[r++] = s + 3, a[r++] = s + 2;
          }
        }, t;
      }(),
          st = t("ParticleAsset", v("cc.ParticleAsset")((Z = function (t) {
        function e() {
          for (var e, r = arguments.length, i = new Array(r), a = 0; a < r; a++) {
            i[a] = arguments[a];
          }

          return e = t.call.apply(t, [this].concat(i)) || this, h(e, "spriteFrame", X, p(e)), e;
        }

        return r(e, t), e;
      }(S), X = o((H = Z).prototype, "spriteFrame", [w, C], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return null;
        }
      }), Y = H)) || Y);

      l.ParticleAsset = st;

      var ot,
          lt,
          ht,
          pt,
          ut,
          ct,
          dt,
          ft,
          mt,
          yt,
          gt,
          bt,
          _t,
          vt,
          St,
          wt,
          Ct,
          Ft,
          Pt,
          Dt,
          Tt,
          At,
          Rt,
          xt,
          Vt,
          It,
          Ot,
          zt,
          Et,
          Mt,
          Ut,
          kt,
          Lt,
          Nt,
          Bt,
          Gt,
          jt,
          Wt,
          Yt,
          Ht,
          Xt,
          Zt,
          qt,
          Jt,
          Kt,
          Qt,
          $t,
          te,
          ee,
          re,
          ie,
          ae,
          ne,
          se,
          oe,
          le,
          he,
          pe,
          ue,
          ce,
          de,
          fe,
          me,
          ye,
          ge,
          be,
          _e,
          ve,
          Se,
          we,
          Ce,
          Fe,
          Pe,
          De,
          Te,
          Ae,
          Re,
          xe,
          Ve,
          Ie,
          Oe,
          ze,
          Ee,
          Me,
          Ue,
          ke,
          Le,
          Ne,
          Be,
          Ge,
          je,
          We,
          Ye,
          He,
          Xe,
          Ze,
          qe,
          Je,
          Ke,
          Qe,
          $e,
          tr,
          er,
          rr = function () {
        function t(t) {
          var e,
              r = this;
          this.pos = 8, this.palette = [], this.imgData = [], this.text = {}, this.width = 0, this.height = 0, this.bits = 0, this.colorType = 0, this.compressionMethod = 0, this.filterMethod = 0, this.interlaceMethod = 0, this.colors = 0, this.hasAlphaChannel = !1, this.pixelBitlength = 0, this.data = t, this.transparency = {
            indexed: [],
            rgb: 0,
            grayscale: 0
          };

          for (var i = 0, a = 0, n = 0;;) {
            n = this.readUInt32();

            var s = function () {
              var t = [];

              for (i = 0; i < 4; ++i) {
                t.push(String.fromCharCode(r.data[r.pos++]));
              }

              return t;
            }.call(this).join("");

            switch (s) {
              case "IHDR":
                this.width = this.readUInt32(), this.height = this.readUInt32(), this.bits = this.data[this.pos++], this.colorType = this.data[this.pos++], this.compressionMethod = this.data[this.pos++], this.filterMethod = this.data[this.pos++], this.interlaceMethod = this.data[this.pos++];
                break;

              case "acTL":
                this.animation = {
                  numFrames: this.readUInt32(),
                  numPlays: this.readUInt32() || 1 / 0,
                  frames: []
                };
                break;

              case "PLTE":
                this.palette = this.read(n);
                break;

              case "fcTL":
                e && this.animation.frames.push(e), this.pos += 4, e = {
                  width: this.readUInt32(),
                  height: this.readUInt32(),
                  xOffset: this.readUInt32(),
                  yOffset: this.readUInt32()
                };
                var o = this.readUInt16(),
                    l = this.readUInt16() || 100;
                e.delay = 1e3 * o / l, e.disposeOp = this.data[this.pos++], e.blendOp = this.data[this.pos++], e.data = [];
                break;

              case "IDAT":
              case "fdAT":
                for ("fdAT" === s && (this.pos += 4, n -= 4), t = (null != e ? e.data : void 0) || this.imgData, i = 0; n >= 0 ? i < n : i > n; n >= 0 ? ++i : --i) {
                  t.push(this.data[this.pos++]);
                }

                break;

              case "tRNS":
                switch (this.transparency = {}, this.colorType) {
                  case 3:
                    this.transparency.indexed = this.read(n);
                    var h = 255 - this.transparency.indexed.length;
                    if (h > 0) for (a = 0; h >= 0 ? a < h : a > h; h >= 0 ? ++a : --a) {
                      this.transparency.indexed.push(255);
                    }
                    break;

                  case 0:
                    this.transparency.grayscale = this.read(n)[0];
                    break;

                  case 2:
                    this.transparency.rgb = this.read(n);
                }

                break;

              case "tEXt":
                var p = this.read(n),
                    c = p.indexOf(0),
                    d = String.fromCharCode.apply(String, p.slice(0, c));
                this.text[d] = String.fromCharCode.apply(String, p.slice(c + 1));
                break;

              case "IEND":
                e && this.animation.frames.push(e), this.colors = function () {
                  switch (r.colorType) {
                    case 0:
                    case 3:
                    case 4:
                      return 1;

                    case 2:
                    case 6:
                      return 3;
                  }
                }.call(this);
                var f = this.colorType;
                this.hasAlphaChannel = 4 === f || 6 === f;
                var m = this.colors + (this.hasAlphaChannel ? 1 : 0);
                return this.pixelBitlength = this.bits * m, this.colorSpace = function () {
                  switch (r.colors) {
                    case 1:
                      return "DeviceGray";

                    case 3:
                      return "DeviceRGB";
                  }
                }.call(this), void (this.imgData instanceof Uint8Array || (this.imgData = new Uint8Array(this.imgData)));

              default:
                this.pos += n;
            }

            if (this.pos += 4, this.pos > this.data.length) throw new Error(u(6017));
          }
        }

        var e = t.prototype;
        return e.read = function (t) {
          var e = 0,
              r = [];

          for (e = 0; t >= 0 ? e < t : e > t; t >= 0 ? ++e : --e) {
            r.push(this.data[this.pos++]);
          }

          return r;
        }, e.readUInt32 = function () {
          return this.data[this.pos++] << 24 | this.data[this.pos++] << 16 | this.data[this.pos++] << 8 | this.data[this.pos++];
        }, e.readUInt16 = function () {
          return this.data[this.pos++] << 8 | this.data[this.pos++];
        }, e.decodePixels = function (t) {
          if (null == t && (t = this.imgData), 0 === t.length) return new Uint8Array(0);
          t = new j.Inflate(t, {
            index: 0,
            verify: !1
          }).decompress();

          for (var e = this.pixelBitlength / 8, r = e * this.width, i = new Uint8Array(r * this.height), a = t.length, n = 0, s = 0, o = 0, l = 0, h = 0, p = 0, c = 0, d = 0, f = 0, m = 0, y = 0, g = 0, b = 0, _ = 0, v = 0, S = 0, w = 0, C = 0, F = 0; s < a;) {
            switch (t[s++]) {
              case 0:
                for (p = c = 0; c < r; p = c += 1) {
                  i[o++] = t[s++];
                }

                break;

              case 1:
                for (p = d = 0; d < r; p = d += 1) {
                  l = t[s++], g = p < e ? 0 : i[o - e], i[o++] = (l + g) % 256;
                }

                break;

              case 2:
                for (p = f = 0; f < r; p = f += 1) {
                  l = t[s++], h = (p - p % e) / e, C = n && i[(n - 1) * r + h * e + p % e], i[o++] = (C + l) % 256;
                }

                break;

              case 3:
                for (p = m = 0; m < r; p = m += 1) {
                  l = t[s++], h = (p - p % e) / e, g = p < e ? 0 : i[o - e], C = n && i[(n - 1) * r + h * e + p % e], i[o++] = (l + Math.floor((g + C) / 2)) % 256;
                }

                break;

              case 4:
                for (p = y = 0; y < r; p = y += 1) {
                  l = t[s++], h = (p - p % e) / e, g = p < e ? 0 : i[o - e], 0 === n ? C = F = 0 : (C = i[(n - 1) * r + h * e + p % e], F = h && i[(n - 1) * r + (h - 1) * e + p % e]), b = g + C - F, _ = Math.abs(b - g), S = Math.abs(b - C), w = Math.abs(b - F), v = _ <= S && _ <= w ? g : S <= w ? C : F, i[o++] = (l + v) % 256;
                }

                break;

              default:
                throw new Error(u(6018, t[s - 1]));
            }

            n++;
          }

          return i;
        }, e.copyToImageData = function (t, e) {
          var r,
              i = this.hasAlphaChannel,
              a = this.colors;
          this.palette.length && (r = null != this._decodedPalette ? this._decodedPalette : this._decodedPalette = this.decodePalette(), a = 4, i = !0);
          var n = t.data || t,
              s = n.length,
              o = r || e,
              l = 0,
              h = 0,
              p = 0,
              u = 0;
          if (1 === a) for (; l < s;) {
            p = r ? 4 * e[l / 4] : h, u = o[p++], n[l++] = u, n[l++] = u, n[l++] = u, n[l++] = i ? o[p++] : 255, h = p;
          } else for (; l < s;) {
            p = r ? 4 * e[l / 4] : h, n[l++] = o[p++], n[l++] = o[p++], n[l++] = o[p++], n[l++] = i ? o[p++] : 255, h = p;
          }
        }, e.decodePalette = function () {
          for (var t = this.palette, e = this.transparency.indexed || [], r = new Uint8Array((e.length || 0) + t.length), i = 0, a = 0, n = 0, s = 0, o = 0, l = t.length; o < l; s = o += 3) {
            r[i++] = t[s], r[i++] = t[s + 1], r[i++] = t[s + 2], n = e[a++], r[i++] = null != n ? n : 255;
          }

          return r;
        }, e.render = function (t) {
          t.width = this.width, t.height = this.height;
          var e = t.getContext("2d"),
              r = e.createImageData(this.width, this.height);
          return this.copyToImageData(r, this.decodePixels(null)), e.putImageData(r, 0, 0);
        }, t;
      }(),
          ir = function () {
        function t() {
          this._littleEndian = !1, this._tiffData = [], this._fileDirectories = [];
        }

        var e = t.prototype;
        return e.getUint8 = function (t) {
          return this._tiffData[t];
        }, e.getUint16 = function (t) {
          return this._littleEndian ? this._tiffData[t + 1] << 8 | this._tiffData[t] : this._tiffData[t] << 8 | this._tiffData[t + 1];
        }, e.getUint32 = function (t) {
          var e = this._tiffData;
          return this._littleEndian ? e[t + 3] << 24 | e[t + 2] << 16 | e[t + 1] << 8 | e[t] : e[t] << 24 | e[t + 1] << 16 | e[t + 2] << 8 | e[t + 3];
        }, e.checkLittleEndian = function () {
          var t = this.getUint16(0);
          if (18761 === t) this._littleEndian = !0;else {
            if (19789 !== t) throw console.log(t), TypeError(u(6019));
            this._littleEndian = !1;
          }
          return this._littleEndian;
        }, e.hasTowel = function () {
          if (42 !== this.getUint16(2)) throw RangeError(u(6020));
          return !0;
        }, e.getFieldTypeName = function (t) {
          return t in nr ? nr[t] : null;
        }, e.getFieldTagName = function (t) {
          return t in ar ? ar[t] : (c(6021, t), "Tag" + t);
        }, e.getFieldTypeLength = function (t) {
          return -1 !== ["BYTE", "ASCII", "SBYTE", "UNDEFINED"].indexOf(t) ? 1 : -1 !== ["SHORT", "SSHORT"].indexOf(t) ? 2 : -1 !== ["LONG", "SLONG", "FLOAT"].indexOf(t) ? 4 : -1 !== ["RATIONAL", "SRATIONAL", "DOUBLE"].indexOf(t) ? 8 : 0;
        }, e.getFieldValues = function (t, e, r, i) {
          var a = [],
              n = this.getFieldTypeLength(e);
          if (n * r <= 4) !1 === this._littleEndian ? a.push(i >>> 8 * (4 - n)) : a.push(i);else for (var s = 0; s < r; s++) {
            var o = n * s;
            n >= 8 ? -1 !== ["RATIONAL", "SRATIONAL"].indexOf(e) ? (a.push(this.getUint32(i + o)), a.push(this.getUint32(i + o + 4))) : c(8e3) : a.push(this.getBytes(n, i + o));
          }
          return "ASCII" === e && a.forEach(function (t, e, r) {
            r[e] = String.fromCharCode(t);
          }), a;
        }, e.getBytes = function (t, e) {
          if (t <= 0) c(8001);else {
            if (t <= 1) return this.getUint8(e);
            if (t <= 2) return this.getUint16(e);
            if (t <= 3) return this.getUint32(e) >>> 8;
            if (t <= 4) return this.getUint32(e);
            c(8002);
          }
          return 0;
        }, e.getBits = function (t, e, r) {
          r = r || 0;
          var i = e + Math.floor(r / 8),
              a = r + t,
              n = 32 - t,
              s = 0,
              o = 0;
          return a <= 0 ? c(6023) : a <= 8 ? (s = 24 + r, o = this.getUint8(i)) : a <= 16 ? (s = 16 + r, o = this.getUint16(i)) : a <= 32 ? (s = r, o = this.getUint32(i)) : c(6022), {
            bits: o << s >>> n,
            byteOffset: i + Math.floor(a / 8),
            bitOffset: a % 8
          };
        }, e.parseFileDirectory = function (t) {
          var e = this.getUint16(t),
              r = [],
              i = 0,
              a = 0;

          for (i = t + 2, a = 0; a < e; i += 12, a++) {
            var n = this.getUint16(i),
                s = this.getUint16(i + 2),
                o = this.getUint32(i + 4),
                l = this.getUint32(i + 8),
                h = this.getFieldTagName(n),
                p = this.getFieldTypeName(s),
                u = this.getFieldValues(h, p, o, l);
            r[h] = {
              type: p,
              values: u
            };
          }

          this._fileDirectories.push(r);

          var c = this.getUint32(i);
          0 !== c && this.parseFileDirectory(c);
        }, e.clampColorSample = function (t, e) {
          var r = Math.pow(2, 8 - e);
          return Math.floor(t * r + (r - 1));
        }, e.parseTIFF = function (t, e) {
          var r = this;

          if (e = e || document.createElement("canvas"), this._tiffData = t, this._canvas = e, this.checkLittleEndian(), this.hasTowel()) {
            var i = this.getUint32(4);
            this._fileDirectories.length = 0, this.parseFileDirectory(i);
            var a = this._fileDirectories[0],
                n = a.ImageWidth.values[0],
                s = a.ImageLength.values[0];
            this._canvas.width = n, this._canvas.height = s;
            var o = [],
                l = a.Compression ? a.Compression.values[0] : 1,
                h = a.SamplesPerPixel.values[0],
                p = [],
                d = 0,
                f = !1;
            a.BitsPerSample.values.forEach(function (t, e) {
              p[e] = {
                bitsPerSample: t,
                hasBytesPerSample: !1,
                bytesPerSample: void 0
              }, t % 8 == 0 && (p[e].hasBytesPerSample = !0, p[e].bytesPerSample = t / 8), d += t;
            }, this);
            var m = 0;
            d % 8 == 0 && (f = !0, m = d / 8);
            var y,
                g = a.StripOffsets.values,
                b = g.length;
            if (a.StripByteCounts) y = a.StripByteCounts.values;else {
              if (c(8003), 1 !== b) throw Error(u(6024));
              y = [Math.ceil(n * s * d / 8)];
            }

            for (var _ = 1, v = 1, S = 0; S < b; S++) {
              var w = g[S];
              o[S] = [];

              for (var C = y[S], F = 0, P = 0, D = 1, T = !0, A = [], R = 0, x = 0, V = 0; F < C; F += D) {
                switch (l) {
                  case 1:
                    A = [];

                    for (var I = 0; I < h; I++) {
                      var O = p[I];

                      if (!O.hasBytesPerSample) {
                        var z = this.getBits(O.bitsPerSample, w + F, P);
                        throw A.push(z.bits), F = z.byteOffset - w, P = z.bitOffset, RangeError(u(6025));
                      }

                      var E = O.bytesPerSample * I;
                      A.push(this.getBytes(O.bytesPerSample, w + F + E));
                    }

                    if (o[S].push(A), !f) throw D = 0, RangeError(u(6026));
                    D = m;
                    break;

                  case 2:
                  case 3:
                  case 4:
                  case 5:
                  case 6:
                  case 7:
                    break;

                  case 32773:
                    if (T) {
                      T = !1;
                      var M = this.getUint8(w + F);
                      M >= 0 && M <= 127 ? _ = M + 1 : M >= -127 && M <= -1 ? v = 1 - M : T = !0;
                    } else {
                      for (var U = this.getUint8(w + F), k = 0; k < v; k++) {
                        var L = p[x];
                        if (!L.hasBytesPerSample) throw RangeError(u(6025));
                        V = V << 8 * R | U, ++R === L.bytesPerSample && (A.push(V), V = R = 0, x++), x === h && (o[S].push(A), A = [], x = 0);
                      }

                      0 == --_ && (T = !0);
                    }

                    D = 1;
                }
              }
            }

            if (e.getContext) {
              var N = this._canvas.getContext("2d");

              N.fillStyle = "rgba(255, 255, 255, 0)";
              var B = a.RowsPerStrip ? a.RowsPerStrip.values[0] : s,
                  G = o.length,
                  j = s % B,
                  W = 0 === j ? B : j,
                  Y = B,
                  H = 0,
                  X = a.PhotometricInterpretation.values[0],
                  Z = [],
                  q = 0;
              a.ExtraSamples && (q = (Z = a.ExtraSamples.values).length);
              var J = [],
                  K = 0;
              a.ColorMap && (J = a.ColorMap.values, K = Math.pow(2, p[0].bitsPerSample));

              for (var Q = 0; Q < G; Q++) {
                Q + 1 === G && (Y = W);

                for (var $ = o[Q].length, tt = H * Q, et = 0, rt = 0; et < Y && rt < $; et++) {
                  for (var it = 0; it < n; it++, rt++) {
                    var at = o[Q][rt],
                        nt = 0,
                        st = 0,
                        ot = 0,
                        lt = 1;
                    if (q > 0) for (var ht = 0; ht < q; ht++) {
                      if (1 === Z[ht] || 2 === Z[ht]) {
                        lt = at[3 + ht] / 256;
                        break;
                      }
                    }
                    !function () {
                      switch (X) {
                        case 0:
                          var t = 0;
                          p[0].hasBytesPerSample && (t = Math.pow(16, 2 * p[0].bytesPerSample)), at.forEach(function (e, r, i) {
                            i[r] = t - e;
                          });

                        case 1:
                          nt = st = ot = r.clampColorSample(at[0], p[0].bitsPerSample);
                          break;

                        case 2:
                          nt = r.clampColorSample(at[0], p[0].bitsPerSample), st = r.clampColorSample(at[1], p[1].bitsPerSample), ot = r.clampColorSample(at[2], p[2].bitsPerSample);
                          break;

                        case 3:
                          if (void 0 === J) throw Error(u(6027));
                          var e = at[0];
                          nt = r.clampColorSample(J[e], 16), st = r.clampColorSample(J[K + e], 16), ot = r.clampColorSample(J[2 * K + e], 16);
                          break;

                        default:
                          throw RangeError(u(6028, X));
                      }
                    }(), N.fillStyle = "rgba(" + nt + ", " + st + ", " + ot + ", " + lt + ")", N.fillRect(it, tt + et, 1, 1);
                  }
                }

                H = Y;
              }
            }

            return this._canvas;
          }
        }, t;
      }(),
          ar = {
        315: "Artist",
        258: "BitsPerSample",
        265: "CellLength",
        264: "CellWidth",
        320: "ColorMap",
        259: "Compression",
        33432: "Copyright",
        306: "DateTime",
        338: "ExtraSamples",
        266: "FillOrder",
        289: "FreeByteCounts",
        288: "FreeOffsets",
        291: "GrayResponseCurve",
        290: "GrayResponseUnit",
        316: "HostComputer",
        270: "ImageDescription",
        257: "ImageLength",
        256: "ImageWidth",
        271: "Make",
        281: "MaxSampleValue",
        280: "MinSampleValue",
        272: "Model",
        254: "NewSubfileType",
        274: "Orientation",
        262: "PhotometricInterpretation",
        284: "PlanarConfiguration",
        296: "ResolutionUnit",
        278: "RowsPerStrip",
        277: "SamplesPerPixel",
        305: "Software",
        279: "StripByteCounts",
        273: "StripOffsets",
        255: "SubfileType",
        263: "Threshholding",
        282: "XResolution",
        283: "YResolution",
        326: "BadFaxLines",
        327: "CleanFaxData",
        343: "ClipPath",
        328: "ConsecutiveBadFaxLines",
        433: "Decode",
        434: "DefaultImageColor",
        269: "DocumentName",
        336: "DotRange",
        321: "HalftoneHints",
        346: "Indexed",
        347: "JPEGTables",
        285: "PageName",
        297: "PageNumber",
        317: "Predictor",
        319: "PrimaryChromaticities",
        532: "ReferenceBlackWhite",
        339: "SampleFormat",
        559: "StripRowCounts",
        330: "SubIFDs",
        292: "T4Options",
        293: "T6Options",
        325: "TileByteCounts",
        323: "TileLength",
        324: "TileOffsets",
        322: "TileWidth",
        301: "TransferFunction",
        318: "WhitePoint",
        344: "XClipPathUnits",
        286: "XPosition",
        529: "YCbCrCoefficients",
        531: "YCbCrPositioning",
        530: "YCbCrSubSampling",
        345: "YClipPathUnits",
        287: "YPosition",
        37378: "ApertureValue",
        40961: "ColorSpace",
        36868: "DateTimeDigitized",
        36867: "DateTimeOriginal",
        34665: "Exif IFD",
        36864: "ExifVersion",
        33434: "ExposureTime",
        41728: "FileSource",
        37385: "Flash",
        40960: "FlashpixVersion",
        33437: "FNumber",
        42016: "ImageUniqueID",
        37384: "LightSource",
        37500: "MakerNote",
        37377: "ShutterSpeedValue",
        37510: "UserComment",
        33723: "IPTC",
        34675: "ICC Profile",
        700: "XMP",
        42112: "GDAL_METADATA",
        42113: "GDAL_NODATA",
        34377: "Photoshop"
      },
          nr = {
        1: "BYTE",
        2: "ASCII",
        3: "SHORT",
        4: "LONG",
        5: "RATIONAL",
        6: "SBYTE",
        7: "UNDEFINED",
        8: "SSHORT",
        9: "SLONG",
        10: "SRATIONAL",
        11: "FLOAT",
        12: "DOUBLE"
      };

      function sr(t) {
        var e = t.parent,
            r = t.getComponent(Sr);
        return e && r ? sr(e) : t.getComponentsInChildren(Sr);
      }

      !function (t) {
        t[t.JPG = 0] = "JPG", t[t.PNG = 1] = "PNG", t[t.TIFF = 2] = "TIFF", t[t.WEBP = 3] = "WEBP", t[t.PVR = 4] = "PVR", t[t.ETC = 5] = "ETC", t[t.S3TC = 6] = "S3TC", t[t.ATITC = 7] = "ATITC", t[t.TGA = 8] = "TGA", t[t.RAWDATA = 9] = "RAWDATA", t[t.UNKNOWN = 10] = "UNKNOWN";
      }(er || (er = {}));

      var or,
          lr,
          hr,
          pr,
          ur,
          cr,
          dr,
          fr,
          mr,
          yr,
          gr,
          br,
          _r,
          vr,
          Sr = t("ParticleSystem2D", (ot = v("cc.ParticleSystem2D"), lt = x(), ht = V(), pt = I(), ut = F(st), ct = V(), dt = I(), ft = F(k), mt = I(), yt = I(), gt = I(), bt = I(), _t = I(), vt = I(), St = I(), wt = I(), Ct = O(), Ft = I(), Pt = I(), Dt = I(), Tt = I(), At = I(), Rt = I(), xt = I(), Vt = I(), It = I(), Ot = I(), zt = I(), Et = I(), Mt = I(), Ut = F(J), kt = I(), Lt = V(), Nt = I(), Bt = F(q), Gt = I(), jt = I(), Wt = I(), Yt = I(), Ht = I(), Xt = I(), Zt = I(), qt = I(), Jt = I(), Kt = I(), Qt = I(), $t = I(), te = I(), ee = I(), re = I(), ie = V(), ae = I(), ne = V(), se = I(), oe = z("preview"), ot(le = lt(le = P(le = D((tr = $e = function (t) {
        function e() {
          var e;
          return e = t.call(this) || this, h(e, "duration", pe, p(e)), h(e, "emissionRate", ue, p(e)), h(e, "life", ce, p(e)), h(e, "lifeVar", de, p(e)), h(e, "angle", fe, p(e)), h(e, "angleVar", me, p(e)), h(e, "startSize", ye, p(e)), h(e, "startSizeVar", ge, p(e)), h(e, "endSize", be, p(e)), h(e, "endSizeVar", _e, p(e)), h(e, "startSpin", ve, p(e)), h(e, "startSpinVar", Se, p(e)), h(e, "endSpin", we, p(e)), h(e, "endSpinVar", Ce, p(e)), h(e, "sourcePos", Fe, p(e)), h(e, "posVar", Pe, p(e)), h(e, "emitterMode", De, p(e)), h(e, "gravity", Te, p(e)), h(e, "speed", Ae, p(e)), h(e, "speedVar", Re, p(e)), h(e, "tangentialAccel", xe, p(e)), h(e, "tangentialAccelVar", Ve, p(e)), h(e, "radialAccel", Ie, p(e)), h(e, "radialAccelVar", Oe, p(e)), h(e, "rotationIsDir", ze, p(e)), h(e, "startRadius", Ee, p(e)), h(e, "startRadiusVar", Me, p(e)), h(e, "endRadius", Ue, p(e)), h(e, "endRadiusVar", ke, p(e)), h(e, "rotatePerS", Le, p(e)), h(e, "rotatePerSVar", Ne, p(e)), e.aspectRatio = 1, h(e, "playOnLoad", Be, p(e)), h(e, "autoRemoveOnFinish", Ge, p(e)), h(e, "_preview", je, p(e)), h(e, "_custom", We, p(e)), h(e, "_file", Ye, p(e)), h(e, "_spriteFrame", He, p(e)), h(e, "_totalParticles", Xe, p(e)), h(e, "_startColor", Ze, p(e)), h(e, "_startColorVar", qe, p(e)), h(e, "_endColor", Je, p(e)), h(e, "_endColorVar", Ke, p(e)), h(e, "_positionType", Qe, p(e)), e._stopped = !0, e.initProperties(), e;
        }

        r(e, t);
        var i = e.prototype;
        return i.onEnable = function () {
          t.prototype.onEnable.call(this), this._updateMaterial();
        }, i.onDestroy = function () {
          t.prototype.onDestroy.call(this), this.autoRemoveOnFinish && (this.autoRemoveOnFinish = !1), this._simulator.uvFilled = 0, this._simulator.renderData && this._assembler && this._assembler.removeData(this._simulator.renderData);
        }, i.initProperties = function () {
          this._previewTimer = null, this._focused = !1, this.aspectRatio = 1, this._simulator = new nt(this);
        }, i.onFocusInEditor = function () {
          this._focused = !0;

          for (var t = sr(this.node), e = 0; e < t.length; ++e) {
            t[e]._startPreview();
          }
        }, i.onLostFocusInEditor = function () {
          this._focused = !1;

          for (var t = sr(this.node), e = 0; e < t.length; ++e) {
            t[e]._stopPreview();
          }
        }, i._startPreview = function () {
          this._preview && this.resetSystem();
        }, i._stopPreview = function () {
          this._preview && (this.resetSystem(), this.stopSystem()), this._previewTimer && clearInterval(this._previewTimer);
        }, i.__preload = function () {
          t.prototype.__preload.call(this), this._custom && this.spriteFrame && !this._renderSpriteFrame ? this._applySpriteFrame() : this._file && (this._custom ? !this._getTexture() && this._applyFile() : this._applyFile()), this.playOnLoad && this.resetSystem();
        }, i._flushAssembler = function () {
          var t = e.Assembler.getAssembler(this);
          this._assembler !== t && (this._assembler = t), this._assembler && this._assembler.createData && (this._simulator.renderData = this._assembler.createData(this));
        }, i.lateUpdate = function (t) {
          this._simulator.finished || this._simulator.step(t);
        }, i.addParticle = function () {}, i.stopSystem = function () {
          this._stopped = !0, this._simulator.stop();
        }, i.resetSystem = function () {
          this._stopped = !1, this._simulator.reset(), this._renderFlag = this._canRender();
        }, i.isFull = function () {
          return this.particleCount >= this.totalParticles;
        }, i._applyFile = function () {
          var t = this._file;

          if (t) {
            if (!t) return void d(6029);
            if (!this.isValid) return;
            this._plistFile = t.nativeUrl, this._custom || (this._spriteFrame !== t.spriteFrame && (this.spriteFrame = t.spriteFrame), this._initWithDictionary(t._nativeAsset)), this._spriteFrame ? !this._renderSpriteFrame && this._spriteFrame && this._applySpriteFrame() : t.spriteFrame ? this.spriteFrame = t.spriteFrame : this._custom && this._initTextureWithDictionary(t._nativeAsset);
          }
        }, i._initTextureWithDictionary = function (t) {
          var e,
              r = this;

          if (t.spriteFrameUuid) {
            var i = t.spriteFrameUuid;
            U.loadAny(i, function (e, i) {
              e ? (t.spriteFrameUuid = void 0, r._initTextureWithDictionary(t), f(e)) : r.spriteFrame = i;
            });
          } else {
            var a = T(this._plistFile, t.textureFileName || "");
            if (t.textureFileName) U.loadRemote(a, function (e, i) {
              e ? (t.textureFileName = void 0, r._initTextureWithDictionary(t), f(e)) : r.spriteFrame = i ? k.createWithImage(i) : k.createWithImage(A.get("white-texture"));
            });else if (t.textureImageData) {
              var n = t.textureImageData;
              if (!(n && n.length > 0)) return !1;
              var s = U.assets.get(a);

              if (!s) {
                var o = W.unzipBase64AsArray(n, 1);
                if (!o) return m(6030, this._file.name), !1;
                var l = (e = o).length > 8 && 137 === e[0] && 80 === e[1] && 78 === e[2] && 71 === e[3] && 13 === e[4] && 10 === e[5] && 26 === e[6] && 10 === e[7] ? er.PNG : e.length > 2 && (73 === e[0] && 73 === e[1] || 77 === e[0] && 77 === e[1] || 255 === e[0] && 216 === e[1]) ? er.TIFF : er.UNKNOWN;
                if (l !== er.TIFF && l !== er.PNG) return m(6031, this._file.name), !1;
                var h = document.createElement("canvas");
                l === er.PNG ? new rr(o).render(h) : (this._tiffReader || (this._tiffReader = new ir()), this._tiffReader.parseTIFF(o, h)), s = new R(h), U.assets.add(a, s);
              }

              s || m(6032, this._file.name), this.spriteFrame = s ? k.createWithImage(s) : k.createWithImage(A.get("white-texture"));
            }
          }

          return !0;
        }, i._initWithDictionary = function (t) {
          this.totalParticles = parseInt(t.maxParticles || 0), this.life = parseFloat(t.particleLifespan || 0), this.lifeVar = parseFloat(t.particleLifespanVariance || 0);
          var e = t.emissionRate;
          this.emissionRate = e || Math.min(this.totalParticles / this.life, Number.MAX_VALUE), this.duration = parseFloat(t.duration || 0), this._srcBlendFactor = parseInt(t.blendFuncSource || y.SRC_ALPHA), this._dstBlendFactor = parseInt(t.blendFuncDestination || y.ONE_MINUS_SRC_ALPHA);
          var r = this._startColor;
          r.r = 255 * parseFloat(t.startColorRed || 0), r.g = 255 * parseFloat(t.startColorGreen || 0), r.b = 255 * parseFloat(t.startColorBlue || 0), r.a = 255 * parseFloat(t.startColorAlpha || 0);
          var i = this._startColorVar;
          i.r = 255 * parseFloat(t.startColorVarianceRed || 0), i.g = 255 * parseFloat(t.startColorVarianceGreen || 0), i.b = 255 * parseFloat(t.startColorVarianceBlue || 0), i.a = 255 * parseFloat(t.startColorVarianceAlpha || 0);
          var a = this._endColor;
          a.r = 255 * parseFloat(t.finishColorRed || 0), a.g = 255 * parseFloat(t.finishColorGreen || 0), a.b = 255 * parseFloat(t.finishColorBlue || 0), a.a = 255 * parseFloat(t.finishColorAlpha || 0);
          var n = this._endColorVar;

          if (n.r = 255 * parseFloat(t.finishColorVarianceRed || 0), n.g = 255 * parseFloat(t.finishColorVarianceGreen || 0), n.b = 255 * parseFloat(t.finishColorVarianceBlue || 0), n.a = 255 * parseFloat(t.finishColorVarianceAlpha || 0), this.startSize = parseFloat(t.startParticleSize || 0), this.startSizeVar = parseFloat(t.startParticleSizeVariance || 0), this.endSize = parseFloat(t.finishParticleSize || 0), this.endSizeVar = parseFloat(t.finishParticleSizeVariance || 0), this.positionType = parseFloat(void 0 !== t.positionType ? t.positionType : J.FREE), this.sourcePos.set(0, 0), this.posVar.set(parseFloat(t.sourcePositionVariancex || 0), parseFloat(t.sourcePositionVariancey || 0)), this.angle = parseFloat(t.angle || 0), this.angleVar = parseFloat(t.angleVariance || 0), this.startSpin = parseFloat(t.rotationStart || 0), this.startSpinVar = parseFloat(t.rotationStartVariance || 0), this.endSpin = parseFloat(t.rotationEnd || 0), this.endSpinVar = parseFloat(t.rotationEndVariance || 0), this.emitterMode = parseInt(t.emitterType || q.GRAVITY), this.emitterMode === q.GRAVITY) {
            this.gravity.set(parseFloat(t.gravityx || 0), parseFloat(t.gravityy || 0)), this.speed = parseFloat(t.speed || 0), this.speedVar = parseFloat(t.speedVariance || 0), this.radialAccel = parseFloat(t.radialAcceleration || 0), this.radialAccelVar = parseFloat(t.radialAccelVariance || 0), this.tangentialAccel = parseFloat(t.tangentialAcceleration || 0), this.tangentialAccelVar = parseFloat(t.tangentialAccelVariance || 0);
            var s = t.rotationIsDir || "";
            null !== s ? (s = s.toString().toLowerCase(), this.rotationIsDir = "true" === s || "1" === s) : this.rotationIsDir = !1;
          } else {
            if (this.emitterMode !== q.RADIUS) return m(6009), !1;
            this.startRadius = parseFloat(t.maxRadius || 0), this.startRadiusVar = parseFloat(t.maxRadiusVariance || 0), this.endRadius = parseFloat(t.minRadius || 0), this.endRadiusVar = parseFloat(t.minRadiusVariance || 0), this.rotatePerS = parseFloat(t.rotatePerSecond || 0), this.rotatePerSVar = parseFloat(t.rotatePerSecondVariance || 0);
          }

          return this._initTextureWithDictionary(t), !0;
        }, i._syncAspect = function () {
          if (this._renderSpriteFrame) {
            var t = this._renderSpriteFrame.rect;
            this.aspectRatio = t.width / t.height;
          }
        }, i._applySpriteFrame = function () {
          this._renderSpriteFrame = this._renderSpriteFrame || this._spriteFrame, this._renderSpriteFrame ? this._renderSpriteFrame.texture && (this._simulator.updateUVs(!0), this._syncAspect(), this._updateMaterial(), this._stopped = !1, this._renderFlag = this._canRender()) : this.resetSystem();
        }, i._getTexture = function () {
          return this._renderSpriteFrame && this._renderSpriteFrame.texture;
        }, i._updateMaterial = function () {
          var t = this.getMaterialInstance(0);
          t && t.recompileShaders({
            USE_LOCAL: this._positionType !== J.FREE
          });
        }, i._finishedSimulation = function () {
          this.resetSystem(), this.stopSystem(), this._renderFlag = this._canRender(), this.autoRemoveOnFinish && this._stopped && this.node.destroy();
        }, i._canRender = function () {
          return t.prototype._canRender.call(this) && !this._stopped && null !== this._renderSpriteFrame;
        }, i._render = function (t) {
          this._positionType === J.RELATIVE ? t.commitComp(this, this._simulator.renderData, this._renderSpriteFrame, this._assembler, this.node.parent) : this.positionType === J.GROUPED ? t.commitComp(this, this._simulator.renderData, this._renderSpriteFrame, this._assembler, this.node) : t.commitComp(this, this._simulator.renderData, this._renderSpriteFrame, this._assembler, null);
        }, g(e, [{
          key: "custom",
          get: function get() {
            return this._custom;
          },
          set: function set(t) {
            this._custom !== t && (this._custom = t, this._applyFile());
          }
        }, {
          key: "file",
          get: function get() {
            return this._file;
          },
          set: function set(t) {
            this._file !== t && (this._file = t, t ? this._applyFile() : this.custom = !0);
          }
        }, {
          key: "spriteFrame",
          get: function get() {
            return this._spriteFrame;
          },
          set: function set(t) {
            this._renderSpriteFrame !== t && (this._renderSpriteFrame = t, t && !t._uuid || (this._spriteFrame = t), this._applySpriteFrame());
          }
        }, {
          key: "particleCount",
          get: function get() {
            return this._simulator.particles.length;
          }
        }, {
          key: "totalParticles",
          get: function get() {
            return this._totalParticles;
          },
          set: function set(t) {
            this._totalParticles !== t && (this._totalParticles = t);
          }
        }, {
          key: "startColor",
          get: function get() {
            return this._startColor;
          },
          set: function set(t) {
            this._startColor.r = t.r, this._startColor.g = t.g, this._startColor.b = t.b, this._startColor.a = t.a;
          }
        }, {
          key: "startColorVar",
          get: function get() {
            return this._startColorVar;
          },
          set: function set(t) {
            this._startColorVar.r = t.r, this._startColorVar.g = t.g, this._startColorVar.b = t.b, this._startColorVar.a = t.a;
          }
        }, {
          key: "color",
          get: function get() {
            return this._color;
          },
          set: function set() {}
        }, {
          key: "endColor",
          get: function get() {
            return this._endColor;
          },
          set: function set(t) {
            this._endColor.r = t.r, this._endColor.g = t.g, this._endColor.b = t.b, this._endColor.a = t.a;
          }
        }, {
          key: "endColorVar",
          get: function get() {
            return this._endColorVar;
          },
          set: function set(t) {
            this._endColorVar.r = t.r, this._endColorVar.g = t.g, this._endColorVar.b = t.b, this._endColorVar.a = t.a;
          }
        }, {
          key: "positionType",
          get: function get() {
            return this._positionType;
          },
          set: function set(t) {
            this._positionType = t, this._updateMaterial();
          }
        }, {
          key: "preview",
          get: function get() {
            return this._preview;
          },
          set: function set(t) {
            t ? this._startPreview() : this._stopPreview(), this._preview = t;
          }
        }, {
          key: "stopped",
          get: function get() {
            return this._stopped;
          }
        }, {
          key: "active",
          get: function get() {
            return this._simulator.active;
          }
        }, {
          key: "assembler",
          get: function get() {
            return this._assembler;
          }
        }]), e;
      }(B), $e.EmitterMode = q, $e.PositionType = J, $e.DURATION_INFINITY = -1, $e.START_SIZE_EQUAL_TO_END_SIZE = -1, $e.START_RADIUS_EQUAL_TO_END_RADIUS = -1, o((he = tr).prototype, "custom", [C, ht, pt], Object.getOwnPropertyDescriptor(he.prototype, "custom"), he.prototype), o(he.prototype, "file", [ut, ct, dt], Object.getOwnPropertyDescriptor(he.prototype, "file"), he.prototype), o(he.prototype, "spriteFrame", [ft, mt], Object.getOwnPropertyDescriptor(he.prototype, "spriteFrame"), he.prototype), o(he.prototype, "totalParticles", [C, yt], Object.getOwnPropertyDescriptor(he.prototype, "totalParticles"), he.prototype), pe = o(he.prototype, "duration", [w, C, gt], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return -1;
        }
      }), ue = o(he.prototype, "emissionRate", [w, C, bt], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 10;
        }
      }), ce = o(he.prototype, "life", [w, C, _t], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 1;
        }
      }), de = o(he.prototype, "lifeVar", [w, C, vt], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 0;
        }
      }), o(he.prototype, "startColor", [C, St], Object.getOwnPropertyDescriptor(he.prototype, "startColor"), he.prototype), o(he.prototype, "startColorVar", [C, wt], Object.getOwnPropertyDescriptor(he.prototype, "startColorVar"), he.prototype), o(he.prototype, "color", [Ct], Object.getOwnPropertyDescriptor(he.prototype, "color"), he.prototype), o(he.prototype, "endColor", [C, Ft], Object.getOwnPropertyDescriptor(he.prototype, "endColor"), he.prototype), o(he.prototype, "endColorVar", [C, Pt], Object.getOwnPropertyDescriptor(he.prototype, "endColorVar"), he.prototype), fe = o(he.prototype, "angle", [w, C, Dt], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 90;
        }
      }), me = o(he.prototype, "angleVar", [w, C, Tt], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 20;
        }
      }), ye = o(he.prototype, "startSize", [w, C, At], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 50;
        }
      }), ge = o(he.prototype, "startSizeVar", [w, C, Rt], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 0;
        }
      }), be = o(he.prototype, "endSize", [w, C, xt], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 0;
        }
      }), _e = o(he.prototype, "endSizeVar", [w, C, Vt], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 0;
        }
      }), ve = o(he.prototype, "startSpin", [w, C, It], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 0;
        }
      }), Se = o(he.prototype, "startSpinVar", [w, C, Ot], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 0;
        }
      }), we = o(he.prototype, "endSpin", [w, C, zt], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 0;
        }
      }), Ce = o(he.prototype, "endSpinVar", [w, C, Et], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 0;
        }
      }), Fe = o(he.prototype, "sourcePos", [w], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return b.ZERO.clone();
        }
      }), Pe = o(he.prototype, "posVar", [w, C, Mt], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return b.ZERO.clone();
        }
      }), o(he.prototype, "positionType", [Ut, kt], Object.getOwnPropertyDescriptor(he.prototype, "positionType"), he.prototype), o(he.prototype, "preview", [C, Lt, Nt], Object.getOwnPropertyDescriptor(he.prototype, "preview"), he.prototype), De = o(he.prototype, "emitterMode", [w, C, Bt, Gt], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return q.GRAVITY;
        }
      }), Te = o(he.prototype, "gravity", [w, C, jt], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return b.ZERO.clone();
        }
      }), Ae = o(he.prototype, "speed", [w, C, Wt], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 180;
        }
      }), Re = o(he.prototype, "speedVar", [w, C, Yt], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 50;
        }
      }), xe = o(he.prototype, "tangentialAccel", [w, C, Ht], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 80;
        }
      }), Ve = o(he.prototype, "tangentialAccelVar", [w, C, Xt], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 0;
        }
      }), Ie = o(he.prototype, "radialAccel", [w, C, Zt], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 0;
        }
      }), Oe = o(he.prototype, "radialAccelVar", [w, C, qt], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 0;
        }
      }), ze = o(he.prototype, "rotationIsDir", [w, C, Jt], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !1;
        }
      }), Ee = o(he.prototype, "startRadius", [w, C, Kt], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 0;
        }
      }), Me = o(he.prototype, "startRadiusVar", [w, C, Qt], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 0;
        }
      }), Ue = o(he.prototype, "endRadius", [w, C, $t], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 0;
        }
      }), ke = o(he.prototype, "endRadiusVar", [w, C, te], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 0;
        }
      }), Le = o(he.prototype, "rotatePerS", [w, C, ee], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 0;
        }
      }), Ne = o(he.prototype, "rotatePerSVar", [w, C, re], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 0;
        }
      }), Be = o(he.prototype, "playOnLoad", [w, C, ie, ae], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !0;
        }
      }), Ge = o(he.prototype, "autoRemoveOnFinish", [w, C, ne, se], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !1;
        }
      }), je = o(he.prototype, "_preview", [oe], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !0;
        }
      }), We = o(he.prototype, "_custom", [w], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !1;
        }
      }), Ye = o(he.prototype, "_file", [w], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return null;
        }
      }), He = o(he.prototype, "_spriteFrame", [w], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return null;
        }
      }), Xe = o(he.prototype, "_totalParticles", [w], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 150;
        }
      }), Ze = o(he.prototype, "_startColor", [w], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return new _(255, 255, 255, 255);
        }
      }), qe = o(he.prototype, "_startColorVar", [w], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return new _(0, 0, 0, 0);
        }
      }), Je = o(he.prototype, "_endColor", [w], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return new _(255, 255, 255, 0);
        }
      }), Ke = o(he.prototype, "_endColorVar", [w], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return new _(0, 0, 0, 0);
        }
      }), Qe = o(he.prototype, "_positionType", [w], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return J.FREE;
        }
      }), le = he)) || le) || le) || le) || le)),
          wr = function () {
        function t(t, e) {
          this.point = new b(), this.dir = new b(), this.distance = 0, this.time = 0, t && this.point.set(t), e && this.dir.set(e);
        }

        var e = t.prototype;
        return e.setPoint = function (t, e) {
          this.point.x = t, this.point.y = e;
        }, e.setDir = function (t, e) {
          this.dir.x = t, this.dir.y = e;
        }, t;
      }(),
          Cr = t("MotionStreak", (or = v("cc.MotionStreak"), lr = x(), hr = M(), pr = F(E), or(ur = D(ur = P(ur = lr(ur = hr((vr = _r = function (t) {
        function e() {
          for (var e, r = arguments.length, i = new Array(r), a = 0; a < r; a++) {
            i[a] = arguments[a];
          }

          return e = t.call.apply(t, [this].concat(i)) || this, h(e, "_preview", dr, p(e)), h(e, "_fadeTime", fr, p(e)), h(e, "_minSeg", mr, p(e)), h(e, "_stroke", yr, p(e)), h(e, "_texture", gr, p(e)), h(e, "_fastMode", br, p(e)), e._points = [], e;
        }

        r(e, t);
        var i = e.prototype;
        return i.onEnable = function () {
          t.prototype.onEnable.call(this), this.reset();
        }, i._flushAssembler = function () {
          var t = e.Assembler.getAssembler(this);
          this._assembler !== t && (this._assembler = t), this._renderData || this._assembler && this._assembler.createData && (this._renderData = this._assembler.createData(this), this._renderData.material = this.material);
        }, i.onFocusInEditor = function () {
          this._preview && this.reset();
        }, i.onLostFocusInEditor = function () {
          this._preview && this.reset();
        }, i.reset = function () {
          this._points.length = 0, this._renderData && this._renderData.clear();
        }, i.lateUpdate = function (t) {
          this._assembler && this._assembler.update(this, t);
        }, i._render = function (t) {
          t.commitComp(this, this.renderData, this._texture, this._assembler, null);
        }, g(e, [{
          key: "preview",
          get: function get() {
            return this._preview;
          },
          set: function set(t) {
            this._preview = t, this.reset();
          }
        }, {
          key: "fadeTime",
          get: function get() {
            return this._fadeTime;
          },
          set: function set(t) {
            this._fadeTime = t, this.reset();
          }
        }, {
          key: "minSeg",
          get: function get() {
            return this._minSeg;
          },
          set: function set(t) {
            this._minSeg = t;
          }
        }, {
          key: "stroke",
          get: function get() {
            return this._stroke;
          },
          set: function set(t) {
            this._stroke = t;
          }
        }, {
          key: "texture",
          get: function get() {
            return this._texture;
          },
          set: function set(t) {
            this._texture !== t && (this._texture = t);
          }
        }, {
          key: "fastMode",
          get: function get() {
            return this._fastMode;
          },
          set: function set(t) {
            this._fastMode = t;
          }
        }, {
          key: "points",
          get: function get() {
            return this._points;
          }
        }]), e;
      }(B), _r.Point = wr, o((cr = vr).prototype, "preview", [C], Object.getOwnPropertyDescriptor(cr.prototype, "preview"), cr.prototype), o(cr.prototype, "fadeTime", [C], Object.getOwnPropertyDescriptor(cr.prototype, "fadeTime"), cr.prototype), o(cr.prototype, "minSeg", [C], Object.getOwnPropertyDescriptor(cr.prototype, "minSeg"), cr.prototype), o(cr.prototype, "stroke", [C], Object.getOwnPropertyDescriptor(cr.prototype, "stroke"), cr.prototype), o(cr.prototype, "texture", [pr], Object.getOwnPropertyDescriptor(cr.prototype, "texture"), cr.prototype), o(cr.prototype, "fastMode", [C], Object.getOwnPropertyDescriptor(cr.prototype, "fastMode"), cr.prototype), dr = o(cr.prototype, "_preview", [w], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !1;
        }
      }), fr = o(cr.prototype, "_fadeTime", [w], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 1;
        }
      }), mr = o(cr.prototype, "_minSeg", [w], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 1;
        }
      }), yr = o(cr.prototype, "_stroke", [w], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 64;
        }
      }), gr = o(cr.prototype, "_texture", [w], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return null;
        }
      }), br = o(cr.prototype, "_fastMode", [w], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !1;
        }
      }), ur = cr)) || ur) || ur) || ur) || ur) || ur)),
          Fr = (new b(), new b()),
          Pr = new b();

      function Dr(t, e) {
        return t.x = -e.y, t.y = e.x, t;
      }

      var Tr = {
        createData: function createData(t) {
          var e = t.requestRenderData();
          return e.dataLength = 4, e.resize(16, 42), e;
        },
        update: function update(t, e) {
          var r,
              i = t.stroke / 2,
              a = t.node.worldMatrix,
              n = a.m12,
              s = a.m13,
              o = t.points;

          if (o.length > 1) {
            var l = o[0],
                h = l.point.x - n,
                p = l.point.y - s;
            h * h + p * p < t.minSeg && (r = l);
          }

          r || (r = new Cr.Point(), o.unshift(r)), r.setPoint(n, s), r.time = t.fadeTime + e;
          var u,
              c = 0;

          if (!(o.length < 2)) {
            var d = t.renderData;
            this.updateRenderDataCache(t, d);
            var f = t.color,
                m = f.r,
                y = f.g,
                g = f.b,
                _ = f.a,
                v = o[1];
            v.distance = b.subtract(Pr, r.point, v.point).length(), Pr.normalize(), v.setDir(Pr.x, Pr.y), r.setDir(Pr.x, Pr.y), d.dataLength = 2 * o.length;

            for (var S = d.data, w = t.fadeTime, C = !1, F = o.length - 1; F >= 0; F--) {
              var P = o[F],
                  D = P.point,
                  T = P.dir;
              if (P.time -= e, P.time < 0) o.splice(F, 1);else {
                var A = P.time / w,
                    R = o[F - 1];

                if (!C) {
                  if (!R) {
                    o.splice(F, 1);
                    continue;
                  }

                  D.x = R.point.x - T.x * A, D.y = R.point.y - T.y * A;
                }

                C = !0, Dr(Fr, T);
                var x = (A * _ << 24 >>> 0) + (g << 16) + (y << 8) + m,
                    V = c;
                S[V].x = D.x + Fr.x * i, S[V].y = D.y + Fr.y * i, S[V].u = 1, S[V].v = A, S[V].color._val = x, S[V += 1].x = D.x - Fr.x * i, S[V].y = D.y - Fr.y * i, S[V].u = 0, S[V].v = A, S[V].color._val = x, c += 2;
              }
            }

            u = c <= 2 ? 0 : 3 * (c - 2), d.resize(c, u);
          }
        },
        updateRenderDataCache: function updateRenderDataCache(t, e) {
          e.passDirty && e.updatePass(t), e.nodeDirty && e.updateNode(t), e.textureDirty && t.texture && (e.updateTexture(t.texture), e.material = t.getRenderMaterial(0)), e.hashDirty && e.updateHash();
        },
        updateRenderData: function updateRenderData() {},
        updateColor: function updateColor() {},
        fillBuffers: function fillBuffers(t) {
          for (var e = t.renderData, r = e.chunk, i = e.data, a = e.vertexCount, n = e.indexCount, s = r.vb, o = 0, l = 0; l < a; l++) {
            var h = i[l];
            s[o++] = h.x, s[o++] = h.y, s[o++] = h.z, s[o++] = h.u, s[o++] = h.v, _.toArray(s, h.color, o), o += 4;
          }

          for (var p = r.bufferId, u = r.vertexOffset, c = r.vertexAccessor.getMeshBuffer(r.bufferId), d = r.vertexAccessor.getIndexBuffer(p), f = c.indexOffset, m = 0, y = n; m < y; m += 2) {
            var g = u + m;
            d[f++] = g, d[f++] = g + 2, d[f++] = g + 1, d[f++] = g + 1, d[f++] = g + 2, d[f++] = g + 3;
          }

          c.indexOffset += e.indexCount, c.setDirty();
        }
      },
          Ar = t("MotionStreakAssemblerManager", {
        getAssembler: function getAssembler() {
          return Tr;
        }
      });
      Cr.Assembler = Ar;
      var Rr = {
        maxParticleDeltaTime: 0,
        createData: function createData() {
          return G.add();
        },
        removeData: function removeData(t) {
          G.remove(t);
        },
        updateRenderData: function updateRenderData() {},
        fillBuffers: function fillBuffers() {}
      },
          xr = t("ParticleSystem2DAssembler", {
        getAssembler: function getAssembler() {
          return Rr.maxParticleDeltaTime || (Rr.maxParticleDeltaTime = l.game.frameTime / 1e3 * 2), Rr;
        }
      });
      Sr.Assembler = xr;
    }
  };
}); 
 			}); 
		define("__plugin__/wx0446ba2621dda60a/particle.js", function(require, module, exports){ 			
"use strict";

require("@babel/runtime/helpers/Arrayincludes");

System.register(["./texture-barrier-60b5983b.js", "./json-asset-933a1d4c.js", "./index-f2b92470.js", "./renderable-component-7c6600ed.js", "./deprecated-26630860.js", "./deprecated-ef6bb945.js", "./index-5d4b7661.js", "./create-mesh-39923017.js", "./mesh-f5415e9d.js", "./mesh-renderer-fb3b7695.js", "./deprecated-6c081405.js", "./skeleton-b0039cea.js", "./skeletal-animation-utils-121f35a2.js", "./deprecated-e75308d4.js"], function (t) {
  "use strict";

  var e, i, r, a, n, o, s, l, u, h, c, _, d, p, f, m, y, v, b, g, M, S, w, T, x, O, z, R, E, A, C, P, D, F, I, B, L, U, V, H, k, N, G, W, j, X, K, Y, Z, q, Q, $, J, tt, et, it, rt, at, nt, ot, st, lt, ut, ht, ct, _t, dt, pt, ft, mt, yt, vt, bt, gt, Mt, St, wt, Tt, xt, Ot, zt, Rt, Et, At, Ct, Pt, Dt, Ft, It, Bt;

  return {
    setters: [function (t) {
      e = t.bT, i = t.W, r = t.aC, a = t.a_, n = t.m, o = t.l, s = t.bU, l = t.c0, u = t.c1, h = t.b$, c = t.i, _ = t.a$, d = t.al, p = t.o, f = t.q, m = t.ap, y = t.an, v = t.b3, b = t.bB, g = t.bv, M = t.cw, S = t.cS, w = t.R, T = t.A, x = t.f, O = t.u, z = t.P, R = t.cT, E = t.bX;
    }, function (t) {
      A = t.bW, C = t.bZ, P = t.aT, D = t.cd, F = t.a5, I = t.aW, B = t.bo, L = t.cg, U = t.ch, V = t.cc, H = t.T, k = t.ae, N = t.ad, G = t.bm, W = t.bX, j = t.Q, X = t.aO, K = t.ac, Y = t.d$, Z = t.bp, q = t.cs, Q = t.aS, $ = t.c_, J = t.dy, tt = t.dT, et = t.am, it = t.b$, rt = t.V, at = t.M, nt = t.bY, ot = t.dj, st = t.W, lt = t.Z, ut = t.ai, ht = t.af, ct = t.ag, _t = t.ah, dt = t.e0, pt = t.dl, ft = t.an, mt = t.aa, yt = t.ci, vt = t.x, bt = t.dr, gt = t.ce, Mt = t.bJ, St = t.bM, wt = t.dz, Tt = t.ds, xt = t.de, Ot = t.aH, zt = t.b6, Rt = t.ay, Et = t.ax;
    }, function () {}, function (t) {
      At = t.f, Ct = t.M, Pt = t.p;
    }, function () {}, function (t) {
      Dt = t.d, Ft = t.D;
    }, function () {}, function (t) {
      It = t.c;
    }, function (t) {
      Bt = t.M;
    }, function () {}, function () {}, function () {}, function () {}, function () {}],
    execute: function execute() {
      var Lt,
          Ut,
          Vt,
          Ht,
          kt,
          Nt,
          Gt,
          Wt,
          jt,
          Xt,
          Kt,
          Yt,
          Zt,
          qt,
          Qt,
          $t,
          Jt,
          te,
          ee,
          ie,
          re = (Lt = A("cc.Billboard"), Ut = L(), Vt = U(), Ht = C(P), kt = C(P), Nt = V(), Gt = V(), Wt = V(), jt = V(), Jt = Lt(Xt = Ut(Xt = Vt(Xt = D(($t = function (t) {
        function l() {
          var e;
          return e = t.call(this) || this, u(e, "_texture", Yt, h(e)), u(e, "_height", Zt, h(e)), u(e, "_width", qt, h(e)), u(e, "_rotation", Qt, h(e)), e._model = null, e._mesh = null, e._material = null, e._uniform = new H(1, 1, 0, 0), e;
        }

        e(l, t);
        var c = l.prototype;
        return c.onLoad = function () {
          this.createModel();
        }, c.onEnable = function () {
          this.attachToScene(), this._model.enabled = !0, this.width = this._width, this.height = this._height, this.rotation = this.rotation, this.texture = this.texture;
        }, c.onDisable = function () {
          this.detachFromScene();
        }, c.attachToScene = function () {
          this._model && this.node && this.node.scene && (this._model.scene && this.detachFromScene(), this._getRenderScene().addModel(this._model));
        }, c.detachFromScene = function () {
          this._model && this._model.scene && this._model.scene.removeModel(this._model);
        }, c.createModel = function () {
          this._mesh = It({
            primitiveMode: i.TRIANGLE_LIST,
            positions: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            uvs: [0, 0, 1, 0, 0, 1, 1, 1],
            colors: [F.WHITE.r, F.WHITE.g, F.WHITE.b, F.WHITE.a, F.WHITE.r, F.WHITE.g, F.WHITE.b, F.WHITE.a, F.WHITE.r, F.WHITE.g, F.WHITE.b, F.WHITE.a, F.WHITE.r, F.WHITE.g, F.WHITE.b, F.WHITE.a],
            attributes: [new r(a.ATTR_POSITION, n.RGB32F), new r(a.ATTR_TEX_COORD, n.RG32F), new r(a.ATTR_COLOR, n.RGBA8UI, !0)],
            indices: [0, 1, 2, 1, 2, 3]
          }, void 0, {
            calculateBounds: !1
          });
          var t = this._model = o.director.root.createModel(At, this.node);
          t.node = t.transform = this.node, null == this._material && (this._material = new I(), this._material.copy(B.get("default-billboard-material"))), t.initSubModel(0, this._mesh.renderingSubMeshes[0], this._material);
        }, s(l, [{
          key: "texture",
          get: function get() {
            return this._texture;
          },
          set: function set(t) {
            this._texture = t, this._material && this._material.setProperty("mainTexture", t);
          }
        }, {
          key: "height",
          get: function get() {
            return this._height;
          },
          set: function set(t) {
            this._height = t, this._material && (this._uniform.y = t, this._material.setProperty("cc_size_rotation", this._uniform));
          }
        }, {
          key: "width",
          get: function get() {
            return this._width;
          },
          set: function set(t) {
            this._width = t, this._material && (this._uniform.x = t, this._material.setProperty("cc_size_rotation", this._uniform));
          }
        }, {
          key: "rotation",
          get: function get() {
            return Math.round(100 * k(this._rotation)) / 100;
          },
          set: function set(t) {
            this._rotation = N(t), this._material && (this._uniform.z = this._rotation, this._material.setProperty("cc_size_rotation", this._uniform));
          }
        }]), l;
      }(G), Yt = l((Kt = $t).prototype, "_texture", [Ht], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return null;
        }
      }), l(Kt.prototype, "texture", [kt, Nt], Object.getOwnPropertyDescriptor(Kt.prototype, "texture"), Kt.prototype), Zt = l(Kt.prototype, "_height", [W], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 0;
        }
      }), l(Kt.prototype, "height", [Gt], Object.getOwnPropertyDescriptor(Kt.prototype, "height"), Kt.prototype), qt = l(Kt.prototype, "_width", [W], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 0;
        }
      }), l(Kt.prototype, "width", [Wt], Object.getOwnPropertyDescriptor(Kt.prototype, "width"), Kt.prototype), Qt = l(Kt.prototype, "_rotation", [W], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 0;
        }
      }), l(Kt.prototype, "rotation", [jt], Object.getOwnPropertyDescriptor(Kt.prototype, "rotation"), Kt.prototype), Xt = Kt)) || Xt) || Xt) || Xt) || Xt, t({
        Billboard: Jt,
        BillboardComponent: Jt
      }), Jt),
          ae = [new r(a.ATTR_POSITION, n.RGB32F), new r(a.ATTR_TEX_COORD, n.RGBA32F), new r(a.ATTR_TEX_COORD1, n.RGB32F), new r(a.ATTR_COLOR, n.RGBA8, !0)],
          ne = new j(),
          oe = new j(),
          se = function (t) {
        function r() {
          var e;
          return (e = t.call(this) || this)._capacity = void 0, e._vertSize = 0, e._vBuffer = null, e._vertAttrsFloatCount = 0, e._vdataF32 = null, e._vdataUint32 = null, e._iaInfo = void 0, e._iaInfoBuffer = void 0, e._subMeshData = null, e._vertCount = 0, e._indexCount = 0, e._material = null, e.type = Ct.LINE, e._capacity = 100, e._iaInfo = new m([new y()]), e._iaInfoBuffer = e._device.createBuffer(new d(p.INDIRECT, f.DEVICE, v, v)), e;
        }

        e(r, t);
        var a = r.prototype;
        return a.setCapacity = function (t) {
          this._capacity = t, this.createBuffer();
        }, a.createBuffer = function () {
          this._vertSize = 0;

          for (var t, e = c(ae); !(t = e()).done;) {
            var i = t.value;
            i.offset = this._vertSize, this._vertSize += _[i.format].size;
          }

          this._vertAttrsFloatCount = this._vertSize / 4, this._vBuffer = this.createSubMeshData(), this._vdataF32 = new Float32Array(this._vBuffer), this._vdataUint32 = new Uint32Array(this._vBuffer);
        }, a.updateMaterial = function (e) {
          this._material = e, t.prototype.setSubModelMaterial.call(this, 0, e);
        }, a.createSubMeshData = function () {
          this._subMeshData && this.destroySubMeshData(), this._vertCount = 2, this._indexCount = 6;

          var t = this._device.createBuffer(new d(p.VERTEX | p.TRANSFER_DST, f.DEVICE, this._vertSize * this._capacity * this._vertCount, this._vertSize)),
              e = new ArrayBuffer(this._vertSize * this._capacity * this._vertCount);

          t.update(e);

          for (var r = new Uint16Array((this._capacity - 1) * this._indexCount), a = 0, n = 0; n < this._capacity - 1; ++n) {
            var o = 2 * n;
            r[a++] = o, r[a++] = o + 1, r[a++] = o + 2, r[a++] = o + 3, r[a++] = o + 2, r[a++] = o + 1;
          }

          var s = this._device.createBuffer(new d(p.INDEX | p.TRANSFER_DST, f.DEVICE, (this._capacity - 1) * this._indexCount * Uint16Array.BYTES_PER_ELEMENT, Uint16Array.BYTES_PER_ELEMENT));

          return s.update(r), this._iaInfo.drawInfos[0].vertexCount = this._capacity * this._vertCount, this._iaInfo.drawInfos[0].indexCount = (this._capacity - 1) * this._indexCount, this._iaInfoBuffer.update(this._iaInfo), this._subMeshData = new X([t], ae, i.TRIANGLE_LIST, s, this._iaInfoBuffer), this.initSubModel(0, this._subMeshData, this._material), e;
        }, a.addLineVertexData = function (t, e, i) {
          if (t.length > 1) {
            var r = 0;
            j.subtract(ne, t[1], t[0]), this._vdataF32[r++] = t[0].x, this._vdataF32[r++] = t[0].y, this._vdataF32[r++] = t[0].z, this._vdataF32[r++] = 0, this._vdataF32[r++] = e.evaluate(0, 1), this._vdataF32[r++] = 0, this._vdataF32[r++] = 0, this._vdataF32[r++] = ne.x, this._vdataF32[r++] = ne.y, this._vdataF32[r++] = ne.z, this._vdataUint32[r++] = i.evaluate(0, 1)._val, this._vdataF32[r++] = t[0].x, this._vdataF32[r++] = t[0].y, this._vdataF32[r++] = t[0].z, this._vdataF32[r++] = 1, this._vdataF32[r++] = e.evaluate(0, 1), this._vdataF32[r++] = 0, this._vdataF32[r++] = 1, this._vdataF32[r++] = ne.x, this._vdataF32[r++] = ne.y, this._vdataF32[r++] = ne.z, this._vdataUint32[r++] = i.evaluate(0, 1)._val;

            for (var a = 1; a < t.length - 1; a++) {
              j.subtract(ne, t[a - 1], t[a]), j.subtract(oe, t[a + 1], t[a]), j.subtract(oe, oe, ne);
              var n = a / t.length;
              this._vdataF32[r++] = t[a].x, this._vdataF32[r++] = t[a].y, this._vdataF32[r++] = t[a].z, this._vdataF32[r++] = 0, this._vdataF32[r++] = e.evaluate(n, 1), this._vdataF32[r++] = n, this._vdataF32[r++] = 0, this._vdataF32[r++] = oe.x, this._vdataF32[r++] = oe.y, this._vdataF32[r++] = oe.z, this._vdataUint32[r++] = i.evaluate(n, 1)._val, this._vdataF32[r++] = t[a].x, this._vdataF32[r++] = t[a].y, this._vdataF32[r++] = t[a].z, this._vdataF32[r++] = 1, this._vdataF32[r++] = e.evaluate(n, 1), this._vdataF32[r++] = n, this._vdataF32[r++] = 1, this._vdataF32[r++] = oe.x, this._vdataF32[r++] = oe.y, this._vdataF32[r++] = oe.z, this._vdataUint32[r++] = i.evaluate(n, 1)._val;
            }

            j.subtract(ne, t[t.length - 1], t[t.length - 2]), this._vdataF32[r++] = t[t.length - 1].x, this._vdataF32[r++] = t[t.length - 1].y, this._vdataF32[r++] = t[t.length - 1].z, this._vdataF32[r++] = 0, this._vdataF32[r++] = e.evaluate(1, 1), this._vdataF32[r++] = 1, this._vdataF32[r++] = 0, this._vdataF32[r++] = ne.x, this._vdataF32[r++] = ne.y, this._vdataF32[r++] = ne.z, this._vdataUint32[r++] = i.evaluate(1, 1)._val, this._vdataF32[r++] = t[t.length - 1].x, this._vdataF32[r++] = t[t.length - 1].y, this._vdataF32[r++] = t[t.length - 1].z, this._vdataF32[r++] = 1, this._vdataF32[r++] = e.evaluate(1, 1), this._vdataF32[r++] = 1, this._vdataF32[r++] = 1, this._vdataF32[r++] = ne.x, this._vdataF32[r++] = ne.y, this._vdataF32[r++] = ne.z, this._vdataUint32[r++] = i.evaluate(1, 1)._val;
          }

          this.updateIA(Math.max(0, t.length - 1));
        }, a.updateIA = function (t) {
          this._subModels[0].inputAssembler.vertexBuffers[0].update(this._vdataF32), this._iaInfo.drawInfos[0].firstIndex = 0, this._iaInfo.drawInfos[0].indexCount = this._indexCount * t, this._iaInfoBuffer.update(this._iaInfo);
        }, a.destroySubMeshData = function () {
          this._subMeshData && (this._subMeshData.destroy(), this._subMeshData = null);
        }, r;
      }(At),
          le = b.Attr.setClassAttr,
          ue = [["mode", "constant", "multiplier"], ["mode", "spline", "multiplier"], ["mode", "splineMin", "splineMax", "multiplier"], ["mode", "constantMin", "constantMax", "multiplier"]],
          he = g({
        Constant: 0,
        Curve: 1,
        TwoCurves: 2,
        TwoConstants: 3
      }),
          ce = t("CurveRange", A("cc.CurveRange")((ie = ee = function () {
        function t() {
          this.mode = he.Constant, this.spline = Y(), this.splineMin = Y(), this.splineMax = Y(), this.constant = 0, this.constantMin = 0, this.constantMax = 0, this.multiplier = 1;
        }

        var e = t.prototype;
        return e.evaluate = function (t, e) {
          switch (this.mode) {
            default:
            case he.Constant:
              return this.constant;

            case he.Curve:
              return this.spline.evaluate(t) * this.multiplier;

            case he.TwoCurves:
              return K(this.splineMin.evaluate(t), this.splineMax.evaluate(t), e) * this.multiplier;

            case he.TwoConstants:
              return K(this.constantMin, this.constantMax, e);
          }
        }, e.getMax = function () {
          switch (this.mode) {
            default:
            case he.Constant:
              return this.constant;

            case he.Curve:
              return this.multiplier;

            case he.TwoConstants:
              return this.constantMax;

            case he.TwoCurves:
              return this.multiplier;
          }
        }, e._onBeforeSerialize = function () {
          return ue[this.mode];
        }, s(t, [{
          key: "curve",
          get: function get() {
            var t;
            return null !== (t = this._curve) && void 0 !== t ? t : this._curve = new q(this.spline);
          },
          set: function set(t) {
            this._curve = t, this.spline = t._internalCurve;
          }
        }, {
          key: "curveMin",
          get: function get() {
            var t;
            return null !== (t = this._curveMin) && void 0 !== t ? t : this._curveMin = new q(this.splineMin);
          },
          set: function set(t) {
            this._curveMin = t, this.splineMin = t._internalCurve;
          }
        }, {
          key: "curveMax",
          get: function get() {
            var t;
            return null !== (t = this._curveMax) && void 0 !== t ? t : this._curveMax = new q(this.splineMax);
          },
          set: function set(t) {
            this._curveMax = t, this.splineMax = t._internalCurve;
          }
        }]), t;
      }(), ee.Mode = he, te = ie)) || te);

      function _e(t, e, i) {
        switch (t.mode) {
          case he.Constant:
            return t.constant;

          case he.Curve:
            return t.spline.evaluate(e) * t.multiplier;

          case he.TwoCurves:
            return 0 === i ? t.splineMin.evaluate(e) * t.multiplier : t.splineMax.evaluate(e) * t.multiplier;

          case he.TwoConstants:
            return 0 === i ? t.constantMin : t.constantMax;

          default:
            return 0;
        }
      }

      function de(t) {
        switch (t.mode) {
          case he.TwoConstants:
          case he.TwoCurves:
            return 2;

          default:
            return 1;
        }
      }

      function pe(t, e, i) {
        var r = new Q({
          width: e,
          height: i,
          _data: t,
          _compressed: !1,
          format: $.RGBA32F
        }),
            a = new P();
        return a.setFilters(J.NEAREST, J.NEAREST), a.setMipFilter(J.NONE), a.setWrapMode(tt.CLAMP_TO_EDGE, tt.CLAMP_TO_EDGE, tt.CLAMP_TO_EDGE), a.image = r, a;
      }

      function fe(t, e, i, r, a) {
        for (var n = Math.max(de(e), de(i), de(r)), o = new Float32Array(t * n * 4), s = [e, i, r], l = 1 / (t - 1), u = 0; u < n; u++) {
          for (var h = 0; h < 3; h++) {
            for (var c = s[h], _ = 0, d = 0, p = 0; p < t; p++) {
              var f = _e(c, l * p, u);

              d = a ? f : (_ += f) / (p + 1), o[4 * p + h] = d;
            }
          }
        }

        return pe(o, t, n);
      }

      b.fastDefine("cc.CurveRange", ce, {
        multiplier: 1,
        constantMax: 0,
        constantMin: 0,
        constant: 0,
        mode: he.Constant,
        splineMax: Object.freeze(Y()),
        splineMin: Object.freeze(Y()),
        spline: Object.freeze(Y())
      }), le(ce, "multiplier", "visible", !0), le(ce, "constantMax", "visible", !0), le(ce, "constantMin", "visible", !0), le(ce, "constant", "visible", !0), le(ce, "mode", "type", "Enum"), le(ce, "mode", "enumList", g.getList(he)), le(ce, "mode", "visible", !0), le(ce, "splineMax", "type", "Object"), le(ce, "splineMax", "ctor", Z), le(ce, "splineMax", "visible", !0), le(ce, "splineMin", "type", "Object"), le(ce, "splineMin", "ctor", Z), le(ce, "splineMin", "visible", !0), le(ce, "spline", "type", "Object"), le(ce, "spline", "ctor", Z), le(ce, "spline", "visible", !0);
      var me = g({
        Blend: 0,
        Fixed: 1
      }),
          ye = t("ColorKey", function () {
        this.color = F.WHITE.clone(), this.time = 0;
      });
      b.fastDefine("cc.ColorKey", ye, {
        color: F.WHITE.clone(),
        time: 0
      }), b.Attr.setClassAttr(ye, "color", "visible", !0), b.Attr.setClassAttr(ye, "time", "visible", !0);
      var ve = t("AlphaKey", function () {
        this.alpha = 1, this.time = 0;
      });
      b.fastDefine("cc.AlphaKey", ve, {
        alpha: 1,
        time: 0
      }), b.Attr.setClassAttr(ve, "alpha", "visible", !0), b.Attr.setClassAttr(ve, "time", "visible", !0);
      var be,
          ge,
          Me,
          Se,
          we,
          Te,
          xe,
          Oe,
          ze,
          Re,
          Ee,
          Ae,
          Ce,
          Pe,
          De,
          Fe,
          Ie,
          Be = t("Gradient", function () {
        function t() {
          this.colorKeys = new Array(), this.alphaKeys = new Array(), this.mode = me.Blend, this._color = void 0, this._color = F.WHITE.clone();
        }

        var e = t.prototype;
        return e.setKeys = function (t, e) {
          this.colorKeys = t, this.alphaKeys = e;
        }, e.sortKeys = function () {
          this.colorKeys.length > 1 && this.colorKeys.sort(function (t, e) {
            return t.time - e.time;
          }), this.alphaKeys.length > 1 && this.alphaKeys.sort(function (t, e) {
            return t.time - e.time;
          });
        }, e.evaluate = function (t) {
          return this.getRGB(t), this._color._set_a_unsafe(this.getAlpha(t)), this._color;
        }, e.randomColor = function () {
          var t = this.colorKeys[Math.trunc(Math.random() * this.colorKeys.length)],
              e = this.alphaKeys[Math.trunc(Math.random() * this.alphaKeys.length)];
          return this._color.set(t.color), this._color._set_a_unsafe(e.alpha), this._color;
        }, e.getRGB = function (t) {
          if (this.colorKeys.length > 1) {
            t = et(t, 1);

            for (var e = 1; e < this.colorKeys.length; ++e) {
              var i = this.colorKeys[e - 1].time,
                  r = this.colorKeys[e].time;

              if (t >= i && t < r) {
                if (this.mode === me.Fixed) return this.colorKeys[e].color;
                var a = (t - i) / (r - i);
                return F.lerp(this._color, this.colorKeys[e - 1].color, this.colorKeys[e].color, a), this._color;
              }
            }

            var n = this.colorKeys.length - 1;
            return t < this.colorKeys[0].time ? F.lerp(this._color, F.BLACK, this.colorKeys[0].color, t / this.colorKeys[0].time) : t > this.colorKeys[n].time && F.lerp(this._color, this.colorKeys[n].color, F.BLACK, (t - this.colorKeys[n].time) / (1 - this.colorKeys[n].time)), this._color;
          }

          return 1 === this.colorKeys.length ? (this._color.set(this.colorKeys[0].color), this._color) : (this._color.set(F.WHITE), this._color);
        }, e.getAlpha = function (t) {
          if (this.alphaKeys.length > 1) {
            t = et(t, 1);

            for (var e = 1; e < this.alphaKeys.length; ++e) {
              var i = this.alphaKeys[e - 1].time,
                  r = this.alphaKeys[e].time;

              if (t >= i && t < r) {
                if (this.mode === me.Fixed) return this.alphaKeys[e].alpha;
                var a = (t - i) / (r - i);
                return K(this.alphaKeys[e - 1].alpha, this.alphaKeys[e].alpha, a);
              }
            }

            var n = this.alphaKeys.length - 1;
            return t < this.alphaKeys[0].time ? K(0, this.alphaKeys[0].alpha, t / this.alphaKeys[0].time) : t > this.alphaKeys[n].time ? K(this.alphaKeys[n].alpha, 0, (t - this.alphaKeys[n].time) / (1 - this.alphaKeys[n].time)) : 255;
          }

          return 1 === this.alphaKeys.length ? this.alphaKeys[0].alpha : 255;
        }, t;
      }());
      Be.Mode = me, b.fastDefine("cc.Gradient", Be, {
        colorKeys: [],
        alphaKeys: [],
        mode: me.Blend
      }), b.Attr.setClassAttr(Be, "colorKeys", "visible", !0), b.Attr.setClassAttr(Be, "alphaKeys", "visible", !0), b.Attr.setClassAttr(Be, "mode", "visible", !0);

      var Le,
          Ue,
          Ve,
          He,
          ke,
          Ne,
          Ge,
          We,
          je,
          Xe,
          Ke,
          Ye,
          Ze,
          qe,
          Qe,
          $e,
          Je,
          ti,
          ei,
          ii,
          ri,
          ai,
          ni,
          oi,
          si,
          li,
          ui,
          hi,
          ci,
          _i,
          di,
          pi,
          fi,
          mi,
          yi,
          vi,
          bi,
          gi,
          Mi = M,
          Si = g({
        Color: 0,
        Gradient: 1,
        TwoColors: 2,
        TwoGradients: 3,
        RandomColor: 4
      }),
          wi = t("GradientRange", (be = A("cc.GradientRange"), ge = C(Si), Me = C(Be), Se = C(Be), we = C(Be), Te = C(Si), be((Ie = Fe = function () {
        function t() {
          u(this, "color", ze, this), u(this, "colorMin", Re, this), u(this, "colorMax", Ee, this), u(this, "gradient", Ae, this), u(this, "gradientMin", Ce, this), u(this, "gradientMax", Pe, this), u(this, "_mode", De, this), this._color = F.WHITE.clone();
        }

        var e = t.prototype;
        return e.evaluate = function (t, e) {
          switch (this._mode) {
            case Si.Color:
              return this.color;

            case Si.TwoColors:
              return F.lerp(this._color, this.colorMin, this.colorMax, e), this._color;

            case Si.RandomColor:
              return this.gradient.randomColor();

            case Si.Gradient:
              return this.gradient.evaluate(t);

            case Si.TwoGradients:
              return F.lerp(this._color, this.gradientMin.evaluate(t), this.gradientMax.evaluate(t), e), this._color;

            default:
              return this.color;
          }
        }, e._onBeforeSerialize = function () {
          return Mi[this._mode];
        }, s(t, [{
          key: "mode",
          get: function get() {
            return this._mode;
          },
          set: function set(t) {
            this._mode = t;
          }
        }]), t;
      }(), Fe.Mode = Si, l((Oe = Ie).prototype, "mode", [ge], Object.getOwnPropertyDescriptor(Oe.prototype, "mode"), Oe.prototype), ze = l(Oe.prototype, "color", [W, it], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return F.WHITE.clone();
        }
      }), Re = l(Oe.prototype, "colorMin", [W, it], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return F.WHITE.clone();
        }
      }), Ee = l(Oe.prototype, "colorMax", [W, it], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return F.WHITE.clone();
        }
      }), Ae = l(Oe.prototype, "gradient", [Me], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return new Be();
        }
      }), Ce = l(Oe.prototype, "gradientMin", [Se], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return new Be();
        }
      }), Pe = l(Oe.prototype, "gradientMax", [we], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return new Be();
        }
      }), De = l(Oe.prototype, "_mode", [Te], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return Si.Color;
        }
      }), xe = Oe)) || xe));

      function Ti(t, e, i) {
        switch (t.mode) {
          case Si.Color:
            return t.color;

          case Si.TwoColors:
            return 0 === i ? t.colorMin : t.colorMax;

          case Si.RandomColor:
            return t.gradient.randomColor();

          case Si.Gradient:
            return t.gradient.evaluate(e);

          case Si.TwoGradients:
            return 0 === i ? t.gradientMin.evaluate(e) : t.gradientMax.evaluate(e);

          default:
            return t.color;
        }
      }

      var xi = {
        parent: null,
        owner: null,
        subModelIdx: 0
      },
          Oi = {
        CC_USE_WORLD_SPACE: !1
      },
          zi = function (e) {
        return t({
          Line: e,
          LineComponent: e
        }), e;
      }((Le = A("cc.Line"), Ue = L(), Ve = U(), He = C(P), ke = C(P), Ne = nt(), Ge = V(), We = nt(), je = V(), Xe = C([j]), Ke = C([j]), Ye = nt(), Ze = V(), qe = C(ce), Qe = C(ce), $e = ot(), Je = nt(), ti = V(), ei = C(rt), ii = nt(), ri = V(), ai = C(rt), ni = nt(), oi = V(), si = C(wi), li = C(wi), ui = nt(), hi = V(), Le(ci = Ue(ci = Ve(ci = D((gi = function (t) {
        function i() {
          var e;
          return e = t.call(this) || this, u(e, "_texture", di, h(e)), e._material = null, e._materialInstance = null, u(e, "_worldSpace", pi, h(e)), u(e, "_positions", fi, h(e)), u(e, "_width", mi, h(e)), u(e, "_tile", yi, h(e)), u(e, "_offset", vi, h(e)), u(e, "_color", bi, h(e)), e._model = null, e._tile_offset = new H(), e;
        }

        e(i, t);
        var r = i.prototype;
        return r.onLoad = function () {
          var t = this._model = o.director.root.createModel(se);
          t.node = t.transform = this.node, null === this._material && (this._material = new I(), this._material.copy(B.get("default-trail-material")), Oi.CC_USE_WORLD_SPACE = this.worldSpace, xi.parent = this._material, xi.subModelIdx = 0, this._materialInstance = new at(xi), xi.parent = null, xi.subModelIdx = 0, this._materialInstance.recompileShaders(Oi)), t.updateMaterial(this._materialInstance), t.setCapacity(100);
        }, r.onEnable = function () {
          this._model && (this._attachToScene(), this.texture = this._texture, this.tile = this._tile, this.offset = this._offset, this._model.addLineVertexData(this._positions, this._width, this._color));
        }, r.onDisable = function () {
          this._model && this._detachFromScene();
        }, r._attachToScene = function () {
          this._model && this.node && this.node.scene && (this._model.scene && this._detachFromScene(), this._getRenderScene().addModel(this._model));
        }, r._detachFromScene = function () {
          this._model && this._model.scene && this._model.scene.removeModel(this._model);
        }, s(i, [{
          key: "texture",
          get: function get() {
            return this._texture;
          },
          set: function set(t) {
            this._texture = t, this._materialInstance && this._materialInstance.setProperty("mainTexture", t);
          }
        }, {
          key: "worldSpace",
          get: function get() {
            return this._worldSpace;
          },
          set: function set(t) {
            this._worldSpace = t, this._materialInstance && (Oi.CC_USE_WORLD_SPACE = this.worldSpace, this._materialInstance.recompileShaders(Oi), this._model && this._model.setSubModelMaterial(0, this._materialInstance));
          }
        }, {
          key: "positions",
          get: function get() {
            return this._positions;
          },
          set: function set(t) {
            this._positions = t, this._model && this._model.addLineVertexData(this._positions, this._width, this._color);
          }
        }, {
          key: "width",
          get: function get() {
            return this._width;
          },
          set: function set(t) {
            this._width = t, this._model && this._model.addLineVertexData(this._positions, this._width, this._color);
          }
        }, {
          key: "tile",
          get: function get() {
            return this._tile;
          },
          set: function set(t) {
            this._tile.set(t), this._materialInstance && (this._tile_offset.x = this._tile.x, this._tile_offset.y = this._tile.y, this._materialInstance.setProperty("mainTiling_Offset", this._tile_offset));
          }
        }, {
          key: "offset",
          get: function get() {
            return this._offset;
          },
          set: function set(t) {
            this._offset.set(t), this._materialInstance && (this._tile_offset.z = this._offset.x, this._tile_offset.w = this._offset.y, this._materialInstance.setProperty("mainTiling_Offset", this._tile_offset));
          }
        }, {
          key: "color",
          get: function get() {
            return this._color;
          },
          set: function set(t) {
            this._color = t, this._model && this._model.addLineVertexData(this._positions, this._width, this._color);
          }
        }]), i;
      }(G), di = l((_i = gi).prototype, "_texture", [He], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return null;
        }
      }), l(_i.prototype, "texture", [ke, Ne, Ge], Object.getOwnPropertyDescriptor(_i.prototype, "texture"), _i.prototype), pi = l(_i.prototype, "_worldSpace", [W], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !1;
        }
      }), l(_i.prototype, "worldSpace", [We, je], Object.getOwnPropertyDescriptor(_i.prototype, "worldSpace"), _i.prototype), fi = l(_i.prototype, "_positions", [Xe], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return [];
        }
      }), l(_i.prototype, "positions", [Ke, Ye, Ze], Object.getOwnPropertyDescriptor(_i.prototype, "positions"), _i.prototype), mi = l(_i.prototype, "_width", [qe], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return new ce();
        }
      }), l(_i.prototype, "width", [Qe, $e, Je, ti], Object.getOwnPropertyDescriptor(_i.prototype, "width"), _i.prototype), yi = l(_i.prototype, "_tile", [W], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return new rt(1, 1);
        }
      }), l(_i.prototype, "tile", [ei, ii, ri], Object.getOwnPropertyDescriptor(_i.prototype, "tile"), _i.prototype), vi = l(_i.prototype, "_offset", [W], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return new rt(0, 0);
        }
      }), l(_i.prototype, "offset", [ai, ni, oi], Object.getOwnPropertyDescriptor(_i.prototype, "offset"), _i.prototype), bi = l(_i.prototype, "_color", [si], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return new wi();
        }
      }), l(_i.prototype, "color", [li, ui, hi], Object.getOwnPropertyDescriptor(_i.prototype, "color"), _i.prototype), ci = _i)) || ci) || ci) || ci) || ci)),
          Ri = function () {
        function t(t) {
          this.particleSystem = void 0, this.position = void 0, this.velocity = void 0, this.animatedVelocity = void 0, this.ultimateVelocity = void 0, this.angularVelocity = void 0, this.axisOfRotation = void 0, this.rotation = void 0, this.startEuler = void 0, this.startRotation = void 0, this.startRotated = void 0, this.deltaQuat = void 0, this.deltaMat = void 0, this.localMat = void 0, this.startSize = void 0, this.size = void 0, this.startColor = void 0, this.color = void 0, this.randomSeed = void 0, this.remainingLifetime = void 0, this.loopCount = void 0, this.lastLoop = void 0, this.trailDelay = void 0, this.startLifetime = void 0, this.emitAccumulator0 = void 0, this.emitAccumulator1 = void 0, this.frameIndex = void 0, this.startRow = void 0, this.particleSystem = t, this.position = new j(0, 0, 0), this.velocity = new j(0, 0, 0), this.animatedVelocity = new j(0, 0, 0), this.ultimateVelocity = new j(0, 0, 0), this.angularVelocity = new j(0, 0, 0), this.axisOfRotation = new j(0, 0, 0), this.rotation = new j(0, 0, 0), this.startEuler = new j(0, 0, 0), this.startRotation = new st(), this.startRotated = !1, this.deltaQuat = new st(), this.deltaMat = new lt(), this.localMat = new lt(), this.startSize = new j(0, 0, 0), this.size = new j(0, 0, 0), this.startColor = F.WHITE.clone(), this.color = F.WHITE.clone(), this.randomSeed = 0, this.remainingLifetime = 0, this.loopCount = 0, this.lastLoop = 0, this.trailDelay = 0, this.startLifetime = 0, this.emitAccumulator0 = 0, this.emitAccumulator1 = 0, this.frameIndex = 0, this.startRow = 0;
        }

        return t.prototype.reset = function () {
          this.rotation.set(0, 0, 0), this.startEuler.set(0, 0, 0), this.startRotation.set(0, 0, 0, 1), this.startRotated = !1, this.deltaQuat.set(0, 0, 0, 1), this.deltaMat.identity(), this.localMat.identity();
        }, t;
      }();

      Ri.INDENTIFY_NEG_QUAT = 10, Ri.R2D = 180 / Math.PI;

      var Ei,
          Ai,
          Ci,
          Pi,
          Di,
          Fi,
          Ii,
          Bi,
          Li,
          Ui,
          Vi,
          Hi,
          ki,
          Ni,
          Gi,
          Wi,
          ji,
          Xi,
          Ki,
          Yi,
          Zi,
          qi,
          Qi,
          $i,
          Ji,
          tr,
          er,
          ir,
          rr,
          ar,
          nr,
          or,
          sr,
          lr,
          ur = "colorModule",
          hr = "rotationModule",
          cr = "sizeModule",
          _r = "textureModule",
          dr = ["sizeModule", "colorModule", "forceModule", "velocityModule", "limitModule", "rotationModule", "textureModule"],
          pr = ["_colorOverLifetimeModule", "_shapeModule", "_sizeOvertimeModule", "_velocityOvertimeModule", "_forceOvertimeModule", "_limitVelocityOvertimeModule", "_rotationOvertimeModule", "_textureAnimationModule", "_trailModule"],
          fr = function () {
        function t() {
          this.target = null, this.needUpdate = !1, this.needAnimate = !0, this.name = void 0;
        }

        var e = t.prototype;
        return e.bindTarget = function (t) {
          this.target = t;
        }, e.update = function () {}, t;
      }(),
          mr = g({
        World: 0,
        Local: 1,
        Custom: 2
      }),
          yr = g({
        Pause: 0,
        PauseAndCatchup: 1,
        AlwaysSimulate: 2
      }),
          vr = g({
        World: 0,
        Local: 1,
        View: 2
      }),
          br = g({
        Billboard: 0,
        StrecthedBillboard: 1,
        HorizontalBillboard: 2,
        VerticalBillboard: 3,
        Mesh: 4
      }),
          gr = g({
        Box: 0,
        Circle: 1,
        Cone: 2,
        Sphere: 3,
        Hemisphere: 4
      }),
          Mr = g({
        Base: 0,
        Edge: 1,
        Shell: 2,
        Volume: 3
      }),
          Sr = g({
        Random: 0,
        Loop: 1,
        PingPong: 2
      }),
          wr = g({
        Particles: 0
      }),
          Tr = g({
        Stretch: 0
      }),
          xr = (Ei = A("cc.ColorOvertimeModule"), Ai = nt(), Ci = C(wi), Pi = nt(), Ei((Li = function (t) {
        function i() {
          for (var e, i = arguments.length, r = new Array(i), a = 0; a < i; a++) {
            r[a] = arguments[a];
          }

          return e = t.call.apply(t, [this].concat(r)) || this, u(e, "_enable", Ii, h(e)), u(e, "color", Bi, h(e)), e.name = ur, e;
        }

        return e(i, t), i.prototype.animate = function (t) {
          t.color.set(t.startColor), t.color.multiply(this.color.evaluate(1 - t.remainingLifetime / t.startLifetime, ut(t.randomSeed + 91041)));
        }, s(i, [{
          key: "enable",
          get: function get() {
            return this._enable;
          },
          set: function set(t) {
            this._enable !== t && (this._enable = t, this.target && this.target.enableModule(this.name, t, this));
          }
        }]), i;
      }(fr), Ii = l((Fi = Li).prototype, "_enable", [W], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !1;
        }
      }), l(Fi.prototype, "enable", [Ai], Object.getOwnPropertyDescriptor(Fi.prototype, "enable"), Fi.prototype), Bi = l(Fi.prototype, "color", [Ci, W, Pi], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return new wi();
        }
      }), Di = Fi)) || Di),
          Or = new j(0, 0, -1);

      function zr(t, e, i, r) {
        return e !== t ? (t === mr.World || lt.invert(i, i), lt.getRotation(r, i), !0) : (st.set(r, 0, 0, 0, 1), !1);
      }

      function Rr(t, e) {
        rt.set(t, Math.cos(e), Math.sin(e));
      }

      function Er(t) {
        var e = ct(-1, 1),
            i = ct(0, 2 * Math.PI),
            r = Math.sqrt(1 - e * e),
            a = r * Math.cos(i),
            n = r * Math.sin(i);
        j.set(t, a, n, e);
      }

      function Ar(t, e, i) {
        Er(t), j.multiplyScalar(t, t, e + (i - e) * ht());
      }

      function Cr(t, e, i, r) {
        Rr(t, r), t.z = 0, j.multiplyScalar(t, t, e + (i - e) * ht());
      }

      function Pr(t) {
        for (var e = 0; e < t.length; e++) {
          var i = e + _t(0, t.length - e),
              r = t[i];

          t[i] = t[e], t[e] = r;
        }
      }

      function Dr() {
        var t = ct(-1, 1);
        return 0 === t && t++, S(t);
      }

      var Fr,
          Ir,
          Br,
          Lr,
          Ur,
          Vr,
          Hr,
          kr,
          Nr,
          Gr,
          Wr,
          jr,
          Xr,
          Kr,
          Yr,
          Zr,
          qr,
          Qr,
          $r,
          Jr,
          ta,
          ea,
          ia,
          ra,
          aa,
          na,
          oa,
          sa,
          la,
          ua,
          ha,
          ca,
          _a,
          da,
          pa,
          fa,
          ma,
          ya,
          va,
          ba,
          ga,
          Ma,
          Sa,
          wa,
          Ta,
          xa,
          Oa,
          za,
          Ra,
          Ea,
          Aa,
          Ca,
          Pa,
          Da,
          Fa,
          Ia,
          Ba,
          La,
          Ua,
          Va,
          Ha = 212165,
          ka = new j(),
          Na = (Ui = A("cc.ForceOvertimeModule"), Vi = nt(), Hi = C(ce), ki = ot(), Ni = nt(), Gi = V(), Wi = C(ce), ji = ot(), Xi = nt(), Ki = V(), Yi = C(ce), Zi = ot(), qi = nt(), Qi = V(), $i = C(mr), Ji = nt(), tr = V(), Ui((lr = function (t) {
        function i() {
          var e;
          return e = t.call(this) || this, u(e, "_enable", rr, h(e)), u(e, "x", ar, h(e)), u(e, "y", nr, h(e)), u(e, "z", or, h(e)), u(e, "space", sr, h(e)), e.randomized = !1, e.rotation = void 0, e.needTransform = void 0, e.name = "forceModule", e.rotation = new st(), e.needTransform = !1, e.needUpdate = !0, e;
        }

        e(i, t);
        var r = i.prototype;
        return r.update = function (t, e) {
          this.needTransform = zr(t, this.space, e, this.rotation);
        }, r.animate = function (t, e) {
          var i = 1 - t.remainingLifetime / t.startLifetime,
              r = j.set(ka, this.x.evaluate(i, ut(t.randomSeed + Ha)), this.y.evaluate(i, ut(t.randomSeed + Ha)), this.z.evaluate(i, ut(t.randomSeed + Ha)));
          this.needTransform && j.transformQuat(r, r, this.rotation), j.scaleAndAdd(t.velocity, t.velocity, r, e), j.copy(t.ultimateVelocity, t.velocity);
        }, s(i, [{
          key: "enable",
          get: function get() {
            return this._enable;
          },
          set: function set(t) {
            this._enable !== t && (this._enable = t, this.target && this.target.enableModule(this.name, t, this));
          }
        }]), i;
      }(fr), rr = l((ir = lr).prototype, "_enable", [W], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !1;
        }
      }), l(ir.prototype, "enable", [Vi], Object.getOwnPropertyDescriptor(ir.prototype, "enable"), ir.prototype), ar = l(ir.prototype, "x", [Hi, W, ki, Ni, Gi], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return new ce();
        }
      }), nr = l(ir.prototype, "y", [Wi, W, ji, Xi, Ki], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return new ce();
        }
      }), or = l(ir.prototype, "z", [Yi, W, Zi, qi, Qi], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return new ce();
        }
      }), sr = l(ir.prototype, "space", [$i, W, Ji, tr], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return mr.Local;
        }
      }), er = ir)) || er),
          Ga = 23541,
          Wa = new j(),
          ja = new j(),
          Xa = (Fr = A("cc.LimitVelocityOvertimeModule"), Ir = nt(), Br = C(ce), Lr = ot(), Ur = nt(), Vr = V(), Hr = C(ce), kr = ot(), Nr = nt(), Gr = V(), Wr = C(ce), jr = ot(), Xr = nt(), Kr = V(), Yr = C(ce), Zr = ot(), qr = nt(), Qr = V(), $r = nt(), Jr = V(), ta = nt(), ea = V(), ia = C(mr), ra = nt(), aa = V(), Fr((fa = function (t) {
        function i() {
          var e;
          return e = t.call(this) || this, u(e, "_enable", sa, h(e)), u(e, "limitX", la, h(e)), u(e, "limitY", ua, h(e)), u(e, "limitZ", ha, h(e)), u(e, "limit", ca, h(e)), u(e, "dampen", _a, h(e)), u(e, "separateAxes", da, h(e)), u(e, "space", pa, h(e)), e.drag = null, e.multiplyDragByParticleSize = !1, e.multiplyDragByParticleVelocity = !1, e.name = "limitModule", e.rotation = void 0, e.needTransform = void 0, e.rotation = new st(), e.needTransform = !1, e.needUpdate = !0, e;
        }

        e(i, t);
        var r = i.prototype;
        return r.update = function (t, e) {
          this.needTransform = zr(t, this.space, e, this.rotation);
        }, r.animate = function (t) {
          var e = 1 - t.remainingLifetime / t.startLifetime,
              i = Wa;
          this.separateAxes ? (j.set(ja, this.limitX.evaluate(e, ut(t.randomSeed + Ga)), this.limitY.evaluate(e, ut(t.randomSeed + Ga)), this.limitZ.evaluate(e, ut(t.randomSeed + Ga))), this.needTransform && j.transformQuat(ja, ja, this.rotation), j.set(i, Ka(t.ultimateVelocity.x, ja.x, this.dampen), Ka(t.ultimateVelocity.y, ja.y, this.dampen), Ka(t.ultimateVelocity.z, ja.z, this.dampen))) : (j.normalize(i, t.ultimateVelocity), j.multiplyScalar(i, i, Ka(t.ultimateVelocity.length(), this.limit.evaluate(e, ut(t.randomSeed + Ga)), this.dampen))), j.copy(t.ultimateVelocity, i);
        }, s(i, [{
          key: "enable",
          get: function get() {
            return this._enable;
          },
          set: function set(t) {
            this._enable !== t && (this._enable = t, this.target && this.target.enableModule(this.name, t, this));
          }
        }]), i;
      }(fr), sa = l((oa = fa).prototype, "_enable", [W], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !1;
        }
      }), l(oa.prototype, "enable", [Ir], Object.getOwnPropertyDescriptor(oa.prototype, "enable"), oa.prototype), la = l(oa.prototype, "limitX", [Br, W, Lr, Ur, Vr], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return new ce();
        }
      }), ua = l(oa.prototype, "limitY", [Hr, W, kr, Nr, Gr], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return new ce();
        }
      }), ha = l(oa.prototype, "limitZ", [Wr, W, jr, Xr, Kr], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return new ce();
        }
      }), ca = l(oa.prototype, "limit", [Yr, W, Zr, qr, Qr], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return new ce();
        }
      }), _a = l(oa.prototype, "dampen", [W, $r, Jr], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 3;
        }
      }), da = l(oa.prototype, "separateAxes", [W, ta, ea], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !1;
        }
      }), pa = l(oa.prototype, "space", [ia, W, ra, aa], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return mr.Local;
        }
      }), na = oa)) || na);

      function Ka(t, e, i) {
        var r = Math.sign(t),
            a = Math.abs(t);
        return a > e && (a = K(a, e, i)), a * r;
      }

      var Ya,
          Za,
          qa,
          Qa,
          $a,
          Ja,
          tn,
          en,
          rn,
          an,
          nn,
          on,
          sn,
          ln,
          un,
          hn,
          cn,
          _n,
          dn,
          pn,
          fn,
          mn,
          yn,
          vn,
          bn,
          gn,
          Mn,
          Sn,
          wn,
          Tn,
          xn,
          On,
          zn,
          Rn,
          En,
          An,
          Cn,
          Pn,
          Dn,
          Fn,
          In,
          Bn,
          Ln,
          Un,
          Vn,
          Hn,
          kn,
          Nn,
          Gn,
          Wn,
          jn,
          Xn,
          Kn,
          Yn,
          Zn,
          qn,
          Qn,
          $n,
          Jn,
          to,
          eo,
          io,
          ro,
          ao,
          no,
          oo,
          so,
          lo,
          uo,
          ho,
          co,
          _o,
          po,
          fo,
          mo,
          yo,
          vo,
          bo,
          go,
          Mo,
          So,
          wo,
          To,
          xo,
          Oo,
          zo,
          Ro,
          Eo,
          Ao,
          Co,
          Po,
          Do,
          Fo,
          Io,
          Bo,
          Lo,
          Uo,
          Vo,
          Ho,
          ko,
          No,
          Go,
          Wo,
          jo,
          Xo,
          Ko,
          Yo,
          Zo,
          qo,
          Qo,
          $o,
          Jo,
          ts,
          es,
          is,
          rs,
          as,
          ns,
          os,
          ss,
          ls,
          us,
          hs,
          cs,
          _s,
          ds,
          ps,
          fs,
          ms,
          ys,
          vs,
          bs,
          gs,
          Ms,
          Ss,
          ws,
          Ts,
          xs,
          Os,
          zs,
          Rs,
          Es,
          As,
          Cs,
          Ps,
          Ds,
          Fs,
          Is,
          Bs,
          Ls,
          Us,
          Vs,
          Hs,
          ks,
          Ns,
          Gs,
          Ws,
          js,
          Xs,
          Ks,
          Ys,
          Zs,
          qs,
          Qs,
          $s,
          Js,
          tl,
          el,
          il,
          rl,
          al,
          nl,
          ol,
          sl,
          ll,
          ul,
          hl,
          cl,
          _l,
          dl,
          pl,
          fl,
          ml,
          yl = (ma = A("cc.RotationOvertimeModule"), ya = nt(), va = nt(), ba = V(), ga = C(ce), Ma = ot(), Sa = nt(), wa = V(), Ta = C(ce), xa = ot(), Oa = nt(), za = V(), Ra = C(ce), Ea = ot(), Aa = nt(), Ca = V(), ma((Va = function (t) {
        function i() {
          for (var e, i = arguments.length, r = new Array(i), a = 0; a < i; a++) {
            r[a] = arguments[a];
          }

          return e = t.call.apply(t, [this].concat(r)) || this, u(e, "_enable", Fa, h(e)), u(e, "_separateAxes", Ia, h(e)), u(e, "x", Ba, h(e)), u(e, "y", La, h(e)), u(e, "z", Ua, h(e)), e.name = hr, e._startMat = new lt(), e._matRot = new lt(), e._quatRot = new st(), e._otherEuler = new j(), e;
        }

        e(i, t);
        var r = i.prototype;
        return r._processRotation = function (t) {
          var e = t.particleSystem.processor.getInfo().renderMode;
          e !== br.Mesh && e === br.StrecthedBillboard && this._quatRot.set(0, 0, 0, 1), st.normalize(this._quatRot, this._quatRot), this._quatRot.w < 0 && (this._quatRot.x += Ri.INDENTIFY_NEG_QUAT);
        }, r.animate = function (t, e) {
          var i = 1 - t.remainingLifetime / t.startLifetime,
              r = ut(t.randomSeed + 125292),
              a = t.particleSystem.processor.getInfo().renderMode;
          this._separateAxes && a !== br.VerticalBillboard && a !== br.HorizontalBillboard ? st.fromEuler(t.deltaQuat, this.x.evaluate(i, r) * e * Ri.R2D, this.y.evaluate(i, r) * e * Ri.R2D, this.z.evaluate(i, r) * e * Ri.R2D) : st.fromEuler(t.deltaQuat, 0, 0, this.z.evaluate(i, r) * e * Ri.R2D), t.deltaMat = lt.fromQuat(t.deltaMat, t.deltaQuat), t.localMat = t.localMat.multiply(t.deltaMat), t.startRotated || (a !== br.Mesh && (a === br.StrecthedBillboard ? t.startEuler.set(0, 0, 0) : a !== br.Billboard && t.startEuler.set(0, 0, t.startEuler.z)), st.fromEuler(t.startRotation, t.startEuler.x * Ri.R2D, t.startEuler.y * Ri.R2D, t.startEuler.z * Ri.R2D), t.startRotated = !0), this._startMat = lt.fromQuat(this._startMat, t.startRotation), this._matRot = this._startMat.multiply(t.localMat), lt.getRotation(this._quatRot, this._matRot), this._processRotation(t, Ri.R2D), t.rotation.set(this._quatRot.x, this._quatRot.y, this._quatRot.z);
        }, s(i, [{
          key: "enable",
          get: function get() {
            return this._enable;
          },
          set: function set(t) {
            this._enable !== t && (this._enable = t, this.target && this.target.enableModule(this.name, t, this));
          }
        }, {
          key: "separateAxes",
          get: function get() {
            return this._separateAxes;
          },
          set: function set(t) {
            this._separateAxes = t;
          }
        }]), i;
      }(fr), Fa = l((Da = Va).prototype, "_enable", [W], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !1;
        }
      }), l(Da.prototype, "enable", [ya], Object.getOwnPropertyDescriptor(Da.prototype, "enable"), Da.prototype), Ia = l(Da.prototype, "_separateAxes", [W], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !1;
        }
      }), l(Da.prototype, "separateAxes", [va, ba], Object.getOwnPropertyDescriptor(Da.prototype, "separateAxes"), Da.prototype), Ba = l(Da.prototype, "x", [ga, W, Ma, dt, Sa, wa], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return new ce();
        }
      }), La = l(Da.prototype, "y", [Ta, W, xa, dt, Oa, za], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return new ce();
        }
      }), Ua = l(Da.prototype, "z", [Ra, W, Ea, dt, Aa, Ca], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return new ce();
        }
      }), Pa = Da)) || Pa),
          vl = (Ya = A("cc.SizeOvertimeModule"), Za = nt(), qa = nt(), Qa = V(), $a = C(ce), Ja = ot(), tn = nt(), en = V(), rn = C(ce), an = ot(), nn = nt(), on = V(), sn = C(ce), ln = ot(), un = nt(), hn = V(), cn = C(ce), _n = ot(), dn = nt(), pn = V(), Ya((wn = function (t) {
        function i() {
          for (var e, i = arguments.length, r = new Array(i), a = 0; a < i; a++) {
            r[a] = arguments[a];
          }

          return e = t.call.apply(t, [this].concat(r)) || this, u(e, "_enable", yn, h(e)), u(e, "separateAxes", vn, h(e)), u(e, "size", bn, h(e)), u(e, "x", gn, h(e)), u(e, "y", Mn, h(e)), u(e, "z", Sn, h(e)), e.name = cr, e;
        }

        return e(i, t), i.prototype.animate = function (t) {
          if (this.separateAxes) {
            var e = 1 - t.remainingLifetime / t.startLifetime,
                i = ut(t.randomSeed + 39825);
            t.size.x = t.startSize.x * this.x.evaluate(e, i), t.size.y = t.startSize.y * this.y.evaluate(e, i), t.size.z = t.startSize.z * this.z.evaluate(e, i);
          } else j.multiplyScalar(t.size, t.startSize, this.size.evaluate(1 - t.remainingLifetime / t.startLifetime, ut(t.randomSeed + 39825)));
        }, s(i, [{
          key: "enable",
          get: function get() {
            return this._enable;
          },
          set: function set(t) {
            this._enable !== t && (this._enable = t, this.target && this.target.enableModule(this.name, t, this));
          }
        }]), i;
      }(fr), yn = l((mn = wn).prototype, "_enable", [W], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !1;
        }
      }), l(mn.prototype, "enable", [Za], Object.getOwnPropertyDescriptor(mn.prototype, "enable"), mn.prototype), vn = l(mn.prototype, "separateAxes", [W, qa, Qa], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !1;
        }
      }), bn = l(mn.prototype, "size", [$a, W, Ja, tn, en], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return new ce();
        }
      }), gn = l(mn.prototype, "x", [rn, W, an, nn, on], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return new ce();
        }
      }), Mn = l(mn.prototype, "y", [sn, W, ln, un, hn], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return new ce();
        }
      }), Sn = l(mn.prototype, "z", [cn, W, _n, dn, pn], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return new ce();
        }
      }), fn = mn)) || fn),
          bl = 90794,
          gl = g({
        Grid: 0
      }),
          Ml = g({
        WholeSheet: 0,
        SingleRow: 1
      }),
          Sl = (Tn = A("cc.TextureAnimationModule"), xn = pt("numTilesX"), On = pt("numTilesY"), zn = nt(), Rn = C(gl), En = C(gl), An = nt(), Cn = V(), Pn = nt(), Dn = V(), Fn = nt(), In = V(), Bn = C(Ml), Ln = nt(), Un = V(), Vn = C(ce), Hn = ot(), kn = nt(), Nn = V(), Gn = C(ce), Wn = ot(), jn = nt(), Xn = V(), Kn = nt(), Yn = V(), Zn = nt(), qn = V(), Qn = nt(), $n = V(), Tn((fo = function (t) {
        function i() {
          for (var e, i = arguments.length, r = new Array(i), a = 0; a < i; a++) {
            r[a] = arguments[a];
          }

          return e = t.call.apply(t, [this].concat(r)) || this, u(e, "_enable", eo, h(e)), u(e, "_numTilesX", io, h(e)), u(e, "_numTilesY", ro, h(e)), u(e, "_mode", ao, h(e)), u(e, "animation", no, h(e)), u(e, "frameOverTime", oo, h(e)), u(e, "startFrame", so, h(e)), u(e, "cycleCount", lo, h(e)), u(e, "_flipU", uo, h(e)), u(e, "_flipV", ho, h(e)), u(e, "_uvChannelMask", co, h(e)), u(e, "randomRow", _o, h(e)), u(e, "rowIndex", po, h(e)), e.name = _r, e;
        }

        e(i, t);
        var r = i.prototype;
        return r.init = function (t) {
          t.startRow = Math.floor(Math.random() * this.numTilesY);
        }, r.animate = function (t) {
          var e = 1 - t.remainingLifetime / t.startLifetime,
              i = this.startFrame.evaluate(e, ut(t.randomSeed + bl)) / (this.numTilesX * this.numTilesY);
          if (this.animation === Ml.WholeSheet) t.frameIndex = et(this.cycleCount * (this.frameOverTime.evaluate(e, ut(t.randomSeed + bl)) + i), 1);else if (this.animation === Ml.SingleRow) {
            var r = 1 / this.numTilesY;

            if (this.randomRow) {
              var a = et(this.cycleCount * (this.frameOverTime.evaluate(e, ut(t.randomSeed + bl)) + i), 1),
                  n = t.startRow * r,
                  o = n + r;
              t.frameIndex = K(n, o, a);
            } else {
              var s = this.rowIndex * r,
                  l = s + r;
              t.frameIndex = K(s, l, et(this.cycleCount * (this.frameOverTime.evaluate(e, ut(t.randomSeed + bl)) + i), 1));
            }
          }
        }, s(i, [{
          key: "enable",
          get: function get() {
            return this._enable;
          },
          set: function set(t) {
            this._enable !== t && (this._enable = t, this.target && (this.target.updateMaterialParams(), this.target.enableModule(this.name, t, this)));
          }
        }, {
          key: "mode",
          get: function get() {
            return this._mode;
          },
          set: function set(t) {
            t !== gl.Grid && console.error("particle texture animation's sprites is not supported!");
          }
        }, {
          key: "numTilesX",
          get: function get() {
            return this._numTilesX;
          },
          set: function set(t) {
            this._numTilesX !== t && (this._numTilesX = t, this.target.updateMaterialParams());
          }
        }, {
          key: "numTilesY",
          get: function get() {
            return this._numTilesY;
          },
          set: function set(t) {
            this._numTilesY !== t && (this._numTilesY = t, this.target.updateMaterialParams());
          }
        }, {
          key: "flipU",
          get: function get() {
            return this._flipU;
          },
          set: function set() {
            console.error("particle texture animation's flipU is not supported!");
          }
        }, {
          key: "flipV",
          get: function get() {
            return this._flipV;
          },
          set: function set() {
            console.error("particle texture animation's flipV is not supported!");
          }
        }, {
          key: "uvChannelMask",
          get: function get() {
            return this._uvChannelMask;
          },
          set: function set() {
            console.error("particle texture animation's uvChannelMask is not supported!");
          }
        }]), i;
      }(fr), eo = l((to = fo).prototype, "_enable", [W], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !1;
        }
      }), io = l(to.prototype, "_numTilesX", [xn], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 0;
        }
      }), ro = l(to.prototype, "_numTilesY", [On], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 0;
        }
      }), l(to.prototype, "enable", [zn], Object.getOwnPropertyDescriptor(to.prototype, "enable"), to.prototype), ao = l(to.prototype, "_mode", [Rn], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return gl.Grid;
        }
      }), l(to.prototype, "mode", [En, An, Cn], Object.getOwnPropertyDescriptor(to.prototype, "mode"), to.prototype), l(to.prototype, "numTilesX", [Pn, Dn], Object.getOwnPropertyDescriptor(to.prototype, "numTilesX"), to.prototype), l(to.prototype, "numTilesY", [Fn, In], Object.getOwnPropertyDescriptor(to.prototype, "numTilesY"), to.prototype), no = l(to.prototype, "animation", [Bn, W, Ln, Un], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return Ml.WholeSheet;
        }
      }), oo = l(to.prototype, "frameOverTime", [Vn, W, Hn, kn, Nn], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return new ce();
        }
      }), so = l(to.prototype, "startFrame", [Gn, W, Wn, jn, Xn], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return new ce();
        }
      }), lo = l(to.prototype, "cycleCount", [W, Kn, Yn], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 0;
        }
      }), uo = l(to.prototype, "_flipU", [W], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 0;
        }
      }), ho = l(to.prototype, "_flipV", [W], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 0;
        }
      }), co = l(to.prototype, "_uvChannelMask", [W], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return -1;
        }
      }), _o = l(to.prototype, "randomRow", [W, Zn, qn], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !1;
        }
      }), po = l(to.prototype, "rowIndex", [W, Qn, $n], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 0;
        }
      }), Jn = to)) || Jn),
          wl = 197866,
          Tl = new j(),
          xl = (mo = A("cc.VelocityOvertimeModule"), yo = nt(), vo = C(ce), bo = ot(), go = nt(), Mo = V(), So = C(ce), wo = ot(), To = nt(), xo = V(), Oo = C(ce), zo = ot(), Ro = nt(), Eo = V(), Ao = C(ce), Co = ot(), Po = nt(), Do = V(), Fo = C(mr), Io = nt(), Bo = V(), mo((jo = function (t) {
        function i() {
          var e;
          return e = t.call(this) || this, u(e, "_enable", Vo, h(e)), u(e, "x", Ho, h(e)), u(e, "y", ko, h(e)), u(e, "z", No, h(e)), u(e, "speedModifier", Go, h(e)), u(e, "space", Wo, h(e)), e.rotation = void 0, e.needTransform = void 0, e.name = "velocityModule", e.rotation = new st(), e.speedModifier.constant = 1, e.needTransform = !1, e.needUpdate = !0, e;
        }

        e(i, t);
        var r = i.prototype;
        return r.update = function (t, e) {
          this.needTransform = zr(t, this.space, e, this.rotation);
        }, r.animate = function (t) {
          var e = 1 - t.remainingLifetime / t.startLifetime,
              i = j.set(Tl, this.x.evaluate(e, ut(t.randomSeed ^ wl)), this.y.evaluate(e, ut(156497 ^ t.randomSeed)), this.z.evaluate(e, ut(984136 ^ t.randomSeed)));
          this.needTransform && j.transformQuat(i, i, this.rotation), j.add(t.animatedVelocity, t.animatedVelocity, i), j.add(t.ultimateVelocity, t.velocity, t.animatedVelocity), j.multiplyScalar(t.ultimateVelocity, t.ultimateVelocity, this.speedModifier.evaluate(1 - t.remainingLifetime / t.startLifetime, ut(t.randomSeed + wl)));
        }, s(i, [{
          key: "enable",
          get: function get() {
            return this._enable;
          },
          set: function set(t) {
            this._enable !== t && (this._enable = t, this.target && this.target.enableModule(this.name, t, this));
          }
        }]), i;
      }(fr), Vo = l((Uo = jo).prototype, "_enable", [W], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !1;
        }
      }), l(Uo.prototype, "enable", [yo], Object.getOwnPropertyDescriptor(Uo.prototype, "enable"), Uo.prototype), Ho = l(Uo.prototype, "x", [vo, W, bo, go, Mo], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return new ce();
        }
      }), ko = l(Uo.prototype, "y", [So, W, wo, To, xo], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return new ce();
        }
      }), No = l(Uo.prototype, "z", [Oo, W, zo, Ro, Eo], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return new ce();
        }
      }), Go = l(Uo.prototype, "speedModifier", [Ao, W, Co, Po, Do], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return new ce();
        }
      }), Wo = l(Uo.prototype, "space", [Fo, W, Io, Bo], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return mr.Local;
        }
      }), Lo = Uo)) || Lo),
          Ol = t("Burst", (Xo = A("cc.Burst"), Ko = C(ce), Yo = ot(), Xo((es = function () {
        function t() {
          u(this, "_time", Qo, this), u(this, "_repeatCount", $o, this), u(this, "repeatInterval", Jo, this), u(this, "count", ts, this), this._remainingCount = void 0, this._curTime = void 0, this._remainingCount = 0, this._curTime = 0;
        }

        var e = t.prototype;
        return e.update = function (t, e) {
          if (0 === this._remainingCount && (this._remainingCount = this._repeatCount, this._curTime = this._time), this._remainingCount > 0) {
            var i = et(t._time - t.startDelay.evaluate(0, 1), t.duration) - e;
            i = i > 0 ? i : 0;
            var r = et(t.time - t.startDelay.evaluate(0, 1), t.duration);
            this._curTime >= i && this._curTime < r && (t.emit(this.count.evaluate(this._curTime / t.duration, 1), e - (r - this._curTime)), this._curTime += this.repeatInterval, --this._remainingCount);
          }
        }, e.reset = function () {
          this._remainingCount = 0, this._curTime = 0;
        }, e.getMaxCount = function (t) {
          return this.count.getMax() * Math.min(Math.ceil(t.duration / this.repeatInterval), this.repeatCount);
        }, s(t, [{
          key: "time",
          get: function get() {
            return this._time;
          },
          set: function set(t) {
            this._time = t, this._curTime = t;
          }
        }, {
          key: "repeatCount",
          get: function get() {
            return this._repeatCount;
          },
          set: function set(t) {
            this._repeatCount = t, this._remainingCount = t;
          }
        }]), t;
      }(), Qo = l((qo = es).prototype, "_time", [W], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 0;
        }
      }), l(qo.prototype, "time", [it], Object.getOwnPropertyDescriptor(qo.prototype, "time"), qo.prototype), $o = l(qo.prototype, "_repeatCount", [W], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 1;
        }
      }), l(qo.prototype, "repeatCount", [it], Object.getOwnPropertyDescriptor(qo.prototype, "repeatCount"), qo.prototype), Jo = l(qo.prototype, "repeatInterval", [W, it], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 1;
        }
      }), ts = l(qo.prototype, "count", [Ko, W, Yo], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return new ce();
        }
      }), Zo = qo)) || Zo)),
          zl = new j(0, 0, 0),
          Rl = [],
          El = new j(.5, .5, .5),
          Al = (is = A("cc.ShapeModule"), rs = nt(), as = V(), ns = nt(), os = V(), ss = nt(), ls = V(), us = nt(), hs = V(), cs = nt(), _s = V(), ds = nt(), ps = C(gr), fs = pt("shapeType"), ms = nt(), ys = C(gr), vs = V(), bs = C(Mr), gs = nt(), Ms = V(), Ss = nt(), ws = V(), Ts = nt(), xs = V(), Os = nt(), zs = V(), Rs = nt(), Es = V(), As = nt(), Cs = V(), Ps = nt(), Ds = V(), Fs = C(Sr), Is = nt(), Bs = V(), Ls = yt(), Us = nt(), Vs = V(), Hs = C(ce), ks = yt(), Ns = ot(), Gs = nt(), Ws = V(), js = nt(), Xs = V(), Ks = nt(), Ys = V(), is((ml = function () {
        function t() {
          u(this, "_enable", Qs, this), u(this, "_shapeType", $s, this), u(this, "emitFrom", Js, this), u(this, "alignToDirection", tl, this), u(this, "randomDirectionAmount", el, this), u(this, "sphericalDirectionAmount", il, this), u(this, "randomPositionAmount", rl, this), u(this, "radius", al, this), u(this, "radiusThickness", nl, this), u(this, "arcMode", ol, this), u(this, "arcSpread", sl, this), u(this, "arcSpeed", ll, this), u(this, "length", ul, this), u(this, "boxThickness", hl, this), u(this, "_position", cl, this), u(this, "_rotation", _l, this), u(this, "_scale", dl, this), u(this, "_arc", pl, this), u(this, "_angle", fl, this), this.mat = void 0, this.quat = void 0, this.particleSystem = void 0, this.lastTime = void 0, this.totalAngle = void 0, this.mat = new lt(), this.quat = new st(), this.particleSystem = null, this.lastTime = 0, this.totalAngle = 0;
        }

        var e = t.prototype;
        return e.onInit = function (t) {
          this.particleSystem = t, this.constructMat(), this.lastTime = this.particleSystem._time;
        }, e.emit = function (t) {
          switch (this.shapeType) {
            case gr.Box:
              !function (t, e, i, r) {
                switch (t) {
                  case Mr.Volume:
                    a = i, n = El, j.set(a, ct(-n.x, n.x), ct(-n.y, n.y), ct(-n.z, n.z));
                    break;

                  case Mr.Shell:
                    Rl.splice(0, Rl.length), Rl.push(ct(-.5, .5)), Rl.push(ct(-.5, .5)), Rl.push(.5 * Dr()), Pr(Rl), Cl(Rl, e), j.set(i, Rl[0], Rl[1], Rl[2]);
                    break;

                  case Mr.Edge:
                    Rl.splice(0, Rl.length), Rl.push(ct(-.5, .5)), Rl.push(.5 * Dr()), Rl.push(.5 * Dr()), Pr(Rl), Cl(Rl, e), j.set(i, Rl[0], Rl[1], Rl[2]);
                    break;

                  default:
                    console.warn(t + " is not supported for box emitter.");
                }

                var a, n;
                j.copy(r, Or);
              }(this.emitFrom, this.boxThickness, t.position, t.velocity);
              break;

            case gr.Circle:
              e = this.radius, i = this.radiusThickness, r = this.generateArcAngle(), a = t.position, n = t.velocity, Cr(a, e * (1 - i), e, r), j.normalize(n, a);
              break;

            case gr.Cone:
              !function (t, e, i, r, a, n, o, s) {
                switch (t) {
                  case Mr.Base:
                    Cr(o, e * (1 - i), e, r), rt.multiplyScalar(s, o, Math.sin(a)), s.z = -Math.cos(a) * e, j.normalize(s, s), o.z = 0;
                    break;

                  case Mr.Shell:
                    Rr(o, r), rt.multiplyScalar(s, o, Math.sin(a)), s.z = -Math.cos(a), j.normalize(s, s), rt.multiplyScalar(o, o, e), o.z = 0;
                    break;

                  case Mr.Volume:
                    Cr(o, e * (1 - i), e, r), rt.multiplyScalar(s, o, Math.sin(a)), s.z = -Math.cos(a) * e, j.normalize(s, s), o.z = 0, j.add(o, o, j.multiplyScalar(zl, s, n * ht() / -s.z));
                    break;

                  default:
                    console.warn(t + " is not supported for cone emitter.");
                }
              }(this.emitFrom, this.radius, this.radiusThickness, this.generateArcAngle(), this._angle, this.length, t.position, t.velocity);
              break;

            case gr.Sphere:
              !function (t, e, i, r, a) {
                switch (t) {
                  case Mr.Volume:
                    Ar(r, e * (1 - i), e), j.normalize(a, r);
                    break;

                  case Mr.Shell:
                    Er(r), j.multiplyScalar(r, r, e), j.normalize(a, r);
                    break;

                  default:
                    console.warn(t + " is not supported for sphere emitter.");
                }
              }(this.emitFrom, this.radius, this.radiusThickness, t.position, t.velocity);
              break;

            case gr.Hemisphere:
              !function (t, e, i, r, a) {
                switch (t) {
                  case Mr.Volume:
                    Ar(r, e * (1 - i), e), r.z > 0 && (r.z *= -1), j.normalize(a, r);
                    break;

                  case Mr.Shell:
                    Er(r), j.multiplyScalar(r, r, e), r.z > 0 && (r.z *= -1), j.normalize(a, r);
                    break;

                  default:
                    console.warn(t + " is not supported for hemisphere emitter.");
                }
              }(this.emitFrom, this.radius, this.radiusThickness, t.position, t.velocity);
              break;

            default:
              console.warn(this.shapeType + " shapeType is not supported by ShapeModule.");
          }

          var e, i, r, a, n;

          if (this.randomPositionAmount > 0 && (t.position.x += ct(-this.randomPositionAmount, this.randomPositionAmount), t.position.y += ct(-this.randomPositionAmount, this.randomPositionAmount), t.position.z += ct(-this.randomPositionAmount, this.randomPositionAmount)), j.transformQuat(t.velocity, t.velocity, this.quat), j.transformMat4(t.position, t.position, this.mat), this.sphericalDirectionAmount > 0) {
            var o = j.normalize(zl, t.position);
            j.lerp(t.velocity, t.velocity, o, this.sphericalDirectionAmount);
          }

          this.lastTime = this.particleSystem._time;
        }, e.constructMat = function () {
          st.fromEuler(this.quat, this._rotation.x, this._rotation.y, this._rotation.z), lt.fromRTS(this.mat, this.quat, this._position, this._scale);
        }, e.generateArcAngle = function () {
          if (this.arcMode === Sr.Random) return ct(0, this._arc);
          var t = this.totalAngle + 2 * Math.PI * this.arcSpeed.evaluate(this.particleSystem._time, 1) * (this.particleSystem._time - this.lastTime);

          switch (this.totalAngle = t, 0 !== this.arcSpread && (t = Math.floor(t / (this._arc * this.arcSpread)) * this._arc * this.arcSpread), this.arcMode) {
            case Sr.Loop:
              return et(t, this._arc);

            case Sr.PingPong:
              return ft(t, this._arc);

            default:
              return et(t, this._arc);
          }
        }, s(t, [{
          key: "position",
          get: function get() {
            return this._position;
          },
          set: function set(t) {
            this._position = t, this.constructMat();
          }
        }, {
          key: "rotation",
          get: function get() {
            return this._rotation;
          },
          set: function set(t) {
            this._rotation = t, this.constructMat();
          }
        }, {
          key: "scale",
          get: function get() {
            return this._scale;
          },
          set: function set(t) {
            this._scale = t, this.constructMat();
          }
        }, {
          key: "arc",
          get: function get() {
            return k(this._arc);
          },
          set: function set(t) {
            this._arc = N(t);
          }
        }, {
          key: "angle",
          get: function get() {
            return Math.round(100 * k(this._angle)) / 100;
          },
          set: function set(t) {
            this._angle = N(t);
          }
        }, {
          key: "enable",
          get: function get() {
            return this._enable;
          },
          set: function set(t) {
            this._enable = t;
          }
        }, {
          key: "shapeType",
          get: function get() {
            return this._shapeType;
          },
          set: function set(t) {
            switch (this._shapeType = t, this._shapeType) {
              case gr.Box:
                this.emitFrom === Mr.Base && (this.emitFrom = Mr.Volume);
                break;

              case gr.Cone:
                this.emitFrom === Mr.Edge && (this.emitFrom = Mr.Base);
                break;

              case gr.Sphere:
              case gr.Hemisphere:
                this.emitFrom !== Mr.Base && this.emitFrom !== Mr.Edge || (this.emitFrom = Mr.Volume);
            }
          }
        }]), t;
      }(), l((qs = ml).prototype, "position", [rs, as], Object.getOwnPropertyDescriptor(qs.prototype, "position"), qs.prototype), l(qs.prototype, "rotation", [ns, os], Object.getOwnPropertyDescriptor(qs.prototype, "rotation"), qs.prototype), l(qs.prototype, "scale", [ss, ls], Object.getOwnPropertyDescriptor(qs.prototype, "scale"), qs.prototype), l(qs.prototype, "arc", [us, hs], Object.getOwnPropertyDescriptor(qs.prototype, "arc"), qs.prototype), l(qs.prototype, "angle", [cs, _s], Object.getOwnPropertyDescriptor(qs.prototype, "angle"), qs.prototype), Qs = l(qs.prototype, "_enable", [W], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !1;
        }
      }), l(qs.prototype, "enable", [ds], Object.getOwnPropertyDescriptor(qs.prototype, "enable"), qs.prototype), $s = l(qs.prototype, "_shapeType", [ps, fs, ms], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return gr.Cone;
        }
      }), l(qs.prototype, "shapeType", [ys, vs], Object.getOwnPropertyDescriptor(qs.prototype, "shapeType"), qs.prototype), Js = l(qs.prototype, "emitFrom", [bs, W, gs, Ms], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return Mr.Volume;
        }
      }), tl = l(qs.prototype, "alignToDirection", [W, Ss, ws], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !1;
        }
      }), el = l(qs.prototype, "randomDirectionAmount", [W, Ts, xs], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 0;
        }
      }), il = l(qs.prototype, "sphericalDirectionAmount", [W, Os, zs], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 0;
        }
      }), rl = l(qs.prototype, "randomPositionAmount", [W, Rs, Es], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 0;
        }
      }), al = l(qs.prototype, "radius", [W, As, Cs], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 1;
        }
      }), nl = l(qs.prototype, "radiusThickness", [W, Ps, Ds], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 1;
        }
      }), ol = l(qs.prototype, "arcMode", [Fs, W, Is, Bs], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return Sr.Random;
        }
      }), sl = l(qs.prototype, "arcSpread", [Ls, W, Us, Vs], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 0;
        }
      }), ll = l(qs.prototype, "arcSpeed", [Hs, ks, Ns, W, Gs, Ws], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return new ce();
        }
      }), ul = l(qs.prototype, "length", [W, js, Xs], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 5;
        }
      }), hl = l(qs.prototype, "boxThickness", [W, Ks, Ys], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return new j(0, 0, 0);
        }
      }), cl = l(qs.prototype, "_position", [W], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return new j(0, 0, 0);
        }
      }), _l = l(qs.prototype, "_rotation", [W], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return new j(0, 0, 0);
        }
      }), dl = l(qs.prototype, "_scale", [W], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return new j(1, 1, 1);
        }
      }), pl = l(qs.prototype, "_arc", [W], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return N(360);
        }
      }), fl = l(qs.prototype, "_angle", [W], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return N(25);
        }
      }), Zs = qs)) || Zs);

      function Cl(t, e) {
        e.x > 0 && (t[0] += .5 * ct(-e.x, e.x), t[0] = mt(t[0], -.5, .5)), e.y > 0 && (t[1] += .5 * ct(-e.y, e.y), t[1] = mt(t[1], -.5, .5)), e.z > 0 && (t[2] += .5 * ct(-e.z, e.z), t[2] = mt(t[2], -.5, .5));
      }

      var Pl,
          Dl,
          Fl,
          Il,
          Bl,
          Ll,
          Ul,
          Vl,
          Hl,
          kl,
          Nl,
          Gl,
          Wl,
          jl,
          Xl,
          Kl,
          Yl,
          Zl,
          ql,
          Ql,
          $l,
          Jl,
          tu,
          eu,
          iu,
          ru,
          au,
          nu,
          ou,
          su,
          lu,
          uu,
          hu,
          cu,
          _u = [0, 0, 1, 0, 0, 1, 1, 1],
          du = function (t) {
        function r() {
          var e;
          return (e = t.call(this) || this)._capacity = void 0, e._vertAttrs = void 0, e._vertSize = void 0, e._vBuffer = void 0, e._vertAttrsFloatCount = void 0, e._vdataF32 = void 0, e._vdataUint32 = void 0, e._iaInfo = void 0, e._iaInfoBuffer = void 0, e._subMeshData = void 0, e._mesh = void 0, e._vertCount = 0, e._indexCount = 0, e._startTimeOffset = 0, e._lifeTimeOffset = 0, e._material = null, e.type = Ct.PARTICLE_BATCH, e._capacity = 0, e._vertAttrs = null, e._vertSize = 0, e._vBuffer = null, e._vertAttrsFloatCount = 0, e._vdataF32 = null, e._vdataUint32 = null, e._iaInfo = new m([new y()]), e._iaInfoBuffer = e._device.createBuffer(new d(p.INDIRECT, f.HOST | f.DEVICE, v, v)), e._subMeshData = null, e._mesh = null, e;
        }

        e(r, t);
        var n = r.prototype;
        return n.setCapacity = function (t) {
          var e = this._capacity !== t;
          this._capacity = t, this._subMeshData && e && this.rebuild();
        }, n.setVertexAttributes = function (t, e) {
          if (this._mesh !== t || this._vertAttrs !== e) {
            this._mesh = t, this._vertAttrs = e, this._vertSize = 0;

            for (var i, r = c(this._vertAttrs); !(i = r()).done;) {
              var a = i.value;
              a.offset = this._vertSize, this._vertSize += _[a.format].size;
            }

            this._vertAttrsFloatCount = this._vertSize / 4, this.rebuild();
          }
        }, n.createSubMeshData = function () {
          this.destroySubMeshData(), this._vertCount = 4, this._indexCount = 6, this._mesh && (this._vertCount = this._mesh.struct.vertexBundles[this._mesh.struct.primitives[0].vertexBundelIndices[0]].view.count, this._indexCount = this._mesh.struct.primitives[0].indexView.count);

          var t = this._device.createBuffer(new d(p.VERTEX | p.TRANSFER_DST, f.HOST | f.DEVICE, this._vertSize * this._capacity * this._vertCount, this._vertSize)),
              e = new ArrayBuffer(this._vertSize * this._capacity * this._vertCount);

          if (this._mesh && this._capacity > 0) {
            var r = this._vertAttrs[this._vertAttrs.findIndex(function (t) {
              return t.name === a.ATTR_TEX_COORD;
            })].offset;

            this._mesh.copyAttribute(0, a.ATTR_TEX_COORD, e, this._vertSize, r);

            var n = this._vertAttrs.findIndex(function (t) {
              return t.name === a.ATTR_TEX_COORD3;
            });

            if (r = this._vertAttrs[n++].offset, this._mesh.copyAttribute(0, a.ATTR_POSITION, e, this._vertSize, r), r = this._vertAttrs[n++].offset, this._mesh.copyAttribute(0, a.ATTR_NORMAL, e, this._vertSize, r), r = this._vertAttrs[n++].offset, !this._mesh.copyAttribute(0, a.ATTR_COLOR, e, this._vertSize, r)) for (var o = new Uint32Array(e), s = 0; s < this._vertCount; ++s) {
              o[s * this._vertAttrsFloatCount + r / 4] = F.WHITE._val;
            }

            for (var l = new Float32Array(e), u = 1; u < this._capacity; u++) {
              l.copyWithin(u * this._vertSize * this._vertCount / 4, 0, this._vertSize * this._vertCount / 4);
            }
          }

          t.update(e);
          var h = new Uint16Array(this._capacity * this._indexCount);

          if (this._mesh && this._capacity > 0) {
            this._mesh.copyIndices(0, h);

            for (var c = 1; c < this._capacity; c++) {
              for (var _ = 0; _ < this._indexCount; _++) {
                h[c * this._indexCount + _] = h[_] + c * this._vertCount;
              }
            }
          } else for (var m = 0, y = 0; y < this._capacity; ++y) {
            var b = 4 * y;
            h[m++] = b, h[m++] = b + 1, h[m++] = b + 2, h[m++] = b + 3, h[m++] = b + 2, h[m++] = b + 1;
          }

          var g = this._device.createBuffer(new d(p.INDEX | p.TRANSFER_DST, f.DEVICE, this._capacity * this._indexCount * Uint16Array.BYTES_PER_ELEMENT, Uint16Array.BYTES_PER_ELEMENT));

          return g.update(h), this._iaInfo.drawInfos[0].vertexCount = this._capacity * this._vertCount, this._iaInfo.drawInfos[0].indexCount = this._capacity * this._indexCount, this._iaInfoBuffer || (this._iaInfoBuffer = this._device.createBuffer(new d(p.INDIRECT, f.HOST | f.DEVICE, v, v))), this._iaInfoBuffer.update(this._iaInfo), this._subMeshData = new X([t], this._vertAttrs, i.TRIANGLE_LIST, g, this._iaInfoBuffer), this.initSubModel(0, this._subMeshData, this._material), e;
        }, n.updateMaterial = function (t) {
          this._material = t, this.setSubModelMaterial(0, t);
        }, n.addParticleVertexData = function (t, e) {
          if (this._mesh) for (var i = 0; i < this._vertCount; i++) {
            var r = (t * this._vertCount + i) * this._vertAttrsFloatCount;
            this._vdataF32[r++] = e[0].x, this._vdataF32[r++] = e[0].y, this._vdataF32[r++] = e[0].z, r += 2, this._vdataF32[r++] = e[1].z, this._vdataF32[r++] = e[2].x, this._vdataF32[r++] = e[2].y, this._vdataF32[r++] = e[2].z, this._vdataF32[r++] = e[3].x, this._vdataF32[r++] = e[3].y, this._vdataF32[r++] = e[3].z, this._vdataUint32[r++] = e[4];
          } else {
            var a = t * this._vertAttrsFloatCount;
            this._vdataF32[a++] = e[0].x, this._vdataF32[a++] = e[0].y, this._vdataF32[a++] = e[0].z, this._vdataF32[a++] = e[1].x, this._vdataF32[a++] = e[1].y, this._vdataF32[a++] = e[1].z, this._vdataF32[a++] = e[2].x, this._vdataF32[a++] = e[2].y, this._vdataF32[a++] = e[2].z, this._vdataF32[a++] = e[3].x, this._vdataF32[a++] = e[3].y, this._vdataF32[a++] = e[3].z, this._vdataUint32[a++] = e[4], e[5] && (this._vdataF32[a++] = e[5].x, this._vdataF32[a++] = e[5].y, this._vdataF32[a++] = e[5].z);
          }
        }, n.addGPUParticleVertexData = function (t, e, i) {
          for (var r = e * this._vertAttrsFloatCount * this._vertCount, a = 0; a < this._vertCount; a++) {
            var n = r;
            this._vdataF32[n++] = t.position.x, this._vdataF32[n++] = t.position.y, this._vdataF32[n++] = t.position.z, this._vdataF32[n++] = i, this._vdataF32[n++] = t.startSize.x, this._vdataF32[n++] = t.startSize.y, this._vdataF32[n++] = t.startSize.z, this._vdataF32[n++] = _u[2 * a], this._vdataF32[n++] = t.rotation.x, this._vdataF32[n++] = t.rotation.y, this._vdataF32[n++] = t.rotation.z, this._vdataF32[n++] = _u[2 * a + 1], this._vdataF32[n++] = t.startColor.r / 255, this._vdataF32[n++] = t.startColor.g / 255, this._vdataF32[n++] = t.startColor.b / 255, this._vdataF32[n++] = t.startColor.a / 255, this._vdataF32[n++] = t.velocity.x, this._vdataF32[n++] = t.velocity.y, this._vdataF32[n++] = t.velocity.z, this._vdataF32[n++] = t.startLifetime, this._vdataF32[n++] = t.randomSeed, r += this._vertAttrsFloatCount;
          }
        }, n.updateGPUParticles = function (t, e, i) {
          for (var r = this._vertAttrsFloatCount * this._vertCount, a = 0, n = 0, o = 0, s = 0; s < t; ++s) {
            a = s * r, n = this._vdataF32[a + this._startTimeOffset], this._vdataF32[a + this._lifeTimeOffset] - (e - n) < i && (o = --t * r, this._vdataF32.copyWithin(a, o, o + r), s--);
          }

          return t;
        }, n.constructAttributeIndex = function () {
          if (this._vertAttrs) {
            var t = this._vertAttrs.findIndex(function (t) {
              return "a_position_starttime" === t.name;
            }),
                e = this._vertAttrs[t].offset;

            this._startTimeOffset = e / 4 + 3, t = this._vertAttrs.findIndex(function (t) {
              return "a_dir_life" === t.name;
            }), e = this._vertAttrs[t].offset, this._lifeTimeOffset = e / 4 + 3;
          }
        }, n.updateIA = function (t) {
          t <= 0 || (this._subModels[0].inputAssembler.vertexBuffers[0].update(this._vdataF32), this._iaInfo.drawInfos[0].firstIndex = 0, this._iaInfo.drawInfos[0].indexCount = this._indexCount * t, this._iaInfoBuffer.update(this._iaInfo));
        }, n.clear = function () {
          this._subModels[0].inputAssembler.indexCount = 0;
        }, n.destroy = function () {
          t.prototype.destroy.call(this), this._vertAttrs = null, this._vBuffer = null, this._vdataF32 = null, this._vdataUint32 = null, this._material = null, this._mesh = null, this.destroySubMeshData(), this._iaInfoBuffer && (this._iaInfoBuffer.destroy(), this._iaInfoBuffer = null);
        }, n.rebuild = function () {
          this._vBuffer = this.createSubMeshData(), this._vdataF32 = new Float32Array(this._vBuffer), this._vdataUint32 = new Uint32Array(this._vBuffer);
        }, n.destroySubMeshData = function () {
          this._subMeshData && (this._subMeshData.destroy(), this._subMeshData = null, this._iaInfoBuffer = null);
        }, r;
      }(At),
          pu = function () {
        function t(t) {
          this._particleSystem = null, this._model = null, this._renderInfo = null, this._vertAttrs = [], this._renderInfo = t;
        }

        var e = t.prototype;
        return e.getInfo = function () {
          return this._renderInfo;
        }, e.onInit = function (t) {
          this._particleSystem = t;
        }, e.onEnable = function () {
          if (this._particleSystem) {
            this.attachToScene();
            var t = this._model;
            t && (t.node = t.transform = this._particleSystem.node);
          }
        }, e.onDisable = function () {
          this.detachFromScene();
        }, e.onDestroy = function () {
          this._model && (o.director.root.destroyModel(this._model), this._model = null);
        }, e.attachToScene = function () {
          this._model && (this._model.scene && this.detachFromScene(), this._particleSystem._getRenderScene().addModel(this._model));
        }, e.detachFromScene = function () {
          this._model && this._model.scene && this._model.scene.removeModel(this._model);
        }, e.setVertexAttributes = function () {
          this._model && this._model.setVertexAttributes(this._renderInfo.renderMode === br.Mesh ? this._renderInfo.mesh : null, this._vertAttrs);
        }, e.clear = function () {
          this._model && (this._model.enabled = !1);
        }, e.getModel = function () {
          return this._model;
        }, e._initModel = function () {
          this._model || (this._model = o.director.root.createModel(du), this._model.setCapacity(this._particleSystem.capacity), this._model.visFlags = this._particleSystem.visibility);
        }, e.updateTrailMaterial = function () {}, e.getDefaultTrailMaterial = function () {
          return null;
        }, t;
      }(),
          fu = new j(),
          mu = new lt(),
          yu = new st(),
          vu = (new j(), ["_colorOverLifetimeModule", "_sizeOvertimeModule", "_velocityOvertimeModule", "_forceOvertimeModule", "_limitVelocityOvertimeModule", "_rotationOvertimeModule", "_textureAnimationModule"]),
          bu = [0, 0, 1, 0, 0, 1, 1, 1],
          gu = [new r(a.ATTR_POSITION, n.RGB32F), new r(a.ATTR_TEX_COORD, n.RGB32F), new r(a.ATTR_TEX_COORD1, n.RGB32F), new r(a.ATTR_TEX_COORD2, n.RGB32F), new r(a.ATTR_COLOR, n.RGBA8, !0)],
          Mu = [new r(a.ATTR_POSITION, n.RGB32F), new r(a.ATTR_TEX_COORD, n.RGB32F), new r(a.ATTR_TEX_COORD1, n.RGB32F), new r(a.ATTR_TEX_COORD2, n.RGB32F), new r(a.ATTR_COLOR, n.RGBA8, !0), new r(a.ATTR_COLOR1, n.RGB32F)],
          Su = [new r(a.ATTR_POSITION, n.RGB32F), new r(a.ATTR_TEX_COORD, n.RGB32F), new r(a.ATTR_TEX_COORD1, n.RGB32F), new r(a.ATTR_TEX_COORD2, n.RGB32F), new r(a.ATTR_COLOR, n.RGBA8, !0), new r(a.ATTR_TEX_COORD3, n.RGB32F), new r(a.ATTR_NORMAL, n.RGB32F), new r(a.ATTR_COLOR1, n.RGBA8, !0)],
          wu = {
        parent: null,
        owner: null,
        subModelIdx: 0
      },
          Tu = function (t) {
        function i(e) {
          var i;
          return (i = t.call(this, e) || this)._defines = void 0, i._trailDefines = void 0, i._frameTile_velLenScale = void 0, i._tmp_velLenScale = void 0, i._defaultMat = null, i._node_scale = void 0, i._attrs = void 0, i._particles = null, i._defaultTrailMat = null, i._updateList = new Map(), i._animateList = new Map(), i._runAnimateList = new Array(), i._fillDataFunc = null, i._uScaleHandle = 0, i._uLenHandle = 0, i._uNodeRotHandle = 0, i._alignSpace = vr.View, i._inited = !1, i._localMat = new lt(), i._gravity = new H(), i._model = null, i._frameTile_velLenScale = new H(1, 1, 0, 0), i._tmp_velLenScale = i._frameTile_velLenScale.clone(), i._node_scale = new H(), i._attrs = new Array(5), i._defines = {
            CC_USE_WORLD_SPACE: !0,
            CC_USE_BILLBOARD: !0,
            CC_USE_STRETCHED_BILLBOARD: !1,
            CC_USE_HORIZONTAL_BILLBOARD: !1,
            CC_USE_VERTICAL_BILLBOARD: !1
          }, i._trailDefines = {
            CC_USE_WORLD_SPACE: !0
          }, i;
        }

        e(i, t);
        var r = i.prototype;
        return r.onInit = function (e) {
          var i = this;
          t.prototype.onInit.call(this, e), this._particles = new w(function () {
            return new Ri(i);
          }, 16), this._setVertexAttrib(), this._setFillFunc(), this._initModuleList(), this._initModel(), this.updateMaterialParams(), this.updateTrailMaterial(), this.setVertexAttributes(), this._inited = !0;
        }, r.clear = function () {
          t.prototype.clear.call(this), this._particles.reset(), this._particleSystem._trailModule && this._particleSystem._trailModule.clear(), this.updateRenderData(), this._model.enabled = !1;
        }, r.updateRenderMode = function () {
          this._setVertexAttrib(), this._setFillFunc(), this.updateMaterialParams(), this.setVertexAttributes();
        }, r.onDestroy = function () {
          var e;
          null === (e = this._particles) || void 0 === e || e.destroy(), t.prototype.onDestroy.call(this);
        }, r.getFreeParticle = function () {
          return this._particles.length >= this._particleSystem.capacity ? null : this._particles.add();
        }, r.getDefaultTrailMaterial = function () {
          return this._defaultTrailMat;
        }, r.setNewParticle = function () {}, r._initModuleList = function () {
          var t = this;
          vu.forEach(function (e) {
            var i = t._particleSystem[e];
            i && i.enable && (i.needUpdate && (t._updateList[i.name] = i), i.needAnimate && (t._animateList[i.name] = i));
          }), this._runAnimateList.length = 0;

          for (var e = 0, i = dr.length; e < i; e++) {
            var r = this._animateList[dr[e]];
            r && this._runAnimateList.push(r);
          }
        }, r.enableModule = function (t, e, i) {
          e ? (i.needUpdate && (this._updateList[i.name] = i), i.needAnimate && (this._animateList[i.name] = i)) : (delete this._animateList[t], delete this._updateList[t]), this._runAnimateList.length = 0;

          for (var r = 0, a = dr.length; r < a; r++) {
            var n = this._animateList[dr[r]];
            n && this._runAnimateList.push(n);
          }

          this.updateMaterialParams();
        }, r.updateAlignSpace = function (t) {
          this._alignSpace = t;
        }, r.getDefaultMaterial = function () {
          return this._defaultMat;
        }, r.updateRotation = function (t) {
          t && this.doUpdateRotation(t);
        }, r.doUpdateRotation = function (t) {
          if (this._renderInfo.renderMode === br.Mesh || this._alignSpace !== vr.View) {
            if (this._alignSpace === vr.Local) this._particleSystem.node.getRotation(yu);else if (this._alignSpace === vr.World) this._particleSystem.node.getWorldRotation(yu);else if (this._alignSpace === vr.View) {
              var e;
              yu.set(0, 0, 0, 1);
              var i = null === (e = this._particleSystem.node.scene.renderScene) || void 0 === e ? void 0 : e.cameras;
              if (void 0 !== i) for (var r = 0; r < (null == i ? void 0 : i.length); ++r) {
                var a = i[r];

                if ((a.visibility & this._particleSystem.node.layer) === this._particleSystem.node.layer) {
                  st.fromViewUp(yu, a.forward);
                  break;
                }
              }
            } else yu.set(0, 0, 0, 1);
            t.setUniform(this._uNodeRotHandle, yu);
          }
        }, r.updateScale = function (t) {
          t && this.doUpdateScale(t);
        }, r.doUpdateScale = function (t) {
          switch (this._particleSystem.scaleSpace) {
            case mr.Local:
              this._particleSystem.node.getScale(this._node_scale);

              break;

            case mr.World:
              this._particleSystem.node.getWorldScale(this._node_scale);

          }

          t.setUniform(this._uScaleHandle, this._node_scale);
        }, r.updateParticles = function (t) {
          var e = this,
              i = this._particleSystem;
          if (!i) return this._particles.length;
          i.node.getWorldMatrix(mu);

          var r = (i.getMaterialInstance(0) || this._defaultMat).passes[0];

          this.doUpdateScale(r), this.doUpdateRotation(r), this._updateList.forEach(function (t) {
            t.update(i._simulationSpace, mu);
          });
          var a = i._trailModule,
              n = a && a.enable;

          if (n && a.update(), i.simulationSpace === mr.Local) {
            var o = i.node.getRotation();
            lt.fromQuat(this._localMat, o), this._localMat.transpose();
          }

          for (var s = function s(r) {
            var o = e._particles.data[r];
            if (o.remainingLifetime -= t, j.set(o.animatedVelocity, 0, 0, 0), o.remainingLifetime < 0) return n && a.removeParticle(o), e._particles.removeAt(r), --r, l = r, "continue";

            if (i.simulationSpace === mr.Local) {
              var s = 9.8 * -i.gravityModifier.evaluate(1 - o.remainingLifetime / o.startLifetime, ut(o.randomSeed)) * t;
              e._gravity.x = 0, e._gravity.y = s, e._gravity.z = 0, e._gravity.w = 1, e._gravity = e._gravity.transformMat4(e._localMat), o.velocity.x += e._gravity.x, o.velocity.y += e._gravity.y, o.velocity.z += e._gravity.z;
            } else o.velocity.y -= 9.8 * i.gravityModifier.evaluate(1 - o.remainingLifetime / o.startLifetime, ut(o.randomSeed)) * t;

            j.copy(o.ultimateVelocity, o.velocity), e._runAnimateList.forEach(function (e) {
              e.animate(o, t);
            }), j.scaleAndAdd(o.position, o.position, o.ultimateVelocity, t), n && a.animate(o, t), l = r;
          }, l = 0; l < this._particles.length; ++l) {
            s(l);
          }

          return this._model.enabled = this._particles.length > 0, this._particles.length;
        }, r.updateRenderData = function () {
          for (var t = 0, e = 0; e < this._particles.length; ++e) {
            var i = this._particles.data[e],
                r = 0,
                a = this._particleSystem._textureAnimationModule;
            a && a.enable && (r = i.frameIndex), t = 4 * e, this._fillDataFunc(i, t, r);
          }
        }, r.beforeRender = function () {
          this._model.updateIA(this._particles.length);
        }, r.getParticleCount = function () {
          return this._particles.length;
        }, r.onMaterialModified = function (t) {
          this._inited && (0 === t ? this.updateMaterialParams() : this.updateTrailMaterial());
        }, r.onRebuildPSO = function (t, e) {
          this._model && 0 === t && this._model.setSubModelMaterial(0, e);
          var i = this._particleSystem._trailModule;
          i && i._trailModel && 1 === t && i._trailModel.setSubModelMaterial(0, e);
        }, r._setFillFunc = function () {
          this._renderInfo.renderMode === br.Mesh ? this._fillDataFunc = this._fillMeshData : this._renderInfo.renderMode === br.StrecthedBillboard ? this._fillDataFunc = this._fillStrecthedData : this._fillDataFunc = this._fillNormalData;
        }, r._fillMeshData = function (t, e, i) {
          var r = e / 4;
          this._attrs[0] = t.position, fu.z = i, this._attrs[1] = fu, this._attrs[2] = t.size, this._attrs[3] = t.rotation, this._attrs[4] = t.color._val, this._model.addParticleVertexData(r, this._attrs);
        }, r._fillStrecthedData = function (t, e, i) {
          for (var r = 0; r < 4; ++r) {
            this._attrs[0] = t.position, fu.x = bu[2 * r], fu.y = bu[2 * r + 1], fu.z = i, this._attrs[1] = fu, this._attrs[2] = t.size, this._attrs[3] = t.rotation, this._attrs[4] = t.color._val, this._attrs[5] = t.ultimateVelocity, this._attrs[6] = null, this._model.addParticleVertexData(e++, this._attrs);
          }
        }, r._fillNormalData = function (t, e, i) {
          for (var r = 0; r < 4; ++r) {
            this._attrs[0] = t.position, fu.x = bu[2 * r], fu.y = bu[2 * r + 1], fu.z = i, this._attrs[1] = fu, this._attrs[2] = t.size, this._attrs[3] = t.rotation, this._attrs[4] = t.color._val, this._attrs[5] = null, this._model.addParticleVertexData(e++, this._attrs);
          }
        }, r._setVertexAttrib = function () {
          switch (this._renderInfo.renderMode) {
            case br.StrecthedBillboard:
              this._vertAttrs = Mu.slice();
              break;

            case br.Mesh:
              this._vertAttrs = Su.slice();
              break;

            default:
              this._vertAttrs = gu.slice();
          }
        }, r.updateMaterialParams = function () {
          if (this._particleSystem) {
            var t = this._particleSystem,
                e = t.sharedMaterial;

            if (null != e) {
              var i = e._effectAsset._name;
              this._renderInfo.mainTexture = e.getProperty("mainTexture", 0), -1 !== i.indexOf("particle") && -1 === i.indexOf("particle-gpu") || t.setMaterial(null, 0);
            }

            null == t.sharedMaterial && null == this._defaultMat && (wu.parent = B.get("default-particle-material"), wu.owner = this._particleSystem, wu.subModelIdx = 0, this._defaultMat = new at(wu), wu.parent = null, wu.owner = null, wu.subModelIdx = 0, null !== this._renderInfo.mainTexture && this._defaultMat.setProperty("mainTexture", this._renderInfo.mainTexture));

            var r = t.getMaterialInstance(0) || this._defaultMat;

            t._simulationSpace === mr.World ? this._defines.CC_USE_WORLD_SPACE = !0 : this._defines.CC_USE_WORLD_SPACE = !1;
            var a = r.passes[0];
            this._uScaleHandle = a.getHandle("scale"), this._uLenHandle = a.getHandle("frameTile_velLenScale"), this._uNodeRotHandle = a.getHandle("nodeRotation");
            var n = this._renderInfo.renderMode,
                o = this._frameTile_velLenScale;
            n === br.Billboard ? this._defines.CC_RENDER_MODE = 0 : n === br.StrecthedBillboard ? (this._defines.CC_RENDER_MODE = 1, o.z = this._renderInfo.velocityScale, o.w = this._renderInfo.lengthScale) : n === br.HorizontalBillboard ? this._defines.CC_RENDER_MODE = 2 : n === br.VerticalBillboard ? this._defines.CC_RENDER_MODE = 3 : n === br.Mesh ? this._defines.CC_RENDER_MODE = 4 : console.warn("particle system renderMode " + n + " not support.");
            var s = t._textureAnimationModule;
            s && s.enable ? (H.copy(this._tmp_velLenScale, o), rt.set(this._tmp_velLenScale, s.numTilesX, s.numTilesY), a.setUniform(this._uLenHandle, this._tmp_velLenScale)) : a.setUniform(this._uLenHandle, o);
            var l,
                u = this._particleSystem._rotationOvertimeModule;
            l = u && u.enable, this._defines.ROTATION_OVER_TIME_MODULE_ENABLE = l, r.recompileShaders(this._defines), this._model && this._model.updateMaterial(r);
          }
        }, r.updateTrailMaterial = function () {
          if (this._particleSystem) {
            var t = this._particleSystem,
                e = t._trailModule;

            if (e && e.enable) {
              t.simulationSpace === mr.World || e.space === mr.World ? this._trailDefines.CC_USE_WORLD_SPACE = !0 : this._trailDefines.CC_USE_WORLD_SPACE = !1;
              var i = t.getMaterialInstance(1);
              null === i && null === this._defaultTrailMat && (wu.parent = B.get("default-trail-material"), wu.owner = this._particleSystem, wu.subModelIdx = 1, this._defaultTrailMat = new at(wu), wu.parent = null, wu.owner = null, wu.subModelIdx = 0), (i = i || this._defaultTrailMat).recompileShaders(this._trailDefines), e.updateMaterial();
            }
          }
        }, i;
      }(pu),
          xu = new lt(),
          Ou = new H(),
          zu = new st(),
          Ru = new st(),
          Eu = (new j(), 32),
          Au = "a_position_starttime",
          Cu = "a_size_uv",
          Pu = "a_rotation_uv",
          Du = "a_color",
          Fu = "a_dir_life",
          Iu = "a_rndSeed",
          Bu = [new r(Au, n.RGBA32F), new r(Cu, n.RGBA32F), new r(Pu, n.RGBA32F), new r(Du, n.RGBA32F), new r(Fu, n.RGBA32F), new r(Iu, n.R32F)],
          Lu = [new r(Au, n.RGBA32F), new r(Cu, n.RGBA32F), new r(Pu, n.RGBA32F), new r(Du, n.RGBA32F), new r(Fu, n.RGBA32F), new r(Iu, n.R32F), new r(a.ATTR_TEX_COORD, n.RGB32F), new r(a.ATTR_TEX_COORD3, n.RGB32F), new r(a.ATTR_NORMAL, n.RGB32F), new r(a.ATTR_COLOR1, n.RGBA8, !0)],
          Uu = {
        parent: null,
        owner: null,
        subModelIdx: 0
      },
          Vu = function (t) {
        function i(e) {
          var i;
          return (i = t.call(this, e) || this)._defines = void 0, i._frameTile_velLenScale = void 0, i._unifrom_velLenScale = void 0, i._tmp_velLenScale = void 0, i._node_scale = void 0, i._vertAttrs = [], i._defaultMat = null, i._particleNum = 0, i._tempParticle = null, i._colorTexture = null, i._forceTexture = null, i._velocityTexture = null, i._rotationTexture = null, i._sizeTexture = null, i._animTexture = null, i._uTimeHandle = 0, i._uRotHandle = 0, i._uNodeRotHandle = 0, i._alignSpace = vr.View, i._inited = !1, i._frameTile_velLenScale = new H(1, 1, 0, 0), i._unifrom_velLenScale = i._frameTile_velLenScale.clone(), i._tmp_velLenScale = i._frameTile_velLenScale.clone(), i._node_scale = new H(), i._defines = {
            CC_USE_WORLD_SPACE: !0,
            CC_USE_BILLBOARD: !0,
            CC_USE_STRETCHED_BILLBOARD: !1,
            CC_USE_HORIZONTAL_BILLBOARD: !1,
            CC_USE_VERTICAL_BILLBOARD: !1,
            COLOR_OVER_TIME_MODULE_ENABLE: !1
          }, i._tempParticle = new Ri(null), i._particleNum = 0, i;
        }

        e(i, t);
        var r = i.prototype;
        return r.onInit = function (e) {
          t.prototype.onInit.call(this, e), this._setVertexAttrib(), this._initModel(), this.updateMaterialParams(), this.setVertexAttributes(), this._inited = !0;
        }, r.updateRenderMode = function () {
          this._setVertexAttrib(), this.updateMaterialParams(), this.setVertexAttributes();
        }, r.setVertexAttributes = function () {
          t.prototype.setVertexAttributes.call(this), this._model.constructAttributeIndex();
        }, r.clear = function () {
          t.prototype.clear.call(this), this._particleNum = 0, this.updateRenderData();
        }, r.onDestroy = function () {
          t.prototype.onDestroy.call(this), this._forceTexture && this._forceTexture.destroy(), this._velocityTexture && this._velocityTexture.destroy(), this._colorTexture && this._colorTexture.destroy(), this._sizeTexture && this._sizeTexture.destroy(), this._rotationTexture && this._rotationTexture.destroy(), this._animTexture && this._animTexture.destroy();
        }, r.enableModule = function () {
          var t = this._particleSystem.getMaterialInstance(0) || this._defaultMat;

          t && (this.initShaderUniform(t), t.recompileShaders(this._defines), this._model && this._model.setSubModelMaterial(0, t));
        }, r.getFreeParticle = function () {
          return this._particleNum >= this._particleSystem._capacity ? null : this._tempParticle;
        }, r.setNewParticle = function (t) {
          this._model.addGPUParticleVertexData(t, this._particleNum, this._particleSystem._time), this._particleNum++;
        }, r.getDefaultMaterial = function () {
          return this._defaultMat;
        }, r.updateRotation = function (t) {
          t && this.doUpdateRotation(t);
        }, r.doUpdateRotation = function (t) {
          if (this._renderInfo.renderMode === br.Mesh || this._alignSpace !== vr.View) {
            if (this._alignSpace === vr.Local) this._particleSystem.node.getRotation(Ru);else if (this._alignSpace === vr.World) this._particleSystem.node.getWorldRotation(Ru);else if (this._alignSpace === vr.View) {
              var e;
              Ru.set(0, 0, 0, 1);
              var i = null === (e = this._particleSystem.node.scene.renderScene) || void 0 === e ? void 0 : e.cameras;
              if (void 0 !== i) for (var r = 0; r < (null == i ? void 0 : i.length); ++r) {
                var a = i[r];

                if ((a.visibility & this._particleSystem.node.layer) === this._particleSystem.node.layer) {
                  st.fromViewUp(Ru, a.forward);
                  break;
                }
              }
            } else Ru.set(0, 0, 0, 1);
            t.setUniform(this._uNodeRotHandle, Ru);
          }
        }, r.updateScale = function (t) {
          t && this.doUpdateScale(t);
        }, r.doUpdateScale = function (t) {
          switch (this._particleSystem.scaleSpace) {
            case mr.Local:
              this._particleSystem.node.getScale(this._node_scale);

              break;

            case mr.World:
              this._particleSystem.node.getWorldScale(this._node_scale);

          }

          t.setUniform(t.getHandle("scale"), this._node_scale);
        }, r.updateParticles = function (t) {
          return this._particleNum = this._model.updateGPUParticles(this._particleNum, this._particleSystem._time, t), this.updateShaderUniform(t), this._model.enabled = this._particleNum > 0, this._particleNum;
        }, r.updateRenderData = function () {}, r.beforeRender = function () {
          this._model.updateIA(this._particleNum);
        }, r.updateAlignSpace = function (t) {
          this._alignSpace = t;
        }, r.updateShaderUniform = function (t) {
          var e = this._particleSystem.getMaterialInstance(0) || this._defaultMat;

          if (e) {
            var i = e.passes[0];
            Ou.x = this._particleSystem._time, Ou.y = t, i.setUniform(this._uTimeHandle, Ou), this._particleSystem.node.getWorldRotation(zu), i.setUniform(this._uRotHandle, zu), this.doUpdateRotation(i);
          }
        }, r.initShaderUniform = function (t) {
          var e = t.passes[0];
          this._uTimeHandle = e.getHandle("u_timeDelta"), this._uRotHandle = e.getHandle("u_worldRot"), this._uNodeRotHandle = e.getHandle("nodeRotation"), this.doUpdateScale(e), e.setUniform(e.getHandle("frameTile_velLenScale"), this._unifrom_velLenScale), Ou.x = Eu, Ou.y = .03125, e.setUniform(e.getHandle("u_sampleInfo"), Ou);
          var i = !1,
              r = this._particleSystem._forceOvertimeModule;

          if (i = r && r.enable, this._defines.FORCE_OVER_TIME_MODULE_ENABLE = i, i) {
            this._forceTexture && this._forceTexture.destroy(), this._forceTexture = fe(Eu, r.x, r.y, r.z);
            var a = e.getHandle("force_over_time_tex0"),
                n = vt.getBindingFromHandle(a);
            e.bindSampler(n, this._forceTexture.getGFXSampler()), e.bindTexture(n, this._forceTexture.getGFXTexture());
            var s = e.getHandle("u_force_space");
            e.setUniform(s, r.space);
            var l = e.getHandle("u_force_mode");
            e.setUniform(l, this._forceTexture.height);
          }

          var u = this._particleSystem._velocityOvertimeModule;

          if (i = u && u.enable, this._defines.VELOCITY_OVER_TIME_MODULE_ENABLE = i, i) {
            this._velocityTexture && this._velocityTexture.destroy(), this._velocityTexture = function (t, e, i, r, a) {
              for (var n = Math.max(de(e), de(i), de(r), de(a)), o = new Float32Array(t * n * 4), s = [e, i, r, a], l = 1 / (t - 1), u = 0; u < n; u++) {
                for (var h = 0; h < 4; h++) {
                  for (var c = s[h], _ = 0, d = 0, p = 0; p < t; p++) {
                    var f = _e(c, l * p, u);

                    d = (_ += f) / (p + 1), o[4 * p + h] = d;
                  }
                }
              }

              return pe(o, t, n);
            }(Eu, u.x, u.y, u.z, u.speedModifier);
            var h = e.getHandle("velocity_over_time_tex0"),
                c = vt.getBindingFromHandle(h);
            e.bindSampler(c, this._velocityTexture.getGFXSampler()), e.bindTexture(c, this._velocityTexture.getGFXTexture());

            var _ = e.getHandle("u_velocity_space");

            e.setUniform(_, u.space);
            var d = e.getHandle("u_velocity_mode");
            e.setUniform(d, this._velocityTexture.height);
          }

          var p = this._particleSystem._colorOverLifetimeModule;

          if (i = p && p.enable, this._defines.COLOR_OVER_TIME_MODULE_ENABLE = i, i) {
            this._colorTexture && this._colorTexture.destroy(), this._colorTexture = function (t, e) {
              for (var i = function (t) {
                switch (t.mode) {
                  case Si.TwoColors:
                  case Si.TwoGradients:
                    return 2;

                  default:
                    return 1;
                }
              }(e), r = new Uint8Array(t * i * 4), a = 1 / (t - 1), n = 0, o = 0; o < i; o++) {
                for (var s = 0; s < t; s++) {
                  var l = Ti(e, a * s, o);
                  r[n] = l.r, r[n + 1] = l.g, r[n + 2] = l.b, r[n + 3] = l.a, n += 4;
                }
              }

              var u = new P();
              return u.create(t, i, $.RGBA8888), u.setFilters(J.LINEAR, J.LINEAR), u.setWrapMode(tt.CLAMP_TO_EDGE, tt.CLAMP_TO_EDGE), u.uploadData(r), u;
            }(Eu, p.color);
            var f = e.getHandle("color_over_time_tex0"),
                m = vt.getBindingFromHandle(f);
            e.bindSampler(m, this._colorTexture.getGFXSampler()), e.bindTexture(m, this._colorTexture.getGFXTexture());
            var y = e.getHandle("u_color_mode");
            e.setUniform(y, this._colorTexture.height);
          }

          var v = this._particleSystem._rotationOvertimeModule;

          if (i = v && v.enable, this._defines.ROTATION_OVER_TIME_MODULE_ENABLE = i, i) {
            this._rotationTexture && this._rotationTexture.destroy(), v.separateAxes ? this._rotationTexture = fe(Eu, v.x, v.y, v.z) : this._rotationTexture = function (t, e) {
              for (var i = de(e), r = new Float32Array(t * i * 4), a = 1 / (t - 1), n = 0, o = 0; o < i; o++) {
                for (var s = 0; s < t; s++) {
                  var l = _e(e, a * s, o);

                  r[n + 2] = l, n += 4;
                }
              }

              return pe(r, t, i);
            }(Eu, v.z);
            var b = e.getHandle("rotation_over_time_tex0"),
                g = vt.getBindingFromHandle(b);
            e.bindSampler(g, this._rotationTexture.getGFXSampler()), e.bindTexture(g, this._rotationTexture.getGFXTexture());
            var M = e.getHandle("u_rotation_mode");
            e.setUniform(M, this._rotationTexture.height);
          }

          var S = this._particleSystem._sizeOvertimeModule;

          if (i = S && S.enable, this._defines.SIZE_OVER_TIME_MODULE_ENABLE = i, i) {
            this._sizeTexture && this._sizeTexture.destroy(), S.separateAxes ? this._sizeTexture = fe(Eu, S.x, S.y, S.z, !0) : this._sizeTexture = function (t, e) {
              for (var i = de(e), r = new Float32Array(t * i * 4), a = 1 / (t - 1), n = 0, o = 0, s = 0; s < i; s++) {
                0;

                for (var l = 0; l < t; l++) {
                  var u = _e(e, a * l, s);

                  n = u, r[o] = n, r[o + 1] = n, r[o + 2] = n, o += 4;
                }
              }

              return pe(r, t, i);
            }(Eu, S.size);
            var w = e.getHandle("size_over_time_tex0"),
                x = vt.getBindingFromHandle(w);
            e.bindSampler(x, this._sizeTexture.getGFXSampler()), e.bindTexture(x, this._sizeTexture.getGFXTexture());
            var O = e.getHandle("u_size_mode");
            e.setUniform(O, this._sizeTexture.height);
          }

          var z = this._particleSystem._textureAnimationModule;

          if (i = z && z.enable, this._defines.TEXTURE_ANIMATION_MODULE_ENABLE = i, i) {
            this._animTexture && this._animTexture.destroy(), this._animTexture = function (t, e, i) {
              for (var r = Math.max(de(e), de(i)), a = new Float32Array(t * r * 4), n = [e, i], o = 1 / (t - 1), s = 0; s < r; s++) {
                for (var l = 0; l < 2; l++) {
                  for (var u = n[l], h = 0, c = 0, _ = 0; _ < t; _++) {
                    var d = _e(u, o * _, s);

                    c = (h += d) / (_ + 1), a[4 * _ + l] = c;
                  }
                }
              }

              return pe(a, t, r);
            }(Eu, z.startFrame, z.frameOverTime);
            var R = e.getHandle("texture_animation_tex0"),
                E = vt.getBindingFromHandle(R);
            e.bindSampler(E, this._animTexture.getGFXSampler()), e.bindTexture(E, this._animTexture.getGFXTexture());
            var A = e.getHandle("u_anim_info");
            Ou.x = this._animTexture.height, Ou.y = z.numTilesX * z.numTilesY, Ou.z = z.cycleCount, e.setUniform(A, Ou);
          }

          this._defines.USE_VK_SHADER = o.game._gfxDevice.gfxAPI === T.VULKAN;
        }, r.getParticleCount = function () {
          return this._particleNum;
        }, r.onMaterialModified = function () {
          this._inited && this.updateMaterialParams();
        }, r.onRebuildPSO = function (t, e) {
          this._model && 0 === t && this._model.setSubModelMaterial(0, e);
        }, r._setVertexAttrib = function () {
          switch (this._renderInfo.renderMode) {
            case br.StrecthedBillboard:
              this._vertAttrs = Bu.slice();
              break;

            case br.Mesh:
              this._vertAttrs = Lu.slice();
              break;

            default:
              this._vertAttrs = Bu.slice();
          }
        }, r.updateMaterialParams = function () {
          if (this._particleSystem) {
            var t = this._particleSystem,
                e = t.sharedMaterial;

            if (null !== e) {
              var i = e._effectAsset._name;
              this._renderInfo.mainTexture = e.getProperty("mainTexture", 0), -1 === i.indexOf("particle-gpu") && (this._renderInfo.mainTexture = e.getProperty("mainTexture", 0), this._particleSystem.setMaterial(null, 0));
            }

            null == t.sharedMaterial && null == this._defaultMat && (Uu.parent = B.get("default-particle-gpu-material"), Uu.owner = t, Uu.subModelIdx = 0, this._defaultMat = new at(Uu), Uu.parent = null, Uu.owner = null, Uu.subModelIdx = 0, null !== this._renderInfo.mainTexture && this._defaultMat.setProperty("mainTexture", this._renderInfo.mainTexture));

            var r = t.getMaterialInstance(0) || this._defaultMat;

            t.node.getWorldMatrix(xu), t._simulationSpace === mr.World ? this._defines.CC_USE_WORLD_SPACE = !0 : this._defines.CC_USE_WORLD_SPACE = !1;
            var a = this._renderInfo.renderMode;
            a === br.Billboard ? this._defines.CC_RENDER_MODE = 0 : a === br.StrecthedBillboard ? (this._defines.CC_RENDER_MODE = 1, this._frameTile_velLenScale.z = this._renderInfo.velocityScale, this._frameTile_velLenScale.w = this._renderInfo.lengthScale) : a === br.HorizontalBillboard ? this._defines.CC_RENDER_MODE = 2 : a === br.VerticalBillboard ? this._defines.CC_RENDER_MODE = 3 : a === br.Mesh ? this._defines.CC_RENDER_MODE = 4 : console.warn("particle system renderMode " + a + " not support.");
            var n = t._textureAnimationModule;
            n && n.enable ? (rt.set(this._frameTile_velLenScale, n.numTilesX, n.numTilesY), H.copy(this._unifrom_velLenScale, this._frameTile_velLenScale)) : (this._tmp_velLenScale.z = this._frameTile_velLenScale.z, this._tmp_velLenScale.w = this._frameTile_velLenScale.w, H.copy(this._unifrom_velLenScale, this._tmp_velLenScale)), this.initShaderUniform(r), r.recompileShaders(this._defines), this._model && this._model.updateMaterial(r);
          }
        }, i;
      }(pu);

      function Hu() {
        var t = Dt.root.device;
        return !!(t.capabilities.maxVertexTextureUnits >= 8 && t.getFormatFeatures(n.RGBA32F) & (O.RENDER_TARGET | O.SAMPLED_TEXTURE)) || (o.warn("Maybe the device has restrictions on vertex textures or does not support float textures."), !1);
      }

      var ku,
          Nu,
          Gu,
          Wu,
          ju,
          Xu,
          Ku,
          Yu,
          Zu,
          qu,
          Qu,
          $u,
          Ju,
          th,
          eh,
          ih,
          rh,
          ah,
          nh,
          oh,
          sh,
          lh,
          uh,
          hh,
          ch,
          _h,
          dh,
          ph,
          fh,
          mh,
          yh,
          vh,
          bh,
          gh,
          Mh,
          Sh,
          wh,
          Th,
          xh,
          Oh,
          zh,
          Rh,
          Eh,
          Ah,
          Ch,
          Ph,
          Dh,
          Fh,
          Ih,
          Bh,
          Lh,
          Uh,
          Vh,
          Hh,
          kh,
          Nh,
          Gh,
          Wh,
          jh,
          Xh,
          Kh,
          Yh,
          Zh,
          qh,
          Qh,
          $h,
          Jh,
          tc,
          ec,
          ic,
          rc,
          ac,
          nc,
          oc,
          sc,
          lc,
          uc,
          hc,
          cc,
          _c,
          dc,
          pc,
          fc,
          mc,
          yc,
          vc,
          bc,
          gc,
          Mc,
          Sc,
          wc,
          Tc,
          xc,
          Oc,
          zc,
          Rc,
          Ec,
          Ac,
          Cc,
          Pc,
          Dc,
          Fc,
          Ic,
          Bc,
          Lc,
          Uc,
          Vc,
          Hc,
          kc,
          Nc,
          Gc,
          Wc,
          jc,
          Xc,
          Kc,
          Yc,
          Zc,
          qc,
          Qc,
          $c,
          Jc,
          t_,
          e_,
          i_,
          r_,
          a_,
          n_,
          o_,
          s_,
          l_,
          u_,
          h_,
          c_,
          __,
          d_,
          p_,
          f_,
          m_,
          y_,
          v_,
          b_,
          g_,
          M_,
          S_,
          w_,
          T_,
          x_,
          O_,
          z_,
          R_,
          E_,
          A_,
          C_,
          P_,
          D_,
          F_,
          I_,
          B_,
          L_,
          U_,
          V_,
          H_,
          k_,
          N_,
          G_,
          W_,
          j_,
          X_,
          K_,
          Y_,
          Z_,
          q_,
          Q_,
          $_,
          J_,
          td,
          ed,
          id,
          rd,
          ad,
          nd,
          od,
          sd,
          ld,
          ud,
          hd,
          cd,
          _d,
          dd,
          pd,
          fd,
          md,
          yd,
          vd,
          bd,
          gd,
          Md,
          Sd,
          wd,
          Td,
          xd,
          Od,
          zd,
          Rd,
          Ed,
          Ad,
          Cd,
          Pd,
          Dd,
          Fd,
          Id,
          Bd,
          Ld,
          Ud,
          Vd,
          Hd,
          kd,
          Nd,
          Gd,
          Wd,
          jd,
          Xd,
          Kd,
          Yd,
          Zd,
          qd,
          Qd,
          $d,
          Jd,
          tp,
          ep,
          ip,
          rp,
          ap,
          np,
          op = (Pl = A("cc.ParticleSystemRenderer"), Dl = C(br), Fl = nt(), Il = V(), Bl = nt(), Ll = V(), Ul = nt(), Vl = V(), Hl = C(br), kl = C(Bt), Nl = nt(), Gl = V(), Wl = C(I), jl = nt(), Xl = V(), Kl = C(I), Yl = nt(), Zl = V(), ql = nt(), Ql = V(), $l = C(vr), Jl = nt(), tu = V(), Pl((cu = hu = function () {
        function t() {
          u(this, "_renderMode", ru, this), u(this, "_velocityScale", au, this), u(this, "_lengthScale", nu, this), u(this, "_mesh", ou, this), u(this, "_mainTexture", su, this), u(this, "_useGPU", lu, this), u(this, "_alignSpace", uu, this), this._particleSystem = null;
        }

        var e = t.prototype;
        return e.create = function (t) {
          null === this._particleSystem ? this._particleSystem = t : this._particleSystem !== t && x(6033);
        }, e.onInit = function (t) {
          if (this.create(t), this._particleSystem.processor) x(6034);else {
            var e = this._useGPU && Hu();
            this._particleSystem.processor = e ? new Vu(this) : new Tu(this), this._particleSystem.processor.updateAlignSpace(this.alignSpace), this._particleSystem.processor.onInit(t);
          }
        }, e._switchProcessor = function () {
          this._particleSystem && (this._particleSystem.processor && (this._particleSystem.processor.detachFromScene(), this._particleSystem.processor.clear(), this._particleSystem.processor = null), this._particleSystem.processor = this._useGPU ? new Vu(this) : new Tu(this), this._particleSystem.processor.updateAlignSpace(this.alignSpace), this._particleSystem.processor.onInit(this._particleSystem), this._particleSystem.processor.onEnable(), this._particleSystem.bindModule());
        }, s(t, [{
          key: "renderMode",
          get: function get() {
            return this._renderMode;
          },
          set: function set(t) {
            this._renderMode !== t && (this._renderMode = t, this._particleSystem && this._particleSystem.processor.updateRenderMode());
          }
        }, {
          key: "velocityScale",
          get: function get() {
            return this._velocityScale;
          },
          set: function set(t) {
            this._velocityScale = t, this._particleSystem && this._particleSystem.processor.updateMaterialParams();
          }
        }, {
          key: "lengthScale",
          get: function get() {
            return this._lengthScale;
          },
          set: function set(t) {
            this._lengthScale = t, this._particleSystem && this._particleSystem.processor.updateMaterialParams();
          }
        }, {
          key: "mesh",
          get: function get() {
            return this._mesh;
          },
          set: function set(t) {
            this._mesh = t, this._particleSystem && this._particleSystem.processor.setVertexAttributes();
          }
        }, {
          key: "particleMaterial",
          get: function get() {
            return this._particleSystem ? this._particleSystem.getMaterial(0) : null;
          },
          set: function set(t) {
            this._particleSystem && this._particleSystem.setMaterial(t, 0);
          }
        }, {
          key: "trailMaterial",
          get: function get() {
            return this._particleSystem ? this._particleSystem.getMaterial(1) : null;
          },
          set: function set(t) {
            this._particleSystem && this._particleSystem.setMaterial(t, 1);
          }
        }, {
          key: "mainTexture",
          get: function get() {
            return this._mainTexture;
          },
          set: function set(t) {
            this._mainTexture = t;
          }
        }, {
          key: "useGPU",
          get: function get() {
            return this._useGPU;
          },
          set: function set(t) {
            this._useGPU !== t && (Hu() ? this._useGPU = t : this._useGPU = !1, this._switchProcessor());
          }
        }, {
          key: "alignSpace",
          get: function get() {
            return this._alignSpace;
          },
          set: function set(t) {
            this._alignSpace = t, this._particleSystem.processor.updateAlignSpace(this._alignSpace);
          }
        }]), t;
      }(), hu.AlignmentSpace = vr, l((iu = cu).prototype, "renderMode", [Dl, Fl, Il], Object.getOwnPropertyDescriptor(iu.prototype, "renderMode"), iu.prototype), l(iu.prototype, "velocityScale", [Bl, Ll], Object.getOwnPropertyDescriptor(iu.prototype, "velocityScale"), iu.prototype), l(iu.prototype, "lengthScale", [Ul, Vl], Object.getOwnPropertyDescriptor(iu.prototype, "lengthScale"), iu.prototype), ru = l(iu.prototype, "_renderMode", [Hl, W], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return br.Billboard;
        }
      }), au = l(iu.prototype, "_velocityScale", [W], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 1;
        }
      }), nu = l(iu.prototype, "_lengthScale", [W], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 1;
        }
      }), ou = l(iu.prototype, "_mesh", [W], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return null;
        }
      }), l(iu.prototype, "mesh", [kl, Nl, Gl], Object.getOwnPropertyDescriptor(iu.prototype, "mesh"), iu.prototype), l(iu.prototype, "particleMaterial", [Wl, jl, bt, Xl], Object.getOwnPropertyDescriptor(iu.prototype, "particleMaterial"), iu.prototype), l(iu.prototype, "trailMaterial", [Kl, Yl, bt, Zl], Object.getOwnPropertyDescriptor(iu.prototype, "trailMaterial"), iu.prototype), su = l(iu.prototype, "_mainTexture", [W], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return null;
        }
      }), lu = l(iu.prototype, "_useGPU", [W], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !1;
        }
      }), l(iu.prototype, "useGPU", [ql, Ql], Object.getOwnPropertyDescriptor(iu.prototype, "useGPU"), iu.prototype), l(iu.prototype, "alignSpace", [$l, Jl, tu], Object.getOwnPropertyDescriptor(iu.prototype, "alignSpace"), iu.prototype), uu = l(iu.prototype, "_alignSpace", [W], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return vr.View;
        }
      }), eu = iu)) || eu),
          sp = Math.cos(N(100)),
          lp = {
        position: new j(),
        velocity: new j()
      },
          up = new st(),
          hp = new lt(),
          cp = new j(),
          _p = new j(),
          dp = new F(),
          pp = function () {
        function t(t) {
          for (this.start = void 0, this.end = void 0, this.trailElements = void 0, this.start = -1, this.end = -1, this.trailElements = []; t--;) {
            this.trailElements.push({
              position: new j(),
              lifetime: 0,
              width: 0,
              velocity: new j(),
              direction: 0,
              color: new F()
            });
          }
        }

        var e = t.prototype;
        return e.getElement = function (t) {
          return -1 === this.start ? null : (t < 0 && (t = (t + this.trailElements.length) % this.trailElements.length), t >= this.trailElements.length && (t %= this.trailElements.length), this.trailElements[t]);
        }, e.addElement = function () {
          if (0 === this.trailElements.length) return null;
          if (-1 === this.start) return this.start = 0, this.end = 1, this.trailElements[0];
          this.start === this.end && (this.trailElements.splice(this.end, 0, {
            position: new j(),
            lifetime: 0,
            width: 0,
            velocity: new j(),
            direction: 0,
            color: new F()
          }), this.start++, this.start %= this.trailElements.length);
          var t = this.end++;
          return this.end %= this.trailElements.length, this.trailElements[t];
        }, e.iterateElement = function (t, e, i, r) {
          for (var a = this.start >= this.end ? this.end + this.trailElements.length : this.end, n = this.start; n < a; n++) {
            e(t, this.trailElements[n % this.trailElements.length], i, r) && (this.start++, this.start %= this.trailElements.length);
          }

          this.start === a && (this.start = -1, this.end = -1);
        }, e.count = function () {
          return this.start < this.end ? this.end - this.start : this.trailElements.length + this.end - this.start;
        }, e.clear = function () {
          this.start = -1, this.end = -1;
        }, t;
      }(),
          fp = (ku = A("cc.TrailModule"), Nu = nt(), Gu = C(wr), Wu = nt(), ju = V(), Xu = C(ce), Ku = ot(), Yu = nt(), Zu = V(), qu = nt(), Qu = V(), $u = C(mr), Ju = nt(), th = V(), eh = C(Tr), ih = nt(), rh = V(), ah = nt(), nh = V(), oh = C(ce), sh = ot(), lh = nt(), uh = V(), hh = nt(), ch = V(), _h = C(wi), dh = nt(), ph = V(), fh = C(wi), mh = nt(), yh = V(), vh = C(mr), ku((Fh = function () {
        var t = e.prototype;

        function e() {
          u(this, "_enable", Mh, this), u(this, "mode", Sh, this), u(this, "lifeTime", wh, this), u(this, "_minParticleDistance", Th, this), u(this, "existWithParticles", xh, this), u(this, "textureMode", Oh, this), u(this, "widthFromParticle", zh, this), u(this, "widthRatio", Rh, this), u(this, "colorFromParticle", Eh, this), u(this, "colorOverTrail", Ah, this), u(this, "colorOvertime", Ch, this), u(this, "_space", Ph, this), u(this, "_particleSystem", Dh, this), this._minSquaredDistance = 0, this._vertSize = void 0, this._trailNum = 0, this._trailLifetime = 0, this.vbOffset = 0, this.ibOffset = 0, this._trailSegments = null, this._particleTrail = void 0, this._trailModel = null, this._iaInfo = void 0, this._iaInfoBuffer = null, this._subMeshData = null, this._vertAttrs = void 0, this._vbF32 = null, this._vbUint32 = null, this._iBuffer = null, this._needTransform = !1, this._material = null, this._iaInfo = new m([new y()]), this._vertAttrs = [new r(a.ATTR_POSITION, n.RGB32F), new r(a.ATTR_TEX_COORD, n.RGBA32F), new r(a.ATTR_TEX_COORD1, n.RGB32F), new r(a.ATTR_COLOR, n.RGBA8, !0)], this._vertSize = 0;

          for (var t, e = c(this._vertAttrs); !(t = e()).done;) {
            var i = t.value;
            this._vertSize += _[i.format].size;
          }

          this._particleTrail = new Map();
        }

        return t.getModel = function () {
          return this._trailModel;
        }, t.onInit = function (t) {
          this._particleSystem = t, this.minParticleDistance = this._minParticleDistance;

          for (var e = 0, i = t.startLifetime.getMax(), r = t.rateOverTime.getMax(), a = t.duration, n = 0, o = t.bursts.length; n < o; n++) {
            e += t.bursts[n].getMaxCount(t) * Math.ceil(i / a);
          }

          this._trailNum = Math.ceil(i * this.lifeTime.getMax() * 60 * (r * a + e)), this._trailSegments = new z(function () {
            return new pp(10);
          }, Math.ceil(r * a), function (t) {
            return t.trailElements.length = 0;
          }), this._enable && (this.enable = this._enable);
        }, t.onEnable = function () {
          this._attachToScene();
        }, t.onDisable = function () {
          this._particleTrail.clear(), this._detachFromScene();
        }, t._attachToScene = function () {
          this._trailModel && (this._trailModel.scene && this._detachFromScene(), this._particleSystem._getRenderScene().addModel(this._trailModel));
        }, t._detachFromScene = function () {
          this._trailModel && this._trailModel.scene && this._trailModel.scene.removeModel(this._trailModel);
        }, t.destroy = function () {
          this.destroySubMeshData(), this._trailModel && (Dt.root.destroyModel(this._trailModel), this._trailModel = null), this._trailSegments && (this._trailSegments.destroy(), this._trailSegments = null);
        }, t.play = function () {
          this._trailModel && this._enable && (this._trailModel.enabled = !0);
        }, t.clear = function () {
          if (this.enable) {
            for (var t = this._particleTrail.values(), e = t.next(); !e.done;) {
              e.value.clear(), e = t.next();
            }

            this._particleTrail.clear(), this.updateRenderData(), this._trailModel && (this._trailModel.enabled = !1);
          }
        }, t.updateMaterial = function () {
          this._particleSystem && (this._material = this._particleSystem.getMaterialInstance(1) || this._particleSystem.processor._defaultTrailMat, this._trailModel && this._trailModel.setSubModelMaterial(0, this._material));
        }, t.update = function () {
          this._trailLifetime = this.lifeTime.evaluate(this._particleSystem._time, 1), this.space === mr.World && this._particleSystem._simulationSpace === mr.Local ? (this._needTransform = !0, this._particleSystem.node.getWorldMatrix(hp), this._particleSystem.node.getWorldRotation(up)) : this._needTransform = !1;
        }, t.animate = function (t, e) {
          if (this._trailSegments) if (t.loopCount > t.lastLoop) t.trailDelay > 1 ? (t.lastLoop = t.loopCount, t.trailDelay = 0) : t.trailDelay++;else {
            var i = this._particleTrail.get(t);

            if (!i) return i = this._trailSegments.alloc(), void this._particleTrail.set(t, i);
            var r = i.getElement(i.end - 1);

            if (this._needTransform ? j.transformMat4(cp, t.position, hp) : j.copy(cp, t.position), !(r && (i.iterateElement(this, this._updateTrailElement, t, e), j.squaredDistance(r.position, cp) < this._minSquaredDistance)) && (r = i.addElement())) {
              j.copy(r.position, cp), r.lifetime = 0, this.widthFromParticle ? r.width = t.size.x * this.widthRatio.evaluate(0, 1) : r.width = this.widthRatio.evaluate(0, 1);
              var a = i.count();

              if (2 === a) {
                var n = i.getElement(i.end - 2);
                j.subtract(n.velocity, r.position, n.position);
              } else if (a > 2) {
                var o = i.getElement(i.end - 2),
                    s = i.getElement(i.end - 3);
                j.subtract(cp, s.position, o.position), j.subtract(_p, r.position, o.position), j.subtract(o.velocity, _p, cp), j.equals(j.ZERO, o.velocity) && j.copy(o.velocity, cp), j.normalize(o.velocity, o.velocity), this._checkDirectionReverse(o, s);
              }

              this.colorFromParticle ? r.color.set(t.color) : r.color.set(this.colorOvertime.evaluate(0, 1));
            }
          }
        }, t.removeParticle = function (t) {
          var e = this._particleTrail.get(t);

          e && this._trailSegments && (e.clear(), this._trailSegments.free(e), this._particleTrail.delete(t));
        }, t.updateRenderData = function () {
          this.vbOffset = 0, this.ibOffset = 0;

          for (var t, e = c(this._particleTrail.keys()); !(t = e()).done;) {
            var i = t.value,
                r = this._particleTrail.get(i);

            if (-1 !== r.start) {
              var a = 4 * this.vbOffset / this._vertSize,
                  n = r.start >= r.end ? r.end + r.trailElements.length : r.end,
                  o = n - r.start,
                  s = 1 / o,
                  l = r.trailElements[r.start];

              this._fillVertexBuffer(l, this.colorOverTrail.evaluate(1, 1), a, 1, 0, 4);

              for (var u = r.start + 1; u < n; u++) {
                var h = r.trailElements[u % r.trailElements.length],
                    _ = u - r.start;

                this._fillVertexBuffer(h, this.colorOverTrail.evaluate(1 - _ / o, 1), a, 1 - _ * s, _, 5);
              }

              this._needTransform ? j.transformMat4(lp.position, i.position, hp) : j.copy(lp.position, i.position);
              var d = this._trailModel;

              if (d && d.node.invalidateChildren(gt.POSITION), 1 === o || 2 === o) {
                var p = r.getElement(r.end - 1);
                j.subtract(p.velocity, lp.position, p.position), this._vbF32[this.vbOffset - this._vertSize / 4 - 4] = p.velocity.x, this._vbF32[this.vbOffset - this._vertSize / 4 - 3] = p.velocity.y, this._vbF32[this.vbOffset - this._vertSize / 4 - 2] = p.velocity.z, this._vbF32[this.vbOffset - 4] = p.velocity.x, this._vbF32[this.vbOffset - 3] = p.velocity.y, this._vbF32[this.vbOffset - 2] = p.velocity.z, j.subtract(lp.velocity, lp.position, p.position), this._checkDirectionReverse(lp, p);
              } else if (o > 2) {
                var f = r.getElement(r.end - 1),
                    m = r.getElement(r.end - 2);
                j.subtract(cp, m.position, f.position), j.subtract(_p, lp.position, f.position), j.normalize(cp, cp), j.normalize(_p, _p), j.subtract(f.velocity, _p, cp), j.normalize(f.velocity, f.velocity), this._checkDirectionReverse(f, m), this.vbOffset -= this._vertSize / 4 * 2, this.ibOffset -= 6, this._fillVertexBuffer(f, this.colorOverTrail.evaluate(s, 1), a, s, o - 1, 5), j.subtract(lp.velocity, lp.position, f.position), j.normalize(lp.velocity, lp.velocity), this._checkDirectionReverse(lp, f);
              }

              this.widthFromParticle ? lp.width = i.size.x * this.widthRatio.evaluate(0, 1) : lp.width = this.widthRatio.evaluate(0, 1), lp.color = i.color, j.equals(lp.velocity, j.ZERO) ? this.ibOffset -= 3 : this._fillVertexBuffer(lp, this.colorOverTrail.evaluate(0, 1), a, 0, o, 1);
            }
          }

          this._trailModel.enabled = this.ibOffset > 0;
        }, t.updateIA = function (t) {
          var e = this._trailModel && this._trailModel.subModels;

          if (e && e.length > 0) {
            var i = e[0];
            i.inputAssembler.vertexBuffers[0].update(this._vbF32), i.inputAssembler.indexBuffer.update(this._iBuffer), this._iaInfo.drawInfos[0].firstIndex = 0, this._iaInfo.drawInfos[0].indexCount = t, this._iaInfoBuffer.update(this._iaInfo);
          }
        }, t.beforeRender = function () {
          this.updateIA(this.ibOffset);
        }, t._createModel = function () {
          this._trailModel || (this._trailModel = o.director.root.createModel(At));
        }, t.rebuild = function () {
          var t = Dt.root.device,
              e = t.createBuffer(new d(p.VERTEX | p.TRANSFER_DST, f.HOST | f.DEVICE, this._vertSize * (this._trailNum + 1) * 2, this._vertSize)),
              r = new ArrayBuffer(this._vertSize * (this._trailNum + 1) * 2);
          this._vbF32 = new Float32Array(r), this._vbUint32 = new Uint32Array(r), e.update(r);
          var a = t.createBuffer(new d(p.INDEX | p.TRANSFER_DST, f.HOST | f.DEVICE, 6 * Math.max(1, this._trailNum) * Uint16Array.BYTES_PER_ELEMENT, Uint16Array.BYTES_PER_ELEMENT));
          this._iBuffer = new Uint16Array(6 * Math.max(1, this._trailNum)), a.update(this._iBuffer), this._iaInfoBuffer = t.createBuffer(new d(p.INDIRECT, f.HOST | f.DEVICE, v, v)), this._iaInfo.drawInfos[0].vertexCount = 2 * (this._trailNum + 1), this._iaInfo.drawInfos[0].indexCount = 6 * this._trailNum, this._iaInfoBuffer.update(this._iaInfo), this._subMeshData = new X([e], this._vertAttrs, i.TRIANGLE_LIST, a, this._iaInfoBuffer);
          var n = this._trailModel;
          n && (n.node = n.transform = this._particleSystem.node, n.visFlags = this._particleSystem.visibility, n.initSubModel(0, this._subMeshData, this._material), n.enabled = !0);
        }, t._updateTrailElement = function (t, e, i, r) {
          return e.lifetime += r, t.colorFromParticle ? (e.color.set(i.color), e.color.multiply(t.colorOvertime.evaluate(1 - i.remainingLifetime / i.startLifetime, 1))) : e.color.set(t.colorOvertime.evaluate(1 - i.remainingLifetime / i.startLifetime, 1)), t.widthFromParticle ? e.width = i.size.x * t.widthRatio.evaluate(e.lifetime / t._trailLifetime, 1) : e.width = t.widthRatio.evaluate(e.lifetime / t._trailLifetime, 1), e.lifetime > t._trailLifetime;
        }, t._fillVertexBuffer = function (t, e, i, r, a, n) {
          this._vbF32[this.vbOffset++] = t.position.x, this._vbF32[this.vbOffset++] = t.position.y, this._vbF32[this.vbOffset++] = t.position.z, this._vbF32[this.vbOffset++] = t.direction, this._vbF32[this.vbOffset++] = t.width, this._vbF32[this.vbOffset++] = r, this._vbF32[this.vbOffset++] = 0, this._vbF32[this.vbOffset++] = t.velocity.x, this._vbF32[this.vbOffset++] = t.velocity.y, this._vbF32[this.vbOffset++] = t.velocity.z, dp.set(t.color), dp.multiply(e), this._vbUint32[this.vbOffset++] = dp._val, this._vbF32[this.vbOffset++] = t.position.x, this._vbF32[this.vbOffset++] = t.position.y, this._vbF32[this.vbOffset++] = t.position.z, this._vbF32[this.vbOffset++] = 1 - t.direction, this._vbF32[this.vbOffset++] = t.width, this._vbF32[this.vbOffset++] = r, this._vbF32[this.vbOffset++] = 1, this._vbF32[this.vbOffset++] = t.velocity.x, this._vbF32[this.vbOffset++] = t.velocity.y, this._vbF32[this.vbOffset++] = t.velocity.z, this._vbUint32[this.vbOffset++] = dp._val, 1 & n && (this._iBuffer[this.ibOffset++] = i + 2 * a, this._iBuffer[this.ibOffset++] = i + 2 * a - 1, this._iBuffer[this.ibOffset++] = i + 2 * a + 1), 4 & n && (this._iBuffer[this.ibOffset++] = i + 2 * a, this._iBuffer[this.ibOffset++] = i + 2 * a + 1, this._iBuffer[this.ibOffset++] = i + 2 * a + 2);
        }, t._checkDirectionReverse = function (t, e) {
          j.dot(t.velocity, e.velocity) < sp ? t.direction = 1 - e.direction : t.direction = e.direction;
        }, t.destroySubMeshData = function () {
          this._subMeshData && (this._subMeshData.destroy(), this._subMeshData = null);
        }, s(e, [{
          key: "enable",
          get: function get() {
            return this._enable;
          },
          set: function set(t) {
            t === this._enable && this._trailModel || (t && !this._enable && (this._enable = t, this._particleSystem.processor && this._particleSystem.processor.updateTrailMaterial()), t && !this._trailModel && (this._createModel(), this.rebuild()), this._enable = t, this._trailModel && (this._trailModel.enabled = t), t ? this.onEnable() : this.onDisable());
          }
        }, {
          key: "minParticleDistance",
          get: function get() {
            return this._minParticleDistance;
          },
          set: function set(t) {
            this._minParticleDistance = t, this._minSquaredDistance = t * t;
          }
        }, {
          key: "space",
          get: function get() {
            return this._space;
          },
          set: function set(t) {
            this._space = t;
            var e = this._particleSystem;
            e && e.processor && e.processor.updateTrailMaterial();
          }
        }]), e;
      }(), l((gh = Fh).prototype, "enable", [Nu], Object.getOwnPropertyDescriptor(gh.prototype, "enable"), gh.prototype), Mh = l(gh.prototype, "_enable", [W], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !1;
        }
      }), Sh = l(gh.prototype, "mode", [Gu, W, Wu, ju], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return wr.Particles;
        }
      }), wh = l(gh.prototype, "lifeTime", [Xu, W, Ku, Yu, Zu], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return new ce();
        }
      }), Th = l(gh.prototype, "_minParticleDistance", [W], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return .1;
        }
      }), l(gh.prototype, "minParticleDistance", [qu, Qu], Object.getOwnPropertyDescriptor(gh.prototype, "minParticleDistance"), gh.prototype), l(gh.prototype, "space", [$u, Ju, th], Object.getOwnPropertyDescriptor(gh.prototype, "space"), gh.prototype), xh = l(gh.prototype, "existWithParticles", [W], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !0;
        }
      }), Oh = l(gh.prototype, "textureMode", [eh, W, ih, rh], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return Tr.Stretch;
        }
      }), zh = l(gh.prototype, "widthFromParticle", [W, ah, nh], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !0;
        }
      }), Rh = l(gh.prototype, "widthRatio", [oh, W, sh, lh, uh], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return new ce();
        }
      }), Eh = l(gh.prototype, "colorFromParticle", [W, hh, ch], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !1;
        }
      }), Ah = l(gh.prototype, "colorOverTrail", [_h, W, dh, ph], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return new wi();
        }
      }), Ch = l(gh.prototype, "colorOvertime", [fh, W, mh, yh], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return new wi();
        }
      }), Ph = l(gh.prototype, "_space", [vh], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return mr.World;
        }
      }), Dh = l(gh.prototype, "_particleSystem", [W], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return null;
        }
      }), bh = gh)) || bh),
          mp = new lt(),
          yp = new st(),
          vp = new j(),
          bp = ["_colorOverLifetimeModule", "_sizeOvertimeModule", "_velocityOvertimeModule", "_forceOvertimeModule", "_limitVelocityOvertimeModule", "_rotationOvertimeModule", "_textureAnimationModule"],
          gp = function () {
        function t(t) {
          this._particleSystem = void 0, this._processor = void 0, this._node = void 0, this._particlesAll = void 0, this._updateList = new Map(), this._animateList = new Map(), this._runAnimateList = new Array(), this._localMat = new lt(), this._gravity = new H(), this.minPos = new j(), this.maxPos = new j(), this._nodePos = new j(), this._nodeSize = new j(), this._particleSystem = t, this._processor = this._particleSystem.processor, this._node = t.node, this._particlesAll = [], this._initModuleList();
        }

        var e = t.prototype;
        return e._updateBoundingNode = function () {
          this._nodeSize.set(this.maxPos.x - this.minPos.x, this.maxPos.y - this.minPos.y, this.maxPos.z - this.minPos.z), this._nodePos.set(this.minPos.x + .5 * this._nodeSize.x, this.minPos.y + .5 * this._nodeSize.y, this.minPos.z + .5 * this._nodeSize.z);
        }, e.setBoundingBoxSize = function (t) {
          this.maxPos.x = this._nodePos.x + t.x, this.maxPos.y = this._nodePos.y + t.y, this.maxPos.z = this._nodePos.z + t.z, this.minPos.x = this._nodePos.x - t.x, this.minPos.y = this._nodePos.y - t.y, this.minPos.z = this._nodePos.z - t.z, this._updateBoundingNode();
        }, e.setBoundingBoxCenter = function (t, e, i) {
          this.maxPos.x = t + .5 * this._nodeSize.x, this.maxPos.y = e + .5 * this._nodeSize.y, this.maxPos.z = i + .5 * this._nodeSize.z, this.minPos.x = t - .5 * this._nodeSize.x, this.minPos.y = e - .5 * this._nodeSize.y, this.minPos.z = i - .5 * this._nodeSize.z, this._updateBoundingNode();
        }, e._initModuleList = function () {
          var t = this;
          bp.forEach(function (e) {
            var i = t._particleSystem[e];
            i && i.enable && (i.needUpdate && (t._updateList[i.name] = i), i.needAnimate && (t._animateList[i.name] = i));
          }), this._runAnimateList.length = 0;

          for (var e = 0, i = dr.length; e < i; e++) {
            var r = this._animateList[dr[e]];
            r && this._runAnimateList.push(r);
          }
        }, e._emit = function (t, e, i) {
          var r = this._particleSystem,
              a = this._node,
              n = r.time % r.duration / r.duration;
          a.invalidateChildren(gt.POSITION), r.simulationSpace === mr.World && (a.getWorldMatrix(mp), a.getWorldRotation(yp));

          for (var o = 0; o < t; ++o) {
            var s = new Ri(r);
            s.particleSystem = r, s.reset();
            var l = ut(_t(0, R));
            r._shapeModule && r._shapeModule.enable ? r._shapeModule.emit(s) : (j.set(s.position, 0, 0, 0), j.copy(s.velocity, Or)), r._textureAnimationModule && r._textureAnimationModule.enable && r._textureAnimationModule.init(s);
            var u = r.startSpeed.evaluate(n, l);
            j.multiplyScalar(s.velocity, s.velocity, u), r.simulationSpace === mr.World && (j.transformMat4(s.position, s.position, mp), j.transformQuat(s.velocity, s.velocity, yp)), j.copy(s.ultimateVelocity, s.velocity), j.set(s.rotation, 0, 0, 0), r.startSize3D ? j.set(s.startSize, r.startSizeX.evaluate(n, l), r.startSizeY.evaluate(n, l), r.startSizeZ.evaluate(n, l)) : (j.set(s.startSize, r.startSizeX.evaluate(n, l), 1, 1), s.startSize.y = s.startSize.x), j.copy(s.size, s.startSize), s.startLifetime = r.startLifetime.evaluate(n, l) + e, s.remainingLifetime = s.startLifetime, i.push(s);
          }
        }, e._updateParticles = function (t, e) {
          var i = this,
              r = this._particleSystem;

          switch (r.node.getWorldMatrix(mp), r.scaleSpace) {
            case mr.Local:
              r.node.getScale(vp);
              break;

            case mr.World:
              r.node.getWorldScale(vp);
          }

          if (this._updateList.forEach(function (t) {
            t.update(r.simulationSpace, mp);
          }), r.simulationSpace === mr.Local) {
            var a = r.node.getRotation();
            lt.fromQuat(this._localMat, a), this._localMat.transpose();
          }

          for (var n = function n(a) {
            var n = e[a];

            if (n.remainingLifetime -= t, j.set(n.animatedVelocity, 0, 0, 0), r.simulationSpace === mr.Local) {
              var o = 9.8 * -r.gravityModifier.evaluate(1 - n.remainingLifetime / n.startLifetime, ut(n.randomSeed)) * t;
              i._gravity.x = 0, i._gravity.y = o, i._gravity.z = 0, i._gravity.w = 1, i._gravity = i._gravity.transformMat4(i._localMat), n.velocity.x += i._gravity.x, n.velocity.y += i._gravity.y, n.velocity.z += i._gravity.z;
            } else n.velocity.y -= 9.8 * r.gravityModifier.evaluate(1 - n.remainingLifetime / n.startLifetime, ut(n.randomSeed)) * t;

            j.copy(n.ultimateVelocity, n.velocity), i._runAnimateList.forEach(function (e) {
              e.animate(n, t);
            }), j.scaleAndAdd(n.position, n.position, n.ultimateVelocity, t);
          }, o = 0; o < e.length; ++o) {
            n(o);
          }
        }, e._calculateBounding = function (t) {
          var e = new j(),
              i = new j(),
              r = new j(),
              a = new j(),
              n = new j(1, 1, 1);

          if (this._processor.getInfo().renderMode === br.Mesh) {
            var o = this._processor.getInfo().mesh;

            if (o && o.struct.minPosition && o.struct.maxPosition) {
              var s = new Mt();
              Mt.fromPoints(s, o.struct.minPosition, o.struct.maxPosition);
              var l = Math.max(s.halfExtents.x, s.halfExtents.y, s.halfExtents.z);
              n.set(l, l, l);
            }
          }

          for (var u = 0; u < this._particlesAll.length; ++u) {
            var h = this._particlesAll[u];
            j.multiply(e, vp, h.size), j.multiply(e, e, n), i.set(h.position), this._particleSystem.simulationSpace !== mr.World && j.transformMat4(i, i, this._particleSystem.node._mat), t && 0 === u ? (j.subtract(this.minPos, i, e), j.add(this.maxPos, i, e)) : (j.subtract(r, i, e), j.add(a, i, e), j.min(this.minPos, this.minPos, r), j.max(this.maxPos, this.maxPos, a));
          }
        }, e.calculatePositions = function () {
          this._emit(this._particleSystem.capacity, 0, this._particlesAll);

          var t = ut(_t(0, R));
          this._updateParticles(0, this._particlesAll), this._calculateBounding(!0), this._updateParticles(this._particleSystem.startLifetime.evaluate(0, t), this._particlesAll), this._calculateBounding(!1), this._updateBoundingNode();
        }, e.clear = function () {
          this._particlesAll.length = 0;
        }, e.destroy = function () {}, t;
      }(),
          Mp = new lt(),
          Sp = new st(),
          wp = Object.getOwnPropertyDescriptor(Pt.prototype, "sharedMaterials"),
          Tp = function (e) {
        return t({
          ParticleSystem: e,
          ParticleSystemComponent: e
        }), e;
      }((Ih = A("cc.ParticleSystem"), Bh = L(), Lh = U(), Uh = Tt(99), Vh = ot(), Hh = nt(), kh = V(), Nh = C(wi), Gh = nt(), Wh = V(), jh = C(mr), Xh = nt(), Kh = V(), Yh = nt(), Zh = V(), qh = pt("startSize"), Qh = ot(), $h = C(ce), Jh = nt(), tc = V(), ec = C(ce), ic = ot(), rc = nt(), ac = V(), nc = C(ce), oc = ot(), sc = nt(), lc = V(), uc = C(ce), hc = ot(), cc = nt(), _c = V(), dc = nt(), pc = V(), fc = C(ce), mc = ot(), yc = nt(), vc = V(), bc = C(ce), gc = ot(), Mc = nt(), Sc = V(), wc = C(ce), Tc = pt("startRotation"), xc = ot(), Oc = nt(), zc = V(), Rc = C(ce), Ec = ot(), Ac = nt(), Cc = V(), Pc = C(ce), Dc = ot(), Fc = nt(), Ic = V(), Bc = nt(), Lc = V(), Uc = nt(), Vc = V(), Hc = nt(), kc = V(), Nc = C(mr), Gc = nt(), Wc = V(), jc = nt(), Xc = V(), Kc = nt(), Yc = V(), Zc = C(ce), qc = ot(), Qc = nt(), $c = V(), Jc = C(ce), t_ = ot(), e_ = nt(), i_ = V(), r_ = C(ce), a_ = ot(), n_ = nt(), o_ = V(), s_ = C([Ol]), l_ = nt(), u_ = V(), h_ = C(Boolean), c_ = nt(), __ = V(), d_ = C(yr), p_ = nt(), f_ = V(), m_ = C(Number), y_ = nt(), v_ = V(), b_ = C(Number), g_ = nt(), M_ = V(), S_ = C(Number), w_ = nt(), T_ = V(), x_ = nt(), O_ = V(), z_ = pt("enableCulling"), R_ = yt(), E_ = C(I), A_ = xt(), C_ = C(xr), P_ = C(xr), D_ = nt(), F_ = V(), I_ = C(Al), B_ = C(Al), L_ = nt(), U_ = V(), V_ = C(vl), H_ = C(vl), k_ = nt(), N_ = V(), G_ = C(xl), W_ = C(xl), j_ = nt(), X_ = V(), K_ = C(Na), Y_ = C(Na), Z_ = nt(), q_ = V(), Q_ = C(Xa), $_ = C(Xa), J_ = nt(), td = V(), ed = C(yl), id = C(yl), rd = nt(), ad = V(), nd = C(Sl), od = C(Sl), sd = nt(), ld = V(), ud = C(fp), hd = C(fp), cd = nt(), _d = V(), dd = C(op), pd = nt(), fd = V(), Ih(md = Bh(md = Lh(md = Uh(md = D((np = ap = function (t) {
        function i() {
          var e;
          return e = t.call(this) || this, u(e, "startColor", vd, h(e)), u(e, "scaleSpace", bd, h(e)), u(e, "startSize3D", gd, h(e)), u(e, "startSizeX", Md, h(e)), u(e, "startSizeY", Sd, h(e)), u(e, "startSizeZ", wd, h(e)), u(e, "startSpeed", Td, h(e)), u(e, "startRotation3D", xd, h(e)), u(e, "startRotationX", Od, h(e)), u(e, "startRotationY", zd, h(e)), u(e, "startRotationZ", Rd, h(e)), u(e, "startDelay", Ed, h(e)), u(e, "startLifetime", Ad, h(e)), u(e, "duration", Cd, h(e)), u(e, "loop", Pd, h(e)), u(e, "simulationSpeed", Dd, h(e)), u(e, "playOnAwake", Fd, h(e)), u(e, "gravityModifier", Id, h(e)), u(e, "rateOverTime", Bd, h(e)), u(e, "rateOverDistance", Ld, h(e)), u(e, "bursts", Ud, h(e)), u(e, "_renderCulling", Vd, h(e)), u(e, "_cullingMode", Hd, h(e)), u(e, "_aabbHalfX", kd, h(e)), u(e, "_aabbHalfY", Nd, h(e)), u(e, "_aabbHalfZ", Gd, h(e)), u(e, "_dataCulling", Wd, h(e)), u(e, "_colorOverLifetimeModule", jd, h(e)), u(e, "_shapeModule", Xd, h(e)), u(e, "_sizeOvertimeModule", Kd, h(e)), u(e, "_velocityOvertimeModule", Yd, h(e)), u(e, "_forceOvertimeModule", Zd, h(e)), u(e, "_limitVelocityOvertimeModule", qd, h(e)), u(e, "_rotationOvertimeModule", Qd, h(e)), u(e, "_textureAnimationModule", $d, h(e)), u(e, "_trailModule", Jd, h(e)), u(e, "renderer", tp, h(e)), e._isPlaying = void 0, e._isPaused = void 0, e._isStopped = void 0, e._isEmitting = void 0, e._needRefresh = void 0, e._time = void 0, e._emitRateTimeCounter = void 0, e._emitRateDistanceCounter = void 0, e._oldWPos = void 0, e._curWPos = void 0, e._boundingBox = void 0, e._culler = void 0, e._oldPos = void 0, e._curPos = void 0, e._isCulled = void 0, e._isSimulating = void 0, e._customData1 = void 0, e._customData2 = void 0, e._subEmitters = void 0, e._needAttach = void 0, u(e, "_prewarm", ep, h(e)), u(e, "_capacity", ip, h(e)), u(e, "_simulationSpace", rp, h(e)), e.processor = null, e.rateOverTime.constant = 10, e.startLifetime.constant = 5, e.startSizeX.constant = 1, e.startSpeed.constant = 5, e._isPlaying = !1, e._isPaused = !1, e._isStopped = !0, e._isEmitting = !1, e._needRefresh = !0, e._needAttach = !1, e._time = 0, e._emitRateTimeCounter = 0, e._emitRateDistanceCounter = 0, e._oldWPos = new j(), e._curWPos = new j(), e._boundingBox = null, e._culler = null, e._oldPos = null, e._curPos = null, e._isCulled = !1, e._isSimulating = !0, e._customData1 = new rt(), e._customData2 = new rt(), e._subEmitters = [], e;
        }

        e(i, t);
        var r = i.prototype;
        return r.onFocusInEditor = function () {
          this.renderer.create(this);
        }, r.onLoad = function () {
          this.renderer.onInit(this), this._shapeModule && this._shapeModule.onInit(this), this._trailModule && this._trailModule.onInit(this), this.bindModule(), this._resetPosition();
        }, r._onMaterialModified = function (t, e) {
          null !== this.processor && this.processor.onMaterialModified(t, e);
        }, r._onRebuildPSO = function (t, e) {
          this.processor.onRebuildPSO(t, e);
        }, r._collectModels = function () {
          return this._models.length = 0, this._models.push(this.processor._model), this._trailModule && this._trailModule.enable && this._trailModule._trailModel && this._models.push(this._trailModule._trailModel), this._models;
        }, r._attachToScene = function () {
          this.processor.attachToScene(), this._trailModule && this._trailModule.enable && this._trailModule._attachToScene();
        }, r._detachFromScene = function () {
          this.processor.detachFromScene(), this._trailModule && this._trailModule.enable && this._trailModule._detachFromScene(), this._boundingBox && (this._boundingBox = null), this._culler && (this._culler.clear(), this._culler.destroy(), this._culler = null);
        }, r.bindModule = function () {
          this._colorOverLifetimeModule && this._colorOverLifetimeModule.bindTarget(this.processor), this._sizeOvertimeModule && this._sizeOvertimeModule.bindTarget(this.processor), this._rotationOvertimeModule && this._rotationOvertimeModule.bindTarget(this.processor), this._forceOvertimeModule && this._forceOvertimeModule.bindTarget(this.processor), this._limitVelocityOvertimeModule && this._limitVelocityOvertimeModule.bindTarget(this.processor), this._velocityOvertimeModule && this._velocityOvertimeModule.bindTarget(this.processor), this._textureAnimationModule && this._textureAnimationModule.bindTarget(this.processor);
        }, r.play = function () {
          if (this._isPaused && (this._isPaused = !1), this._isStopped && (this._isStopped = !1), this._isPlaying = !0, this._isEmitting = !0, this._resetPosition(), this._prewarm && this._prewarmSystem(), this._trailModule && this._trailModule.play(), this.processor) {
            var t = this.processor.getModel();
            t && (t.enabled = this.enabledInHierarchy);
          }
        }, r.pause = function () {
          this._isStopped ? console.warn("pause(): particle system is already stopped.") : (this._isPlaying && (this._isPlaying = !1), this._isPaused = !0);
        }, r.stop = function () {
          (this._isPlaying || this._isPaused) && this.clear(), this._isPlaying && (this._isPlaying = !1), this._isPaused && (this._isPaused = !1), this._time = 0, this._emitRateTimeCounter = 0, this._emitRateDistanceCounter = 0, this._isStopped = !0, this._needRefresh = !0;

          for (var t, e = c(this.bursts); !(t = e()).done;) {
            t.value.reset();
          }
        }, r.clear = function () {
          this.enabledInHierarchy && (this.processor.clear(), this._trailModule && this._trailModule.clear()), this._calculateBounding(!1);
        }, r.getParticleCount = function () {
          return this.processor.getParticleCount();
        }, r.setCustomData1 = function (t, e) {
          rt.set(this._customData1, t, e);
        }, r.setCustomData2 = function (t, e) {
          rt.set(this._customData2, t, e);
        }, r.onDestroy = function () {
          o.director.off(o.Director.EVENT_BEFORE_COMMIT, this.beforeRender, this), this.processor.onDestroy(), this._trailModule && this._trailModule.destroy(), this._culler && (this._culler.clear(), this._culler.destroy(), this._culler = null);
        }, r.onEnable = function () {
          o.director.on(o.Director.EVENT_BEFORE_COMMIT, this.beforeRender, this), this.playOnAwake && !M && this.play(), this.processor.onEnable(), this._trailModule && this._trailModule.onEnable();
        }, r.onDisable = function () {
          o.director.off(o.Director.EVENT_BEFORE_COMMIT, this.beforeRender, this), this.processor.onDisable(), this._trailModule && this._trailModule.onDisable(), this._boundingBox && (this._boundingBox = null), this._culler && (this._culler.clear(), this._culler.destroy(), this._culler = null);
        }, r._calculateBounding = function (t) {
          this._boundingBox && (this._culler || (this._culler = new gp(this)), this._culler.calculatePositions(), Mt.fromPoints(this._boundingBox, this._culler.minPos, this._culler.maxPos), t ? (this.aabbHalfX = this._boundingBox.halfExtents.x, this.aabbHalfY = this._boundingBox.halfExtents.y, this.aabbHalfZ = this._boundingBox.halfExtents.z) : (this.aabbHalfX ? this.setBoundingX(this.aabbHalfX) : this.aabbHalfX = this._boundingBox.halfExtents.x, this.aabbHalfY ? this.setBoundingY(this.aabbHalfY) : this.aabbHalfY = this._boundingBox.halfExtents.y, this.aabbHalfZ ? this.setBoundingZ(this.aabbHalfZ) : this.aabbHalfZ = this._boundingBox.halfExtents.z), this._culler.clear());
        }, r.update = function (t) {
          var e,
              i,
              r = t * this.simulationSpeed;

          if (this.renderCulling) {
            var a;

            if (this._boundingBox || (this._boundingBox = new Mt(), this._calculateBounding(!1)), this._curPos || (this._curPos = new j()), this.node.getWorldPosition(this._curPos), this._oldPos || (this._oldPos = new j(), this._oldPos.set(this._curPos)), !this._curPos.equals(this._oldPos) && this._boundingBox && this._culler) {
              var n = this._curPos.x - this._oldPos.x,
                  o = this._curPos.y - this._oldPos.y,
                  s = this._curPos.z - this._oldPos.z,
                  l = this._boundingBox.center;
              l.x += n, l.y += o, l.z += s, this._culler.setBoundingBoxCenter(l.x, l.y, l.z), this._oldPos.set(this._curPos);
            }

            var u = null === (a = this.node.scene.renderScene) || void 0 === a ? void 0 : a.cameras,
                h = !0;
            if (void 0 !== u && this._boundingBox) for (var c = 0; c < u.length; ++c) {
              var _ = u[c];

              if ((_.visibility & this.node.layer) === this.node.layer && St.aabbFrustum(this._boundingBox, _.frustum)) {
                h = !1;
                break;
              }
            }

            if (h) {
              if (this._cullingMode !== yr.AlwaysSimulate && (this._isSimulating = !1), this._isCulled || (this.processor.detachFromScene(), this._isCulled = !0), this._trailModule && this._trailModule.enable && this._trailModule._detachFromScene(), this._cullingMode === yr.PauseAndCatchup && (this._time += r), this._cullingMode !== yr.AlwaysSimulate) return;
            } else this._isCulled && (this._attachToScene(), this._isCulled = !1), this._isSimulating || (this._isSimulating = !0);

            if (!this._isSimulating) return;
          } else this._boundingBox && (this._boundingBox = null), this._culler && (this._culler.clear(), this._culler.destroy(), this._culler = null), this._isSimulating = !0;

          if (this._isPlaying) this._time += r, this._emit(r), 0 !== this.processor.updateParticles(r) || this._isEmitting || this.stop();else {
            var d = (this.getMaterialInstance(0) || this.processor.getDefaultMaterial()).passes[0];
            this.processor.updateRotation(d), this.processor.updateScale(d);
          }
          (this.processor.updateRenderData(), this._trailModule && this._trailModule.enable && this._trailModule.updateRenderData(), this._needAttach && this.getParticleCount() > 0 && !this._isCulled) && ((null === (e = this.processor.getModel()) || void 0 === e ? void 0 : e.scene) || this.processor.attachToScene(), this._trailModule && this._trailModule.enable && ((null === (i = this._trailModule.getModel()) || void 0 === i ? void 0 : i.scene) || this._trailModule._attachToScene()), this._needAttach = !1);
        }, r.beforeRender = function () {
          var t, e;
          this._isPlaying && (this.processor.beforeRender(), this._trailModule && this._trailModule.enable && this._trailModule.beforeRender(), this.getParticleCount() <= 0 ? (null === (e = this.processor.getModel()) || void 0 === e ? void 0 : e.scene) && (this.processor.detachFromScene(), this._trailModule && this._trailModule.enable && this._trailModule._detachFromScene(), this._needAttach = !1) : (null === (t = this.processor.getModel()) || void 0 === t ? void 0 : t.scene) || (this._needAttach = !0));
        }, r._onVisibilityChange = function (t) {
          this.processor._model && (this.processor._model.visFlags = t);
        }, r.emit = function (t, e) {
          var i = this._time % this.duration / this.duration;
          this._needRefresh && (this.node.invalidateChildren(gt.POSITION), this._needRefresh = !1), this._simulationSpace === mr.World && (this.node.getWorldMatrix(Mp), this.node.getWorldRotation(Sp));

          for (var r = 0; r < t; ++r) {
            var a = this.processor.getFreeParticle();
            if (null === a) return;
            a.particleSystem = this, a.reset();
            var n = ut(_t(0, R));
            this._shapeModule && this._shapeModule.enable ? this._shapeModule.emit(a) : (j.set(a.position, 0, 0, 0), j.copy(a.velocity, Or)), this._textureAnimationModule && this._textureAnimationModule.enable && this._textureAnimationModule.init(a);
            var o = this.startSpeed.evaluate(i, n);
            j.multiplyScalar(a.velocity, a.velocity, o), this._simulationSpace === mr.World && (j.transformMat4(a.position, a.position, Mp), j.transformQuat(a.velocity, a.velocity, Sp)), j.copy(a.ultimateVelocity, a.velocity), this.startRotation3D ? a.startEuler.set(this.startRotationX.evaluate(i, n), this.startRotationY.evaluate(i, n), this.startRotationZ.evaluate(i, n)) : a.startEuler.set(0, 0, this.startRotationZ.evaluate(i, n)), a.rotation.set(a.startEuler), this.startSize3D ? j.set(a.startSize, this.startSizeX.evaluate(i, n), this.startSizeY.evaluate(i, n), this.startSizeZ.evaluate(i, n)) : (j.set(a.startSize, this.startSizeX.evaluate(i, n), 1, 1), a.startSize.y = a.startSize.x), j.copy(a.size, a.startSize), a.startColor.set(this.startColor.evaluate(i, n)), a.color.set(a.startColor), a.startLifetime = this.startLifetime.evaluate(i, n) + e, a.remainingLifetime = a.startLifetime, a.randomSeed = _t(0, 233280), a.loopCount++, this.processor.setNewParticle(a);
          }
        }, r._prewarmSystem = function () {
          this.startDelay.mode = he.Constant, this.startDelay.constant = 0;

          for (var t = this.duration / 1, e = 0; e < t; ++e) {
            this._time += 1, this._emit(1), this.processor.updateParticles(1);
          }
        }, r._emit = function (t) {
          var e = this.startDelay.evaluate(0, 1);

          if (this._time > e) {
            if (this._time > this.duration + e && !this.loop) return void (this._isEmitting = !1);

            if (this._emitRateTimeCounter += this.rateOverTime.evaluate(this._time / this.duration, 1) * t, this._emitRateTimeCounter > 1 && this._isEmitting) {
              var i = Math.floor(this._emitRateTimeCounter);
              this._emitRateTimeCounter -= i, this.emit(i, t);
            }

            this.node.getWorldPosition(this._curWPos);
            var r = j.distance(this._curWPos, this._oldWPos);

            if (j.copy(this._oldWPos, this._curWPos), this._emitRateDistanceCounter += r * this.rateOverDistance.evaluate(this._time / this.duration, 1), this._emitRateDistanceCounter > 1 && this._isEmitting) {
              var a = Math.floor(this._emitRateDistanceCounter);
              this._emitRateDistanceCounter -= a, this.emit(a, t);
            }

            for (var n, o = c(this.bursts); !(n = o()).done;) {
              n.value.update(this, t);
            }
          }
        }, r._resetPosition = function () {
          this.node.getWorldPosition(this._oldWPos), j.copy(this._curWPos, this._oldWPos);
        }, r.addSubEmitter = function (t) {
          this._subEmitters.push(t);
        }, r.removeSubEmitter = function (t) {
          this._subEmitters.splice(this._subEmitters.indexOf(t), 1);
        }, r.addBurst = function (t) {
          this.bursts.push(t);
        }, r.removeBurst = function (t) {
          this.bursts.splice(this.bursts.indexOf(t), 1);
        }, r.getBoundingX = function () {
          return this._aabbHalfX;
        }, r.getBoundingY = function () {
          return this._aabbHalfY;
        }, r.getBoundingZ = function () {
          return this._aabbHalfZ;
        }, r.setBoundingX = function (t) {
          this._boundingBox && this._culler && (this._boundingBox.halfExtents.x = t, this._culler.setBoundingBoxSize(this._boundingBox.halfExtents), this._aabbHalfX = t);
        }, r.setBoundingY = function (t) {
          this._boundingBox && this._culler && (this._boundingBox.halfExtents.y = t, this._culler.setBoundingBoxSize(this._boundingBox.halfExtents), this._aabbHalfY = t);
        }, r.setBoundingZ = function (t) {
          this._boundingBox && this._culler && (this._boundingBox.halfExtents.z = t, this._culler.setBoundingBoxSize(this._boundingBox.halfExtents), this._aabbHalfZ = t);
        }, r._onBeforeSerialize = function (t) {
          var e = this;
          return this.dataCulling ? t.filter(function (t) {
            return !pr.includes(t) || e[t] && e[t].enable;
          }) : t;
        }, s(i, [{
          key: "capacity",
          get: function get() {
            return this._capacity;
          },
          set: function set(t) {
            this._capacity = Math.floor(t > 0 ? t : 0), this.processor && this.processor._model && this.processor._model.setCapacity(this._capacity);
          }
        }, {
          key: "prewarm",
          get: function get() {
            return this._prewarm;
          },
          set: function set(t) {
            !0 === t && this.loop, this._prewarm = t;
          }
        }, {
          key: "simulationSpace",
          get: function get() {
            return this._simulationSpace;
          },
          set: function set(t) {
            t !== this._simulationSpace && (this._simulationSpace = t, this.processor && (this.processor.updateMaterialParams(), this.processor.updateTrailMaterial()));
          }
        }, {
          key: "renderCulling",
          get: function get() {
            return this._renderCulling;
          },
          set: function set(t) {
            this._renderCulling = t, t && (this._boundingBox || (this._boundingBox = new Mt(), this._calculateBounding(!1)));
          }
        }, {
          key: "cullingMode",
          get: function get() {
            return this._cullingMode;
          },
          set: function set(t) {
            this._cullingMode = t;
          }
        }, {
          key: "aabbHalfX",
          get: function get() {
            return this.getBoundingX() || 0;
          },
          set: function set(t) {
            this.setBoundingX(t);
          }
        }, {
          key: "aabbHalfY",
          get: function get() {
            return this.getBoundingY() || 0;
          },
          set: function set(t) {
            this.setBoundingY(t);
          }
        }, {
          key: "aabbHalfZ",
          get: function get() {
            return this.getBoundingZ() || 0;
          },
          set: function set(t) {
            this.setBoundingZ(t);
          }
        }, {
          key: "dataCulling",
          get: function get() {
            return this._dataCulling;
          },
          set: function set(t) {
            this._dataCulling = t;
          }
        }, {
          key: "sharedMaterials",
          get: function get() {
            return wp.get.call(this);
          },
          set: function set(t) {
            wp.set.call(this, t);
          }
        }, {
          key: "colorOverLifetimeModule",
          get: function get() {
            return this._colorOverLifetimeModule;
          },
          set: function set(t) {
            t && (this._colorOverLifetimeModule = t);
          }
        }, {
          key: "shapeModule",
          get: function get() {
            return this._shapeModule;
          },
          set: function set(t) {
            t && (this._shapeModule = t);
          }
        }, {
          key: "sizeOvertimeModule",
          get: function get() {
            return this._sizeOvertimeModule;
          },
          set: function set(t) {
            t && (this._sizeOvertimeModule = t);
          }
        }, {
          key: "velocityOvertimeModule",
          get: function get() {
            return this._velocityOvertimeModule;
          },
          set: function set(t) {
            t && (this._velocityOvertimeModule = t);
          }
        }, {
          key: "forceOvertimeModule",
          get: function get() {
            return this._forceOvertimeModule;
          },
          set: function set(t) {
            t && (this._forceOvertimeModule = t);
          }
        }, {
          key: "limitVelocityOvertimeModule",
          get: function get() {
            return this._limitVelocityOvertimeModule;
          },
          set: function set(t) {
            t && (this._limitVelocityOvertimeModule = t);
          }
        }, {
          key: "rotationOvertimeModule",
          get: function get() {
            return this._rotationOvertimeModule;
          },
          set: function set(t) {
            t && (this._rotationOvertimeModule = t);
          }
        }, {
          key: "textureAnimationModule",
          get: function get() {
            return this._textureAnimationModule;
          },
          set: function set(t) {
            t && (this._textureAnimationModule = t);
          }
        }, {
          key: "trailModule",
          get: function get() {
            return this._trailModule;
          },
          set: function set(t) {
            t && (this._trailModule = t);
          }
        }, {
          key: "isPlaying",
          get: function get() {
            return this._isPlaying;
          }
        }, {
          key: "isPaused",
          get: function get() {
            return this._isPaused;
          }
        }, {
          key: "isStopped",
          get: function get() {
            return this._isStopped;
          }
        }, {
          key: "isEmitting",
          get: function get() {
            return this._isEmitting;
          }
        }, {
          key: "time",
          get: function get() {
            return this._time;
          }
        }]), i;
      }(Pt), ap.CullingMode = yr, l((yd = np).prototype, "capacity", [Vh, Hh, kh], Object.getOwnPropertyDescriptor(yd.prototype, "capacity"), yd.prototype), vd = l(yd.prototype, "startColor", [Nh, W, Gh, Wh], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return new wi();
        }
      }), bd = l(yd.prototype, "scaleSpace", [jh, W, Xh, Kh], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return mr.Local;
        }
      }), gd = l(yd.prototype, "startSize3D", [W, Yh, Zh], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !1;
        }
      }), Md = l(yd.prototype, "startSizeX", [qh, Qh, $h, Jh, tc], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return new ce();
        }
      }), Sd = l(yd.prototype, "startSizeY", [ec, W, ic, rc, ac], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return new ce();
        }
      }), wd = l(yd.prototype, "startSizeZ", [nc, W, oc, sc, lc], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return new ce();
        }
      }), Td = l(yd.prototype, "startSpeed", [uc, W, hc, cc, _c], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return new ce();
        }
      }), xd = l(yd.prototype, "startRotation3D", [W, dc, pc], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !1;
        }
      }), Od = l(yd.prototype, "startRotationX", [fc, W, mc, dt, yc, vc], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return new ce();
        }
      }), zd = l(yd.prototype, "startRotationY", [bc, W, gc, dt, Mc, Sc], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return new ce();
        }
      }), Rd = l(yd.prototype, "startRotationZ", [wc, Tc, xc, dt, Oc, zc], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return new ce();
        }
      }), Ed = l(yd.prototype, "startDelay", [Rc, W, Ec, Ac, Cc], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return new ce();
        }
      }), Ad = l(yd.prototype, "startLifetime", [Pc, W, Dc, Fc, Ic], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return new ce();
        }
      }), Cd = l(yd.prototype, "duration", [W, Bc, Lc], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 5;
        }
      }), Pd = l(yd.prototype, "loop", [W, Uc, Vc], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !0;
        }
      }), l(yd.prototype, "prewarm", [Hc, kc], Object.getOwnPropertyDescriptor(yd.prototype, "prewarm"), yd.prototype), l(yd.prototype, "simulationSpace", [Nc, W, Gc, Wc], Object.getOwnPropertyDescriptor(yd.prototype, "simulationSpace"), yd.prototype), Dd = l(yd.prototype, "simulationSpeed", [W, jc, Xc], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 1;
        }
      }), Fd = l(yd.prototype, "playOnAwake", [W, Kc, Yc], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !0;
        }
      }), Id = l(yd.prototype, "gravityModifier", [Zc, W, qc, Qc, $c], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return new ce();
        }
      }), Bd = l(yd.prototype, "rateOverTime", [Jc, W, t_, e_, i_], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return new ce();
        }
      }), Ld = l(yd.prototype, "rateOverDistance", [r_, W, a_, n_, o_], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return new ce();
        }
      }), Ud = l(yd.prototype, "bursts", [s_, W, l_, u_], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return [];
        }
      }), l(yd.prototype, "renderCulling", [h_, c_, __], Object.getOwnPropertyDescriptor(yd.prototype, "renderCulling"), yd.prototype), Vd = l(yd.prototype, "_renderCulling", [W], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !1;
        }
      }), l(yd.prototype, "cullingMode", [d_, p_, f_], Object.getOwnPropertyDescriptor(yd.prototype, "cullingMode"), yd.prototype), Hd = l(yd.prototype, "_cullingMode", [W], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return yr.Pause;
        }
      }), l(yd.prototype, "aabbHalfX", [m_, y_, v_], Object.getOwnPropertyDescriptor(yd.prototype, "aabbHalfX"), yd.prototype), kd = l(yd.prototype, "_aabbHalfX", [W], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 0;
        }
      }), l(yd.prototype, "aabbHalfY", [b_, g_, M_], Object.getOwnPropertyDescriptor(yd.prototype, "aabbHalfY"), yd.prototype), Nd = l(yd.prototype, "_aabbHalfY", [W], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 0;
        }
      }), l(yd.prototype, "aabbHalfZ", [S_, w_, T_], Object.getOwnPropertyDescriptor(yd.prototype, "aabbHalfZ"), yd.prototype), Gd = l(yd.prototype, "_aabbHalfZ", [W], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 0;
        }
      }), l(yd.prototype, "dataCulling", [x_, O_], Object.getOwnPropertyDescriptor(yd.prototype, "dataCulling"), yd.prototype), Wd = l(yd.prototype, "_dataCulling", [W, z_], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !1;
        }
      }), l(yd.prototype, "sharedMaterials", [wt, R_, E_, W, A_], Object.getOwnPropertyDescriptor(yd.prototype, "sharedMaterials"), yd.prototype), jd = l(yd.prototype, "_colorOverLifetimeModule", [C_], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return null;
        }
      }), l(yd.prototype, "colorOverLifetimeModule", [P_, D_, F_], Object.getOwnPropertyDescriptor(yd.prototype, "colorOverLifetimeModule"), yd.prototype), Xd = l(yd.prototype, "_shapeModule", [I_], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return null;
        }
      }), l(yd.prototype, "shapeModule", [B_, L_, U_], Object.getOwnPropertyDescriptor(yd.prototype, "shapeModule"), yd.prototype), Kd = l(yd.prototype, "_sizeOvertimeModule", [V_], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return null;
        }
      }), l(yd.prototype, "sizeOvertimeModule", [H_, k_, N_], Object.getOwnPropertyDescriptor(yd.prototype, "sizeOvertimeModule"), yd.prototype), Yd = l(yd.prototype, "_velocityOvertimeModule", [G_], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return null;
        }
      }), l(yd.prototype, "velocityOvertimeModule", [W_, j_, X_], Object.getOwnPropertyDescriptor(yd.prototype, "velocityOvertimeModule"), yd.prototype), Zd = l(yd.prototype, "_forceOvertimeModule", [K_], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return null;
        }
      }), l(yd.prototype, "forceOvertimeModule", [Y_, Z_, q_], Object.getOwnPropertyDescriptor(yd.prototype, "forceOvertimeModule"), yd.prototype), qd = l(yd.prototype, "_limitVelocityOvertimeModule", [Q_], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return null;
        }
      }), l(yd.prototype, "limitVelocityOvertimeModule", [$_, J_, td], Object.getOwnPropertyDescriptor(yd.prototype, "limitVelocityOvertimeModule"), yd.prototype), Qd = l(yd.prototype, "_rotationOvertimeModule", [ed], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return null;
        }
      }), l(yd.prototype, "rotationOvertimeModule", [id, rd, ad], Object.getOwnPropertyDescriptor(yd.prototype, "rotationOvertimeModule"), yd.prototype), $d = l(yd.prototype, "_textureAnimationModule", [nd], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return null;
        }
      }), l(yd.prototype, "textureAnimationModule", [od, sd, ld], Object.getOwnPropertyDescriptor(yd.prototype, "textureAnimationModule"), yd.prototype), Jd = l(yd.prototype, "_trailModule", [ud], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return null;
        }
      }), l(yd.prototype, "trailModule", [hd, cd, _d], Object.getOwnPropertyDescriptor(yd.prototype, "trailModule"), yd.prototype), tp = l(yd.prototype, "renderer", [dd, W, pd, fd], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return new op();
        }
      }), ep = l(yd.prototype, "_prewarm", [W], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !1;
        }
      }), ip = l(yd.prototype, "_capacity", [W], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 100;
        }
      }), rp = l(yd.prototype, "_simulationSpace", [W], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return mr.Local;
        }
      }), md = yd)) || md) || md) || md) || md) || md)),
          xp = t("ParticleUtils", function () {
        function t() {}

        return t.instantiate = function (t) {
          return this.registeredSceneEvent || (Dt.on(Ft.EVENT_BEFORE_SCENE_LAUNCH, this.onSceneUnload, this), this.registeredSceneEvent = !0), this.particleSystemPool.has(t._uuid) || this.particleSystemPool.set(t._uuid, new z(function () {
            return Ot(t) || new zt();
          }, 1, function (t) {
            return t.destroy();
          })), this.particleSystemPool.get(t._uuid).alloc();
        }, t.destroy = function (t) {
          this.particleSystemPool.has(t._prefab.asset._uuid) && (this.stop(t), this.particleSystemPool.get(t._prefab.asset._uuid).free(t));
        }, t.play = function (t) {
          for (var e, i = c(t.getComponentsInChildren(Tp)); !(e = i()).done;) {
            e.value.play();
          }
        }, t.stop = function (t) {
          for (var e, i = c(t.getComponentsInChildren(Tp)); !(e = i()).done;) {
            e.value.stop();
          }
        }, t.onSceneUnload = function () {
          this.particleSystemPool.forEach(function (t) {
            return t.destroy();
          }), this.particleSystemPool.clear();
        }, t;
      }());

      xp.particleSystemPool = new Map(), xp.registeredSceneEvent = !1, Rt(Ol.prototype, "Burst.prototype", [{
        name: "minCount"
      }, {
        name: "maxCount"
      }]), Et(Tp.prototype, "ParticleSystem.prototype", [{
        name: "enableCulling",
        newName: "dataCulling"
      }]), o.ParticleSystemComponent = Tp, E.setClassAlias(Tp, "cc.ParticleSystemComponent"), o.BillboardComponent = re, E.setClassAlias(re, "cc.BillboardComponent"), o.LineComponent = zi, E.setClassAlias(zi, "cc.LineComponent"), o.ParticleUtils = xp;
    }
  };
}); 
 			}); 
		define("__plugin__/wx0446ba2621dda60a/primitive.js", function(require, module, exports){ 			
"use strict";

System.register(["./texture-barrier-60b5983b.js", "./json-asset-933a1d4c.js", "./create-mesh-39923017.js", "./mesh-f5415e9d.js", "./capsule-3dc9b423.js"], function (i) {
  "use strict";

  var n, o, t, r, s, e, a, u, v, c, f, h, m, p, d, l, P, M, g;
  return {
    setters: [function (i) {
      n = i.W, o = i.bw, t = i.bT, r = i.c0, s = i.l, e = i.c1, a = i.b$;
    }, function (i) {
      u = i.Q, v = i.bW, c = i.bZ, f = i.bX, h = i.b$;
    }, function (i) {
      m = i.c;
    }, function (i) {
      p = i.M;
    }, function (i) {
      d = i.c, l = i.a, P = i.b, M = i.p, g = i.d;
    }],
    execute: function execute() {
      var x,
          b,
          y,
          E,
          I,
          L,
          R,
          w,
          z,
          A = Object.freeze({
        __proto__: null,
        box: P,
        cone: function cone(i, n, o) {
          return void 0 === i && (i = .5), void 0 === n && (n = 1), void 0 === o && (o = {}), d(0, i, n, o);
        },
        cylinder: d,
        plane: M,
        quad: function quad(i) {
          var n = l(i),
              o = {
            positions: [-.5, -.5, 0, -.5, .5, 0, .5, .5, 0, .5, -.5, 0],
            indices: [0, 3, 1, 3, 2, 1],
            minPos: {
              x: -.5,
              y: -.5,
              z: 0
            },
            maxPos: {
              x: .5,
              y: .5,
              z: 0
            },
            boundingRadius: Math.sqrt(.5)
          };
          return !1 !== n.includeNormal && (o.normals = [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1]), !1 !== n.includeUV && (o.uvs = [0, 0, 0, 1, 1, 1, 1, 0]), o;
        },
        sphere: function sphere(i, n) {
          void 0 === i && (i = .5), void 0 === n && (n = {});

          for (var o = void 0 !== n.segments ? n.segments : 32, t = [], r = [], s = [], e = [], a = new u(-i, -i, -i), v = new u(i, i, i), c = i, f = 0; f <= o; ++f) {
            for (var h = f * Math.PI / o, m = Math.sin(h), p = -Math.cos(h), d = 0; d <= o; ++d) {
              var l = 2 * d * Math.PI / o - Math.PI / 2,
                  P = Math.sin(l) * m,
                  M = p,
                  g = Math.cos(l) * m,
                  x = d / o,
                  b = f / o;

              if (t.push(P * i, M * i, g * i), r.push(P, M, g), s.push(x, b), f < o && d < o) {
                var y = o + 1,
                    E = y * f + d,
                    I = y * (f + 1) + d,
                    L = y * (f + 1) + d + 1,
                    R = y * f + d + 1;
                e.push(E, R, I), e.push(R, L, I);
              }
            }
          }

          return {
            positions: t,
            indices: e,
            normals: r,
            uvs: s,
            minPos: a,
            maxPos: v,
            boundingRadius: c
          };
        },
        torus: function torus(i, n, o) {
          void 0 === i && (i = .4), void 0 === n && (n = .1), void 0 === o && (o = {});

          for (var t = o.radialSegments || 32, r = o.tubularSegments || 32, s = o.arc || 2 * Math.PI, e = [], a = [], v = [], c = [], f = new u(-i - n, -n, -i - n), h = new u(i + n, n, i + n), m = i + n, p = 0; p <= t; p++) {
            for (var d = 0; d <= r; d++) {
              var l = d / r,
                  P = p / t,
                  M = l * s,
                  g = P * Math.PI * 2,
                  x = (i + n * Math.cos(g)) * Math.sin(M),
                  b = n * Math.sin(g),
                  y = (i + n * Math.cos(g)) * Math.cos(M),
                  E = Math.sin(M) * Math.cos(g),
                  I = Math.sin(g),
                  L = Math.cos(M) * Math.cos(g);

              if (e.push(x, b, y), a.push(E, I, L), v.push(l, P), d < r && p < t) {
                var R = r + 1,
                    w = R * p + d,
                    z = R * (p + 1) + d,
                    A = R * (p + 1) + d + 1,
                    N = R * p + d + 1;
                c.push(w, N, z), c.push(N, A, z);
              }
            }
          }

          return {
            positions: e,
            normals: a,
            uvs: v,
            indices: c,
            minPos: f,
            maxPos: h,
            boundingRadius: m
          };
        },
        capsule: g,
        circle: function circle(i) {
          var o = function (i) {
            return (i = l(i)).segments = 64, i;
          }(i).segments,
              t = new Array(3 * (o + 1));

          t[0] = 0, t[1] = 0, t[2] = 0;
          var r = new Array(1 + 2 * o);
          r[0] = 0;

          for (var s = 2 * Math.PI / o, e = 0; e < o; ++e) {
            var a = s * e,
                u = Math.cos(a),
                v = Math.sin(a),
                c = 3 * (e + 1);
            t[c + 0] = u, t[c + 1] = v, t[c + 2] = 0;
            var f = 2 * e;
            r[1 + f] = e + 1, r[1 + (f + 1)] = e + 2;
          }

          return o > 0 && (r[r.length - 1] = 1), {
            positions: t,
            indices: r,
            minPos: {
              x: 1,
              y: 1,
              z: 0
            },
            maxPos: {
              x: -1,
              y: -1,
              z: 0
            },
            boundingRadius: 1,
            primitiveMode: n.TRIANGLE_FAN
          };
        },
        translate: function translate(i, n) {
          for (var o = n.x || 0, t = n.y || 0, r = n.z || 0, s = Math.floor(i.positions.length / 3), e = 0; e < s; ++e) {
            var a = 3 * e,
                u = 3 * e + 1,
                v = 3 * e + 2;
            i.positions[a] += o, i.positions[u] += t, i.positions[v] += r;
          }

          return i.minPos && (i.minPos.x += o, i.minPos.y += t, i.minPos.z += r), i.maxPos && (i.maxPos.x += o, i.maxPos.y += t, i.maxPos.z += r), i;
        },
        scale: function scale(i, n) {
          for (var o = n.x || 0, t = n.y || 0, r = n.z || 0, s = Math.floor(i.positions.length / 3), e = 0; e < s; ++e) {
            var a = 3 * e,
                u = 3 * e + 1,
                v = 3 * e + 2;
            i.positions[a] *= o, i.positions[u] *= t, i.positions[v] *= r;
          }

          return i.minPos && (i.minPos.x *= o, i.minPos.y *= t, i.minPos.z *= r), i.maxPos && (i.maxPos.x *= o, i.maxPos.y *= t, i.maxPos.z *= r), i.boundingRadius = Math.max(Math.max(o, t), r), i;
        },
        wireframed: function wireframed(i) {
          var o = i.indices;
          if (!o) return i;
          if (i.primitiveMode && i.primitiveMode !== n.TRIANGLE_LIST) return i;

          for (var t = [[0, 1], [1, 2], [2, 0]], r = [], s = {}, e = 0; e < o.length; e += 3) {
            for (var a = 0; a < 3; ++a) {
              var u = o[e + t[a][0]],
                  v = o[e + t[a][1]],
                  c = u > v ? v << 16 | u : u << 16 | v;
              void 0 === s[c] && (s[c] = 0, r.push(u, v));
            }
          }

          return i.indices = r, i.primitiveMode = n.LINE_LIST, i;
        },
        wireframe: function wireframe(i) {
          for (var n = [[0, 1], [1, 2], [2, 0]], o = [], t = {}, r = 0; r < i.length; r += 3) {
            for (var s = 0; s < 3; ++s) {
              var e = i[r + n[s][0]],
                  a = i[r + n[s][1]],
                  u = e > a ? a << 16 | e : e << 16 | a;
              void 0 === t[u] && (t[u] = 0, o.push(e, a));
            }
          }

          return o;
        },
        invWinding: function invWinding(i) {
          for (var n = [], o = 0; o < i.length; o += 3) {
            n.push(i[o], i[o + 2], i[o + 1]);
          }

          return n;
        },
        toWavefrontOBJ: function toWavefrontOBJ(i, o) {
          if (void 0 === o && (o = 1), !i.indices || !i.uvs || !i.normals || void 0 !== i.primitiveMode && i.primitiveMode !== n.TRIANGLE_LIST) return "";

          for (var t = i.positions, r = i.uvs, s = i.normals, e = i.indices, a = function a(i) {
            return e[i] + 1 + "/" + (e[i] + 1) + "/" + (e[i] + 1);
          }, u = "", v = 0; v < t.length; v += 3) {
            u += "v " + t[v] * o + " " + t[v + 1] * o + " " + t[v + 2] * o + "\n";
          }

          for (var c = 0; c < r.length; c += 2) {
            u += "vt " + r[c] + " " + r[c + 1] + "\n";
          }

          for (var f = 0; f < s.length; f += 3) {
            u += "vn " + s[f] + " " + s[f + 1] + " " + s[f + 2] + "\n";
          }

          for (var h = 0; h < e.length; h += 3) {
            u += "f " + a(h) + " " + a(h + 1) + " " + a(h + 2) + "\n";
          }

          return u;
        },
        normals: function normals(i, n, o) {
          void 0 === o && (o = 1);

          for (var t = new Array(2 * i.length), r = 0; r < i.length / 3; ++r) {
            var s = 3 * r,
                e = 6 * r;
            t[e + 0] = i[s + 0], t[e + 1] = i[s + 1], t[e + 2] = i[s + 2], t[e + 3] = i[s + 0] + n[s + 0] * o, t[e + 4] = i[s + 1] + n[s + 1] * o, t[e + 5] = i[s + 2] + n[s + 2] * o;
          }

          return t;
        },
        applyDefaultGeometryOptions: l
      });
      i("primitives", A), function (i) {
        i[i.BOX = 0] = "BOX", i[i.SPHERE = 1] = "SPHERE", i[i.CYLINDER = 2] = "CYLINDER", i[i.CONE = 3] = "CONE", i[i.CAPSULE = 4] = "CAPSULE", i[i.TORUS = 5] = "TORUS", i[i.PLANE = 6] = "PLANE", i[i.QUAD = 7] = "QUAD";
      }(z || (z = {})), o(z);
      var N = i("Primitive", (x = v("cc.Primitive"), b = c(z), x((w = R = function (i) {
        function n(n) {
          var o;
          return void 0 === n && (n = z.BOX), o = i.call(this) || this, e(o, "type", I, a(o)), e(o, "info", L, a(o)), o.type = n, o;
        }

        return t(n, i), n.prototype.onLoaded = function () {
          m(A[z[this.type].toLowerCase()](this.info), this);
        }, n;
      }(p), R.PrimitiveType = z, I = r((E = w).prototype, "type", [b], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return z.BOX;
        }
      }), L = r(E.prototype, "info", [f, h], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return {};
        }
      }), y = E)) || y));
      s.Primitive = N, s.primitives = A;
    }
  };
}); 
 			}); 
		define("__plugin__/wx0446ba2621dda60a/profiler.js", function(require, module, exports){ 			
"use strict";

System.register(["./texture-barrier-60b5983b.js", "./json-asset-933a1d4c.js", "./renderable-component-7c6600ed.js", "./create-mesh-39923017.js", "./mesh-f5415e9d.js", "./mesh-renderer-fb3b7695.js"], function (t) {
  "use strict";

  var e, s, i, a, r, h, n, o, _, c, u, f, l, d, m;

  return {
    setters: [function (t) {
      e = t.bU, s = t.bT, i = t.l, a = t.aq, r = t.r, h = t.s, n = t.m, o = t.af;
    }, function (t) {
      _ = t.bW, c = t.b6, u = t.aW, f = t.b8, l = t.d7;
    }, function () {}, function (t) {
      d = t.c;
    }, function () {}, function (t) {
      m = t.M;
    }],
    execute: function execute() {
      var v,
          p = function () {
        function t(t, e, s) {
          this._id = void 0, this._opts = void 0, this._accumStart = void 0, this._total = 0, this._value = 0, this._averageValue = 0, this._accumValue = 0, this._accumSamples = 0, this._id = t, this._opts = e, this._accumStart = s;
        }

        var s = t.prototype;
        return s.sample = function (t) {
          this._average(this._value, t);
        }, s.human = function () {
          var t = this._opts,
              e = t.average,
              s = t.isInteger,
              i = e ? this._averageValue : this._value;
          return s ? Math.round(i) : Math.round(100 * i) / 100;
        }, s.alarm = function () {
          return this._opts.below && this._value < this._opts.below || this._opts.over && this._value > this._opts.over;
        }, s._average = function (t, e) {
          if (void 0 === e && (e = 0), this._opts.average) {
            this._accumValue += t, ++this._accumSamples;
            var s = e;
            s - this._accumStart >= this._opts.average && (this._averageValue = this._accumValue / this._accumSamples, this._accumValue = 0, this._accumStart = s, this._accumSamples = 0);
          }
        }, e(t, [{
          key: "value",
          get: function get() {
            return this._value;
          },
          set: function set(t) {
            this._value = t;
          }
        }]), t;
      }(),
          g = _("cc.PerfCounter")(v = function (t) {
        function e(e, s, i) {
          var a;
          return (a = t.call(this, e, s, i) || this)._time = void 0, a._time = i, a;
        }

        s(e, t);
        var i = e.prototype;
        return i.start = function (t) {
          void 0 === t && (t = 0), this._time = t;
        }, i.end = function (t) {
          void 0 === t && (t = 0), this._value = t - this._time, this._average(this._value);
        }, i.tick = function () {
          this.end(), this.start();
        }, i.frame = function (t) {
          var e = t,
              s = e - this._time;
          this._total++, s > (this._opts.average || 1e3) && (this._value = 1e3 * this._total / s, this._total = 0, this._time = e, this._average(this._value));
        }, e;
      }(p)) || v,
          E = "0123456789. ",
          w = 500,
          D = {
        0: 0,
        1: 1,
        2: 2,
        3: 3,
        4: 4,
        5: 5,
        6: 6,
        7: 7,
        8: 8,
        9: 9,
        ".": 10
      },
          T = {
        fps: {
          desc: "Framerate (FPS)",
          below: 30,
          average: w,
          isInteger: !0
        },
        draws: {
          desc: "Draw call",
          isInteger: !0
        },
        frame: {
          desc: "Frame time (ms)",
          min: 0,
          max: 50,
          average: w
        },
        instances: {
          desc: "Instance Count",
          isInteger: !0
        },
        tricount: {
          desc: "Triangle",
          isInteger: !0
        },
        logic: {
          desc: "Game Logic (ms)",
          min: 0,
          max: 50,
          average: w,
          color: "#080"
        },
        physics: {
          desc: "Physics (ms)",
          min: 0,
          max: 50,
          average: w
        },
        render: {
          desc: "Renderer (ms)",
          min: 0,
          max: 50,
          average: w,
          color: "#f90"
        },
        textureMemory: {
          desc: "GFX Texture Mem(M)"
        },
        bufferMemory: {
          desc: "GFX Buffer Mem(M)"
        }
      },
          S = t("Profiler", function () {
        function t() {
          this._stats = null, this.id = "__Profiler__", this._showFPS = !1, this._rootNode = null, this._device = null, this._swapchain = null, this._pipeline = null, this._meshRenderer = null, this._canvas = null, this._ctx = null, this._texture = null, this._region = new o(), this._canvasArr = [], this._regionArr = [this._region], this.digitsData = null, this.offsetData = null, this.pass = null, this._canvasDone = !1, this._statsDone = !1, this._inited = !1, this._lineHeight = 256 / (Object.keys(T).length + 1), this._wordHeight = 0, this._eachNumWidth = 0, this._totalLines = 0, this.lastTime = 0, this._canvas = document.createElement("canvas"), this._ctx = this._canvas.getContext("2d"), this._canvasArr.push(this._canvas);
        }

        var e = t.prototype;
        return e.reset = function () {
          this._stats = null, this._showFPS = !1, this._rootNode = null, this._device = null, this._swapchain = null, this._pipeline = null, this._meshRenderer && this._meshRenderer.destroy(), this._meshRenderer = null, this.digitsData = null, this.offsetData = null, this.pass = null, this._canvasDone = !1, this._statsDone = !1, this._inited = !1, this._lineHeight = 256 / (Object.keys(T).length + 1), this._wordHeight = 0, this._eachNumWidth = 0, this._totalLines = 0, this.lastTime = 0;
        }, e.isShowingStats = function () {
          return this._showFPS;
        }, e.hideStats = function () {
          this._showFPS && (this._rootNode && (this._rootNode.active = !1), i.director.off(i.Director.EVENT_BEFORE_UPDATE, this.beforeUpdate, this), i.director.off(i.Director.EVENT_AFTER_UPDATE, this.afterUpdate, this), i.director.off(i.Director.EVENT_BEFORE_PHYSICS, this.beforePhysics, this), i.director.off(i.Director.EVENT_AFTER_PHYSICS, this.afterPhysics, this), i.director.off(i.Director.EVENT_BEFORE_DRAW, this.beforeDraw, this), i.director.off(i.Director.EVENT_AFTER_DRAW, this.afterDraw, this), this._showFPS = !1, this._pipeline.profiler = null, i.game.config.showFPS = !1);
        }, e.showStats = function () {
          if (!this._showFPS) {
            if (!this._device) {
              var t = i.director.root;
              this._device = t.device, this._swapchain = t.mainWindow.swapchain, this._pipeline = t.pipeline;
            }

            this.generateCanvas(), this.generateStats(), i.game.once(i.Game.EVENT_ENGINE_INITED, this.generateNode, this), this._rootNode && (this._rootNode.active = !0), i.director.on(i.Director.EVENT_BEFORE_UPDATE, this.beforeUpdate, this), i.director.on(i.Director.EVENT_AFTER_UPDATE, this.afterUpdate, this), i.director.on(i.Director.EVENT_BEFORE_PHYSICS, this.beforePhysics, this), i.director.on(i.Director.EVENT_AFTER_PHYSICS, this.afterPhysics, this), i.director.on(i.Director.EVENT_BEFORE_DRAW, this.beforeDraw, this), i.director.on(i.Director.EVENT_AFTER_DRAW, this.afterDraw, this), this._showFPS = !0, this._canvasDone = !0, this._statsDone = !0, i.game.config.showFPS = !0;
          }
        }, e.generateCanvas = function () {
          if (!this._canvasDone) {
            this._ctx && this._canvas && (this._canvas.width = 256, this._canvas.height = 256, this._canvas.style.width = "" + this._canvas.width, this._canvas.style.height = "" + this._canvas.height, this._ctx.font = "23px Arial", this._ctx.textBaseline = "top", this._ctx.fillStyle = "#fff", this._texture = this._device.createTexture(new a(r.TEX2D, h.SAMPLED | h.TRANSFER_DST, n.RGBA8, 256, 256)), this._region.texExtent.width = 256, this._region.texExtent.height = 256);
          }
        }, e.generateStats = function () {
          if (!this._statsDone && this._ctx && this._canvas) {
            this._stats = null;
            var t = performance.now();
            this._ctx.textAlign = "left";
            var e = 0;

            for (var s in T) {
              var i = T[s];
              this._ctx.fillText(i.desc, 0, e * this._lineHeight), i.counter = new g(s, i, t), e++;
            }

            this._totalLines = e, this._wordHeight = this._totalLines * this._lineHeight / this._canvas.height;

            for (var a = 0; a < E.length; ++a) {
              var r = this._ctx.measureText(E[a]).width;

              this._eachNumWidth = Math.max(this._eachNumWidth, r);
            }

            for (var h = 0; h < E.length; ++h) {
              this._ctx.fillText(E[h], h * this._eachNumWidth, this._totalLines * this._lineHeight);
            }

            this._eachNumWidth /= this._canvas.width, this._stats = T, this._canvasArr[0] = this._canvas, this._device.copyTexImagesToTexture(this._canvasArr, this._texture, this._regionArr);
          }
        }, e.generateNode = function () {
          if (!this._rootNode || !this._rootNode.isValid) {
            this._rootNode = new c("PROFILER_NODE"), i.game.addPersistRootNode(this._rootNode);
            var t = new c("Profiler_Root");
            t.parent = this._rootNode;

            for (var e = .4, s = e / this._totalLines, a = e / this._wordHeight, r = s / 23, h = this._eachNumWidth * this._canvas.width * r, n = [0, e, 0, a, e, 0, a, 0, 0, 0, 0, 0], o = [0, 2, 1, 0, 3, 2], _ = [0, 0, -1, 0, 1, 0, -1, 0, 1, this._wordHeight, -1, 0, 0, this._wordHeight, -1, 0], l = 0, v = 0; v < this._totalLines; v++) {
              for (var p = 0; p < 8; p++) {
                n.push(a + p * h, e - v * s, 0), n.push(a + (p + 1) * h, e - v * s, 0), n.push(a + (p + 1) * h, e - (v + 1) * s, 0), n.push(a + p * h, e - (v + 1) * s, 0), l = 4 * (8 * v + p + 1), o.push(0 + l, 2 + l, 1 + l, 0 + l, 3 + l, 2 + l);
                var g = 8 * v + p,
                    E = Math.floor(g / 4),
                    w = g - 4 * E;
                _.push(0, this._wordHeight, E, w), _.push(this._eachNumWidth, this._wordHeight, E, w), _.push(this._eachNumWidth, 1, E, w), _.push(0, 1, E, w);
              }
            }

            this._meshRenderer = t.addComponent(m), this._meshRenderer.mesh = d({
              positions: n,
              indices: o,
              colors: _
            });
            var D = new u();
            D.initialize({
              effectName: "profiler"
            });
            var T = this.pass = D.passes[0],
                S = T.getBinding("mainTexture"),
                N = T.getBinding("digits"),
                x = T.getBinding("offset");
            T.bindTexture(S, this._texture), this.digitsData = T.blocks[N], this.offsetData = T.blocks[x], this.offsetData[3] = -1, this._meshRenderer.material = D, this._meshRenderer.node.layer = f.Enum.PROFILER, this._inited = !0;
          }
        }, e.beforeUpdate = function () {
          if (this._stats) {
            var t = performance.now();
            this._stats.frame.counter.start(t), this._stats.logic.counter.start(t);
          }
        }, e.afterUpdate = function () {
          if (this._stats) {
            var t = performance.now();
            i.director.isPaused() ? this._stats.frame.counter.start(t) : this._stats.logic.counter.end(t);
          }
        }, e.beforePhysics = function () {
          if (this._stats) {
            var t = performance.now();

            this._stats.physics.counter.start(t);
          }
        }, e.afterPhysics = function () {
          if (this._stats) {
            var t = performance.now();

            this._stats.physics.counter.end(t);
          }
        }, e.beforeDraw = function () {
          if (this._stats && this._inited) {
            var t = this._swapchain.surfaceTransform,
                e = this._device.capabilities.clipSpaceSignY;

            if (t !== this.offsetData[3]) {
              var s = l[t],
                  i = -.9 * e;
              this.offsetData[0] = -.9 * s[0] + i * s[2], this.offsetData[1] = -.9 * s[1] + i * s[3], this.offsetData[2] = this._eachNumWidth, this.offsetData[3] = t;
            }

            this.pass._setRootBufferDirty(!0), this._meshRenderer.model && (this._pipeline.profiler = this._meshRenderer.model);
            var a = performance.now();

            this._stats.render.counter.start(a);
          }
        }, e.afterDraw = function () {
          if (this._stats && this._inited) {
            var t = performance.now();

            if (this._stats.frame.counter.end(t), this._stats.fps.counter.frame(t), this._stats.render.counter.end(t), !(t - this.lastTime < w)) {
              this.lastTime = t;
              var e = this._device;
              this._stats.draws.counter.value = e.numDrawCalls, this._stats.instances.counter.value = e.numInstances, this._stats.bufferMemory.counter.value = e.memoryStatus.bufferSize / 1048576, this._stats.textureMemory.counter.value = e.memoryStatus.textureSize / 1048576, this._stats.tricount.counter.value = e.numTris;
              var s = 0,
                  i = this.digitsData;

              for (var a in this._stats) {
                var r = this._stats[a];
                r.counter.sample(t);

                for (var h = r.counter.human().toString(), n = 7; n >= 0; n--) {
                  var o = 8 * s + n,
                      _ = h[h.length - (8 - n)],
                      c = D[_];
                  void 0 === c && (c = 11), i[o] = c;
                }

                s++;
              }
            }
          }
        }, t;
      }()),
          N = t("profiler", new S());

      i.profiler = N;
    }
  };
}); 
 			}); 
		define("__plugin__/wx0446ba2621dda60a/renderable-2d-e2838949.js", function(require, module, exports){ 			
"use strict";

System.register(["./texture-barrier-60b5983b.js", "./json-asset-933a1d4c.js", "./renderable-component-7c6600ed.js", "./deprecated-26630860.js", "./deprecated-ef6bb945.js"], function (t) {
  "use strict";

  var e, i, n, r, a, s, o, h, c, l, u, d, _, f, p, g, D, y, v, E, m, S, R, A, b, k, P, x, C, T, M, w, L, N, B, O, F, H, I, z, V, U, G, W, Y, X, j, Z, q, K, Q, $, J, tt, et, it, nt, rt, at;

  return {
    setters: [function (t) {
      e = t.aC, i = t.a_, n = t.m, r = t.a$, a = t.l, s = t.P, o = t.bU, h = t.bT, c = t.bA, l = t.bW, u = t.al, d = t.o, _ = t.q, f = t.aE, p = t.R, g = t.i, D = t.c0, y = t.c1, v = t.b$, E = t.d, m = t.z, S = t.bg, R = t.E, A = t.bw, b = t.G, k = t.bh, P = t.bi;
    }, function (t) {
      x = t.a5, C = t.V, T = t.Q, M = t.Z, w = t.a3, L = t.bW, N = t.dP, B = t.cd, O = t.dR, F = t.a9, H = t.a7, I = t.bJ, z = t.cg, V = t.ds, U = t.ch, G = t.bY, W = t.cc, Y = t.bm, X = t.a1, j = t.bX, Z = t.bZ, q = t.aW, K = t.bo, Q = t.dz, $ = t.dr, J = t.dQ, tt = t.ci, et = t.de;
    }, function (t) {
      it = t.p;
    }, function (t) {
      nt = t.k;
    }, function (t) {
      rt = t.d, at = t.D;
    }],
    execute: function execute() {
      t({
        I: void 0,
        b: void 0,
        e: lt,
        g: ut
      });
      var st = t("c", [new e(i.ATTR_POSITION, n.RGB32F)]),
          ot = t("d", [new e(i.ATTR_POSITION, n.RGB32F), new e(i.ATTR_COLOR, n.RGBA32F)]),
          ht = t("f", [new e(i.ATTR_POSITION, n.RGB32F), new e(i.ATTR_TEX_COORD, n.RG32F), new e(i.ATTR_COLOR, n.RGBA32F)]),
          ct = t("h", [new e(i.ATTR_POSITION, n.RGB32F), new e(i.ATTR_TEX_COORD, n.RG32F), new e(i.ATTR_COLOR, n.RGBA32F), new e(i.ATTR_COLOR2, n.RGBA32F)]);

      function lt(t) {
        for (var e = 0, i = 0; i < t.length; i++) {
          var n = t[i];
          e += r[n.format].count;
        }

        return e;
      }

      function ut(t) {
        for (var e = 0, i = 0; i < t.length; i++) {
          var n = t[i];
          e += r[n.format].size;
        }

        return e;
      }

      a.internal.vfmtPosUvColor = ht, a.internal.vfmtPosUvTwoColor = ct, t("v", Object.freeze({
        __proto__: null,
        vfmt: st,
        vfmtPosColor: ot,
        vfmtPosUvColor: ht,
        vfmtPosUvTwoColor: ct,
        getComponentPerVertex: lt,
        getAttributeStride: ut
      }));

      var dt,
          _t,
          ft,
          pt,
          gt,
          Dt,
          yt,
          vt,
          Et,
          mt,
          St,
          Rt,
          At,
          bt,
          kt,
          Pt = ut(ht) >> 2,
          xt = new s(function () {
        return {
          x: 0,
          y: 0,
          z: 0,
          u: 0,
          v: 0,
          color: x.WHITE.clone()
        };
      }, 128),
          Ct = null,
          Tt = t("B", function () {
        function t(t) {
          void 0 === t && (t = ht), this.material = null, this.chunk = null, this.dataHash = 0, this.isMeshBuffer = !1, this._vc = 0, this._ic = 0, this._floatStride = 0, this._vertexFormat = ht, this._floatStride = t === ht ? Pt : ut(t) >> 2, this._vertexFormat = t;
        }

        return t.prototype.isValid = function () {
          return this._ic > 0 && this.chunk.vertexAccessor;
        }, o(t, [{
          key: "vertexCount",
          get: function get() {
            return this._vc;
          }
        }, {
          key: "indexCount",
          get: function get() {
            return this._ic;
          }
        }, {
          key: "stride",
          get: function get() {
            return this._floatStride << 2;
          }
        }, {
          key: "floatStride",
          get: function get() {
            return this._floatStride;
          }
        }, {
          key: "vertexFormat",
          get: function get() {
            return this._vertexFormat;
          }
        }]), t;
      }()),
          Mt = t("a", function (t) {
        function e(e, i) {
          var n;
          return void 0 === e && (e = ht), (n = t.call(this, e) || this).indices = null, n.vertDirty = !0, n.frame = void 0, n.layer = 0, n.blendHash = -1, n.textureHash = 0, n.nodeDirty = !0, n.passDirty = !0, n.textureDirty = !0, n.hashDirty = !0, n._data = [], n._pivotX = 0, n._pivotY = 0, n._width = 0, n._height = 0, n._accessor = null, i || (i = rt.root.batcher2D.switchBufferAccessor(n._vertexFormat)), n._accessor = i, n;
        }

        h(e, t), e.add = function (t, i) {
          void 0 === t && (t = ht), Ct || (Ct = new p(function () {
            return new e();
          }, 32));
          var n = Ct.add();
          return n._floatStride = t === ht ? Pt : ut(t) >> 2, n._vertexFormat = t, i || (i = rt.root.batcher2D.switchBufferAccessor(n._vertexFormat)), n._accessor = i, n;
        }, e.remove = function (t) {
          var e = Ct.data.indexOf(t);
          -1 !== e && (t.clear(), t._accessor = null, Ct.removeAt(e));
        };
        var i = e.prototype;
        return i.resize = function (t, e) {
          t === this._vc && e === this._ic && this.chunk || (this._vc = t, this._ic = e, this.chunk && (this._accessor.recycleChunk(this.chunk), this.chunk = null), this.chunk = this._accessor.allocateChunk(t, e), this.updateHash());
        }, i.resizeAndCopy = function (t, e) {
          if (t !== this._vc || e !== this._ic || !this.chunk) {
            this._vc = t, this._ic = e;
            var i = this.chunk;
            this.chunk = this._accessor.allocateChunk(t, e), i && (this.chunk.vb.set(i.vb), this._accessor.recycleChunk(i)), this.updateHash();
          }
        }, i.getMeshBuffer = function () {
          return this.chunk && this._accessor ? this._accessor.getMeshBuffer(this.chunk.bufferId) : null;
        }, i.updateNode = function (t) {
          this.layer = t.node.layer, this.nodeDirty = !1, this.hashDirty = !0;
        }, i.updatePass = function (t) {
          this.material = t.getRenderMaterial(0), this.blendHash = t.blendHash, this.passDirty = !1, this.hashDirty = !0;
        }, i.updateTexture = function (t) {
          this.frame = t, this.textureHash = t.getHash(), this.textureDirty = !1, this.hashDirty = !0;
        }, i.updateHash = function () {
          var t = "" + (this.chunk ? this.chunk.bufferId : -1) + this.layer + " " + this.blendHash + " " + this.textureHash;
          this.dataHash = c(t, 666), this.hashDirty = !1;
        }, i.updateRenderData = function (t, e) {
          if (this.passDirty && (this.material = t.getRenderMaterial(0), this.blendHash = t.blendHash, this.passDirty = !1, this.hashDirty = !0), this.nodeDirty) {
            var i = t.node.scene ? t._getRenderScene() : null;
            this.layer = t.node.layer, null !== i && (this.nodeDirty = !1), this.hashDirty = !0;
          }

          this.textureDirty && (this.frame = e, this.textureHash = e.getHash(), this.textureDirty = !1, this.hashDirty = !0), this.hashDirty && this.updateHash();
        }, i.updateSizeNPivot = function (t, e, i, n) {
          t === this._width && e === this._height && i === this._pivotX && n === this._pivotY || (this._width = t, this._height = e, this._pivotX = i, this._pivotY = n, this.vertDirty = !0);
        }, i.clear = function () {
          this.resize(0, 0), this._data.length = 0, this._pivotX = 0, this._pivotY = 0, this._width = 0, this._height = 0, this.indices = null, this.vertDirty = !0, this.material = null, this.nodeDirty = !0, this.passDirty = !0, this.textureDirty = !0, this.hashDirty = !0, this.layer = 0, this.blendHash = -1, this.frame = null, this.textureHash = 0, this.dataHash = 0;
        }, o(e, [{
          key: "dataLength",
          get: function get() {
            return this._data.length;
          },
          set: function set(t) {
            var e = this._data;

            if (e.length !== t) {
              var i = e.length,
                  n = 0;

              for (n = t; n < i; n++) {
                xt.free(e[n]);
              }

              for (n = i; n < t; n++) {
                e[n] = xt.alloc();
              }

              e.length = t;
            }
          }
        }, {
          key: "data",
          get: function get() {
            return this._data;
          }
        }]), e;
      }(Tt)),
          wt = t("M", function (t) {
        function e(e) {
          var i;
          return void 0 === e && (e = ht), (i = t.call(this, e) || this).isMeshBuffer = !0, i.vData = void 0, i.iData = void 0, i.vertexStart = 0, i.vertexRange = 0, i.indexStart = 0, i.indexRange = 0, i.lastFilledIndex = 0, i.lastFilledVertex = 0, i._byteLength = 0, i._vertexBuffers = [], i._indexBuffer = null, i._iaPool = null, i._iaInfo = null, i.vData = new Float32Array(256 * i.stride), i.iData = new Uint16Array(1536), i;
        }

        h(e, t), e.add = function (t) {
          void 0 === t && (t = ht);
          var e = Lt.add();
          return e._floatStride = t === ht ? Pt : ut(t) >> 2, e._vertexFormat = t, e;
        }, e.remove = function (t) {
          var e = Lt.data.indexOf(t);
          -1 !== e && (Lt.data[e].clear(), Lt.removeAt(e));
        };
        var i = e.prototype;
        return i.request = function (t, e) {
          var i = this._byteLength + t * this.stride;
          return !!this.reserve(t, e) && (this._vc += t, this._ic += e, this._byteLength = i, this.vertexRange = this._vc, this.indexRange = this._ic, !0);
        }, i.reserve = function (t, e) {
          var i = this._byteLength + t * this.stride,
              n = this.indexCount + e;
          if (t + this.vertexCount > 65535) return !1;
          var r = this.vData.byteLength,
              a = this.iData.length,
              s = this.vData.length,
              o = this.iData.length;

          if (i > r || n > a) {
            for (; r < i || a < n;) {
              r = 4 * (s *= 2), a = o *= 2;
            }

            this._reallocBuffer(s, o);
          }

          return !0;
        }, i.resize = function (t, e) {
          var i = t * this.stride;
          l(t >= 0 && e >= 0 && i <= this.vData.byteLength && e <= this.iData.length), this._vc = t, this._ic = e, this._byteLength = i, this.updateRange(0, t, 0, e);
        }, i.updateRange = function (t, e, i, n) {
          l(e >= 0 && n >= 0 && e <= this._vc && n <= this._ic), this.vertexStart = t, this.indexStart = i, this.vertexRange = e, this.indexRange = n;
        }, i.requestIA = function (t) {
          this._initIAInfo(t);

          var e = this._iaPool.add();

          return e.firstIndex = this.indexStart, e.indexCount = this.indexRange, e;
        }, i.uploadBuffers = function () {
          if (0 !== this._byteLength && this._vertexBuffers[0] && this._indexBuffer) {
            var t = this._ic,
                e = new Float32Array(this.vData.buffer, 0, this._byteLength >> 2),
                i = new Uint16Array(this.iData.buffer, 0, t),
                n = this._vertexBuffers[0];
            this._byteLength > n.size && n.resize(this._byteLength), n.update(e);
            var r = t << 1;
            r > this._indexBuffer.size && this._indexBuffer.resize(r), this._indexBuffer.update(i);
          }
        }, i.freeIAPool = function () {
          this._iaPool && this._iaPool.reset();
        }, i.reset = function () {
          this._vc = 0, this._ic = 0, this._byteLength = 0, this.vertexStart = 0, this.vertexRange = 0, this.indexStart = 0, this.indexRange = 0, this.lastFilledIndex = 0, this.lastFilledVertex = 0, this.material = null, this.freeIAPool();
        }, i.clear = function () {
          this.reset(), this._iaPool && this._iaPool.destroy(), this._vertexBuffers[0] && (this._vertexBuffers[0].destroy(), this._vertexBuffers = []), this._iaInfo = null, this.vData = new Float32Array(256 * this.stride), this.iData = new Uint16Array(1536);
        }, i._initIAInfo = function (t) {
          var e = this;

          if (!this._iaInfo) {
            var i = this.stride,
                n = this._vertexBuffers;
            n.length || n.push(t.createBuffer(new u(d.VERTEX | d.TRANSFER_DST, _.DEVICE, i, i)));
            var r = Uint16Array.BYTES_PER_ELEMENT;
            this._indexBuffer || (this._indexBuffer = t.createBuffer(new u(d.INDEX | d.TRANSFER_DST, _.DEVICE, r, r))), this._iaInfo = new f(this._vertexFormat, n, this._indexBuffer), this._iaPool = new p(function () {
              return t.createInputAssembler(e._iaInfo);
            }, 1, function (t) {
              t.destroy();
            });
          }
        }, i._reallocBuffer = function (t, e) {
          var i = this.vData;
          this.vData = new Float32Array(t), i && this.vData.set(i, 0);
          var n = this.iData;
          this.iData = new Uint16Array(e), n && this.iData.set(n, 0);
        }, o(e, [{
          key: "formatByte",
          get: function get() {
            return this.stride;
          },
          set: function set() {}
        }, {
          key: "floatStride",
          get: function get() {
            return this._floatStride;
          }
        }, {
          key: "vDataOffset",
          get: function get() {
            return this._byteLength >>> 2;
          }
        }]), e;
      }(Tt)),
          Lt = new p(function () {
        return new wt();
      }, 32),
          Nt = new C(),
          Bt = new C(),
          Ot = new T(),
          Ft = new M(),
          Ht = new M(),
          It = new M(),
          zt = new M(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
          Vt = new w(),
          Ut = t("U", (dt = L("cc.UITransform"), _t = z(), ft = V(110), pt = U(), gt = G(), Dt = W(), yt = G(), vt = W(), dt(Et = _t(Et = ft(Et = pt(Et = N(Et = B((bt = At = function (t) {
        function e() {
          for (var e, i = arguments.length, n = new Array(i), r = 0; r < i; r++) {
            n[r] = arguments[r];
          }

          return (e = t.call.apply(t, [this].concat(n)) || this)._priority = 0, y(e, "_contentSize", St, v(e)), y(e, "_anchorPoint", Rt, v(e)), e;
        }

        h(e, t);
        var i = e.prototype;
        return i.__preload = function () {
          this.node._uiProps.uiTransformComp = this;
        }, i.onLoad = function () {
          this.node.parent && e.insertChangeMap(this.node.parent);
        }, i.onEnable = function () {
          this.node.on(O.PARENT_CHANGED, this._parentChanged, this), this._markRenderDataDirty();
        }, i.onDisable = function () {
          this.node.off(O.PARENT_CHANGED, this._parentChanged, this);
        }, i.onDestroy = function () {
          this.node._uiProps.uiTransformComp = null;
        }, i.setContentSize = function (t, e) {
          var i = this._contentSize;

          if (void 0 === e) {
            if (F((t = t).width, i.width, H) && F(t.height, i.height, H)) return;
            i.width = t.width, i.height = t.height;
          } else {
            if (F(t = t, i.width, H) && F(e, i.height, H)) return;
            i.width = t, i.height = e;
          }

          this.node.emit(O.SIZE_CHANGED), this._markRenderDataDirty();
        }, i.setAnchorPoint = function (t, e) {
          var i = this._anchorPoint;

          if (void 0 === e) {
            if ((t = t).x === i.x && t.y === i.y) return;
            i.x = t.x, i.y = t.y;
          } else {
            if (t === i.x && e === i.y) return;
            i.x = t, i.y = e;
          }

          this.node.emit(O.ANCHOR_CHANGED, this._anchorPoint), this._markRenderDataDirty();
        }, i.isHit = function (t) {
          for (var e = this._contentSize.width, i = this._contentSize.height, n = Nt, r = Bt, a = this._getRenderScene().cameras, s = 0; s < a.length; s++) {
            var o = a[s];

            if (o.visibility & this.node.layer) {
              o.node.getWorldRT(Ft);
              var h = Ft.m12,
                  c = Ft.m13,
                  l = nt.center;

              if (Ft.m12 = l.x - (Ft.m00 * h + Ft.m04 * c), Ft.m13 = l.y - (Ft.m01 * h + Ft.m05 * c), M.invert(Ft, Ft), C.transformMat4(n, t, Ft), this.node.getWorldMatrix(It), M.invert(Ft, It), !M.strictEquals(Ft, zt)) {
                C.transformMat4(r, n, Ft), r.x += this._anchorPoint.x * e, r.y += this._anchorPoint.y * i;
                var u = !1;
                if (r.x >= 0 && r.y >= 0 && r.x <= e && r.y <= i && (u = this._maskTest(n)), u) return !0;
              }
            }
          }

          return !1;
        }, i.hitTest = function (t) {
          for (var e = this._contentSize.width, i = this._contentSize.height, n = Ot, r = Nt, a = Bt, s = this._getRenderScene().cameras, o = 0; o < s.length; o++) {
            var h = s[o];

            if (h.visibility & this.node.layer && (T.set(n, t.x, t.y, 0), h.screenToWorld(n, n), C.set(r, n.x, n.y), this.node.getWorldMatrix(It), M.invert(Ft, It), !M.strictEquals(Ft, zt))) {
              C.transformMat4(a, r, Ft), a.x += this._anchorPoint.x * e, a.y += this._anchorPoint.y * i;
              var c = !1;
              if (a.x >= 0 && a.y >= 0 && a.x <= e && a.y <= i && (c = this._maskTest(r)), c) return !0;
            }
          }

          return !1;
        }, i._maskTest = function (t) {
          var e,
              i,
              n = null === (e = this.node) || void 0 === e || null === (i = e.eventProcessor) || void 0 === i ? void 0 : i.maskList;
          if (n) for (var r = this.node, a = n.length, s = 0, o = 0; r && o < a; ++s, r = r.parent) {
            var h = n[o];

            if (s === h.index) {
              if (r !== h.comp.node) {
                n.length = o;
                break;
              }

              var c = h.comp;
              if (c && c._enabled && !c.isHit(t)) return !1;
              o++;
            } else if (s > h.index) {
              n.length = o;
              break;
            }
          }
          return !0;
        }, i.convertToNodeSpaceAR = function (t, e) {
          return this.node.getWorldMatrix(It), M.invert(Ft, It), e || (e = new T()), T.transformMat4(e, t, Ft);
        }, i.convertToWorldSpaceAR = function (t, e) {
          return this.node.getWorldMatrix(It), e || (e = new T()), T.transformMat4(e, t, It);
        }, i.getBoundingBox = function () {
          M.fromRTS(Ht, this.node.getRotation(), this.node.getPosition(), this.node.getScale());
          var t = this._contentSize.width,
              e = this._contentSize.height,
              i = new w(-this._anchorPoint.x * t, -this._anchorPoint.y * e, t, e);
          return i.transformMat4(Ht), i;
        }, i.getBoundingBoxToWorld = function () {
          return this.node.parent ? (this.node.parent.getWorldMatrix(It), this.getBoundingBoxTo(It)) : this.getBoundingBox();
        }, i.getBoundingBoxTo = function (t) {
          M.fromRTS(Ht, this.node.getRotation(), this.node.getPosition(), this.node.getScale());
          var i = this._contentSize.width,
              n = this._contentSize.height,
              r = new w(-this._anchorPoint.x * i, -this._anchorPoint.y * n, i, n);
          if (M.multiply(It, t, Ht), r.transformMat4(It), !this.node.children) return r;

          for (var a, s = this.node.children, o = g(s); !(a = o()).done;) {
            var h = a.value;

            if (h && h.active) {
              var c = h.getComponent(e);

              if (c) {
                var l = c.getBoundingBoxTo(t);
                l && w.union(r, r, l);
              }
            }
          }

          return r;
        }, i.getComputeAABB = function (t) {
          var e = this._contentSize.width,
              i = this._contentSize.height;
          Vt.set(-this._anchorPoint.x * e, -this._anchorPoint.y * i, e, i), Vt.transformMat4(this.node.worldMatrix);
          var n = Vt.x + .5 * Vt.width,
              r = Vt.y + .5 * Vt.height,
              a = this.node.worldPosition.z,
              s = Vt.width / 2,
              o = Vt.height / 2;
          return null != t ? (I.set(t, n, r, a, s, o, .001), t) : new I(n, r, a, s, o, .001);
        }, i._parentChanged = function () {
          this.node.getComponent("cc.RenderRoot2D") || this.node.parent && e.insertChangeMap(this.node.parent);
        }, i._markRenderDataDirty = function () {
          var t = this.node._uiProps.uiComp;
          t && (t.markForUpdateRenderData(), t.renderData && (t.renderData.vertDirty = !0));
        }, e.insertChangeMap = function (t) {
          var i = t.uuid;
          e.priorityChangeNodeMap.has(i) || e.priorityChangeNodeMap.set(i, t);
        }, e._sortChildrenSibling = function (t) {
          var e = t.children;
          e && e.sort(function (t, e) {
            var i = t._uiProps.uiTransformComp,
                n = e._uiProps.uiTransformComp,
                r = (i ? i._priority : 0) - (n ? n._priority : 0);
            return 0 === r ? t.getSiblingIndex() - e.getSiblingIndex() : r;
          });
        }, e._sortSiblings = function () {
          e.priorityChangeNodeMap.forEach(function (t) {
            e._sortChildrenSibling(t), t._updateSiblingIndex(), t.emit("childrenSiblingOrderChanged");
          }), e.priorityChangeNodeMap.clear();
        }, e._cleanChangeMap = function () {
          e.priorityChangeNodeMap.clear();
        }, o(e, [{
          key: "contentSize",
          get: function get() {
            return this._contentSize;
          },
          set: function set(t) {
            this._contentSize.equals(t) || (this._contentSize.set(t), this.node.emit(O.SIZE_CHANGED), this._markRenderDataDirty());
          }
        }, {
          key: "width",
          get: function get() {
            return this._contentSize.width;
          },
          set: function set(t) {
            this._contentSize.width !== t && (this._contentSize.width = t, this.node.emit(O.SIZE_CHANGED), this._markRenderDataDirty());
          }
        }, {
          key: "height",
          get: function get() {
            return this._contentSize.height;
          },
          set: function set(t) {
            this.contentSize.height !== t && (this._contentSize.height = t, this.node.emit(O.SIZE_CHANGED), this._markRenderDataDirty());
          }
        }, {
          key: "anchorPoint",
          get: function get() {
            return this._anchorPoint;
          },
          set: function set(t) {
            this._anchorPoint.equals(t) || (this._anchorPoint.set(t), this.node.emit(O.ANCHOR_CHANGED, this._anchorPoint), this._markRenderDataDirty());
          }
        }, {
          key: "anchorX",
          get: function get() {
            return this._anchorPoint.x;
          },
          set: function set(t) {
            this._anchorPoint.x !== t && (this._anchorPoint.x = t, this.node.emit(O.ANCHOR_CHANGED, this._anchorPoint), this._markRenderDataDirty());
          }
        }, {
          key: "anchorY",
          get: function get() {
            return this._anchorPoint.y;
          },
          set: function set(t) {
            this._anchorPoint.y !== t && (this._anchorPoint.y = t, this.node.emit(O.ANCHOR_CHANGED, this._anchorPoint), this._markRenderDataDirty());
          }
        }, {
          key: "priority",
          get: function get() {
            return this._priority;
          },
          set: function set(t) {
            this._priority !== t && (this.node.getComponent("cc.RenderRoot2D") ? E(6706) : (this._priority = t, this.node.parent && e.insertChangeMap(this.node.parent)));
          }
        }, {
          key: "visibility",
          get: function get() {
            var t = rt.root.batcher2D.getFirstRenderCamera(this.node);
            return t ? t.visibility : 0;
          }
        }, {
          key: "cameraPriority",
          get: function get() {
            var t = rt.root.batcher2D.getFirstRenderCamera(this.node);
            return t ? t.priority : 0;
          }
        }]), e;
      }(Y), At.EventType = O, At.priorityChangeNodeMap = new Map(), D((mt = bt).prototype, "contentSize", [gt, Dt], Object.getOwnPropertyDescriptor(mt.prototype, "contentSize"), mt.prototype), D(mt.prototype, "anchorPoint", [yt, vt], Object.getOwnPropertyDescriptor(mt.prototype, "anchorPoint"), mt.prototype), St = D(mt.prototype, "_contentSize", [j], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return new X(100, 100);
        }
      }), Rt = D(mt.prototype, "_anchorPoint", [j], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return new C(.5, .5);
        }
      }), Et = mt)) || Et) || Et) || Et) || Et) || Et) || Et));

      rt.on(at.EVENT_AFTER_UPDATE, Ut._sortSiblings), rt.on(at.EVENT_BEFORE_SCENE_LAUNCH, Ut._cleanChangeMap), function (t) {
        t[t.DISABLED = 0] = "DISABLED", t[t.CLEAR = 1] = "CLEAR", t[t.ENTER_LEVEL = 2] = "ENTER_LEVEL", t[t.ENABLED = 3] = "ENABLED", t[t.EXIT_LEVEL = 4] = "EXIT_LEVEL", t[t.CLEAR_INVERTED = 5] = "CLEAR_INVERTED", t[t.ENTER_LEVEL_INVERTED = 6] = "ENTER_LEVEL_INVERTED";
      }(kt || (kt = t("b", {})));
      var Gt,
          Wt,
          Yt,
          Xt,
          jt,
          Zt,
          qt,
          Kt,
          Qt,
          $t,
          Jt,
          te,
          ee,
          ie,
          ne,
          re,
          ae,
          se,
          oe,
          he,
          ce = t("S", function () {
        function t() {
          this.stage = kt.DISABLED, this._maskStack = [], this._stencilPattern = {
            stencilTest: !0,
            func: m.ALWAYS,
            stencilMask: 65535,
            writeMask: 65535,
            failOp: R.KEEP,
            zFailOp: R.KEEP,
            passOp: R.KEEP,
            ref: 1
          }, this.stencilStateMap = new Map(), this.stencilStateMapWithDepth = new Map();
        }

        var e = t.prototype;
        return e.pushMask = function (t) {
          this._maskStack.push(t);
        }, e.clear = function (t) {
          t.stencilStage = t.inverted ? kt.CLEAR_INVERTED : kt.CLEAR;
        }, e.enterLevel = function (t) {
          t.graphics.stencilStage = t.inverted ? kt.ENTER_LEVEL_INVERTED : kt.ENTER_LEVEL;
        }, e.enableMask = function () {
          this.stage = kt.ENABLED;
        }, e.exitMask = function () {
          0 !== this._maskStack.length && (this._maskStack.pop(), 0 === this._maskStack.length ? this.stage = kt.DISABLED : this.stage = kt.ENABLED);
        }, e.getWriteMask = function () {
          return 1 << this._maskStack.length - 1;
        }, e.getExitWriteMask = function () {
          return 1 << this._maskStack.length;
        }, e.getStencilRef = function () {
          for (var t = 0, e = 0; e < this._maskStack.length; ++e) {
            t += 1 << e;
          }

          return t;
        }, e.reset = function () {
          this._maskStack.length = 0, this.stage = kt.DISABLED;
        }, e.destroy = function () {
          this.stencilStateMap.forEach(function (t) {
            t.destroy();
          }), this.stencilStateMap.clear();
        }, e.getStencilStage = function (t, e) {
          var i = 0,
              n = !1,
              r = !1,
              a = m.LESS,
              s = this.stencilStateMap;

          if (e && e.passes[0]) {
            var o = e.passes[0].depthStencilState,
                h = 0,
                c = 0;
            o.depthTest && (h = 1), o.depthWrite && (c = 1), i = h | c << 1 | o.depthFunc << 2 | t << 6 | this._maskStack.length << 9, n = o.depthTest, r = o.depthWrite, a = o.depthFunc, s = this.stencilStateMapWithDepth;
          } else i = t << 16 | this._maskStack.length;

          if (s && s.has(i)) return s.get(i);
          this.setStateFromStage(t);
          var l = new S(n, r, a, this._stencilPattern.stencilTest, this._stencilPattern.func, this._stencilPattern.stencilMask, this._stencilPattern.writeMask, this._stencilPattern.failOp, this._stencilPattern.zFailOp, this._stencilPattern.passOp, this._stencilPattern.ref, this._stencilPattern.stencilTest, this._stencilPattern.func, this._stencilPattern.stencilMask, this._stencilPattern.writeMask, this._stencilPattern.failOp, this._stencilPattern.zFailOp, this._stencilPattern.passOp, this._stencilPattern.ref);
          return s.set(i, l), l;
        }, e.getStencilHash = function (t) {
          return t << 8 | this._maskStack.length;
        }, e.setStateFromStage = function (t) {
          var e = this._stencilPattern;
          t === kt.DISABLED ? (e.stencilTest = !1, e.func = m.ALWAYS, e.failOp = R.KEEP, e.stencilMask = e.writeMask = 65535, e.ref = 1) : (e.stencilTest = !0, t === kt.ENABLED ? (e.func = m.EQUAL, e.failOp = R.KEEP, e.stencilMask = e.ref = this.getStencilRef(), e.writeMask = this.getWriteMask()) : t === kt.CLEAR ? (e.func = m.NEVER, e.failOp = R.ZERO, e.writeMask = e.stencilMask = e.ref = this.getWriteMask()) : t === kt.CLEAR_INVERTED || t === kt.ENTER_LEVEL ? (e.func = m.NEVER, e.failOp = R.REPLACE, e.writeMask = e.stencilMask = e.ref = this.getWriteMask()) : t === kt.ENTER_LEVEL_INVERTED && (e.func = m.NEVER, e.failOp = R.ZERO, e.writeMask = e.stencilMask = e.ref = this.getWriteMask()));
        }, o(t, [{
          key: "pattern",
          get: function get() {
            return this._stencilPattern;
          }
        }]), t;
      }());
      ce.sharedManager = null, ce.sharedManager = new ce(), A(b), function (t) {
        t[t.ADD_COLOR = 0] = "ADD_COLOR", t[t.ADD_COLOR_AND_TEXTURE = 1] = "ADD_COLOR_AND_TEXTURE", t[t.GRAYSCALE = 2] = "GRAYSCALE", t[t.USE_ALPHA_SEPARATED = 3] = "USE_ALPHA_SEPARATED", t[t.USE_ALPHA_SEPARATED_AND_GRAY = 4] = "USE_ALPHA_SEPARATED_AND_GRAY";
      }(he || (he = t("I", {})));
      var le = t("R", (Gt = L("cc.Renderable2D"), Wt = J(Ut), Yt = tt(), Xt = Z(q), jt = Z(q), Zt = G(), qt = W(), Kt = et(), Qt = G(), $t = W(), Gt(Jt = Wt(Jt = N(Jt = B((oe = se = function (t) {
        function e() {
          for (var e, i = arguments.length, n = new Array(i), r = 0; r < i; r++) {
            n[r] = arguments[r];
          }

          return e = t.call.apply(t, [this].concat(n)) || this, y(e, "_materials", ee, v(e)), y(e, "_customMaterial", ie, v(e)), e.stencilStage = kt.DISABLED, y(e, "_srcBlendFactor", ne, v(e)), y(e, "_dstBlendFactor", re, v(e)), y(e, "_color", ae, v(e)), e._assembler = null, e._postAssembler = null, e._renderData = null, e._renderDataFlag = !0, e._renderFlag = !0, e._delegateSrc = null, e._instanceMaterialType = -1, e._blendState = new P(), e._blendHash = 0, e._useVertexOpacity = !1, e._lastParent = null, e;
        }

        h(e, t);
        var i = e.prototype;
        return i.updateBlendHash = function () {
          var t = this._blendState.targets[0].blendDst << 4;
          this._blendHash = t | this._blendState.targets[0].blendSrc;
        }, i.__preload = function () {
          this.node._uiProps.uiComp = this, this._flushAssembler && this._flushAssembler();
        }, i.onEnable = function () {
          this.node.on(O.ANCHOR_CHANGED, this._nodeStateChange, this), this.node.on(O.SIZE_CHANGED, this._nodeStateChange, this), this.node.on(O.PARENT_CHANGED, this._colorDirty, this), this.updateMaterial(), this._renderFlag = this._canRender(), this._colorDirty();
        }, i.onRestore = function () {
          this.updateMaterial(), this.markForUpdateRenderData();
        }, i.onDisable = function () {
          this.node.off(O.ANCHOR_CHANGED, this._nodeStateChange, this), this.node.off(O.SIZE_CHANGED, this._nodeStateChange, this), this.node.off(O.PARENT_CHANGED, this._colorDirty, this), this._renderFlag = !1;
        }, i.onDestroy = function () {
          if (this.node._uiProps.uiComp === this && (this.node._uiProps.uiComp = null), this.destroyRenderData(), this._materialInstances) for (var t = 0; t < this._materialInstances.length; t++) {
            var e = this._materialInstances[t];
            e && e.destroy();
          }
          this._blendState && this._blendState.destroy();
        }, i.markForUpdateRenderData = function (t) {
          if (void 0 === t && (t = !0), this._renderFlag = this._canRender(), t) {
            var e = this._renderData;
            e && (e.vertDirty = !0), this._renderDataFlag = t;
          } else this._renderDataFlag = t;
        }, i.requestRenderData = function () {
          var t = Mt.add();
          return this._renderData = t, t;
        }, i.destroyRenderData = function () {
          this._renderData && (Mt.remove(this._renderData), this._renderData = null);
        }, i.updateAssembler = function (t) {
          this._renderDataFlag && (this._assembler.updateRenderData(this, t), this._renderDataFlag = !1), this._renderFlag && this._render(t);
        }, i.postUpdateAssembler = function (t) {
          this._postAssembler && this._renderFlag && this._postRender(t);
        }, i._render = function () {}, i._postRender = function () {}, i._canRender = function () {
          return this.isValid && null !== this.getMaterial(0) && this.enabled && (this._delegateSrc ? this._delegateSrc.activeInHierarchy : this.enabledInHierarchy) && this._color.a > 0;
        }, i._postCanRender = function () {}, i.updateMaterial = function () {
          if (this._customMaterial) return this.setMaterial(this._customMaterial, 0), this._renderData && (this._renderData.material = this._customMaterial, this.markForUpdateRenderData(), this._renderData.passDirty = !0), void (this._blendHash = -1);

          var t = this._updateBuiltinMaterial();

          this.setMaterial(t, 0), this._renderData && (this._renderData.material = t, this.markForUpdateRenderData()), this._updateBlendFunc();
        }, i._updateColor = function () {
          this.node._uiProps.colorDirty = !0, this._assembler && (this._assembler.updateColor(this), this._renderFlag = this._canRender());
        }, i._updateBlendFunc = function () {
          var t = this._blendState.targets[0];
          t || (t = new k(), this._blendState.setTarget(0, t)), t.blendDst === this._dstBlendFactor && t.blendSrc === this._srcBlendFactor || (t.blend = !0, t.blendDstAlpha = b.ONE_MINUS_SRC_ALPHA, t.blendDst = this._dstBlendFactor, t.blendSrc = this._srcBlendFactor, this.renderData && (this.renderData.passDirty = !0)), this.updateBlendHash();
        }, i.getBlendState = function () {
          return this._blendState;
        }, i._nodeStateChange = function () {
          this._renderData && this.markForUpdateRenderData();

          for (var t = 0; t < this.node.children.length; ++t) {
            var i = this.node.children[t].getComponent(e);
            i && i.markForUpdateRenderData();
          }
        }, i._colorDirty = function () {
          this.node._uiProps.colorDirty = !0;
        }, i._onMaterialModified = function (e, i) {
          this._renderData && (this.markForUpdateRenderData(), this._renderData.passDirty = !0), t.prototype._onMaterialModified.call(this, e, i);
        }, i._updateBuiltinMaterial = function () {
          var t;

          switch (this._instanceMaterialType) {
            case he.ADD_COLOR:
              t = K.get("ui-base-material");
              break;

            case he.GRAYSCALE:
              t = K.get("ui-sprite-gray-material");
              break;

            case he.USE_ALPHA_SEPARATED:
              t = K.get("ui-sprite-alpha-sep-material");
              break;

            case he.USE_ALPHA_SEPARATED_AND_GRAY:
              t = K.get("ui-sprite-gray-alpha-sep-material");
              break;

            default:
              t = K.get("ui-sprite-material");
          }

          return t;
        }, i.setNodeDirty = function () {
          this.renderData && (this.renderData.nodeDirty = !0);
        }, i.setTextureDirty = function () {
          this.renderData && (this.renderData.textureDirty = !0);
        }, o(e, [{
          key: "sharedMaterials",
          get: function get() {
            return this._materials;
          },
          set: function set(t) {
            for (var e = 0; e < t.length; e++) {
              t[e] !== this._materials[e] && this.setMaterial(t[e], e);
            }

            if (t.length < this._materials.length) {
              for (var i = t.length; i < this._materials.length; i++) {
                this.setMaterial(null, i);
              }

              this._materials.splice(t.length);
            }
          }
        }, {
          key: "customMaterial",
          get: function get() {
            return this._customMaterial;
          },
          set: function set(t) {
            this._customMaterial = t, this.updateMaterial();
          }
        }, {
          key: "color",
          get: function get() {
            return this._color;
          },
          set: function set(t) {
            this._color.equals(t) || (this._color.set(t), this._updateColor());
          }
        }, {
          key: "renderData",
          get: function get() {
            return this._renderData;
          }
        }, {
          key: "delegateSrc",
          set: function set(t) {
            this._delegateSrc = t;
          }
        }, {
          key: "blendHash",
          get: function get() {
            return this._blendHash;
          }
        }, {
          key: "useVertexOpacity",
          get: function get() {
            return this._useVertexOpacity;
          }
        }]), e;
      }(it), se.BlendState = b, se.Assembler = null, se.PostAssembler = null, ee = D((te = oe).prototype, "_materials", [Q], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return [];
        }
      }), D(te.prototype, "sharedMaterials", [Q, Yt], Object.getOwnPropertyDescriptor(te.prototype, "sharedMaterials"), te.prototype), ie = D(te.prototype, "_customMaterial", [Xt], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return null;
        }
      }), D(te.prototype, "customMaterial", [jt, Zt, qt, Kt, $], Object.getOwnPropertyDescriptor(te.prototype, "customMaterial"), te.prototype), D(te.prototype, "color", [Qt, $t], Object.getOwnPropertyDescriptor(te.prototype, "color"), te.prototype), ne = D(te.prototype, "_srcBlendFactor", [j], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return b.SRC_ALPHA;
        }
      }), re = D(te.prototype, "_dstBlendFactor", [j], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return b.ONE_MINUS_SRC_ALPHA;
        }
      }), ae = D(te.prototype, "_color", [j], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return x.WHITE.clone();
        }
      }), Jt = te)) || Jt) || Jt) || Jt) || Jt));
      a.internal.Renderable2D = le;
    }
  };
}); 
 			}); 
		define("__plugin__/wx0446ba2621dda60a/renderable-component-7c6600ed.js", function(require, module, exports){ 			
"use strict";

System.register(["./texture-barrier-60b5983b.js", "./json-asset-933a1d4c.js"], function (t) {
  "use strict";

  var e, i, n, s, r, a, o, h, u, _, c, l, d, f, p, m, g, w, y, v, S, b, D, I, M, k, A, R, T, L, E, P, B, F, x, N, C, O, V, z, U, j, H, W, G, Y, Z, K, Q, X, q, $, J, tt, et, it, nt, st, rt, at, ot, ht, ut, _t, ct, lt, dt;

  return {
    setters: [function (t) {
      e = t.a5, i = t.k, n = t.l, s = t.bU, r = t.ah, a = t.d, o = t.aq, h = t.r, u = t.s, _ = t.m, c = t.as, l = t.x, d = t.y, f = t.aP, p = t.f, m = t.F, g = t.a$, w = t.aC, y = t.b8, v = t.al, S = t.o, b = t.q, D = t.bT, I = t.i, M = t.bL, k = t.af, A = t.c0, R = t.c1, T = t.b$;
    }, function (t) {
      L = t.Q, E = t.Z, P = t.cj, B = t.d7, F = t.cf, x = t.ac, N = t.ad, C = t.a3, O = t.bL, V = t.B, z = t.d8, U = t.b4, j = t.d9, H = t.da, W = t.b8, G = t.c5, Y = t.bJ, Z = t.T, K = t.bo, Q = t.db, X = t.dc, q = t.dd, $ = t.ce, J = t.A, tt = t.P, et = t.i, it = t.W, nt = t.ay, st = t.ax, rt = t.x, at = t.bW, ot = t.bZ, ht = t.aW, ut = t.M, _t = t.bY, ct = t.de, lt = t.bm, dt = t.bX;
    }],
    execute: function execute() {
      var ft, pt, mt, gt, wt;
      t({
        C: void 0,
        L: void 0,
        M: void 0,
        P: void 0,
        a: void 0,
        b: void 0,
        c: void 0,
        d: void 0,
        h: Nt,
        l: void 0,
        m: qt
      }), function (t) {
        t[t.VERTICAL = 0] = "VERTICAL", t[t.HORIZONTAL = 1] = "HORIZONTAL";
      }(ft || (ft = t("C", {}))), function (t) {
        t[t.ORTHO = 0] = "ORTHO", t[t.PERSPECTIVE = 1] = "PERSPECTIVE";
      }(pt || (pt = t("a", {}))), function (t) {
        t[t.F1_8 = 0] = "F1_8", t[t.F2_0 = 1] = "F2_0", t[t.F2_2 = 2] = "F2_2", t[t.F2_5 = 3] = "F2_5", t[t.F2_8 = 4] = "F2_8", t[t.F3_2 = 5] = "F3_2", t[t.F3_5 = 6] = "F3_5", t[t.F4_0 = 7] = "F4_0", t[t.F4_5 = 8] = "F4_5", t[t.F5_0 = 9] = "F5_0", t[t.F5_6 = 10] = "F5_6", t[t.F6_3 = 11] = "F6_3", t[t.F7_1 = 12] = "F7_1", t[t.F8_0 = 13] = "F8_0", t[t.F9_0 = 14] = "F9_0", t[t.F10_0 = 15] = "F10_0", t[t.F11_0 = 16] = "F11_0", t[t.F13_0 = 17] = "F13_0", t[t.F14_0 = 18] = "F14_0", t[t.F16_0 = 19] = "F16_0", t[t.F18_0 = 20] = "F18_0", t[t.F20_0 = 21] = "F20_0", t[t.F22_0 = 22] = "F22_0";
      }(mt || (mt = t("b", {}))), function (t) {
        t[t.ISO100 = 0] = "ISO100", t[t.ISO200 = 1] = "ISO200", t[t.ISO400 = 2] = "ISO400", t[t.ISO800 = 3] = "ISO800";
      }(gt || (gt = t("c", {}))), function (t) {
        t[t.D1 = 0] = "D1", t[t.D2 = 1] = "D2", t[t.D4 = 2] = "D4", t[t.D8 = 3] = "D8", t[t.D15 = 4] = "D15", t[t.D30 = 5] = "D30", t[t.D60 = 6] = "D60", t[t.D125 = 7] = "D125", t[t.D250 = 8] = "D250", t[t.D500 = 9] = "D500", t[t.D1000 = 10] = "D1000", t[t.D2000 = 11] = "D2000", t[t.D4000 = 12] = "D4000";
      }(wt || (wt = t("d", {})));
      var yt,
          vt = [1.8, 2, 2.2, 2.5, 2.8, 3.2, 3.5, 4, 4.5, 5, 5.6, 6.3, 7.1, 8, 9, 10, 11, 13, 14, 16, 18, 20, 22],
          St = [1, .5, 1 / 4, 1 / 8, 1 / 15, 1 / 30, 1 / 60, .008, .004, .002, .001, 5e-4, 1 / 4e3],
          bt = [100, 200, 400, 800],
          Dt = new L(),
          It = new L(),
          Mt = new E(),
          kt = (t("S", e.STENCIL << 1), []),
          At = t("e", function () {
        function t(t) {
          if (this.isWindowSize = !0, this.screenScale = void 0, this._device = void 0, this._scene = null, this._node = null, this._name = null, this._enabled = !1, this._proj = -1, this._aspect = void 0, this._orthoHeight = 10, this._fovAxis = ft.VERTICAL, this._fov = N(45), this._nearClip = 1, this._farClip = 1e3, this._clearColor = new r(.2, .2, .2, 1), this._viewport = new C(0, 0, 1, 1), this._orientedViewport = new C(0, 0, 1, 1), this._curTransform = i.IDENTITY, this._isProjDirty = !0, this._matView = new E(), this._matProj = new E(), this._matProjInv = new E(), this._matViewProj = new E(), this._matViewProjInv = new E(), this._frustum = new O(), this._forward = new L(), this._position = new L(), this._priority = 0, this._aperture = mt.F16_0, this._apertureValue = void 0, this._shutter = wt.D125, this._shutterValue = 0, this._iso = gt.ISO100, this._isoValue = 0, this._window = null, this._width = 1, this._height = 1, this._clearFlag = e.NONE, this._clearDepth = 1, this._visibility = P, this._exposure = 0, this._clearStencil = 0, this._device = t, this._apertureValue = vt[this._aperture], this._shutterValue = St[this._shutter], this._isoValue = bt[this._iso], this._aspect = this.screenScale = 1, this._frustum.accurate = !0, !kt.length) {
            var n = t.capabilities.clipSpaceSignY;
            kt[i.IDENTITY] = new E(1, 0, 0, 0, 0, n), kt[i.ROTATE_90] = new E(0, 1, 0, 0, -n, 0), kt[i.ROTATE_180] = new E(-1, 0, 0, 0, 0, -n), kt[i.ROTATE_270] = new E(0, -1, 0, 0, n, 0);
          }
        }

        var o = t.prototype;
        return o._setWidth = function (t) {
          this._width = t;
        }, o._setHeight = function (t) {
          this._height = t;
        }, o._setScene = function (t) {
          this._scene = t;
        }, o._updateAspect = function (t) {
          if (void 0 === t && (t = !0), this._aspect = this.window.width * this._viewport.width / (this.window.height * this._viewport.height), t) {
            var e = this.window.swapchain;
            (e && e.surfaceTransform || i.IDENTITY) % 2 && (this._aspect = 1 / this._aspect);
          }

          this._isProjDirty = !0;
        }, o._init = function () {}, o._destroy = function () {}, o.initialize = function (t) {
          this._init(t), this.node = t.node, this._setWidth(1), this._setHeight(1), this.clearFlag = e.NONE, this.clearDepth = 1, this.visibility = P, this._name = t.name, this._proj = t.projection, this._priority = t.priority || 0, this._aspect = this.screenScale = 1, this.updateExposure(), this.changeTargetWindow(t.window);
        }, o.destroy = function () {
          this._window && (this._window.detachCamera(this), this.window = null), this._name = null, this._destroy();
        }, o.attachToScene = function (t) {
          this._enabled = !0, this._setScene(t);
        }, o.detachFromScene = function () {
          this._enabled = !1, this._setScene(null);
        }, o.resize = function (t, e) {
          this._window && (this._setWidth(t), this._setHeight(e), this._updateAspect());
        }, o.setFixedSize = function (t, e) {
          this._setWidth(t), this._setHeight(e), this._updateAspect(!1), this.isWindowSize = !1;
        }, o.syncCameraEditor = function () {}, o.update = function (t) {
          var e;

          if (void 0 === t && (t = !1), this._node) {
            var n = !1;
            (this._node.hasChangedFlags || t) && (E.invert(this._matView, this._node.worldMatrix), this._forward.x = -this._matView.m02, this._forward.y = -this._matView.m06, this._forward.z = -this._matView.m10, this._node.getWorldPosition(this._position), n = !0);
            var s = null === (e = this.window) || void 0 === e ? void 0 : e.swapchain,
                r = s && s.surfaceTransform || i.IDENTITY;

            if (this._isProjDirty || this._curTransform !== r) {
              this._curTransform = r;
              var a = this._device.capabilities.clipSpaceSignY;
              if (this._proj === pt.PERSPECTIVE) E.perspective(this._matProj, this._fov, this._aspect, this._nearClip, this._farClip, this._fovAxis === ft.VERTICAL, this._device.capabilities.clipSpaceMinZ, a, r);else {
                var o = this._orthoHeight * this._aspect,
                    h = this._orthoHeight;
                E.ortho(this._matProj, -o, o, -h, h, this._nearClip, this._farClip, this._device.capabilities.clipSpaceMinZ, a, r);
              }
              E.invert(this._matProjInv, this._matProj), n = !0, this._isProjDirty = !1;
            }

            n && (E.multiply(this._matViewProj, this._matProj, this._matView), E.invert(this._matViewProjInv, this._matViewProj), this._frustum.update(this._matViewProj, this._matViewProjInv));
          }
        }, o.setViewportInOrientedSpace = function (t) {
          var e,
              n = t.x,
              s = t.width,
              r = t.height,
              a = this._device.capabilities.screenSpaceSignY < 0 ? 1 - t.y - r : t.y,
              o = null === (e = this.window) || void 0 === e ? void 0 : e.swapchain;

          switch (o && o.surfaceTransform || i.IDENTITY) {
            case i.ROTATE_90:
              this._viewport.x = 1 - a - r, this._viewport.y = n, this._viewport.width = r, this._viewport.height = s;
              break;

            case i.ROTATE_180:
              this._viewport.x = 1 - n - s, this._viewport.y = 1 - a - r, this._viewport.width = s, this._viewport.height = r;
              break;

            case i.ROTATE_270:
              this._viewport.x = a, this._viewport.y = 1 - n - s, this._viewport.width = r, this._viewport.height = s;
              break;

            case i.IDENTITY:
              this._viewport.x = n, this._viewport.y = a, this._viewport.width = s, this._viewport.height = r;
          }

          this._orientedViewport.x = n, this._orientedViewport.y = a, this._orientedViewport.width = s, this._orientedViewport.height = r, this.resize(this.width, this.height);
        }, o.changeTargetWindow = function (t) {
          void 0 === t && (t = null), this._window && this._window.detachCamera(this);
          var e = t || n.director.root.mainWindow;

          if (e) {
            e.attachCamera(this), this.window = e;
            var s = e.swapchain;
            (s && s.surfaceTransform || i.IDENTITY) % 2 ? this.resize(e.height, e.width) : this.resize(e.width, e.height);
          }
        }, o.detachCamera = function () {
          this._window && this._window.detachCamera(this);
        }, o.screenPointToRay = function (t, e, i) {
          if (!this._node) return null;
          var n = this.width,
              s = this.height,
              r = this._orientedViewport.x * n,
              a = this._orientedViewport.y * s,
              o = this._orientedViewport.width * n,
              h = this._orientedViewport.height * s,
              u = this._proj === pt.PERSPECTIVE,
              _ = this._device.capabilities.clipSpaceSignY,
              c = B[this._curTransform];
          L.set(Dt, (e - r) / o * 2 - 1, (i - a) / h * 2 - 1, u ? 1 : -1);
          var l = Dt.x,
              d = Dt.y;
          return Dt.x = l * c[0] + d * c[2] * _, Dt.y = l * c[1] + d * c[3] * _, L.transformMat4(u ? Dt : t.o, Dt, this._matViewProjInv), u ? (this._node.getWorldPosition(It), F.fromPoints(t, It, Dt)) : L.transformQuat(t.d, L.FORWARD, this._node.worldRotation), t;
        }, o.screenToWorld = function (t, e) {
          var i = this.width,
              n = this.height,
              s = this._orientedViewport.x * i,
              r = this._orientedViewport.y * n,
              a = this._orientedViewport.width * i,
              o = this._orientedViewport.height * n,
              h = this._device.capabilities.clipSpaceSignY,
              u = B[this._curTransform];

          if (this._proj === pt.PERSPECTIVE) {
            L.set(t, (e.x - s) / a * 2 - 1, (e.y - r) / o * 2 - 1, 1);
            var _ = t.x,
                c = t.y;
            t.x = _ * u[0] + c * u[2] * h, t.y = _ * u[1] + c * u[3] * h, L.transformMat4(t, t, this._matViewProjInv), this._node && this._node.getWorldPosition(Dt), L.lerp(t, Dt, t, x(this._nearClip / this._farClip, 1, e.z));
          } else {
            L.set(t, (e.x - s) / a * 2 - 1, (e.y - r) / o * 2 - 1, 2 * e.z - 1);
            var l = t.x,
                d = t.y;
            t.x = l * u[0] + d * u[2] * h, t.y = l * u[1] + d * u[3] * h, L.transformMat4(t, t, this._matViewProjInv);
          }

          return t;
        }, o.worldToScreen = function (t, e) {
          var i = this._device.capabilities.clipSpaceSignY,
              n = B[this._curTransform];
          L.transformMat4(t, e, this._matViewProj);
          var s = t.x,
              r = t.y;
          t.x = s * n[0] + r * n[2] * i, t.y = s * n[1] + r * n[3] * i;

          var a = this.width,
              o = this.height,
              h = this._orientedViewport.x * a,
              u = this._orientedViewport.y * o,
              _ = this._orientedViewport.width * a,
              c = this._orientedViewport.height * o;

          return t.x = h + .5 * (t.x + 1) * _, t.y = u + .5 * (t.y + 1) * c, t.z = .5 * t.z + .5, t;
        }, o.worldMatrixToScreen = function (t, e, i, n) {
          E.multiply(t, this._matViewProj, e), E.multiply(t, kt[this._curTransform], t);
          var s = i / 2,
              r = n / 2;
          return E.identity(Mt), E.transform(Mt, Mt, L.set(Dt, s, r, 0)), E.scale(Mt, Mt, L.set(Dt, s, r, 1)), E.multiply(t, Mt, t), t;
        }, o.setExposure = function (t) {
          this._exposure = .833333 / Math.pow(2, t);
        }, o.updateExposure = function () {
          var t = Math.log2(this._apertureValue * this._apertureValue / this._shutterValue * 100 / this._isoValue);
          this.setExposure(t);
        }, s(t, [{
          key: "name",
          get: function get() {
            return this._name;
          }
        }, {
          key: "scene",
          get: function get() {
            return this._scene;
          }
        }, {
          key: "node",
          get: function get() {
            return this._node;
          },
          set: function set(t) {
            this._node = t;
          }
        }, {
          key: "window",
          get: function get() {
            return this._window;
          },
          set: function set(t) {
            this._window = t;
          }
        }, {
          key: "enabled",
          get: function get() {
            return this._enabled;
          },
          set: function set(t) {
            this._enabled = t;
          }
        }, {
          key: "visibility",
          get: function get() {
            return this._visibility;
          },
          set: function set(t) {
            this._visibility = t;
          }
        }, {
          key: "priority",
          get: function get() {
            return this._priority;
          },
          set: function set(t) {
            this._priority = t;
          }
        }, {
          key: "width",
          get: function get() {
            return this._width;
          }
        }, {
          key: "height",
          get: function get() {
            return this._height;
          }
        }, {
          key: "position",
          get: function get() {
            return this._position;
          },
          set: function set(t) {
            this._position = t;
          }
        }, {
          key: "forward",
          get: function get() {
            return this._forward;
          },
          set: function set(t) {
            this._forward = t;
          }
        }, {
          key: "aperture",
          get: function get() {
            return this._aperture;
          },
          set: function set(t) {
            this._aperture = t, this._apertureValue = vt[this._aperture], this.updateExposure();
          }
        }, {
          key: "apertureValue",
          get: function get() {
            return this._apertureValue;
          }
        }, {
          key: "shutter",
          get: function get() {
            return this._shutter;
          },
          set: function set(t) {
            this._shutter = t, this._shutterValue = St[this._shutter], this.updateExposure();
          }
        }, {
          key: "shutterValue",
          get: function get() {
            return this._shutterValue;
          }
        }, {
          key: "iso",
          get: function get() {
            return this._iso;
          },
          set: function set(t) {
            this._iso = t, this._isoValue = bt[this._iso], this.updateExposure();
          }
        }, {
          key: "isoValue",
          get: function get() {
            return this._isoValue;
          }
        }, {
          key: "exposure",
          get: function get() {
            return this._exposure;
          }
        }, {
          key: "clearFlag",
          get: function get() {
            return this._clearFlag;
          },
          set: function set(t) {
            this._clearFlag = t;
          }
        }, {
          key: "clearColor",
          get: function get() {
            return this._clearColor;
          },
          set: function set(t) {
            this._clearColor.x = t.x, this._clearColor.y = t.y, this._clearColor.z = t.z, this._clearColor.w = t.w;
          }
        }, {
          key: "clearDepth",
          get: function get() {
            return this._clearDepth;
          },
          set: function set(t) {
            this._clearDepth = t;
          }
        }, {
          key: "clearStencil",
          get: function get() {
            return this._clearStencil;
          },
          set: function set(t) {
            this._clearStencil = t;
          }
        }, {
          key: "projectionType",
          get: function get() {
            return this._proj;
          },
          set: function set(t) {
            this._proj = t, this._isProjDirty = !0;
          }
        }, {
          key: "aspect",
          get: function get() {
            return this._aspect;
          }
        }, {
          key: "orthoHeight",
          get: function get() {
            return this._orthoHeight;
          },
          set: function set(t) {
            this._orthoHeight = t, this._isProjDirty = !0;
          }
        }, {
          key: "fovAxis",
          get: function get() {
            return this._fovAxis;
          },
          set: function set(t) {
            this._fovAxis = t, this._isProjDirty = !0;
          }
        }, {
          key: "fov",
          get: function get() {
            return this._fov;
          },
          set: function set(t) {
            this._fov = t, this._isProjDirty = !0;
          }
        }, {
          key: "nearClip",
          get: function get() {
            return this._nearClip;
          },
          set: function set(t) {
            this._nearClip = t, this._isProjDirty = !0;
          }
        }, {
          key: "farClip",
          get: function get() {
            return this._farClip;
          },
          set: function set(t) {
            this._farClip = t, this._isProjDirty = !0;
          }
        }, {
          key: "viewport",
          get: function get() {
            return this._viewport;
          },
          set: function set(t) {
            a(8302), this.setViewportInOrientedSpace(t);
          }
        }, {
          key: "frustum",
          get: function get() {
            return this._frustum;
          },
          set: function set(t) {
            this._frustum = t;
          }
        }, {
          key: "matView",
          get: function get() {
            return this._matView;
          }
        }, {
          key: "matProj",
          get: function get() {
            return this._matProj;
          }
        }, {
          key: "matProjInv",
          get: function get() {
            return this._matProjInv;
          }
        }, {
          key: "matViewProj",
          get: function get() {
            return this._matViewProj;
          }
        }, {
          key: "matViewProjInv",
          get: function get() {
            return this._matViewProjInv;
          }
        }, {
          key: "native",
          get: function get() {
            return this._nativeObj;
          }
        }], [{
          key: "standardExposureValue",
          get: function get() {
            return 1 / 38400;
          }
        }, {
          key: "standardLightMeterScale",
          get: function get() {
            return 1e4;
          }
        }]), t;
      }()),
          Rt = new f(null),
          Tt = t("g", function () {
        function t() {
          this._device = null, this._passes = null, this._shaders = null, this._subMesh = null, this._patches = null, this._priority = z.DEFAULT, this._inputAssembler = null, this._descriptorSet = null, this._worldBoundDescriptorSet = null, this._planarInstanceShader = null, this._planarShader = null, this._reflectionTex = null, this._reflectionSampler = null;
        }

        var e = t.prototype;
        return e._destroyDescriptorSet = function () {
          this._descriptorSet.destroy(), this._descriptorSet = null;
        }, e._destroyWorldBoundDescriptorSet = function () {
          this._worldBoundDescriptorSet.destroy(), this._worldBoundDescriptorSet = null;
        }, e._destroyInputAssembler = function () {
          this._inputAssembler.destroy(), this._inputAssembler = null;
        }, e._createDescriptorSet = function (t) {
          this._descriptorSet = this._device.createDescriptorSet(t);
        }, e._createWorldBoundDescriptorSet = function (t) {
          this._worldBoundDescriptorSet = this._device.createDescriptorSet(t);
        }, e._setInputAssembler = function (t) {
          this._inputAssembler = this._device.createInputAssembler(t);
        }, e._setSubMesh = function (t) {
          this._subMesh = t;
        }, e._init = function () {}, e.initialize = function (t, e, i) {
          void 0 === i && (i = null);
          var s = n.director.root;
          this._device = s.device, Rt.layout = e[0].localSetLayout, this._init(), this._setInputAssembler(t.iaInfo), this._createDescriptorSet(Rt);
          var r = n.director.root.pipeline.pipelineSceneData.getOcclusionQueryPass(),
              a = new f(null);

          if (a.layout = r.localSetLayout, this._createWorldBoundDescriptorSet(a), this._setSubMesh(t), this._patches = i, this._passes = e, this._flushPassInfo(), e[0].batchingScheme === V.VB_MERGING && (this.subMesh.genFlatBuffers(), this._setSubMesh(this.subMesh)), this.priority = z.DEFAULT, e[0].phase === U("reflection")) {
            var p = s.mainWindow.width,
                m = s.mainWindow.height,
                g = 512;
            m < p ? (p = g * p / m, m = g) : m = g * m / (p = g), this._reflectionTex = this._device.createTexture(new o(h.TEX2D, u.STORAGE | u.TRANSFER_SRC | u.SAMPLED, _.RGBA8, p, m)), this.descriptorSet.bindTexture(j, this._reflectionTex), this._reflectionSampler = this._device.getSampler(new c(l.LINEAR, l.LINEAR, l.NONE, d.CLAMP, d.CLAMP, d.CLAMP)), this.descriptorSet.bindSampler(j, this._reflectionSampler), this.descriptorSet.bindTexture(H, this._reflectionTex);
          }
        }, e._initNativePlanarShadowShader = function (t) {
          this._planarShader = t.getPlanarShader(this._patches);
        }, e.initPlanarShadowShader = function () {
          var t = n.director.root.pipeline.pipelineSceneData.shadows;

          this._initNativePlanarShadowShader(t);
        }, e._initNativePlanarShadowInstanceShader = function (t) {
          this._planarInstanceShader = t.getPlanarInstanceShader(this._patches);
        }, e.initPlanarShadowInstanceShader = function () {
          var t = n.director.root.pipeline.pipelineSceneData.shadows;

          this._initNativePlanarShadowInstanceShader(t);
        }, e._destroy = function () {}, e.destroy = function () {
          this._destroyDescriptorSet(), this._destroyWorldBoundDescriptorSet(), this._destroyInputAssembler(), this.priority = z.DEFAULT, this._patches = null, this._subMesh = null, this._passes = null, this._shaders = null, this._reflectionTex && this._reflectionTex.destroy(), this._reflectionTex = null, this._reflectionSampler = null, this._destroy();
        }, e.update = function () {
          for (var t = 0; t < this._passes.length; ++t) {
            this._passes[t].update();
          }

          this._descriptorSet.update(), this._worldBoundDescriptorSet.update();
        }, e.onPipelineStateChanged = function () {
          var t = this._passes;

          if (t) {
            for (var e = 0; e < t.length; e++) {
              var i = t[e];
              i.beginChangeStatesSilently(), i.tryCompile(), i.endChangeStatesSilently();
            }

            this._flushPassInfo();
          }
        }, e.onMacroPatchesStateChanged = function (t) {
          this._patches = t;
          var e = this._passes;

          if (e) {
            for (var i = 0; i < e.length; i++) {
              var n = e[i];
              n.beginChangeStatesSilently(), n.tryCompile(), n.endChangeStatesSilently();
            }

            this._flushPassInfo();
          }
        }, e._flushPassInfo = function () {
          var t = this._passes;

          if (t) {
            this._shaders || (this._shaders = []), this._shaders.length = t.length;

            for (var e = 0, i = t.length; e < i; e++) {
              this._shaders[e] = t[e].getShaderVariant(this.patches);
            }
          }
        }, s(t, [{
          key: "passes",
          get: function get() {
            return this._passes;
          },
          set: function set(t) {
            t.length > 8 ? p(12004, 8) : (this._passes = t, this._flushPassInfo(), this._passes[0].batchingScheme === V.VB_MERGING && (this.subMesh.genFlatBuffers(), this._setSubMesh(this.subMesh)), this._descriptorSet && (this._destroyDescriptorSet(), Rt.layout = t[0].localSetLayout, this._createDescriptorSet(Rt)));
          }
        }, {
          key: "shaders",
          get: function get() {
            return this._shaders;
          }
        }, {
          key: "subMesh",
          get: function get() {
            return this._subMesh;
          },
          set: function set(t) {
            this._inputAssembler.destroy(), this._inputAssembler.initialize(t.iaInfo), this._passes[0].batchingScheme === V.VB_MERGING && this.subMesh.genFlatBuffers(), this._setSubMesh(t);
          }
        }, {
          key: "priority",
          get: function get() {
            return this._priority;
          },
          set: function set(t) {
            this._priority = t;
          }
        }, {
          key: "inputAssembler",
          get: function get() {
            return this._inputAssembler;
          }
        }, {
          key: "descriptorSet",
          get: function get() {
            return this._descriptorSet;
          }
        }, {
          key: "worldBoundDescriptorSet",
          get: function get() {
            return this._worldBoundDescriptorSet;
          }
        }, {
          key: "patches",
          get: function get() {
            return this._patches;
          }
        }, {
          key: "planarInstanceShader",
          get: function get() {
            return this._planarInstanceShader;
          }
        }, {
          key: "planarShader",
          get: function get() {
            return this._planarShader;
          }
        }, {
          key: "native",
          get: function get() {
            return this._nativeObj;
          }
        }]), t;
      }()),
          Lt = new E(),
          Et = [{
        name: "CC_RECEIVE_SHADOW",
        value: !0
      }],
          Pt = [{
        name: "CC_USE_LIGHTMAP",
        value: !0
      }];
      !function (t) {
        t[t.DEFAULT = 0] = "DEFAULT", t[t.SKINNING = 1] = "SKINNING", t[t.BAKED_SKINNING = 2] = "BAKED_SKINNING", t[t.BATCH_2D = 3] = "BATCH_2D", t[t.PARTICLE_BATCH = 4] = "PARTICLE_BATCH", t[t.LINE = 5] = "LINE";
      }(yt || (yt = t("M", {})));
      var Bt,
          Ft = new c(l.LINEAR, l.LINEAR, l.NONE, d.CLAMP, d.CLAMP, d.CLAMP),
          xt = new c(l.LINEAR, l.LINEAR, l.LINEAR, d.CLAMP, d.CLAMP, d.CLAMP);

      function Nt(t, e) {
        e < 1e3 ? e = 1e3 : e > 15e3 && (e = 15e3);
        var i = e * e,
            n = (.860117757 + .000154118254 * e + 1.28641212e-7 * i) / (1 + .000842420235 * e + 7.08145163e-7 * i),
            s = (.317398726 + 422806245e-13 * e + 4.20481691e-8 * i) / (1 - 289741816e-13 * e + 1.61456053e-7 * i),
            r = 2 * n - 8 * s + 4,
            a = 3 * n / r,
            o = 2 * s / r,
            h = 1 / o * a,
            u = 1 / o * (1 - a - o);
        t.x = 3.2404542 * h - 1.5371385 + -.4985314 * u, t.y = -.969266 * h + 1.8760108 + .041556 * u, t.z = .0556434 * h - .2040259 + 1.0572252 * u;
      }

      t("f", function () {
        function t() {
          this.type = yt.DEFAULT, this.scene = null, this.isDynamicBatching = !1, this.instancedAttributes = {
            buffer: null,
            views: [],
            attributes: []
          }, this._worldBounds = null, this._modelBounds = null, this._subModels = [], this._node = null, this._transform = null, this._device = void 0, this._inited = !1, this._descriptorSetCount = 1, this._updateStamp = -1, this._localDataUpdated = !0, this._localData = new Float32Array(G.COUNT), this._localBuffer = null, this._instMatWorldIdx = -1, this._lightmap = null, this._lightmapUVParam = new Z(), this._worldBoundBuffer = null, this._receiveShadow = !1, this._castShadow = !1, this._shadowBias = 0, this._shadowNormalBias = 0, this._enabled = !0, this._visFlags = W.Enum.NONE, this._device = n.director.root.device;
        }

        var e = t.prototype;
        return e._setReceiveShadow = function (t) {
          this._receiveShadow = t;
        }, e._init = function () {}, e.initialize = function () {
          this._inited || (this._init(), this._setReceiveShadow(!0), this.castShadow = !1, this.enabled = !0, this.visFlags = W.Enum.NONE, this._inited = !0);
        }, e._destroySubmodel = function (t) {
          t.destroy();
        }, e._destroy = function () {}, e.destroy = function () {
          for (var t = this._subModels, e = 0; e < t.length; e++) {
            var i = this._subModels[e];

            this._destroySubmodel(i);
          }

          this._localBuffer && (this._localBuffer.destroy(), this._localBuffer = null), this._worldBoundBuffer && (this._worldBoundBuffer.destroy(), this._worldBoundBuffer = null), this._worldBounds = null, this._modelBounds = null, this._subModels.length = 0, this._inited = !1, this._localDataUpdated = !0, this._transform = null, this._node = null, this.isDynamicBatching = !1, this._destroy();
        }, e.attachToScene = function (t) {
          this.scene = t, this._localDataUpdated = !0;
        }, e.detachFromScene = function () {
          this.scene = null;
        }, e.updateTransform = function () {
          var t = this.transform;

          if (t.hasChangedFlags || t._dirtyFlags) {
            t.updateWorldTransform(), this._localDataUpdated = !0;
            var e = this._worldBounds;
            this._modelBounds && e && this._modelBounds.transform(t._mat, t._pos, t._rot, t._scale, e);
          }
        }, e.updateWorldBound = function () {
          var t = this.transform;

          if (null !== t) {
            t.updateWorldTransform(), this._localDataUpdated = !0;
            var e = this._worldBounds;
            this._modelBounds && e && this._modelBounds.transform(t._mat, t._pos, t._rot, t._scale, e);
          }
        }, e._applyLocalData = function () {}, e._applyLocalBuffer = function () {}, e._applyWorldBoundBuffer = function () {}, e.updateUBOs = function (t) {
          for (var e = this._subModels, i = 0; i < e.length; i++) {
            e[i].update();
          }

          if (this._updateStamp = t, this._localDataUpdated) {
            this._localDataUpdated = !1;
            var n,
                s,
                r,
                a,
                o = this.transform._mat,
                h = this._instMatWorldIdx;

            if (h >= 0) {
              var u = this.instancedAttributes.views;
              n = o, s = u[h], r = u[h + 1], a = u[h + 2], s[0] = n.m00, s[1] = n.m01, s[2] = n.m02, s[3] = n.m12, r[0] = n.m04, r[1] = n.m05, r[2] = n.m06, r[3] = n.m13, a[0] = n.m08, a[1] = n.m09, a[2] = n.m10, a[3] = n.m14;
            } else if (this._localBuffer) {
              E.toArray(this._localData, o, G.MAT_WORLD_OFFSET), E.inverseTranspose(Lt, o);

              var _ = Math.abs(E.determinant(Lt)),
                  c = 1 / Math.sqrt(_);

              E.multiplyScalar(Lt, Lt, c), E.toArray(this._localData, Lt, G.MAT_WORLD_IT_OFFSET), this._localBuffer.update(this._localData), this._applyLocalData(), this._applyLocalBuffer();
            }
          }
        }, e._updateNativeBounds = function () {}, e.createBoundingShape = function (t, e) {
          t && e && (this._modelBounds = Y.fromPoints(Y.create(), t, e), this._worldBounds = Y.clone(this._modelBounds), this._updateNativeBounds());
        }, e._createSubModel = function () {
          return new Tt();
        }, e.initSubModel = function (t, e, i) {
          this.initialize(), null == this._subModels[t] ? this._subModels[t] = this._createSubModel() : this._subModels[t].destroy(), this._subModels[t].initialize(e, i.passes, this.getMacroPatches(t)), this._subModels[t].initPlanarShadowShader(), this._subModels[t].initPlanarShadowInstanceShader(), this._updateAttributesAndBinding(t);
        }, e.setSubModelMesh = function (t, e) {
          this._subModels[t] && (this._subModels[t].subMesh = e);
        }, e.setSubModelMaterial = function (t, e) {
          this._subModels[t] && (this._subModels[t].passes = e.passes, this._updateAttributesAndBinding(t));
        }, e.onGlobalPipelineStateChanged = function () {
          for (var t = this._subModels, e = 0; e < t.length; e++) {
            t[e].onPipelineStateChanged();
          }
        }, e.onMacroPatchesStateChanged = function () {
          for (var t = this._subModels, e = 0; e < t.length; e++) {
            t[e].onMacroPatchesStateChanged(this.getMacroPatches(e));
          }
        }, e.updateLightingmap = function (t, e) {
          Z.toArray(this._localData, e, G.LIGHTINGMAP_UVPARAM), this._localDataUpdated = !0, this._lightmap = t, this._lightmapUVParam = e, this.onMacroPatchesStateChanged(), null === t && (t = K.get("empty-texture"));
          var i = t.getGFXTexture();
          if (i) for (var n = this._device.getSampler(t.mipmaps.length > 1 ? xt : Ft), s = this._subModels, r = 0; r < s.length; r++) {
            var a = s[r].descriptorSet;
            a.bindTexture(Q, i), a.bindSampler(Q, n), a.update();
          }
        }, e.updateLocalShadowBias = function () {
          var t = this._localData;
          t[G.LOCAL_SHADOW_BIAS + 0] = this._shadowBias, t[G.LOCAL_SHADOW_BIAS + 1] = this._shadowNormalBias, t[G.LOCAL_SHADOW_BIAS + 2] = 0, t[G.LOCAL_SHADOW_BIAS + 3] = 0, this._localDataUpdated = !0;
        }, e.getMacroPatches = function () {
          var t = this.receiveShadow ? Et : null;
          return null != this._lightmap && (t = t ? t.concat(Pt) : Pt), t;
        }, e._updateAttributesAndBinding = function (t) {
          var e = this._subModels[t];

          if (e) {
            this._initLocalDescriptors(t), this._updateLocalDescriptors(t, e.descriptorSet), this._initWorldBoundDescriptors(t), this._updateWorldBoundDescriptors(t, e.worldBoundDescriptorSet);
            var i = e.passes[0].getShaderVariant(e.patches);

            this._updateInstancedAttributes(i.attributes, e.passes[0]);
          }
        }, e._getInstancedAttributeIndex = function (t) {
          for (var e = this.instancedAttributes.attributes, i = 0; i < e.length; i++) {
            if (e[i].name === t) return i;
          }

          return -1;
        }, e._setInstMatWorldIdx = function (t) {
          this._instMatWorldIdx = t;
        }, e._updateInstancedAttributes = function (t, e) {
          if (e.device.hasFeature(m.INSTANCED_ARRAYS)) {
            for (var i = 0, n = 0; n < t.length; n++) {
              var s = t[n];
              s.isInstanced && (i += g[s.format].size);
            }

            var r = this.instancedAttributes;
            r.buffer = new Uint8Array(i), r.views.length = r.attributes.length = 0;

            for (var a = 0, o = 0; o < t.length; o++) {
              var h = t[o];

              if (h.isInstanced) {
                var u = new w();
                u.format = h.format, u.name = h.name, u.isNormalized = h.isNormalized, u.location = h.location, r.attributes.push(u);
                var _ = g[h.format],
                    c = new (y(_))(r.buffer.buffer, a, _.count);
                r.views.push(c), a += _.size;
              }
            }

            e.batchingScheme === V.INSTANCING && e.getInstancedBuffer().destroy(), this._setInstMatWorldIdx(this._getInstancedAttributeIndex(X)), this._localDataUpdated = !0;
          }
        }, e._initLocalDescriptors = function () {
          this._localBuffer || (this._localBuffer = this._device.createBuffer(new v(S.UNIFORM | S.TRANSFER_DST, b.DEVICE, G.SIZE, G.SIZE)), this._applyLocalBuffer());
        }, e._initWorldBoundDescriptors = function () {
          this._worldBoundBuffer || (this._worldBoundBuffer = this._device.createBuffer(new v(S.UNIFORM | S.TRANSFER_DST, b.DEVICE, q.SIZE, q.SIZE)), this._applyWorldBoundBuffer());
        }, e._updateLocalDescriptors = function (t, e) {
          this._localBuffer && e.bindBuffer(G.BINDING, this._localBuffer);
        }, e._updateWorldBoundDescriptors = function (t, e) {
          this._worldBoundBuffer && e.bindBuffer(q.BINDING, this._worldBoundBuffer);
        }, s(t, [{
          key: "subModels",
          get: function get() {
            return this._subModels;
          }
        }, {
          key: "inited",
          get: function get() {
            return this._inited;
          }
        }, {
          key: "worldBounds",
          get: function get() {
            return this._worldBounds;
          }
        }, {
          key: "modelBounds",
          get: function get() {
            return this._modelBounds;
          }
        }, {
          key: "localBuffer",
          get: function get() {
            return this._localBuffer;
          }
        }, {
          key: "worldBoundBuffer",
          get: function get() {
            return this._worldBoundBuffer;
          }
        }, {
          key: "updateStamp",
          get: function get() {
            return this._updateStamp;
          }
        }, {
          key: "isInstancingEnabled",
          get: function get() {
            return this._instMatWorldIdx >= 0;
          }
        }, {
          key: "shadowBias",
          get: function get() {
            return this._shadowBias;
          },
          set: function set(t) {
            this._shadowBias = t;
          }
        }, {
          key: "shadowNormalBias",
          get: function get() {
            return this._shadowNormalBias;
          },
          set: function set(t) {
            this._shadowNormalBias = t;
          }
        }, {
          key: "receiveShadow",
          get: function get() {
            return this._receiveShadow;
          },
          set: function set(t) {
            this._setReceiveShadow(t), this.onMacroPatchesStateChanged();
          }
        }, {
          key: "castShadow",
          get: function get() {
            return this._castShadow;
          },
          set: function set(t) {
            this._castShadow = t;
          }
        }, {
          key: "node",
          get: function get() {
            return this._node;
          },
          set: function set(t) {
            this._node = t;
          }
        }, {
          key: "transform",
          get: function get() {
            return this._transform;
          },
          set: function set(t) {
            this._transform = t;
          }
        }, {
          key: "visFlags",
          get: function get() {
            return this._visFlags;
          },
          set: function set(t) {
            this._visFlags = t;
          }
        }, {
          key: "enabled",
          get: function get() {
            return this._enabled;
          },
          set: function set(t) {
            this._enabled = t;
          }
        }, {
          key: "native",
          get: function get() {
            return this._nativeObj;
          }
        }]), t;
      }()), t("O", function () {
        function t() {
          this._enabled = !1, this._minPos = new L(0, 0, 0), this._maxPos = new L(0, 0, 0), this._depth = 0;
        }

        var e = t.prototype;
        return e.initialize = function (t) {
          this._enabled = t.enabled, this._minPos = t.minPos, this._maxPos = t.maxPos, this._depth = t.depth;
        }, e._destroy = function () {}, e.destroy = function () {
          this._destroy();
        }, s(t, [{
          key: "enabled",
          get: function get() {
            return this._enabled;
          },
          set: function set(t) {
            this._enabled = t;
          }
        }, {
          key: "minPos",
          get: function get() {
            return this._minPos;
          },
          set: function set(t) {
            this._minPos = t;
          }
        }, {
          key: "maxPos",
          get: function get() {
            return this._maxPos;
          },
          set: function set(t) {
            this._maxPos = t;
          }
        }, {
          key: "depth",
          get: function get() {
            return this._depth;
          },
          set: function set(t) {
            this._depth = t;
          }
        }, {
          key: "native",
          get: function get() {
            return this._nativeObj;
          }
        }]), t;
      }()), function (t) {
        t[t.DIRECTIONAL = 0] = "DIRECTIONAL", t[t.SPHERE = 1] = "SPHERE", t[t.SPOT = 2] = "SPOT", t[t.UNKNOWN = 3] = "UNKNOWN";
      }(Bt || (Bt = t("L", {})));
      var Ct,
          Ot,
          Vt = t("n", function (t) {
        return 4 * Math.PI * Math.PI * t * t;
      }),
          zt = t("i", function () {
        function t() {
          this._baked = !1, this._color = new L(1, 1, 1), this._colorTemp = 6550, this._colorTempRGB = new L(1, 1, 1), this._scene = null, this._node = null, this._name = null, this._useColorTemperature = !1, this._type = Bt.UNKNOWN;
        }

        var e = t.prototype;
        return e._init = function () {}, e._destroy = function () {}, e.initialize = function () {
          this._init(), this.color = new L(1, 1, 1), this.colorTemperature = 6550;
        }, e.attachToScene = function (t) {
          this._scene = t;
        }, e.detachFromScene = function () {
          this._scene = null;
        }, e.destroy = function () {
          this._name = null, this._node = null, this._destroy();
        }, e.update = function () {}, s(t, [{
          key: "baked",
          get: function get() {
            return this._baked;
          },
          set: function set(t) {
            this._baked = t;
          }
        }, {
          key: "color",
          get: function get() {
            return this._color;
          },
          set: function set(t) {
            this._color.set(t);
          }
        }, {
          key: "useColorTemperature",
          get: function get() {
            return this._useColorTemperature;
          },
          set: function set(t) {
            this._useColorTemperature = t;
          }
        }, {
          key: "colorTemperature",
          get: function get() {
            return this._colorTemp;
          },
          set: function set(t) {
            this._colorTemp = t, Nt(this._colorTempRGB, this._colorTemp);
          }
        }, {
          key: "colorTemperatureRGB",
          get: function get() {
            return this._colorTempRGB;
          }
        }, {
          key: "node",
          get: function get() {
            return this._node;
          },
          set: function set(t) {
            this._node = t, this._node && (this._node.hasChangedFlags |= $.ROTATION);
          }
        }, {
          key: "type",
          get: function get() {
            return this._type;
          }
        }, {
          key: "name",
          get: function get() {
            return this._name;
          },
          set: function set(t) {
            this._name = t;
          }
        }, {
          key: "scene",
          get: function get() {
            return this._scene;
          }
        }, {
          key: "native",
          get: function get() {
            return this._nativeObj;
          }
        }]), t;
      }()),
          Ut = new L(0, 0, -1),
          jt = new L(),
          Ht = (t("D", function (t) {
        function e() {
          var e;
          return (e = t.call(this) || this)._dir = new L(1, -1, -1), e._illuminanceHDR = J.SUN_ILLUM, e._illuminanceLDR = 1, e._shadowEnabled = !1, e._shadowPcf = tt.HARD, e._shadowBias = 1e-5, e._shadowNormalBias = 0, e._shadowSaturation = 1, e._shadowDistance = 100, e._shadowInvisibleOcclusionRange = 200, e._shadowFixedArea = !1, e._shadowNear = .1, e._shadowFar = 10, e._shadowOrthoSize = 5, e._type = Bt.DIRECTIONAL, e;
        }

        D(e, t);
        var i = e.prototype;
        return i.initialize = function () {
          t.prototype.initialize.call(this), this.illuminance = J.SUN_ILLUM, this.direction = new L(1, -1, -1);
        }, i.update = function () {
          this._node && this._node.hasChangedFlags && (this.direction = L.transformQuat(jt, Ut, this._node.worldRotation));
        }, s(e, [{
          key: "direction",
          get: function get() {
            return this._dir;
          },
          set: function set(t) {
            L.normalize(this._dir, t);
          }
        }, {
          key: "illuminance",
          get: function get() {
            return n.director.root.pipeline.pipelineSceneData.isHDR ? this._illuminanceHDR : this._illuminanceLDR;
          },
          set: function set(t) {
            n.director.root.pipeline.pipelineSceneData.isHDR ? this.illuminanceHDR = t : this.illuminanceLDR = t;
          }
        }, {
          key: "illuminanceHDR",
          get: function get() {
            return this._illuminanceHDR;
          },
          set: function set(t) {
            this._illuminanceHDR = t;
          }
        }, {
          key: "illuminanceLDR",
          get: function get() {
            return this._illuminanceLDR;
          },
          set: function set(t) {
            this._illuminanceLDR = t;
          }
        }, {
          key: "shadowEnabled",
          get: function get() {
            return this._shadowEnabled;
          },
          set: function set(t) {
            this._shadowEnabled = t;
          }
        }, {
          key: "shadowPcf",
          get: function get() {
            return this._shadowPcf;
          },
          set: function set(t) {
            this._shadowPcf = t;
          }
        }, {
          key: "shadowBias",
          get: function get() {
            return this._shadowBias;
          },
          set: function set(t) {
            this._shadowBias = t;
          }
        }, {
          key: "shadowNormalBias",
          get: function get() {
            return this._shadowNormalBias;
          },
          set: function set(t) {
            this._shadowNormalBias = t;
          }
        }, {
          key: "shadowSaturation",
          get: function get() {
            return this._shadowSaturation;
          },
          set: function set(t) {
            this._shadowSaturation = t;
          }
        }, {
          key: "shadowDistance",
          get: function get() {
            return this._shadowDistance;
          },
          set: function set(t) {
            this._shadowDistance = Math.min(t, et.MAX_FAR);
          }
        }, {
          key: "shadowInvisibleOcclusionRange",
          get: function get() {
            return this._shadowInvisibleOcclusionRange;
          },
          set: function set(t) {
            this._shadowInvisibleOcclusionRange = Math.min(t, et.MAX_FAR);
          }
        }, {
          key: "shadowFixedArea",
          get: function get() {
            return this._shadowFixedArea;
          },
          set: function set(t) {
            this._shadowFixedArea = t;
          }
        }, {
          key: "shadowNear",
          get: function get() {
            return this._shadowNear;
          },
          set: function set(t) {
            this._shadowNear = t;
          }
        }, {
          key: "shadowFar",
          get: function get() {
            return this._shadowFar;
          },
          set: function set(t) {
            this._shadowFar = Math.min(t, et.MAX_FAR);
          }
        }, {
          key: "shadowOrthoSize",
          get: function get() {
            return this._shadowOrthoSize;
          },
          set: function set(t) {
            this._shadowOrthoSize = t;
          }
        }]), e;
      }(zt)), t("j", function (t) {
        D(i, t);
        var e = i.prototype;

        function i() {
          var e;
          return (e = t.call(this) || this)._needUpdate = !1, e._size = .15, e._range = 1, e._luminanceHDR = 0, e._luminanceLDR = 0, e._pos = void 0, e._aabb = void 0, e._aabb = Y.create(), e._pos = new L(), e._type = Bt.SPHERE, e;
        }

        return e._init = function () {
          t.prototype._init.call(this);
        }, e._destroy = function () {
          t.prototype._destroy.call(this);
        }, e.initialize = function () {
          t.prototype.initialize.call(this), this.size = .15, this.range = 1, this.luminanceHDR = 1700 / Vt(.15), this.luminanceLDR = 1;
        }, e.update = function () {
          if (this._node && (this._node.hasChangedFlags || this._needUpdate)) {
            this._node.getWorldPosition(this._pos);

            var t = this._range;
            Y.set(this._aabb, this._pos.x, this._pos.y, this._pos.z, t, t, t), this._needUpdate = !1;
          }
        }, s(i, [{
          key: "position",
          get: function get() {
            return this._pos;
          }
        }, {
          key: "size",
          get: function get() {
            return this._size;
          },
          set: function set(t) {
            this._size = t;
          }
        }, {
          key: "range",
          get: function get() {
            return this._range;
          },
          set: function set(t) {
            this._range = t, this._needUpdate = !0;
          }
        }, {
          key: "luminance",
          get: function get() {
            return n.director.root.pipeline.pipelineSceneData.isHDR ? this._luminanceHDR : this._luminanceLDR;
          },
          set: function set(t) {
            n.director.root.pipeline.pipelineSceneData.isHDR ? this.luminanceHDR = t : this.luminanceLDR = t;
          }
        }, {
          key: "luminanceHDR",
          get: function get() {
            return this._luminanceHDR;
          },
          set: function set(t) {
            this._luminanceHDR = t;
          }
        }, {
          key: "luminanceLDR",
          set: function set(t) {
            this._luminanceLDR = t;
          }
        }, {
          key: "aabb",
          get: function get() {
            return this._aabb;
          }
        }]), i;
      }(zt)), new L(0, 0, -1)),
          Wt = new it(),
          Gt = new E(),
          Yt = new E(),
          Zt = new E(),
          Kt = new E(),
          Qt = t("k", function (t) {
        D(i, t);
        var e = i.prototype;

        function i() {
          var e;
          return (e = t.call(this) || this)._dir = new L(1, -1, -1), e._range = 5, e._spotAngle = Math.cos(Math.PI / 6), e._pos = void 0, e._aabb = void 0, e._frustum = void 0, e._angle = 0, e._needUpdate = !1, e._size = .15, e._luminanceHDR = 0, e._luminanceLDR = 0, e._shadowEnabled = !1, e._shadowPcf = tt.HARD, e._shadowBias = 1e-5, e._shadowNormalBias = 0, e._aabb = Y.create(), e._frustum = O.create(), e._pos = new L(), e._type = Bt.SPOT, e;
        }

        return e._init = function () {
          t.prototype._init.call(this);
        }, e._destroy = function () {
          t.prototype._destroy.call(this);
        }, e._setDirection = function (t) {
          this._dir.set(t);
        }, e.initialize = function () {
          t.prototype.initialize.call(this), this.size = .15, this.luminanceHDR = 1700 / Vt(.15), this.luminanceLDR = 1, this.range = Math.cos(Math.PI / 6), this._setDirection(new L(1, -1, -1));
        }, e.update = function () {
          this._node && (this._node.hasChangedFlags || this._needUpdate) && (this._node.getWorldPosition(this._pos), L.transformQuat(this._dir, Ht, this._node.getWorldRotation(Wt)), L.normalize(this._dir, this._dir), Y.set(this._aabb, this._pos.x, this._pos.y, this._pos.z, this._range, this._range, this._range), this._node.getWorldRT(Gt), E.invert(Gt, Gt), E.perspective(Yt, this._angle, 1, .001, this._range), E.multiply(Zt, Yt, Gt), this._frustum.update(Zt, Kt), this._needUpdate = !1);
        }, s(i, [{
          key: "position",
          get: function get() {
            return this._pos;
          }
        }, {
          key: "size",
          get: function get() {
            return this._size;
          },
          set: function set(t) {
            this._size = t;
          }
        }, {
          key: "range",
          get: function get() {
            return this._range;
          },
          set: function set(t) {
            this._range = t, this._needUpdate = !0;
          }
        }, {
          key: "luminance",
          get: function get() {
            return n.director.root.pipeline.pipelineSceneData.isHDR ? this._luminanceHDR : this._luminanceLDR;
          },
          set: function set(t) {
            n.director.root.pipeline.pipelineSceneData.isHDR ? this.luminanceHDR = t : this.luminanceLDR = t;
          }
        }, {
          key: "luminanceHDR",
          get: function get() {
            return this._luminanceHDR;
          },
          set: function set(t) {
            this._luminanceHDR = t;
          }
        }, {
          key: "luminanceLDR",
          get: function get() {
            return this._luminanceLDR;
          },
          set: function set(t) {
            this._luminanceLDR = t;
          }
        }, {
          key: "direction",
          get: function get() {
            return this._dir;
          }
        }, {
          key: "spotAngle",
          get: function get() {
            return this._spotAngle;
          },
          set: function set(t) {
            this._angle = t, this._spotAngle = Math.cos(.5 * t), this._needUpdate = !0;
          }
        }, {
          key: "angle",
          get: function get() {
            return this._angle;
          }
        }, {
          key: "aabb",
          get: function get() {
            return this._aabb;
          }
        }, {
          key: "frustum",
          get: function get() {
            return this._frustum;
          }
        }, {
          key: "shadowEnabled",
          get: function get() {
            return this._shadowEnabled;
          },
          set: function set(t) {
            this._shadowEnabled = t;
          }
        }, {
          key: "shadowPcf",
          get: function get() {
            return this._shadowPcf;
          },
          set: function set(t) {
            this._shadowPcf = t;
          }
        }, {
          key: "shadowBias",
          get: function get() {
            return this._shadowBias;
          },
          set: function set(t) {
            this._shadowBias = t;
          }
        }, {
          key: "shadowNormalBias",
          get: function get() {
            return this._shadowNormalBias;
          },
          set: function set(t) {
            this._shadowNormalBias = t;
          }
        }]), i;
      }(zt)),
          Xt = t("R", function () {
        function t(t) {
          this._root = void 0, this._name = "", this._cameras = [], this._models = [], this._batches = [], this._directionalLights = [], this._sphereLights = [], this._spotLights = [], this._mainLight = null, this._modelId = 0, this._root = t, this._createNativeObject();
        }

        t.registerCreateFunc = function (e) {
          e._createSceneFun = function (e) {
            return new t(e);
          };
        };

        var e = t.prototype;
        return e.initialize = function (t) {
          return this._name = t.name, !0;
        }, e.activate = function () {}, e.update = function (t) {
          var e = this._mainLight;
          e && e.update();

          for (var i = this._sphereLights, n = 0; n < i.length; n++) {
            i[n].update();
          }

          for (var s = this._spotLights, r = 0; r < s.length; r++) {
            s[r].update();
          }

          for (var a = this._models, o = 0; o < a.length; o++) {
            var h = a[o];
            h.enabled && (h.updateTransform(t), h.updateUBOs(t));
          }
        }, e._destroy = function () {}, e.destroy = function () {
          this.removeCameras(), this.removeSphereLights(), this.removeSpotLights(), this.removeModels(), this._destroy();
        }, e.addCamera = function (t) {
          t.attachToScene(this), this._cameras.push(t);
        }, e.removeCamera = function (t) {
          for (var e = 0; e < this._cameras.length; ++e) {
            if (this._cameras[e] === t) return this._cameras.splice(e, 1), void t.detachFromScene();
          }
        }, e.removeCameras = function () {
          for (var t, e = I(this._cameras); !(t = e()).done;) {
            t.value.detachFromScene();
          }

          this._cameras.splice(0);
        }, e.setMainLight = function (t) {
          this._mainLight = t;
        }, e.unsetMainLight = function (t) {
          if (this._mainLight === t) {
            var e = this._directionalLights;
            if (e.length) return this.setMainLight(e[e.length - 1]), void (this._mainLight.node && (this._mainLight.node.hasChangedFlags |= $.ROTATION));
            this.setMainLight(null);
          }
        }, e.addDirectionalLight = function (t) {
          t.attachToScene(this), this._directionalLights.push(t);
        }, e.removeDirectionalLight = function (t) {
          for (var e = 0; e < this._directionalLights.length; ++e) {
            if (this._directionalLights[e] === t) return t.detachFromScene(), void this._directionalLights.splice(e, 1);
          }
        }, e.addSphereLight = function (t) {
          t.attachToScene(this), this._sphereLights.push(t);
        }, e.removeSphereLight = function (t) {
          for (var e = 0; e < this._sphereLights.length; ++e) {
            if (this._sphereLights[e] === t) return t.detachFromScene(), void this._sphereLights.splice(e, 1);
          }
        }, e.addSpotLight = function (t) {
          t.attachToScene(this), this._spotLights.push(t);
        }, e.removeSpotLight = function (t) {
          for (var e = 0; e < this._spotLights.length; ++e) {
            if (this._spotLights[e] === t) return t.detachFromScene(), void this._spotLights.splice(e, 1);
          }
        }, e.removeSphereLights = function () {
          for (var t = 0; t < this._sphereLights.length; ++t) {
            this._sphereLights[t].detachFromScene();
          }

          this._sphereLights.length = 0;
        }, e.removeSpotLights = function () {
          for (var t = 0; t < this._spotLights.length; ++t) {
            this._spotLights[t].detachFromScene();
          }

          this._spotLights = [];
        }, e.addModel = function (t) {
          t.attachToScene(this), this._models.push(t);
        }, e.removeModel = function (t) {
          for (var e = 0; e < this._models.length; ++e) {
            if (this._models[e] === t) return t.detachFromScene(), void this._models.splice(e, 1);
          }
        }, e.removeModels = function () {
          for (var t, e = I(this._models); !(t = e()).done;) {
            var i = t.value;
            i.detachFromScene(), i.destroy();
          }

          this._models.length = 0;
        }, e.addBatch = function (t) {
          this._batches.push(t);
        }, e.removeBatch = function (t) {
          for (var e = 0; e < this._batches.length; ++e) {
            if (this._batches[e] === t) return void this._batches.splice(e, 1);
          }
        }, e.removeBatches = function () {
          this._batches.length = 0;
        }, e.onGlobalPipelineStateChanged = function () {
          for (var t, e = I(this._models); !(t = e()).done;) {
            t.value.onGlobalPipelineStateChanged();
          }
        }, e.generateModelId = function () {
          return this._modelId++;
        }, e._createNativeObject = function () {}, s(t, [{
          key: "root",
          get: function get() {
            return this._root;
          }
        }, {
          key: "name",
          get: function get() {
            return this._name;
          }
        }, {
          key: "cameras",
          get: function get() {
            return this._cameras;
          }
        }, {
          key: "mainLight",
          get: function get() {
            return this._mainLight;
          }
        }, {
          key: "sphereLights",
          get: function get() {
            return this._sphereLights;
          }
        }, {
          key: "spotLights",
          get: function get() {
            return this._spotLights;
          }
        }, {
          key: "models",
          get: function get() {
            return this._models;
          }
        }, {
          key: "native",
          get: function get() {
            return this._nativeObj;
          }
        }, {
          key: "batches",
          get: function get() {
            return this._batches;
          }
        }]), t;
      }());

      function qt(t) {
        return --t, t |= t >> 16, t |= t >> 8, t |= t >> 4, t |= t >> 2, t |= t >> 1, ++t;
      }

      function $t(t, e) {
        return Math.ceil(t / e) * e;
      }

      !function (t) {
        t[t.OPAQUE = 0] = "OPAQUE", t[t.TRANSPARENT = 1] = "TRANSPARENT", t[t.OVERLAY = 2] = "OVERLAY";
      }(Ct || (Ct = t("l", {}))), function (t) {
        t[t.DEFAULT = 1] = "DEFAULT", t[t.FORWARD = 2] = "FORWARD", t[t.SHADOWCAST = 4] = "SHADOWCAST";
      }(Ot || (Ot = t("P", {}))), t("T", function () {
        function t(t) {
          this._device = void 0, this._format = _.UNKNOWN, this._formatSize = 0, this._chunks = [], this._chunkCount = 0, this._handles = [], this._region0 = new k(), this._region1 = new k(), this._region2 = new k(), this._roundUpFn = null, this._bufferViewCtor = Uint8Array, this._channels = 4, this._alignment = 1, this._device = t;
        }

        var e = t.prototype;
        return e.initialize = function (t) {
          var e = g[t.format];
          this._format = t.format, this._formatSize = e.size, this._channels = e.count, this._bufferViewCtor = y(e), this._roundUpFn = t.roundUpFn || null, this._alignment = t.alignment || 1, t.inOrderFree && (this.alloc = this._McDonaldAlloc);
        }, e.destroy = function () {
          for (var t = 0; t < this._chunkCount; ++t) {
            this._chunks[t].texture.destroy();
          }

          this._chunks.length = 0, this._handles.length = 0;
        }, e.alloc = function (t, e) {
          t = $t(t, this._alignment);
          var i = -1,
              n = -1;
          if (void 0 !== e && (i = e, n = this._findAvailableSpace(t, i)), n < 0) for (var s = 0; s < this._chunkCount && (i = s, !((n = this._findAvailableSpace(t, i)) >= 0)); ++s) {
            ;
          }

          if (n >= 0) {
            var r = this._chunks[i];
            r.start += t;
            var a = {
              chunkIdx: i,
              start: n,
              end: n + t,
              texture: r.texture
            };
            return this._handles.push(a), a;
          }

          var o = Math.sqrt(t / this._formatSize),
              h = this._roundUpFn && this._roundUpFn(o, this._formatSize) || Math.max(1024, qt(o)),
              u = this._chunks[this.createChunk(h)];

          u.start += t;
          var _ = {
            chunkIdx: this._chunkCount - 1,
            start: 0,
            end: t,
            texture: u.texture
          };
          return this._handles.push(_), _;
        }, e.free = function (t) {
          for (var e = 0; e < this._handles.length; ++e) {
            if (this._handles[e] === t) return this._chunks[t.chunkIdx].end = t.end, void this._handles.splice(e, 1);
          }
        }, e.createChunk = function (t) {
          var e = t * t * this._formatSize;
          M("TextureBufferPool: Allocate chunk " + this._chunkCount + ", size: " + e + ", format: " + this._format);
          var i = {
            texture: this._device.createTexture(new o(h.TEX2D, u.SAMPLED | u.TRANSFER_DST, this._format, t, t)),
            size: e,
            start: 0,
            end: e
          };
          return this._chunks[this._chunkCount] = i, this._chunkCount++;
        }, e.update = function (t, e) {
          var i = [],
              n = [],
              s = t.start / this._formatSize,
              r = e.byteLength / this._formatSize,
              a = s % t.texture.width,
              o = Math.floor(s / t.texture.width),
              h = Math.min(t.texture.width - a, r),
              u = 0;
          a > 0 && (this._region0.texOffset.x = a, this._region0.texOffset.y = o, this._region0.texExtent.width = h, this._region0.texExtent.height = 1, i.push(new this._bufferViewCtor(e, u * this._formatSize, h * this._channels)), n.push(this._region0), a = 0, o += 1, r -= h, u += h), r > 0 && (this._region1.texOffset.x = a, this._region1.texOffset.y = o, r > t.texture.width ? (this._region1.texExtent.width = t.texture.width, this._region1.texExtent.height = Math.floor(r / t.texture.width), h = this._region1.texExtent.width * this._region1.texExtent.height) : (h = r, this._region1.texExtent.width = h, this._region1.texExtent.height = 1), i.push(new this._bufferViewCtor(e, u * this._formatSize, h * this._channels)), n.push(this._region1), a = 0, o += this._region1.texExtent.height, r -= h, u += h), r > 0 && (this._region2.texOffset.x = a, this._region2.texOffset.y = o, this._region2.texExtent.width = r, this._region2.texExtent.height = 1, i.push(new this._bufferViewCtor(e, u * this._formatSize, r * this._channels)), n.push(this._region2)), this._device.copyBuffersToTexture(i, t.texture, n);
        }, e._findAvailableSpace = function (t, e) {
          var i = this._chunks[e],
              n = !1,
              s = i.start;
          if (s + t <= i.size) n = !0;else {
            s = 0;

            for (var r = this._handles.filter(function (t) {
              return t.chunkIdx === e;
            }).sort(function (t, e) {
              return t.start - e.start;
            }), a = 0; a < r.length; a++) {
              var o = r[a];

              if (s + t <= o.start) {
                n = !0;
                break;
              }

              s = o.end;
            }

            !n && s + t <= i.size && (n = !0);
          }
          return n ? s : -1;
        }, e._McDonaldAlloc = function (t) {
          t = $t(t, this._alignment);

          for (var e = 0; e < this._chunkCount; ++e) {
            var i = this._chunks[e],
                n = !1,
                s = i.start;

            if (s + t <= i.end ? n = !0 : s > i.end ? s + t <= i.size ? n = !0 : t <= i.end && (i.start = s = 0, n = !0) : s === i.end && (i.start = s = 0, i.end = i.size, t <= i.end && (n = !0)), n) {
              i.start += t;
              var r = {
                chunkIdx: e,
                start: s,
                end: s + t,
                texture: i.texture
              };
              return this._handles.push(r), r;
            }
          }

          var a = Math.sqrt(t / this._formatSize),
              o = this._roundUpFn && this._roundUpFn(a, this._formatSize) || Math.max(1024, qt(a)),
              h = this._chunks[this.createChunk(o)];

          h.start += t;
          var u = {
            chunkIdx: this._chunkCount,
            start: 0,
            end: t,
            texture: h.texture
          };
          return this._handles.push(u), u;
        }, t;
      }()), nt(Xt.prototype, "RenderScene.prototype", [{
        name: "raycastUI2DNode"
      }, {
        name: "raycastUINode"
      }]), nt(Xt.prototype, "RenderScene.prototype", [{
        name: "raycastAll",
        suggest: "using intersect.rayModel in geometry"
      }, {
        name: "raycastAllModels",
        suggest: "using intersect.rayModel in geometry"
      }, {
        name: "raycastSingleModel",
        suggest: "using intersect.rayModel in geometry"
      }, {
        name: "raycastAllCanvas",
        suggest: "using intersect.rayAABB in geometry"
      }, {
        name: "rayResultCanvas"
      }, {
        name: "rayResultModels"
      }, {
        name: "rayResultAll"
      }, {
        name: "rayResultSingleModel"
      }]);
      var Jt = t("o", {});
      nt(Jt, "CameraVisFlags", [{
        name: "GENERAL"
      }]), st(Jt, "CameraVisFlags", [{
        name: "PROFILER",
        newName: "PROFILER",
        target: W.BitMask,
        targetName: "PROFILER"
      }, {
        name: "GIZMOS",
        newName: "GIZMOS",
        target: W.BitMask,
        targetName: "GIZMOS"
      }, {
        name: "EDITOR",
        newName: "EDITOR",
        target: W.BitMask,
        targetName: "EDITOR"
      }, {
        name: "UI",
        newName: "UI",
        target: W.BitMask,
        targetName: "UI_3D"
      }, {
        name: "UI2D",
        newName: "UI2D",
        target: W.BitMask,
        targetName: "UI_2D"
      }]), n.CameraVisFlags = Jt;

      var te,
          ee,
          ie,
          ne,
          se,
          re,
          ae,
          oe,
          he,
          ue,
          _e = t("V", {});

      nt(_e, "VisibilityFlags", [{
        name: "GENERAL"
      }]), st(_e, "VisibilityFlags", [{
        name: "ALWALS",
        newName: "ALWALS",
        target: W.Enum,
        targetName: "ALWALS"
      }, {
        name: "PROFILER",
        newName: "PROFILER",
        target: W.Enum,
        targetName: "PROFILER"
      }, {
        name: "GIZMOS",
        newName: "GIZMOS",
        target: W.Enum,
        targetName: "GIZMOS"
      }, {
        name: "EDITOR",
        newName: "EDITOR",
        target: W.Enum,
        targetName: "EDITOR"
      }, {
        name: "UI",
        newName: "UI",
        target: W.Enum,
        targetName: "UI_3D"
      }, {
        name: "UI2D",
        newName: "UI2D",
        target: W.Enum,
        targetName: "UI_2D"
      }]), n.VisibilityFlags = _e, st(rt.prototype, "Pass.prototype", [{
        name: "getBindingTypeFromHandle",
        newName: "getDescriptorTypeFromHandle"
      }]), nt(At.prototype, "Camera.prototype", [{
        name: "getSplitFrustum"
      }, {
        name: "setMatView"
      }, {
        name: "setMatViewInv"
      }, {
        name: "setMatProjInv"
      }, {
        name: "setMatViewProjInv"
      }, {
        name: "setMatProj"
      }, {
        name: "setMatViewProj"
      }, {
        name: "getMatViewInv"
      }]), nt(et.prototype, "Shadows.prototype", [{
        name: "aspect"
      }, {
        name: "selfShadow"
      }, {
        name: "linear"
      }, {
        name: "packing"
      }, {
        name: "autoAdapt"
      }, {
        name: "fixedArea"
      }, {
        name: "pcf"
      }, {
        name: "bias"
      }, {
        name: "normalBias"
      }, {
        name: "near"
      }, {
        name: "far"
      }, {
        name: "shadowDistance"
      }, {
        name: "invisibleOcclusionRange"
      }, {
        name: "orthoSize"
      }, {
        name: "saturation"
      }]), nt(Qt.prototype, "SpotLight.prototype", [{
        name: "aspect"
      }]);
      var ce = {
        parent: null,
        owner: null,
        subModelIdx: 0
      },
          le = t("p", (te = at("cc.RenderableComponent"), ee = ot(ht), ie = _t(), ne = ct(), se = ot([ht]), te((ue = function (t) {
        function e() {
          for (var e, i = arguments.length, n = new Array(i), s = 0; s < i; s++) {
            n[s] = arguments[s];
          }

          return e = t.call.apply(t, [this].concat(n)) || this, R(e, "_visFlags", oe, T(e)), R(e, "_materials", he, T(e)), e._materialInstances = [], e._models = [], e;
        }

        D(e, t);
        var i = e.prototype;
        return i.getMaterial = function (t) {
          return t < 0 || t >= this._materials.length ? null : this._materials[t];
        }, i.setMaterial = function (t, e) {
          t && t instanceof ut && console.error("Can't set a material instance to a sharedMaterial slot"), this._materials[e] = t;
          var i = this._materialInstances[e];
          i && (i.destroy(), this._materialInstances[e] = null), this._onMaterialModified(e, this._materials[e]);
        }, i.getMaterialInstance = function (t) {
          if (!this._materials[t]) return null;

          if (!this._materialInstances[t]) {
            ce.parent = this._materials[t], ce.owner = this, ce.subModelIdx = t;
            var e = new ut(ce);
            ce.parent = null, ce.owner = null, ce.subModelIdx = 0, this.setMaterialInstance(e, t);
          }

          return this._materialInstances[t];
        }, i.setMaterialInstance = function (t, e) {
          if ("number" == typeof t) {
            a(12007);
            var i = t;
            t = e, e = i;
          }

          var n = this._materialInstances[e];
          t && t.parent ? t !== n && (this._materialInstances[e] = t, this._onMaterialModified(e, t)) : (t !== this._materials[e] || n) && this.setMaterial(t, e);
        }, i.getRenderMaterial = function (t) {
          return this._materialInstances[t] || this._materials[t];
        }, i._collectModels = function () {
          return this._models;
        }, i._attachToScene = function () {}, i._detachFromScene = function () {}, i._onMaterialModified = function () {}, i._onRebuildPSO = function () {}, i._clearMaterials = function () {}, i._onVisibilityChange = function () {}, s(e, [{
          key: "visibility",
          get: function get() {
            return this._visFlags;
          },
          set: function set(t) {
            this._visFlags = t, this._onVisibilityChange(t);
          }
        }, {
          key: "sharedMaterials",
          get: function get() {
            return this._materials;
          },
          set: function set(t) {
            for (var e = 0; e < t.length; e++) {
              t[e] !== this._materials[e] && this.setMaterial(t[e], e);
            }

            if (t.length < this._materials.length) {
              for (var i = t.length; i < this._materials.length; i++) {
                this.setMaterial(null, i);
              }

              this._materials.splice(t.length);
            }
          }
        }, {
          key: "materials",
          get: function get() {
            for (var t = 0; t < this._materials.length; t++) {
              this._materialInstances[t] = this.getMaterialInstance(t);
            }

            return this._materialInstances;
          },
          set: function set(t) {
            for (var e = t.length, i = this._materials.length, n = e; n < i; n++) {
              this.setMaterialInstance(null, n);
            }

            this._materials.length = e, this._materialInstances.length = e;

            for (var s = 0; s < e; s++) {
              this._materialInstances[s] != t[s] && this.setMaterialInstance(t[s], s);
            }
          }
        }, {
          key: "sharedMaterial",
          get: function get() {
            return this.getMaterial(0);
          }
        }, {
          key: "material",
          get: function get() {
            return this.getMaterialInstance(0);
          },
          set: function set(t) {
            (1 !== this._materials.length || this._materialInstances[0] || this._materials[0] !== t) && this.setMaterialInstance(t, 0);
          }
        }]), e;
      }(lt), oe = A((ae = ue).prototype, "_visFlags", [dt], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return W.Enum.NONE;
        }
      }), A(ae.prototype, "sharedMaterials", [ee, ie, ne], Object.getOwnPropertyDescriptor(ae.prototype, "sharedMaterials"), ae.prototype), he = A(ae.prototype, "_materials", [se], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return [];
        }
      }), re = ae)) || re));
      n.RenderableComponent = le;
    }
  };
}); 
 			}); 
		define("__plugin__/wx0446ba2621dda60a/skeletal-animation-utils-121f35a2.js", function(require, module, exports){ 			
"use strict";

System.register(["./texture-barrier-60b5983b.js", "./json-asset-933a1d4c.js"], function (e) {
  "use strict";

  var t, n;
  return {
    setters: [function (e) {
      t = e.l;
    }, function (e) {
      n = e.Z;
    }],
    execute: function execute() {
      e({
        a: function a(e, t) {
          for (var r, o = null, u = 0; e !== t;) {
            var i = e.uuid;

            if (l.has(i)) {
              o = l.get(i);
              break;
            }

            o = {
              node: e,
              local: new n(),
              world: new n(),
              stamp: -1,
              parent: null
            }, l.set(i, o), _a[u++] = o, e = e.parent, o = null;
          }

          for (; u > 0;) {
            r = _a[--u], _a[u] = null, r.parent = o, o = r;
          }

          return o;
        },
        b: function b(e, t) {
          for (var r = 0, o = n.IDENTITY; e;) {
            if (e.stamp === t || e.stamp + 1 === t && !e.node.hasChangedFlags) {
              o = e.world, e.stamp = t;
              break;
            }

            e.stamp = t, _a[r++] = e, e = e.parent;
          }

          for (; r > 0;) {
            e = _a[--r], _a[r] = null;
            var l = e.node;
            n.fromRTS(e.local, l.rotation, l.position, l.scale), o = n.multiply(e.world, o, e.local);
          }

          return o;
        },
        c: function c(e, t) {
          for (var n = e, r = ""; null !== n && n !== t;) {
            r = n.name + "/" + r, n = n.parent;
          }

          return r.slice(0, -1);
        },
        d: function d(e) {
          for (var t = l.get(e.uuid) || null; t;) {
            l.delete(t.node.uuid), t = t.parent;
          }
        },
        g: function g(e, t, r) {
          for (n.identity(r); e !== t;) {
            n.fromRTS(o, e.rotation, e.position, e.scale), n.multiply(r, o, r), e = e.parent;
          }

          return r;
        }
      });
      var r = e("B", Symbol("BakeNodeCurves"));
      e("S", function () {
        function e() {}

        return e.getOrExtract = function (n) {
          var o = e.pool.get(n);

          if (!o || o.samples !== n.sample) {
            o && t.director.root.dataPoolManager.releaseAnimationClip(n);
            var a = Math.ceil(n.sample * n.duration) + 1,
                l = n.sample;
            o = n[r](0, l, a), e.pool.set(n, o);
          }

          return o;
        }, e.destroy = function (t) {
          e.pool.delete(t);
        }, e;
      }()).pool = new Map();
      var o = new n(),
          _a = [],
          l = new Map();
    }
  };
}); 
 			}); 
		define("__plugin__/wx0446ba2621dda60a/skeleton-b0039cea.js", function(require, module, exports){ 			
"use strict";

System.register(["./texture-barrier-60b5983b.js", "./json-asset-933a1d4c.js"], function (i) {
  "use strict";

  var t, n, e, o, s, r, c, a, u, h, l, b, p;
  return {
    setters: [function (i) {
      t = i.bH, n = i.bT, e = i.l, o = i.bU, s = i.c0, r = i.c1, c = i.b$, a = i.bA;
    }, function (i) {
      u = i.bW, h = i.bZ, l = i.Z, b = i.aL, p = i.bX;
    }],
    execute: function execute() {
      var d,
          f,
          _,
          m,
          v,
          P,
          g,
          y,
          j,
          k = i("S", (d = u("cc.Skeleton"), f = h([t]), _ = h([l]), d((j = function (i) {
        function t() {
          for (var t, n = arguments.length, e = new Array(n), o = 0; o < n; o++) {
            e[o] = arguments[o];
          }

          return t = i.call.apply(i, [this].concat(e)) || this, r(t, "_joints", P, c(t)), r(t, "_bindposes", g, c(t)), r(t, "_hash", y, c(t)), t._invBindposes = null, t;
        }

        n(t, i);
        var s = t.prototype;
        return s.destroy = function () {
          var t, n;
          return null === (t = null === (n = e.director.root) || void 0 === n ? void 0 : n.dataPoolManager) || void 0 === t || t.releaseSkeleton(this), i.prototype.destroy.call(this);
        }, s.validate = function () {
          return this.joints.length > 0 && this.bindposes.length > 0;
        }, o(t, [{
          key: "joints",
          get: function get() {
            return this._joints;
          },
          set: function set(i) {
            this._joints = i;
          }
        }, {
          key: "bindposes",
          get: function get() {
            return this._bindposes;
          },
          set: function set(i) {
            this._bindposes = i;
          }
        }, {
          key: "inverseBindposes",
          get: function get() {
            if (!this._invBindposes) {
              this._invBindposes = [];

              for (var i = 0; i < this._bindposes.length; i++) {
                var t = new l();
                l.invert(t, this._bindposes[i]), this._invBindposes.push(t);
              }
            }

            return this._invBindposes;
          }
        }, {
          key: "hash",
          get: function get() {
            if (!this._hash) {
              for (var i = "", t = 0; t < this._bindposes.length; t++) {
                var n = this._bindposes[t];
                i += n.m00.toPrecision(2) + " " + n.m01.toPrecision(2) + " " + n.m02.toPrecision(2) + " " + n.m03.toPrecision(2) + " " + n.m04.toPrecision(2) + " " + n.m05.toPrecision(2) + " " + n.m06.toPrecision(2) + " " + n.m07.toPrecision(2) + " " + n.m08.toPrecision(2) + " " + n.m09.toPrecision(2) + " " + n.m10.toPrecision(2) + " " + n.m11.toPrecision(2) + " " + n.m12.toPrecision(2) + " " + n.m13.toPrecision(2) + " " + n.m14.toPrecision(2) + " " + n.m15.toPrecision(2) + "\n";
              }

              this._hash = a(i, 666);
            }

            return this._hash;
          }
        }]), t;
      }(b), P = s((v = j).prototype, "_joints", [f], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return [];
        }
      }), g = s(v.prototype, "_bindposes", [_], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return [];
        }
      }), y = s(v.prototype, "_hash", [p], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 0;
        }
      }), m = v)) || m));

      e.Skeleton = k;
    }
  };
}); 
 			}); 
		define("__plugin__/wx0446ba2621dda60a/spine.js", function(require, module, exports){ 			
"use strict";

System.register(["./texture-barrier-60b5983b.js", "./json-asset-933a1d4c.js", "./index-f2b92470.js", "./renderable-component-7c6600ed.js", "./deprecated-26630860.js", "./deprecated-ef6bb945.js", "./renderable-2d-e2838949.js", "./graphics-f99ac3d9.js", "./static-vb-accessor-3aa47319.js"], function (t) {
  "use strict";

  var e, n, i, r, a, s, o, l, h, u, c, d, f, p, m, g, v, y, x, w, _, E, b, T, M, A, C, S, k, I, R, P, V, D, N, F, O, L, U, B, Y, X, W, q, H, j, z, G, Z;

  return {
    setters: [function (t) {
      e = t.i, n = t.bT, i = t.bH, r = t.bv, a = t.bU, s = t.c0, o = t.l, l = t.c1, h = t.b$, u = t.bw, c = t.bX, d = t.w, f = t.c, p = t.H, m = t.bC, g = t.bB, v = t.R, y = t.G;
    }, function (t) {
      x = t.Z, w = t.dy, _ = t.dT, E = t.bW, b = t.bZ, T = t.aT, M = t.b6, A = t.aL, C = t.bX, S = t.aW, k = t.cd, I = t.bo, R = t.M, P = t.a5, V = t.dz, D = t.b$, N = t.cg, F = t.ch, O = t.bY, L = t.de, U = t.cc, B = t.ci, Y = t.ay;
    }, function () {}, function () {}, function () {}, function (t) {
      X = t.d, W = t.a;
    }, function (t) {
      q = t.R, H = t.a, j = t.h, z = t.f;
    }, function (t) {
      G = t.G;
    }, function (t) {
      Z = t.S;
    }],
    execute: function execute() {
      var _J,
          Q,
          K,
          $ = (_J = function J(t, e) {
        return (_J = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function (t, e) {
          t.__proto__ = e;
        } || function (t, e) {
          for (var n in e) {
            e.hasOwnProperty(n) && (t[n] = e[n]);
          }
        })(t, e);
      }, function (t, e) {
        function n() {
          this.constructor = t;
        }

        _J(t, e), t.prototype = null === e ? Object.create(e) : (n.prototype = e.prototype, new n());
      });

      !function (t) {
        var e,
            n,
            i,
            r = function () {
          function t(t, e, n) {
            if (null == t) throw new Error("name cannot be null.");
            if (null == e) throw new Error("timelines cannot be null.");
            this.name = t, this.timelines = e, this.timelineIds = [];

            for (var i = 0; i < e.length; i++) {
              this.timelineIds[e[i].getPropertyId()] = !0;
            }

            this.duration = n;
          }

          return t.prototype.hasTimeline = function (t) {
            return 1 == this.timelineIds[t];
          }, t.prototype.apply = function (t, e, n, i, r, a, s, o) {
            if (null == t) throw new Error("skeleton cannot be null.");
            i && 0 != this.duration && (n %= this.duration, e > 0 && (e %= this.duration));

            for (var l = this.timelines, h = 0, u = l.length; h < u; h++) {
              l[h].apply(t, e, n, r, a, s, o);
            }
          }, t.binarySearch = function (t, e, n) {
            void 0 === n && (n = 1);
            var i = 0,
                r = t.length / n - 2;
            if (0 == r) return n;

            for (var a = r >>> 1;;) {
              if (t[(a + 1) * n] <= e ? i = a + 1 : r = a, i == r) return (i + 1) * n;
              a = i + r >>> 1;
            }
          }, t.linearSearch = function (t, e, n) {
            for (var i = 0, r = t.length - n; i <= r; i += n) {
              if (t[i] > e) return i;
            }

            return -1;
          }, t;
        }();

        t.Animation = r, function (t) {
          t[t.setup = 0] = "setup", t[t.first = 1] = "first", t[t.replace = 2] = "replace", t[t.add = 3] = "add";
        }(e = t.MixBlend || (t.MixBlend = {})), function (t) {
          t[t.mixIn = 0] = "mixIn", t[t.mixOut = 1] = "mixOut";
        }(n = t.MixDirection || (t.MixDirection = {})), function (t) {
          t[t.rotate = 0] = "rotate", t[t.translate = 1] = "translate", t[t.scale = 2] = "scale", t[t.shear = 3] = "shear", t[t.attachment = 4] = "attachment", t[t.color = 5] = "color", t[t.deform = 6] = "deform", t[t.event = 7] = "event", t[t.drawOrder = 8] = "drawOrder", t[t.ikConstraint = 9] = "ikConstraint", t[t.transformConstraint = 10] = "transformConstraint", t[t.pathConstraintPosition = 11] = "pathConstraintPosition", t[t.pathConstraintSpacing = 12] = "pathConstraintSpacing", t[t.pathConstraintMix = 13] = "pathConstraintMix", t[t.twoColor = 14] = "twoColor";
        }(i = t.TimelineType || (t.TimelineType = {}));

        var a = function () {
          function e(n) {
            if (n <= 0) throw new Error("frameCount must be > 0: " + n);
            this.curves = t.Utils.newFloatArray((n - 1) * e.BEZIER_SIZE);
          }

          return e.prototype.getFrameCount = function () {
            return this.curves.length / e.BEZIER_SIZE + 1;
          }, e.prototype.setLinear = function (t) {
            this.curves[t * e.BEZIER_SIZE] = e.LINEAR;
          }, e.prototype.setStepped = function (t) {
            this.curves[t * e.BEZIER_SIZE] = e.STEPPED;
          }, e.prototype.getCurveType = function (t) {
            var n = t * e.BEZIER_SIZE;
            if (n == this.curves.length) return e.LINEAR;
            var i = this.curves[n];
            return i == e.LINEAR ? e.LINEAR : i == e.STEPPED ? e.STEPPED : e.BEZIER;
          }, e.prototype.setCurve = function (t, n, i, r, a) {
            var s = .03 * (2 * -n + r),
                o = .03 * (2 * -i + a),
                l = .006 * (3 * (n - r) + 1),
                h = .006 * (3 * (i - a) + 1),
                u = 2 * s + l,
                c = 2 * o + h,
                d = .3 * n + s + .16666667 * l,
                f = .3 * i + o + .16666667 * h,
                p = t * e.BEZIER_SIZE,
                m = this.curves;
            m[p++] = e.BEZIER;

            for (var g = d, v = f, y = p + e.BEZIER_SIZE - 1; p < y; p += 2) {
              m[p] = g, m[p + 1] = v, d += u, f += c, u += l, c += h, g += d, v += f;
            }
          }, e.prototype.getCurvePercent = function (n, i) {
            i = t.MathUtils.clamp(i, 0, 1);
            var r = this.curves,
                a = n * e.BEZIER_SIZE,
                s = r[a];
            if (s == e.LINEAR) return i;
            if (s == e.STEPPED) return 0;

            for (var o = 0, l = ++a, h = a + e.BEZIER_SIZE - 1; a < h; a += 2) {
              if ((o = r[a]) >= i) {
                var u = void 0,
                    c = void 0;
                return a == l ? (u = 0, c = 0) : (u = r[a - 2], c = r[a - 1]), c + (r[a + 1] - c) * (i - u) / (o - u);
              }
            }

            var d = r[a - 1];
            return d + (1 - d) * (i - o) / (1 - o);
          }, e.LINEAR = 0, e.STEPPED = 1, e.BEZIER = 2, e.BEZIER_SIZE = 19, e;
        }();

        t.CurveTimeline = a;

        var s = function (n) {
          function a(e) {
            var i = n.call(this, e) || this;
            return i.frames = t.Utils.newFloatArray(e << 1), i;
          }

          return $(a, n), a.prototype.getPropertyId = function () {
            return (i.rotate << 24) + this.boneIndex;
          }, a.prototype.setFrame = function (t, e, n) {
            t <<= 1, this.frames[t] = e, this.frames[t + a.ROTATION] = n;
          }, a.prototype.apply = function (t, n, i, s, o, l) {
            var h = this.frames,
                u = t.bones[this.boneIndex];
            if (u.active) if (i < h[0]) switch (l) {
              case e.setup:
                return void (u.rotation = u.data.rotation);

              case e.first:
                var c = u.data.rotation - u.rotation;
                u.rotation += (c - 360 * (16384 - (16384.499999999996 - c / 360 | 0))) * o;
            } else if (i >= h[h.length - a.ENTRIES]) {
              var d = h[h.length + a.PREV_ROTATION];

              switch (l) {
                case e.setup:
                  u.rotation = u.data.rotation + d * o;
                  break;

                case e.first:
                case e.replace:
                  d += u.data.rotation - u.rotation, d -= 360 * (16384 - (16384.499999999996 - d / 360 | 0));

                case e.add:
                  u.rotation += d * o;
              }
            } else {
              var f = r.binarySearch(h, i, a.ENTRIES),
                  p = h[f + a.PREV_ROTATION],
                  m = h[f],
                  g = this.getCurvePercent((f >> 1) - 1, 1 - (i - m) / (h[f + a.PREV_TIME] - m)),
                  v = h[f + a.ROTATION] - p;

              switch (v = p + (v - 360 * (16384 - (16384.499999999996 - v / 360 | 0))) * g, l) {
                case e.setup:
                  u.rotation = u.data.rotation + (v - 360 * (16384 - (16384.499999999996 - v / 360 | 0))) * o;
                  break;

                case e.first:
                case e.replace:
                  v += u.data.rotation - u.rotation;

                case e.add:
                  u.rotation += (v - 360 * (16384 - (16384.499999999996 - v / 360 | 0))) * o;
              }
            }
          }, a.ENTRIES = 2, a.PREV_TIME = -2, a.PREV_ROTATION = -1, a.ROTATION = 1, a;
        }(a);

        t.RotateTimeline = s;

        var o = function (n) {
          function a(e) {
            var i = n.call(this, e) || this;
            return i.frames = t.Utils.newFloatArray(e * a.ENTRIES), i;
          }

          return $(a, n), a.prototype.getPropertyId = function () {
            return (i.translate << 24) + this.boneIndex;
          }, a.prototype.setFrame = function (t, e, n, i) {
            t *= a.ENTRIES, this.frames[t] = e, this.frames[t + a.X] = n, this.frames[t + a.Y] = i;
          }, a.prototype.apply = function (t, n, i, s, o, l) {
            var h = this.frames,
                u = t.bones[this.boneIndex];
            if (u.active) if (i < h[0]) switch (l) {
              case e.setup:
                return u.x = u.data.x, void (u.y = u.data.y);

              case e.first:
                u.x += (u.data.x - u.x) * o, u.y += (u.data.y - u.y) * o;
            } else {
              var c = 0,
                  d = 0;
              if (i >= h[h.length - a.ENTRIES]) c = h[h.length + a.PREV_X], d = h[h.length + a.PREV_Y];else {
                var f = r.binarySearch(h, i, a.ENTRIES);
                c = h[f + a.PREV_X], d = h[f + a.PREV_Y];
                var p = h[f],
                    m = this.getCurvePercent(f / a.ENTRIES - 1, 1 - (i - p) / (h[f + a.PREV_TIME] - p));
                c += (h[f + a.X] - c) * m, d += (h[f + a.Y] - d) * m;
              }

              switch (l) {
                case e.setup:
                  u.x = u.data.x + c * o, u.y = u.data.y + d * o;
                  break;

                case e.first:
                case e.replace:
                  u.x += (u.data.x + c - u.x) * o, u.y += (u.data.y + d - u.y) * o;
                  break;

                case e.add:
                  u.x += c * o, u.y += d * o;
              }
            }
          }, a.ENTRIES = 3, a.PREV_TIME = -3, a.PREV_X = -2, a.PREV_Y = -1, a.X = 1, a.Y = 2, a;
        }(a);

        t.TranslateTimeline = o;

        var l = function (a) {
          function s(t) {
            return a.call(this, t) || this;
          }

          return $(s, a), s.prototype.getPropertyId = function () {
            return (i.scale << 24) + this.boneIndex;
          }, s.prototype.apply = function (i, a, o, l, h, u, c) {
            var d = this.frames,
                f = i.bones[this.boneIndex];
            if (f.active) if (o < d[0]) switch (u) {
              case e.setup:
                return f.scaleX = f.data.scaleX, void (f.scaleY = f.data.scaleY);

              case e.first:
                f.scaleX += (f.data.scaleX - f.scaleX) * h, f.scaleY += (f.data.scaleY - f.scaleY) * h;
            } else {
              var p = 0,
                  m = 0;
              if (o >= d[d.length - s.ENTRIES]) p = d[d.length + s.PREV_X] * f.data.scaleX, m = d[d.length + s.PREV_Y] * f.data.scaleY;else {
                var g = r.binarySearch(d, o, s.ENTRIES);
                p = d[g + s.PREV_X], m = d[g + s.PREV_Y];
                var v = d[g],
                    y = this.getCurvePercent(g / s.ENTRIES - 1, 1 - (o - v) / (d[g + s.PREV_TIME] - v));
                p = (p + (d[g + s.X] - p) * y) * f.data.scaleX, m = (m + (d[g + s.Y] - m) * y) * f.data.scaleY;
              }
              if (1 == h) u == e.add ? (f.scaleX += p - f.data.scaleX, f.scaleY += m - f.data.scaleY) : (f.scaleX = p, f.scaleY = m);else {
                var x = 0,
                    w = 0;
                if (c == n.mixOut) switch (u) {
                  case e.setup:
                    x = f.data.scaleX, w = f.data.scaleY, f.scaleX = x + (Math.abs(p) * t.MathUtils.signum(x) - x) * h, f.scaleY = w + (Math.abs(m) * t.MathUtils.signum(w) - w) * h;
                    break;

                  case e.first:
                  case e.replace:
                    x = f.scaleX, w = f.scaleY, f.scaleX = x + (Math.abs(p) * t.MathUtils.signum(x) - x) * h, f.scaleY = w + (Math.abs(m) * t.MathUtils.signum(w) - w) * h;
                    break;

                  case e.add:
                    x = f.scaleX, w = f.scaleY, f.scaleX = x + (Math.abs(p) * t.MathUtils.signum(x) - f.data.scaleX) * h, f.scaleY = w + (Math.abs(m) * t.MathUtils.signum(w) - f.data.scaleY) * h;
                } else switch (u) {
                  case e.setup:
                    x = Math.abs(f.data.scaleX) * t.MathUtils.signum(p), w = Math.abs(f.data.scaleY) * t.MathUtils.signum(m), f.scaleX = x + (p - x) * h, f.scaleY = w + (m - w) * h;
                    break;

                  case e.first:
                  case e.replace:
                    x = Math.abs(f.scaleX) * t.MathUtils.signum(p), w = Math.abs(f.scaleY) * t.MathUtils.signum(m), f.scaleX = x + (p - x) * h, f.scaleY = w + (m - w) * h;
                    break;

                  case e.add:
                    x = t.MathUtils.signum(p), w = t.MathUtils.signum(m), f.scaleX = Math.abs(f.scaleX) * x + (p - Math.abs(f.data.scaleX) * x) * h, f.scaleY = Math.abs(f.scaleY) * w + (m - Math.abs(f.data.scaleY) * w) * h;
                }
              }
            }
          }, s;
        }(o);

        t.ScaleTimeline = l;

        var h = function (t) {
          function n(e) {
            return t.call(this, e) || this;
          }

          return $(n, t), n.prototype.getPropertyId = function () {
            return (i.shear << 24) + this.boneIndex;
          }, n.prototype.apply = function (t, i, a, s, o, l) {
            var h = this.frames,
                u = t.bones[this.boneIndex];
            if (u.active) if (a < h[0]) switch (l) {
              case e.setup:
                return u.shearX = u.data.shearX, void (u.shearY = u.data.shearY);

              case e.first:
                u.shearX += (u.data.shearX - u.shearX) * o, u.shearY += (u.data.shearY - u.shearY) * o;
            } else {
              var c = 0,
                  d = 0;
              if (a >= h[h.length - n.ENTRIES]) c = h[h.length + n.PREV_X], d = h[h.length + n.PREV_Y];else {
                var f = r.binarySearch(h, a, n.ENTRIES);
                c = h[f + n.PREV_X], d = h[f + n.PREV_Y];
                var p = h[f],
                    m = this.getCurvePercent(f / n.ENTRIES - 1, 1 - (a - p) / (h[f + n.PREV_TIME] - p));
                c += (h[f + n.X] - c) * m, d += (h[f + n.Y] - d) * m;
              }

              switch (l) {
                case e.setup:
                  u.shearX = u.data.shearX + c * o, u.shearY = u.data.shearY + d * o;
                  break;

                case e.first:
                case e.replace:
                  u.shearX += (u.data.shearX + c - u.shearX) * o, u.shearY += (u.data.shearY + d - u.shearY) * o;
                  break;

                case e.add:
                  u.shearX += c * o, u.shearY += d * o;
              }
            }
          }, n;
        }(o);

        t.ShearTimeline = h;

        var u = function (n) {
          function a(e) {
            var i = n.call(this, e) || this;
            return i.frames = t.Utils.newFloatArray(e * a.ENTRIES), i;
          }

          return $(a, n), a.prototype.getPropertyId = function () {
            return (i.color << 24) + this.slotIndex;
          }, a.prototype.setFrame = function (t, e, n, i, r, s) {
            t *= a.ENTRIES, this.frames[t] = e, this.frames[t + a.R] = n, this.frames[t + a.G] = i, this.frames[t + a.B] = r, this.frames[t + a.A] = s;
          }, a.prototype.apply = function (t, n, i, s, o, l) {
            var h = t.slots[this.slotIndex];

            if (h.bone.active) {
              var u = this.frames;
              if (i < u[0]) switch (l) {
                case e.setup:
                  return void h.color.setFromColor(h.data.color);

                case e.first:
                  var c = h.color,
                      d = h.data.color;
                  c.add((d.r - c.r) * o, (d.g - c.g) * o, (d.b - c.b) * o, (d.a - c.a) * o);
              } else {
                var f = 0,
                    p = 0,
                    m = 0,
                    g = 0;

                if (i >= u[u.length - a.ENTRIES]) {
                  var v = u.length;
                  f = u[v + a.PREV_R], p = u[v + a.PREV_G], m = u[v + a.PREV_B], g = u[v + a.PREV_A];
                } else {
                  var y = r.binarySearch(u, i, a.ENTRIES);
                  f = u[y + a.PREV_R], p = u[y + a.PREV_G], m = u[y + a.PREV_B], g = u[y + a.PREV_A];
                  var x = u[y],
                      w = this.getCurvePercent(y / a.ENTRIES - 1, 1 - (i - x) / (u[y + a.PREV_TIME] - x));
                  f += (u[y + a.R] - f) * w, p += (u[y + a.G] - p) * w, m += (u[y + a.B] - m) * w, g += (u[y + a.A] - g) * w;
                }

                1 == o ? h.color.set(f, p, m, g) : (c = h.color, l == e.setup && c.setFromColor(h.data.color), c.add((f - c.r) * o, (p - c.g) * o, (m - c.b) * o, (g - c.a) * o));
              }
            }
          }, a.ENTRIES = 5, a.PREV_TIME = -5, a.PREV_R = -4, a.PREV_G = -3, a.PREV_B = -2, a.PREV_A = -1, a.R = 1, a.G = 2, a.B = 3, a.A = 4, a;
        }(a);

        t.ColorTimeline = u;

        var c = function (n) {
          function a(e) {
            var i = n.call(this, e) || this;
            return i.frames = t.Utils.newFloatArray(e * a.ENTRIES), i;
          }

          return $(a, n), a.prototype.getPropertyId = function () {
            return (i.twoColor << 24) + this.slotIndex;
          }, a.prototype.setFrame = function (t, e, n, i, r, s, o, l, h) {
            t *= a.ENTRIES, this.frames[t] = e, this.frames[t + a.R] = n, this.frames[t + a.G] = i, this.frames[t + a.B] = r, this.frames[t + a.A] = s, this.frames[t + a.R2] = o, this.frames[t + a.G2] = l, this.frames[t + a.B2] = h;
          }, a.prototype.apply = function (t, n, i, s, o, l) {
            var h = t.slots[this.slotIndex];

            if (h.bone.active) {
              var u = this.frames;
              if (i < u[0]) switch (l) {
                case e.setup:
                  return h.color.setFromColor(h.data.color), void h.darkColor.setFromColor(h.data.darkColor);

                case e.first:
                  var c = h.color,
                      d = h.darkColor,
                      f = h.data.color,
                      p = h.data.darkColor;
                  c.add((f.r - c.r) * o, (f.g - c.g) * o, (f.b - c.b) * o, (f.a - c.a) * o), d.add((p.r - d.r) * o, (p.g - d.g) * o, (p.b - d.b) * o, 0);
              } else {
                var m = 0,
                    g = 0,
                    v = 0,
                    y = 0,
                    x = 0,
                    w = 0,
                    _ = 0;

                if (i >= u[u.length - a.ENTRIES]) {
                  var E = u.length;
                  m = u[E + a.PREV_R], g = u[E + a.PREV_G], v = u[E + a.PREV_B], y = u[E + a.PREV_A], x = u[E + a.PREV_R2], w = u[E + a.PREV_G2], _ = u[E + a.PREV_B2];
                } else {
                  var b = r.binarySearch(u, i, a.ENTRIES);
                  m = u[b + a.PREV_R], g = u[b + a.PREV_G], v = u[b + a.PREV_B], y = u[b + a.PREV_A], x = u[b + a.PREV_R2], w = u[b + a.PREV_G2], _ = u[b + a.PREV_B2];
                  var T = u[b],
                      M = this.getCurvePercent(b / a.ENTRIES - 1, 1 - (i - T) / (u[b + a.PREV_TIME] - T));
                  m += (u[b + a.R] - m) * M, g += (u[b + a.G] - g) * M, v += (u[b + a.B] - v) * M, y += (u[b + a.A] - y) * M, x += (u[b + a.R2] - x) * M, w += (u[b + a.G2] - w) * M, _ += (u[b + a.B2] - _) * M;
                }

                1 == o ? (h.color.set(m, g, v, y), h.darkColor.set(x, w, _, 1)) : (c = h.color, d = h.darkColor, l == e.setup && (c.setFromColor(h.data.color), d.setFromColor(h.data.darkColor)), c.add((m - c.r) * o, (g - c.g) * o, (v - c.b) * o, (y - c.a) * o), d.add((x - d.r) * o, (w - d.g) * o, (_ - d.b) * o, 0));
              }
            }
          }, a.ENTRIES = 8, a.PREV_TIME = -8, a.PREV_R = -7, a.PREV_G = -6, a.PREV_B = -5, a.PREV_A = -4, a.PREV_R2 = -3, a.PREV_G2 = -2, a.PREV_B2 = -1, a.R = 1, a.G = 2, a.B = 3, a.A = 4, a.R2 = 5, a.G2 = 6, a.B2 = 7, a;
        }(a);

        t.TwoColorTimeline = c;

        var d = function () {
          function a(e) {
            this.frames = t.Utils.newFloatArray(e), this.attachmentNames = new Array(e);
          }

          return a.prototype.getPropertyId = function () {
            return (i.attachment << 24) + this.slotIndex;
          }, a.prototype.getFrameCount = function () {
            return this.frames.length;
          }, a.prototype.setFrame = function (t, e, n) {
            this.frames[t] = e, this.attachmentNames[t] = n;
          }, a.prototype.apply = function (t, i, a, s, o, l, h) {
            var u = t.slots[this.slotIndex];
            if (u.bone.active) if (h != n.mixOut || l != e.setup) {
              var c = this.frames;

              if (a < c[0]) {
                if (l == e.setup || l == e.first) {
                  var d = u.data.attachmentName;
                  u.setAttachment(null == d ? null : t.getAttachment(this.slotIndex, d));
                }
              } else {
                var f;
                f = a >= c[c.length - 1] ? c.length - 1 : r.binarySearch(c, a, 1) - 1;
                var p = this.attachmentNames[f];
                t.slots[this.slotIndex].setAttachment(null == p ? null : t.getAttachment(this.slotIndex, p));
              }
            } else {
              var m = u.data.attachmentName;
              u.setAttachment(null == m ? null : t.getAttachment(this.slotIndex, m));
            }
          }, a;
        }();

        t.AttachmentTimeline = d;

        var f = null,
            p = function (n) {
          function a(e) {
            var i = n.call(this, e) || this;
            return i.frames = t.Utils.newFloatArray(e), i.frameVertices = new Array(e), null == f && (f = t.Utils.newFloatArray(64)), i;
          }

          return $(a, n), a.prototype.getPropertyId = function () {
            return (i.deform << 27) + +this.attachment.id + this.slotIndex;
          }, a.prototype.setFrame = function (t, e, n) {
            this.frames[t] = e, this.frameVertices[t] = n;
          }, a.prototype.apply = function (n, i, a, s, o, l) {
            var h = n.slots[this.slotIndex];

            if (h.bone.active) {
              var u = h.getAttachment();

              if (u instanceof t.VertexAttachment && u.deformAttachment == this.attachment) {
                var c = h.deform;
                0 == c.length && (l = e.setup);
                var d = this.frameVertices,
                    f = d[0].length,
                    p = this.frames;

                if (a < p[0]) {
                  var m = u;

                  switch (l) {
                    case e.setup:
                      return void (c.length = 0);

                    case e.first:
                      if (1 == o) {
                        c.length = 0;
                        break;
                      }

                      var g = t.Utils.setArraySize(c, f);
                      if (null == m.bones) for (var v = m.vertices, y = 0; y < f; y++) {
                        g[y] += (v[y] - g[y]) * o;
                      } else for (o = 1 - o, y = 0; y < f; y++) {
                        g[y] *= o;
                      }
                  }
                } else {
                  var x = t.Utils.setArraySize(c, f);

                  if (a >= p[p.length - 1]) {
                    var w = d[p.length - 1];
                    if (1 == o) {
                      if (l == e.add) {
                        if (null == (m = u).bones) {
                          v = m.vertices;

                          for (var _ = 0; _ < f; _++) {
                            x[_] += w[_] - v[_];
                          }
                        } else for (var E = 0; E < f; E++) {
                          x[E] += w[E];
                        }
                      } else t.Utils.arrayCopy(w, 0, x, 0, f);
                    } else switch (l) {
                      case e.setup:
                        var b = u;

                        if (null == b.bones) {
                          v = b.vertices;

                          for (var T = 0; T < f; T++) {
                            var M = v[T];
                            x[T] = M + (w[T] - M) * o;
                          }
                        } else for (var A = 0; A < f; A++) {
                          x[A] = w[A] * o;
                        }

                        break;

                      case e.first:
                      case e.replace:
                        for (var C = 0; C < f; C++) {
                          x[C] += (w[C] - x[C]) * o;
                        }

                      case e.add:
                        if (null == (m = u).bones) {
                          v = m.vertices;

                          for (var S = 0; S < f; S++) {
                            x[S] += (w[S] - v[S]) * o;
                          }
                        } else for (var k = 0; k < f; k++) {
                          x[k] += w[k] * o;
                        }

                    }
                  } else {
                    var I = r.binarySearch(p, a),
                        R = d[I - 1],
                        P = d[I],
                        V = p[I],
                        D = this.getCurvePercent(I - 1, 1 - (a - V) / (p[I - 1] - V));
                    if (1 == o) {
                      if (l == e.add) {
                        if (null == (m = u).bones) {
                          v = m.vertices;

                          for (var N = 0; N < f; N++) {
                            var F = R[N];
                            x[N] += F + (P[N] - F) * D - v[N];
                          }
                        } else for (var O = 0; O < f; O++) {
                          F = R[O], x[O] += F + (P[O] - F) * D;
                        }
                      } else for (var L = 0; L < f; L++) {
                        F = R[L], x[L] = F + (P[L] - F) * D;
                      }
                    } else switch (l) {
                      case e.setup:
                        var U = u;

                        if (null == U.bones) {
                          v = U.vertices;

                          for (var B = 0; B < f; B++) {
                            F = R[B], M = v[B], x[B] = M + (F + (P[B] - F) * D - M) * o;
                          }
                        } else for (var Y = 0; Y < f; Y++) {
                          F = R[Y], x[Y] = (F + (P[Y] - F) * D) * o;
                        }

                        break;

                      case e.first:
                      case e.replace:
                        for (var X = 0; X < f; X++) {
                          F = R[X], x[X] += (F + (P[X] - F) * D - x[X]) * o;
                        }

                        break;

                      case e.add:
                        if (null == (m = u).bones) {
                          v = m.vertices;

                          for (var W = 0; W < f; W++) {
                            F = R[W], x[W] += (F + (P[W] - F) * D - v[W]) * o;
                          }
                        } else for (var q = 0; q < f; q++) {
                          F = R[q], x[q] += (F + (P[q] - F) * D) * o;
                        }

                    }
                  }
                }
              }
            }
          }, a;
        }(a);

        t.DeformTimeline = p;

        var m = function () {
          function e(e) {
            this.frames = t.Utils.newFloatArray(e), this.events = new Array(e);
          }

          return e.prototype.getPropertyId = function () {
            return i.event << 24;
          }, e.prototype.getFrameCount = function () {
            return this.frames.length;
          }, e.prototype.setFrame = function (t, e) {
            this.frames[t] = e.time, this.events[t] = e;
          }, e.prototype.apply = function (t, e, n, i, a, s, o) {
            if (null != i) {
              var l = this.frames,
                  h = this.frames.length;
              if (e > n) this.apply(t, e, Number.MAX_VALUE, i, a, s, o), e = -1;else if (e >= l[h - 1]) return;

              if (!(n < l[0])) {
                var u = 0;
                if (e < l[0]) u = 0;else for (var c = l[u = r.binarySearch(l, e)]; u > 0 && l[u - 1] == c;) {
                  u--;
                }

                for (; u < h && n >= l[u]; u++) {
                  i.push(this.events[u]);
                }
              }
            }
          }, e;
        }();

        t.EventTimeline = m;

        var g = function () {
          function a(e) {
            this.frames = t.Utils.newFloatArray(e), this.drawOrders = new Array(e);
          }

          return a.prototype.getPropertyId = function () {
            return i.drawOrder << 24;
          }, a.prototype.getFrameCount = function () {
            return this.frames.length;
          }, a.prototype.setFrame = function (t, e, n) {
            this.frames[t] = e, this.drawOrders[t] = n;
          }, a.prototype.apply = function (i, a, s, o, l, h, u) {
            var c = i.drawOrder,
                d = i.slots;

            if (u != n.mixOut || h != e.setup) {
              var f = this.frames;
              if (s < f[0]) h != e.setup && h != e.first || t.Utils.arrayCopy(i.slots, 0, i.drawOrder, 0, i.slots.length);else {
                var p;
                p = s >= f[f.length - 1] ? f.length - 1 : r.binarySearch(f, s) - 1;
                var m = this.drawOrders[p];
                if (null == m) t.Utils.arrayCopy(d, 0, c, 0, d.length);else for (var g = 0, v = m.length; g < v; g++) {
                  c[g] = d[m[g]];
                }
              }
            } else t.Utils.arrayCopy(i.slots, 0, i.drawOrder, 0, i.slots.length);
          }, a;
        }();

        t.DrawOrderTimeline = g;

        var v = function (a) {
          function s(e) {
            var n = a.call(this, e) || this;
            return n.frames = t.Utils.newFloatArray(e * s.ENTRIES), n;
          }

          return $(s, a), s.prototype.getPropertyId = function () {
            return (i.ikConstraint << 24) + this.ikConstraintIndex;
          }, s.prototype.setFrame = function (t, e, n, i, r, a, o) {
            t *= s.ENTRIES, this.frames[t] = e, this.frames[t + s.MIX] = n, this.frames[t + s.SOFTNESS] = i, this.frames[t + s.BEND_DIRECTION] = r, this.frames[t + s.COMPRESS] = a ? 1 : 0, this.frames[t + s.STRETCH] = o ? 1 : 0;
          }, s.prototype.apply = function (t, i, a, o, l, h, u) {
            var c = this.frames,
                d = t.ikConstraints[this.ikConstraintIndex];
            if (d.active) if (a < c[0]) switch (h) {
              case e.setup:
                return d.mix = d.data.mix, d.softness = d.data.softness, d.bendDirection = d.data.bendDirection, d.compress = d.data.compress, void (d.stretch = d.data.stretch);

              case e.first:
                d.mix += (d.data.mix - d.mix) * l, d.softness += (d.data.softness - d.softness) * l, d.bendDirection = d.data.bendDirection, d.compress = d.data.compress, d.stretch = d.data.stretch;
            } else if (a >= c[c.length - s.ENTRIES]) h == e.setup ? (d.mix = d.data.mix + (c[c.length + s.PREV_MIX] - d.data.mix) * l, d.softness = d.data.softness + (c[c.length + s.PREV_SOFTNESS] - d.data.softness) * l, u == n.mixOut ? (d.bendDirection = d.data.bendDirection, d.compress = d.data.compress, d.stretch = d.data.stretch) : (d.bendDirection = c[c.length + s.PREV_BEND_DIRECTION], d.compress = 0 != c[c.length + s.PREV_COMPRESS], d.stretch = 0 != c[c.length + s.PREV_STRETCH])) : (d.mix += (c[c.length + s.PREV_MIX] - d.mix) * l, d.softness += (c[c.length + s.PREV_SOFTNESS] - d.softness) * l, u == n.mixIn && (d.bendDirection = c[c.length + s.PREV_BEND_DIRECTION], d.compress = 0 != c[c.length + s.PREV_COMPRESS], d.stretch = 0 != c[c.length + s.PREV_STRETCH]));else {
              var f = r.binarySearch(c, a, s.ENTRIES),
                  p = c[f + s.PREV_MIX],
                  m = c[f + s.PREV_SOFTNESS],
                  g = c[f],
                  v = this.getCurvePercent(f / s.ENTRIES - 1, 1 - (a - g) / (c[f + s.PREV_TIME] - g));
              h == e.setup ? (d.mix = d.data.mix + (p + (c[f + s.MIX] - p) * v - d.data.mix) * l, d.softness = d.data.softness + (m + (c[f + s.SOFTNESS] - m) * v - d.data.softness) * l, u == n.mixOut ? (d.bendDirection = d.data.bendDirection, d.compress = d.data.compress, d.stretch = d.data.stretch) : (d.bendDirection = c[f + s.PREV_BEND_DIRECTION], d.compress = 0 != c[f + s.PREV_COMPRESS], d.stretch = 0 != c[f + s.PREV_STRETCH])) : (d.mix += (p + (c[f + s.MIX] - p) * v - d.mix) * l, d.softness += (m + (c[f + s.SOFTNESS] - m) * v - d.softness) * l, u == n.mixIn && (d.bendDirection = c[f + s.PREV_BEND_DIRECTION], d.compress = 0 != c[f + s.PREV_COMPRESS], d.stretch = 0 != c[f + s.PREV_STRETCH]));
            }
          }, s.ENTRIES = 6, s.PREV_TIME = -6, s.PREV_MIX = -5, s.PREV_SOFTNESS = -4, s.PREV_BEND_DIRECTION = -3, s.PREV_COMPRESS = -2, s.PREV_STRETCH = -1, s.MIX = 1, s.SOFTNESS = 2, s.BEND_DIRECTION = 3, s.COMPRESS = 4, s.STRETCH = 5, s;
        }(a);

        t.IkConstraintTimeline = v;

        var y = function (n) {
          function a(e) {
            var i = n.call(this, e) || this;
            return i.frames = t.Utils.newFloatArray(e * a.ENTRIES), i;
          }

          return $(a, n), a.prototype.getPropertyId = function () {
            return (i.transformConstraint << 24) + this.transformConstraintIndex;
          }, a.prototype.setFrame = function (t, e, n, i, r, s) {
            t *= a.ENTRIES, this.frames[t] = e, this.frames[t + a.ROTATE] = n, this.frames[t + a.TRANSLATE] = i, this.frames[t + a.SCALE] = r, this.frames[t + a.SHEAR] = s;
          }, a.prototype.apply = function (t, n, i, s, o, l) {
            var h = this.frames,
                u = t.transformConstraints[this.transformConstraintIndex];
            if (u.active) if (i < h[0]) {
              var c = u.data;

              switch (l) {
                case e.setup:
                  return u.rotateMix = c.rotateMix, u.translateMix = c.translateMix, u.scaleMix = c.scaleMix, void (u.shearMix = c.shearMix);

                case e.first:
                  u.rotateMix += (c.rotateMix - u.rotateMix) * o, u.translateMix += (c.translateMix - u.translateMix) * o, u.scaleMix += (c.scaleMix - u.scaleMix) * o, u.shearMix += (c.shearMix - u.shearMix) * o;
              }
            } else {
              var d = 0,
                  f = 0,
                  p = 0,
                  m = 0;

              if (i >= h[h.length - a.ENTRIES]) {
                var g = h.length;
                d = h[g + a.PREV_ROTATE], f = h[g + a.PREV_TRANSLATE], p = h[g + a.PREV_SCALE], m = h[g + a.PREV_SHEAR];
              } else {
                var v = r.binarySearch(h, i, a.ENTRIES);
                d = h[v + a.PREV_ROTATE], f = h[v + a.PREV_TRANSLATE], p = h[v + a.PREV_SCALE], m = h[v + a.PREV_SHEAR];
                var y = h[v],
                    x = this.getCurvePercent(v / a.ENTRIES - 1, 1 - (i - y) / (h[v + a.PREV_TIME] - y));
                d += (h[v + a.ROTATE] - d) * x, f += (h[v + a.TRANSLATE] - f) * x, p += (h[v + a.SCALE] - p) * x, m += (h[v + a.SHEAR] - m) * x;
              }

              l == e.setup ? (c = u.data, u.rotateMix = c.rotateMix + (d - c.rotateMix) * o, u.translateMix = c.translateMix + (f - c.translateMix) * o, u.scaleMix = c.scaleMix + (p - c.scaleMix) * o, u.shearMix = c.shearMix + (m - c.shearMix) * o) : (u.rotateMix += (d - u.rotateMix) * o, u.translateMix += (f - u.translateMix) * o, u.scaleMix += (p - u.scaleMix) * o, u.shearMix += (m - u.shearMix) * o);
            }
          }, a.ENTRIES = 5, a.PREV_TIME = -5, a.PREV_ROTATE = -4, a.PREV_TRANSLATE = -3, a.PREV_SCALE = -2, a.PREV_SHEAR = -1, a.ROTATE = 1, a.TRANSLATE = 2, a.SCALE = 3, a.SHEAR = 4, a;
        }(a);

        t.TransformConstraintTimeline = y;

        var x = function (n) {
          function a(e) {
            var i = n.call(this, e) || this;
            return i.frames = t.Utils.newFloatArray(e * a.ENTRIES), i;
          }

          return $(a, n), a.prototype.getPropertyId = function () {
            return (i.pathConstraintPosition << 24) + this.pathConstraintIndex;
          }, a.prototype.setFrame = function (t, e, n) {
            t *= a.ENTRIES, this.frames[t] = e, this.frames[t + a.VALUE] = n;
          }, a.prototype.apply = function (t, n, i, s, o, l) {
            var h = this.frames,
                u = t.pathConstraints[this.pathConstraintIndex];
            if (u.active) if (i < h[0]) switch (l) {
              case e.setup:
                return void (u.position = u.data.position);

              case e.first:
                u.position += (u.data.position - u.position) * o;
            } else {
              var c = 0;
              if (i >= h[h.length - a.ENTRIES]) c = h[h.length + a.PREV_VALUE];else {
                var d = r.binarySearch(h, i, a.ENTRIES);
                c = h[d + a.PREV_VALUE];
                var f = h[d],
                    p = this.getCurvePercent(d / a.ENTRIES - 1, 1 - (i - f) / (h[d + a.PREV_TIME] - f));
                c += (h[d + a.VALUE] - c) * p;
              }
              l == e.setup ? u.position = u.data.position + (c - u.data.position) * o : u.position += (c - u.position) * o;
            }
          }, a.ENTRIES = 2, a.PREV_TIME = -2, a.PREV_VALUE = -1, a.VALUE = 1, a;
        }(a);

        t.PathConstraintPositionTimeline = x;

        var w = function (t) {
          function n(e) {
            return t.call(this, e) || this;
          }

          return $(n, t), n.prototype.getPropertyId = function () {
            return (i.pathConstraintSpacing << 24) + this.pathConstraintIndex;
          }, n.prototype.apply = function (t, i, a, s, o, l) {
            var h = this.frames,
                u = t.pathConstraints[this.pathConstraintIndex];
            if (u.active) if (a < h[0]) switch (l) {
              case e.setup:
                return void (u.spacing = u.data.spacing);

              case e.first:
                u.spacing += (u.data.spacing - u.spacing) * o;
            } else {
              var c = 0;
              if (a >= h[h.length - n.ENTRIES]) c = h[h.length + n.PREV_VALUE];else {
                var d = r.binarySearch(h, a, n.ENTRIES);
                c = h[d + n.PREV_VALUE];
                var f = h[d],
                    p = this.getCurvePercent(d / n.ENTRIES - 1, 1 - (a - f) / (h[d + n.PREV_TIME] - f));
                c += (h[d + n.VALUE] - c) * p;
              }
              l == e.setup ? u.spacing = u.data.spacing + (c - u.data.spacing) * o : u.spacing += (c - u.spacing) * o;
            }
          }, n;
        }(x);

        t.PathConstraintSpacingTimeline = w;

        var _ = function (n) {
          function a(e) {
            var i = n.call(this, e) || this;
            return i.frames = t.Utils.newFloatArray(e * a.ENTRIES), i;
          }

          return $(a, n), a.prototype.getPropertyId = function () {
            return (i.pathConstraintMix << 24) + this.pathConstraintIndex;
          }, a.prototype.setFrame = function (t, e, n, i) {
            t *= a.ENTRIES, this.frames[t] = e, this.frames[t + a.ROTATE] = n, this.frames[t + a.TRANSLATE] = i;
          }, a.prototype.apply = function (t, n, i, s, o, l) {
            var h = this.frames,
                u = t.pathConstraints[this.pathConstraintIndex];
            if (u.active) if (i < h[0]) switch (l) {
              case e.setup:
                return u.rotateMix = u.data.rotateMix, void (u.translateMix = u.data.translateMix);

              case e.first:
                u.rotateMix += (u.data.rotateMix - u.rotateMix) * o, u.translateMix += (u.data.translateMix - u.translateMix) * o;
            } else {
              var c = 0,
                  d = 0;
              if (i >= h[h.length - a.ENTRIES]) c = h[h.length + a.PREV_ROTATE], d = h[h.length + a.PREV_TRANSLATE];else {
                var f = r.binarySearch(h, i, a.ENTRIES);
                c = h[f + a.PREV_ROTATE], d = h[f + a.PREV_TRANSLATE];
                var p = h[f],
                    m = this.getCurvePercent(f / a.ENTRIES - 1, 1 - (i - p) / (h[f + a.PREV_TIME] - p));
                c += (h[f + a.ROTATE] - c) * m, d += (h[f + a.TRANSLATE] - d) * m;
              }
              l == e.setup ? (u.rotateMix = u.data.rotateMix + (c - u.data.rotateMix) * o, u.translateMix = u.data.translateMix + (d - u.data.translateMix) * o) : (u.rotateMix += (c - u.rotateMix) * o, u.translateMix += (d - u.translateMix) * o);
            }
          }, a.ENTRIES = 3, a.PREV_TIME = -3, a.PREV_ROTATE = -2, a.PREV_TRANSLATE = -1, a.ROTATE = 1, a.TRANSLATE = 2, a;
        }(a);

        t.PathConstraintMixTimeline = _;
      }(K || (K = {})), function (t) {
        var e = function () {
          function e(e) {
            this.tracks = new Array(), this.timeScale = 1, this.events = new Array(), this.listeners = new Array(), this.queue = new r(this), this.propertyIDs = new t.IntSet(), this.animationsChanged = !1, this.trackEntryPool = new t.Pool(function () {
              return new n();
            }), this.data = e;
          }

          return e.prototype.update = function (t) {
            t *= this.timeScale;

            for (var e = this.tracks, n = 0, i = e.length; n < i; n++) {
              var r = e[n];

              if (null != r) {
                r.animationLast = r.nextAnimationLast, r.trackLast = r.nextTrackLast;
                var a = t * r.timeScale;

                if (r.delay > 0) {
                  if (r.delay -= a, r.delay > 0) continue;
                  a = -r.delay, r.delay = 0;
                }

                var s = r.next;

                if (null != s) {
                  var o = r.trackLast - s.delay;

                  if (o >= 0) {
                    for (s.delay = 0, s.trackTime += 0 == r.timeScale ? 0 : (o / r.timeScale + t) * s.timeScale, r.trackTime += a, this.setCurrent(n, s, !0); null != s.mixingFrom;) {
                      s.mixTime += t, s = s.mixingFrom;
                    }

                    continue;
                  }
                } else if (r.trackLast >= r.trackEnd && null == r.mixingFrom) {
                  e[n] = null, this.queue.end(r), this.disposeNext(r);
                  continue;
                }

                if (null != r.mixingFrom && this.updateMixingFrom(r, t)) {
                  var l = r.mixingFrom;

                  for (r.mixingFrom = null, null != l && (l.mixingTo = null); null != l;) {
                    this.queue.end(l), l = l.mixingFrom;
                  }
                }

                r.trackTime += a;
              }
            }

            this.queue.drain();
          }, e.prototype.updateMixingFrom = function (t, e) {
            var n = t.mixingFrom;
            if (null == n) return !0;
            var i = this.updateMixingFrom(n, e);
            return n.animationLast = n.nextAnimationLast, n.trackLast = n.nextTrackLast, t.mixTime > 0 && t.mixTime >= t.mixDuration ? (0 != n.totalAlpha && 0 != t.mixDuration || (t.mixingFrom = n.mixingFrom, null != n.mixingFrom && (n.mixingFrom.mixingTo = t), t.interruptAlpha = n.interruptAlpha, this.queue.end(n)), i) : (n.trackTime += e * n.timeScale, t.mixTime += e, !1);
          }, e.prototype.apply = function (n) {
            if (null == n) throw new Error("skeleton cannot be null.");
            this.animationsChanged && this._animationsChanged();

            for (var i = this.events, r = this.tracks, a = !1, s = 0, o = r.length; s < o; s++) {
              var l = r[s];

              if (!(null == l || l.delay > 0)) {
                a = !0;
                var h = 0 == s ? t.MixBlend.first : l.mixBlend,
                    u = l.alpha;
                null != l.mixingFrom ? u *= this.applyMixingFrom(l, n, h) : l.trackTime >= l.trackEnd && null == l.next && (u = 0);
                var c = l.animationLast,
                    d = l.getAnimationTime(),
                    f = l.animation.timelines.length,
                    p = l.animation.timelines;
                if (0 == s && 1 == u || h == t.MixBlend.add) for (var m = 0; m < f; m++) {
                  t.Utils.webkit602BugfixHelper(u, h), p[m].apply(n, c, d, i, u, h, t.MixDirection.mixIn);
                } else {
                  var g = l.timelineMode,
                      v = 0 == l.timelinesRotation.length;
                  v && t.Utils.setArraySize(l.timelinesRotation, f << 1, null);
                  var y = l.timelinesRotation;

                  for (m = 0; m < f; m++) {
                    var x = p[m],
                        w = (g[m] & e.NOT_LAST - 1) == e.SUBSEQUENT ? h : t.MixBlend.setup;
                    x instanceof t.RotateTimeline ? this.applyRotateTimeline(x, n, d, u, w, y, m << 1, v) : (t.Utils.webkit602BugfixHelper(u, h), x.apply(n, c, d, i, u, w, t.MixDirection.mixIn));
                  }
                }
                this.queueEvents(l, d), i.length = 0, l.nextAnimationLast = d, l.nextTrackLast = l.trackTime;
              }
            }

            return this.queue.drain(), a;
          }, e.prototype.applyMixingFrom = function (n, i, r) {
            var a = n.mixingFrom;
            null != a.mixingFrom && this.applyMixingFrom(a, i, r);
            var s = 0;
            0 == n.mixDuration ? (s = 1, r == t.MixBlend.first && (r = t.MixBlend.setup)) : ((s = n.mixTime / n.mixDuration) > 1 && (s = 1), r != t.MixBlend.first && (r = a.mixBlend));
            var o = s < a.eventThreshold ? this.events : null,
                l = s < a.attachmentThreshold,
                h = s < a.drawOrderThreshold,
                u = a.animationLast,
                c = a.getAnimationTime(),
                d = a.animation.timelines.length,
                f = a.animation.timelines,
                p = a.alpha * n.interruptAlpha,
                m = p * (1 - s);
            if (r == t.MixBlend.add) for (var g = 0; g < d; g++) {
              f[g].apply(i, u, c, o, m, r, t.MixDirection.mixOut);
            } else {
              var v = a.timelineMode,
                  y = a.timelineHoldMix,
                  x = 0 == a.timelinesRotation.length;
              x && t.Utils.setArraySize(a.timelinesRotation, d << 1, null);
              var w = a.timelinesRotation;

              for (a.totalAlpha = 0, g = 0; g < d; g++) {
                var _ = f[g],
                    E = t.MixDirection.mixOut,
                    b = void 0,
                    T = 0;

                switch (v[g] & e.NOT_LAST - 1) {
                  case e.SUBSEQUENT:
                    if (b = r, !l && _ instanceof t.AttachmentTimeline) {
                      if ((v[g] & e.NOT_LAST) == e.NOT_LAST) continue;
                      b = t.MixBlend.setup;
                    }

                    if (!h && _ instanceof t.DrawOrderTimeline) continue;
                    T = m;
                    break;

                  case e.FIRST:
                    b = t.MixBlend.setup, T = m;
                    break;

                  case e.HOLD:
                    b = t.MixBlend.setup, T = p;
                    break;

                  default:
                    b = t.MixBlend.setup;
                    var M = y[g];
                    T = p * Math.max(0, 1 - M.mixTime / M.mixDuration);
                }

                a.totalAlpha += T, _ instanceof t.RotateTimeline ? this.applyRotateTimeline(_, i, c, T, b, w, g << 1, x) : (t.Utils.webkit602BugfixHelper(T, r), b == t.MixBlend.setup && (_ instanceof t.AttachmentTimeline ? (l || (v[g] & e.NOT_LAST) == e.NOT_LAST) && (E = t.MixDirection.mixIn) : _ instanceof t.DrawOrderTimeline && h && (E = t.MixDirection.mixIn)), _.apply(i, u, c, o, T, b, E));
              }
            }
            return n.mixDuration > 0 && this.queueEvents(a, c), this.events.length = 0, a.nextAnimationLast = c, a.nextTrackLast = a.trackTime, s;
          }, e.prototype.applyRotateTimeline = function (e, n, i, r, a, s, o, l) {
            if (l && (s[o] = 0), 1 != r) {
              var h = e,
                  u = h.frames,
                  c = n.bones[h.boneIndex];

              if (c.active) {
                var d = 0,
                    f = 0;
                if (i < u[0]) switch (a) {
                  case t.MixBlend.setup:
                    c.rotation = c.data.rotation;

                  default:
                    return;

                  case t.MixBlend.first:
                    d = c.rotation, f = c.data.rotation;
                } else if (d = a == t.MixBlend.setup ? c.data.rotation : c.rotation, i >= u[u.length - t.RotateTimeline.ENTRIES]) f = c.data.rotation + u[u.length + t.RotateTimeline.PREV_ROTATION];else {
                  var p = t.Animation.binarySearch(u, i, t.RotateTimeline.ENTRIES),
                      m = u[p + t.RotateTimeline.PREV_ROTATION],
                      g = u[p],
                      v = h.getCurvePercent((p >> 1) - 1, 1 - (i - g) / (u[p + t.RotateTimeline.PREV_TIME] - g));
                  f = u[p + t.RotateTimeline.ROTATION] - m, f = m + (f -= 360 * (16384 - (16384.499999999996 - f / 360 | 0))) * v + c.data.rotation, f -= 360 * (16384 - (16384.499999999996 - f / 360 | 0));
                }
                var y = 0,
                    x = f - d;
                if (0 == (x -= 360 * (16384 - (16384.499999999996 - x / 360 | 0)))) y = s[o];else {
                  var w = 0,
                      _ = 0;
                  l ? (w = 0, _ = x) : (w = s[o], _ = s[o + 1]);
                  var E = x > 0,
                      b = w >= 0;
                  t.MathUtils.signum(_) != t.MathUtils.signum(x) && Math.abs(_) <= 90 && (Math.abs(w) > 180 && (w += 360 * t.MathUtils.signum(w)), b = E), y = x + w - w % 360, b != E && (y += 360 * t.MathUtils.signum(w)), s[o] = y;
                }
                s[o + 1] = x, d += y * r, c.rotation = d - 360 * (16384 - (16384.499999999996 - d / 360 | 0));
              }
            } else e.apply(n, 0, i, null, 1, a, t.MixDirection.mixIn);
          }, e.prototype.queueEvents = function (t, e) {
            for (var n = t.animationStart, i = t.animationEnd, r = i - n, a = t.trackLast % r, s = this.events, o = 0, l = s.length; o < l; o++) {
              var h = s[o];
              if (h.time < a) break;
              h.time > i || this.queue.event(t, h);
            }

            for ((t.loop ? 0 == r || a > t.trackTime % r : e >= i && t.animationLast < i) && this.queue.complete(t); o < l; o++) {
              s[o].time < n || this.queue.event(t, s[o]);
            }
          }, e.prototype.clearTracks = function () {
            var t = this.queue.drainDisabled;
            this.queue.drainDisabled = !0;

            for (var e = 0, n = this.tracks.length; e < n; e++) {
              this.clearTrack(e);
            }

            this.tracks.length = 0, this.queue.drainDisabled = t, this.queue.drain();
          }, e.prototype.clearTrack = function (t) {
            if (!(t >= this.tracks.length)) {
              var e = this.tracks[t];

              if (null != e) {
                this.queue.end(e), this.disposeNext(e);

                for (var n = e;;) {
                  var i = n.mixingFrom;
                  if (null == i) break;
                  this.queue.end(i), n.mixingFrom = null, n.mixingTo = null, n = i;
                }

                this.tracks[e.trackIndex] = null, this.queue.drain();
              }
            }
          }, e.prototype.setCurrent = function (t, e, n) {
            var i = this.expandToIndex(t);
            this.tracks[t] = e, null != i && (n && this.queue.interrupt(i), e.mixingFrom = i, i.mixingTo = e, e.mixTime = 0, null != i.mixingFrom && i.mixDuration > 0 && (e.interruptAlpha *= Math.min(1, i.mixTime / i.mixDuration)), i.timelinesRotation.length = 0), this.queue.start(e);
          }, e.prototype.setAnimation = function (t, e, n) {
            var i = this.data.skeletonData.findAnimation(e);
            if (null == i) throw new Error("Animation not found: " + e);
            return this.setAnimationWith(t, i, n);
          }, e.prototype.setAnimationWith = function (t, e, n) {
            if (null == e) throw new Error("animation cannot be null.");
            var i = !0,
                r = this.expandToIndex(t);
            null != r && (-1 == r.nextTrackLast ? (this.tracks[t] = r.mixingFrom, this.queue.interrupt(r), this.queue.end(r), this.disposeNext(r), r = r.mixingFrom, i = !1) : this.disposeNext(r));
            var a = this.trackEntry(t, e, n, r);
            return this.setCurrent(t, a, i), this.queue.drain(), a;
          }, e.prototype.addAnimation = function (t, e, n, i) {
            var r = this.data.skeletonData.findAnimation(e);
            if (null == r) throw new Error("Animation not found: " + e);
            return this.addAnimationWith(t, r, n, i);
          }, e.prototype.addAnimationWith = function (t, e, n, i) {
            if (null == e) throw new Error("animation cannot be null.");
            var r = this.expandToIndex(t);
            if (null != r) for (; null != r.next;) {
              r = r.next;
            }
            var a = this.trackEntry(t, e, n, r);
            if (null == r) this.setCurrent(t, a, !0), this.queue.drain();else if (r.next = a, i <= 0) {
              var s = r.animationEnd - r.animationStart;
              0 != s ? (r.loop ? i += s * (1 + (r.trackTime / s | 0)) : i += Math.max(s, r.trackTime), i -= this.data.getMix(r.animation, e)) : i = r.trackTime;
            }
            return a.delay = i, a;
          }, e.prototype.setEmptyAnimation = function (t, n) {
            var i = this.setAnimationWith(t, e.emptyAnimation, !1);
            return i.mixDuration = n, i.trackEnd = n, i;
          }, e.prototype.addEmptyAnimation = function (t, n, i) {
            i <= 0 && (i -= n);
            var r = this.addAnimationWith(t, e.emptyAnimation, !1, i);
            return r.mixDuration = n, r.trackEnd = n, r;
          }, e.prototype.setEmptyAnimations = function (t) {
            var e = this.queue.drainDisabled;
            this.queue.drainDisabled = !0;

            for (var n = 0, i = this.tracks.length; n < i; n++) {
              var r = this.tracks[n];
              null != r && this.setEmptyAnimation(r.trackIndex, t);
            }

            this.queue.drainDisabled = e, this.queue.drain();
          }, e.prototype.expandToIndex = function (e) {
            return e < this.tracks.length ? this.tracks[e] : (t.Utils.ensureArrayCapacity(this.tracks, e + 1, null), this.tracks.length = e + 1, null);
          }, e.prototype.trackEntry = function (t, e, n, i) {
            var r = this.trackEntryPool.obtain();
            return r.trackIndex = t, r.animation = e, r.loop = n, r.holdPrevious = !1, r.eventThreshold = 0, r.attachmentThreshold = 0, r.drawOrderThreshold = 0, r.animationStart = 0, r.animationEnd = e.duration, r.animationLast = -1, r.nextAnimationLast = -1, r.delay = 0, r.trackTime = 0, r.trackLast = -1, r.nextTrackLast = -1, r.trackEnd = Number.MAX_VALUE, r.timeScale = 1, r.alpha = 1, r.interruptAlpha = 1, r.mixTime = 0, r.mixDuration = null == i ? 0 : this.data.getMix(i.animation, e), r;
          }, e.prototype.disposeNext = function (t) {
            for (var e = t.next; null != e;) {
              this.queue.dispose(e), e = e.next;
            }

            t.next = null;
          }, e.prototype._animationsChanged = function () {
            this.animationsChanged = !1, this.propertyIDs.clear();

            for (var e = 0, n = this.tracks.length; e < n; e++) {
              if (null != (i = this.tracks[e])) {
                for (; null != i.mixingFrom;) {
                  i = i.mixingFrom;
                }

                do {
                  null != i.mixingFrom && i.mixBlend == t.MixBlend.add || this.computeHold(i), i = i.mixingTo;
                } while (null != i);
              }
            }

            for (this.propertyIDs.clear(), e = this.tracks.length - 1; e >= 0; e--) {
              for (var i = this.tracks[e]; null != i;) {
                this.computeNotLast(i), i = i.mixingFrom;
              }
            }
          }, e.prototype.computeHold = function (n) {
            var i = n.mixingTo,
                r = n.animation.timelines,
                a = n.animation.timelines.length,
                s = t.Utils.setArraySize(n.timelineMode, a);
            n.timelineHoldMix.length = 0;
            var o = t.Utils.setArraySize(n.timelineHoldMix, a),
                l = this.propertyIDs;
            if (null != i && i.holdPrevious) for (var h = 0; h < a; h++) {
              l.add(r[h].getPropertyId()), s[h] = e.HOLD;
            } else t: for (h = 0; h < a; h++) {
              var u = r[h],
                  c = u.getPropertyId();
              if (l.add(c)) {
                if (null == i || u instanceof t.AttachmentTimeline || u instanceof t.DrawOrderTimeline || u instanceof t.EventTimeline || !i.animation.hasTimeline(c)) s[h] = e.FIRST;else {
                  for (var d = i.mixingTo; null != d; d = d.mixingTo) {
                    if (!d.animation.hasTimeline(c)) {
                      if (n.mixDuration > 0) {
                        s[h] = e.HOLD_MIX, o[h] = d;
                        continue t;
                      }

                      break;
                    }
                  }

                  s[h] = e.HOLD;
                }
              } else s[h] = e.SUBSEQUENT;
            }
          }, e.prototype.computeNotLast = function (n) {
            for (var i = n.animation.timelines, r = n.animation.timelines.length, a = n.timelineMode, s = this.propertyIDs, o = 0; o < r; o++) {
              if (i[o] instanceof t.AttachmentTimeline) {
                var l = i[o];
                s.add(l.slotIndex) || (a[o] |= e.NOT_LAST);
              }
            }
          }, e.prototype.getCurrent = function (t) {
            return t >= this.tracks.length ? null : this.tracks[t];
          }, e.prototype.addListener = function (t) {
            if (null == t) throw new Error("listener cannot be null.");
            this.listeners.push(t);
          }, e.prototype.removeListener = function (t) {
            var e = this.listeners.indexOf(t);
            e >= 0 && this.listeners.splice(e, 1);
          }, e.prototype.clearListeners = function () {
            this.listeners.length = 0;
          }, e.prototype.clearListenerNotifications = function () {
            this.queue.clear();
          }, e.emptyAnimation = new t.Animation("<empty>", [], 0), e.SUBSEQUENT = 0, e.FIRST = 1, e.HOLD = 2, e.HOLD_MIX = 3, e.NOT_LAST = 4, e;
        }();

        t.AnimationState = e;

        var n = function () {
          function e() {
            this.mixBlend = t.MixBlend.replace, this.timelineMode = new Array(), this.timelineHoldMix = new Array(), this.timelinesRotation = new Array();
          }

          return e.prototype.reset = function () {
            this.next = null, this.mixingFrom = null, this.mixingTo = null, this.animation = null, this.listener = null, this.timelineMode.length = 0, this.timelineHoldMix.length = 0, this.timelinesRotation.length = 0;
          }, e.prototype.getAnimationTime = function () {
            if (this.loop) {
              var t = this.animationEnd - this.animationStart;
              return 0 == t ? this.animationStart : this.trackTime % t + this.animationStart;
            }

            return Math.min(this.trackTime + this.animationStart, this.animationEnd);
          }, e.prototype.setAnimationLast = function (t) {
            this.animationLast = t, this.nextAnimationLast = t;
          }, e.prototype.isComplete = function () {
            return this.trackTime >= this.animationEnd - this.animationStart;
          }, e.prototype.resetRotationDirections = function () {
            this.timelinesRotation.length = 0;
          }, e;
        }();

        t.TrackEntry = n;

        var i,
            r = function () {
          function t(t) {
            this.objects = [], this.drainDisabled = !1, this.animState = t;
          }

          return t.prototype.start = function (t) {
            this.objects.push(i.start), this.objects.push(t), this.animState.animationsChanged = !0;
          }, t.prototype.interrupt = function (t) {
            this.objects.push(i.interrupt), this.objects.push(t);
          }, t.prototype.end = function (t) {
            this.objects.push(i.end), this.objects.push(t), this.animState.animationsChanged = !0;
          }, t.prototype.dispose = function (t) {
            this.objects.push(i.dispose), this.objects.push(t);
          }, t.prototype.complete = function (t) {
            this.objects.push(i.complete), this.objects.push(t);
          }, t.prototype.event = function (t, e) {
            this.objects.push(i.event), this.objects.push(t), this.objects.push(e);
          }, t.prototype.drain = function () {
            if (!this.drainDisabled) {
              this.drainDisabled = !0;

              for (var t = this.objects, e = this.animState.listeners, n = 0; n < t.length; n += 2) {
                var r = t[n],
                    a = t[n + 1];

                switch (r) {
                  case i.start:
                    null != a.listener && a.listener.start && a.listener.start(a);

                    for (var s = 0; s < e.length; s++) {
                      e[s].start && e[s].start(a);
                    }

                    break;

                  case i.interrupt:
                    for (null != a.listener && a.listener.interrupt && a.listener.interrupt(a), s = 0; s < e.length; s++) {
                      e[s].interrupt && e[s].interrupt(a);
                    }

                    break;

                  case i.end:
                    for (null != a.listener && a.listener.end && a.listener.end(a), s = 0; s < e.length; s++) {
                      e[s].end && e[s].end(a);
                    }

                  case i.dispose:
                    for (null != a.listener && a.listener.dispose && a.listener.dispose(a), s = 0; s < e.length; s++) {
                      e[s].dispose && e[s].dispose(a);
                    }

                    this.animState.trackEntryPool.free(a);
                    break;

                  case i.complete:
                    for (null != a.listener && a.listener.complete && a.listener.complete(a), s = 0; s < e.length; s++) {
                      e[s].complete && e[s].complete(a);
                    }

                    break;

                  case i.event:
                    var o = t[2 + n++];

                    for (null != a.listener && a.listener.event && a.listener.event(a, o), s = 0; s < e.length; s++) {
                      e[s].event && e[s].event(a, o);
                    }

                }
              }

              this.clear(), this.drainDisabled = !1;
            }
          }, t.prototype.clear = function () {
            this.objects.length = 0;
          }, t;
        }();

        t.EventQueue = r, function (t) {
          t[t.start = 0] = "start", t[t.interrupt = 1] = "interrupt", t[t.end = 2] = "end", t[t.dispose = 3] = "dispose", t[t.complete = 4] = "complete", t[t.event = 5] = "event";
        }(i = t.EventType || (t.EventType = {}));

        var a = function () {
          function t() {}

          return t.prototype.start = function () {}, t.prototype.interrupt = function () {}, t.prototype.end = function () {}, t.prototype.dispose = function () {}, t.prototype.complete = function () {}, t.prototype.event = function () {}, t;
        }();

        t.AnimationStateAdapter = a;
      }(K || (K = {})), function (t) {
        var e = function () {
          function t(t) {
            if (this.animationToMixTime = {}, this.defaultMix = 0, null == t) throw new Error("skeletonData cannot be null.");
            this.skeletonData = t;
          }

          return t.prototype.setMix = function (t, e, n) {
            var i = this.skeletonData.findAnimation(t);
            if (null == i) throw new Error("Animation not found: " + t);
            var r = this.skeletonData.findAnimation(e);
            if (null == r) throw new Error("Animation not found: " + e);
            this.setMixWith(i, r, n);
          }, t.prototype.setMixWith = function (t, e, n) {
            if (null == t) throw new Error("from cannot be null.");
            if (null == e) throw new Error("to cannot be null.");
            var i = t.name + "." + e.name;
            this.animationToMixTime[i] = n;
          }, t.prototype.getMix = function (t, e) {
            var n = t.name + "." + e.name,
                i = this.animationToMixTime[n];
            return void 0 === i ? this.defaultMix : i;
          }, t;
        }();

        t.AnimationStateData = e;
      }(K || (K = {})), function (t) {
        var e = function () {
          function e(t, e) {
            void 0 === e && (e = ""), this.assets = {}, this.errors = {}, this.toLoad = 0, this.loaded = 0, this.textureLoader = t, this.pathPrefix = e;
          }

          return e.downloadText = function (t, e, n) {
            var i = new XMLHttpRequest();
            i.open("GET", t, !0), i.onload = function () {
              200 == i.status ? e(i.responseText) : n(i.status, i.responseText);
            }, i.onerror = function () {
              n(i.status, i.responseText);
            }, i.send();
          }, e.downloadBinary = function (t, e, n) {
            var i = new XMLHttpRequest();
            i.open("GET", t, !0), i.responseType = "arraybuffer", i.onload = function () {
              200 == i.status ? e(new Uint8Array(i.response)) : n(i.status, i.responseText);
            }, i.onerror = function () {
              n(i.status, i.responseText);
            }, i.send();
          }, e.prototype.loadBinary = function (t, n, i) {
            var r = this;
            void 0 === n && (n = null), void 0 === i && (i = null), t = this.pathPrefix + t, this.toLoad++, e.downloadBinary(t, function (e) {
              r.assets[t] = e, n && n(t, e), r.toLoad--, r.loaded++;
            }, function (e, n) {
              r.errors[t] = "Couldn't load binary " + t + ": status " + status + ", " + n, i && i(t, "Couldn't load binary " + t + ": status " + status + ", " + n), r.toLoad--, r.loaded++;
            });
          }, e.prototype.loadText = function (t, n, i) {
            var r = this;
            void 0 === n && (n = null), void 0 === i && (i = null), t = this.pathPrefix + t, this.toLoad++, e.downloadText(t, function (e) {
              r.assets[t] = e, n && n(t, e), r.toLoad--, r.loaded++;
            }, function (e, n) {
              r.errors[t] = "Couldn't load text " + t + ": status " + status + ", " + n, i && i(t, "Couldn't load text " + t + ": status " + status + ", " + n), r.toLoad--, r.loaded++;
            });
          }, e.prototype.loadTexture = function (t, e, n) {
            var i = this;
            void 0 === e && (e = null), void 0 === n && (n = null), t = this.pathPrefix + t, this.toLoad++;
            var r = new Image();
            r.crossOrigin = "anonymous", r.onload = function () {
              var n = i.textureLoader(r);
              i.assets[t] = n, i.toLoad--, i.loaded++, e && e(t, r);
            }, r.onerror = function () {
              i.errors[t] = "Couldn't load image " + t, i.toLoad--, i.loaded++, n && n(t, "Couldn't load image " + t);
            }, r.src = t;
          }, e.prototype.loadTextureData = function (t, e, n, i) {
            var r = this;
            void 0 === n && (n = null), void 0 === i && (i = null), t = this.pathPrefix + t, this.toLoad++;
            var a = new Image();
            a.onload = function () {
              var e = r.textureLoader(a);
              r.assets[t] = e, r.toLoad--, r.loaded++, n && n(t, a);
            }, a.onerror = function () {
              r.errors[t] = "Couldn't load image " + t, r.toLoad--, r.loaded++, i && i(t, "Couldn't load image " + t);
            }, a.src = e;
          }, e.prototype.loadTextureAtlas = function (n, i, r) {
            var a = this;
            void 0 === i && (i = null), void 0 === r && (r = null);
            var s = n.lastIndexOf("/") >= 0 ? n.substring(0, n.lastIndexOf("/")) : "";
            n = this.pathPrefix + n, this.toLoad++, e.downloadText(n, function (e) {
              var o = {
                count: 0
              },
                  l = new Array();

              try {
                new t.TextureAtlas(e, function (e) {
                  l.push(s + "/" + e);
                  var n = document.createElement("img");
                  return n.width = 16, n.height = 16, new t.FakeTexture(n);
                });
              } catch (t) {
                var h = t;
                return a.errors[n] = "Couldn't load texture atlas " + n + ": " + h.message, r && r(n, "Couldn't load texture atlas " + n + ": " + h.message), a.toLoad--, void a.loaded++;
              }

              for (var u = function u(h) {
                var u = !1;
                a.loadTexture(h, function (h) {
                  if (o.count++, o.count == l.length) if (u) a.errors[n] = "Couldn't load texture atlas page " + h + "} of atlas " + n, r && r(n, "Couldn't load texture atlas page " + h + " of atlas " + n), a.toLoad--, a.loaded++;else try {
                    var c = new t.TextureAtlas(e, function (t) {
                      return a.get(s + "/" + t);
                    });
                    a.assets[n] = c, i && i(n, c), a.toLoad--, a.loaded++;
                  } catch (t) {
                    var d = t;
                    a.errors[n] = "Couldn't load texture atlas " + n + ": " + d.message, r && r(n, "Couldn't load texture atlas " + n + ": " + d.message), a.toLoad--, a.loaded++;
                  }
                }, function (t) {
                  u = !0, o.count++, o.count == l.length && (a.errors[n] = "Couldn't load texture atlas page " + t + "} of atlas " + n, r && r(n, "Couldn't load texture atlas page " + t + " of atlas " + n), a.toLoad--, a.loaded++);
                });
              }, c = 0, d = l; c < d.length; c++) {
                u(d[c]);
              }
            }, function (t, e) {
              a.errors[n] = "Couldn't load texture atlas " + n + ": status " + status + ", " + e, r && r(n, "Couldn't load texture atlas " + n + ": status " + status + ", " + e), a.toLoad--, a.loaded++;
            });
          }, e.prototype.get = function (t) {
            return t = this.pathPrefix + t, this.assets[t];
          }, e.prototype.remove = function (t) {
            t = this.pathPrefix + t;
            var e = this.assets[t];
            e.dispose && e.dispose(), this.assets[t] = null;
          }, e.prototype.removeAll = function () {
            for (var t in this.assets) {
              var e = this.assets[t];
              e.dispose && e.dispose();
            }

            this.assets = {};
          }, e.prototype.isLoadingComplete = function () {
            return 0 == this.toLoad;
          }, e.prototype.getToLoad = function () {
            return this.toLoad;
          }, e.prototype.getLoaded = function () {
            return this.loaded;
          }, e.prototype.dispose = function () {
            this.removeAll();
          }, e.prototype.hasErrors = function () {
            return Object.keys(this.errors).length > 0;
          }, e.prototype.getErrors = function () {
            return this.errors;
          }, e;
        }();

        t.AssetManager = e;
      }(K || (K = {})), function (t) {
        var e = function () {
          function e(t) {
            this.atlas = t;
          }

          return e.prototype.newRegionAttachment = function (e, n, i) {
            var r = this.atlas.findRegion(i);
            if (null == r) return null;
            r.renderObject = r;
            var a = new t.RegionAttachment(n);
            return a.setRegion(r), a;
          }, e.prototype.newMeshAttachment = function (e, n, i) {
            var r = this.atlas.findRegion(i);
            if (null == r) return null;
            r.renderObject = r;
            var a = new t.MeshAttachment(n);
            return a.region = r, a;
          }, e.prototype.newBoundingBoxAttachment = function (e, n) {
            return new t.BoundingBoxAttachment(n);
          }, e.prototype.newPathAttachment = function (e, n) {
            return new t.PathAttachment(n);
          }, e.prototype.newPointAttachment = function (e, n) {
            return new t.PointAttachment(n);
          }, e.prototype.newClippingAttachment = function (e, n) {
            return new t.ClippingAttachment(n);
          }, e;
        }();

        t.AtlasAttachmentLoader = e;
      }(K || (K = {})), function (t) {
        var e;
        (e = t.BlendMode || (t.BlendMode = {}))[e.Normal = 0] = "Normal", e[e.Additive = 1] = "Additive", e[e.Multiply = 2] = "Multiply", e[e.Screen = 3] = "Screen";
      }(K || (K = {})), function (t) {
        var e = function () {
          function e(t, e, n) {
            if (this.children = new Array(), this.x = 0, this.y = 0, this.rotation = 0, this.scaleX = 0, this.scaleY = 0, this.shearX = 0, this.shearY = 0, this.ax = 0, this.ay = 0, this.arotation = 0, this.ascaleX = 0, this.ascaleY = 0, this.ashearX = 0, this.ashearY = 0, this.appliedValid = !1, this.a = 0, this.b = 0, this.c = 0, this.d = 0, this.worldY = 0, this.worldX = 0, this.sorted = !1, this.active = !1, null == t) throw new Error("data cannot be null.");
            if (null == e) throw new Error("skeleton cannot be null.");
            this.data = t, this.skeleton = e, this.parent = n, this.setToSetupPose();
          }

          return e.prototype.isActive = function () {
            return this.active;
          }, e.prototype.update = function () {
            this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);
          }, e.prototype.updateWorldTransform = function () {
            this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);
          }, e.prototype.updateWorldTransformWith = function (e, n, i, r, a, s, o) {
            this.ax = e, this.ay = n, this.arotation = i, this.ascaleX = r, this.ascaleY = a, this.ashearX = s, this.ashearY = o, this.appliedValid = !0;
            var l = this.parent;

            if (null == l) {
              var h = this.skeleton,
                  u = i + 90 + o,
                  c = h.scaleX,
                  d = h.scaleY;
              return this.a = t.MathUtils.cosDeg(i + s) * r * c, this.b = t.MathUtils.cosDeg(u) * a * c, this.c = t.MathUtils.sinDeg(i + s) * r * d, this.d = t.MathUtils.sinDeg(u) * a * d, this.worldX = e * c + h.x, void (this.worldY = n * d + h.y);
            }

            var f = l.a,
                p = l.b,
                m = l.c,
                g = l.d;

            switch (this.worldX = f * e + p * n + l.worldX, this.worldY = m * e + g * n + l.worldY, this.data.transformMode) {
              case t.TransformMode.Normal:
                u = i + 90 + o;
                var v = t.MathUtils.cosDeg(i + s) * r,
                    y = t.MathUtils.cosDeg(u) * a,
                    x = t.MathUtils.sinDeg(i + s) * r,
                    w = t.MathUtils.sinDeg(u) * a;
                return this.a = f * v + p * x, this.b = f * y + p * w, this.c = m * v + g * x, void (this.d = m * y + g * w);

              case t.TransformMode.OnlyTranslation:
                u = i + 90 + o, this.a = t.MathUtils.cosDeg(i + s) * r, this.b = t.MathUtils.cosDeg(u) * a, this.c = t.MathUtils.sinDeg(i + s) * r, this.d = t.MathUtils.sinDeg(u) * a;
                break;

              case t.TransformMode.NoRotationOrReflection:
                var _ = 0;
                (T = f * f + m * m) > 1e-4 ? (p = m * (T = Math.abs(f * g - p * m) / T), g = f * T, _ = Math.atan2(m, f) * t.MathUtils.radDeg) : (f = 0, m = 0, _ = 90 - Math.atan2(g, p) * t.MathUtils.radDeg);
                var E = i + s - _,
                    b = i + o - _ + 90;
                v = t.MathUtils.cosDeg(E) * r, y = t.MathUtils.cosDeg(b) * a, x = t.MathUtils.sinDeg(E) * r, w = t.MathUtils.sinDeg(b) * a, this.a = f * v - p * x, this.b = f * y - p * w, this.c = m * v + g * x, this.d = m * y + g * w;
                break;

              case t.TransformMode.NoScale:
              case t.TransformMode.NoScaleOrReflection:
                var T,
                    M = t.MathUtils.cosDeg(i),
                    A = t.MathUtils.sinDeg(i),
                    C = (f * M + p * A) / this.skeleton.scaleX,
                    S = (m * M + g * A) / this.skeleton.scaleY;
                (T = Math.sqrt(C * C + S * S)) > 1e-5 && (T = 1 / T), C *= T, S *= T, T = Math.sqrt(C * C + S * S), this.data.transformMode == t.TransformMode.NoScale && f * g - p * m < 0 != (this.skeleton.scaleX < 0 != this.skeleton.scaleY < 0) && (T = -T);
                var k = Math.PI / 2 + Math.atan2(S, C),
                    I = Math.cos(k) * T,
                    R = Math.sin(k) * T;
                v = t.MathUtils.cosDeg(s) * r, y = t.MathUtils.cosDeg(90 + o) * a, x = t.MathUtils.sinDeg(s) * r, w = t.MathUtils.sinDeg(90 + o) * a, this.a = C * v + I * x, this.b = C * y + I * w, this.c = S * v + R * x, this.d = S * y + R * w;
            }

            this.a *= this.skeleton.scaleX, this.b *= this.skeleton.scaleX, this.c *= this.skeleton.scaleY, this.d *= this.skeleton.scaleY;
          }, e.prototype.setToSetupPose = function () {
            var t = this.data;
            this.x = t.x, this.y = t.y, this.rotation = t.rotation, this.scaleX = t.scaleX, this.scaleY = t.scaleY, this.shearX = t.shearX, this.shearY = t.shearY;
          }, e.prototype.getWorldRotationX = function () {
            return Math.atan2(this.c, this.a) * t.MathUtils.radDeg;
          }, e.prototype.getWorldRotationY = function () {
            return Math.atan2(this.d, this.b) * t.MathUtils.radDeg;
          }, e.prototype.getWorldScaleX = function () {
            return Math.sqrt(this.a * this.a + this.c * this.c);
          }, e.prototype.getWorldScaleY = function () {
            return Math.sqrt(this.b * this.b + this.d * this.d);
          }, e.prototype.updateAppliedTransform = function () {
            this.appliedValid = !0;
            var e = this.parent;
            if (null == e) return this.ax = this.worldX, this.ay = this.worldY, this.arotation = Math.atan2(this.c, this.a) * t.MathUtils.radDeg, this.ascaleX = Math.sqrt(this.a * this.a + this.c * this.c), this.ascaleY = Math.sqrt(this.b * this.b + this.d * this.d), this.ashearX = 0, void (this.ashearY = Math.atan2(this.a * this.b + this.c * this.d, this.a * this.d - this.b * this.c) * t.MathUtils.radDeg);
            var n = e.a,
                i = e.b,
                r = e.c,
                a = e.d,
                s = 1 / (n * a - i * r),
                o = this.worldX - e.worldX,
                l = this.worldY - e.worldY;
            this.ax = o * a * s - l * i * s, this.ay = l * n * s - o * r * s;
            var h = s * a,
                u = s * n,
                c = s * i,
                d = s * r,
                f = h * this.a - c * this.c,
                p = h * this.b - c * this.d,
                m = u * this.c - d * this.a,
                g = u * this.d - d * this.b;

            if (this.ashearX = 0, this.ascaleX = Math.sqrt(f * f + m * m), this.ascaleX > 1e-4) {
              var v = f * g - p * m;
              this.ascaleY = v / this.ascaleX, this.ashearY = Math.atan2(f * p + m * g, v) * t.MathUtils.radDeg, this.arotation = Math.atan2(m, f) * t.MathUtils.radDeg;
            } else this.ascaleX = 0, this.ascaleY = Math.sqrt(p * p + g * g), this.ashearY = 0, this.arotation = 90 - Math.atan2(g, p) * t.MathUtils.radDeg;
          }, e.prototype.worldToLocal = function (t) {
            var e = this.a,
                n = this.b,
                i = this.c,
                r = this.d,
                a = 1 / (e * r - n * i),
                s = t.x - this.worldX,
                o = t.y - this.worldY;
            return t.x = s * r * a - o * n * a, t.y = o * e * a - s * i * a, t;
          }, e.prototype.localToWorld = function (t) {
            var e = t.x,
                n = t.y;
            return t.x = e * this.a + n * this.b + this.worldX, t.y = e * this.c + n * this.d + this.worldY, t;
          }, e.prototype.worldToLocalRotation = function (e) {
            var n = t.MathUtils.sinDeg(e),
                i = t.MathUtils.cosDeg(e);
            return Math.atan2(this.a * n - this.c * i, this.d * i - this.b * n) * t.MathUtils.radDeg + this.rotation - this.shearX;
          }, e.prototype.localToWorldRotation = function (e) {
            e -= this.rotation - this.shearX;
            var n = t.MathUtils.sinDeg(e),
                i = t.MathUtils.cosDeg(e);
            return Math.atan2(i * this.c + n * this.d, i * this.a + n * this.b) * t.MathUtils.radDeg;
          }, e.prototype.rotateWorld = function (e) {
            var n = this.a,
                i = this.b,
                r = this.c,
                a = this.d,
                s = t.MathUtils.cosDeg(e),
                o = t.MathUtils.sinDeg(e);
            this.a = s * n - o * r, this.b = s * i - o * a, this.c = o * n + s * r, this.d = o * i + s * a, this.appliedValid = !1;
          }, e;
        }();

        t.Bone = e;
      }(K || (K = {})), function (t) {
        var e;
        t.BoneData = function (n, i, r) {
          if (this.x = 0, this.y = 0, this.rotation = 0, this.scaleX = 1, this.scaleY = 1, this.shearX = 0, this.shearY = 0, this.transformMode = e.Normal, this.skinRequired = !1, this.color = new t.Color(), n < 0) throw new Error("index must be >= 0.");
          if (null == i) throw new Error("name cannot be null.");
          this.index = n, this.name = i, this.parent = r;
        }, function (t) {
          t[t.Normal = 0] = "Normal", t[t.OnlyTranslation = 1] = "OnlyTranslation", t[t.NoRotationOrReflection = 2] = "NoRotationOrReflection", t[t.NoScale = 3] = "NoScale", t[t.NoScaleOrReflection = 4] = "NoScaleOrReflection";
        }(e = t.TransformMode || (t.TransformMode = {}));
      }(K || (K = {})), function (t) {
        t.ConstraintData = function (t, e, n) {
          this.name = t, this.order = e, this.skinRequired = n;
        };
      }(K || (K = {})), function (t) {
        t.Event = function (t, e) {
          if (null == e) throw new Error("data cannot be null.");
          this.time = t, this.data = e;
        };
      }(K || (K = {})), function (t) {
        t.EventData = function (t) {
          this.name = t;
        };
      }(K || (K = {})), function (t) {
        var e = function () {
          function e(t, e) {
            if (this.bendDirection = 0, this.compress = !1, this.stretch = !1, this.mix = 1, this.softness = 0, this.active = !1, null == t) throw new Error("data cannot be null.");
            if (null == e) throw new Error("skeleton cannot be null.");
            this.data = t, this.mix = t.mix, this.softness = t.softness, this.bendDirection = t.bendDirection, this.compress = t.compress, this.stretch = t.stretch, this.bones = new Array();

            for (var n = 0; n < t.bones.length; n++) {
              this.bones.push(e.findBone(t.bones[n].name));
            }

            this.target = e.findBone(t.target.name);
          }

          return e.prototype.isActive = function () {
            return this.active;
          }, e.prototype.apply = function () {
            this.update();
          }, e.prototype.update = function () {
            var t = this.target,
                e = this.bones;

            switch (e.length) {
              case 1:
                this.apply1(e[0], t.worldX, t.worldY, this.compress, this.stretch, this.data.uniform, this.mix);
                break;

              case 2:
                this.apply2(e[0], e[1], t.worldX, t.worldY, this.bendDirection, this.stretch, this.softness, this.mix);
            }
          }, e.prototype.apply1 = function (e, n, i, r, a, s, o) {
            e.appliedValid || e.updateAppliedTransform();
            var l = e.parent,
                h = 1 / (l.a * l.d - l.b * l.c),
                u = n - l.worldX,
                c = i - l.worldY,
                d = (u * l.d - c * l.b) * h - e.ax,
                f = (c * l.a - u * l.c) * h - e.ay,
                p = Math.atan2(f, d) * t.MathUtils.radDeg - e.ashearX - e.arotation;
            e.ascaleX < 0 && (p += 180), p > 180 ? p -= 360 : p < -180 && (p += 360);
            var m = e.ascaleX,
                g = e.ascaleY;

            if (r || a) {
              var v = e.data.length * m,
                  y = Math.sqrt(d * d + f * f);

              if (r && y < v || a && y > v && v > 1e-4) {
                var x = (y / v - 1) * o + 1;
                m *= x, s && (g *= x);
              }
            }

            e.updateWorldTransformWith(e.ax, e.ay, e.arotation + p * o, m, g, e.ashearX, e.ashearY);
          }, e.prototype.apply2 = function (e, n, i, r, a, s, o, l) {
            if (0 != l) {
              e.appliedValid || e.updateAppliedTransform(), n.appliedValid || n.updateAppliedTransform();
              var h = e.ax,
                  u = e.ay,
                  c = e.ascaleX,
                  d = c,
                  f = e.ascaleY,
                  p = n.ascaleX,
                  m = 0,
                  g = 0,
                  v = 0;
              c < 0 ? (c = -c, m = 180, v = -1) : (m = 0, v = 1), f < 0 && (f = -f, v = -v), p < 0 ? (p = -p, g = 180) : g = 0;
              var y = n.ax,
                  x = 0,
                  w = 0,
                  _ = 0,
                  E = e.a,
                  b = e.b,
                  T = e.c,
                  M = e.d,
                  A = Math.abs(c - f) <= 1e-4;
              A ? (w = E * y + b * (x = n.ay) + e.worldX, _ = T * y + M * x + e.worldY) : (x = 0, w = E * y + e.worldX, _ = T * y + e.worldY);
              var C = e.parent;
              E = C.a, b = C.b, T = C.c;
              var S,
                  k,
                  I = 1 / (E * (M = C.d) - b * T),
                  R = w - C.worldX,
                  P = _ - C.worldY,
                  V = (R * M - P * b) * I - h,
                  D = (P * E - R * T) * I - u,
                  N = Math.sqrt(V * V + D * D),
                  F = n.data.length * p;
              if (N < 1e-4) return this.apply1(e, i, r, !1, s, !1, l), void n.updateWorldTransformWith(y, x, 0, n.ascaleX, n.ascaleY, n.ashearX, n.ashearY);
              var O = ((R = i - C.worldX) * M - (P = r - C.worldY) * b) * I - h,
                  L = (P * E - R * T) * I - u,
                  U = O * O + L * L;

              if (0 != o) {
                o *= c * (p + 1) / 2;
                var B = Math.sqrt(U),
                    Y = B - N - F * c + o;

                if (Y > 0) {
                  var X = Math.min(1, Y / (2 * o)) - 1;
                  U = (O -= (X = (Y - o * (1 - X * X)) / B) * O) * O + (L -= X * L) * L;
                }
              }

              t: if (A) {
                var W = (U - N * N - (F *= c) * F) / (2 * N * F);
                W < -1 ? W = -1 : W > 1 && (W = 1, s && (d *= (Math.sqrt(U) / (N + F) - 1) * l + 1)), k = Math.acos(W) * a, E = N + F * W, b = F * Math.sin(k), S = Math.atan2(L * E - O * b, O * E + L * b);
              } else {
                var q = (E = c * F) * E,
                    H = (b = f * F) * b,
                    j = Math.atan2(L, O),
                    z = -2 * H * N,
                    G = H - q;

                if ((M = z * z - 4 * G * (T = H * N * N + q * U - q * H)) >= 0) {
                  var Z = Math.sqrt(M);
                  z < 0 && (Z = -Z);
                  var J = (Z = -(z + Z) / 2) / G,
                      Q = T / Z,
                      K = Math.abs(J) < Math.abs(Q) ? J : Q;

                  if (K * K <= U) {
                    P = Math.sqrt(U - K * K) * a, S = j - Math.atan2(P, K), k = Math.atan2(P / f, (K - N) / c);
                    break t;
                  }
                }

                var $ = t.MathUtils.PI,
                    tt = N - E,
                    et = tt * tt,
                    nt = 0,
                    it = 0,
                    rt = N + E,
                    at = rt * rt,
                    st = 0;
                (T = -E * N / (q - H)) >= -1 && T <= 1 && (T = Math.acos(T), (M = (R = E * Math.cos(T) + N) * R + (P = b * Math.sin(T)) * P) < et && ($ = T, et = M, tt = R, nt = P), M > at && (it = T, at = M, rt = R, st = P)), U <= (et + at) / 2 ? (S = j - Math.atan2(nt * a, tt), k = $ * a) : (S = j - Math.atan2(st * a, rt), k = it * a);
              }

              var ot = Math.atan2(x, y) * v,
                  lt = e.arotation;
              (S = (S - ot) * t.MathUtils.radDeg + m - lt) > 180 ? S -= 360 : S < -180 && (S += 360), e.updateWorldTransformWith(h, u, lt + S * l, d, e.ascaleY, 0, 0), lt = n.arotation, (k = ((k + ot) * t.MathUtils.radDeg - n.ashearX) * v + g - lt) > 180 ? k -= 360 : k < -180 && (k += 360), n.updateWorldTransformWith(y, x, lt + k * l, n.ascaleX, n.ascaleY, n.ashearX, n.ashearY);
            } else n.updateWorldTransform();
          }, e;
        }();

        t.IkConstraint = e;
      }(K || (K = {})), function (t) {
        var e = function (t) {
          function e(e) {
            var n = t.call(this, e, 0, !1) || this;
            return n.bones = new Array(), n.bendDirection = 1, n.compress = !1, n.stretch = !1, n.uniform = !1, n.mix = 1, n.softness = 0, n;
          }

          return $(e, t), e;
        }(t.ConstraintData);

        t.IkConstraintData = e;
      }(K || (K = {})), function (t) {
        var e = function () {
          function e(t, e) {
            if (this.position = 0, this.spacing = 0, this.rotateMix = 0, this.translateMix = 0, this.spaces = new Array(), this.positions = new Array(), this.world = new Array(), this.curves = new Array(), this.lengths = new Array(), this.segments = new Array(), this.active = !1, null == t) throw new Error("data cannot be null.");
            if (null == e) throw new Error("skeleton cannot be null.");
            this.data = t, this.bones = new Array();

            for (var n = 0, i = t.bones.length; n < i; n++) {
              this.bones.push(e.findBone(t.bones[n].name));
            }

            this.target = e.findSlot(t.target.name), this.position = t.position, this.spacing = t.spacing, this.rotateMix = t.rotateMix, this.translateMix = t.translateMix;
          }

          return e.prototype.isActive = function () {
            return this.active;
          }, e.prototype.apply = function () {
            this.update();
          }, e.prototype.update = function () {
            var n = this.target.getAttachment();

            if (n instanceof t.PathAttachment) {
              var i = this.rotateMix,
                  r = this.translateMix,
                  a = i > 0;

              if (r > 0 || a) {
                var s = this.data,
                    o = s.spacingMode == t.SpacingMode.Percent,
                    l = s.rotateMode,
                    h = l == t.RotateMode.Tangent,
                    u = l == t.RotateMode.ChainScale,
                    c = this.bones.length,
                    d = h ? c : c + 1,
                    f = this.bones,
                    p = t.Utils.setArraySize(this.spaces, d),
                    m = null,
                    g = this.spacing;

                if (u || !o) {
                  u && (m = t.Utils.setArraySize(this.lengths, c));

                  for (var v = s.spacingMode == t.SpacingMode.Length, y = 0, x = d - 1; y < x;) {
                    var w = (R = f[y]).data.length;
                    if (w < e.epsilon) u && (m[y] = 0), p[++y] = 0;else if (o) {
                      if (u) {
                        var _ = w * R.a,
                            E = w * R.c,
                            b = Math.sqrt(_ * _ + E * E);

                        m[y] = b;
                      }

                      p[++y] = g;
                    } else {
                      _ = w * R.a, E = w * R.c;
                      var T = Math.sqrt(_ * _ + E * E);
                      u && (m[y] = T), p[++y] = (v ? w + g : g) * T / w;
                    }
                  }
                } else for (y = 1; y < d; y++) {
                  p[y] = g;
                }

                var M = this.computeWorldPositions(n, d, h, s.positionMode == t.PositionMode.Percent, o),
                    A = M[0],
                    C = M[1],
                    S = s.offsetRotation,
                    k = !1;
                0 == S ? k = l == t.RotateMode.Chain : (k = !1, S *= (I = this.target.bone).a * I.d - I.b * I.c > 0 ? t.MathUtils.degRad : -t.MathUtils.degRad), y = 0;

                for (var I = 3; y < c; y++, I += 3) {
                  var R;
                  (R = f[y]).worldX += (A - R.worldX) * r, R.worldY += (C - R.worldY) * r;
                  var P = (_ = M[I]) - A,
                      V = (E = M[I + 1]) - C;

                  if (u) {
                    var D = m[y];

                    if (0 != D) {
                      var N = (Math.sqrt(P * P + V * V) / D - 1) * i + 1;
                      R.a *= N, R.c *= N;
                    }
                  }

                  if (A = _, C = E, a) {
                    var F = R.a,
                        O = R.b,
                        L = R.c,
                        U = R.d,
                        B = 0,
                        Y = 0,
                        X = 0;

                    if (B = h ? M[I - 1] : 0 == p[y + 1] ? M[I + 2] : Math.atan2(V, P), B -= Math.atan2(L, F), k) {
                      Y = Math.cos(B), X = Math.sin(B);
                      var W = R.data.length;
                      A += (W * (Y * F - X * L) - P) * i, C += (W * (X * F + Y * L) - V) * i;
                    } else B += S;

                    B > t.MathUtils.PI ? B -= t.MathUtils.PI2 : B < -t.MathUtils.PI && (B += t.MathUtils.PI2), B *= i, Y = Math.cos(B), X = Math.sin(B), R.a = Y * F - X * L, R.b = Y * O - X * U, R.c = X * F + Y * L, R.d = X * O + Y * U;
                  }

                  R.appliedValid = !1;
                }
              }
            }
          }, e.prototype.computeWorldPositions = function (n, i, r, a, s) {
            var o = this.target,
                l = this.position,
                h = this.spaces,
                u = t.Utils.setArraySize(this.positions, 3 * i + 2),
                c = null,
                d = n.closed,
                f = n.worldVerticesLength,
                p = f / 6,
                m = e.NONE;

            if (!n.constantSpeed) {
              var g = n.lengths,
                  v = g[p -= d ? 1 : 2];
              if (a && (l *= v), s) for (var y = 1; y < i; y++) {
                h[y] *= v;
              }
              c = t.Utils.setArraySize(this.world, 8), y = 0;

              for (var x = 0, w = 0; y < i; y++, x += 3) {
                var _ = l += H = h[y];

                if (d) (_ %= v) < 0 && (_ += v), w = 0;else {
                  if (_ < 0) {
                    m != e.BEFORE && (m = e.BEFORE, n.computeWorldVertices(o, 2, 4, c, 0, 2)), this.addBeforePosition(_, c, 0, u, x);
                    continue;
                  }

                  if (_ > v) {
                    m != e.AFTER && (m = e.AFTER, n.computeWorldVertices(o, f - 6, 4, c, 0, 2)), this.addAfterPosition(_ - v, c, 0, u, x);
                    continue;
                  }
                }

                for (;; w++) {
                  var E = g[w];

                  if (!(_ > E)) {
                    0 == w ? _ /= E : _ = (_ - (Z = g[w - 1])) / (E - Z);
                    break;
                  }
                }

                w != m && (m = w, d && w == p ? (n.computeWorldVertices(o, f - 4, 4, c, 0, 2), n.computeWorldVertices(o, 0, 4, c, 4, 2)) : n.computeWorldVertices(o, 6 * w + 2, 8, c, 0, 2)), this.addCurvePosition(_, c[0], c[1], c[2], c[3], c[4], c[5], c[6], c[7], u, x, r || y > 0 && 0 == H);
              }

              return u;
            }

            d ? (f += 2, c = t.Utils.setArraySize(this.world, f), n.computeWorldVertices(o, 2, f - 4, c, 0, 2), n.computeWorldVertices(o, 0, 2, c, f - 4, 2), c[f - 2] = c[0], c[f - 1] = c[1]) : (p--, f -= 4, c = t.Utils.setArraySize(this.world, f), n.computeWorldVertices(o, 2, f, c, 0, 2));

            for (var b = t.Utils.setArraySize(this.curves, p), T = 0, M = c[0], A = c[1], C = 0, S = 0, k = 0, I = 0, R = 0, P = 0, V = 0, D = 0, N = 0, F = 0, O = 0, L = 0, U = 0, B = 0, Y = (y = 0, 2); y < p; y++, Y += 6) {
              C = c[Y], S = c[Y + 1], k = c[Y + 2], I = c[Y + 3], O = 2 * (V = .1875 * (M - 2 * C + k)) + (N = .09375 * (3 * (C - k) - M + (R = c[Y + 4]))), L = 2 * (D = .1875 * (A - 2 * S + I)) + (F = .09375 * (3 * (S - I) - A + (P = c[Y + 5]))), U = .75 * (C - M) + V + .16666667 * N, B = .75 * (S - A) + D + .16666667 * F, T += Math.sqrt(U * U + B * B), U += O, B += L, O += N, L += F, T += Math.sqrt(U * U + B * B), U += O, B += L, T += Math.sqrt(U * U + B * B), U += O + N, B += L + F, T += Math.sqrt(U * U + B * B), b[y] = T, M = R, A = P;
            }

            if (l *= a ? T : T / n.lengths[p - 1], s) for (y = 1; y < i; y++) {
              h[y] *= T;
            }

            for (var X = this.segments, W = 0, q = (y = 0, x = 0, w = 0, 0); y < i; y++, x += 3) {
              var H;
              if (_ = l += H = h[y], d) (_ %= T) < 0 && (_ += T), w = 0;else {
                if (_ < 0) {
                  this.addBeforePosition(_, c, 0, u, x);
                  continue;
                }

                if (_ > T) {
                  this.addAfterPosition(_ - T, c, f - 4, u, x);
                  continue;
                }
              }

              for (;; w++) {
                var j = b[w];

                if (!(_ > j)) {
                  0 == w ? _ /= j : _ = (_ - (Z = b[w - 1])) / (j - Z);
                  break;
                }
              }

              if (w != m) {
                m = w;
                var z = 6 * w;

                for (M = c[z], A = c[z + 1], C = c[z + 2], S = c[z + 3], k = c[z + 4], I = c[z + 5], O = 2 * (V = .03 * (M - 2 * C + k)) + (N = .006 * (3 * (C - k) - M + (R = c[z + 6]))), L = 2 * (D = .03 * (A - 2 * S + I)) + (F = .006 * (3 * (S - I) - A + (P = c[z + 7]))), U = .3 * (C - M) + V + .16666667 * N, B = .3 * (S - A) + D + .16666667 * F, W = Math.sqrt(U * U + B * B), X[0] = W, z = 1; z < 8; z++) {
                  U += O, B += L, O += N, L += F, W += Math.sqrt(U * U + B * B), X[z] = W;
                }

                U += O, B += L, W += Math.sqrt(U * U + B * B), X[8] = W, U += O + N, B += L + F, W += Math.sqrt(U * U + B * B), X[9] = W, q = 0;
              }

              for (_ *= W;; q++) {
                var G = X[q];

                if (!(_ > G)) {
                  var Z;
                  0 == q ? _ /= G : _ = q + (_ - (Z = X[q - 1])) / (G - Z);
                  break;
                }
              }

              this.addCurvePosition(.1 * _, M, A, C, S, k, I, R, P, u, x, r || y > 0 && 0 == H);
            }

            return u;
          }, e.prototype.addBeforePosition = function (t, e, n, i, r) {
            var a = e[n],
                s = e[n + 1],
                o = e[n + 2] - a,
                l = e[n + 3] - s,
                h = Math.atan2(l, o);
            i[r] = a + t * Math.cos(h), i[r + 1] = s + t * Math.sin(h), i[r + 2] = h;
          }, e.prototype.addAfterPosition = function (t, e, n, i, r) {
            var a = e[n + 2],
                s = e[n + 3],
                o = a - e[n],
                l = s - e[n + 1],
                h = Math.atan2(l, o);
            i[r] = a + t * Math.cos(h), i[r + 1] = s + t * Math.sin(h), i[r + 2] = h;
          }, e.prototype.addCurvePosition = function (t, e, n, i, r, a, s, o, l, h, u, c) {
            if (0 == t || isNaN(t)) return h[u] = e, h[u + 1] = n, void (h[u + 2] = Math.atan2(r - n, i - e));

            var d = t * t,
                f = d * t,
                p = 1 - t,
                m = p * p,
                g = m * p,
                v = p * t,
                y = 3 * v,
                x = p * y,
                w = y * t,
                _ = e * g + i * x + a * w + o * f,
                E = n * g + r * x + s * w + l * f;

            h[u] = _, h[u + 1] = E, c && (h[u + 2] = t < .001 ? Math.atan2(r - n, i - e) : Math.atan2(E - (n * m + r * v * 2 + s * d), _ - (e * m + i * v * 2 + a * d)));
          }, e.NONE = -1, e.BEFORE = -2, e.AFTER = -3, e.epsilon = 1e-5, e;
        }();

        t.PathConstraint = e;
      }(K || (K = {})), function (t) {
        var e,
            n,
            i,
            r = function (t) {
          function e(e) {
            var n = t.call(this, e, 0, !1) || this;
            return n.bones = new Array(), n;
          }

          return $(e, t), e;
        }(t.ConstraintData);

        t.PathConstraintData = r, (i = t.PositionMode || (t.PositionMode = {}))[i.Fixed = 0] = "Fixed", i[i.Percent = 1] = "Percent", (n = t.SpacingMode || (t.SpacingMode = {}))[n.Length = 0] = "Length", n[n.Fixed = 1] = "Fixed", n[n.Percent = 2] = "Percent", (e = t.RotateMode || (t.RotateMode = {}))[e.Tangent = 0] = "Tangent", e[e.Chain = 1] = "Chain", e[e.ChainScale = 2] = "ChainScale";
      }(K || (K = {})), function (t) {
        var e = function () {
          function t(t) {
            this.toLoad = new Array(), this.assets = {}, this.clientId = t;
          }

          return t.prototype.loaded = function () {
            var t = 0;

            for (var e in this.assets) {
              t++;
            }

            return t;
          }, t;
        }(),
            n = function () {
          function t(t) {
            void 0 === t && (t = ""), this.clientAssets = {}, this.queuedAssets = {}, this.rawAssets = {}, this.errors = {}, this.pathPrefix = t;
          }

          return t.prototype.queueAsset = function (t, n, i) {
            var r = this.clientAssets[t];
            return null == r && (r = new e(t), this.clientAssets[t] = r), null !== n && (r.textureLoader = n), r.toLoad.push(i), this.queuedAssets[i] !== i && (this.queuedAssets[i] = i, !0);
          }, t.prototype.loadText = function (t, e) {
            var n = this;

            if (e = this.pathPrefix + e, this.queueAsset(t, null, e)) {
              var i = new XMLHttpRequest();
              i.onreadystatechange = function () {
                i.readyState == XMLHttpRequest.DONE && (i.status >= 200 && i.status < 300 ? n.rawAssets[e] = i.responseText : n.errors[e] = "Couldn't load text " + e + ": status " + i.status + ", " + i.responseText);
              }, i.open("GET", e, !0), i.send();
            }
          }, t.prototype.loadJson = function (t, e) {
            var n = this;

            if (e = this.pathPrefix + e, this.queueAsset(t, null, e)) {
              var i = new XMLHttpRequest();
              i.onreadystatechange = function () {
                i.readyState == XMLHttpRequest.DONE && (i.status >= 200 && i.status < 300 ? n.rawAssets[e] = JSON.parse(i.responseText) : n.errors[e] = "Couldn't load text " + e + ": status " + i.status + ", " + i.responseText);
              }, i.open("GET", e, !0), i.send();
            }
          }, t.prototype.loadTexture = function (t, e, n) {
            var i = this;

            if (n = this.pathPrefix + n, this.queueAsset(t, e, n)) {
              var r = new Image();
              r.src = n, r.crossOrigin = "anonymous", r.onload = function () {
                i.rawAssets[n] = r;
              }, r.onerror = function () {
                i.errors[n] = "Couldn't load image " + n;
              };
            }
          }, t.prototype.get = function (t, e) {
            e = this.pathPrefix + e;
            var n = this.clientAssets[t];
            return null == n || n.assets[e];
          }, t.prototype.updateClientAssets = function (t) {
            for (var e = 0; e < t.toLoad.length; e++) {
              var n = t.toLoad[e];

              if (null == t.assets[n]) {
                var i = this.rawAssets[n];
                if (null == i) continue;
                i instanceof HTMLImageElement ? t.assets[n] = t.textureLoader(i) : t.assets[n] = i;
              }
            }
          }, t.prototype.isLoadingComplete = function (t) {
            var e = this.clientAssets[t];
            return null == e || (this.updateClientAssets(e), e.toLoad.length == e.loaded());
          }, t.prototype.dispose = function () {}, t.prototype.hasErrors = function () {
            return Object.keys(this.errors).length > 0;
          }, t.prototype.getErrors = function () {
            return this.errors;
          }, t;
        }();

        t.SharedAssetManager = n;
      }(K || (K = {})), function (t) {
        var e = function () {
          function e(e) {
            if (this._updateCache = new Array(), this.updateCacheReset = new Array(), this.time = 0, this.scaleX = 1, this.scaleY = 1, this.x = 0, this.y = 0, null == e) throw new Error("data cannot be null.");
            this.data = e, this.bones = new Array();

            for (var n = 0; n < e.bones.length; n++) {
              var i = e.bones[n],
                  r = void 0;
              if (null == i.parent) r = new t.Bone(i, this, null);else {
                var a = this.bones[i.parent.index];
                r = new t.Bone(i, this, a), a.children.push(r);
              }
              this.bones.push(r);
            }

            for (this.slots = new Array(), this.drawOrder = new Array(), n = 0; n < e.slots.length; n++) {
              var s = e.slots[n],
                  o = (r = this.bones[s.boneData.index], new t.Slot(s, r));
              this.slots.push(o), this.drawOrder.push(o);
            }

            for (this.ikConstraints = new Array(), n = 0; n < e.ikConstraints.length; n++) {
              var l = e.ikConstraints[n];
              this.ikConstraints.push(new t.IkConstraint(l, this));
            }

            for (this.transformConstraints = new Array(), n = 0; n < e.transformConstraints.length; n++) {
              var h = e.transformConstraints[n];
              this.transformConstraints.push(new t.TransformConstraint(h, this));
            }

            for (this.pathConstraints = new Array(), n = 0; n < e.pathConstraints.length; n++) {
              var u = e.pathConstraints[n];
              this.pathConstraints.push(new t.PathConstraint(u, this));
            }

            this.color = new t.Color(1, 1, 1, 1), this.updateCache();
          }

          return e.prototype.updateCache = function () {
            this._updateCache.length = 0, this.updateCacheReset.length = 0;

            for (var t = this.bones, e = 0, n = t.length; e < n; e++) {
              (r = t[e]).sorted = r.data.skinRequired, r.active = !r.sorted;
            }

            if (null != this.skin) {
              var i = this.skin.bones;

              for (e = 0, n = this.skin.bones.length; e < n; e++) {
                var r = this.bones[i[e].index];

                do {
                  r.sorted = !1, r.active = !0, r = r.parent;
                } while (null != r);
              }
            }

            var a = this.ikConstraints,
                s = this.transformConstraints,
                o = this.pathConstraints,
                l = a.length,
                h = s.length,
                u = o.length,
                c = l + h + u;

            t: for (e = 0; e < c; e++) {
              for (var d = 0; d < l; d++) {
                if ((f = a[d]).data.order == e) {
                  this.sortIkConstraint(f);
                  continue t;
                }
              }

              for (d = 0; d < h; d++) {
                if ((f = s[d]).data.order == e) {
                  this.sortTransformConstraint(f);
                  continue t;
                }
              }

              for (d = 0; d < u; d++) {
                var f;

                if ((f = o[d]).data.order == e) {
                  this.sortPathConstraint(f);
                  continue t;
                }
              }
            }

            for (e = 0, n = t.length; e < n; e++) {
              this.sortBone(t[e]);
            }
          }, e.prototype.sortIkConstraint = function (e) {
            if (e.active = e.target.isActive() && (!e.data.skinRequired || null != this.skin && t.Utils.contains(this.skin.constraints, e.data, !0)), e.active) {
              var n = e.target;
              this.sortBone(n);
              var i = e.bones,
                  r = i[0];

              if (this.sortBone(r), i.length > 1) {
                var a = i[i.length - 1];
                this._updateCache.indexOf(a) > -1 || this.updateCacheReset.push(a);
              }

              this._updateCache.push(e), this.sortReset(r.children), i[i.length - 1].sorted = !0;
            }
          }, e.prototype.sortPathConstraint = function (e) {
            if (e.active = e.target.bone.isActive() && (!e.data.skinRequired || null != this.skin && t.Utils.contains(this.skin.constraints, e.data, !0)), e.active) {
              var n = e.target,
                  i = n.data.index,
                  r = n.bone;
              null != this.skin && this.sortPathConstraintAttachment(this.skin, i, r), null != this.data.defaultSkin && this.data.defaultSkin != this.skin && this.sortPathConstraintAttachment(this.data.defaultSkin, i, r);

              for (var a = 0, s = this.data.skins.length; a < s; a++) {
                this.sortPathConstraintAttachment(this.data.skins[a], i, r);
              }

              var o = n.getAttachment();
              o instanceof t.PathAttachment && this.sortPathConstraintAttachmentWith(o, r);
              var l = e.bones,
                  h = l.length;

              for (a = 0; a < h; a++) {
                this.sortBone(l[a]);
              }

              for (this._updateCache.push(e), a = 0; a < h; a++) {
                this.sortReset(l[a].children);
              }

              for (a = 0; a < h; a++) {
                l[a].sorted = !0;
              }
            }
          }, e.prototype.sortTransformConstraint = function (e) {
            if (e.active = e.target.isActive() && (!e.data.skinRequired || null != this.skin && t.Utils.contains(this.skin.constraints, e.data, !0)), e.active) {
              this.sortBone(e.target);
              var n = e.bones,
                  i = n.length;
              if (e.data.local) for (var r = 0; r < i; r++) {
                var a = n[r];
                this.sortBone(a.parent), this._updateCache.indexOf(a) > -1 || this.updateCacheReset.push(a);
              } else for (r = 0; r < i; r++) {
                this.sortBone(n[r]);
              }

              this._updateCache.push(e);

              for (var s = 0; s < i; s++) {
                this.sortReset(n[s].children);
              }

              for (s = 0; s < i; s++) {
                n[s].sorted = !0;
              }
            }
          }, e.prototype.sortPathConstraintAttachment = function (t, e, n) {
            var i = t.attachments[e];
            if (i) for (var r in i) {
              this.sortPathConstraintAttachmentWith(i[r], n);
            }
          }, e.prototype.sortPathConstraintAttachmentWith = function (e, n) {
            if (e instanceof t.PathAttachment) {
              var i = e.bones;
              if (null == i) this.sortBone(n);else for (var r = this.bones, a = 0; a < i.length;) {
                for (var s = i[a++], o = a + s; a < o; a++) {
                  var l = i[a];
                  this.sortBone(r[l]);
                }
              }
            }
          }, e.prototype.sortBone = function (t) {
            if (!t.sorted) {
              var e = t.parent;
              null != e && this.sortBone(e), t.sorted = !0, this._updateCache.push(t);
            }
          }, e.prototype.sortReset = function (t) {
            for (var e = 0, n = t.length; e < n; e++) {
              var i = t[e];
              i.active && (i.sorted && this.sortReset(i.children), i.sorted = !1);
            }
          }, e.prototype.updateWorldTransform = function () {
            for (var t = this.updateCacheReset, e = 0, n = t.length; e < n; e++) {
              var i = t[e];
              i.ax = i.x, i.ay = i.y, i.arotation = i.rotation, i.ascaleX = i.scaleX, i.ascaleY = i.scaleY, i.ashearX = i.shearX, i.ashearY = i.shearY, i.appliedValid = !0;
            }

            var r = this._updateCache;

            for (e = 0, n = r.length; e < n; e++) {
              r[e].update();
            }
          }, e.prototype.setToSetupPose = function () {
            this.setBonesToSetupPose(), this.setSlotsToSetupPose();
          }, e.prototype.setBonesToSetupPose = function () {
            for (var t = this.bones, e = 0, n = t.length; e < n; e++) {
              t[e].setToSetupPose();
            }

            var i = this.ikConstraints;

            for (e = 0, n = i.length; e < n; e++) {
              (o = i[e]).mix = o.data.mix, o.softness = o.data.softness, o.bendDirection = o.data.bendDirection, o.compress = o.data.compress, o.stretch = o.data.stretch;
            }

            var r = this.transformConstraints;

            for (e = 0, n = r.length; e < n; e++) {
              var a = (o = r[e]).data;
              o.rotateMix = a.rotateMix, o.translateMix = a.translateMix, o.scaleMix = a.scaleMix, o.shearMix = a.shearMix;
            }

            var s = this.pathConstraints;

            for (e = 0, n = s.length; e < n; e++) {
              var o;
              a = (o = s[e]).data, o.position = a.position, o.spacing = a.spacing, o.rotateMix = a.rotateMix, o.translateMix = a.translateMix;
            }
          }, e.prototype.setSlotsToSetupPose = function () {
            var e = this.slots;
            t.Utils.arrayCopy(e, 0, this.drawOrder, 0, e.length);

            for (var n = 0, i = e.length; n < i; n++) {
              e[n].setToSetupPose();
            }
          }, e.prototype.getRootBone = function () {
            return 0 == this.bones.length ? null : this.bones[0];
          }, e.prototype.findBone = function (t) {
            if (null == t) throw new Error("boneName cannot be null.");

            for (var e = this.bones, n = 0, i = e.length; n < i; n++) {
              var r = e[n];
              if (r.data.name == t) return r;
            }

            return null;
          }, e.prototype.findBoneIndex = function (t) {
            if (null == t) throw new Error("boneName cannot be null.");

            for (var e = this.bones, n = 0, i = e.length; n < i; n++) {
              if (e[n].data.name == t) return n;
            }

            return -1;
          }, e.prototype.findSlot = function (t) {
            if (null == t) throw new Error("slotName cannot be null.");

            for (var e = this.slots, n = 0, i = e.length; n < i; n++) {
              var r = e[n];
              if (r.data.name == t) return r;
            }

            return null;
          }, e.prototype.findSlotIndex = function (t) {
            if (null == t) throw new Error("slotName cannot be null.");

            for (var e = this.slots, n = 0, i = e.length; n < i; n++) {
              if (e[n].data.name == t) return n;
            }

            return -1;
          }, e.prototype.setSkinByName = function (t) {
            var e = this.data.findSkin(t);
            if (null == e) throw new Error("Skin not found: " + t);
            this.setSkin(e);
          }, e.prototype.setSkin = function (t) {
            if (t != this.skin) {
              if (null != t) if (null != this.skin) t.attachAll(this, this.skin);else for (var e = this.slots, n = 0, i = e.length; n < i; n++) {
                var r = e[n],
                    a = r.data.attachmentName;

                if (null != a) {
                  var s = t.getAttachment(n, a);
                  null != s && r.setAttachment(s);
                }
              }
              this.skin = t, this.updateCache();
            }
          }, e.prototype.getAttachmentByName = function (t, e) {
            return this.getAttachment(this.data.findSlotIndex(t), e);
          }, e.prototype.getAttachment = function (t, e) {
            if (null == e) throw new Error("attachmentName cannot be null.");

            if (null != this.skin) {
              var n = this.skin.getAttachment(t, e);
              if (null != n) return n;
            }

            return null != this.data.defaultSkin ? this.data.defaultSkin.getAttachment(t, e) : null;
          }, e.prototype.setAttachment = function (t, e) {
            if (null == t) throw new Error("slotName cannot be null.");

            for (var n = this.slots, i = 0, r = n.length; i < r; i++) {
              var a = n[i];

              if (a.data.name == t) {
                var s = null;
                if (null != e && null == (s = this.getAttachment(i, e))) throw new Error("Attachment not found: " + e + ", for slot: " + t);
                return void a.setAttachment(s);
              }
            }

            throw new Error("Slot not found: " + t);
          }, e.prototype.findIkConstraint = function (t) {
            if (null == t) throw new Error("constraintName cannot be null.");

            for (var e = this.ikConstraints, n = 0, i = e.length; n < i; n++) {
              var r = e[n];
              if (r.data.name == t) return r;
            }

            return null;
          }, e.prototype.findTransformConstraint = function (t) {
            if (null == t) throw new Error("constraintName cannot be null.");

            for (var e = this.transformConstraints, n = 0, i = e.length; n < i; n++) {
              var r = e[n];
              if (r.data.name == t) return r;
            }

            return null;
          }, e.prototype.findPathConstraint = function (t) {
            if (null == t) throw new Error("constraintName cannot be null.");

            for (var e = this.pathConstraints, n = 0, i = e.length; n < i; n++) {
              var r = e[n];
              if (r.data.name == t) return r;
            }

            return null;
          }, e.prototype.getBounds = function (e, n, i) {
            if (void 0 === i && (i = new Array(2)), null == e) throw new Error("offset cannot be null.");
            if (null == n) throw new Error("size cannot be null.");

            for (var r = this.drawOrder, a = Number.POSITIVE_INFINITY, s = Number.POSITIVE_INFINITY, o = Number.NEGATIVE_INFINITY, l = Number.NEGATIVE_INFINITY, h = 0, u = r.length; h < u; h++) {
              var c = r[h];

              if (c.bone.active) {
                var d = 0,
                    f = null,
                    p = c.getAttachment();
                if (p instanceof t.RegionAttachment) d = 8, f = t.Utils.setArraySize(i, d, 0), p.computeWorldVertices(c.bone, f, 0, 2);else if (p instanceof t.MeshAttachment) {
                  var m = p;
                  d = m.worldVerticesLength, f = t.Utils.setArraySize(i, d, 0), m.computeWorldVertices(c, 0, d, f, 0, 2);
                }
                if (null != f) for (var g = 0, v = f.length; g < v; g += 2) {
                  var y = f[g],
                      x = f[g + 1];
                  a = Math.min(a, y), s = Math.min(s, x), o = Math.max(o, y), l = Math.max(l, x);
                }
              }
            }

            e.set(a, s), n.set(o - a, l - s);
          }, e.prototype.update = function (t) {
            this.time += t;
          }, e;
        }();

        t.Skeleton = e;
      }(K || (K = {})), function (t) {
        var e = function () {
          function e(t) {
            this.scale = 1, this.linkedMeshes = new Array(), this.attachmentLoader = t;
          }

          return e.prototype.readSkeletonData = function (i) {
            var r = this.scale,
                a = new t.SkeletonData();
            a.name = "";
            var s = new n(i);
            a.hash = s.readString(), a.version = s.readString(), a.x = s.readFloat(), a.y = s.readFloat(), a.width = s.readFloat(), a.height = s.readFloat();
            var o = s.readBoolean();
            o && (a.fps = s.readFloat(), a.imagesPath = s.readString(), a.audioPath = s.readString());
            var l = 0;
            l = s.readInt(!0);

            for (var h = 0; h < l; h++) {
              s.strings.push(s.readString());
            }

            for (l = s.readInt(!0), h = 0; h < l; h++) {
              var u = s.readString(),
                  c = 0 == h ? null : a.bones[s.readInt(!0)];
              (p = new t.BoneData(h, u, c)).rotation = s.readFloat(), p.x = s.readFloat() * r, p.y = s.readFloat() * r, p.scaleX = s.readFloat(), p.scaleY = s.readFloat(), p.shearX = s.readFloat(), p.shearY = s.readFloat(), p.length = s.readFloat() * r, p.transformMode = e.TransformModeValues[s.readInt(!0)], p.skinRequired = s.readBoolean(), o && t.Color.rgba8888ToColor(p.color, s.readInt32()), a.bones.push(p);
            }

            for (l = s.readInt(!0), h = 0; h < l; h++) {
              var d = s.readString(),
                  f = a.bones[s.readInt(!0)],
                  p = new t.SlotData(h, d, f);
              t.Color.rgba8888ToColor(p.color, s.readInt32());
              var m = s.readInt32();
              -1 != m && t.Color.rgb888ToColor(p.darkColor = new t.Color(), m), p.attachmentName = s.readStringRef(), p.blendMode = e.BlendModeValues[s.readInt(!0)], a.slots.push(p);
            }

            l = s.readInt(!0), h = 0;

            for (var g = void 0; h < l; h++) {
              (p = new t.IkConstraintData(s.readString())).order = s.readInt(!0), p.skinRequired = s.readBoolean(), g = s.readInt(!0);

              for (var v = 0; v < g; v++) {
                p.bones.push(a.bones[s.readInt(!0)]);
              }

              p.target = a.bones[s.readInt(!0)], p.mix = s.readFloat(), p.softness = s.readFloat() * r, p.bendDirection = s.readByte(), p.compress = s.readBoolean(), p.stretch = s.readBoolean(), p.uniform = s.readBoolean(), a.ikConstraints.push(p);
            }

            for (l = s.readInt(!0), h = 0, g = void 0; h < l; h++) {
              for ((p = new t.TransformConstraintData(s.readString())).order = s.readInt(!0), p.skinRequired = s.readBoolean(), g = s.readInt(!0), v = 0; v < g; v++) {
                p.bones.push(a.bones[s.readInt(!0)]);
              }

              p.target = a.bones[s.readInt(!0)], p.local = s.readBoolean(), p.relative = s.readBoolean(), p.offsetRotation = s.readFloat(), p.offsetX = s.readFloat() * r, p.offsetY = s.readFloat() * r, p.offsetScaleX = s.readFloat(), p.offsetScaleY = s.readFloat(), p.offsetShearY = s.readFloat(), p.rotateMix = s.readFloat(), p.translateMix = s.readFloat(), p.scaleMix = s.readFloat(), p.shearMix = s.readFloat(), a.transformConstraints.push(p);
            }

            for (l = s.readInt(!0), h = 0, g = void 0; h < l; h++) {
              for ((p = new t.PathConstraintData(s.readString())).order = s.readInt(!0), p.skinRequired = s.readBoolean(), g = s.readInt(!0), v = 0; v < g; v++) {
                p.bones.push(a.bones[s.readInt(!0)]);
              }

              p.target = a.slots[s.readInt(!0)], p.positionMode = e.PositionModeValues[s.readInt(!0)], p.spacingMode = e.SpacingModeValues[s.readInt(!0)], p.rotateMode = e.RotateModeValues[s.readInt(!0)], p.offsetRotation = s.readFloat(), p.position = s.readFloat(), p.positionMode == t.PositionMode.Fixed && (p.position *= r), p.spacing = s.readFloat(), p.spacingMode != t.SpacingMode.Length && p.spacingMode != t.SpacingMode.Fixed || (p.spacing *= r), p.rotateMix = s.readFloat(), p.translateMix = s.readFloat(), a.pathConstraints.push(p);
            }

            var y = this.readSkin(s, a, !0, o);

            for (null != y && (a.defaultSkin = y, a.skins.push(y)), h = a.skins.length, t.Utils.setArraySize(a.skins, l = h + s.readInt(!0)); h < l; h++) {
              a.skins[h] = this.readSkin(s, a, !1, o);
            }

            for (l = this.linkedMeshes.length, h = 0; h < l; h++) {
              var x = this.linkedMeshes[h],
                  w = null == x.skin ? a.defaultSkin : a.findSkin(x.skin);
              if (null == w) throw new Error("Skin not found: " + x.skin);

              var _ = w.getAttachment(x.slotIndex, x.parent);

              if (null == _) throw new Error("Parent mesh not found: " + x.parent);
              x.mesh.deformAttachment = x.inheritDeform ? _ : x.mesh, x.mesh.setParentMesh(_), x.mesh.updateUVs();
            }

            for (this.linkedMeshes.length = 0, l = s.readInt(!0), h = 0; h < l; h++) {
              (p = new t.EventData(s.readStringRef())).intValue = s.readInt(!1), p.floatValue = s.readFloat(), p.stringValue = s.readString(), p.audioPath = s.readString(), null != p.audioPath && (p.volume = s.readFloat(), p.balance = s.readFloat()), a.events.push(p);
            }

            for (l = s.readInt(!0), h = 0; h < l; h++) {
              a.animations.push(this.readAnimation(s, s.readString(), a));
            }

            return a;
          }, e.prototype.readSkin = function (e, n, i, r) {
            var a = null,
                s = 0;

            if (i) {
              if (0 == (s = e.readInt(!0))) return null;
              a = new t.Skin("default");
            } else {
              (a = new t.Skin(e.readStringRef())).bones.length = e.readInt(!0);

              for (var o = 0, l = a.bones.length; o < l; o++) {
                a.bones[o] = n.bones[e.readInt(!0)];
              }

              for (o = 0, l = e.readInt(!0); o < l; o++) {
                a.constraints.push(n.ikConstraints[e.readInt(!0)]);
              }

              for (o = 0, l = e.readInt(!0); o < l; o++) {
                a.constraints.push(n.transformConstraints[e.readInt(!0)]);
              }

              for (o = 0, l = e.readInt(!0); o < l; o++) {
                a.constraints.push(n.pathConstraints[e.readInt(!0)]);
              }

              s = e.readInt(!0);
            }

            for (o = 0; o < s; o++) {
              for (var h = e.readInt(!0), u = 0, c = e.readInt(!0); u < c; u++) {
                var d = e.readStringRef(),
                    f = this.readAttachment(e, n, a, h, d, r);
                null != f && a.setAttachment(h, d, f);
              }
            }

            return a;
          }, e.prototype.readAttachment = function (n, r, a, s, o, l) {
            var h = this.scale,
                u = n.readStringRef();
            null == u && (u = o);
            var c = n.readByte();

            switch (e.AttachmentTypeValues[c]) {
              case t.AttachmentType.Region:
                var d = n.readStringRef(),
                    f = n.readFloat(),
                    p = n.readFloat(),
                    m = n.readFloat(),
                    g = n.readFloat(),
                    v = n.readFloat(),
                    y = n.readFloat(),
                    x = n.readFloat(),
                    w = n.readInt32();
                null == d && (d = u);

                var _ = this.attachmentLoader.newRegionAttachment(a, u, d);

                return null == _ ? null : (_.path = d, _.x = p * h, _.y = m * h, _.scaleX = g, _.scaleY = v, _.rotation = f, _.width = y * h, _.height = x * h, t.Color.rgba8888ToColor(_.color, w), _.updateOffset(), _);

              case t.AttachmentType.BoundingBox:
                var E = n.readInt(!0),
                    b = this.readVertices(n, E),
                    T = (w = l ? n.readInt32() : 0, this.attachmentLoader.newBoundingBoxAttachment(a, u));
                return null == T ? null : (T.worldVerticesLength = E << 1, T.vertices = b.vertices, T.bones = b.bones, l && t.Color.rgba8888ToColor(T.color, w), T);

              case t.AttachmentType.Mesh:
                d = n.readStringRef(), w = n.readInt32(), E = n.readInt(!0);
                var M = this.readFloatArray(n, E << 1, 1),
                    A = this.readShortArray(n),
                    C = (b = this.readVertices(n, E), n.readInt(!0)),
                    S = null;
                return y = 0, x = 0, l && (S = this.readShortArray(n), y = n.readFloat(), x = n.readFloat()), null == d && (d = u), null == (k = this.attachmentLoader.newMeshAttachment(a, u, d)) ? null : (k.path = d, t.Color.rgba8888ToColor(k.color, w), k.bones = b.bones, k.vertices = b.vertices, k.worldVerticesLength = E << 1, k.triangles = A, k.regionUVs = M, k.updateUVs(), k.hullLength = C << 1, l && (k.edges = S, k.width = y * h, k.height = x * h), k);

              case t.AttachmentType.LinkedMesh:
                d = n.readStringRef(), w = n.readInt32();
                var k,
                    I = n.readStringRef(),
                    R = n.readStringRef(),
                    P = n.readBoolean();
                return y = 0, x = 0, l && (y = n.readFloat(), x = n.readFloat()), null == d && (d = u), null == (k = this.attachmentLoader.newMeshAttachment(a, u, d)) ? null : (k.path = d, t.Color.rgba8888ToColor(k.color, w), l && (k.width = y * h, k.height = x * h), this.linkedMeshes.push(new i(k, I, s, R, P)), k);

              case t.AttachmentType.Path:
                for (var V = n.readBoolean(), D = n.readBoolean(), N = (E = n.readInt(!0), b = this.readVertices(n, E), t.Utils.newArray(E / 3, 0)), F = 0, O = N.length; F < O; F++) {
                  N[F] = n.readFloat() * h;
                }

                return w = l ? n.readInt32() : 0, null == (d = this.attachmentLoader.newPathAttachment(a, u)) ? null : (d.closed = V, d.constantSpeed = D, d.worldVerticesLength = E << 1, d.vertices = b.vertices, d.bones = b.bones, d.lengths = N, l && t.Color.rgba8888ToColor(d.color, w), d);

              case t.AttachmentType.Point:
                f = n.readFloat(), p = n.readFloat(), m = n.readFloat(), w = l ? n.readInt32() : 0;
                var L = this.attachmentLoader.newPointAttachment(a, u);
                return null == L ? null : (L.x = p * h, L.y = m * h, L.rotation = f, l && t.Color.rgba8888ToColor(L.color, w), L);

              case t.AttachmentType.Clipping:
                var U = n.readInt(!0),
                    B = (E = n.readInt(!0), b = this.readVertices(n, E), w = l ? n.readInt32() : 0, this.attachmentLoader.newClippingAttachment(a, u));
                return null == B ? null : (B.endSlot = r.slots[U], B.worldVerticesLength = E << 1, B.vertices = b.vertices, B.bones = b.bones, l && t.Color.rgba8888ToColor(B.color, w), B);
            }

            return null;
          }, e.prototype.readVertices = function (e, n) {
            var i = n << 1,
                a = new r(),
                s = this.scale;
            if (!e.readBoolean()) return a.vertices = this.readFloatArray(e, i, s), a;

            for (var o = new Array(), l = new Array(), h = 0; h < n; h++) {
              var u = e.readInt(!0);
              l.push(u);

              for (var c = 0; c < u; c++) {
                l.push(e.readInt(!0)), o.push(e.readFloat() * s), o.push(e.readFloat() * s), o.push(e.readFloat());
              }
            }

            return a.vertices = t.Utils.toFloatArray(o), a.bones = l, a;
          }, e.prototype.readFloatArray = function (t, e, n) {
            var i = new Array(e);
            if (1 == n) for (var r = 0; r < e; r++) {
              i[r] = t.readFloat();
            } else for (r = 0; r < e; r++) {
              i[r] = t.readFloat() * n;
            }
            return i;
          }, e.prototype.readShortArray = function (t) {
            for (var e = t.readInt(!0), n = new Array(e), i = 0; i < e; i++) {
              n[i] = t.readShort();
            }

            return n;
          }, e.prototype.readAnimation = function (n, i, r) {
            for (var a = new Array(), s = this.scale, o = 0, l = new t.Color(), h = new t.Color(), u = 0, c = n.readInt(!0); u < c; u++) {
              for (var d = n.readInt(!0), f = 0, p = n.readInt(!0); f < p; f++) {
                var m = n.readByte(),
                    g = n.readInt(!0);

                switch (m) {
                  case e.SLOT_ATTACHMENT:
                    (w = new t.AttachmentTimeline(g)).slotIndex = d;

                    for (var v = 0; v < g; v++) {
                      w.setFrame(v, n.readFloat(), n.readStringRef());
                    }

                    a.push(w), o = Math.max(o, w.frames[g - 1]);
                    break;

                  case e.SLOT_COLOR:
                    for ((w = new t.ColorTimeline(g)).slotIndex = d, v = 0; v < g; v++) {
                      var y = n.readFloat();
                      t.Color.rgba8888ToColor(l, n.readInt32()), w.setFrame(v, y, l.r, l.g, l.b, l.a), v < g - 1 && this.readCurve(n, v, w);
                    }

                    a.push(w), o = Math.max(o, w.frames[(g - 1) * t.ColorTimeline.ENTRIES]);
                    break;

                  case e.SLOT_TWO_COLOR:
                    for ((w = new t.TwoColorTimeline(g)).slotIndex = d, v = 0; v < g; v++) {
                      y = n.readFloat(), t.Color.rgba8888ToColor(l, n.readInt32()), t.Color.rgb888ToColor(h, n.readInt32()), w.setFrame(v, y, l.r, l.g, l.b, l.a, h.r, h.g, h.b), v < g - 1 && this.readCurve(n, v, w);
                    }

                    a.push(w), o = Math.max(o, w.frames[(g - 1) * t.TwoColorTimeline.ENTRIES]);
                }
              }
            }

            for (u = 0, c = n.readInt(!0); u < c; u++) {
              var x = n.readInt(!0);

              for (f = 0, p = n.readInt(!0); f < p; f++) {
                switch (m = n.readByte(), g = n.readInt(!0), m) {
                  case e.BONE_ROTATE:
                    for ((w = new t.RotateTimeline(g)).boneIndex = x, v = 0; v < g; v++) {
                      w.setFrame(v, n.readFloat(), n.readFloat()), v < g - 1 && this.readCurve(n, v, w);
                    }

                    a.push(w), o = Math.max(o, w.frames[(g - 1) * t.RotateTimeline.ENTRIES]);
                    break;

                  case e.BONE_TRANSLATE:
                  case e.BONE_SCALE:
                  case e.BONE_SHEAR:
                    var w = void 0,
                        _ = 1;

                    for (m == e.BONE_SCALE ? w = new t.ScaleTimeline(g) : m == e.BONE_SHEAR ? w = new t.ShearTimeline(g) : (w = new t.TranslateTimeline(g), _ = s), w.boneIndex = x, v = 0; v < g; v++) {
                      w.setFrame(v, n.readFloat(), n.readFloat() * _, n.readFloat() * _), v < g - 1 && this.readCurve(n, v, w);
                    }

                    a.push(w), o = Math.max(o, w.frames[(g - 1) * t.TranslateTimeline.ENTRIES]);
                }
              }
            }

            for (u = 0, c = n.readInt(!0); u < c; u++) {
              var E = n.readInt(!0);

              for (g = n.readInt(!0), (w = new t.IkConstraintTimeline(g)).ikConstraintIndex = E, v = 0; v < g; v++) {
                w.setFrame(v, n.readFloat(), n.readFloat(), n.readFloat() * s, n.readByte(), n.readBoolean(), n.readBoolean()), v < g - 1 && this.readCurve(n, v, w);
              }

              a.push(w), o = Math.max(o, w.frames[(g - 1) * t.IkConstraintTimeline.ENTRIES]);
            }

            for (u = 0, c = n.readInt(!0); u < c; u++) {
              for (E = n.readInt(!0), g = n.readInt(!0), (w = new t.TransformConstraintTimeline(g)).transformConstraintIndex = E, v = 0; v < g; v++) {
                w.setFrame(v, n.readFloat(), n.readFloat(), n.readFloat(), n.readFloat(), n.readFloat()), v < g - 1 && this.readCurve(n, v, w);
              }

              a.push(w), o = Math.max(o, w.frames[(g - 1) * t.TransformConstraintTimeline.ENTRIES]);
            }

            for (u = 0, c = n.readInt(!0); u < c; u++) {
              E = n.readInt(!0);
              var b = r.pathConstraints[E];

              for (f = 0, p = n.readInt(!0); f < p; f++) {
                switch (m = n.readByte(), g = n.readInt(!0), m) {
                  case e.PATH_POSITION:
                  case e.PATH_SPACING:
                    for (w = void 0, _ = 1, m == e.PATH_SPACING ? (w = new t.PathConstraintSpacingTimeline(g), b.spacingMode != t.SpacingMode.Length && b.spacingMode != t.SpacingMode.Fixed || (_ = s)) : (w = new t.PathConstraintPositionTimeline(g), b.positionMode == t.PositionMode.Fixed && (_ = s)), w.pathConstraintIndex = E, v = 0; v < g; v++) {
                      w.setFrame(v, n.readFloat(), n.readFloat() * _), v < g - 1 && this.readCurve(n, v, w);
                    }

                    a.push(w), o = Math.max(o, w.frames[(g - 1) * t.PathConstraintPositionTimeline.ENTRIES]);
                    break;

                  case e.PATH_MIX:
                    for ((w = new t.PathConstraintMixTimeline(g)).pathConstraintIndex = E, v = 0; v < g; v++) {
                      w.setFrame(v, n.readFloat(), n.readFloat(), n.readFloat()), v < g - 1 && this.readCurve(n, v, w);
                    }

                    a.push(w), o = Math.max(o, w.frames[(g - 1) * t.PathConstraintMixTimeline.ENTRIES]);
                }
              }
            }

            for (u = 0, c = n.readInt(!0); u < c; u++) {
              var T = r.skins[n.readInt(!0)];

              for (f = 0, p = n.readInt(!0); f < p; f++) {
                d = n.readInt(!0);

                for (var M = 0, A = n.readInt(!0); M < A; M++) {
                  var C = T.getAttachment(d, n.readStringRef()),
                      S = null != C.bones,
                      k = C.vertices,
                      I = S ? k.length / 3 * 2 : k.length;

                  for (g = n.readInt(!0), (w = new t.DeformTimeline(g)).slotIndex = d, w.attachment = C, v = 0; v < g; v++) {
                    y = n.readFloat();
                    var R = void 0,
                        P = n.readInt(!0);
                    if (0 == P) R = S ? t.Utils.newFloatArray(I) : k;else {
                      R = t.Utils.newFloatArray(I);
                      var V = n.readInt(!0);
                      if (P += V, 1 == s) for (var D = V; D < P; D++) {
                        R[D] = n.readFloat();
                      } else for (D = V; D < P; D++) {
                        R[D] = n.readFloat() * s;
                      }

                      if (!S) {
                        D = 0;

                        for (var N = R.length; D < N; D++) {
                          R[D] += k[D];
                        }
                      }
                    }
                    w.setFrame(v, y, R), v < g - 1 && this.readCurve(n, v, w);
                  }

                  a.push(w), o = Math.max(o, w.frames[g - 1]);
                }
              }
            }

            var F = n.readInt(!0);

            if (F > 0) {
              w = new t.DrawOrderTimeline(F);
              var O = r.slots.length;

              for (u = 0; u < F; u++) {
                y = n.readFloat();
                var L = n.readInt(!0),
                    U = t.Utils.newArray(O, 0);

                for (f = O - 1; f >= 0; f--) {
                  U[f] = -1;
                }

                var B = t.Utils.newArray(O - L, 0),
                    Y = 0,
                    X = 0;

                for (f = 0; f < L; f++) {
                  for (d = n.readInt(!0); Y != d;) {
                    B[X++] = Y++;
                  }

                  U[Y + n.readInt(!0)] = Y++;
                }

                for (; Y < O;) {
                  B[X++] = Y++;
                }

                for (f = O - 1; f >= 0; f--) {
                  -1 == U[f] && (U[f] = B[--X]);
                }

                w.setFrame(u, y, U);
              }

              a.push(w), o = Math.max(o, w.frames[F - 1]);
            }

            var W = n.readInt(!0);

            if (W > 0) {
              for (w = new t.EventTimeline(W), u = 0; u < W; u++) {
                y = n.readFloat();
                var q = r.events[n.readInt(!0)],
                    H = new t.Event(y, q);
                H.intValue = n.readInt(!1), H.floatValue = n.readFloat(), H.stringValue = n.readBoolean() ? n.readString() : q.stringValue, null != H.data.audioPath && (H.volume = n.readFloat(), H.balance = n.readFloat()), w.setFrame(u, H);
              }

              a.push(w), o = Math.max(o, w.frames[W - 1]);
            }

            return new t.Animation(i, a, o);
          }, e.prototype.readCurve = function (t, n, i) {
            switch (t.readByte()) {
              case e.CURVE_STEPPED:
                i.setStepped(n);
                break;

              case e.CURVE_BEZIER:
                this.setCurve(i, n, t.readFloat(), t.readFloat(), t.readFloat(), t.readFloat());
            }
          }, e.prototype.setCurve = function (t, e, n, i, r, a) {
            t.setCurve(e, n, i, r, a);
          }, e.AttachmentTypeValues = [0, 1, 2, 3, 4, 5, 6], e.TransformModeValues = [t.TransformMode.Normal, t.TransformMode.OnlyTranslation, t.TransformMode.NoRotationOrReflection, t.TransformMode.NoScale, t.TransformMode.NoScaleOrReflection], e.PositionModeValues = [t.PositionMode.Fixed, t.PositionMode.Percent], e.SpacingModeValues = [t.SpacingMode.Length, t.SpacingMode.Fixed, t.SpacingMode.Percent], e.RotateModeValues = [t.RotateMode.Tangent, t.RotateMode.Chain, t.RotateMode.ChainScale], e.BlendModeValues = [t.BlendMode.Normal, t.BlendMode.Additive, t.BlendMode.Multiply, t.BlendMode.Screen], e.BONE_ROTATE = 0, e.BONE_TRANSLATE = 1, e.BONE_SCALE = 2, e.BONE_SHEAR = 3, e.SLOT_ATTACHMENT = 0, e.SLOT_COLOR = 1, e.SLOT_TWO_COLOR = 2, e.PATH_POSITION = 0, e.PATH_SPACING = 1, e.PATH_MIX = 2, e.CURVE_LINEAR = 0, e.CURVE_STEPPED = 1, e.CURVE_BEZIER = 2, e;
        }();

        t.SkeletonBinary = e;

        var n = function () {
          function t(t, e, n, i) {
            void 0 === e && (e = new Array()), void 0 === n && (n = 0), void 0 === i && (i = new DataView(t.buffer)), this.strings = e, this.index = n, this.buffer = i;
          }

          return t.prototype.readByte = function () {
            return this.buffer.getInt8(this.index++);
          }, t.prototype.readShort = function () {
            var t = this.buffer.getInt16(this.index);
            return this.index += 2, t;
          }, t.prototype.readInt32 = function () {
            var t = this.buffer.getInt32(this.index);
            return this.index += 4, t;
          }, t.prototype.readInt = function (t) {
            var e = this.readByte(),
                n = 127 & e;
            return 0 != (128 & e) && (n |= (127 & (e = this.readByte())) << 7, 0 != (128 & e) && (n |= (127 & (e = this.readByte())) << 14, 0 != (128 & e) && (n |= (127 & (e = this.readByte())) << 21, 0 != (128 & e) && (n |= (127 & (e = this.readByte())) << 28)))), t ? n : n >>> 1 ^ -(1 & n);
          }, t.prototype.readStringRef = function () {
            var t = this.readInt(!0);
            return 0 == t ? null : this.strings[t - 1];
          }, t.prototype.readString = function () {
            var t = this.readInt(!0);

            switch (t) {
              case 0:
                return null;

              case 1:
                return "";
            }

            t--;

            for (var e = "", n = 0; n < t;) {
              var i = this.readByte();

              switch (i >> 4) {
                case 12:
                case 13:
                  e += String.fromCharCode((31 & i) << 6 | 63 & this.readByte()), n += 2;
                  break;

                case 14:
                  e += String.fromCharCode((15 & i) << 12 | (63 & this.readByte()) << 6 | 63 & this.readByte()), n += 3;
                  break;

                default:
                  e += String.fromCharCode(i), n++;
              }
            }

            return e;
          }, t.prototype.readFloat = function () {
            var t = this.buffer.getFloat32(this.index);
            return this.index += 4, t;
          }, t.prototype.readBoolean = function () {
            return 0 != this.readByte();
          }, t;
        }(),
            i = function i(t, e, n, _i, r) {
          this.mesh = t, this.skin = e, this.slotIndex = n, this.parent = _i, this.inheritDeform = r;
        },
            r = function r(t, e) {
          void 0 === t && (t = null), void 0 === e && (e = null), this.bones = t, this.vertices = e;
        };
      }(K || (K = {})), function (t) {
        var e = function () {
          function e() {
            this.minX = 0, this.minY = 0, this.maxX = 0, this.maxY = 0, this.boundingBoxes = new Array(), this.polygons = new Array(), this.polygonPool = new t.Pool(function () {
              return t.Utils.newFloatArray(16);
            });
          }

          return e.prototype.update = function (e, n) {
            if (null == e) throw new Error("skeleton cannot be null.");
            var i = this.boundingBoxes,
                r = this.polygons,
                a = this.polygonPool,
                s = e.slots,
                o = s.length;
            i.length = 0, a.freeAll(r), r.length = 0;

            for (var l = 0; l < o; l++) {
              var h = s[l];

              if (h.bone.active) {
                var u = h.getAttachment();

                if (u instanceof t.BoundingBoxAttachment) {
                  var c = u;
                  i.push(c);
                  var d = a.obtain();
                  d.length != c.worldVerticesLength && (d = t.Utils.newFloatArray(c.worldVerticesLength)), r.push(d), c.computeWorldVertices(h, 0, c.worldVerticesLength, d, 0, 2);
                }
              }
            }

            n ? this.aabbCompute() : (this.minX = Number.POSITIVE_INFINITY, this.minY = Number.POSITIVE_INFINITY, this.maxX = Number.NEGATIVE_INFINITY, this.maxY = Number.NEGATIVE_INFINITY);
          }, e.prototype.aabbCompute = function () {
            for (var t = Number.POSITIVE_INFINITY, e = Number.POSITIVE_INFINITY, n = Number.NEGATIVE_INFINITY, i = Number.NEGATIVE_INFINITY, r = this.polygons, a = 0, s = r.length; a < s; a++) {
              for (var o = r[a], l = o, h = 0, u = o.length; h < u; h += 2) {
                var c = l[h],
                    d = l[h + 1];
                t = Math.min(t, c), e = Math.min(e, d), n = Math.max(n, c), i = Math.max(i, d);
              }
            }

            this.minX = t, this.minY = e, this.maxX = n, this.maxY = i;
          }, e.prototype.aabbContainsPoint = function (t, e) {
            return t >= this.minX && t <= this.maxX && e >= this.minY && e <= this.maxY;
          }, e.prototype.aabbIntersectsSegment = function (t, e, n, i) {
            var r = this.minX,
                a = this.minY,
                s = this.maxX,
                o = this.maxY;
            if (t <= r && n <= r || e <= a && i <= a || t >= s && n >= s || e >= o && i >= o) return !1;
            var l = (i - e) / (n - t),
                h = l * (r - t) + e;
            if (h > a && h < o) return !0;
            if ((h = l * (s - t) + e) > a && h < o) return !0;
            var u = (a - e) / l + t;
            return u > r && u < s || (u = (o - e) / l + t) > r && u < s;
          }, e.prototype.aabbIntersectsSkeleton = function (t) {
            return this.minX < t.maxX && this.maxX > t.minX && this.minY < t.maxY && this.maxY > t.minY;
          }, e.prototype.containsPoint = function (t, e) {
            for (var n = this.polygons, i = 0, r = n.length; i < r; i++) {
              if (this.containsPointPolygon(n[i], t, e)) return this.boundingBoxes[i];
            }

            return null;
          }, e.prototype.containsPointPolygon = function (t, e, n) {
            for (var i = t, r = t.length, a = r - 2, s = !1, o = 0; o < r; o += 2) {
              var l = i[o + 1],
                  h = i[a + 1];

              if (l < n && h >= n || h < n && l >= n) {
                var u = i[o];
                u + (n - l) / (h - l) * (i[a] - u) < e && (s = !s);
              }

              a = o;
            }

            return s;
          }, e.prototype.intersectsSegment = function (t, e, n, i) {
            for (var r = this.polygons, a = 0, s = r.length; a < s; a++) {
              if (this.intersectsSegmentPolygon(r[a], t, e, n, i)) return this.boundingBoxes[a];
            }

            return null;
          }, e.prototype.intersectsSegmentPolygon = function (t, e, n, i, r) {
            for (var a = t, s = t.length, o = e - i, l = n - r, h = e * r - n * i, u = a[s - 2], c = a[s - 1], d = 0; d < s; d += 2) {
              var f = a[d],
                  p = a[d + 1],
                  m = u * p - c * f,
                  g = u - f,
                  v = c - p,
                  y = o * v - l * g,
                  x = (h * g - o * m) / y;

              if ((x >= u && x <= f || x >= f && x <= u) && (x >= e && x <= i || x >= i && x <= e)) {
                var w = (h * v - l * m) / y;
                if ((w >= c && w <= p || w >= p && w <= c) && (w >= n && w <= r || w >= r && w <= n)) return !0;
              }

              u = f, c = p;
            }

            return !1;
          }, e.prototype.getPolygon = function (t) {
            if (null == t) throw new Error("boundingBox cannot be null.");
            var e = this.boundingBoxes.indexOf(t);
            return -1 == e ? null : this.polygons[e];
          }, e.prototype.getWidth = function () {
            return this.maxX - this.minX;
          }, e.prototype.getHeight = function () {
            return this.maxY - this.minY;
          }, e;
        }();

        t.SkeletonBounds = e;
      }(K || (K = {})), function (t) {
        var e = function () {
          function e() {
            this.triangulator = new t.Triangulator(), this.clippingPolygon = new Array(), this.clipOutput = new Array(), this.clippedVertices = new Array(), this.clippedTriangles = new Array(), this.scratch = new Array();
          }

          return e.prototype.clipStart = function (n, i) {
            if (null != this.clipAttachment) return 0;
            this.clipAttachment = i;
            var r = i.worldVerticesLength,
                a = t.Utils.setArraySize(this.clippingPolygon, r);
            i.computeWorldVertices(n, 0, r, a, 0, 2);
            var s = this.clippingPolygon;
            e.makeClockwise(s);

            for (var o = this.clippingPolygons = this.triangulator.decompose(s, this.triangulator.triangulate(s)), l = 0, h = o.length; l < h; l++) {
              var u = o[l];
              e.makeClockwise(u), u.push(u[0]), u.push(u[1]);
            }

            return o.length;
          }, e.prototype.clipEndWithSlot = function (t) {
            null != this.clipAttachment && this.clipAttachment.endSlot == t.data && this.clipEnd();
          }, e.prototype.clipEnd = function () {
            null != this.clipAttachment && (this.clipAttachment = null, this.clippingPolygons = null, this.clippedVertices.length = 0, this.clippedTriangles.length = 0, this.clippingPolygon.length = 0);
          }, e.prototype.isClipping = function () {
            return null != this.clipAttachment;
          }, e.prototype.clipTriangles = function (e, n, i, r, a, s, o, l, h, u, c) {
            void 0 === h && (h = 2), void 0 === u && (u = 0), void 0 === c && (c = 0);
            var d = this.clipOutput,
                f = this.clippedVertices,
                p = this.clippedTriangles,
                m = this.clippingPolygons,
                g = this.clippingPolygons.length,
                v = l ? 12 : 8,
                y = 0;
            f.length = 0, p.length = 0;

            t: for (var x = 0; x < r; x += 3) {
              for (var w = i[x] * h, _ = e[w + u], E = e[w + u + 1], b = a[w + c], T = a[w + c + 1], M = e[(w = i[x + 1] * h) + u], A = e[w + u + 1], C = a[w + c], S = a[w + c + 1], k = e[(w = i[x + 2] * h) + u], I = e[w + u + 1], R = a[w + c], P = a[w + c + 1], V = 0; V < g; V++) {
                var D = f.length;

                if (!this.clip(_, E, M, A, k, I, m[V], d)) {
                  (W = t.Utils.setArraySize(f, D + 3 * v))[D] = _, W[D + 1] = E, W[D + 2] = s.r, W[D + 3] = s.g, W[D + 4] = s.b, W[D + 5] = s.a, l ? (W[D + 6] = b, W[D + 7] = T, W[D + 8] = o.r, W[D + 9] = o.g, W[D + 10] = o.b, W[D + 11] = o.a, W[D + 12] = M, W[D + 13] = A, W[D + 14] = s.r, W[D + 15] = s.g, W[D + 16] = s.b, W[D + 17] = s.a, W[D + 18] = C, W[D + 19] = S, W[D + 20] = o.r, W[D + 21] = o.g, W[D + 22] = o.b, W[D + 23] = o.a, W[D + 24] = k, W[D + 25] = I, W[D + 26] = s.r, W[D + 27] = s.g, W[D + 28] = s.b, W[D + 29] = s.a, W[D + 30] = R, W[D + 31] = P, W[D + 32] = o.r, W[D + 33] = o.g, W[D + 34] = o.b, W[D + 35] = o.a) : (W[D + 6] = b, W[D + 7] = T, W[D + 8] = M, W[D + 9] = A, W[D + 10] = s.r, W[D + 11] = s.g, W[D + 12] = s.b, W[D + 13] = s.a, W[D + 14] = C, W[D + 15] = S, W[D + 16] = k, W[D + 17] = I, W[D + 18] = s.r, W[D + 19] = s.g, W[D + 20] = s.b, W[D + 21] = s.a, W[D + 22] = R, W[D + 23] = P), D = p.length, (K = t.Utils.setArraySize(p, D + 3))[D] = y, K[D + 1] = y + 1, K[D + 2] = y + 2, y += 3;
                  continue t;
                }

                var N = d.length;

                if (0 != N) {
                  for (var F = A - I, O = k - M, L = _ - k, U = I - E, B = 1 / (F * L + O * (E - I)), Y = N >> 1, X = this.clipOutput, W = t.Utils.setArraySize(f, D + Y * v), q = 0; q < N; q += 2) {
                    var H = X[q],
                        j = X[q + 1];
                    W[D] = H, W[D + 1] = j, W[D + 2] = s.r, W[D + 3] = s.g, W[D + 4] = s.b, W[D + 5] = s.a;
                    var z = H - k,
                        G = j - I,
                        Z = (F * z + O * G) * B,
                        J = (U * z + L * G) * B,
                        Q = 1 - Z - J;
                    W[D + 6] = b * Z + C * J + R * Q, W[D + 7] = T * Z + S * J + P * Q, l && (W[D + 8] = o.r, W[D + 9] = o.g, W[D + 10] = o.b, W[D + 11] = o.a), D += v;
                  }

                  D = p.length;
                  var K = t.Utils.setArraySize(p, D + 3 * (Y - 2));

                  for (Y--, q = 1; q < Y; q++) {
                    K[D] = y, K[D + 1] = y + q, K[D + 2] = y + q + 1, D += 3;
                  }

                  y += Y + 1;
                }
              }
            }
          }, e.prototype.clip = function (t, e, n, i, r, a, s, o) {
            var l = o,
                h = !1,
                u = null;
            s.length % 4 >= 2 ? (u = o, o = this.scratch) : u = this.scratch, u.length = 0, u.push(t), u.push(e), u.push(n), u.push(i), u.push(r), u.push(a), u.push(t), u.push(e), o.length = 0;

            for (var c = s, d = s.length - 4, f = 0;; f += 2) {
              for (var p = c[f], m = c[f + 1], g = c[f + 2], v = c[f + 3], y = p - g, x = m - v, w = u, _ = u.length - 2, E = o.length, b = 0; b < _; b += 2) {
                var T = w[b],
                    M = w[b + 1],
                    A = w[b + 2],
                    C = w[b + 3],
                    S = y * (C - v) - x * (A - g) > 0;

                if (y * (M - v) - x * (T - g) > 0) {
                  if (S) {
                    o.push(A), o.push(C);
                    continue;
                  }

                  var k = (R = C - M) * (g - p) - (P = A - T) * (v - m);

                  if (Math.abs(k) > 1e-6) {
                    var I = (P * (m - M) - R * (p - T)) / k;
                    o.push(p + (g - p) * I), o.push(m + (v - m) * I);
                  } else o.push(p), o.push(m);
                } else if (S) {
                  var R, P;
                  k = (R = C - M) * (g - p) - (P = A - T) * (v - m), Math.abs(k) > 1e-6 ? (I = (P * (m - M) - R * (p - T)) / k, o.push(p + (g - p) * I), o.push(m + (v - m) * I)) : (o.push(p), o.push(m)), o.push(A), o.push(C);
                }

                h = !0;
              }

              if (E == o.length) return l.length = 0, !0;
              if (o.push(o[0]), o.push(o[1]), f == d) break;
              var V = o;
              (o = u).length = 0, u = V;
            }

            if (l != o) {
              l.length = 0, f = 0;

              for (var D = o.length - 2; f < D; f++) {
                l[f] = o[f];
              }
            } else l.length = l.length - 2;

            return h;
          }, e.makeClockwise = function (t) {
            for (var e = t, n = t.length, i = e[n - 2] * e[1] - e[0] * e[n - 1], r = 0, a = 0, s = 0, o = 0, l = n - 3; o < l; o += 2) {
              r = e[o], a = e[o + 1], s = e[o + 2], i += r * e[o + 3] - s * a;
            }

            if (!(i < 0)) {
              o = 0;
              var h = n - 2;

              for (l = n >> 1; o < l; o += 2) {
                var u = e[o],
                    c = e[o + 1],
                    d = h - o;
                e[o] = e[d], e[o + 1] = e[d + 1], e[d] = u, e[d + 1] = c;
              }
            }
          }, e;
        }();

        t.SkeletonClipping = e;
      }(K || (K = {})), function (t) {
        var e = function () {
          function t() {
            this.bones = new Array(), this.slots = new Array(), this.skins = new Array(), this.events = new Array(), this.animations = new Array(), this.ikConstraints = new Array(), this.transformConstraints = new Array(), this.pathConstraints = new Array(), this.fps = 0;
          }

          return t.prototype.findBone = function (t) {
            if (null == t) throw new Error("boneName cannot be null.");

            for (var e = this.bones, n = 0, i = e.length; n < i; n++) {
              var r = e[n];
              if (r.name == t) return r;
            }

            return null;
          }, t.prototype.findBoneIndex = function (t) {
            if (null == t) throw new Error("boneName cannot be null.");

            for (var e = this.bones, n = 0, i = e.length; n < i; n++) {
              if (e[n].name == t) return n;
            }

            return -1;
          }, t.prototype.findSlot = function (t) {
            if (null == t) throw new Error("slotName cannot be null.");

            for (var e = this.slots, n = 0, i = e.length; n < i; n++) {
              var r = e[n];
              if (r.name == t) return r;
            }

            return null;
          }, t.prototype.findSlotIndex = function (t) {
            if (null == t) throw new Error("slotName cannot be null.");

            for (var e = this.slots, n = 0, i = e.length; n < i; n++) {
              if (e[n].name == t) return n;
            }

            return -1;
          }, t.prototype.findSkin = function (t) {
            if (null == t) throw new Error("skinName cannot be null.");

            for (var e = this.skins, n = 0, i = e.length; n < i; n++) {
              var r = e[n];
              if (r.name == t) return r;
            }

            return null;
          }, t.prototype.findEvent = function (t) {
            if (null == t) throw new Error("eventDataName cannot be null.");

            for (var e = this.events, n = 0, i = e.length; n < i; n++) {
              var r = e[n];
              if (r.name == t) return r;
            }

            return null;
          }, t.prototype.findAnimation = function (t) {
            if (null == t) throw new Error("animationName cannot be null.");

            for (var e = this.animations, n = 0, i = e.length; n < i; n++) {
              var r = e[n];
              if (r.name == t) return r;
            }

            return null;
          }, t.prototype.findIkConstraint = function (t) {
            if (null == t) throw new Error("constraintName cannot be null.");

            for (var e = this.ikConstraints, n = 0, i = e.length; n < i; n++) {
              var r = e[n];
              if (r.name == t) return r;
            }

            return null;
          }, t.prototype.findTransformConstraint = function (t) {
            if (null == t) throw new Error("constraintName cannot be null.");

            for (var e = this.transformConstraints, n = 0, i = e.length; n < i; n++) {
              var r = e[n];
              if (r.name == t) return r;
            }

            return null;
          }, t.prototype.findPathConstraint = function (t) {
            if (null == t) throw new Error("constraintName cannot be null.");

            for (var e = this.pathConstraints, n = 0, i = e.length; n < i; n++) {
              var r = e[n];
              if (r.name == t) return r;
            }

            return null;
          }, t.prototype.findPathConstraintIndex = function (t) {
            if (null == t) throw new Error("pathConstraintName cannot be null.");

            for (var e = this.pathConstraints, n = 0, i = e.length; n < i; n++) {
              if (e[n].name == t) return n;
            }

            return -1;
          }, t;
        }();

        t.SkeletonData = e;
      }(K || (K = {})), function (t) {
        var e = function () {
          function e(t) {
            this.scale = 1, this.linkedMeshes = new Array(), this.attachmentLoader = t;
          }

          return e.prototype.readSkeletonData = function (n) {
            var i = this.scale,
                r = new t.SkeletonData(),
                a = "string" == typeof n ? JSON.parse(n) : n,
                s = a.skeleton;
            if (null != s && (r.hash = s.hash, r.version = s.spine, r.x = s.x, r.y = s.y, r.width = s.width, r.height = s.height, r.fps = s.fps, r.imagesPath = s.images), a.bones) for (var o = 0; o < a.bones.length; o++) {
              var l = a.bones[o],
                  h = null,
                  u = this.getValue(l, "parent", null);
              if (null != u && null == (h = r.findBone(u))) throw new Error("Parent bone not found: " + u);
              (p = new t.BoneData(r.bones.length, l.name, h)).length = this.getValue(l, "length", 0) * i, p.x = this.getValue(l, "x", 0) * i, p.y = this.getValue(l, "y", 0) * i, p.rotation = this.getValue(l, "rotation", 0), p.scaleX = this.getValue(l, "scaleX", 1), p.scaleY = this.getValue(l, "scaleY", 1), p.shearX = this.getValue(l, "shearX", 0), p.shearY = this.getValue(l, "shearY", 0), p.transformMode = e.transformModeFromString(this.getValue(l, "transform", "normal")), p.skinRequired = this.getValue(l, "skin", !1), r.bones.push(p);
            }
            if (a.slots) for (o = 0; o < a.slots.length; o++) {
              var c = (k = a.slots[o]).name,
                  d = k.bone,
                  f = r.findBone(d);
              if (null == f) throw new Error("Slot bone not found: " + d);
              var p = new t.SlotData(r.slots.length, c, f),
                  m = this.getValue(k, "color", null);
              null != m && p.color.setFromString(m);
              var g = this.getValue(k, "dark", null);
              null != g && (p.darkColor = new t.Color(1, 1, 1, 1), p.darkColor.setFromString(g)), p.attachmentName = this.getValue(k, "attachment", null), p.blendMode = e.blendModeFromString(this.getValue(k, "blend", "normal")), r.slots.push(p);
            }
            if (a.ik) for (o = 0; o < a.ik.length; o++) {
              var v = a.ik[o];
              (p = new t.IkConstraintData(v.name)).order = this.getValue(v, "order", 0), p.skinRequired = this.getValue(v, "skin", !1);

              for (var y = 0; y < v.bones.length; y++) {
                if (d = v.bones[y], null == (A = r.findBone(d))) throw new Error("IK bone not found: " + d);
                p.bones.push(A);
              }

              var x = v.target;
              if (p.target = r.findBone(x), null == p.target) throw new Error("IK target bone not found: " + x);
              p.mix = this.getValue(v, "mix", 1), p.softness = this.getValue(v, "softness", 0) * i, p.bendDirection = this.getValue(v, "bendPositive", !0) ? 1 : -1, p.compress = this.getValue(v, "compress", !1), p.stretch = this.getValue(v, "stretch", !1), p.uniform = this.getValue(v, "uniform", !1), r.ikConstraints.push(p);
            }
            if (a.transform) for (o = 0; o < a.transform.length; o++) {
              for (v = a.transform[o], (p = new t.TransformConstraintData(v.name)).order = this.getValue(v, "order", 0), p.skinRequired = this.getValue(v, "skin", !1), y = 0; y < v.bones.length; y++) {
                if (d = v.bones[y], null == (A = r.findBone(d))) throw new Error("Transform constraint bone not found: " + d);
                p.bones.push(A);
              }

              if (x = v.target, p.target = r.findBone(x), null == p.target) throw new Error("Transform constraint target bone not found: " + x);
              p.local = this.getValue(v, "local", !1), p.relative = this.getValue(v, "relative", !1), p.offsetRotation = this.getValue(v, "rotation", 0), p.offsetX = this.getValue(v, "x", 0) * i, p.offsetY = this.getValue(v, "y", 0) * i, p.offsetScaleX = this.getValue(v, "scaleX", 0), p.offsetScaleY = this.getValue(v, "scaleY", 0), p.offsetShearY = this.getValue(v, "shearY", 0), p.rotateMix = this.getValue(v, "rotateMix", 1), p.translateMix = this.getValue(v, "translateMix", 1), p.scaleMix = this.getValue(v, "scaleMix", 1), p.shearMix = this.getValue(v, "shearMix", 1), r.transformConstraints.push(p);
            }
            if (a.path) for (o = 0; o < a.path.length; o++) {
              for (v = a.path[o], (p = new t.PathConstraintData(v.name)).order = this.getValue(v, "order", 0), p.skinRequired = this.getValue(v, "skin", !1), y = 0; y < v.bones.length; y++) {
                if (d = v.bones[y], null == (A = r.findBone(d))) throw new Error("Transform constraint bone not found: " + d);
                p.bones.push(A);
              }

              if (x = v.target, p.target = r.findSlot(x), null == p.target) throw new Error("Path target slot not found: " + x);
              p.positionMode = e.positionModeFromString(this.getValue(v, "positionMode", "percent")), p.spacingMode = e.spacingModeFromString(this.getValue(v, "spacingMode", "length")), p.rotateMode = e.rotateModeFromString(this.getValue(v, "rotateMode", "tangent")), p.offsetRotation = this.getValue(v, "rotation", 0), p.position = this.getValue(v, "position", 0), p.positionMode == t.PositionMode.Fixed && (p.position *= i), p.spacing = this.getValue(v, "spacing", 0), p.spacingMode != t.SpacingMode.Length && p.spacingMode != t.SpacingMode.Fixed || (p.spacing *= i), p.rotateMix = this.getValue(v, "rotateMix", 1), p.translateMix = this.getValue(v, "translateMix", 1), r.pathConstraints.push(p);
            }

            if (a.skins) {
              var w = a.skins;

              if (!(w instanceof Array)) {
                var _ = [];

                for (var E in w) {
                  _.push({
                    name: E,
                    attachments: w[E]
                  });
                }

                w = _;
              }

              for (o = 0; o < w.length; o++) {
                var b = w[o],
                    T = new t.Skin(b.name);
                if (b.bones) for (var M = 0; M < b.bones.length; M++) {
                  var A;
                  if (null == (A = r.findBone(b.bones[M]))) throw new Error("Skin bone not found: " + b.bones[o]);
                  T.bones.push(A);
                }
                if (b.ik) for (M = 0; M < b.ik.length; M++) {
                  if (null == (C = r.findIkConstraint(b.ik[M]))) throw new Error("Skin IK constraint not found: " + b.ik[o]);
                  T.constraints.push(C);
                }
                if (b.transform) for (M = 0; M < b.transform.length; M++) {
                  if (null == (C = r.findTransformConstraint(b.transform[M]))) throw new Error("Skin transform constraint not found: " + b.transform[o]);
                  T.constraints.push(C);
                }
                if (b.path) for (M = 0; M < b.path.length; M++) {
                  var C;
                  if (null == (C = r.findPathConstraint(b.path[M]))) throw new Error("Skin path constraint not found: " + b.path[o]);
                  T.constraints.push(C);
                }

                for (var c in b.attachments) {
                  var S = r.findSlot(c);
                  if (null == S) throw new Error("Slot not found: " + c);
                  var k = b.attachments[c];

                  for (var I in k) {
                    var R = this.readAttachment(k[I], T, S.index, I, r);
                    null != R && T.setAttachment(S.index, I, R);
                  }
                }

                r.skins.push(T), "default" == T.name && (r.defaultSkin = T);
              }
            }

            o = 0;

            for (var P = this.linkedMeshes.length; o < P; o++) {
              var V = this.linkedMeshes[o];
              if (null == (T = null == V.skin ? r.defaultSkin : r.findSkin(V.skin))) throw new Error("Skin not found: " + V.skin);
              var D = T.getAttachment(V.slotIndex, V.parent);
              if (null == D) throw new Error("Parent mesh not found: " + V.parent);
              V.mesh.deformAttachment = V.inheritDeform ? D : V.mesh, V.mesh.setParentMesh(D), V.mesh.updateUVs();
            }

            if (this.linkedMeshes.length = 0, a.events) for (var N in a.events) {
              var F = a.events[N];
              (p = new t.EventData(N)).intValue = this.getValue(F, "int", 0), p.floatValue = this.getValue(F, "float", 0), p.stringValue = this.getValue(F, "string", ""), p.audioPath = this.getValue(F, "audio", null), null != p.audioPath && (p.volume = this.getValue(F, "volume", 1), p.balance = this.getValue(F, "balance", 0)), r.events.push(p);
            }
            if (a.animations) for (var O in a.animations) {
              var L = a.animations[O];
              this.readAnimation(L, O, r);
            }
            return r;
          }, e.prototype.readAttachment = function (e, i, r, a, s) {
            var o = this.scale;

            switch (a = this.getValue(e, "name", a), this.getValue(e, "type", "region")) {
              case "region":
                var l = this.getValue(e, "path", a),
                    h = this.attachmentLoader.newRegionAttachment(i, a, l);
                return null == h ? null : (h.path = l, h.x = this.getValue(e, "x", 0) * o, h.y = this.getValue(e, "y", 0) * o, h.scaleX = this.getValue(e, "scaleX", 1), h.scaleY = this.getValue(e, "scaleY", 1), h.rotation = this.getValue(e, "rotation", 0), h.width = e.width * o, h.height = e.height * o, null != (x = this.getValue(e, "color", null)) && h.color.setFromString(x), h.updateOffset(), h);

              case "boundingbox":
                var u = this.attachmentLoader.newBoundingBoxAttachment(i, a);
                return null == u ? null : (this.readVertices(e, u, e.vertexCount << 1), null != (x = this.getValue(e, "color", null)) && u.color.setFromString(x), u);

              case "mesh":
              case "linkedmesh":
                l = this.getValue(e, "path", a);
                var c = this.attachmentLoader.newMeshAttachment(i, a, l);
                if (null == c) return null;
                c.path = l, null != (x = this.getValue(e, "color", null)) && c.color.setFromString(x), c.width = this.getValue(e, "width", 0) * o, c.height = this.getValue(e, "height", 0) * o;
                var d = this.getValue(e, "parent", null);
                if (null != d) return this.linkedMeshes.push(new n(c, this.getValue(e, "skin", null), r, d, this.getValue(e, "deform", !0))), c;
                var f = e.uvs;
                return this.readVertices(e, c, f.length), c.triangles = e.triangles, c.regionUVs = f, c.updateUVs(), c.edges = this.getValue(e, "edges", null), c.hullLength = 2 * this.getValue(e, "hull", 0), c;

              case "path":
                if (null == (l = this.attachmentLoader.newPathAttachment(i, a))) return null;
                l.closed = this.getValue(e, "closed", !1), l.constantSpeed = this.getValue(e, "constantSpeed", !0);
                var p = e.vertexCount;
                this.readVertices(e, l, p << 1);

                for (var m = t.Utils.newArray(p / 3, 0), g = 0; g < e.lengths.length; g++) {
                  m[g] = e.lengths[g] * o;
                }

                return l.lengths = m, null != (x = this.getValue(e, "color", null)) && l.color.setFromString(x), l;

              case "point":
                var v = this.attachmentLoader.newPointAttachment(i, a);
                return null == v ? null : (v.x = this.getValue(e, "x", 0) * o, v.y = this.getValue(e, "y", 0) * o, v.rotation = this.getValue(e, "rotation", 0), null != (x = this.getValue(e, "color", null)) && v.color.setFromString(x), v);

              case "clipping":
                var y = this.attachmentLoader.newClippingAttachment(i, a);
                if (null == y) return null;
                var x,
                    w = this.getValue(e, "end", null);

                if (null != w) {
                  var _ = s.findSlot(w);

                  if (null == _) throw new Error("Clipping end slot not found: " + w);
                  y.endSlot = _;
                }

                return p = e.vertexCount, this.readVertices(e, y, p << 1), null != (x = this.getValue(e, "color", null)) && y.color.setFromString(x), y;
            }

            return null;
          }, e.prototype.readVertices = function (e, n, i) {
            var r = this.scale;
            n.worldVerticesLength = i;
            var a = e.vertices;

            if (i != a.length) {
              var s = new Array(),
                  o = new Array();

              for (c = 0, d = a.length; c < d;) {
                var l = a[c++];
                o.push(l);

                for (var h = c + 4 * l; c < h; c += 4) {
                  o.push(a[c]), s.push(a[c + 1] * r), s.push(a[c + 2] * r), s.push(a[c + 3]);
                }
              }

              n.bones = o, n.vertices = t.Utils.toFloatArray(s);
            } else {
              var u = t.Utils.toFloatArray(a);
              if (1 != r) for (var c = 0, d = a.length; c < d; c++) {
                u[c] *= r;
              }
              n.vertices = u;
            }
          }, e.prototype.readAnimation = function (e, n, i) {
            var r = this.scale,
                a = new Array(),
                s = 0;
            if (e.slots) for (var o in e.slots) {
              var l = e.slots[o];
              if (-1 == (Q = i.findSlotIndex(o))) throw new Error("Slot not found: " + o);

              for (var h in l) {
                var u = l[h];

                if ("attachment" == h) {
                  (w = new t.AttachmentTimeline(u.length)).slotIndex = Q;

                  for (var c = 0, d = 0; d < u.length; d++) {
                    var f = u[d];
                    w.setFrame(c++, this.getValue(f, "time", 0), f.name);
                  }

                  a.push(w), s = Math.max(s, w.frames[w.getFrameCount() - 1]);
                } else if ("color" == h) {
                  for ((w = new t.ColorTimeline(u.length)).slotIndex = Q, c = 0, d = 0; d < u.length; d++) {
                    f = u[d];
                    var p = new t.Color();
                    p.setFromString(f.color), w.setFrame(c, this.getValue(f, "time", 0), p.r, p.g, p.b, p.a), this.readCurve(f, w, c), c++;
                  }

                  a.push(w), s = Math.max(s, w.frames[(w.getFrameCount() - 1) * t.ColorTimeline.ENTRIES]);
                } else {
                  if ("twoColor" != h) throw new Error("Invalid timeline type for a slot: " + h + " (" + o + ")");

                  for ((w = new t.TwoColorTimeline(u.length)).slotIndex = Q, c = 0, d = 0; d < u.length; d++) {
                    f = u[d];
                    var m = new t.Color(),
                        g = new t.Color();
                    m.setFromString(f.light), g.setFromString(f.dark), w.setFrame(c, this.getValue(f, "time", 0), m.r, m.g, m.b, m.a, g.r, g.g, g.b), this.readCurve(f, w, c), c++;
                  }

                  a.push(w), s = Math.max(s, w.frames[(w.getFrameCount() - 1) * t.TwoColorTimeline.ENTRIES]);
                }
              }
            }
            if (e.bones) for (var v in e.bones) {
              var y = e.bones[v],
                  x = i.findBoneIndex(v);
              if (-1 == x) throw new Error("Bone not found: " + v);

              for (var h in y) {
                if (u = y[h], "rotate" === h) {
                  for ((w = new t.RotateTimeline(u.length)).boneIndex = x, c = 0, d = 0; d < u.length; d++) {
                    f = u[d], w.setFrame(c, this.getValue(f, "time", 0), this.getValue(f, "angle", 0)), this.readCurve(f, w, c), c++;
                  }

                  a.push(w), s = Math.max(s, w.frames[(w.getFrameCount() - 1) * t.RotateTimeline.ENTRIES]);
                } else {
                  if ("translate" !== h && "scale" !== h && "shear" !== h) throw new Error("Invalid timeline type for a bone: " + h + " (" + v + ")");
                  var w = null,
                      _ = 1,
                      E = 0;

                  for ("scale" === h ? (w = new t.ScaleTimeline(u.length), E = 1) : "shear" === h ? w = new t.ShearTimeline(u.length) : (w = new t.TranslateTimeline(u.length), _ = r), w.boneIndex = x, c = 0, d = 0; d < u.length; d++) {
                    f = u[d];
                    var b = this.getValue(f, "x", E),
                        T = this.getValue(f, "y", E);
                    w.setFrame(c, this.getValue(f, "time", 0), b * _, T * _), this.readCurve(f, w, c), c++;
                  }

                  a.push(w), s = Math.max(s, w.frames[(w.getFrameCount() - 1) * t.TranslateTimeline.ENTRIES]);
                }
              }
            }
            if (e.ik) for (var M in e.ik) {
              var A = e.ik[M],
                  C = i.findIkConstraint(M);

              for ((w = new t.IkConstraintTimeline(A.length)).ikConstraintIndex = i.ikConstraints.indexOf(C), c = 0, d = 0; d < A.length; d++) {
                f = A[d], w.setFrame(c, this.getValue(f, "time", 0), this.getValue(f, "mix", 1), this.getValue(f, "softness", 0) * r, this.getValue(f, "bendPositive", !0) ? 1 : -1, this.getValue(f, "compress", !1), this.getValue(f, "stretch", !1)), this.readCurve(f, w, c), c++;
              }

              a.push(w), s = Math.max(s, w.frames[(w.getFrameCount() - 1) * t.IkConstraintTimeline.ENTRIES]);
            }
            if (e.transform) for (var M in e.transform) {
              for (A = e.transform[M], C = i.findTransformConstraint(M), (w = new t.TransformConstraintTimeline(A.length)).transformConstraintIndex = i.transformConstraints.indexOf(C), c = 0, d = 0; d < A.length; d++) {
                f = A[d], w.setFrame(c, this.getValue(f, "time", 0), this.getValue(f, "rotateMix", 1), this.getValue(f, "translateMix", 1), this.getValue(f, "scaleMix", 1), this.getValue(f, "shearMix", 1)), this.readCurve(f, w, c), c++;
              }

              a.push(w), s = Math.max(s, w.frames[(w.getFrameCount() - 1) * t.TransformConstraintTimeline.ENTRIES]);
            }
            var S = e.path || e.paths;
            if (S) for (var M in S) {
              A = S[M];
              var k = i.findPathConstraintIndex(M);
              if (-1 == k) throw new Error("Path constraint not found: " + M);
              var I = i.pathConstraints[k];

              for (var h in A) {
                if (u = A[h], "position" === h || "spacing" === h) {
                  for (w = null, _ = 1, "spacing" === h ? (w = new t.PathConstraintSpacingTimeline(u.length), I.spacingMode != t.SpacingMode.Length && I.spacingMode != t.SpacingMode.Fixed || (_ = r)) : (w = new t.PathConstraintPositionTimeline(u.length), I.positionMode == t.PositionMode.Fixed && (_ = r)), w.pathConstraintIndex = k, c = 0, d = 0; d < u.length; d++) {
                    f = u[d], w.setFrame(c, this.getValue(f, "time", 0), this.getValue(f, h, 0) * _), this.readCurve(f, w, c), c++;
                  }

                  a.push(w), s = Math.max(s, w.frames[(w.getFrameCount() - 1) * t.PathConstraintPositionTimeline.ENTRIES]);
                } else if ("mix" === h) {
                  for ((w = new t.PathConstraintMixTimeline(u.length)).pathConstraintIndex = k, c = 0, d = 0; d < u.length; d++) {
                    f = u[d], w.setFrame(c, this.getValue(f, "time", 0), this.getValue(f, "rotateMix", 1), this.getValue(f, "translateMix", 1)), this.readCurve(f, w, c), c++;
                  }

                  a.push(w), s = Math.max(s, w.frames[(w.getFrameCount() - 1) * t.PathConstraintMixTimeline.ENTRIES]);
                }
              }
            }
            if (e.deform) for (var R in e.deform) {
              var P = e.deform[R],
                  V = i.findSkin(R);
              if (null == V) throw new Error("Skin not found: " + R);

              for (var o in P) {
                if (l = P[o], -1 == (Q = i.findSlotIndex(o))) throw new Error("Slot not found: " + l.name);

                for (var h in l) {
                  u = l[h];
                  var D = V.getAttachment(Q, h);

                  if (null != D) {
                    var N = null != D.bones,
                        F = D.vertices,
                        O = N ? F.length / 3 * 2 : F.length;
                    (w = new t.DeformTimeline(u.length)).slotIndex = Q, w.attachment = D, c = 0;

                    for (var L = 0; L < u.length; L++) {
                      f = u[L];
                      var U = void 0,
                          B = this.getValue(f, "vertices", null);
                      if (null == B) U = N ? t.Utils.newFloatArray(O) : F;else {
                        U = t.Utils.newFloatArray(O);
                        var Y = this.getValue(f, "offset", 0);
                        if (t.Utils.arrayCopy(B, 0, U, Y, B.length), 1 != r) for (var X = (d = Y) + B.length; d < X; d++) {
                          U[d] *= r;
                        }
                        if (!N) for (d = 0; d < O; d++) {
                          U[d] += F[d];
                        }
                      }
                      w.setFrame(c, this.getValue(f, "time", 0), U), this.readCurve(f, w, c), c++;
                    }

                    a.push(w), s = Math.max(s, w.frames[w.getFrameCount() - 1]);
                  }
                }
              }
            }
            var W = e.drawOrder;

            if (null == W && (W = e.draworder), null != W) {
              w = new t.DrawOrderTimeline(W.length);
              var q = i.slots.length;

              for (c = 0, L = 0; L < W.length; L++) {
                var H = W[L],
                    j = null,
                    z = this.getValue(H, "offsets", null);

                if (null != z) {
                  j = t.Utils.newArray(q, -1);
                  var G = t.Utils.newArray(q - z.length, 0),
                      Z = 0,
                      J = 0;

                  for (d = 0; d < z.length; d++) {
                    var Q,
                        K = z[d];
                    if (-1 == (Q = i.findSlotIndex(K.slot))) throw new Error("Slot not found: " + K.slot);

                    for (; Z != Q;) {
                      G[J++] = Z++;
                    }

                    j[Z + K.offset] = Z++;
                  }

                  for (; Z < q;) {
                    G[J++] = Z++;
                  }

                  for (d = q - 1; d >= 0; d--) {
                    -1 == j[d] && (j[d] = G[--J]);
                  }
                }

                w.setFrame(c++, this.getValue(H, "time", 0), j);
              }

              a.push(w), s = Math.max(s, w.frames[w.getFrameCount() - 1]);
            }

            if (e.events) {
              for (w = new t.EventTimeline(e.events.length), c = 0, d = 0; d < e.events.length; d++) {
                var $ = e.events[d],
                    tt = i.findEvent($.name);
                if (null == tt) throw new Error("Event not found: " + $.name);
                var et = new t.Event(t.Utils.toSinglePrecision(this.getValue($, "time", 0)), tt);
                et.intValue = this.getValue($, "int", tt.intValue), et.floatValue = this.getValue($, "float", tt.floatValue), et.stringValue = this.getValue($, "string", tt.stringValue), null != et.data.audioPath && (et.volume = this.getValue($, "volume", 1), et.balance = this.getValue($, "balance", 0)), w.setFrame(c++, et);
              }

              a.push(w), s = Math.max(s, w.frames[w.getFrameCount() - 1]);
            }

            if (isNaN(s)) throw new Error("Error while parsing animation, duration is NaN");
            i.animations.push(new t.Animation(n, a, s));
          }, e.prototype.readCurve = function (t, e, n) {
            var i = t.curve;
            i && ("stepped" == i ? e.setStepped(n) : "[object Array]" === Object.prototype.toString.call(i) ? e.setCurve(n, i[0], i[1], i[2], i[3]) : e.setCurve(n, i, this.getValue(t, "c2", 0), this.getValue(t, "c3", 1), this.getValue(t, "c4", 1)));
          }, e.prototype.getValue = function (t, e, n) {
            return void 0 !== t[e] ? t[e] : n;
          }, e.blendModeFromString = function (e) {
            if ("normal" == (e = e.toLowerCase())) return t.BlendMode.Normal;
            if ("additive" == e) return t.BlendMode.Additive;
            if ("multiply" == e) return t.BlendMode.Multiply;
            if ("screen" == e) return t.BlendMode.Screen;
            throw new Error("Unknown blend mode: " + e);
          }, e.positionModeFromString = function (e) {
            if ("fixed" == (e = e.toLowerCase())) return t.PositionMode.Fixed;
            if ("percent" == e) return t.PositionMode.Percent;
            throw new Error("Unknown position mode: " + e);
          }, e.spacingModeFromString = function (e) {
            if ("length" == (e = e.toLowerCase())) return t.SpacingMode.Length;
            if ("fixed" == e) return t.SpacingMode.Fixed;
            if ("percent" == e) return t.SpacingMode.Percent;
            throw new Error("Unknown position mode: " + e);
          }, e.rotateModeFromString = function (e) {
            if ("tangent" == (e = e.toLowerCase())) return t.RotateMode.Tangent;
            if ("chain" == e) return t.RotateMode.Chain;
            if ("chainscale" == e) return t.RotateMode.ChainScale;
            throw new Error("Unknown rotate mode: " + e);
          }, e.transformModeFromString = function (e) {
            if ("normal" == (e = e.toLowerCase())) return t.TransformMode.Normal;
            if ("onlytranslation" == e) return t.TransformMode.OnlyTranslation;
            if ("norotationorreflection" == e) return t.TransformMode.NoRotationOrReflection;
            if ("noscale" == e) return t.TransformMode.NoScale;
            if ("noscaleorreflection" == e) return t.TransformMode.NoScaleOrReflection;
            throw new Error("Unknown transform mode: " + e);
          }, e;
        }();

        t.SkeletonJson = e;

        var n = function n(t, e, _n2, i, r) {
          this.mesh = t, this.skin = e, this.slotIndex = _n2, this.parent = i, this.inheritDeform = r;
        };
      }(K || (K = {})), function (t) {
        var e = function e(t, _e2, n) {
          this.slotIndex = t, this.name = _e2, this.attachment = n;
        };

        t.SkinEntry = e;

        var n = function () {
          function n(t) {
            if (this.attachments = new Array(), this.bones = Array(), this.constraints = new Array(), null == t) throw new Error("name cannot be null.");
            this.name = t;
          }

          return n.prototype.setAttachment = function (t, e, n) {
            if (null == n) throw new Error("attachment cannot be null.");
            var i = this.attachments;
            t >= i.length && (i.length = t + 1), i[t] || (i[t] = {}), i[t][e] = n;
          }, n.prototype.addSkin = function (t) {
            for (var e = 0; e < t.bones.length; e++) {
              for (var n = t.bones[e], i = !1, r = 0; r < this.bones.length; r++) {
                if (this.bones[r] == n) {
                  i = !0;
                  break;
                }
              }

              i || this.bones.push(n);
            }

            for (e = 0; e < t.constraints.length; e++) {
              var a = t.constraints[e];

              for (i = !1, r = 0; r < this.constraints.length; r++) {
                if (this.constraints[r] == a) {
                  i = !0;
                  break;
                }
              }

              i || this.constraints.push(a);
            }

            var s = t.getAttachments();

            for (e = 0; e < s.length; e++) {
              var o = s[e];
              this.setAttachment(o.slotIndex, o.name, o.attachment);
            }
          }, n.prototype.copySkin = function (e) {
            for (var n = 0; n < e.bones.length; n++) {
              for (var i = e.bones[n], r = !1, a = 0; a < this.bones.length; a++) {
                if (this.bones[a] == i) {
                  r = !0;
                  break;
                }
              }

              r || this.bones.push(i);
            }

            for (n = 0; n < e.constraints.length; n++) {
              var s = e.constraints[n];

              for (r = !1, a = 0; a < this.constraints.length; a++) {
                if (this.constraints[a] == s) {
                  r = !0;
                  break;
                }
              }

              r || this.constraints.push(s);
            }

            var o = e.getAttachments();

            for (n = 0; n < o.length; n++) {
              var l = o[n];
              null != l.attachment && (l.attachment instanceof t.MeshAttachment ? (l.attachment = l.attachment.newLinkedMesh(), this.setAttachment(l.slotIndex, l.name, l.attachment)) : (l.attachment = l.attachment.copy(), this.setAttachment(l.slotIndex, l.name, l.attachment)));
            }
          }, n.prototype.getAttachment = function (t, e) {
            var n = this.attachments[t];
            return n ? n[e] : null;
          }, n.prototype.removeAttachment = function (t, e) {
            var n = this.attachments[t];
            n && (n[e] = null);
          }, n.prototype.getAttachments = function () {
            for (var t = new Array(), n = 0; n < this.attachments.length; n++) {
              var i = this.attachments[n];
              if (i) for (var r in i) {
                var a = i[r];
                a && t.push(new e(n, r, a));
              }
            }

            return t;
          }, n.prototype.getAttachmentsForSlot = function (t, n) {
            var i = this.attachments[t];
            if (i) for (var r in i) {
              var a = i[r];
              a && n.push(new e(t, r, a));
            }
          }, n.prototype.clear = function () {
            this.attachments.length = 0, this.bones.length = 0, this.constraints.length = 0;
          }, n.prototype.attachAll = function (t, e) {
            for (var n = 0, i = 0; i < t.slots.length; i++) {
              var r = t.slots[i],
                  a = r.getAttachment();

              if (a && n < e.attachments.length) {
                var s = e.attachments[n];

                for (var o in s) {
                  if (a == s[o]) {
                    var l = this.getAttachment(n, o);
                    null != l && r.setAttachment(l);
                    break;
                  }
                }
              }

              n++;
            }
          }, n;
        }();

        t.Skin = n;
      }(K || (K = {})), function (t) {
        var e = function () {
          function e(e, n) {
            if (this.deform = new Array(), null == e) throw new Error("data cannot be null.");
            if (null == n) throw new Error("bone cannot be null.");
            this.data = e, this.bone = n, this.color = new t.Color(), this.darkColor = null == e.darkColor ? null : new t.Color(), this.setToSetupPose();
          }

          return e.prototype.getSkeleton = function () {
            return this.bone.skeleton;
          }, e.prototype.getAttachment = function () {
            return this.attachment;
          }, e.prototype.setAttachment = function (t) {
            this.attachment != t && (this.attachment = t, this.attachmentTime = this.bone.skeleton.time, this.deform.length = 0);
          }, e.prototype.setAttachmentTime = function (t) {
            this.attachmentTime = this.bone.skeleton.time - t;
          }, e.prototype.getAttachmentTime = function () {
            return this.bone.skeleton.time - this.attachmentTime;
          }, e.prototype.setToSetupPose = function () {
            this.color.setFromColor(this.data.color), null != this.darkColor && this.darkColor.setFromColor(this.data.darkColor), null == this.data.attachmentName ? this.attachment = null : (this.attachment = null, this.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName)));
          }, e;
        }();

        t.Slot = e;
      }(K || (K = {})), function (t) {
        t.SlotData = function (e, n, i) {
          if (this.color = new t.Color(1, 1, 1, 1), e < 0) throw new Error("index must be >= 0.");
          if (null == n) throw new Error("name cannot be null.");
          if (null == i) throw new Error("boneData cannot be null.");
          this.index = e, this.name = n, this.boneData = i;
        };
      }(K || (K = {})), function (t) {
        var e,
            n,
            i = function () {
          function t(t) {
            this._image = t;
          }

          return t.prototype.getImage = function () {
            return this._image;
          }, t.filterFromString = function (t) {
            switch (t.toLowerCase()) {
              case "nearest":
                return e.Nearest;

              case "linear":
                return e.Linear;

              case "mipmap":
                return e.MipMap;

              case "mipmapnearestnearest":
                return e.MipMapNearestNearest;

              case "mipmaplinearnearest":
                return e.MipMapLinearNearest;

              case "mipmapnearestlinear":
                return e.MipMapNearestLinear;

              case "mipmaplinearlinear":
                return e.MipMapLinearLinear;

              default:
                throw new Error("Unknown texture filter " + t);
            }
          }, t.wrapFromString = function (t) {
            switch (t.toLowerCase()) {
              case "mirroredtepeat":
                return n.MirroredRepeat;

              case "clamptoedge":
                return n.ClampToEdge;

              case "repeat":
                return n.Repeat;

              default:
                throw new Error("Unknown texture wrap " + t);
            }
          }, t;
        }();

        t.Texture = i, function (t) {
          t[t.Nearest = 9728] = "Nearest", t[t.Linear = 9729] = "Linear", t[t.MipMap = 9987] = "MipMap", t[t.MipMapNearestNearest = 9984] = "MipMapNearestNearest", t[t.MipMapLinearNearest = 9985] = "MipMapLinearNearest", t[t.MipMapNearestLinear = 9986] = "MipMapNearestLinear", t[t.MipMapLinearLinear = 9987] = "MipMapLinearLinear";
        }(e = t.TextureFilter || (t.TextureFilter = {})), function (t) {
          t[t.MirroredRepeat = 33648] = "MirroredRepeat", t[t.ClampToEdge = 33071] = "ClampToEdge", t[t.Repeat = 10497] = "Repeat";
        }(n = t.TextureWrap || (t.TextureWrap = {}));

        t.TextureRegion = function () {
          this.u = 0, this.v = 0, this.u2 = 0, this.v2 = 0, this.width = 0, this.height = 0, this.rotate = !1, this.offsetX = 0, this.offsetY = 0, this.originalWidth = 0, this.originalHeight = 0;
        };

        var r = function (t) {
          function e() {
            return null !== t && t.apply(this, arguments) || this;
          }

          return $(e, t), e.prototype.setFilters = function () {}, e.prototype.setWraps = function () {}, e.prototype.dispose = function () {}, e;
        }(i);

        t.FakeTexture = r;
      }(K || (K = {})), function (t) {
        var e = function () {
          function e(t, e) {
            this.pages = new Array(), this.regions = new Array(), this.load(t, e);
          }

          return e.prototype.load = function (e, a) {
            if (null == a) throw new Error("textureLoader cannot be null.");

            for (var s = new n(e), o = new Array(4), l = null;;) {
              var h = s.readLine();
              if (null == h) break;
              if (0 == (h = h.trim()).length) l = null;else if (l) {
                var u = new r();
                u.name = h, u.page = l;
                var c = s.readValue();
                "true" == c.toLocaleLowerCase() ? u.degrees = 90 : "false" == c.toLocaleLowerCase() ? u.degrees = 0 : u.degrees = parseFloat(c), u.rotate = 90 == u.degrees, s.readTuple(o);
                var d = parseInt(o[0]),
                    f = parseInt(o[1]);
                s.readTuple(o);
                var p = parseInt(o[0]),
                    m = parseInt(o[1]);
                u.u = d / l.width, u.v = f / l.height, u.rotate ? (u.u2 = (d + m) / l.width, u.v2 = (f + p) / l.height) : (u.u2 = (d + p) / l.width, u.v2 = (f + m) / l.height), u.x = d, u.y = f, u.width = Math.abs(p), u.height = Math.abs(m), 4 == s.readTuple(o) && 4 == s.readTuple(o) && s.readTuple(o), u.originalWidth = parseInt(o[0]), u.originalHeight = parseInt(o[1]), s.readTuple(o), u.offsetX = parseInt(o[0]), u.offsetY = parseInt(o[1]), u.index = parseInt(s.readValue()), u.texture = l.texture, this.regions.push(u);
              } else {
                (l = new i()).name = h, 2 == s.readTuple(o) && (l.width = parseInt(o[0]), l.height = parseInt(o[1]), s.readTuple(o)), s.readTuple(o), l.minFilter = t.Texture.filterFromString(o[0]), l.magFilter = t.Texture.filterFromString(o[1]);
                var g = s.readValue();
                l.uWrap = t.TextureWrap.ClampToEdge, l.vWrap = t.TextureWrap.ClampToEdge, "x" == g ? l.uWrap = t.TextureWrap.Repeat : "y" == g ? l.vWrap = t.TextureWrap.Repeat : "xy" == g && (l.uWrap = l.vWrap = t.TextureWrap.Repeat), l.texture = a(h), l.texture.setFilters(l.minFilter, l.magFilter), l.texture.setWraps(l.uWrap, l.vWrap), l.width = l.texture.getImage().width, l.height = l.texture.getImage().height, this.pages.push(l);
              }
            }
          }, e.prototype.findRegion = function (t) {
            for (var e = 0; e < this.regions.length; e++) {
              if (this.regions[e].name == t) return this.regions[e];
            }

            return null;
          }, e.prototype.dispose = function () {
            for (var t = 0; t < this.pages.length; t++) {
              this.pages[t].texture.dispose();
            }
          }, e;
        }();

        t.TextureAtlas = e;

        var n = function () {
          function t(t) {
            this.index = 0, this.lines = t.split(/\r\n|\r|\n/);
          }

          return t.prototype.readLine = function () {
            return this.index >= this.lines.length ? null : this.lines[this.index++];
          }, t.prototype.readValue = function () {
            var t = this.readLine(),
                e = t.indexOf(":");
            if (-1 == e) throw new Error("Invalid line: " + t);
            return t.substring(e + 1).trim();
          }, t.prototype.readTuple = function (t) {
            var e = this.readLine(),
                n = e.indexOf(":");
            if (-1 == n) throw new Error("Invalid line: " + e);

            for (var i = 0, r = n + 1; i < 3; i++) {
              var a = e.indexOf(",", r);
              if (-1 == a) break;
              t[i] = e.substr(r, a - r).trim(), r = a + 1;
            }

            return t[i] = e.substring(r).trim(), i + 1;
          }, t;
        }(),
            i = function i() {};

        t.TextureAtlasPage = i;

        var r = function (t) {
          function e() {
            return null !== t && t.apply(this, arguments) || this;
          }

          return $(e, t), e;
        }(t.TextureRegion);

        t.TextureAtlasRegion = r;
      }(K || (K = {})), function (t) {
        var e = function () {
          function e(e, n) {
            if (this.rotateMix = 0, this.translateMix = 0, this.scaleMix = 0, this.shearMix = 0, this.temp = new t.Vector2(), this.active = !1, null == e) throw new Error("data cannot be null.");
            if (null == n) throw new Error("skeleton cannot be null.");
            this.data = e, this.rotateMix = e.rotateMix, this.translateMix = e.translateMix, this.scaleMix = e.scaleMix, this.shearMix = e.shearMix, this.bones = new Array();

            for (var i = 0; i < e.bones.length; i++) {
              this.bones.push(n.findBone(e.bones[i].name));
            }

            this.target = n.findBone(e.target.name);
          }

          return e.prototype.isActive = function () {
            return this.active;
          }, e.prototype.apply = function () {
            this.update();
          }, e.prototype.update = function () {
            this.data.local ? this.data.relative ? this.applyRelativeLocal() : this.applyAbsoluteLocal() : this.data.relative ? this.applyRelativeWorld() : this.applyAbsoluteWorld();
          }, e.prototype.applyAbsoluteWorld = function () {
            for (var e = this.rotateMix, n = this.translateMix, i = this.scaleMix, r = this.shearMix, a = this.target, s = a.a, o = a.b, l = a.c, h = a.d, u = s * h - o * l > 0 ? t.MathUtils.degRad : -t.MathUtils.degRad, c = this.data.offsetRotation * u, d = this.data.offsetShearY * u, f = this.bones, p = 0, m = f.length; p < m; p++) {
              var g = f[p],
                  v = !1;

              if (0 != e) {
                var y = g.a,
                    x = g.b,
                    w = g.c,
                    _ = g.d;
                (C = Math.atan2(l, s) - Math.atan2(w, y) + c) > t.MathUtils.PI ? C -= t.MathUtils.PI2 : C < -t.MathUtils.PI && (C += t.MathUtils.PI2), C *= e;
                var E = Math.cos(C),
                    b = Math.sin(C);
                g.a = E * y - b * w, g.b = E * x - b * _, g.c = b * y + E * w, g.d = b * x + E * _, v = !0;
              }

              if (0 != n) {
                var T = this.temp;
                a.localToWorld(T.set(this.data.offsetX, this.data.offsetY)), g.worldX += (T.x - g.worldX) * n, g.worldY += (T.y - g.worldY) * n, v = !0;
              }

              if (i > 0) {
                var M = Math.sqrt(g.a * g.a + g.c * g.c),
                    A = Math.sqrt(s * s + l * l);
                M > 1e-5 && (M = (M + (A - M + this.data.offsetScaleX) * i) / M), g.a *= M, g.c *= M, M = Math.sqrt(g.b * g.b + g.d * g.d), A = Math.sqrt(o * o + h * h), M > 1e-5 && (M = (M + (A - M + this.data.offsetScaleY) * i) / M), g.b *= M, g.d *= M, v = !0;
              }

              if (r > 0) {
                x = g.b, _ = g.d;
                var C,
                    S = Math.atan2(_, x);
                (C = Math.atan2(h, o) - Math.atan2(l, s) - (S - Math.atan2(g.c, g.a))) > t.MathUtils.PI ? C -= t.MathUtils.PI2 : C < -t.MathUtils.PI && (C += t.MathUtils.PI2), C = S + (C + d) * r, M = Math.sqrt(x * x + _ * _), g.b = Math.cos(C) * M, g.d = Math.sin(C) * M, v = !0;
              }

              v && (g.appliedValid = !1);
            }
          }, e.prototype.applyRelativeWorld = function () {
            for (var e = this.rotateMix, n = this.translateMix, i = this.scaleMix, r = this.shearMix, a = this.target, s = a.a, o = a.b, l = a.c, h = a.d, u = s * h - o * l > 0 ? t.MathUtils.degRad : -t.MathUtils.degRad, c = this.data.offsetRotation * u, d = this.data.offsetShearY * u, f = this.bones, p = 0, m = f.length; p < m; p++) {
              var g,
                  v = f[p],
                  y = !1;

              if (0 != e) {
                var x = v.a,
                    w = v.b,
                    _ = v.c,
                    E = v.d;
                (g = Math.atan2(l, s) + c) > t.MathUtils.PI ? g -= t.MathUtils.PI2 : g < -t.MathUtils.PI && (g += t.MathUtils.PI2), g *= e;
                var b = Math.cos(g),
                    T = Math.sin(g);
                v.a = b * x - T * _, v.b = b * w - T * E, v.c = T * x + b * _, v.d = T * w + b * E, y = !0;
              }

              if (0 != n) {
                var M = this.temp;
                a.localToWorld(M.set(this.data.offsetX, this.data.offsetY)), v.worldX += M.x * n, v.worldY += M.y * n, y = !0;
              }

              if (i > 0) {
                var A = (Math.sqrt(s * s + l * l) - 1 + this.data.offsetScaleX) * i + 1;
                v.a *= A, v.c *= A, A = (Math.sqrt(o * o + h * h) - 1 + this.data.offsetScaleY) * i + 1, v.b *= A, v.d *= A, y = !0;
              }

              if (r > 0) (g = Math.atan2(h, o) - Math.atan2(l, s)) > t.MathUtils.PI ? g -= t.MathUtils.PI2 : g < -t.MathUtils.PI && (g += t.MathUtils.PI2), w = v.b, E = v.d, g = Math.atan2(E, w) + (g - t.MathUtils.PI / 2 + d) * r, A = Math.sqrt(w * w + E * E), v.b = Math.cos(g) * A, v.d = Math.sin(g) * A, y = !0;
              y && (v.appliedValid = !1);
            }
          }, e.prototype.applyAbsoluteLocal = function () {
            var t = this.rotateMix,
                e = this.translateMix,
                n = this.scaleMix,
                i = this.shearMix,
                r = this.target;
            r.appliedValid || r.updateAppliedTransform();

            for (var a = this.bones, s = 0, o = a.length; s < o; s++) {
              var l = a[s];
              l.appliedValid || l.updateAppliedTransform();
              var h = l.arotation;

              if (0 != t) {
                var u = r.arotation - h + this.data.offsetRotation;
                h += (u -= 360 * (16384 - (16384.499999999996 - u / 360 | 0))) * t;
              }

              var c = l.ax,
                  d = l.ay;
              0 != e && (c += (r.ax - c + this.data.offsetX) * e, d += (r.ay - d + this.data.offsetY) * e);
              var f = l.ascaleX,
                  p = l.ascaleY;
              0 != n && (f > 1e-5 && (f = (f + (r.ascaleX - f + this.data.offsetScaleX) * n) / f), p > 1e-5 && (p = (p + (r.ascaleY - p + this.data.offsetScaleY) * n) / p));
              var m = l.ashearY;
              0 != i && (u = r.ashearY - m + this.data.offsetShearY, u -= 360 * (16384 - (16384.499999999996 - u / 360 | 0)), l.shearY += u * i), l.updateWorldTransformWith(c, d, h, f, p, l.ashearX, m);
            }
          }, e.prototype.applyRelativeLocal = function () {
            var t = this.rotateMix,
                e = this.translateMix,
                n = this.scaleMix,
                i = this.shearMix,
                r = this.target;
            r.appliedValid || r.updateAppliedTransform();

            for (var a = this.bones, s = 0, o = a.length; s < o; s++) {
              var l = a[s];
              l.appliedValid || l.updateAppliedTransform();
              var h = l.arotation;
              0 != t && (h += (r.arotation + this.data.offsetRotation) * t);
              var u = l.ax,
                  c = l.ay;
              0 != e && (u += (r.ax + this.data.offsetX) * e, c += (r.ay + this.data.offsetY) * e);
              var d = l.ascaleX,
                  f = l.ascaleY;
              0 != n && (d > 1e-5 && (d *= (r.ascaleX - 1 + this.data.offsetScaleX) * n + 1), f > 1e-5 && (f *= (r.ascaleY - 1 + this.data.offsetScaleY) * n + 1));
              var p = l.ashearY;
              0 != i && (p += (r.ashearY + this.data.offsetShearY) * i), l.updateWorldTransformWith(u, c, h, d, f, l.ashearX, p);
            }
          }, e;
        }();

        t.TransformConstraint = e;
      }(K || (K = {})), function (t) {
        var e = function (t) {
          function e(e) {
            var n = t.call(this, e, 0, !1) || this;
            return n.bones = new Array(), n.rotateMix = 0, n.translateMix = 0, n.scaleMix = 0, n.shearMix = 0, n.offsetRotation = 0, n.offsetX = 0, n.offsetY = 0, n.offsetScaleX = 0, n.offsetScaleY = 0, n.offsetShearY = 0, n.relative = !1, n.local = !1, n;
          }

          return $(e, t), e;
        }(t.ConstraintData);

        t.TransformConstraintData = e;
      }(K || (K = {})), function (t) {
        var e = function () {
          function e() {
            this.convexPolygons = new Array(), this.convexPolygonsIndices = new Array(), this.indicesArray = new Array(), this.isConcaveArray = new Array(), this.triangles = new Array(), this.polygonPool = new t.Pool(function () {
              return new Array();
            }), this.polygonIndicesPool = new t.Pool(function () {
              return new Array();
            });
          }

          return e.prototype.triangulate = function (t) {
            var n = t,
                i = t.length >> 1,
                r = this.indicesArray;
            r.length = 0;

            for (var a = 0; a < i; a++) {
              r[a] = a;
            }

            var s = this.isConcaveArray;
            s.length = 0, a = 0;

            for (var o = i; a < o; ++a) {
              s[a] = e.isConcave(a, i, n, r);
            }

            var l = this.triangles;

            for (l.length = 0; i > 3;) {
              for (var h = i - 1, u = (a = 0, 1);;) {
                t: if (!s[a]) {
                  for (var c = r[h] << 1, d = r[a] << 1, f = r[u] << 1, p = n[c], m = n[c + 1], g = n[d], v = n[d + 1], y = n[f], x = n[f + 1], w = (u + 1) % i; w != h; w = (w + 1) % i) {
                    if (s[w]) {
                      var _ = r[w] << 1,
                          E = n[_],
                          b = n[_ + 1];

                      if (e.positiveArea(y, x, p, m, E, b) && e.positiveArea(p, m, g, v, E, b) && e.positiveArea(g, v, y, x, E, b)) break t;
                    }
                  }

                  break;
                }

                if (0 == u) {
                  do {
                    if (!s[a]) break;
                    a--;
                  } while (a > 0);

                  break;
                }

                h = a, a = u, u = (u + 1) % i;
              }

              l.push(r[(i + a - 1) % i]), l.push(r[a]), l.push(r[(a + 1) % i]), r.splice(a, 1), s.splice(a, 1);
              var T = (--i + a - 1) % i,
                  M = a == i ? 0 : a;
              s[T] = e.isConcave(T, i, n, r), s[M] = e.isConcave(M, i, n, r);
            }

            return 3 == i && (l.push(r[2]), l.push(r[0]), l.push(r[1])), l;
          }, e.prototype.decompose = function (t, n) {
            var i = t,
                r = this.convexPolygons;
            this.polygonPool.freeAll(r), r.length = 0;
            var a = this.convexPolygonsIndices;
            this.polygonIndicesPool.freeAll(a), a.length = 0;
            var s = this.polygonIndicesPool.obtain();
            s.length = 0;
            var o = this.polygonPool.obtain();
            o.length = 0;

            for (var l = -1, h = 0, u = 0, c = n.length; u < c; u += 3) {
              var d = n[u] << 1,
                  f = n[u + 1] << 1,
                  p = n[u + 2] << 1,
                  m = i[d],
                  g = i[d + 1],
                  v = i[f],
                  y = i[f + 1],
                  x = i[p],
                  w = i[p + 1],
                  _ = !1;

              if (l == d) {
                var E = o.length - 4,
                    b = e.winding(o[E], o[E + 1], o[E + 2], o[E + 3], x, w),
                    T = e.winding(x, w, o[0], o[1], o[2], o[3]);
                b == h && T == h && (o.push(x), o.push(w), s.push(p), _ = !0);
              }

              _ || (o.length > 0 ? (r.push(o), a.push(s)) : (this.polygonPool.free(o), this.polygonIndicesPool.free(s)), (o = this.polygonPool.obtain()).length = 0, o.push(m), o.push(g), o.push(v), o.push(y), o.push(x), o.push(w), (s = this.polygonIndicesPool.obtain()).length = 0, s.push(d), s.push(f), s.push(p), h = e.winding(m, g, v, y, x, w), l = d);
            }

            for (o.length > 0 && (r.push(o), a.push(s)), u = 0, c = r.length; u < c; u++) {
              if (0 != (s = a[u]).length) for (var M = s[0], A = s[s.length - 1], C = (o = r[u])[E = o.length - 4], S = o[E + 1], k = o[E + 2], I = o[E + 3], R = o[0], P = o[1], V = o[2], D = o[3], N = e.winding(C, S, k, I, R, P), F = 0; F < c; F++) {
                if (F != u) {
                  var O = a[F];

                  if (3 == O.length) {
                    var L = O[0],
                        U = O[1],
                        B = O[2],
                        Y = r[F];
                    x = Y[Y.length - 2], w = Y[Y.length - 1], L == M && U == A && (b = e.winding(C, S, k, I, x, w), T = e.winding(x, w, R, P, V, D), b == N && T == N && (Y.length = 0, O.length = 0, o.push(x), o.push(w), s.push(B), C = k, S = I, k = x, I = w, F = 0));
                  }
                }
              }
            }

            for (u = r.length - 1; u >= 0; u--) {
              0 == (o = r[u]).length && (r.splice(u, 1), this.polygonPool.free(o), s = a[u], a.splice(u, 1), this.polygonIndicesPool.free(s));
            }

            return r;
          }, e.isConcave = function (t, e, n, i) {
            var r = i[(e + t - 1) % e] << 1,
                a = i[t] << 1,
                s = i[(t + 1) % e] << 1;
            return !this.positiveArea(n[r], n[r + 1], n[a], n[a + 1], n[s], n[s + 1]);
          }, e.positiveArea = function (t, e, n, i, r, a) {
            return t * (a - i) + n * (e - a) + r * (i - e) >= 0;
          }, e.winding = function (t, e, n, i, r, a) {
            var s = n - t,
                o = i - e;
            return r * o - a * s + s * e - t * o >= 0 ? 1 : -1;
          }, e;
        }();

        t.Triangulator = e;
      }(K || (K = {})), function (t) {
        var e = function () {
          function t() {
            this.array = new Array();
          }

          return t.prototype.add = function (t) {
            var e = this.contains(t);
            return this.array[0 | t] = 0 | t, !e;
          }, t.prototype.contains = function (t) {
            return null != this.array[0 | t];
          }, t.prototype.remove = function (t) {
            this.array[0 | t] = void 0;
          }, t.prototype.clear = function () {
            this.array.length = 0;
          }, t;
        }();

        t.IntSet = e;

        var n = function () {
          function t(t, e, n, i) {
            void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === n && (n = 0), void 0 === i && (i = 0), this.r = t, this.g = e, this.b = n, this.a = i;
          }

          return t.prototype.set = function (t, e, n, i) {
            return this.r = t, this.g = e, this.b = n, this.a = i, this.clamp(), this;
          }, t.prototype.setFromColor = function (t) {
            return this.r = t.r, this.g = t.g, this.b = t.b, this.a = t.a, this;
          }, t.prototype.setFromString = function (t) {
            return t = "#" == t.charAt(0) ? t.substr(1) : t, this.r = parseInt(t.substr(0, 2), 16) / 255, this.g = parseInt(t.substr(2, 2), 16) / 255, this.b = parseInt(t.substr(4, 2), 16) / 255, this.a = (8 != t.length ? 255 : parseInt(t.substr(6, 2), 16)) / 255, this;
          }, t.prototype.add = function (t, e, n, i) {
            return this.r += t, this.g += e, this.b += n, this.a += i, this.clamp(), this;
          }, t.prototype.clamp = function () {
            return this.r < 0 ? this.r = 0 : this.r > 1 && (this.r = 1), this.g < 0 ? this.g = 0 : this.g > 1 && (this.g = 1), this.b < 0 ? this.b = 0 : this.b > 1 && (this.b = 1), this.a < 0 ? this.a = 0 : this.a > 1 && (this.a = 1), this;
          }, t.rgba8888ToColor = function (t, e) {
            t.r = ((4278190080 & e) >>> 24) / 255, t.g = ((16711680 & e) >>> 16) / 255, t.b = ((65280 & e) >>> 8) / 255, t.a = (255 & e) / 255;
          }, t.rgb888ToColor = function (t, e) {
            t.r = ((16711680 & e) >>> 16) / 255, t.g = ((65280 & e) >>> 8) / 255, t.b = (255 & e) / 255;
          }, t.WHITE = new t(1, 1, 1, 1), t.RED = new t(1, 0, 0, 1), t.GREEN = new t(0, 1, 0, 1), t.BLUE = new t(0, 0, 1, 1), t.MAGENTA = new t(1, 0, 1, 1), t;
        }();

        t.Color = n;

        var i = function () {
          function t() {}

          return t.clamp = function (t, e, n) {
            return t < e ? e : t > n ? n : t;
          }, t.cosDeg = function (e) {
            return Math.cos(e * t.degRad);
          }, t.sinDeg = function (e) {
            return Math.sin(e * t.degRad);
          }, t.signum = function (t) {
            return t > 0 ? 1 : t < 0 ? -1 : 0;
          }, t.toInt = function (t) {
            return t > 0 ? Math.floor(t) : Math.ceil(t);
          }, t.cbrt = function (t) {
            var e = Math.pow(Math.abs(t), 1 / 3);
            return t < 0 ? -e : e;
          }, t.randomTriangular = function (e, n) {
            return t.randomTriangularWith(e, n, .5 * (e + n));
          }, t.randomTriangularWith = function (t, e, n) {
            var i = Math.random(),
                r = e - t;
            return i <= (n - t) / r ? t + Math.sqrt(i * r * (n - t)) : e - Math.sqrt((1 - i) * r * (e - n));
          }, t.PI = 3.1415927, t.PI2 = 2 * t.PI, t.radiansToDegrees = 180 / t.PI, t.radDeg = t.radiansToDegrees, t.degreesToRadians = t.PI / 180, t.degRad = t.degreesToRadians, t;
        }();

        t.MathUtils = i;

        var r = function () {
          function t() {}

          return t.prototype.apply = function (t, e, n) {
            return t + (e - t) * this.applyInternal(n);
          }, t;
        }();

        t.Interpolation = r;

        var a = function (t) {
          function e(e) {
            var n = t.call(this) || this;
            return n.power = 2, n.power = e, n;
          }

          return $(e, t), e.prototype.applyInternal = function (t) {
            return t <= .5 ? Math.pow(2 * t, this.power) / 2 : Math.pow(2 * (t - 1), this.power) / (this.power % 2 == 0 ? -2 : 2) + 1;
          }, e;
        }(r);

        t.Pow = a;

        var s = function (t) {
          function e(e) {
            return t.call(this, e) || this;
          }

          return $(e, t), e.prototype.applyInternal = function (t) {
            return Math.pow(t - 1, this.power) * (this.power % 2 == 0 ? -1 : 1) + 1;
          }, e;
        }(a);

        t.PowOut = s;

        var o = function () {
          function t() {}

          return t.arrayCopy = function (t, e, n, i, r) {
            for (var a = e, s = i; a < e + r; a++, s++) {
              n[s] = t[a];
            }
          }, t.setArraySize = function (t, e, n) {
            void 0 === n && (n = 0);
            var i = t.length;
            if (i == e) return t;
            if (t.length = e, i < e) for (var r = i; r < e; r++) {
              t[r] = n;
            }
            return t;
          }, t.ensureArrayCapacity = function (e, n, i) {
            return void 0 === i && (i = 0), e.length >= n ? e : t.setArraySize(e, n, i);
          }, t.newArray = function (t, e) {
            for (var n = new Array(t), i = 0; i < t; i++) {
              n[i] = e;
            }

            return n;
          }, t.newFloatArray = function (e) {
            if (t.SUPPORTS_TYPED_ARRAYS) return new Float32Array(e);

            for (var n = new Array(e), i = 0; i < n.length; i++) {
              n[i] = 0;
            }

            return n;
          }, t.newShortArray = function (e) {
            if (t.SUPPORTS_TYPED_ARRAYS) return new Int16Array(e);

            for (var n = new Array(e), i = 0; i < n.length; i++) {
              n[i] = 0;
            }

            return n;
          }, t.toFloatArray = function (e) {
            return t.SUPPORTS_TYPED_ARRAYS ? new Float32Array(e) : e;
          }, t.toSinglePrecision = function (e) {
            return t.SUPPORTS_TYPED_ARRAYS ? Math.fround(e) : e;
          }, t.webkit602BugfixHelper = function () {}, t.contains = function (t, e) {
            for (var n = 0; n < t.length; n++) {
              if (t[n] == e) return !0;
            }

            return !1;
          }, t.SUPPORTS_TYPED_ARRAYS = "undefined" != typeof Float32Array, t;
        }();

        t.Utils = o;

        var l = function () {
          function t() {}

          return t.logBones = function (t) {
            for (var e = 0; e < t.bones.length; e++) {
              var n = t.bones[e];
              console.log(n.data.name + ", " + n.a + ", " + n.b + ", " + n.c + ", " + n.d + ", " + n.worldX + ", " + n.worldY);
            }
          }, t;
        }();

        t.DebugUtils = l;

        var h = function () {
          function t(t) {
            this.items = new Array(), this.instantiator = t;
          }

          return t.prototype.obtain = function () {
            return this.items.length > 0 ? this.items.pop() : this.instantiator();
          }, t.prototype.free = function (t) {
            t.reset && t.reset(), this.items.push(t);
          }, t.prototype.freeAll = function (t) {
            for (var e = 0; e < t.length; e++) {
              t[e].reset && t[e].reset(), this.items[e] = t[e];
            }
          }, t.prototype.clear = function () {
            this.items.length = 0;
          }, t;
        }();

        t.Pool = h;

        var u = function () {
          function t(t, e) {
            void 0 === t && (t = 0), void 0 === e && (e = 0), this.x = t, this.y = e;
          }

          return t.prototype.set = function (t, e) {
            return this.x = t, this.y = e, this;
          }, t.prototype.length = function () {
            var t = this.x,
                e = this.y;
            return Math.sqrt(t * t + e * e);
          }, t.prototype.normalize = function () {
            var t = this.length();
            return 0 != t && (this.x /= t, this.y /= t), this;
          }, t;
        }();

        t.Vector2 = u;

        var c = function () {
          function t() {
            this.maxDelta = .064, this.framesPerSecond = 0, this.delta = 0, this.totalTime = 0, this.lastTime = Date.now() / 1e3, this.frameCount = 0, this.frameTime = 0;
          }

          return t.prototype.update = function () {
            var t = Date.now() / 1e3;
            this.delta = t - this.lastTime, this.frameTime += this.delta, this.totalTime += this.delta, this.delta > this.maxDelta && (this.delta = this.maxDelta), this.lastTime = t, this.frameCount++, this.frameTime > 1 && (this.framesPerSecond = this.frameCount / this.frameTime, this.frameTime = 0, this.frameCount = 0);
          }, t;
        }();

        t.TimeKeeper = c;

        var d = function () {
          function t(t) {
            void 0 === t && (t = 32), this.addedValues = 0, this.lastValue = 0, this.mean = 0, this.dirty = !0, this.values = new Array(t);
          }

          return t.prototype.hasEnoughData = function () {
            return this.addedValues >= this.values.length;
          }, t.prototype.addValue = function (t) {
            this.addedValues < this.values.length && this.addedValues++, this.values[this.lastValue++] = t, this.lastValue > this.values.length - 1 && (this.lastValue = 0), this.dirty = !0;
          }, t.prototype.getMean = function () {
            if (this.hasEnoughData()) {
              if (this.dirty) {
                for (var t = 0, e = 0; e < this.values.length; e++) {
                  t += this.values[e];
                }

                this.mean = t / this.values.length, this.dirty = !1;
              }

              return this.mean;
            }

            return 0;
          }, t;
        }();

        t.WindowedMean = d;
      }(K || (K = {})), Math.fround || (Math.fround = (Q = new Float32Array(1), function (t) {
        return Q[0] = t, Q[0];
      })), function (t) {
        var e = function e(t) {
          if (null == t) throw new Error("name cannot be null.");
          this.name = t;
        };

        t.Attachment = e;

        var n = function (e) {
          function n(t) {
            var i = e.call(this, t) || this;
            return i.id = (65535 & n.nextID++) << 11, i.worldVerticesLength = 0, i.deformAttachment = i, i;
          }

          return $(n, e), n.prototype.computeWorldVertices = function (t, e, n, i, r, a) {
            n = r + (n >> 1) * a;
            var s = t.bone.skeleton,
                o = t.deform,
                l = this.vertices,
                h = this.bones;

            if (null != h) {
              for (var u = 0, c = 0, d = 0; d < e; d += 2) {
                u += (g = h[u]) + 1, c += g;
              }

              var f = s.bones;
              if (0 == o.length) for (S = r, T = 3 * c; S < n; S += a) {
                var p = 0,
                    m = 0,
                    g = h[u++];

                for (g += u; u < g; u++, T += 3) {
                  w = f[h[u]], k = l[T], I = l[T + 1];
                  var v = l[T + 2];
                  p += (k * w.a + I * w.b + w.worldX) * v, m += (k * w.c + I * w.d + w.worldY) * v;
                }

                i[S] = p, i[S + 1] = m;
              } else for (var y = o, x = (S = r, T = 3 * c, c << 1); S < n; S += a) {
                for (p = 0, m = 0, g = h[u++], g += u; u < g; u++, T += 3, x += 2) {
                  w = f[h[u]], k = l[T] + y[x], I = l[T + 1] + y[x + 1], v = l[T + 2], p += (k * w.a + I * w.b + w.worldX) * v, m += (k * w.c + I * w.d + w.worldY) * v;
                }

                i[S] = p, i[S + 1] = m;
              }
            } else {
              o.length > 0 && (l = o);

              for (var w, _ = (w = t.bone).worldX, E = w.worldY, b = w.a, T = w.b, M = w.c, A = w.d, C = e, S = r; S < n; C += 2, S += a) {
                var k = l[C],
                    I = l[C + 1];
                i[S] = k * b + I * T + _, i[S + 1] = k * M + I * A + E;
              }
            }
          }, n.prototype.copyTo = function (e) {
            null != this.bones ? (e.bones = new Array(this.bones.length), t.Utils.arrayCopy(this.bones, 0, e.bones, 0, this.bones.length)) : e.bones = null, null != this.vertices ? (e.vertices = t.Utils.newFloatArray(this.vertices.length), t.Utils.arrayCopy(this.vertices, 0, e.vertices, 0, this.vertices.length)) : e.vertices = null, e.worldVerticesLength = this.worldVerticesLength, e.deformAttachment = this.deformAttachment;
          }, n.nextID = 0, n;
        }(e);

        t.VertexAttachment = n;
      }(K || (K = {})), function (t) {
        var e;
        (e = t.AttachmentType || (t.AttachmentType = {}))[e.Region = 0] = "Region", e[e.BoundingBox = 1] = "BoundingBox", e[e.Mesh = 2] = "Mesh", e[e.LinkedMesh = 3] = "LinkedMesh", e[e.Path = 4] = "Path", e[e.Point = 5] = "Point", e[e.Clipping = 6] = "Clipping";
      }(K || (K = {})), function (t) {
        var e = function (e) {
          function n(n) {
            var i = e.call(this, n) || this;
            return i.color = new t.Color(1, 1, 1, 1), i;
          }

          return $(n, e), n.prototype.copy = function () {
            var t = new n(name);
            return this.copyTo(t), t.color.setFromColor(this.color), t;
          }, n;
        }(t.VertexAttachment);

        t.BoundingBoxAttachment = e;
      }(K || (K = {})), function (t) {
        var e = function (e) {
          function n(n) {
            var i = e.call(this, n) || this;
            return i.color = new t.Color(.2275, .2275, .8078, 1), i;
          }

          return $(n, e), n.prototype.copy = function () {
            var t = new n(name);
            return this.copyTo(t), t.endSlot = this.endSlot, t.color.setFromColor(this.color), t;
          }, n;
        }(t.VertexAttachment);

        t.ClippingAttachment = e;
      }(K || (K = {})), function (t) {
        var e = function (e) {
          function n(n) {
            var i = e.call(this, n) || this;
            return i.color = new t.Color(1, 1, 1, 1), i.tempColor = new t.Color(0, 0, 0, 0), i;
          }

          return $(n, e), n.prototype.updateUVs = function () {
            var e = this.regionUVs;
            null != this.uvs && this.uvs.length == e.length || (this.uvs = t.Utils.newFloatArray(e.length));
            var n = this.uvs,
                i = this.uvs.length,
                r = this.region.u,
                a = this.region.v,
                s = 0,
                o = 0;

            if (this.region instanceof t.TextureAtlasRegion) {
              var l = this.region,
                  h = l.texture.getImage().width,
                  u = l.texture.getImage().height;

              switch (l.degrees) {
                case 90:
                  r -= (l.originalHeight - l.offsetY - l.height) / h, a -= (l.originalWidth - l.offsetX - l.width) / u, s = l.originalHeight / h, o = l.originalWidth / u;

                  for (var c = 0; c < i; c += 2) {
                    n[c] = r + e[c + 1] * s, n[c + 1] = a + (1 - e[c]) * o;
                  }

                  return;

                case 180:
                  for (r -= (l.originalWidth - l.offsetX - l.width) / h, a -= l.offsetY / u, s = l.originalWidth / h, o = l.originalHeight / u, c = 0; c < i; c += 2) {
                    n[c] = r + (1 - e[c]) * s, n[c + 1] = a + (1 - e[c + 1]) * o;
                  }

                  return;

                case 270:
                  for (r -= l.offsetY / h, a -= l.offsetX / u, s = l.originalHeight / h, o = l.originalWidth / u, c = 0; c < i; c += 2) {
                    n[c] = r + (1 - e[c + 1]) * s, n[c + 1] = a + e[c] * o;
                  }

                  return;
              }

              r -= l.offsetX / h, a -= (l.originalHeight - l.offsetY - l.height) / u, s = l.originalWidth / h, o = l.originalHeight / u;
            } else null == this.region ? (r = a = 0, s = o = 1) : (s = this.region.u2 - r, o = this.region.v2 - a);

            for (c = 0; c < i; c += 2) {
              n[c] = r + e[c] * s, n[c + 1] = a + e[c + 1] * o;
            }
          }, n.prototype.getParentMesh = function () {
            return this.parentMesh;
          }, n.prototype.setParentMesh = function (t) {
            this.parentMesh = t, null != t && (this.bones = t.bones, this.vertices = t.vertices, this.worldVerticesLength = t.worldVerticesLength, this.regionUVs = t.regionUVs, this.triangles = t.triangles, this.hullLength = t.hullLength, this.worldVerticesLength = t.worldVerticesLength);
          }, n.prototype.copy = function () {
            if (null != this.parentMesh) return this.newLinkedMesh();
            var e = new n(this.name);
            return e.region = this.region, e.path = this.path, e.color.setFromColor(this.color), this.copyTo(e), e.regionUVs = new Array(this.regionUVs.length), t.Utils.arrayCopy(this.regionUVs, 0, e.regionUVs, 0, this.regionUVs.length), e.uvs = new Array(this.uvs.length), t.Utils.arrayCopy(this.uvs, 0, e.uvs, 0, this.uvs.length), e.triangles = new Array(this.triangles.length), t.Utils.arrayCopy(this.triangles, 0, e.triangles, 0, this.triangles.length), e.hullLength = this.hullLength, null != this.edges && (e.edges = new Array(this.edges.length), t.Utils.arrayCopy(this.edges, 0, e.edges, 0, this.edges.length)), e.width = this.width, e.height = this.height, e;
          }, n.prototype.newLinkedMesh = function () {
            var t = new n(this.name);
            return t.region = this.region, t.path = this.path, t.color.setFromColor(this.color), t.deformAttachment = this.deformAttachment, t.setParentMesh(null != this.parentMesh ? this.parentMesh : this), t.updateUVs(), t;
          }, n;
        }(t.VertexAttachment);

        t.MeshAttachment = e;
      }(K || (K = {})), function (t) {
        var e = function (e) {
          function n(n) {
            var i = e.call(this, n) || this;
            return i.closed = !1, i.constantSpeed = !1, i.color = new t.Color(1, 1, 1, 1), i;
          }

          return $(n, e), n.prototype.copy = function () {
            var e = new n(name);
            return this.copyTo(e), e.lengths = new Array(this.lengths.length), t.Utils.arrayCopy(this.lengths, 0, e.lengths, 0, this.lengths.length), e.closed = closed, e.constantSpeed = this.constantSpeed, e.color.setFromColor(this.color), e;
          }, n;
        }(t.VertexAttachment);

        t.PathAttachment = e;
      }(K || (K = {})), function (t) {
        var e = function (e) {
          function n(n) {
            var i = e.call(this, n) || this;
            return i.color = new t.Color(.38, .94, 0, 1), i;
          }

          return $(n, e), n.prototype.computeWorldPosition = function (t, e) {
            return e.x = this.x * t.a + this.y * t.b + t.worldX, e.y = this.x * t.c + this.y * t.d + t.worldY, e;
          }, n.prototype.computeWorldRotation = function (e) {
            var n = t.MathUtils.cosDeg(this.rotation),
                i = t.MathUtils.sinDeg(this.rotation),
                r = n * e.a + i * e.b,
                a = n * e.c + i * e.d;
            return Math.atan2(a, r) * t.MathUtils.radDeg;
          }, n.prototype.copy = function () {
            var t = new n(name);
            return t.x = this.x, t.y = this.y, t.rotation = this.rotation, t.color.setFromColor(this.color), t;
          }, n;
        }(t.VertexAttachment);

        t.PointAttachment = e;
      }(K || (K = {})), function (t) {
        var e = function (e) {
          function n(n) {
            var i = e.call(this, n) || this;
            return i.x = 0, i.y = 0, i.scaleX = 1, i.scaleY = 1, i.rotation = 0, i.width = 0, i.height = 0, i.color = new t.Color(1, 1, 1, 1), i.offset = t.Utils.newFloatArray(8), i.uvs = t.Utils.newFloatArray(8), i.tempColor = new t.Color(1, 1, 1, 1), i;
          }

          return $(n, e), n.prototype.updateOffset = function () {
            var t = this.width / this.region.originalWidth * this.scaleX,
                e = this.height / this.region.originalHeight * this.scaleY,
                i = -this.width / 2 * this.scaleX + this.region.offsetX * t,
                r = -this.height / 2 * this.scaleY + this.region.offsetY * e,
                a = i + this.region.width * t,
                s = r + this.region.height * e,
                o = this.rotation * Math.PI / 180,
                l = Math.cos(o),
                h = Math.sin(o),
                u = i * l + this.x,
                c = i * h,
                d = r * l + this.y,
                f = r * h,
                p = a * l + this.x,
                m = a * h,
                g = s * l + this.y,
                v = s * h,
                y = this.offset;
            y[n.OX1] = u - f, y[n.OY1] = d + c, y[n.OX2] = u - v, y[n.OY2] = g + c, y[n.OX3] = p - v, y[n.OY3] = g + m, y[n.OX4] = p - f, y[n.OY4] = d + m;
          }, n.prototype.setRegion = function (t) {
            this.region = t;
            var e = this.uvs;
            t.rotate ? (e[2] = t.u, e[3] = t.v2, e[4] = t.u, e[5] = t.v, e[6] = t.u2, e[7] = t.v, e[0] = t.u2, e[1] = t.v2) : (e[0] = t.u, e[1] = t.v2, e[2] = t.u, e[3] = t.v, e[4] = t.u2, e[5] = t.v, e[6] = t.u2, e[7] = t.v2);
          }, n.prototype.computeWorldVertices = function (t, e, i, r) {
            var a = this.offset,
                s = t.worldX,
                o = t.worldY,
                l = t.a,
                h = t.b,
                u = t.c,
                c = t.d,
                d = 0,
                f = 0;
            d = a[n.OX1], f = a[n.OY1], e[i] = d * l + f * h + s, e[i + 1] = d * u + f * c + o, i += r, d = a[n.OX2], f = a[n.OY2], e[i] = d * l + f * h + s, e[i + 1] = d * u + f * c + o, i += r, d = a[n.OX3], f = a[n.OY3], e[i] = d * l + f * h + s, e[i + 1] = d * u + f * c + o, i += r, d = a[n.OX4], f = a[n.OY4], e[i] = d * l + f * h + s, e[i + 1] = d * u + f * c + o;
          }, n.prototype.copy = function () {
            var e = new n(name);
            return e.region = this.region, e.rendererObject = this.rendererObject, e.path = this.path, e.x = this.x, e.y = this.y, e.scaleX = this.scaleX, e.scaleY = this.scaleY, e.rotation = this.rotation, e.width = this.width, e.height = this.height, t.Utils.arrayCopy(this.uvs, 0, e.uvs, 0, 8), t.Utils.arrayCopy(this.offset, 0, e.offset, 0, 8), e.color.setFromColor(this.color), e;
          }, n.OX1 = 0, n.OY1 = 1, n.OX2 = 2, n.OY2 = 3, n.OX3 = 4, n.OY3 = 5, n.OX4 = 6, n.OY4 = 7, n.X1 = 0, n.Y1 = 1, n.C1R = 2, n.C1G = 3, n.C1B = 4, n.C1A = 5, n.U1 = 6, n.V1 = 7, n.X2 = 8, n.Y2 = 9, n.C2R = 10, n.C2G = 11, n.C2B = 12, n.C2A = 13, n.U2 = 14, n.V2 = 15, n.X3 = 16, n.Y3 = 17, n.C3R = 18, n.C3G = 19, n.C3B = 20, n.C3A = 21, n.U3 = 22, n.V3 = 23, n.X4 = 24, n.Y4 = 25, n.C4R = 26, n.C4G = 27, n.C4B = 28, n.C4A = 29, n.U4 = 30, n.V4 = 31, n;
        }(t.Attachment);

        t.RegionAttachment = e;
      }(K || (K = {})), function (t) {
        var e = function () {
          function e(t, e) {
            this.jitterX = 0, this.jitterY = 0, this.jitterX = t, this.jitterY = e;
          }

          return e.prototype.begin = function () {}, e.prototype.transform = function (e) {
            e.x += t.MathUtils.randomTriangular(-this.jitterX, this.jitterY), e.y += t.MathUtils.randomTriangular(-this.jitterX, this.jitterY);
          }, e.prototype.end = function () {}, e;
        }();

        t.JitterEffect = e;
      }(K || (K = {})), function (t) {
        var e = function () {
          function e(t, e) {
            this.centerX = 0, this.centerY = 0, this.radius = 0, this.angle = 0, this.worldX = 0, this.worldY = 0, this.radius = t, this.interpolation = e;
          }

          return e.prototype.begin = function (t) {
            this.worldX = t.x + this.centerX, this.worldY = t.y + this.centerY;
          }, e.prototype.transform = function (e) {
            var n = this.angle * t.MathUtils.degreesToRadians,
                i = e.x - this.worldX,
                r = e.y - this.worldY,
                a = Math.sqrt(i * i + r * r);

            if (a < this.radius) {
              var s = this.interpolation.apply(0, n, (this.radius - a) / this.radius),
                  o = Math.cos(s),
                  l = Math.sin(s);
              e.x = o * i - l * r + this.worldX, e.y = l * i + o * r + this.worldY;
            }
          }, e.prototype.end = function () {}, e.interpolation = new t.PowOut(2), e;
        }();

        t.SwirlEffect = e;
      }(K || (K = {}));

      var tt,
          et,
          nt,
          it,
          rt,
          at,
          st = K,
          ot = function () {
        function t() {
          this.start = void 0, this.interrupt = void 0, this.end = void 0, this.dispose = void 0, this.complete = void 0, this.event = void 0;
        }

        return t.getListeners = function (e) {
          return e.listener || (e.listener = new t()), e.listener;
        }, t;
      }(),
          lt = 1 / 60,
          ht = [],
          ut = [],
          ct = 0,
          dt = 0,
          ft = 0,
          pt = null,
          mt = null,
          gt = 0,
          vt = 0,
          yt = 0,
          xt = 0,
          wt = null,
          _t = null,
          Et = 0,
          bt = 0,
          Tt = new st.Color(1, 1, 1, 1),
          Mt = new st.Color(1, 1, 1, 1),
          At = [0, 1, 2, 2, 3, 0],
          Ct = function () {
        function t() {
          this.frames = [], this.totalTime = 0, this.isCompleted = !1, this.maxVertexCount = 0, this.maxIndexCount = 0, this._privateMode = !1, this._inited = !1, this._invalid = !0, this._enableCacheAttachedInfo = !1, this._frameIdx = -1, this._skeletonInfo = null, this._animationName = null, this._tempSegments = null, this._tempColors = null, this._tempBoneInfos = null, this._privateMode = !1, this._inited = !1, this._invalid = !0, this._enableCacheAttachedInfo = !1, this.frames = [], this.totalTime = 0, this._frameIdx = -1, this.isCompleted = !1, this._skeletonInfo = null, this._animationName = null, this._tempSegments = null, this._tempColors = null, this._tempBoneInfos = null;
        }

        var e = t.prototype;
        return e.init = function (t, e) {
          this._inited = !0, this._animationName = e, this._skeletonInfo = t;
        }, e.clear = function () {
          this._inited = !1;

          for (var t = 0, e = this.frames.length; t < e; t++) {
            this.frames[t].segments.length = 0;
          }

          this.invalidAllFrame();
        }, e.bind = function (t) {
          var e = this;

          t.complete = function (t) {
            t && t.animation.name === e._animationName && (e.isCompleted = !0);
          };
        }, e.unbind = function (t) {
          t.complete = null;
        }, e.begin = function () {
          if (this._invalid) {
            var t = this._skeletonInfo,
                e = null == t ? void 0 : t.curAnimationCache;
            e && e !== this && (this._privateMode ? e.invalidAllFrame() : e.updateToFrame());
            var n = null == t ? void 0 : t.skeleton,
                i = null == t ? void 0 : t.listener,
                r = null == t ? void 0 : t.state,
                a = null == n ? void 0 : n.data.findAnimation(this._animationName);
            null == r || r.setAnimationWith(0, a, !1), this.bind(i), t.curAnimationCache = this, this._frameIdx = -1, this.isCompleted = !1, this.totalTime = 0, this._invalid = !1;
          }
        }, e.end = function () {
          this.needToUpdate() || (this._skeletonInfo.curAnimationCache = null, this.frames.length = this._frameIdx + 1, this.isCompleted = !0, this.unbind(this._skeletonInfo.listener));
        }, e.updateToFrame = function (t) {
          if (this._inited && (this.begin(), this.needToUpdate(t))) {
            var e = this._skeletonInfo,
                n = null == e ? void 0 : e.skeleton,
                i = null == e ? void 0 : e.clipper,
                r = null == e ? void 0 : e.state;

            do {
              null == n || n.update(lt), null == r || r.update(lt), null == r || r.apply(n), null == n || n.updateWorldTransform(), this._frameIdx++, this.updateFrame(n, i, this._frameIdx), this.totalTime += lt;
            } while (this.needToUpdate(t));

            this.end();
          }
        }, e.isInited = function () {
          return this._inited;
        }, e.isInvalid = function () {
          return this._invalid;
        }, e.invalidAllFrame = function () {
          this.isCompleted = !1, this._invalid = !0;
        }, e.updateAllFrame = function () {
          this.invalidAllFrame(), this.updateToFrame();
        }, e.enableCacheAttachedInfo = function () {
          this._enableCacheAttachedInfo || (this._enableCacheAttachedInfo = !0, this.invalidAllFrame());
        }, e.fillVertices = function (t, e, n, i, r) {
          if (it = n.a * e.a * t.a * 255, tt = e.r * t.r * 255, et = e.g * t.g * 255, nt = e.b * t.b * 255, Tt.r = tt * n.r, Tt.g = et * n.g, Tt.b = nt * n.b, Tt.a = it, null == r.darkColor ? Mt.set(0, 0, 0, 1) : (Mt.r = r.darkColor.r * tt, Mt.g = r.darkColor.g * et, Mt.b = r.darkColor.b * nt), Mt.a = 0, rt = (Tt.a << 24 >>> 0) + (Tt.b << 16) + (Tt.g << 8) + Tt.r, at = (Mt.a << 24 >>> 0) + (Mt.b << 16) + (Mt.g << 8) + Mt.r, wt !== rt || _t !== at) {
            var a = this._tempColors;
            wt = rt, _t = at, xt > 0 && (a[xt - 1].vfOffset = ft), a[xt++] = {
              fr: Tt.r,
              fg: Tt.g,
              fb: Tt.b,
              fa: Tt.a,
              dr: Mt.r,
              dg: Mt.g,
              db: Mt.b,
              da: Mt.a,
              vfOffset: 0
            };
          }

          if (i.isClipping()) {
            i.clipTriangles(ht, Et, ut, bt, ht, Tt, Mt, !0, 6, ft, ft + 2);
            var s = i.clippedVertices,
                o = i.clippedTriangles;
            bt = o.length, Et = s.length / 12 * 6;

            for (var l = 0, h = dt, u = o.length; l < u;) {
              ut[h++] = o[l++];
            }

            for (var c = 0, d = s.length, f = ft; c < d; c += 12, f += 6) {
              ht[f] = s[c], ht[f + 1] = s[c + 1], ht[f + 2] = s[c + 6], ht[f + 3] = s[c + 7], ht[f + 4] = rt, ht[f + 5] = at;
            }
          } else for (var p = ft, m = ft + Et; p < m; p += 6) {
            ht[p + 4] = rt, ht[p + 5] = at;
          }
        }, e.updateFrame = function (t, e, n) {
          ft = 0, ct = 0, dt = 0, pt = null, mt = null, gt = 0, vt = 0, yt = 0, xt = 0, wt = null, _t = null, this.frames[n] = this.frames[n] || {
            segments: [],
            colors: [],
            boneInfos: [],
            vertices: null,
            uintVert: null,
            indices: null
          };
          var i = this.frames[n],
              r = this._tempSegments = i.segments,
              a = this._tempColors = i.colors,
              s = this._tempBoneInfos = i.boneInfos;
          this.traverseSkeleton(t, e), xt > 0 && (a[xt - 1].vfOffset = ft), a.length = xt, s.length = ct;
          var o = yt - 1;
          if (o >= 0) if (vt > 0) {
            var l = r[o];
            l.indexCount = vt, l.vfCount = 13 * gt, l.vertexCount = gt, r.length = yt;
          } else r.length = yt - 1;

          if (0 !== r.length) {
            var h = i.vertices,
                u = ft / 6,
                c = 13 * u;
            (!h || h.length < c) && (h = i.vertices = new Float32Array(c));

            for (var d = 0, f = 0; d < c;) {
              h[d] = ht[f++], h[d + 1] = ht[f++], h[d + 3] = ht[f++], h[d + 4] = ht[f++], this._setVerticeColor(ht[f++], h, d + 5), this._setVerticeColor(ht[f++], h, d + 9), d += 13;
            }

            var p = i.indices;
            (!p || p.length < dt) && (p = i.indices = new Uint16Array(dt));

            for (var m = 0; m < dt; m++) {
              p[m] = ut[m];
            }

            i.vertices = h, i.indices = p, this.maxVertexCount = u > this.maxVertexCount ? u : this.maxVertexCount, this.maxIndexCount = p.length > this.maxIndexCount ? p.length : this.maxIndexCount;
          }
        }, e.needToUpdate = function (t) {
          return !this.isCompleted && this.totalTime < 30 && (void 0 === t || this._frameIdx < t);
        }, e.traverseSkeleton = function (t, e) {
          var n,
              i,
              r,
              a,
              s,
              o,
              l,
              h,
              u,
              c,
              d,
              f,
              p = this._tempSegments,
              m = this._tempBoneInfos,
              g = t.color,
              v = t.bones;
          if (this._enableCacheAttachedInfo) for (var y = 0, x = v.length; y < x; y++, ct++) {
            var w = v[y],
                _ = m[ct];
            _ || (_ = m[ct] = {}), _.a = w.a, _.b = w.b, _.c = w.c, _.d = w.d, _.worldX = w.worldX, _.worldY = w.worldY;
          }

          for (var E = 0, b = t.drawOrder.length; E < b; E++) {
            if ((f = t.drawOrder[E]).bone.active) if (Et = 0, bt = 0, n = f.getAttachment()) {
              if (o = n instanceof st.RegionAttachment, l = n instanceof st.MeshAttachment, n instanceof st.ClippingAttachment) e.clipStart(f, n);else if (o || l) {
                if (h = n.region.texture.getRealTexture()) {
                  if (d = f.data.blendMode, pt === h.getId() && mt === d || (pt = h.getId(), mt = d, (u = yt - 1) >= 0 && (vt > 0 ? ((c = p[u]).indexCount = vt, c.vertexCount = gt, c.vfCount = 13 * gt) : yt--), p[yt] = {
                    tex: h,
                    blendMode: d,
                    indexCount: 0,
                    vertexCount: 0,
                    vfCount: 0
                  }, yt++, vt = 0, gt = 0), o) s = At, Et = 24, bt = 6, n.computeWorldVertices(f.bone, ht, ft, 6);else if (l) {
                    var T = n;
                    s = T.triangles, Et = 6 * (T.worldVerticesLength >> 1), bt = s.length, T.computeWorldVertices(f, 0, T.worldVerticesLength, ht, ft, 6);
                  }

                  if (0 !== Et && 0 !== bt) {
                    for (var M = 0, A = dt, C = s.length; M < C;) {
                      ut[A++] = s[M++];
                    }

                    a = n.uvs;

                    for (var S = ft, k = ft + Et, I = 0; S < k; S += 6, I += 2) {
                      ht[S + 2] = a[I], ht[S + 3] = a[I + 1];
                    }

                    if (i = n.color, r = f.color, this.fillVertices(g, i, r, e, f), bt > 0) {
                      for (var R = dt, P = dt + bt; R < P; R++) {
                        ut[R] += gt;
                      }

                      dt += bt, ft += Et, vt += bt, gt += Et / 6;
                    }

                    e.clipEndWithSlot(f);
                  } else e.clipEndWithSlot(f);
                } else e.clipEndWithSlot(f);
              } else e.clipEndWithSlot(f);
            } else e.clipEndWithSlot(f);
          }

          e.clipEnd();
        }, e._setVerticeColor = function (t, e, n) {
          e[n] = (255 & t) / 255, e[n + 1] = (t >> 8 & 255) / 255, e[n + 2] = (t >> 16 & 255) / 255, e[n + 3] = (t >> 24 & 255) / 255;
        }, t;
      }(),
          St = function () {
        function t() {
          this._privateMode = void 0, this._skeletonCache = void 0, this._animationPool = void 0, this._privateMode = !1, this._animationPool = {}, this._skeletonCache = {};
        }

        var e = t.prototype;
        return e.enablePrivateMode = function () {
          this._privateMode = !0;
        }, e.clear = function () {
          this._animationPool = {}, this._skeletonCache = {};
        }, e.removeSkeleton = function (t) {
          var e = this._skeletonCache[t];

          if (e) {
            var n = e.animationsCache;

            for (var i in n) {
              var r = n[i];
              r && (this._animationPool[t + "#" + i] = r, r.clear());
            }

            delete this._skeletonCache[t];
          }
        }, e.getSkeletonCache = function (t, e) {
          var n = this._skeletonCache[t];

          if (!n) {
            var i = new st.Skeleton(e),
                r = new st.SkeletonClipping(),
                a = new st.AnimationStateData(i.data),
                s = new st.AnimationState(a),
                o = new ot();
            s.addListener(o), this._skeletonCache[t] = n = {
              skeleton: i,
              clipper: r,
              state: s,
              listener: o,
              animationsCache: {},
              curAnimationCache: null
            };
          }

          return n;
        }, e.getAnimationCache = function (t, e) {
          var n = this._skeletonCache[t];
          return n ? n.animationsCache[e] : null;
        }, e.invalidAnimationCache = function (t) {
          var e = this._skeletonCache[t];

          if (e && e.skeleton) {
            var n = e.animationsCache;

            for (var i in n) {
              n[i].invalidAllFrame();
            }
          }
        }, e.initAnimationCache = function (t, e) {
          if (!e) return null;
          var n = this._skeletonCache[t],
              i = n && n.skeleton;
          if (!i) return null;
          if (!i.data.findAnimation(e)) return null;
          var r = n.animationsCache,
              a = r[e];

          if (!a) {
            var s = t + "#" + e;
            (a = this._animationPool[s]) ? delete this._animationPool[s] : (a = new Ct())._privateMode = this._privateMode, a.init(n, e), r[e] = a;
          }

          return a;
        }, e.updateAnimationCache = function (t, e) {
          if (e) {
            var n = this.initAnimationCache(t, e);
            if (!n) return;
            n.updateAllFrame();
          } else {
            var i = this._skeletonCache[t];
            if (!i || !i.skeleton) return;
            var r = i.animationsCache;

            for (var a in r) {
              r[a].updateAllFrame();
            }
          }
        }, t;
      }();

      St.FrameTime = lt, St.sharedCache = new St();

      var kt,
          It,
          Rt,
          Pt,
          Vt,
          Dt,
          Nt,
          Ft,
          Ot,
          Lt,
          Ut,
          Bt = new x(),
          Yt = function () {
        function t() {
          this._inited = !1, this._skeleton = null, this._skeletonNode = null, this._skeletonComp = null, this._inited = !1, this._skeleton = null, this._skeletonNode = null, this._skeletonComp = null;
        }

        var n = t.prototype;
        return n.init = function (t) {
          this._inited = !0, this._skeleton = t._skeleton, this._skeletonNode = t.node, this._skeletonComp = t;
        }, n.reset = function () {
          this._inited = !1, this._skeleton = null, this._skeletonNode = null, this._skeletonComp = null;
        }, n._syncAttachedNode = function () {
          if (this._inited) {
            var t = this._skeletonComp.socketNodes;

            if (0 !== t.size) {
              var n;
              if (n = this._skeletonComp.isAnimationCached() ? this._skeletonComp._curFrame && this._skeletonComp._curFrame.boneInfos : this._skeleton.bones) for (var i, r = function r(t, e) {
                var n = Bt;
                n.m00 = e.a, n.m01 = e.c, n.m04 = e.b, n.m05 = e.d, n.m12 = e.worldX, n.m13 = e.worldY, t.matrix = Bt;
              }, a = e(t.keys()); !(i = a()).done;) {
                var s = i.value,
                    o = t.get(s);

                if (o && o.isValid) {
                  var l = n[s];
                  l ? r(o, l) : (o.removeFromParent(), o.destroy(), t.delete(s));
                } else t.delete(s);
              }
            }
          }
        }, t;
      }(),
          Xt = function (t) {
        function e(e) {
          var n;
          return (n = t.call(this, e) || this).name = "sp.SkeletonTexture", n._texture = null, n._material = null, n;
        }

        n(e, t);
        var i = e.prototype;
        return i.setRealTexture = function (t) {
          this._texture = t;
        }, i.getRealTexture = function () {
          return this._texture;
        }, i.setFilters = function (t, e) {
          this._texture && this.getRealTexture().setFilters(Wt(t), Wt(e));
        }, i.setWraps = function (t, e) {
          this._texture && this.getRealTexture().setWrapMode(qt(t), qt(e));
        }, i.dispose = function () {}, e;
      }(st.Texture);

      function Wt(t) {
        switch (t) {
          case st.TextureFilter.Nearest:
          case st.TextureFilter.MipMapNearestNearest:
          case st.TextureFilter.MipMapLinearNearest:
            return w.NEAREST;

          case st.TextureFilter.MipMap:
          case st.TextureFilter.MipMapNearestLinear:
          case st.TextureFilter.MipMapLinearLinear:
          case st.TextureFilter.Linear:
          default:
            return w.LINEAR;
        }
      }

      function qt(t) {
        switch (t) {
          case st.TextureWrap.MirroredRepeat:
            return _.MIRRORED_REPEAT;

          case st.TextureWrap.ClampToEdge:
            return _.CLAMP_TO_EDGE;

          case st.TextureWrap.Repeat:
          default:
            return _.REPEAT;
        }
      }

      var Ht = (kt = E("sp.SkeletonData"), It = b([T]), Rt = b([i]), kt((Ut = function (t) {
        function e() {
          var e;
          return e = t.call(this) || this, l(e, "_skeletonJson", Dt, h(e)), l(e, "textures", Nt, h(e)), l(e, "textureNames", Ft, h(e)), l(e, "scale", Ot, h(e)), l(e, "_atlasText", Lt, h(e)), e._buffer = void 0, e._skeletonCache = null, e._atlasCache = null, e._skinsEnum = null, e._animsEnum = null, e.reset(), e;
        }

        n(e, t);
        var i = e.prototype;
        return i.createNode = function (t) {
          var e = new M(this.name);
          return e.addComponent("cc.Skeleton").skeletonData = this, t(null, e);
        }, i.reset = function () {
          this._skeletonCache = null, this._atlasCache = null;
        }, i.resetEnums = function () {}, i.getRuntimeData = function (t) {
          if (this._skeletonCache) return this._skeletonCache;
          if (!(this.textures && this.textures.length > 0) && this.textureNames && this.textureNames.length > 0) return t || console.error(this.name + " no textures found!"), null;

          var e = this._getAtlas(t);

          if (!e) return null;
          var n = new st.AtlasAttachmentLoader(e),
              i = null,
              r = null;
          return this.skeletonJson ? (r = new st.SkeletonJson(n), i = this.skeletonJson) : (r = new st.SkeletonBinary(n), i = new Uint8Array(this._nativeAsset)), r.scale = this.scale, this._skeletonCache = r.readSkeletonData(i), e.dispose(), this._skeletonCache;
        }, i.getSkinsEnum = function () {
          if (this._skinsEnum) return this._skinsEnum;
          var t = this.getRuntimeData(!0);

          if (t) {
            for (var e = t.skins, n = {}, i = 0; i < e.length; i++) {
              n[e[i].name] = i;
            }

            return this._skinsEnum = r(n);
          }

          return null;
        }, i.getAnimsEnum = function () {
          if (this._animsEnum && Object.keys(this._animsEnum).length > 1) return this._animsEnum;
          var t = this.getRuntimeData(!0);

          if (t) {
            for (var e = {
              "<None>": 0
            }, n = t.animations, i = 0; i < n.length; i++) {
              e[n[i].name] = i + 1;
            }

            return this._animsEnum = r(e);
          }

          return null;
        }, i.destroy = function () {
          return St.sharedCache.removeSkeleton(this._uuid), t.prototype.destroy.call(this);
        }, i._getTexture = function (t) {
          for (var e = this.textureNames, n = 0; n < e.length; n++) {
            if (e[n] === t) {
              var i = this.textures[n],
                  r = new Xt({
                width: i.width,
                height: i.height
              });
              return r.setRealTexture(i), r;
            }
          }

          return console.error(this.name + " no textures found!"), null;
        }, i._getAtlas = function (t) {
          return this._atlasCache ? this._atlasCache : this.atlasText ? this._atlasCache = new st.TextureAtlas(this.atlasText, this._getTexture.bind(this)) : (t || console.error(this.name + " no atlas found!"), null);
        }, a(e, [{
          key: "skeletonJsonStr",
          get: function get() {
            return this._skeletonJson ? JSON.stringify(this._skeletonJson) : "";
          }
        }, {
          key: "skeletonJson",
          get: function get() {
            return this._skeletonJson;
          },
          set: function set(t) {
            this.reset(), this._skeletonJson = "string" == typeof t ? JSON.parse(t) : t, !this._uuid && t.skeleton && (this._uuid = t.skeleton.hash);
          }
        }, {
          key: "atlasText",
          get: function get() {
            return this._atlasText;
          },
          set: function set(t) {
            this._atlasText = t, this.reset();
          }
        }, {
          key: "_nativeAsset",
          get: function get() {
            return this._buffer;
          },
          set: function set(t) {
            this._buffer = t, this.reset();
          }
        }]), e;
      }(A), Dt = s((Vt = Ut).prototype, "_skeletonJson", [C], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return null;
        }
      }), Nt = s(Vt.prototype, "textures", [C, It], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return [];
        }
      }), Ft = s(Vt.prototype, "textureNames", [C, Rt], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return [];
        }
      }), Ot = s(Vt.prototype, "scale", [C], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 1;
        }
      }), Lt = s(Vt.prototype, "_atlasText", [C], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return "";
        }
      }), Pt = Vt)) || Pt);
      o.internal.SpineSkeletonData = Ht;

      var jt,
          zt,
          Gt,
          Zt,
          Jt,
          Qt,
          Kt,
          $t,
          te,
          ee,
          ne,
          ie,
          re,
          ae,
          se,
          oe,
          le,
          he,
          ue,
          ce,
          de,
          fe,
          pe,
          me,
          ge,
          ve,
          ye,
          xe,
          we,
          _e,
          Ee,
          be,
          Te,
          Me,
          Ae,
          Ce,
          Se,
          ke,
          Ie,
          Re,
          Pe,
          Ve,
          De,
          Ne,
          Fe,
          Oe,
          Le,
          Ue,
          Be,
          Ye,
          Xe,
          We,
          qe,
          He,
          je,
          ze = function (t) {
        function e() {
          var e;
          return (e = t.call(this) || this)._skeletons = new Set(), e;
        }

        n(e, t), e.getInstance = function () {
          return e._instance || (e._instance = new e(), X.registerSystem(e.ID, e._instance, W.Priority.HIGH)), e._instance;
        };
        var i = e.prototype;
        return i.add = function (t) {
          t && (this._skeletons.has(t) || this._skeletons.add(t));
        }, i.remove = function (t) {
          t && this._skeletons.has(t) && this._skeletons.delete(t);
        }, i.postUpdate = function (t) {
          this._skeletons && this._skeletons.forEach(function (e) {
            e.updateAnimation(t);
          });
        }, e;
      }(W);

      function Ge(t, e, n) {
        g.Attr.setClassAttr(t, e, "type", "Enum"), g.Attr.setClassAttr(t, e, "enumList", r.getList(n));
      }

      ze.ID = "SKELETON", ze._instance = void 0, function (t) {
        t[t.default = 0] = "default";
      }(We || (We = {})), u(We), function (t) {
        t[t["<None>"] = 0] = "<None>";
      }(qe || (qe = {})), u(qe), function (t) {
        t[t.REALTIME = 0] = "REALTIME", t[t.SHARED_CACHE = 1] = "SHARED_CACHE", t[t.PRIVATE_CACHE = 2] = "PRIVATE_CACHE";
      }(He || (He = {})), u(He), function (t) {
        t[t.COLORED_TEXTURED = 0] = "COLORED_TEXTURED", t[t.TWO_COLORED = 1] = "TWO_COLORED";
      }(je || (je = {}));
      var Ze = (jt = E("sp.Skeleton.SpineSocket"), zt = b(M), jt((Jt = s((Zt = function Zt(t, e) {
        void 0 === t && (t = ""), void 0 === e && (e = null), l(this, "path", Jt, this), l(this, "target", Qt, this), this.path = t, this.target = e;
      }).prototype, "path", [C, D], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return "";
        }
      }), Qt = s(Zt.prototype, "target", [zt, D, C], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return null;
        }
      }), Gt = Zt)) || Gt);
      c.setClassAlias(Ze, "sp.Skeleton.SpineSocket");
      var Je = (Kt = E("sp.Skeleton"), $t = N(), te = F(), ee = b(S), ne = O(), ie = L(), re = b(Ht), ae = L(), se = b(We), oe = U(), le = L(), he = b(qe), ue = U(), ce = L(), de = U(), fe = b(He), pe = U(), me = U(), ge = U(), ve = U(), ye = U(), xe = U(), we = U(), _e = b([Ze]), Ee = U(), be = B(), Te = B(), Kt(Me = $t(Me = te(Me = k((Xe = Ye = function (t) {
        function e() {
          var e;
          return e = t.call(this) || this, l(e, "loop", Ce, h(e)), e._frameCache = null, e._curFrame = null, e._effectDelegate = null, e._skeleton = void 0, e._clipper = void 0, e._debugRenderer = void 0, e._startSlotIndex = void 0, e._endSlotIndex = void 0, e._startEntry = void 0, e._endEntry = void 0, e.attachUtil = void 0, e.maxVertexCount = 0, e.maxIndexCount = 0, e._materialCache = {}, e._enumSkins = r({}), e._enumAnimations = r({}), e._playTimes = 0, l(e, "_timeScale", Se, h(e)), e._paused = !1, e._accTime = 0, e._playCount = 0, e._skeletonCache = null, e._animationName = "", e._animationQueue = [], e._headAniInfo = null, e._isAniComplete = !0, e._needUpdateSkeltonData = !0, l(e, "_useTint", ke, h(e)), l(e, "_preCacheMode", Ie, h(e)), l(e, "_cacheMode", Re, h(e)), l(e, "_defaultCacheMode", Pe, h(e)), l(e, "_debugBones", Ve, h(e)), l(e, "_debugSlots", De, h(e)), l(e, "_skeletonData", Ne, h(e)), l(e, "_premultipliedAlpha", Fe, h(e)), l(e, "defaultSkin", Oe, h(e)), l(e, "defaultAnimation", Le, h(e)), l(e, "_sockets", Ue, h(e)), e._drawIdx = 0, e._drawList = new v(function () {
            return {
              material: null,
              texture: null,
              indexOffset: 0,
              indexCount: 0
            };
          }, 1), l(e, "_debugMesh", Be, h(e)), e._rootBone = void 0, e._state = void 0, e._listener = void 0, e._socketNodes = new Map(), e._cachedSockets = new Map(), e._effectDelegate = null, e._skeleton = null, e._rootBone = null, e._listener = null, e._debugRenderer = null, e._startSlotIndex = -1, e._endSlotIndex = -1, e._startEntry = {
            animation: {
              name: ""
            },
            trackIndex: 0
          }, e._endEntry = {
            animation: {
              name: ""
            },
            trackIndex: 0
          }, e.attachUtil = new Yt(), Ge(h(e), "_defaultSkinIndex", e._enumSkins), Ge(h(e), "_animationIndex", e._enumAnimations), e._useVertexOpacity = !0, e;
        }

        n(e, t);
        var i = e.prototype;
        return i.setSkeletonData = function (t) {
          var e = this.node._uiProps.uiTransformComp;

          if (null != t.width && null != t.height && e.setContentSize(t.width, t.height), this._cacheMode === He.SHARED_CACHE ? this._skeletonCache = St.sharedCache : this._cacheMode === He.PRIVATE_CACHE && (this._skeletonCache = new St(), this._skeletonCache.enablePrivateMode()), this.isAnimationCached()) {
            (this.debugBones || this.debugSlots) && d("Debug bones or slots is invalid in cached mode");

            var n = this._skeletonCache.getSkeletonCache(this.skeletonData._uuid, t);

            this._skeleton = n.skeleton, this._clipper = n.clipper, this._rootBone = this._skeleton.getRootBone();
          } else this._skeleton = new st.Skeleton(t), this._clipper = new st.SkeletonClipping(), this._rootBone = this._skeleton.getRootBone();

          this._flushAssembler();
        }, i.setSlotsRange = function (t, e) {
          this.isAnimationCached() ? d("Slots visible range can not be modified in cached mode.") : (this._startSlotIndex = t, this._endSlotIndex = e);
        }, i.setAnimationStateData = function (t) {
          if (this.isAnimationCached()) d("'setAnimationStateData' interface can not be invoked in cached mode.");else {
            var e = new st.AnimationState(t);
            this._listener && (this._state && this._state.removeListener(this._listener), e.addListener(this._listener)), this._state = e;
          }
        }, i.__preload = function () {
          t.prototype.__preload.call(this);

          for (var e = this.node.children, n = 0, i = e.length; n < i; n++) {
            var r = e[n];
            r && "DEBUG_DRAW_NODE" === r.name && r.destroy();
          }

          this._updateSkeletonData(), this._updateDebugDraw(), this._updateUseTint(), this._indexBoneSockets(), this._updateSocketBindings();
        }, i.setAnimationCacheMode = function (t) {
          this._preCacheMode !== t && (this._cacheMode = t, this._needUpdateSkeltonData = !0, this._updateSkeletonData(), this._updateUseTint(), this._updateSocketBindings(), this.markForUpdateRenderData());
        }, i.isAnimationCached = function () {
          return this._cacheMode !== He.REALTIME;
        }, i.updateAnimation = function (t) {
          if (this.markForUpdateRenderData(), !this.paused) if (t *= 1 * this._timeScale, this.isAnimationCached()) {
            if (this._isAniComplete) {
              if (0 === this._animationQueue.length && !this._headAniInfo) {
                var e = this._frameCache;

                if (e && e.isInvalid()) {
                  e.updateToFrame();
                  var n = e.frames;
                  this._curFrame = n[n.length - 1];
                }

                return;
              }

              if (this._headAniInfo || (this._headAniInfo = this._animationQueue.shift()), this._accTime += t, this._accTime > this._headAniInfo.delay) {
                var i = this._headAniInfo;
                this._headAniInfo = null, this.setAnimation(0, i.animationName, i.loop);
              }

              return;
            }

            this._updateCache(t);
          } else this._updateRealtime(t);
        }, i.setVertexEffectDelegate = function (t) {
          this._effectDelegate = t;
        }, i.setToSetupPose = function () {
          this._skeleton && this._skeleton.setToSetupPose();
        }, i.setBonesToSetupPose = function () {
          this._skeleton && this._skeleton.setBonesToSetupPose();
        }, i.setSlotsToSetupPose = function () {
          this._skeleton && this._skeleton.setSlotsToSetupPose();
        }, i.updateAnimationCache = function (t) {
          if (this.isAnimationCached()) {
            var e = this._skeletonData._uuid;
            this._skeletonCache && this._skeletonCache.updateAnimationCache(e, t);
          }
        }, i.invalidAnimationCache = function () {
          this.isAnimationCached() && this._skeletonCache && this._skeletonCache.invalidAnimationCache(this._skeletonData._uuid);
        }, i.findBone = function (t) {
          return this._skeleton ? this._skeleton.findBone(t) : null;
        }, i.findSlot = function (t) {
          return this._skeleton ? this._skeleton.findSlot(t) : null;
        }, i.setSkin = function (t) {
          this._skeleton && (this._skeleton.setSkinByName(t), this._skeleton.setSlotsToSetupPose()), this.invalidAnimationCache();
        }, i.getAttachment = function (t, e) {
          return this._skeleton ? this._skeleton.getAttachmentByName(t, e) : null;
        }, i.setAttachment = function (t, e) {
          this._skeleton && this._skeleton.setAttachment(t, e), this.invalidAnimationCache();
        }, i.getTextureAtlas = function (t) {
          return t.region;
        }, i.setMix = function (t, e, n) {
          this._state && this._state.data.setMix(t, e, n);
        }, i.setAnimation = function (t, e, n) {
          if (this._playTimes = n ? 0 : 1, this._animationName = e, this.isAnimationCached()) {
            if (0 !== t && d("Track index can not greater than 0 in cached mode."), !this._skeletonCache) return null;

            var i = this._skeletonCache.getAnimationCache(this._skeletonData._uuid, e);

            i || (i = this._skeletonCache.initAnimationCache(this._skeletonData._uuid, e)), i && (this._isAniComplete = !1, this._accTime = 0, this._playCount = 0, this._frameCache = i, this._socketNodes.size > 0 && this._frameCache.enableCacheAttachedInfo(), this._frameCache.updateToFrame(0), this._curFrame = this._frameCache.frames[0]);
          } else if (this._skeleton) {
            var r = this._skeleton.data.findAnimation(e);

            if (!r) return f(7509, e), null;

            var a = this._state.setAnimationWith(t, r, n);

            return this._state.apply(this._skeleton), a;
          }

          return null;
        }, i.addAnimation = function (t, e, n, i) {
          if (i = i || 0, this.isAnimationCached()) 0 !== t && d("Track index can not greater than 0 in cached mode."), this._animationQueue.push({
            animationName: e,
            loop: n,
            delay: i
          });else if (this._skeleton) {
            var r,
                a = this._skeleton.data.findAnimation(e);

            return a ? null === (r = this._state) || void 0 === r ? void 0 : r.addAnimationWith(t, a, n, i) : (f(7510, e), null);
          }
          return null;
        }, i.findAnimation = function (t) {
          return this._skeleton ? this._skeleton.data.findAnimation(t) : null;
        }, i.getCurrent = function (t) {
          if (this.isAnimationCached()) d("'getCurrent' interface can not be invoked in cached mode.");else if (this._state) return this._state.getCurrent(t);
          return null;
        }, i.clearTracks = function () {
          this.isAnimationCached() ? d("'clearTracks' interface can not be invoked in cached mode.") : this._state && (this._state.clearTracks(), this.setToSetupPose());
        }, i.clearTrack = function (t) {
          this.isAnimationCached() ? d("'clearTrack' interface can not be invoked in cached mode.") : this._state && this._state.clearTrack(t);
        }, i.setStartListener = function (t) {
          this._ensureListener(), this._listener.start = t;
        }, i.setInterruptListener = function (t) {
          this._ensureListener(), this._listener.interrupt = t;
        }, i.setEndListener = function (t) {
          this._ensureListener(), this._listener.end = t;
        }, i.setDisposeListener = function (t) {
          this._ensureListener(), this._listener.dispose = t;
        }, i.setCompleteListener = function (t) {
          this._ensureListener(), this._listener.complete = t;
        }, i.setEventListener = function (t) {
          this._ensureListener(), this._listener.event = t;
        }, i.setTrackStartListener = function (t, e) {
          ot.getListeners(t).start = e;
        }, i.setTrackInterruptListener = function (t, e) {
          ot.getListeners(t).interrupt = e;
        }, i.setTrackEndListener = function (t, e) {
          ot.getListeners(t).end = e;
        }, i.setTrackDisposeListener = function (t, e) {
          ot.getListeners(t).dispose = e;
        }, i.setTrackCompleteListener = function (t, e) {
          ot.getListeners(t).complete = function (t) {
            var n = Math.floor(t.trackTime / t.animationEnd);
            e(t, n);
          };
        }, i.setTrackEventListener = function (t, e) {
          ot.getListeners(t).event = e;
        }, i.getState = function () {
          return this._state;
        }, i.onEnable = function () {
          t.prototype.onEnable.call(this), this._flushAssembler(), ze.getInstance().add(this);
        }, i.onDisable = function () {
          t.prototype.onDisable.call(this), ze.getInstance().remove(this);
        }, i.onDestroy = function () {
          this._cleanMaterialCache(), this._drawList.destroy(), t.prototype.onDestroy.call(this);
        }, i.destroyRenderData = function () {
          this._drawList.reset(), t.prototype.destroyRenderData.call(this);
        }, i.getMaterialForBlendAndTint = function (t, e, n) {
          var i = n + "/" + t + "/" + e,
              r = this._materialCache[i];
          if (r) return r;
          var a = this.customMaterial;
          null === a && (a = I.get("default-spine-material"));
          var s = !1;

          switch (n) {
            case je.TWO_COLORED:
              s = !0;
              break;

            case je.COLORED_TEXTURED:
          }

          return r = new R({
            parent: a,
            subModelIdx: 0,
            owner: this
          }), this._materialCache[i] = r, r.overridePipelineStates({
            blendState: {
              blendColor: P.WHITE,
              targets: [{
                blendEq: p.ADD,
                blendAlphaEq: p.ADD,
                blendSrc: t,
                blendDst: e,
                blendSrcAlpha: t,
                blendDstAlpha: e
              }]
            }
          }), r.recompileShaders({
            TWO_COLORED: s,
            USE_LOCAL: !0
          }), r;
        }, i.onRestore = function () {
          this.updateMaterial(), this._renderFlag = this._canRender(), this.markForUpdateRenderData();
        }, i.updateMaterial = function () {
          if (this._customMaterial) return this.setMaterial(this._customMaterial, 0), void (this._blendHash = -1);

          var t = this._updateBuiltinMaterial();

          this.setMaterial(t, 0), this._updateBlendFunc(), this._blendHash = -1;
        }, i.querySockets = function () {
          return this._skeleton ? (0 === this._cachedSockets.size && this._indexBoneSockets(), this._cachedSockets.size > 0 ? Array.from(this._cachedSockets.keys()).sort() : []) : [];
        }, i._requestDrawData = function (t, e, n, i) {
          var r = this._drawList.add();

          return r.material = t, r.texture = e, r.indexOffset = n, r.indexCount = i, r;
        }, i._render = function (t) {
          if (this._renderData && this._drawList) {
            var e = this._renderData,
                n = e.chunk,
                i = n.vertexAccessor,
                r = e.getMeshBuffer(),
                a = r.indexOffset;
            i.appendIndices(n.bufferId, e.indices);

            for (var s = 0; s < this._drawList.length; s++) {
              this._drawIdx = s;
              var o = this._drawList.data[s];

              if (o.texture) {
                var l = r.requireFreeIA(t.device);
                l.firstIndex = a + o.indexOffset, l.indexCount = o.indexCount, t.commitIA(this, l, o.texture, o.material, this.node);
              }
            }
          }
        }, i.updateWorldTransform = function () {
          this.isAnimationCached() && this._skeleton && this._skeleton.updateWorldTransform();
        }, i._emitCacheCompleteEvent = function () {
          this._listener && (this._endEntry.animation.name = this._animationName, this._listener.complete && this._listener.complete(this._endEntry), this._listener.end && this._listener.end(this._endEntry));
        }, i._updateCache = function (t) {
          var e = this._frameCache;

          if (e.isInited()) {
            var n = e.frames,
                i = St.FrameTime;
            0 === this._accTime && 0 === this._playCount && (this._startEntry.animation.name = this._animationName, this._listener && this._listener.start && this._listener.start(this._startEntry)), this._accTime += t;
            var r = Math.floor(this._accTime / i);

            if (e.isCompleted || (e.updateToFrame(r), this._renderData && (this._renderData.vertexCount < e.maxVertexCount || this._renderData.indexCount < e.maxIndexCount) && (this.maxVertexCount = e.maxVertexCount > this.maxVertexCount ? e.maxVertexCount : this.maxVertexCount, this.maxIndexCount = e.maxIndexCount > this.maxIndexCount ? e.maxIndexCount : this.maxIndexCount, this._renderData.resize(this.maxVertexCount, this.maxIndexCount), (!this._renderData.indices || this.maxIndexCount > this._renderData.indices.length) && (this._renderData.indices = new Uint16Array(this.maxIndexCount)))), e.isCompleted && r >= n.length) {
              if (this._playCount++, this._playTimes > 0 && this._playCount >= this._playTimes) return this._curFrame = n[n.length - 1], this._accTime = 0, this._playCount = 0, this._isAniComplete = !0, void this._emitCacheCompleteEvent();
              this._accTime = 0, r = 0, this._emitCacheCompleteEvent();
            }

            this._curFrame = n[r];
          }
        }, i._updateRealtime = function (t) {
          var e = this._skeleton,
              n = this._state;
          e && (e.update(t), n && (n.update(t), n.apply(e)));
        }, i._indexBoneSockets = function () {
          if (this._skeleton) {
            this._cachedSockets.clear();

            for (var t = this._skeleton.bones, e = function e(n) {
              return null == n.parent ? n.data.name || "<Unamed>" : e(t[n.parent.data.index]) + "/" + n.data.name;
            }, n = 0, i = t.length; n < i; n++) {
              var r = t[n].data,
                  a = e(t[n]);

              this._cachedSockets.set(a, r.index);
            }
          }
        }, i._updateUseTint = function () {
          this._cleanMaterialCache(), this.destroyRenderData(), this._assembler && this._skeleton && (this._renderData = this._assembler.createData(this), this.markForUpdateRenderData());
        }, i._updateBatch = function () {
          this.markForUpdateRenderData();
        }, i._updateAnimEnum = function () {
          var t;
          t = this.skeletonData ? this.skeletonData.getAnimsEnum() : qe, this._enumAnimations = r({}), Object.assign(this._enumAnimations, t), r.update(this._enumAnimations), Ge(this, "_animationIndex", this._enumAnimations);
        }, i._updateSkinEnum = function () {
          var t;
          t = this.skeletonData ? this.skeletonData.getSkinsEnum() : We, this._enumSkins = r({}), Object.assign(this._enumSkins, t), r.update(this._enumSkins), Ge(this, "_defaultSkinIndex", this._enumSkins);
        }, i._ensureListener = function () {
          this._listener || (this._listener = new ot(), this._state && this._state.addListener(this._listener));
        }, i._updateSkeletonData = function () {
          if (this.skeletonData && !1 !== this._needUpdateSkeltonData) {
            this._needUpdateSkeltonData = !1;
            var t = this.skeletonData.getRuntimeData();

            if (t) {
              try {
                this.setSkeletonData(t), this.isAnimationCached() || this.setAnimationStateData(new st.AnimationStateData(this._skeleton.data)), this.defaultSkin && this.setSkin(this.defaultSkin);
              } catch (t) {
                d(t);
              }

              this._indexBoneSockets(), this.attachUtil.init(this), this._preCacheMode = this._cacheMode, this.animation = this.defaultAnimation;
            }
          }
        }, i._refreshInspector = function () {
          this._updateAnimEnum(), this._updateSkinEnum();
        }, i._updateDebugDraw = function () {
          if (this.debugBones || this.debugSlots || this.debugMesh) {
            if (!this._debugRenderer) {
              var t = new M("DEBUG_DRAW_NODE");
              t.hideFlags |= m.Flags.DontSave | m.Flags.HideInHierarchy;
              var e = t.addComponent(G);
              e.lineWidth = 1, e.strokeColor = new P(255, 0, 0, 255), this._debugRenderer = e, t.parent = this.node;
            }

            this.isAnimationCached() && d("Debug bones or slots is invalid in cached mode");
          } else this._debugRenderer && (this._debugRenderer.node.destroy(), this._debugRenderer = null);
        }, i._flushAssembler = function () {
          var t = e.Assembler.getAssembler(this);
          this._assembler !== t && (this._assembler = t), this._skeleton && this._assembler && (this._renderData = this._assembler.createData(this), this.markForUpdateRenderData(), this._updateColor());
        }, i._updateSocketBindings = function () {
          if (this._skeleton) {
            this._socketNodes.clear();

            for (var t = 0, e = this._sockets.length; t < e; t++) {
              var n = this._sockets[t];

              if (n.path && n.target) {
                var i = this._cachedSockets.get(n.path);

                if (!i) {
                  console.error("Skeleton data does not contain path " + n.path);
                  continue;
                }

                this._socketNodes.set(i, n.target);
              }
            }
          }
        }, i._verifySockets = function (t) {
          for (var e = 0, n = t.length; e < n; e++) {
            var i = t[e].target;
            !i || i.parent && i.parent === this.node || console.error("Target node " + i.name + " is expected to be a direct child of " + this.node.name);
          }

          var r = new Map();
          t.forEach(function (t) {
            t.target && (r.get(t.target) ? console.error("Target node " + t.target.name + " has existed.") : r.set(t.target, !0));
          });
        }, i._cleanMaterialCache = function () {
          for (var t in this._materialCache) {
            this._materialCache[t].destroy();
          }

          this._materialCache = {};
        }, a(e, [{
          key: "drawList",
          get: function get() {
            return this._drawList;
          }
        }, {
          key: "customMaterial",
          get: function get() {
            return this._customMaterial;
          },
          set: function set(t) {
            this._customMaterial = t, this._cleanMaterialCache();
          }
        }, {
          key: "paused",
          get: function get() {
            return this._paused;
          },
          set: function set(t) {
            this._paused = t;
          }
        }, {
          key: "skeletonData",
          get: function get() {
            return this._skeletonData;
          },
          set: function set(t) {
            t && t.resetEnums(), this._skeletonData !== t && (this.destroyRenderData(), this._skeletonData = t, this._needUpdateSkeltonData = !0, this.defaultSkin = "", this.defaultAnimation = "", this._updateSkeletonData());
          }
        }, {
          key: "animation",
          get: function get() {
            if (this.isAnimationCached()) return this._animationName;
            var t = this.getCurrent(0);
            return t && t.animation.name || "";
          },
          set: function set(t) {
            t ? (this.setAnimation(0, t, this.loop), this.markForUpdateRenderData()) : this.isAnimationCached() || (this.clearTrack(0), this.setToSetupPose());
          }
        }, {
          key: "_defaultSkinIndex",
          get: function get() {
            if (this.skeletonData) {
              var t = this.skeletonData.getSkinsEnum();
              if (t) if ("" === this.defaultSkin) {
                if (t.hasOwnProperty(0)) return this._defaultSkinIndex = 0, 0;
              } else {
                var e = t[this.defaultSkin];
                if (void 0 !== e) return e;
              }
            }

            return 0;
          },
          set: function set(t) {
            var e;

            if (this.skeletonData && (e = this.skeletonData.getSkinsEnum()), e) {
              var n = e[t];
              void 0 !== n ? (this.defaultSkin = n, this.setSkin(this.defaultSkin)) : console.error(this.name + " skin enums are invalid");
            } else console.error(this.name + " skin enums are invalid");
          }
        }, {
          key: "_animationIndex",
          get: function get() {
            var t = this.animation;
            if (this.skeletonData) if (t) {
              var e = this.skeletonData.getAnimsEnum();

              if (e) {
                var n = e[t];
                if (void 0 !== n) return n;
              }
            } else this._refreshInspector();
            return 0;
          },
          set: function set(t) {
            var e;

            if (this.skeletonData && (e = this.skeletonData.getAnimsEnum()), e) {
              var n = e[t];
              void 0 !== n ? (this.animation = n, this.animation = n) : console.error(this.name + " animation enums are invalid");
            } else console.error(this.name + " animation enums are invalid");
          }
        }, {
          key: "defaultCacheMode",
          get: function get() {
            return this._defaultCacheMode;
          },
          set: function set(t) {
            this._defaultCacheMode = t, this.setAnimationCacheMode(this._defaultCacheMode);
          }
        }, {
          key: "premultipliedAlpha",
          get: function get() {
            return this._premultipliedAlpha;
          },
          set: function set(t) {
            t !== this._premultipliedAlpha && (this._premultipliedAlpha = t, this.markForUpdateRenderData());
          }
        }, {
          key: "timeScale",
          get: function get() {
            return this._timeScale;
          },
          set: function set(t) {
            t !== this._timeScale && (this._timeScale = t);
          }
        }, {
          key: "debugSlots",
          get: function get() {
            return this._debugSlots;
          },
          set: function set(t) {
            t !== this._debugSlots && (this._debugSlots = t, this._updateDebugDraw(), this.markForUpdateRenderData());
          }
        }, {
          key: "debugBones",
          get: function get() {
            return this._debugBones;
          },
          set: function set(t) {
            t !== this._debugBones && (this._debugBones = t, this._updateDebugDraw(), this.markForUpdateRenderData());
          }
        }, {
          key: "debugMesh",
          get: function get() {
            return this._debugMesh;
          },
          set: function set(t) {
            t !== this._debugMesh && (this._debugMesh = t, this._updateDebugDraw(), this.markForUpdateRenderData());
          }
        }, {
          key: "useTint",
          get: function get() {
            return this._useTint;
          },
          set: function set(t) {
            t !== this._useTint && (this._useTint = t, this._updateUseTint());
          }
        }, {
          key: "sockets",
          get: function get() {
            return this._sockets;
          },
          set: function set(t) {
            this._sockets = t, this._updateSocketBindings(), this.attachUtil._syncAttachedNode();
          }
        }, {
          key: "socketNodes",
          get: function get() {
            return this._socketNodes;
          }
        }]), e;
      }(q), Ye.SpineSocket = Ze, Ye.AnimationCacheMode = He, s((Ae = Xe).prototype, "customMaterial", [V, ee, ne, ie], Object.getOwnPropertyDescriptor(Ae.prototype, "customMaterial"), Ae.prototype), s(Ae.prototype, "skeletonData", [D, re], Object.getOwnPropertyDescriptor(Ae.prototype, "skeletonData"), Ae.prototype), s(Ae.prototype, "_defaultSkinIndex", [ae, se, oe], Object.getOwnPropertyDescriptor(Ae.prototype, "_defaultSkinIndex"), Ae.prototype), s(Ae.prototype, "_animationIndex", [le, he, ue], Object.getOwnPropertyDescriptor(Ae.prototype, "_animationIndex"), Ae.prototype), s(Ae.prototype, "defaultCacheMode", [ce, de, D, fe], Object.getOwnPropertyDescriptor(Ae.prototype, "defaultCacheMode"), Ae.prototype), Ce = s(Ae.prototype, "loop", [C, pe], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !0;
        }
      }), s(Ae.prototype, "premultipliedAlpha", [D, me], Object.getOwnPropertyDescriptor(Ae.prototype, "premultipliedAlpha"), Ae.prototype), s(Ae.prototype, "timeScale", [ge, D], Object.getOwnPropertyDescriptor(Ae.prototype, "timeScale"), Ae.prototype), s(Ae.prototype, "debugSlots", [D, ve], Object.getOwnPropertyDescriptor(Ae.prototype, "debugSlots"), Ae.prototype), s(Ae.prototype, "debugBones", [D, ye], Object.getOwnPropertyDescriptor(Ae.prototype, "debugBones"), Ae.prototype), s(Ae.prototype, "debugMesh", [D, xe], Object.getOwnPropertyDescriptor(Ae.prototype, "debugMesh"), Ae.prototype), s(Ae.prototype, "useTint", [D, we], Object.getOwnPropertyDescriptor(Ae.prototype, "useTint"), Ae.prototype), s(Ae.prototype, "sockets", [_e, Ee], Object.getOwnPropertyDescriptor(Ae.prototype, "sockets"), Ae.prototype), Se = s(Ae.prototype, "_timeScale", [C], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 1;
        }
      }), ke = s(Ae.prototype, "_useTint", [C], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !1;
        }
      }), Ie = s(Ae.prototype, "_preCacheMode", [C], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return -1;
        }
      }), Re = s(Ae.prototype, "_cacheMode", [C], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return He.REALTIME;
        }
      }), Pe = s(Ae.prototype, "_defaultCacheMode", [C], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return He.REALTIME;
        }
      }), Ve = s(Ae.prototype, "_debugBones", [C], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !1;
        }
      }), De = s(Ae.prototype, "_debugSlots", [C], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !1;
        }
      }), Ne = s(Ae.prototype, "_skeletonData", [C], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return null;
        }
      }), Fe = s(Ae.prototype, "_premultipliedAlpha", [C], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !0;
        }
      }), Oe = s(Ae.prototype, "defaultSkin", [C, be], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return "";
        }
      }), Le = s(Ae.prototype, "defaultAnimation", [Te, C], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return "";
        }
      }), Ue = s(Ae.prototype, "_sockets", [C], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return [];
        }
      }), Be = s(Ae.prototype, "_debugMesh", [C], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !1;
        }
      }), Me = Ae)) || Me) || Me) || Me) || Me);
      o.internal.SpineSkeleton = Je;

      var Qe,
          Ke,
          $e,
          tn,
          en,
          nn,
          rn,
          an,
          sn,
          on,
          ln,
          hn,
          un,
          cn,
          dn,
          fn,
          pn,
          mn,
          gn,
          vn,
          yn,
          xn,
          wn,
          _n,
          En,
          bn,
          Tn,
          Mn,
          An,
          Cn,
          Sn,
          kn,
          In,
          Rn,
          Pn,
          Vn = function () {
        function t() {
          this.name = "sp.VertexEffectDelegate", this._vertexEffect = null, this._interpolation = null, this._effectType = void 0, this._vertexEffect = null, this._interpolation = null, this._effectType = "none";
        }

        var e = t.prototype;
        return e.clear = function () {
          this._vertexEffect = null, this._interpolation = null, this._effectType = "none";
        }, e.initJitter = function (t, e) {
          return this._effectType = "jitter", this._vertexEffect = new st.JitterEffect(t, e), this._vertexEffect;
        }, e.initSwirlWithPow = function (t, e) {
          return this._interpolation = new st.Pow(e), this._vertexEffect = new st.SwirlEffect(t, this._interpolation), this._vertexEffect;
        }, e.initSwirlWithPowOut = function (t, e) {
          return this._interpolation = new st.PowOut(e), this._vertexEffect = new st.SwirlEffect(t, this._interpolation), this._vertexEffect;
        }, e.getJitterVertexEffect = function () {
          return this._vertexEffect;
        }, e.getSwirlVertexEffect = function () {
          return this._vertexEffect;
        }, e.getVertexEffect = function () {
          return this._vertexEffect;
        }, e.getEffectType = function () {
          return this._effectType;
        }, t;
      }(),
          Dn = [0, 1, 2, 2, 3, 0],
          Nn = new P(0, 0, 255, 255),
          Fn = new P(255, 0, 0, 255),
          On = new P(0, 255, 0, 255),
          Ln = new P(255, 255, 0, 255),
          Un = new st.Color(1, 1, 1, 1),
          Bn = new st.Color(1, 1, 1, 1),
          Yn = new st.Vector2(),
          Xn = new st.Vector2(),
          Wn = new Float32Array(4),
          qn = new Float32Array(4),
          Hn = 0,
          jn = 0,
          zn = 0,
          Gn = 0,
          Zn = 0,
          Jn = 0,
          Qn = 0,
          Kn = 0,
          $n = null,
          ti = null,
          ei = null;

      function ni(t) {
        var e, n;

        switch (t) {
          case st.BlendMode.Additive:
            e = Qe ? y.ONE : y.SRC_ALPHA, n = y.ONE;
            break;

          case st.BlendMode.Multiply:
            e = y.DST_COLOR, n = y.ONE_MINUS_SRC_ALPHA;
            break;

          case st.BlendMode.Screen:
            e = y.ONE, n = y.ONE_MINUS_SRC_COLOR;
            break;

          case st.BlendMode.Normal:
          default:
            e = Qe ? y.ONE : y.SRC_ALPHA, n = y.ONE_MINUS_SRC_ALPHA;
        }

        return Sn.getMaterialForBlendAndTint(e, n, en ? je.TWO_COLORED : je.COLORED_TEXTURED);
      }

      function ii(t) {
        bn = t.fa * hn, vn = sn * (Ke = Qe ? bn / 255 : 1), yn = on * Ke, xn = ln * Ke, wn = t.fr * vn, _n = t.fg * yn, En = t.fb * xn, Wn[0] = wn / 255, Wn[1] = _n / 255, Wn[2] = En / 255, Wn[3] = bn / 255, Tn = t.dr * vn, Mn = t.dg * yn, An = t.db * xn, Cn = Qe ? 255 : 0, qn[0] = Tn / 255, qn[1] = Mn / 255, qn[2] = An / 255, qn[3] = Cn / 255;
      }

      var ri = new Float32Array(4);

      function ai(t) {
        return ri[0] = t.r / 255, ri[1] = t.g / 255, ri[2] = t.b / 255, ri[3] = t.a / 255, ri;
      }

      var si = null,
          oi = null,
          li = {
        vCount: 32767,
        ensureAccessor: function ensureAccessor(t) {
          var e = t ? oi : si;

          if (!e) {
            var n = X.root.device,
                i = X.root.batcher2D,
                r = t ? j : z;
            t ? (e = oi = new Z(n, r, this.vCount), i.registerBufferAccessor(Number.parseInt("SPINETINT", 36), oi)) : (e = si = new Z(n, r, this.vCount), i.registerBufferAccessor(Number.parseInt("SPINE", 36), si));
          }

          return e;
        },
        createData: function createData(t) {
          var e = t.renderData;

          if (!e) {
            for (var n = t.useTint || t.isAnimationCached(), i = this.ensureAccessor(n), r = t._skeleton.data.skins, a = 0, s = 0, o = 0; o < r.length; ++o) {
              for (var l = r[o].attachments, h = 0; h < l.length; h++) {
                var u = l[h];

                for (var c in u) {
                  var d = u[c];
                  d instanceof st.RegionAttachment ? (a += 4, s += 6) : d instanceof st.MeshAttachment && (a += d.worldVerticesLength >> 1, s += d.triangles.length);
                }
              }
            }

            (e = H.add(n ? j : z, i)).resize(a, s), e.indices && s === e.indices.length || (e.indices = new Uint16Array(s)), t.maxVertexCount = a, t.maxIndexCount = s;
          }

          return e;
        },
        updateRenderData: function updateRenderData(t) {
          Sn = t;
          var e = t._skeleton;
          !t.isAnimationCached() && e && e.updateWorldTransform(), e && function (t) {
            if (t._skeleton) {
              var e = t.color;
              sn = e.r / 255, on = e.g / 255, ln = e.b / 255, hn = t.node._uiProps.opacity, en = t.useTint || t.isAnimationCached(), un = en ? 13 : 9, t.drawList.reset(), Sn = t, t.node, kn = t.renderData, ti = null, gn = !0, Qe = t.premultipliedAlpha, Ke = 1, Pn = !1, $n = t._effectDelegate && t._effectDelegate._vertexEffect, (4294967295 !== e._val || Qe) && (Pn = !0), t.isAnimationCached() ? function () {
                var t = Sn._curFrame;

                if (t) {
                  var e = t.segments;

                  if (0 !== e.length) {
                    cn = 12, Gn = 0, Zn = 0, zn = 0, Jn = 0;
                    var n = null,
                        i = t.vertices,
                        r = t.indices,
                        a = 0,
                        s = 0,
                        o = 0,
                        l = 0,
                        h = t.colors,
                        u = 0,
                        c = h[u++],
                        d = c.vfOffset;
                    ii(c);

                    for (var f = 0, p = kn, m = p.chunk.vb, g = p.indices, v = 0, y = e.length; v < y; v++) {
                      var x = e[v];

                      if (n = ni(x.blendMode)) {
                        if (ti || (ti = n), gn || n.hash !== ti.hash || x.tex && x.tex !== ei) {
                          gn = !1;
                          var w = Jn - f;
                          w > 0 && (Sn._requestDrawData(ti, ei, f, w), f = Jn), ti = n, ei = x.tex;
                        }

                        jn = x.vertexCount, Zn = x.indexCount, a = p.chunk.vertexOffset;

                        for (var _ = Jn, E = Jn + Zn; _ < E; _++) {
                          g[_] = a + zn + r[o++];
                        }

                        if (l = x.vfCount, m.set(i.subarray(s, s + l), s), Pn) for (var b = s / 13 * 6, T = s, M = s + l; T < M; T += un, b += 6) {
                          b >= d && (ii(c = h[u++]), d = c.vfOffset), m.set(Wn, T + 5), m.set(qn, T + 9);
                        }
                        s += l, zn += jn, Jn += Zn, jn = 0, Zn = 0;
                      }
                    }

                    var A = Jn - f;
                    ei && A > 0 && Sn._requestDrawData(ti, ei, f, A);
                  }
                }
              }() : ($n && $n.begin(t._skeleton), function () {
                var t = kn;
                Rn = t.chunk.vb, In = t.indices, Qn = Sn.maxVertexCount, Kn = Sn.maxIndexCount;
                var e,
                    n,
                    i,
                    r,
                    a,
                    s,
                    o = Sn._skeleton,
                    l = o.color,
                    h = Sn._debugRenderer,
                    u = Sn._clipper,
                    c = null;
                $e = Sn._startSlotIndex, tn = Sn._endSlotIndex, mn = !1, -1 === $e && (mn = !0), nn = Sn.debugSlots, rn = Sn.debugBones, an = Sn.debugMesh, h && (rn || nn || an) && (h.clear(), h.lineWidth = 5), cn = 12, Hn = 0, zn = 0, Gn = 0, Zn = 0, Jn = 0;

                for (var d = 0, f = 0, p = o.drawOrder.length; f < p; f++) {
                  if (void 0 !== (s = o.drawOrder[f]) && s.bone.active) if ($e >= 0 && $e === s.data.index && (mn = !0), mn) {
                    if (tn >= 0 && tn === s.data.index && (mn = !1), Hn = 0, Zn = 0, e = s.getAttachment()) {
                      if (r = e instanceof st.RegionAttachment, a = e instanceof st.MeshAttachment, e instanceof st.ClippingAttachment) u.clipStart(s, e);else if (r || a) {
                        var m = e.region.texture.getRealTexture();

                        if (c = ni(s.data.blendMode)) {
                          if (ti || (ti = c), gn || c.hash !== ti.hash || m && ei !== m) {
                            gn = !1;
                            var g = Jn - d;
                            g > 0 && (Sn._requestDrawData(ti, ei, d, g), d = Jn), ei = m, ti = c;
                          }

                          if (r) {
                            if (i = Dn, Hn = (jn = 4) * un, Zn = 6, e.computeWorldVertices(s.bone, Rn, Gn, un), h && nn) {
                              h.strokeColor = Nn, h.moveTo(Rn[Gn], Rn[Gn + 1]);

                              for (var v = Gn + un, y = Gn + Hn; v < y; v += un) {
                                h.lineTo(Rn[v], Rn[v + 1]);
                              }

                              h.close(), h.stroke();
                            }
                          } else if (a) {
                            var x = e;

                            if (i = x.triangles, jn = x.worldVerticesLength >> 1, Hn = jn * un, Zn = i.length, x.computeWorldVertices(s, 0, x.worldVerticesLength, Rn, Gn, un), h && an) {
                              h.strokeColor = Ln;

                              for (var w = 0, _ = i.length; w < _; w += 3) {
                                var E = i[w] * un + Gn,
                                    b = i[w + 1] * un + Gn,
                                    T = i[w + 2] * un + Gn;
                                h.moveTo(Rn[E], Rn[E + 1]), h.lineTo(Rn[b], Rn[b + 1]), h.lineTo(Rn[T], Rn[T + 1]), h.close(), h.stroke();
                              }
                            }
                          }

                          if (0 !== Hn && 0 !== Zn) {
                            var M = e;
                            (In = t.indices).set(i, Jn), n = M.uvs;

                            for (var A = Gn, C = Gn + Hn, S = 0; A < C; A += un, S += 2) {
                              Rn[A + 3] = n[S], Rn[A + 4] = n[S + 1];
                            }

                            if (hi(l, M.color, s.color, u, s), Zn > 0) for (var k = t.chunk.vertexOffset, I = Jn, R = Jn + Zn; I < R; I++) {
                              In[I] += zn + k;
                            }
                            Gn += Hn, zn += jn, Jn += Zn, jn = 0, Zn = 0, u.clipEndWithSlot(s);
                          } else u.clipEndWithSlot(s);
                        } else u.clipEndWithSlot(s);
                      } else u.clipEndWithSlot(s);
                    } else u.clipEndWithSlot(s);
                  } else u.clipEndWithSlot(s);
                }

                var P = Jn - d;

                if (ei && P > 0 && Sn._requestDrawData(ti, ei, d, P), u.clipEnd(), h && rn) {
                  var V;
                  h.strokeColor = Fn, h.fillColor = Nn;

                  for (var D = 0, N = o.bones.length; D < N; D++) {
                    var F = (V = o.bones[D]).data.length * V.a + V.worldX,
                        O = V.data.length * V.c + V.worldY;
                    h.moveTo(V.worldX, V.worldY), h.lineTo(F, O), h.stroke(), h.circle(V.worldX, V.worldY, 1.5 * Math.PI), h.fill(), 0 === D && (h.fillColor = On);
                  }
                }
              }(), $n && $n.end()), (en ? oi : si).getMeshBuffer(kn.chunk.bufferId).setDirty(), t.attachUtil._syncAttachedNode(), Sn = void 0, $n = null;
            }
          }(t);
        },
        updateColor: function updateColor(t) {
          t && (Sn = t).markForUpdateRenderData();
        },
        fillBuffers: function fillBuffers() {}
      };

      function hi(t, e, n, i, r) {
        if (Un.a = n.a * e.a * t.a * hn * 255, Ke = Qe ? Un.a : 255, dn = sn * e.r * t.r * Ke, fn = on * e.g * t.g * Ke, pn = ln * e.b * t.b * Ke, Un.r = dn * n.r, Un.g = fn * n.g, Un.b = pn * n.b, null == r.darkColor ? Bn.set(0, 0, 0, 1) : (Bn.r = r.darkColor.r * dn, Bn.g = r.darkColor.g * fn, Bn.b = r.darkColor.b * pn), Bn.a = Qe ? 255 : 0, i.isClipping()) {
          cn = en ? 12 : 8;
          var a = Rn.subarray(Gn),
              s = Rn.subarray(Gn + 3);
          i.clipTriangles(a, Hn, In.subarray(Jn), Zn, s, Un, Bn, en, un);
          var o = i.clippedVertices,
              l = i.clippedTriangles;
          if (function (t, e) {
            var n = jn,
                i = Zn,
                r = kn;
            Zn = e.length, jn = t.length / cn, Hn = jn * un, Qn += jn - n, Kn += Zn - i;
            var a = In,
                s = r.chunk.vertexOffset,
                o = !1;
            if (Qn > r.vertexCount && (r.resizeAndCopy(Qn, Kn > r.indexCount ? Kn : r.indexCount), Rn = r.chunk.vb, o = !0), Kn > In.length && (In = r.indices = new Uint16Array(Kn), o = !0), o) for (var l = r.chunk.vertexOffset - s, h = 0; h < Jn; ++h) {
              In[h] = a[h] + l;
            }
          }(o, l), l.length > 0 && In.set(l, Jn), $n) for (var h = 0, u = o.length, c = Gn; h < u; h += cn, c += un) {
            Yn.x = o[h], Yn.y = o[h + 1], Un.set(o[h + 2], o[h + 3], o[h + 4], o[h + 5]), Xn.x = o[h + 6], Xn.y = o[h + 7], en ? Bn.set(o[h + 8], o[h + 9], o[h + 10], o[h + 11]) : Bn.set(0, 0, 0, 0), $n.transform(Yn, Xn, Un, Bn), Rn[c] = Yn.x, Rn[c + 1] = Yn.y, Rn[c + 3] = Xn.x, Rn[c + 4] = Xn.y, Rn.set(ai(Un), c + 5), en && Rn.set(ai(Bn), c + 9);
          } else for (var d = 0, f = o.length, p = Gn; d < f; d += cn, p += un) {
            Rn[p] = o[d], Rn[p + 1] = o[d + 1], Rn[p + 3] = o[d + 6], Rn[p + 4] = o[d + 7], Rn[p + 5] = o[d + 2] / 255, Rn[p + 6] = o[d + 3] / 255, Rn[p + 7] = o[d + 4] / 255, Rn[p + 8] = o[d + 5] / 255, en && (Rn[p + 9] = o[d + 8] / 255, Rn[p + 10] = o[d + 9] / 255, Rn[p + 11] = o[d + 10] / 255, Rn[p + 12] = o[d + 11] / 255);
          }
        } else if ($n) for (var m = Gn, g = Gn + Hn; m < g; m += un) {
          Yn.x = Rn[m], Yn.y = Rn[m + 1], Xn.x = Rn[m + 3], Xn.y = Rn[m + 4], $n.transform(Yn, Xn, Un, Bn), Rn[m] = Yn.x, Rn[m + 1] = Yn.y, Rn[m + 3] = Xn.x, Rn[m + 4] = Xn.y, Rn.set(ai(Un), m + 5), en && Rn.set(ai(Bn), m + 9);
        } else {
          Wn.set(ai(Un)), qn.set(ai(Bn));

          for (var v = Gn, y = Gn + Hn; v < y; v += un) {
            Rn.set(Wn, v + 5), en && Rn.set(qn, v + 9);
          }
        }
      }

      o.internal.SpineAssembler = li;
      var ui,
          ci,
          di = {
        getAssembler: function getAssembler() {
          return li;
        }
      };
      Je.Assembler = di, Y(Je.prototype, "Skeleton", [{
        name: "enableBatch",
        suggest: "Not support batch render mode"
      }]), function (t) {
        t[t.REGION = 0] = "REGION", t[t.BOUNDING_BOX = 1] = "BOUNDING_BOX", t[t.MESH = 2] = "MESH", t[t.SKINNED_MESH = 3] = "SKINNED_MESH";
      }(ui || (ui = {})), u(ui), function (t) {
        t[t.START = 0] = "START", t[t.INTERRUPT = 1] = "INTERRUPT", t[t.END = 2] = "END", t[t.DISPOSE = 3] = "DISPOSE", t[t.COMPLETE = 4] = "COMPLETE", t[t.EVENT = 5] = "EVENT";
      }(ci || (ci = {})), u(ci), t("sp", Object.freeze({
        __proto__: null,
        spine: st,

        get ATTACHMENT_TYPE() {
          return ui;
        },

        get AnimationEventType() {
          return ci;
        },

        timeScale: 1,

        get DefaultSkinsEnum() {
          return We;
        },

        get DefaultAnimsEnum() {
          return qe;
        },

        get AnimationCacheMode() {
          return He;
        },

        get SpineMaterialType() {
          return je;
        },

        SpineSocket: Ze,
        Skeleton: Je,
        SkeletonData: Ht,
        SkeletonTexture: Xt,
        convertFilter: Wt,
        convertWraps: qt,
        VertexEffectDelegate: Vn,
        simpleSpineAssembler: di
      }));
    }
  };
}); 
 			}); 
		define("__plugin__/wx0446ba2621dda60a/sprite-827770a8.js", function(require, module, exports){ 			
"use strict";

System.register(["./texture-barrier-60b5983b.js", "./json-asset-933a1d4c.js", "./index-f2b92470.js", "./deprecated-ef6bb945.js", "./sprite-frame-1edab3eb.js", "./renderable-2d-e2838949.js"], function (t) {
  "use strict";

  var e, i, r, n, a, s, o, l, h, u, p, c, f, _, y, d, g, m, D, b, v, F, A, T, x, w, S, E, R, O, z, M, P, I, C, L, U, k, H, N, V, j, B, G, W, X;

  return {
    setters: [function (t) {
      e = t.bT, i = t.cs, r = t.ci, n = t.c0, a = t.l, s = t.c1, o = t.b$, l = t.bU, h = t.w, u = t.ct, p = t.cf, c = t.bQ, f = t.d, _ = t.af, y = t.bw, d = t.cp;
    }, function (t) {
      g = t.bW, m = t.aL, D = t.bX, b = t.b$, v = t.dz, F = t.dN, A = t.e, T = t.bZ, x = t.a5, w = t.c_, S = t.aT, E = t.aS, R = t.dA, O = t.dO, z = t.cg, M = t.ds, P = t.ch, I = t.bY, C = t.cc, L = t.ci, U = t.aX, k = t.aW, H = t.dj, N = t.aa, V = t.V;
    }, function () {}, function (t) {
      j = t.d, B = t.D;
    }, function (t) {
      G = t.S;
    }, function (t) {
      W = t.I, X = t.R;
    }],
    execute: function execute() {
      var Y, Z, $, K;
      t({
        H: void 0,
        O: void 0,
        V: void 0,
        b: void 0,
        e: function e(t) {
          var e = t.charCodeAt(0);
          return e >= 9 && e <= 13 || 32 === e || 133 === e || 160 === e || 5760 === e || e >= 8192 && e <= 8202 || 8232 === e || 8233 === e || 8239 === e || 8287 === e || 12288 === e;
        },
        f: function f(t) {
          return Et.test(t);
        },
        g: function g() {
          return 0;
        },
        h: function h(t) {
          return St.test(t);
        },
        i: function i(t) {
          return /^[\u4E00-\u9FFF\u3400-\u4DFF]+$/.test(t) || /[\u3000-\u303F]|[\u3040-\u309F]|[\u30A0-\u30FF]|[\uFF00-\uFFEF]|[\u4E00-\u9FAF]|[\u2605-\u2606]|[\u2190-\u2195]|\u203B/g.test(t) || /^[\u1100-\u11FF]|[\u3130-\u318F]|[\uA960-\uA97F]|[\uAC00-\uD7AF]|[\uD7B0-\uD7FF]+$/.test(t);
        },
        j: function j(t) {
          return Et.exec(t);
        },
        k: function k(t) {
          return St.exec(t);
        },
        l: function l(t, e, i, r) {
          var n = [];
          if (0 === t.length || i < 0) return n.push(""), n;

          for (var a = t; e > i && a.length > 1;) {
            for (var s = a.length * (i / e) | 0, o = Ot(a, s), l = e - r(o), h = o, u = 0, p = 0; l > i && p++ < 100;) {
              s *= i / l, l = e - r(o = Ot(a, s |= 0));
            }

            for (p = 0; o && l <= i && p++ < 100;) {
              var c = Tt.exec(o);
              h = o, l = e - r(o = Ot(a, s += u = c ? c[0].length : 1));
            }

            0 == (s -= u) ? (s = 1, h = Ot(a, 1)) : 1 === s && a[0] >= "\uD800" && a[0] <= "\uDBFF" && (s = 2, h = Ot(a, 2));

            var f = Ot(a, 0, s),
                _ = void 0;

            xt.test(h || o) && (0 == (s -= (_ = wt.exec(f)) ? _[0].length : 0) && (s = 1), h = Ot(a, s), f = Ot(a, 0, s)), Et.test(h) && (_ = St.exec(f)) && f !== _[0] && (h = Ot(a, s -= _[0].length), f = Ot(a, 0, s)), (0 === n.length || (f = f.trim()).length > 0) && n.push(f), e = r(a = h || o);
          }

          return (0 === n.length || (a = a.trim()).length > 0) && n.push(a), n;
        },
        o: function o(t) {
          var e = t.color.toHEX(),
              i = "";
          return t.isOutlined && t.margin > 0 && (i = i + t.margin + t.out.toHEX()), "" + t.fontSize + t.fontFamily + e + i;
        },
        s: Rt
      });
      var J,
          Q = t("S", g("cc.SpriteAtlas")((K = function (t) {
        function n() {
          for (var e, i = arguments.length, r = new Array(i), n = 0; n < i; n++) {
            r[n] = arguments[n];
          }

          return e = t.call.apply(t, [this].concat(r)) || this, s(e, "spriteFrames", $, o(e)), e;
        }

        e(n, t);
        var a = n.prototype;
        return a.getTexture = function () {
          var t = Object.keys(this.spriteFrames);

          if (t.length > 0) {
            var e = this.spriteFrames[t[0]];
            return e && e.texture;
          }

          return null;
        }, a.getSpriteFrame = function (t) {
          var e = this.spriteFrames[t];
          return e ? (e.name || (e.name = t), e) : null;
        }, a.getSpriteFrames = function () {
          for (var t = [], e = this.spriteFrames, i = 0, r = Object.keys(e); i < r.length; i++) {
            var n = r[i];
            t.push(e[n]);
          }

          return t;
        }, a._serialize = function () {}, a._deserialize = function (t, e) {
          var n = t;
          this._name = n.name;
          var a = n.spriteFrames;
          this.spriteFrames = i();

          for (var s = 0; s < a.length; s += 2) {
            e.result.push(this.spriteFrames, a[s], a[s + 1], r(G));
          }
        }, n;
      }(m), $ = n((Z = K).prototype, "spriteFrames", [D, b], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return i();
        }
      }), Y = Z)) || Y);
      a.SpriteAtlas = Q;
      var q,
          tt,
          et,
          it,
          rt = t("F", g("cc.Font")(J = function (t) {
        function i() {
          return t.apply(this, arguments) || this;
        }

        return e(i, t), i;
      }(m)) || J);
      a.Font = rt;
      var nt,
          at,
          st,
          ot,
          lt,
          ht,
          ut,
          pt,
          ct,
          ft = t("T", g("cc.TTFFont")((it = function (t) {
        function i() {
          for (var e, i = arguments.length, r = new Array(i), n = 0; n < i; n++) {
            r[n] = arguments[n];
          }

          return e = t.call.apply(t, [this].concat(r)) || this, s(e, "_fontFamily", et, o(e)), e;
        }

        return e(i, t), i.prototype.initDefault = function (e) {
          this._fontFamily = "Arial", t.prototype.initDefault.call(this, e);
        }, l(i, [{
          key: "_nativeAsset",
          get: function get() {
            return this._fontFamily;
          },
          set: function set(t) {
            this._fontFamily = t || "Arial";
          }
        }, {
          key: "_nativeDep",
          get: function get() {
            return {
              uuid: this._uuid,
              __nativeName__: this._native,
              ext: A(this._native),
              __isNative__: !0
            };
          }
        }]), i;
      }(rt), et = n((tt = it).prototype, "_fontFamily", [D], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return null;
        }
      }), n(tt.prototype, "_nativeAsset", [v, F], Object.getOwnPropertyDescriptor(tt.prototype, "_nativeAsset"), tt.prototype), n(tt.prototype, "_nativeDep", [v], Object.getOwnPropertyDescriptor(tt.prototype, "_nativeDep"), tt.prototype), q = tt)) || q);
      a.TTFFont = ft;

      var _t,
          yt = function yt() {
        this.u = 0, this.v = 0, this.w = 0, this.h = 0, this.offsetX = 0, this.offsetY = 0, this.textureID = 0, this.valid = !1, this.xAdvance = 0;
      },
          dt = function () {
        function t(t) {
          this.letterDefinitions = {}, this.texture = t;
        }

        var e = t.prototype;
        return e.addLetterDefinitions = function (t, e) {
          this.letterDefinitions[t] = e;
        }, e.cloneLetterDefinition = function () {
          for (var t = {}, e = 0, i = Object.keys(this.letterDefinitions); e < i.length; e++) {
            var r = i[e],
                n = new yt();
            u(n, this.letterDefinitions[r]), t[r] = n;
          }

          return t;
        }, e.getTexture = function () {
          return this.texture;
        }, e.getLetter = function (t) {
          return this.letterDefinitions[t];
        }, e.getLetterDefinitionForChar = function (t) {
          var e = t.charCodeAt(0);
          return this.letterDefinitions.hasOwnProperty(e) ? this.letterDefinitions[e] : null;
        }, e.clear = function () {
          this.letterDefinitions = {};
        }, t;
      }(),
          gt = t("B", (nt = g("cc.BitmapFont"), at = T(G), nt((ct = function (t) {
        function i() {
          for (var e, i = arguments.length, r = new Array(i), n = 0; n < i; n++) {
            r[n] = arguments[n];
          }

          return e = t.call.apply(t, [this].concat(r)) || this, s(e, "fntDataStr", lt, o(e)), s(e, "spriteFrame", ht, o(e)), s(e, "fontSize", ut, o(e)), s(e, "fntConfig", pt, o(e)), e;
        }

        return e(i, t), i.prototype.onLoaded = function () {
          var t = this.spriteFrame;
          !this.fontDefDictionary && t && (this.fontDefDictionary = new dt(t.texture));
          var e = this.fntConfig;

          if (e) {
            var i = e.fontDefDictionary;

            for (var r in i) {
              var n = new yt(),
                  a = i[r].rect;
              n.offsetX = i[r].xOffset, n.offsetY = i[r].yOffset, n.w = a.width, n.h = a.height, n.u = a.x, n.v = a.y, n.textureID = 0, n.valid = !0, n.xAdvance = i[r].xAdvance, this.fontDefDictionary.addLetterDefinitions(r, n);
            }
          } else h("The fnt config is not exists!");
        }, i;
      }(rt), lt = n((ot = ct).prototype, "fntDataStr", [D, b], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return "";
        }
      }), ht = n(ot.prototype, "spriteFrame", [at], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return null;
        }
      }), ut = n(ot.prototype, "fontSize", [D, b], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return -1;
        }
      }), pt = n(ot.prototype, "fntConfig", [D, b], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return null;
        }
      }), st = ot)) || st));

      a.BitmapFont = gt;
      var mt = t("L", g("cc.LabelAtlas")(_t = function (t) {
        function i() {
          return t.apply(this, arguments) || this;
        }

        return e(i, t), i;
      }(gt)) || _t);
      a.LabelAtlas = mt;
      var Dt = t("d", .26),
          bt = t("M", (Dt + 1) / 2 - Dt);
      var vt = new p(2);

      vt.get = function () {
        return this._get() || {
          key: "",
          value: 0,
          prev: null,
          next: null
        };
      };

      var Ft,
          At = new (function () {
        function t(t) {
          this.count = 0, this.limit = 0, this.datas = {}, this.limit = t;
        }

        var e = t.prototype;
        return e.moveToHead = function (t) {
          t.next = this.head, t.prev = null, this.head && (this.head.prev = t), this.head = t, this.tail || (this.tail = t), this.count++, this.datas[t.key] = t;
        }, e.put = function (t, e) {
          var i = vt.get();

          if (i.key = t, i.value = e, this.count >= this.limit) {
            var r = this.tail;
            delete this.datas[r.key], this.count--, this.tail = r.prev, this.tail.next = null, r.prev = null, r.next = null, vt.put(r);
          }

          this.moveToHead(i);
        }, e.remove = function (t) {
          t.prev ? t.prev.next = t.next : this.head = t.next, t.next ? t.next.prev = t.prev : this.tail = t.prev, delete this.datas[t.key], this.count--;
        }, e.get = function (t) {
          var e = this.datas[t];
          return e ? (this.remove(e), this.moveToHead(e), e.value) : null;
        }, e.clear = function () {
          this.count = 0, this.datas = {}, this.head = null, this.tail = null;
        }, e.has = function (t) {
          return !!this.datas[t];
        }, e.delete = function (t) {
          var e = this.datas[t];
          this.remove(e);
        }, t;
      }())(100),
          Tt = /([a-zA-Z0-9--]+|\S)/,
          xt = /^[!,.:;'}\]%\?>]/,
          wt = /([a-zA-Z0-9--iI]+|\S)$/,
          St = /[a-zA-Z0-9--iI]+$/,
          Et = /^[a-zA-Z0-9--iI]/;

      function Rt(t, e, i) {
        var r = (i || t.font) + "" + e,
            n = At.get(r);
        if (null !== n) return n;
        var a = t.measureText(e),
            s = a && a.width || 0;
        return At.put(r, s), s;
      }

      function Ot(t, e, i) {
        var r = e,
            n = i,
            a = t[e];
        if (a >= "\uDC00" && a <= "\uDFFF" && r--, void 0 !== i) if (i - 1 !== e) {
          var s = t[i - 1];
          s >= "\uD800" && s <= "\uDBFF" && n--;
        } else a >= "\uD800" && a <= "\uDBFF" && n++;
        return t.substring(r, n);
      }

      var zt,
          Mt,
          Pt,
          It,
          Ct,
          Lt,
          Ut,
          kt,
          Ht,
          Nt,
          Vt,
          jt,
          Bt,
          Gt,
          Wt,
          Xt,
          Yt,
          Zt,
          $t,
          Kt,
          Jt,
          Qt,
          qt,
          te,
          ee,
          ie,
          re,
          ne,
          ae,
          se,
          oe,
          le,
          he,
          ue,
          pe,
          ce,
          fe,
          _e,
          ye,
          de,
          ge,
          me,
          De,
          be,
          ve,
          Fe,
          Ae,
          Te,
          xe,
          we,
          Se,
          Ee,
          Re,
          Oe,
          ze,
          Me,
          Pe,
          Ie,
          Ce,
          Le,
          Ue,
          ke,
          He,
          Ne,
          Ve,
          je,
          Be,
          Ge,
          We,
          Xe,
          Ye = t("C", function () {
        function t() {
          this.pool = [];
        }

        t.getInstance = function () {
          return Ft || (Ft = new t()), Ft;
        };

        var e = t.prototype;
        return e.get = function () {
          var t = this.pool.pop();

          if (!t) {
            var e = document.createElement("canvas"),
                i = e.getContext("2d");
            t = {
              canvas: e,
              context: i
            };
          }

          return t;
        }, e.put = function (t) {
          this.pool.length >= c.MAX_LABEL_CANVAS_POOL_SIZE || this.pool.push(t);
        }, t;
      }()),
          Ze = x.WHITE.clone(),
          $e = function $e() {
        this.u = 0, this.v = 0, this.w = 0, this.h = 0, this.texture = null, this.offsetX = 0, this.offsetY = 0, this.valid = !1, this.xAdvance = 0;
      },
          Ke = "rgba(255, 255, 255, " + (1 / 255).toFixed(3) + ")",
          Je = function () {
        function t(t, e) {
          this.image = null, this.labelInfo = void 0, this.char = void 0, this.data = null, this.canvas = null, this.context = null, this.width = 0, this.height = 0, this.offsetY = 0, this.hash = void 0, this.char = t, this.labelInfo = e, this.hash = t.charCodeAt(0) + e.hash;
        }

        var e = t.prototype;
        return e.updateRenderData = function () {
          this._updateProperties(), this._updateTexture();
        }, e.destroy = function () {
          this.image = null;
        }, e._updateProperties = function () {
          if (this.data = Ye.getInstance().get(), this.canvas = this.data.canvas, this.context = this.data.context, this.context) {
            this.context.font = this.labelInfo.fontDesc;
            var t = Rt(this.context, this.char, this.labelInfo.fontDesc),
                e = 2 * this.labelInfo.margin + 2;
            this.width = parseFloat(t.toFixed(2)) + e, this.height = (1 + Dt) * this.labelInfo.fontSize + e, this.offsetY = -this.labelInfo.fontSize * Dt / 2;
          }

          this.canvas.width !== this.width && (this.canvas.width = this.width), this.canvas.height !== this.height && (this.canvas.height = this.height), this.image || (this.image = new E()), this.image.reset(this.canvas);
        }, e._updateTexture = function () {
          if (this.context && this.canvas) {
            var t = this.context,
                e = this.labelInfo,
                i = this.canvas.width,
                r = this.canvas.height;
            t.textAlign = "center", t.textBaseline = "alphabetic", t.clearRect(0, 0, i, r), t.fillStyle = Ke, t.fillRect(0, 0, i, r), t.font = e.fontDesc;
            var n = e.fontSize,
                a = i / 2,
                s = r / 2 + n * bt + 0 * n,
                o = e.color;

            if (t.lineJoin = "round", t.fillStyle = "rgba(" + o.r + ", " + o.g + ", " + o.b + ", 1)", e.isOutlined) {
              var l = e.out || Ze;
              t.strokeStyle = "rgba(" + l.r + ", " + l.g + ", " + l.b + ", " + l.a / 255 + ")", t.lineWidth = 2 * e.margin, t.strokeText(this.char, a, s);
            }

            t.fillText(this.char, a, s);
          }
        }, t;
      }(),
          Qe = function (t) {
        function i() {
          return t.apply(this, arguments) || this;
        }

        e(i, t);
        var r = i.prototype;
        return r.initWithSize = function (t, e, i) {
          void 0 === i && (i = w.RGBA8888), this.reset({
            width: t,
            height: e,
            format: i
          });
        }, r.drawTextureAt = function (t, e, i) {
          var r = this.getGFXTexture();

          if (t && r) {
            var n = this._getGFXDevice();

            if (n) {
              var a = new _();
              a.texOffset.x = e, a.texOffset.y = i, a.texExtent.width = t.width, a.texExtent.height = t.height, n.copyTexImagesToTexture([t.data], r, [a]);
            } else console.warn("Unable to get device");
          }
        }, i;
      }(S);

      t("n", function () {
        function t(t, e) {
          this._x = 0, this._y = 0, this._nextY = 0, this._width = 0, this._height = 0, this._halfBleed = 0, this._dirty = !1;
          var i = new Qe();
          i.initWithSize(t, e), this.fontDefDictionary = new dt(i), this._halfBleed = 1, this._width = t, this._height = e, j.on(B.EVENT_BEFORE_SCENE_LAUNCH, this.beforeSceneLoad, this);
        }

        var e = t.prototype;
        return e.insertLetterTexture = function (t) {
          var e = t.image,
              i = j.root.device;
          if (!e || !this.fontDefDictionary || !i) return null;
          var r = e.width,
              n = e.height;
          if (this._x + r + 0 > this._width && (this._x = 0, this._y = this._nextY), this._y + n > this._nextY && (this._nextY = this._y + n + 0), this._nextY > this._height) return f(12100), null;
          this.fontDefDictionary.texture.drawTextureAt(e, this._x, this._y), this._dirty = !0;
          var a = new $e();
          return a.u = this._x + this._halfBleed, a.v = this._y + this._halfBleed, a.texture = this.fontDefDictionary.texture, a.valid = !0, a.w = t.width - 2, a.h = t.height - 2, a.xAdvance = a.w, a.offsetY = t.offsetY, this._x += r + 0, this.fontDefDictionary.addLetterDefinitions(t.hash, a), a;
        }, e.update = function () {
          this._dirty && (this._dirty = !1);
        }, e.reset = function () {
          this._x = 0, this._y = 0, this._nextY = 0, this.fontDefDictionary.clear();
        }, e.destroy = function () {
          this.reset(), this.fontDefDictionary && (this.fontDefDictionary.texture.destroy(), this.fontDefDictionary.texture = null);
        }, e.getTexture = function () {
          return this.fontDefDictionary.getTexture();
        }, e.beforeSceneLoad = function () {
          this.clearAllCache();
        }, e.clearAllCache = function () {
          this.destroy();
          var t = new Qe();
          t.initWithSize(this._width, this._height), this.fontDefDictionary.texture = t;
        }, e.getLetter = function (t) {
          return this.fontDefDictionary.letterDefinitions[t];
        }, e.getLetterDefinitionForChar = function (t, e) {
          var i = t.charCodeAt(0) + e.hash,
              r = this.fontDefDictionary.letterDefinitions[i];

          if (!r) {
            var n = new Je(t, e);
            n.updateRenderData(), r = this.insertLetterTexture(n), n.destroy();
          }

          return r;
        }, l(t, [{
          key: "width",
          get: function get() {
            return this._width;
          }
        }, {
          key: "height",
          get: function get() {
            return this._height;
          }
        }]), t;
      }()), t("m", {
        fontAtlas: null,
        fontSize: 0,
        lineHeight: 0,
        hAlign: 0,
        vAlign: 0,
        hash: "",
        fontFamily: "",
        fontDesc: "Arial",
        color: x.WHITE.clone(),
        isOutlined: !1,
        out: x.WHITE.clone(),
        margin: 0
      }), function (t) {
        t[t.LEFT = 0] = "LEFT", t[t.CENTER = 1] = "CENTER", t[t.RIGHT = 2] = "RIGHT";
      }(Be || (Be = t("H", {}))), y(Be), function (t) {
        t[t.TOP = 0] = "TOP", t[t.CENTER = 1] = "CENTER", t[t.BOTTOM = 2] = "BOTTOM";
      }(Ge || (Ge = t("V", {}))), y(Ge), function (t) {
        t[t.NONE = 0] = "NONE", t[t.CLAMP = 1] = "CLAMP", t[t.SHRINK = 2] = "SHRINK", t[t.RESIZE_HEIGHT = 3] = "RESIZE_HEIGHT";
      }(We || (We = t("O", {}))), y(We), function (t) {
        t[t.NONE = 0] = "NONE", t[t.BITMAP = 1] = "BITMAP", t[t.CHAR = 2] = "CHAR";
      }(Xe || (Xe = t("b", {}))), y(Xe);

      var qe,
          ti,
          ei,
          ii,
          ri,
          ni,
          ai,
          si,
          oi,
          li,
          hi,
          ui,
          pi,
          ci,
          fi,
          _i,
          yi,
          di,
          gi,
          mi,
          Di,
          bi,
          vi,
          Fi,
          Ai,
          Ti,
          xi,
          wi,
          Si,
          Ei,
          Ri,
          Oi,
          zi,
          Mi,
          Pi,
          Ii,
          Ci,
          Li,
          Ui,
          ki,
          Hi,
          Ni,
          Vi,
          ji,
          Bi,
          Gi,
          Wi,
          Xi,
          Yi,
          Zi,
          $i = t("c", (zt = g("cc.Label"), Mt = z(), Pt = M(110), It = P(), Ct = I(), Lt = C(), Ut = T(Be), kt = I(), Ht = C(), Nt = T(Ge), Vt = I(), jt = C(), Bt = I(), Gt = C(), Wt = I(), Xt = L(), Yt = C(), Zt = I(), $t = C(), Kt = L(), Jt = I(), Qt = C(), qt = T(We), te = I(), ee = C(), ie = I(), re = C(), ne = T(rt), ae = I(), se = L(), oe = C(), le = I(), he = C(), ue = T(Xe), pe = I(), ce = C(), fe = I(), _e = C(), ye = I(), de = C(), ge = I(), me = C(), De = L(), be = I(), ve = C(), zt(Fe = Mt(Fe = Pt(Fe = It((je = Ve = function (t) {
        function i() {
          var e;
          return e = t.call(this) || this, s(e, "_string", Te, o(e)), s(e, "_horizontalAlign", xe, o(e)), s(e, "_verticalAlign", we, o(e)), s(e, "_actualFontSize", Se, o(e)), s(e, "_fontSize", Ee, o(e)), s(e, "_fontFamily", Re, o(e)), s(e, "_lineHeight", Oe, o(e)), s(e, "_overflow", ze, o(e)), s(e, "_enableWrapText", Me, o(e)), s(e, "_font", Pe, o(e)), s(e, "_isSystemFontUsed", Ie, o(e)), s(e, "_spacingX", Ce, o(e)), s(e, "_isItalic", Le, o(e)), s(e, "_isBold", Ue, o(e)), s(e, "_isUnderline", ke, o(e)), s(e, "_underlineHeight", He, o(e)), s(e, "_cacheMode", Ne, o(e)), e._N$file = null, e._texture = null, e._ttfSpriteFrame = null, e._userDefinedFont = null, e._assemblerData = null, e._fontAtlas = null, e._letterTexture = null, e._ttfSpriteFrame = null, e;
        }

        e(i, t);
        var r = i.prototype;
        return r.onEnable = function () {
          t.prototype.onEnable.call(this), this._font || this._isSystemFontUsed || (this.useSystemFont = !0), this._isSystemFontUsed && !this._fontFamily && (this.fontFamily = "Arial"), this._applyFontTexture();
        }, r.onDestroy = function () {
          if (this._assembler && this._assembler.resetAssemblerData && this._assembler.resetAssemblerData(this._assemblerData), this._assemblerData = null, this._ttfSpriteFrame) {
            this._ttfSpriteFrame._resetDynamicAtlasFrame();

            var e = this._ttfSpriteFrame.texture;

            if (this._ttfSpriteFrame.destroy(), e) {
              var i = e;
              i.image && i.image.destroy(), e.destroy();
            }

            this._ttfSpriteFrame = null;
          }

          this._letterTexture = null, t.prototype.onDestroy.call(this);
        }, r.updateRenderData = function (t) {
          void 0 === t && (t = !1), this.markForUpdateRenderData(), t && (this._flushAssembler(), this.renderData && (this.renderData.vertDirty = !0), this._applyFontTexture(), this._assembler && this._assembler.updateRenderData(this));
        }, r._render = function (t) {
          t.commitComp(this, this.renderData, this._texture, this._assembler, null);
        }, r._updateColor = function () {
          t.prototype._updateColor.call(this), this.updateRenderData(!1);
        }, r._canRender = function () {
          if (!t.prototype._canRender.call(this) || !this._string) return !1;
          var e = this._font;

          if (e && e instanceof gt) {
            var i = e.spriteFrame;
            if (!i || !i.texture) return !1;
          }

          return !0;
        }, r._flushAssembler = function () {
          var t = i.Assembler.getAssembler(this);
          this._assembler !== t && (this.destroyRenderData(), this._assembler = t), this._renderData || this._assembler && this._assembler.createData && (this._renderData = this._assembler.createData(this), this._renderData.material = this.material);
        }, r._applyFontTexture = function () {
          this.markForUpdateRenderData();
          var t = this._font;

          if (t instanceof gt) {
            var e = t.spriteFrame;
            e && e.texture && (this._texture = e, this.renderData && (this.renderData.textureDirty = !0), this.changeMaterialForDefine(), this._assembler && this._assembler.updateRenderData(this));
          } else {
            if (this.cacheMode === Xe.CHAR) this._letterTexture = this._assembler.getAssemblerData(), this._texture = this._letterTexture;else if (!this._ttfSpriteFrame) {
              this._ttfSpriteFrame = new G(), this._assemblerData = this._assembler.getAssemblerData();
              var i = new E(this._assemblerData.canvas),
                  r = new S();
              r.image = i, this._ttfSpriteFrame.texture = r;
            }
            this.cacheMode !== Xe.CHAR && (this._texture = this._ttfSpriteFrame), this.changeMaterialForDefine();
          }
        }, r.changeMaterialForDefine = function () {
          if (this._texture) {
            var t = !1;

            if (this.cacheMode !== Xe.CHAR) {
              var e = this._texture.texture;

              if (e instanceof R) {
                var i = e.getPixelFormat();
                t = i === w.RGBA_ETC1 || i === w.RGB_A_PVRTC_4BPPV1 || i === w.RGB_A_PVRTC_2BPPV1;
              }
            }

            this._instanceMaterialType = t ? W.USE_ALPHA_SEPARATED : W.ADD_COLOR_AND_TEXTURE, this.updateMaterial();
          }
        }, r._updateBlendFunc = function () {
          t.prototype._updateBlendFunc.call(this);
        }, l(i, [{
          key: "string",
          get: function get() {
            return this._string;
          },
          set: function set(t) {
            t = null == t ? "" : t.toString(), this._string !== t && (this._string = t, this.updateRenderData());
          }
        }, {
          key: "horizontalAlign",
          get: function get() {
            return this._horizontalAlign;
          },
          set: function set(t) {
            this._horizontalAlign !== t && (this._horizontalAlign = t, this.updateRenderData());
          }
        }, {
          key: "verticalAlign",
          get: function get() {
            return this._verticalAlign;
          },
          set: function set(t) {
            this._verticalAlign !== t && (this._verticalAlign = t, this.updateRenderData());
          }
        }, {
          key: "actualFontSize",
          get: function get() {
            return this._actualFontSize;
          },
          set: function set(t) {
            this._actualFontSize = t;
          }
        }, {
          key: "fontSize",
          get: function get() {
            return this._fontSize;
          },
          set: function set(t) {
            this._fontSize !== t && (this._fontSize = t, this.updateRenderData());
          }
        }, {
          key: "fontFamily",
          get: function get() {
            return this._fontFamily;
          },
          set: function set(t) {
            this._fontFamily !== t && (this._fontFamily = t, this.updateRenderData());
          }
        }, {
          key: "lineHeight",
          get: function get() {
            return this._lineHeight;
          },
          set: function set(t) {
            this._lineHeight !== t && (this._lineHeight = t, this.updateRenderData());
          }
        }, {
          key: "spacingX",
          get: function get() {
            return this._spacingX;
          },
          set: function set(t) {
            this._spacingX !== t && (this._spacingX = t, this.updateRenderData());
          }
        }, {
          key: "overflow",
          get: function get() {
            return this._overflow;
          },
          set: function set(t) {
            this._overflow !== t && (this._overflow = t, this.updateRenderData());
          }
        }, {
          key: "enableWrapText",
          get: function get() {
            return this._enableWrapText;
          },
          set: function set(t) {
            this._enableWrapText !== t && (this._enableWrapText = t, this.updateRenderData());
          }
        }, {
          key: "font",
          get: function get() {
            return this._font;
          },
          set: function set(t) {
            this._font !== t && (this._isSystemFontUsed = !t, this._font = t, this._renderData && (this.destroyRenderData(), this._renderData = null), this._fontAtlas = null, this.updateRenderData(!0));
          }
        }, {
          key: "useSystemFont",
          get: function get() {
            return this._isSystemFontUsed;
          },
          set: function set(t) {
            this._isSystemFontUsed !== t && (this.destroyRenderData(), this._renderData = null, this._isSystemFontUsed = !!t, t && (this.font = null), this._flushAssembler(), this.updateRenderData());
          }
        }, {
          key: "cacheMode",
          get: function get() {
            return this._cacheMode;
          },
          set: function set(t) {
            this._cacheMode !== t && (this._cacheMode !== Xe.BITMAP || this._font instanceof gt || !this._ttfSpriteFrame || this._ttfSpriteFrame._resetDynamicAtlasFrame(), this._cacheMode === Xe.CHAR && (this._ttfSpriteFrame = null), this._cacheMode = t, this.updateRenderData(!0));
          }
        }, {
          key: "isBold",
          get: function get() {
            return this._isBold;
          },
          set: function set(t) {
            this._isBold !== t && (this._isBold = t, this.updateRenderData());
          }
        }, {
          key: "isItalic",
          get: function get() {
            return this._isItalic;
          },
          set: function set(t) {
            this._isItalic !== t && (this._isItalic = t, this.updateRenderData());
          }
        }, {
          key: "isUnderline",
          get: function get() {
            return this._isUnderline;
          },
          set: function set(t) {
            this._isUnderline !== t && (this._isUnderline = t, this.updateRenderData());
          }
        }, {
          key: "underlineHeight",
          get: function get() {
            return this._underlineHeight;
          },
          set: function set(t) {
            this._underlineHeight !== t && (this._underlineHeight = t, this.updateRenderData());
          }
        }, {
          key: "spriteFrame",
          get: function get() {
            return this._texture;
          }
        }, {
          key: "ttfSpriteFrame",
          get: function get() {
            return this._ttfSpriteFrame;
          }
        }, {
          key: "assemblerData",
          get: function get() {
            return this._assemblerData;
          }
        }, {
          key: "fontAtlas",
          get: function get() {
            return this._fontAtlas;
          },
          set: function set(t) {
            this._fontAtlas = t;
          }
        }, {
          key: "_bmFontOriginalSize",
          get: function get() {
            return this._font instanceof gt ? this._font.fontSize : -1;
          }
        }]), i;
      }(X), Ve.HorizontalAlign = Be, Ve.VerticalAlign = Ge, Ve.Overflow = We, Ve.CacheMode = Xe, Ve._canvasPool = Ye.getInstance(), n((Ae = je).prototype, "string", [Ct, Lt, O], Object.getOwnPropertyDescriptor(Ae.prototype, "string"), Ae.prototype), n(Ae.prototype, "horizontalAlign", [Ut, kt, Ht], Object.getOwnPropertyDescriptor(Ae.prototype, "horizontalAlign"), Ae.prototype), n(Ae.prototype, "verticalAlign", [Nt, Vt, jt], Object.getOwnPropertyDescriptor(Ae.prototype, "verticalAlign"), Ae.prototype), n(Ae.prototype, "fontSize", [Bt, Gt], Object.getOwnPropertyDescriptor(Ae.prototype, "fontSize"), Ae.prototype), n(Ae.prototype, "fontFamily", [Wt, Xt, Yt], Object.getOwnPropertyDescriptor(Ae.prototype, "fontFamily"), Ae.prototype), n(Ae.prototype, "lineHeight", [Zt, $t], Object.getOwnPropertyDescriptor(Ae.prototype, "lineHeight"), Ae.prototype), n(Ae.prototype, "spacingX", [Kt, Jt, Qt], Object.getOwnPropertyDescriptor(Ae.prototype, "spacingX"), Ae.prototype), n(Ae.prototype, "overflow", [qt, te, ee], Object.getOwnPropertyDescriptor(Ae.prototype, "overflow"), Ae.prototype), n(Ae.prototype, "enableWrapText", [ie, re], Object.getOwnPropertyDescriptor(Ae.prototype, "enableWrapText"), Ae.prototype), n(Ae.prototype, "font", [ne, ae, se, oe], Object.getOwnPropertyDescriptor(Ae.prototype, "font"), Ae.prototype), n(Ae.prototype, "useSystemFont", [le, he], Object.getOwnPropertyDescriptor(Ae.prototype, "useSystemFont"), Ae.prototype), n(Ae.prototype, "cacheMode", [ue, pe, ce], Object.getOwnPropertyDescriptor(Ae.prototype, "cacheMode"), Ae.prototype), n(Ae.prototype, "isBold", [fe, _e], Object.getOwnPropertyDescriptor(Ae.prototype, "isBold"), Ae.prototype), n(Ae.prototype, "isItalic", [ye, de], Object.getOwnPropertyDescriptor(Ae.prototype, "isItalic"), Ae.prototype), n(Ae.prototype, "isUnderline", [ge, me], Object.getOwnPropertyDescriptor(Ae.prototype, "isUnderline"), Ae.prototype), n(Ae.prototype, "underlineHeight", [De, b, be, ve], Object.getOwnPropertyDescriptor(Ae.prototype, "underlineHeight"), Ae.prototype), Te = n(Ae.prototype, "_string", [D], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return "label";
        }
      }), xe = n(Ae.prototype, "_horizontalAlign", [D], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return Be.CENTER;
        }
      }), we = n(Ae.prototype, "_verticalAlign", [D], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return Ge.CENTER;
        }
      }), Se = n(Ae.prototype, "_actualFontSize", [D], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 0;
        }
      }), Ee = n(Ae.prototype, "_fontSize", [D], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 40;
        }
      }), Re = n(Ae.prototype, "_fontFamily", [D], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return "Arial";
        }
      }), Oe = n(Ae.prototype, "_lineHeight", [D], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 40;
        }
      }), ze = n(Ae.prototype, "_overflow", [D], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return We.NONE;
        }
      }), Me = n(Ae.prototype, "_enableWrapText", [D], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !0;
        }
      }), Pe = n(Ae.prototype, "_font", [D], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return null;
        }
      }), Ie = n(Ae.prototype, "_isSystemFontUsed", [D], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !0;
        }
      }), Ce = n(Ae.prototype, "_spacingX", [D], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 0;
        }
      }), Le = n(Ae.prototype, "_isItalic", [D], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !1;
        }
      }), Ue = n(Ae.prototype, "_isBold", [D], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !1;
        }
      }), ke = n(Ae.prototype, "_isUnderline", [D], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !1;
        }
      }), He = n(Ae.prototype, "_underlineHeight", [D], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 2;
        }
      }), Ne = n(Ae.prototype, "_cacheMode", [D], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return Xe.NONE;
        }
      }), Fe = Ae)) || Fe) || Fe) || Fe) || Fe));

      a.Label = $i, function (t) {
        t[t.SIMPLE = 0] = "SIMPLE", t[t.SLICED = 1] = "SLICED", t[t.TILED = 2] = "TILED", t[t.FILLED = 3] = "FILLED";
      }(Wi || (Wi = {})), y(Wi), function (t) {
        t[t.HORIZONTAL = 0] = "HORIZONTAL", t[t.VERTICAL = 1] = "VERTICAL", t[t.RADIAL = 2] = "RADIAL";
      }(Xi || (Xi = {})), y(Xi), function (t) {
        t[t.CUSTOM = 0] = "CUSTOM", t[t.TRIMMED = 1] = "TRIMMED", t[t.RAW = 2] = "RAW";
      }(Yi || (Yi = {})), y(Yi), function (t) {
        t.SPRITE_FRAME_CHANGED = "spriteframe-changed";
      }(Zi || (Zi = {}));
      var Ki = t("a", (qe = g("cc.Sprite"), ti = z(), ei = M(110), ii = P(), ri = T(Q), ni = I(), ai = C(), si = T(G), oi = I(), li = C(), hi = T(Wi), ui = I(), pi = C(), ci = T(Xi), fi = I(), _i = C(), yi = I(), di = C(), gi = H(), mi = I(), Di = C(), bi = H(), vi = I(), Fi = C(), Ai = L(), Ti = I(), xi = C(), wi = I(), Si = C(), Ei = T(Yi), Ri = I(), Oi = C(), qe(zi = ti(zi = ei(zi = ii((Gi = Bi = function (t) {
        function i() {
          for (var e, i = arguments.length, r = new Array(i), n = 0; n < i; n++) {
            r[n] = arguments[n];
          }

          return e = t.call.apply(t, [this].concat(r)) || this, s(e, "_spriteFrame", Pi, o(e)), s(e, "_type", Ii, o(e)), s(e, "_fillType", Ci, o(e)), s(e, "_sizeMode", Li, o(e)), s(e, "_fillCenter", Ui, o(e)), s(e, "_fillStart", ki, o(e)), s(e, "_fillRange", Hi, o(e)), s(e, "_isTrimmedMode", Ni, o(e)), s(e, "_useGrayscale", Vi, o(e)), s(e, "_atlas", ji, o(e)), e;
        }

        e(i, t);
        var r = i.prototype;
        return r.__preload = function () {
          this.changeMaterialForDefine(), t.prototype.__preload.call(this);
        }, r.onEnable = function () {
          t.prototype.onEnable.call(this), this._activateMaterial();
          var e = this._spriteFrame;
          e && (this._updateUVs(), this._type === Wi.SLICED && e.on(G.EVENT_UV_UPDATED, this._updateUVs, this));
        }, r.onDisable = function () {
          this._spriteFrame && this._type === Wi.SLICED && this._spriteFrame.off(G.EVENT_UV_UPDATED, this._updateUVs, this);
        }, r.onDestroy = function () {
          t.prototype.onDestroy.call(this);
        }, r.changeSpriteFrameFromAtlas = function (t) {
          if (this._atlas) {
            var e = this._atlas.getSpriteFrame(t);

            this.spriteFrame = e;
          } else console.warn("SpriteAtlas is null.");
        }, r.changeMaterialForDefine = function () {
          var t,
              e = this._instanceMaterialType;
          this._spriteFrame && (t = this._spriteFrame.texture);
          var i = !1;

          if (t instanceof R) {
            var r = t.getPixelFormat();
            i = r === w.RGBA_ETC1 || r === w.RGB_A_PVRTC_4BPPV1 || r === w.RGB_A_PVRTC_2BPPV1;
          }

          i && this.grayscale ? this._instanceMaterialType = W.USE_ALPHA_SEPARATED_AND_GRAY : i ? this._instanceMaterialType = W.USE_ALPHA_SEPARATED : this.grayscale ? this._instanceMaterialType = W.GRAYSCALE : this._instanceMaterialType = W.ADD_COLOR_AND_TEXTURE, e !== this._instanceMaterialType && this.updateMaterial();
        }, r._updateBuiltinMaterial = function () {
          var e = t.prototype._updateBuiltinMaterial.call(this);

          if (this.spriteFrame && this.spriteFrame.texture instanceof U) {
            var i = d({
              SAMPLE_FROM_RT: !0
            }, e.passes[0].defines),
                r = new k();
            r.initialize({
              effectAsset: e.effectAsset,
              defines: i
            }), e = r;
          }

          return e;
        }, r._render = function (t) {
          t.commitComp(this, this.renderData, this._spriteFrame, this._assembler, null);
        }, r._canRender = function () {
          if (!t.prototype._canRender.call(this)) return !1;
          var e = this._spriteFrame;
          return !(!e || !e.texture);
        }, r._flushAssembler = function () {
          var t = i.Assembler.getAssembler(this);
          this._assembler !== t && (this.destroyRenderData(), this._assembler = t), this._renderData || this._assembler && this._assembler.createData && (this._renderData = this._assembler.createData(this), this._renderData.material = this.getRenderMaterial(0), this.markForUpdateRenderData(), this.spriteFrame && this._assembler.updateUVs(this), this._updateColor()), this._spriteFrame && (this._type === Wi.SLICED ? this._spriteFrame.on(G.EVENT_UV_UPDATED, this._updateUVs, this) : this._spriteFrame.off(G.EVENT_UV_UPDATED, this._updateUVs, this));
        }, r._applySpriteSize = function () {
          if (this._spriteFrame) {
            if (!this._spriteFrame.isDefault) if (Yi.RAW === this._sizeMode) {
              var t = this._spriteFrame.originalSize;

              this.node._uiProps.uiTransformComp.setContentSize(t);
            } else if (Yi.TRIMMED === this._sizeMode) {
              var e = this._spriteFrame.rect;

              this.node._uiProps.uiTransformComp.setContentSize(e.width, e.height);
            }

            this._activateMaterial();
          }
        }, r._resized = function () {}, r._activateMaterial = function () {
          var t = this._spriteFrame,
              e = this.getRenderMaterial(0);
          t && e && this.markForUpdateRenderData(), this._renderData && (this._renderData.material = e);
        }, r._updateUVs = function () {
          this._assembler && this._assembler.updateUVs(this);
        }, r._applySpriteFrame = function (t) {
          var e = this._spriteFrame;
          t && this._type === Wi.SLICED && t.off(G.EVENT_UV_UPDATED, this._updateUVs, this), this._updateUVs();
          var i = !1;
          e && (t && t.texture === e.texture || (i = !0), i && (this._renderData && (this._renderData.textureDirty = !0), this.changeMaterialForDefine()), this._applySpriteSize(), this._type === Wi.SLICED && e.on(G.EVENT_UV_UPDATED, this._updateUVs, this));
        }, l(i, [{
          key: "spriteAtlas",
          get: function get() {
            return this._atlas;
          },
          set: function set(t) {
            this._atlas !== t && (this._atlas = t);
          }
        }, {
          key: "spriteFrame",
          get: function get() {
            return this._spriteFrame;
          },
          set: function set(t) {
            if (this._spriteFrame !== t) {
              var e = this._spriteFrame;
              this._spriteFrame = t, this.markForUpdateRenderData(!1), this._applySpriteFrame(e);
            }
          }
        }, {
          key: "type",
          get: function get() {
            return this._type;
          },
          set: function set(t) {
            this._type !== t && (this._type = t, this._flushAssembler());
          }
        }, {
          key: "fillType",
          get: function get() {
            return this._fillType;
          },
          set: function set(t) {
            this._fillType !== t && (t === Xi.RADIAL || this._fillType === Xi.RADIAL ? (this.destroyRenderData(), this._renderData = null) : this._renderData && this.markForUpdateRenderData(!0)), this._fillType = t, this._flushAssembler();
          }
        }, {
          key: "fillCenter",
          get: function get() {
            return this._fillCenter;
          },
          set: function set(t) {
            this._fillCenter.x = t.x, this._fillCenter.y = t.y, this._type === Wi.FILLED && this._renderData && this.markForUpdateRenderData();
          }
        }, {
          key: "fillStart",
          get: function get() {
            return this._fillStart;
          },
          set: function set(t) {
            this._fillStart = N(t, 0, 1), this._type === Wi.FILLED && this._renderData && (this.markForUpdateRenderData(), this._updateUVs());
          }
        }, {
          key: "fillRange",
          get: function get() {
            return this._fillRange;
          },
          set: function set(t) {
            this._fillRange = N(t, -1, 1), this._type === Wi.FILLED && this._renderData && (this.markForUpdateRenderData(), this._updateUVs());
          }
        }, {
          key: "trim",
          get: function get() {
            return this._isTrimmedMode;
          },
          set: function set(t) {
            this._isTrimmedMode !== t && (this._isTrimmedMode = t, this._type === Wi.SIMPLE && this._renderData && this.markForUpdateRenderData(!0));
          }
        }, {
          key: "grayscale",
          get: function get() {
            return this._useGrayscale;
          },
          set: function set(t) {
            this._useGrayscale !== t && (this._useGrayscale = t, this.changeMaterialForDefine(), this.updateMaterial());
          }
        }, {
          key: "sizeMode",
          get: function get() {
            return this._sizeMode;
          },
          set: function set(t) {
            this._sizeMode !== t && (this._sizeMode = t, t !== Yi.CUSTOM && this._applySpriteSize());
          }
        }]), i;
      }(X), Bi.FillType = Xi, Bi.Type = Wi, Bi.SizeMode = Yi, Bi.EventType = Zi, n((Mi = Gi).prototype, "spriteAtlas", [ri, ni, ai], Object.getOwnPropertyDescriptor(Mi.prototype, "spriteAtlas"), Mi.prototype), n(Mi.prototype, "spriteFrame", [si, oi, li], Object.getOwnPropertyDescriptor(Mi.prototype, "spriteFrame"), Mi.prototype), n(Mi.prototype, "type", [hi, ui, pi], Object.getOwnPropertyDescriptor(Mi.prototype, "type"), Mi.prototype), n(Mi.prototype, "fillType", [ci, fi, _i], Object.getOwnPropertyDescriptor(Mi.prototype, "fillType"), Mi.prototype), n(Mi.prototype, "fillCenter", [yi, di], Object.getOwnPropertyDescriptor(Mi.prototype, "fillCenter"), Mi.prototype), n(Mi.prototype, "fillStart", [gi, mi, Di], Object.getOwnPropertyDescriptor(Mi.prototype, "fillStart"), Mi.prototype), n(Mi.prototype, "fillRange", [bi, vi, Fi], Object.getOwnPropertyDescriptor(Mi.prototype, "fillRange"), Mi.prototype), n(Mi.prototype, "trim", [Ai, Ti, xi], Object.getOwnPropertyDescriptor(Mi.prototype, "trim"), Mi.prototype), n(Mi.prototype, "grayscale", [b, wi, Si], Object.getOwnPropertyDescriptor(Mi.prototype, "grayscale"), Mi.prototype), n(Mi.prototype, "sizeMode", [Ei, Ri, Oi], Object.getOwnPropertyDescriptor(Mi.prototype, "sizeMode"), Mi.prototype), Pi = n(Mi.prototype, "_spriteFrame", [D], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return null;
        }
      }), Ii = n(Mi.prototype, "_type", [D], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return Wi.SIMPLE;
        }
      }), Ci = n(Mi.prototype, "_fillType", [D], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return Xi.HORIZONTAL;
        }
      }), Li = n(Mi.prototype, "_sizeMode", [D], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return Yi.TRIMMED;
        }
      }), Ui = n(Mi.prototype, "_fillCenter", [D], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return new V(0, 0);
        }
      }), ki = n(Mi.prototype, "_fillStart", [D], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 0;
        }
      }), Hi = n(Mi.prototype, "_fillRange", [D], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 0;
        }
      }), Ni = n(Mi.prototype, "_isTrimmedMode", [D], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !0;
        }
      }), Vi = n(Mi.prototype, "_useGrayscale", [D], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !1;
        }
      }), ji = n(Mi.prototype, "_atlas", [D], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return null;
        }
      }), zi = Mi)) || zi) || zi) || zi) || zi));
      a.Sprite = Ki;
    }
  };
}); 
 			}); 
		define("__plugin__/wx0446ba2621dda60a/sprite-frame-1edab3eb.js", function(require, module, exports){ 			
"use strict";

System.register(["./texture-barrier-60b5983b.js", "./json-asset-933a1d4c.js"], function (t) {
  "use strict";

  var e, i, s, r, n, h, a, u, _, c, o, l, f, x, d, g;

  return {
    setters: [function (t) {
      e = t.bT, i = t.af, s = t.l, r = t.bX, n = t.bU, h = t.f, a = t.d;
    }, function (t) {
      u = t.c_, _ = t.aT, c = t.dy, o = t.bW, l = t.a3, f = t.V, x = t.a1, d = t.aL, g = t.aS;
    }],
    execute: function execute() {
      var p = function () {
        function t(t, e) {
          this._texture = void 0, this._width = void 0, this._height = void 0, this._x = void 0, this._y = void 0, this._nexty = void 0, this._innerTextureInfos = {}, this._innerSpriteFrames = void 0, this._count = void 0;
          var i = new v();
          i.initWithSize(t, e), this._texture = i, this._width = t, this._height = e, this._x = 2, this._y = 2, this._nexty = 2, this._innerTextureInfos = {}, this._innerSpriteFrames = [], this._count = 0;
        }

        var e = t.prototype;
        return e.insertSpriteFrame = function (t) {
          var e = t.rect,
              i = t.texture,
              r = this._innerTextureInfos[i.getId()],
              n = e.x,
              h = e.y;

          if (r) n += r.x, h += r.y;else {
            var a = i.width,
                u = i.height;
            if (this._x + a + 2 > this._width && (this._x = 2, this._y = this._nexty), this._y + u + 2 > this._nexty && (this._nexty = this._y + u + 2), this._nexty > this._height) return null;
            s.internal.dynamicAtlasManager.textureBleeding && ((a <= 8 || u <= 8) && (this._texture.drawTextureAt(i.image, this._x - 1, this._y - 1), this._texture.drawTextureAt(i.image, this._x - 1, this._y + 1), this._texture.drawTextureAt(i.image, this._x + 1, this._y - 1), this._texture.drawTextureAt(i.image, this._x + 1, this._y + 1)), this._texture.drawTextureAt(i.image, this._x - 1, this._y), this._texture.drawTextureAt(i.image, this._x + 1, this._y), this._texture.drawTextureAt(i.image, this._x, this._y - 1), this._texture.drawTextureAt(i.image, this._x, this._y + 1)), this._texture.drawTextureAt(i.image, this._x, this._y), this._innerTextureInfos[i.getId()] = {
              x: this._x,
              y: this._y,
              texture: i
            }, this._count++, n += this._x, h += this._y, this._x += a + 2;
          }
          var _ = {
            x: n,
            y: h,
            texture: this._texture
          };
          return this._innerSpriteFrames.push(t), _;
        }, e.deleteInnerTexture = function (t) {
          t && this._innerTextureInfos[t.getId()] && (delete this._innerTextureInfos[t.getId()], this._count--);
        }, e.isEmpty = function () {
          return this._count <= 0;
        }, e.reset = function () {
          this._x = 2, this._y = 2, this._nexty = 2;

          for (var t = this._innerSpriteFrames, e = 0, i = t.length; e < i; e++) {
            var s = t[e];
            s.isValid && s._resetDynamicAtlasFrame();
          }

          this._innerSpriteFrames.length = 0, this._innerTextureInfos = {};
        }, e.destroy = function () {
          this.reset(), this._texture.destroy();
        }, t;
      }(),
          v = function (t) {
        function s() {
          return t.apply(this, arguments) || this;
        }

        e(s, t);
        var r = s.prototype;
        return r.initWithSize = function (t, e, i) {
          void 0 === i && (i = u.RGBA8888), this.reset({
            width: t,
            height: e,
            format: i
          });
        }, r.drawTextureAt = function (t, e, s) {
          var r = this.getGFXTexture();

          if (t && r) {
            var n = this._getGFXDevice();

            if (n) {
              var h = new i();
              h.texOffset.x = e, h.texOffset.y = s, h.texExtent.width = t.width, h.texExtent.height = t.height, n.copyTexImagesToTexture([t.data], r, [h]);
            } else console.warn("Unable to get device");
          }
        }, s;
      }(_),
          y = function () {
        function t() {
          this._atlases = [], this._atlasIndex = -1, this._maxAtlasCount = 5, this._textureSize = 2048, this._maxFrameSize = 512, this._textureBleeding = !0, this._enabled = !1;
        }

        var e = t.prototype;
        return e.newAtlas = function () {
          var t = this._atlases[++this._atlasIndex];
          return t || (t = new p(this._textureSize, this._textureSize), this._atlases.push(t)), t;
        }, e.beforeSceneLoad = function () {
          this.reset();
        }, e.insertSpriteFrame = function (t) {
          if (!this._enabled || this._atlasIndex === this._maxAtlasCount || !t || t._original) return null;
          if (!t.packable) return null;
          var e = t.texture.getSamplerInfo();
          if (e.minFilter !== c.LINEAR || e.magFilter !== c.LINEAR || e.mipFilter !== c.NONE) return null;
          var i = this._atlases[this._atlasIndex];
          i || (i = this.newAtlas());
          var s = i.insertSpriteFrame(t);
          return s || this._atlasIndex === this._maxAtlasCount ? s : (i = this.newAtlas()).insertSpriteFrame(t);
        }, e.reset = function () {
          for (var t = 0, e = this._atlases.length; t < e; t++) {
            this._atlases[t].destroy();
          }

          this._atlases.length = 0, this._atlasIndex = -1;
        }, e.deleteAtlasSpriteFrame = function (t) {
          if (t._original) {
            for (var e, i = this._atlases.length - 1; i >= 0; i--) {
              e = this._atlases[i], r.array.fastRemove(e._innerSpriteFrames, t);
            }

            var s = t._original._texture;
            this.deleteAtlasTexture(s);
          }
        }, e.deleteAtlasTexture = function (t) {
          if (t) for (var e = this._atlases.length - 1; e >= 0; e--) {
            this._atlases[e].deleteInnerTexture(t), this._atlases[e].isEmpty() && (this._atlases[e].destroy(), this._atlases.splice(e, 1), this._atlasIndex--);
          }
        }, e.packToDynamicAtlas = function (t, e) {
          if (e && !e._original && e.packable && e.texture && e.texture.width > 0 && e.texture.height > 0) {
            var i = this.insertSpriteFrame(e);
            i && e._setDynamicAtlasFrame(i);
          }
        }, n(t, [{
          key: "enabled",
          get: function get() {
            return this._enabled;
          },
          set: function set(t) {
            this._enabled !== t && (t ? (this.reset(), s.director.on(s.Director.EVENT_BEFORE_SCENE_LAUNCH, this.beforeSceneLoad, this)) : (this.reset(), s.director.off(s.Director.EVENT_BEFORE_SCENE_LAUNCH, this.beforeSceneLoad, this)), this._enabled = t);
          }
        }, {
          key: "maxAtlasCount",
          get: function get() {
            return this._maxAtlasCount;
          },
          set: function set(t) {
            this._maxAtlasCount = t;
          }
        }, {
          key: "atlasCount",
          get: function get() {
            return this._atlases.length;
          }
        }, {
          key: "textureBleeding",
          get: function get() {
            return this._textureBleeding;
          },
          set: function set(t) {
            this._textureBleeding = t;
          }
        }, {
          key: "textureSize",
          get: function get() {
            return this._textureSize;
          },
          set: function set(t) {
            this._textureSize = t;
          }
        }, {
          key: "maxFrameSize",
          get: function get() {
            return this._maxFrameSize;
          },
          set: function set(t) {
            this._maxFrameSize = t;
          }
        }]), t;
      }();

      y.instance = void 0;
      var m,
          S,
          U,
          w = t("d", y.instance = new y());
      s.internal.dynamicAtlasManager = w;
      var F = [{
        u: 0,
        v: 0
      }, {
        u: 0,
        v: 0
      }, {
        u: 0,
        v: 0
      }, {
        u: 0,
        v: 0
      }],
          V = t("S", o("cc.SpriteFrame")((U = S = function (t) {
        function i() {
          var e;
          return (e = t.call(this) || this).vertices = null, e.uv = [], e.unbiasUV = [], e.uvSliced = [], e._rect = new l(), e._offset = new f(), e._originalSize = new x(), e._rotated = !1, e._capInsets = [0, 0, 0, 0], e._atlasUuid = "", e._texture = void 0, e._isFlipUVY = !1, e._isFlipUVX = !1, e._original = null, e._packable = !0, e;
        }

        e(i, t), i.createWithImage = function (t) {
          var e = t instanceof g ? t : new g(t),
              s = new _();
          s.image = e;
          var r = new i();
          return r.texture = s, r;
        };
        var s = i.prototype;
        return s.textureLoaded = function () {
          return !!this.texture;
        }, s.isRotated = function () {
          return this._rotated;
        }, s.setRotated = function (t) {
          this.rotated = t;
        }, s.getRect = function (t) {
          return t ? (t.set(this._rect), t) : this._rect.clone();
        }, s.setRect = function (t) {
          this.rect = t;
        }, s.getOriginalSize = function (t) {
          return t ? (t.set(this._originalSize), t) : this._originalSize.clone();
        }, s.setOriginalSize = function (t) {
          this.originalSize = t;
        }, s.getOffset = function (t) {
          return t ? (t.set(this._offset), t) : this._offset.clone();
        }, s.setOffset = function (t) {
          this.offset = t;
        }, s.getGFXTexture = function () {
          return this._texture.getGFXTexture();
        }, s.getGFXSampler = function () {
          return this._texture.getGFXSampler();
        }, s.getHash = function () {
          return this._texture.getHash();
        }, s.getSamplerInfo = function () {
          return this._texture.getSamplerInfo();
        }, s.reset = function (t, e) {
          void 0 === e && (e = !1);
          var i = !1;
          e && (this._originalSize.set(0, 0), this._rect.set(0, 0, 0, 0), this._offset.set(0, 0), this._capInsets = [0, 0, 0, 0], this._rotated = !1, i = !0), t && (t.texture && (this._rect.x = this._rect.y = 0, this._rect.width = t.texture.width, this._rect.height = t.texture.height, this._refreshTexture(t.texture), this.checkRect(this._texture)), t.originalSize && this._originalSize.set(t.originalSize), t.rect && this._rect.set(t.rect), t.offset && this._offset.set(t.offset), void 0 !== t.borderTop && (this._capInsets[1] = t.borderTop), void 0 !== t.borderBottom && (this._capInsets[3] = t.borderBottom), void 0 !== t.borderLeft && (this._capInsets[0] = t.borderLeft), void 0 !== t.borderRight && (this._capInsets[2] = t.borderRight), void 0 !== t.isRotate && (this._rotated = !!t.isRotate), void 0 !== t.isFlipUv && (this._isFlipUVY = !!t.isFlipUv), i = !0), i && this.texture && this._calculateUV();
        }, s.checkRect = function (t) {
          var e = this._rect,
              i = e.x,
              s = e.y;
          return this._rotated ? (i += e.height, s += e.width) : (i += e.width, s += e.height), i > t.width ? (h(3300, this.name + "/" + t.name, i, t.width), !1) : !(s > t.height && (h(3301, this.name + "/" + t.name, s, t.height), 1));
        }, s.destroy = function () {
          return this._packable && w && w.deleteAtlasSpriteFrame(this), t.prototype.destroy.call(this);
        }, s._calculateSlicedUV = function () {
          var t = this._rect,
              e = this.texture,
              s = e.width,
              r = e.height,
              n = this._capInsets[0],
              h = this._capInsets[2],
              a = t.width - n - h,
              u = this._capInsets[1],
              _ = this._capInsets[3],
              c = t.height - u - _,
              o = this.uvSliced;

          if (o.length = 0, this._rotated) {
            F[0].u = t.x / s, F[1].u = (t.x + _) / s, F[2].u = (t.x + _ + c) / s, F[3].u = (t.x + t.height) / s, F[3].v = t.y / r, F[2].v = (t.y + n) / r, F[1].v = (t.y + n + a) / r, F[0].v = (t.y + t.width) / r;

            for (var l = 0; l < 4; ++l) {
              for (var f = F[l], x = 0; x < 4; ++x) {
                var d = F[3 - x];
                o.push({
                  u: f.u,
                  v: d.v
                });
              }
            }
          } else {
            F[0].u = t.x / s, F[1].u = (t.x + n) / s, F[2].u = (t.x + n + a) / s, F[3].u = (t.x + t.width) / s, F[3].v = t.y / r, F[2].v = (t.y + u) / r, F[1].v = (t.y + u + c) / r, F[0].v = (t.y + t.height) / r;

            for (var g = 0; g < 4; ++g) {
              for (var p = F[g], v = 0; v < 4; ++v) {
                var y = F[v];
                o.push({
                  u: y.u,
                  v: p.v
                });
              }
            }
          }

          this.emit(i.EVENT_UV_UPDATED, this);
        }, s._calculateUV = function () {
          var t = this._rect,
              e = this.uv,
              i = this.unbiasUV,
              s = this.texture,
              r = s.width,
              n = s.height;

          if (this._rotated) {
            var h = 0 === r ? 0 : t.x / r,
                a = 0 === r ? 1 : (t.x + t.height) / r,
                u = 0 === n ? 0 : t.y / n,
                _ = 0 === n ? 1 : (t.y + t.width) / n;

            this._isFlipUVX && this._isFlipUVY ? (e[0] = a, e[1] = _, e[2] = a, e[3] = u, e[4] = h, e[5] = _, e[6] = h, e[7] = u) : this._isFlipUVX ? (e[0] = a, e[1] = u, e[2] = a, e[3] = _, e[4] = h, e[5] = u, e[6] = h, e[7] = _) : this._isFlipUVY ? (e[0] = h, e[1] = _, e[2] = h, e[3] = u, e[4] = a, e[5] = _, e[6] = a, e[7] = u) : (e[0] = h, e[1] = u, e[2] = h, e[3] = _, e[4] = a, e[5] = u, e[6] = a, e[7] = _);
            var c = 0 === r ? 0 : t.x / r,
                o = 0 === r ? 1 : (t.x + t.height) / r,
                l = 0 === n ? 0 : t.y / n,
                f = 0 === n ? 1 : (t.y + t.width) / n;
            this._isFlipUVX && this._isFlipUVY ? (i[0] = o, i[1] = f, i[2] = o, i[3] = l, i[4] = c, i[5] = f, i[6] = c, i[7] = l) : this._isFlipUVX ? (i[0] = o, i[1] = l, i[2] = o, i[3] = f, i[4] = c, i[5] = l, i[6] = c, i[7] = f) : this._isFlipUVY ? (i[0] = c, i[1] = f, i[2] = c, i[3] = l, i[4] = o, i[5] = f, i[6] = o, i[7] = l) : (i[0] = c, i[1] = l, i[2] = c, i[3] = f, i[4] = o, i[5] = l, i[6] = o, i[7] = f);
          } else {
            var x = 0 === r ? 0 : t.x / r,
                d = 0 === r ? 1 : (t.x + t.width) / r,
                g = 0 === n ? 1 : (t.y + t.height) / n,
                p = 0 === n ? 0 : t.y / n;
            this._isFlipUVX && this._isFlipUVY ? (e[0] = d, e[1] = p, e[2] = x, e[3] = p, e[4] = d, e[5] = g, e[6] = x, e[7] = g) : this._isFlipUVX ? (e[0] = d, e[1] = g, e[2] = x, e[3] = g, e[4] = d, e[5] = p, e[6] = x, e[7] = p) : this._isFlipUVY ? (e[0] = x, e[1] = p, e[2] = d, e[3] = p, e[4] = x, e[5] = g, e[6] = d, e[7] = g) : (e[0] = x, e[1] = g, e[2] = d, e[3] = g, e[4] = x, e[5] = p, e[6] = d, e[7] = p);
            var v = 0 === r ? 0 : t.x / r,
                y = 0 === r ? 1 : (t.x + t.width) / r,
                m = 0 === n ? 1 : (t.y + t.height) / n,
                S = 0 === n ? 0 : t.y / n;
            this._isFlipUVX && this._isFlipUVY ? (i[0] = y, i[1] = S, i[2] = v, i[3] = S, i[4] = y, i[5] = m, i[6] = v, i[7] = m) : this._isFlipUVX ? (i[0] = y, i[1] = m, i[2] = v, i[3] = m, i[4] = y, i[5] = S, i[6] = v, i[7] = S) : this._isFlipUVY ? (i[0] = v, i[1] = S, i[2] = y, i[3] = S, i[4] = v, i[5] = m, i[6] = y, i[7] = m) : (i[0] = v, i[1] = m, i[2] = y, i[3] = m, i[4] = v, i[5] = S, i[6] = y, i[7] = S);
          }

          var U = this.vertices;

          if (U) {
            U.nu.length = 0, U.nv.length = 0;

            for (var w = 0; w < U.u.length; w++) {
              U.nu[w] = U.u[w] / r, U.nv[w] = U.v[w] / n;
            }
          }

          this._calculateSlicedUV();
        }, s._setDynamicAtlasFrame = function (t) {
          t && (this._original = {
            _texture: this._texture,
            _x: this._rect.x,
            _y: this._rect.y
          }, this._texture = t.texture, this._rect.x = t.x, this._rect.y = t.y, this._calculateUV());
        }, s._resetDynamicAtlasFrame = function () {
          this._original && (this._rect.x = this._original._x, this._rect.y = this._original._y, this._texture = this._original._texture, this._original = null, this._calculateUV());
        }, s._checkPackable = function () {
          var t = w;

          if (t) {
            var e = this._texture;

            if (e instanceof _ && !e.isCompressed) {
              var i = this.width,
                  s = this.height;
              !e.image || i > t.maxFrameSize || s > t.maxFrameSize ? this._packable = !1 : e.image && e.image instanceof HTMLCanvasElement && (this._packable = !0);
            } else this._packable = !1;
          }
        }, s._serialize = function () {
          return null;
        }, s._deserialize = function (t) {
          var e = t,
              i = e.rect;
          i && (this._rect = new l(i.x, i.y, i.width, i.height));
          var s = e.offset;
          e.offset && (this._offset = new f(s.x, s.y));
          var r = e.originalSize;
          e.originalSize && (this._originalSize = new x(r.width, r.height)), this._rotated = !!e.rotated, this._name = e.name, this._packable = !!e.packable;
          var n = e.capInsets;
          n && (this._capInsets[0] = n[0], this._capInsets[1] = n[1], this._capInsets[2] = n[2], this._capInsets[3] = n[3]), this.vertices = e.vertices, this.vertices && (this.vertices.nu = [], this.vertices.nv = []);
        }, s.clone = function () {
          var t,
              e,
              s,
              r,
              n,
              h,
              a,
              u,
              _ = new i(),
              c = this.vertices;

          return _.vertices = c ? {
            x: c.x,
            y: c.y,
            triangles: c.triangles,
            nu: null === (t = c.nu) || void 0 === t ? void 0 : t.slice(0),
            u: null === (e = c.u) || void 0 === e ? void 0 : e.slice(0),
            nv: null === (s = c.nv) || void 0 === s ? void 0 : s.slice(0),
            v: null === (r = c.v) || void 0 === r ? void 0 : r.slice(0)
          } : null, (n = _.uv).splice.apply(n, [0, _.uv.length].concat(this.uv)), (h = _.unbiasUV).splice.apply(h, [0, _.unbiasUV.length].concat(this.unbiasUV)), (a = _.uvSliced).splice.apply(a, [0, _.uvSliced.length].concat(this.uvSliced)), _._rect.set(this._rect), _._offset.set(this._offset), _._originalSize.set(this._originalSize), _._rotated = this._rotated, (u = _._capInsets).splice.apply(u, [0, _._capInsets.length].concat(this._capInsets)), _._atlasUuid = this._atlasUuid, _._texture = this._texture, _._isFlipUVX = this._isFlipUVX, _._isFlipUVY = this._isFlipUVY, _;
        }, s._refreshTexture = function (t) {
          this._texture = t;
          var e = this._texture,
              i = {},
              s = !1;
          0 !== this._rect.width && 0 !== this._rect.height && this.checkRect(e) || (i.rect = new l(0, 0, e.width, e.height), s = !0), (0 === this._originalSize.width || 0 === this._originalSize.height || s) && (i.originalSize = new x(e.width, e.height), s = !0), s && (this.reset(i), this.onLoaded()), this._checkPackable();
        }, s.initDefault = function (e) {
          t.prototype.initDefault.call(this, e);
          var i = new _();
          i.initDefault(), this._refreshTexture(i), this._calculateUV();
        }, s.validate = function () {
          return this._texture && this._rect && 0 !== this._rect.width && 0 !== this._rect.height;
        }, n(i, [{
          key: "insetTop",
          get: function get() {
            return this._capInsets[1];
          },
          set: function set(t) {
            this._capInsets[1] !== t && (this._capInsets[1] = t, this._texture && this._calculateSlicedUV());
          }
        }, {
          key: "insetBottom",
          get: function get() {
            return this._capInsets[3];
          },
          set: function set(t) {
            this._capInsets[3] !== t && (this._capInsets[3] = t, this._texture && this._calculateSlicedUV());
          }
        }, {
          key: "insetLeft",
          get: function get() {
            return this._capInsets[0];
          },
          set: function set(t) {
            this._capInsets[0] !== t && (this._capInsets[0] = t, this._texture && this._calculateSlicedUV());
          }
        }, {
          key: "insetRight",
          get: function get() {
            return this._capInsets[2];
          },
          set: function set(t) {
            this._capInsets[2] !== t && (this._capInsets[2] = t, this._texture && this._calculateSlicedUV());
          }
        }, {
          key: "rect",
          get: function get() {
            return this._rect;
          },
          set: function set(t) {
            this._rect.equals(t) || (this._rect.set(t), this._texture && this._calculateUV());
          }
        }, {
          key: "originalSize",
          get: function get() {
            return this._originalSize;
          },
          set: function set(t) {
            this._originalSize.equals(t) || (this._originalSize.set(t), this._texture && this._calculateUV());
          }
        }, {
          key: "offset",
          get: function get() {
            return this._offset;
          },
          set: function set(t) {
            this._offset.set(t);
          }
        }, {
          key: "rotated",
          get: function get() {
            return this._rotated;
          },
          set: function set(t) {
            this._rotated !== t && (this._rotated = t, this._texture && this._calculateUV());
          }
        }, {
          key: "texture",
          get: function get() {
            return this._texture;
          },
          set: function set(t) {
            t ? t !== this._texture && this.reset({
              texture: t
            }, !0) : a(3122, this.name);
          }
        }, {
          key: "atlasUuid",
          get: function get() {
            return this._atlasUuid;
          },
          set: function set(t) {
            this._atlasUuid = t;
          }
        }, {
          key: "width",
          get: function get() {
            return this._texture.width;
          }
        }, {
          key: "height",
          get: function get() {
            return this._texture.height;
          }
        }, {
          key: "_textureSource",
          set: function set(t) {
            window.Build ? this._texture = t : t && (this._refreshTexture(t), this._calculateUV());
          }
        }, {
          key: "flipUVX",
          get: function get() {
            return this._isFlipUVX;
          },
          set: function set(t) {
            this._isFlipUVX = t, this._calculateUV();
          }
        }, {
          key: "flipUVY",
          get: function get() {
            return this._isFlipUVY;
          },
          set: function set(t) {
            this._isFlipUVY = t, this._calculateUV();
          }
        }, {
          key: "packable",
          get: function get() {
            return this._packable;
          },
          set: function set(t) {
            this._packable = t;
          }
        }, {
          key: "original",
          get: function get() {
            return this._original;
          }
        }]), i;
      }(d), S.EVENT_UV_UPDATED = "uv_updated", m = U)) || m);
      s.SpriteFrame = V;
    }
  };
}); 
 			}); 
		define("__plugin__/wx0446ba2621dda60a/static-vb-accessor-3aa47319.js", function(require, module, exports){ 			
"use strict";

System.register(["./texture-barrier-60b5983b.js", "./json-asset-933a1d4c.js", "./index-f2b92470.js", "./renderable-2d-e2838949.js"], function (t) {
  "use strict";

  var e, i, s, r, f, n, a, u, o, h, l, _, c, v, b;

  return {
    setters: [function (t) {
      e = t.bW, i = t.bO, s = t.d, r = t.al, f = t.o, n = t.q, a = t.aE, u = t.bU, o = t.P, h = t.bT, l = t.f, _ = t.g, c = t.bQ;
    }, function (t) {
      v = t.b0;
    }, function () {}, function (t) {
      b = t.e;
    }],
    execute: function execute() {
      var d = t("M", function () {
        function t() {
          this.byteOffset = 0, this.vertexOffset = 0, this.indexOffset = 0, this.vData = null, this.iData = null, this._dirty = !1, this._vertexFormatBytes = 0, this._floatsPerVertex = 0, this._initVDataCount = 0, this._initIDataCount = 0, this._attributes = null, this._iaPool = [], this._iaInfo = null, this._nextFreeIAHandle = 0;
        }

        var o = t.prototype;
        return o.initialize = function (t, s, r, f) {
          this._initVDataCount = r, this._initIDataCount = f, this._attributes = s, this._floatsPerVertex = b(s), e(this._initVDataCount / this._floatsPerVertex < 65536, i(9005)), this.vData && this.iData || (this.vData = new Float32Array(this._initVDataCount), this.iData = new Uint16Array(this._initIDataCount)), this._iaPool.push(this.createNewIA(t));
        }, o.reset = function () {
          this._nextFreeIAHandle = 0, this._dirty = !1;
        }, o.destroy = function () {
          this.reset(), this._attributes = null, this._iaInfo = null, this.vData = null, this.iData = null;

          for (var t = 0; t < this._iaPool.length; ++t) {
            var e = this._iaPool[t];
            e.vertexBuffers[0] && e.vertexBuffers[0].destroy(), e.indexBuffer && e.indexBuffer.destroy(), e.ia.destroy();
          }

          this._iaPool.length = 0;
        }, o.setDirty = function () {
          this._dirty = !0;
        }, o.request = function () {
          return s(9002), !1;
        }, o.requireFreeIA = function (t) {
          return this._iaPool.length <= this._nextFreeIAHandle && this._iaPool.push(this.createNewIA(t)), this._iaPool[this._nextFreeIAHandle++].ia;
        }, o.recycleIA = function (t) {
          for (var e = this._iaPool, i = 0; i < this._nextFreeIAHandle; ++i) {
            if (t === e[i].ia) {
              var s = e[i];
              return e[i] = e[--this._nextFreeIAHandle], void (e[this._nextFreeIAHandle] = s);
            }
          }
        }, o.checkCapacity = function (t, e) {
          var i = (this.vertexOffset + t) * this._floatsPerVertex,
              s = this.indexOffset + e;
          return !(i > this._initVDataCount || s > this._initIDataCount);
        }, o.uploadBuffers = function () {
          if (0 !== this.byteOffset && this._dirty) {
            for (var t = v.__isWebIOS14OrIPadOS14Env ? this._nextFreeIAHandle : 1, e = this.byteOffset, i = this.indexOffset, s = 0; s < t; ++s) {
              var r = this._iaPool[s],
                  f = new Float32Array(this.vData.buffer, 0, e >> 2),
                  n = new Uint16Array(this.iData.buffer, 0, i),
                  a = r.vertexBuffers[0];
              e > a.size && a.resize(e), a.update(f), 2 * i > r.indexBuffer.size && r.indexBuffer.resize(2 * i), r.indexBuffer.update(n);
            }

            this._dirty = !1;
          }
        }, o.createNewIA = function (t) {
          var e, i, s;

          if (v.__isWebIOS14OrIPadOS14Env || !this._iaPool[0]) {
            var u = this._vertexFormatBytes = this._floatsPerVertex * Float32Array.BYTES_PER_ELEMENT,
                o = Uint16Array.BYTES_PER_ELEMENT,
                h = t.createBuffer(new r(f.VERTEX | f.TRANSFER_DST, n.HOST | n.DEVICE, u, u));
            s = t.createBuffer(new r(f.INDEX | f.TRANSFER_DST, n.HOST | n.DEVICE, o, o)), i = [h], this._iaInfo = new a(this._attributes, i, s), e = t.createInputAssembler(this._iaInfo);
          } else e = t.createInputAssembler(this._iaInfo), i = this._iaInfo.vertexBuffers, s = this._iaInfo.indexBuffer;

          return {
            ia: e,
            vertexBuffers: i,
            indexBuffer: s
          };
        }, u(t, [{
          key: "attributes",
          get: function get() {
            return this._attributes;
          }
        }, {
          key: "vertexFormatBytes",
          get: function get() {
            return this._vertexFormatBytes;
          }
        }]), t;
      }()),
          y = function () {
        function t(t, e) {
          this._device = null, this._attributes = null, this._vertexFormatBytes = void 0, this._floatsPerVertex = void 0, this._buffers = [], this._device = t, this._attributes = e, this._floatsPerVertex = b(e), this._vertexFormatBytes = this._floatsPerVertex * Float32Array.BYTES_PER_ELEMENT;
        }

        var e = t.prototype;
        return e.initialize = function () {}, e.reset = function () {}, e.request = function () {}, e.appendBuffers = function () {}, e.uploadBuffers = function () {}, e.destroy = function () {
          this._attributes.length = 0;
        }, u(t, [{
          key: "attributes",
          get: function get() {
            return this._attributes;
          }
        }, {
          key: "vertexFormatBytes",
          get: function get() {
            return this._vertexFormatBytes;
          }
        }, {
          key: "floatsPerVertex",
          get: function get() {
            return this._floatsPerVertex;
          }
        }]), t;
      }(),
          x = new o(function () {
        return {
          offset: 0,
          length: 0
        };
      }, 32),
          g = function g(t, e, i, s) {
        this.vertexAccessor = t, this.bufferId = e, this.vertexOffset = i, this.vb = s;
      };

      t("S", function (t) {
        function e(i, s, r, f) {
          var n;
          return (n = t.call(this, i, s) || this)._freeLists = [], n._vCount = 0, n._iCount = 0, n._vCount = r || Math.floor(1024 * c.BATCHER2D_MEM_INCREMENT / n._vertexFormatBytes), n._iCount = f || n._vCount * e.IB_SCALE, n._allocateBuffer(), n;
        }

        h(e, t);
        var i = e.prototype;
        return i.destroy = function () {
          for (var e = 0; e < this._buffers.length; ++e) {
            this._buffers[e].destroy();

            for (var i = this._freeLists[e], s = 0; s < i.length; ++s) {
              x.free(i[s]);
            }
          }

          this._buffers.length = 0, this._freeLists.length = 0, t.prototype.destroy.call(this);
        }, i.reset = function () {
          for (var t = 0; t < this._buffers.length; ++t) {
            var e = this._buffers[t];
            e.indexOffset = 0, e.reset();
          }
        }, i.getVertexBuffer = function (t) {
          return this._buffers[t].vData;
        }, i.getIndexBuffer = function (t) {
          return this._buffers[t].iData;
        }, i.getMeshBuffer = function (t) {
          return this._buffers[t];
        }, i.uploadBuffers = function () {
          for (var t = 0; t < this._buffers.length; ++t) {
            var e = this._freeLists[t][0],
                i = this._buffers[t];
            (!e || e.length < i.vData.byteLength) && i.uploadBuffers();
          }
        }, i.appendIndices = function (t, e) {
          var i = this._buffers[t];
          e.length && (i.iData.set(e, i.indexOffset), i.indexOffset += e.length);
        }, i.allocateChunk = function (t, e) {
          for (var i, s = t * this.vertexFormatBytes, r = null, f = 0, n = -1, a = null, u = 0; u < this._buffers.length; ++u) {
            r = this._buffers[u], i = this._freeLists[u];

            for (var o = 0; o < i.length; ++o) {
              if (i[o].length >= s) {
                a = i[o], f = u, n = o;
                break;
              }
            }

            if (a) break;
          }

          if (a || (f = this._allocateBuffer(), (r = this._buffers[f]) && r.checkCapacity(t, e) && (n = 0, a = this._freeLists[f][n])), a) {
            var h = a.offset / this.vertexFormatBytes,
                _ = new Float32Array(r.vData.buffer, a.offset, s >> 2).fill(0);

            return this._allocateChunkFromEntry(f, n, a, s), new g(this, f, h, _, e);
          }

          return l(9004, s), null;
        }, i.recycleChunk = function (t) {
          var e = this._freeLists[t.bufferId],
              i = this._buffers[t.bufferId],
              s = t.vertexOffset * this.vertexFormatBytes,
              r = t.vb.byteLength;

          if (0 !== r) {
            for (var f = !1, n = 0, a = null, u = e[n]; u && u.offset < s;) {
              a = u, u = e[++n];
            }

            if (a && 0 == s - (a.offset + a.length) && (a.length += r, s = a.offset, r = a.length, u && u.offset - (s + r) == 0 && (a.length += u.length, e.splice(n, 1), x.free(u), u = null), f = !0), !f && u) {
              if (0 == u.offset - (s + r)) u.offset = s, u.length += r;else {
                var o = x.alloc();
                o.offset = s, o.length = r, e.splice(n, 0, o);
              }
              f = !0;
            }

            if (f) s + r === i.byteOffset && (i.byteOffset = s);else {
              var h = x.alloc();
              h.offset = s, h.length = r, e.push(h);
            }
          }
        }, i._allocateChunkFromEntry = function (t, e, i, s) {
          var r = i.length - s,
              f = i.offset + s,
              n = this._buffers[t];
          n.byteOffset < f && (n.byteOffset = f), _(r >= 0, 9004, t, i.offset, i.length), 0 === r ? (this._freeLists[t].splice(e, 1), x.free(i)) : (i.offset += s, i.length = r);
        }, i._allocateBuffer = function () {
          _(this._buffers.length === this._freeLists.length, 9003);

          var t = new d(),
              e = this._vCount * this._floatsPerVertex;
          t.initialize(this._device, this._attributes, e, this._iCount), this._buffers.push(t);
          var i = x.alloc();
          i.offset = 0, i.length = t.vData.byteLength;
          var s = [i];
          return this._freeLists.push(s), this._buffers.length - 1;
        }, e;
      }(y)).IB_SCALE = 4;
    }
  };
}); 
 			}); 
		define("__plugin__/wx0446ba2621dda60a/terrain-asset-ecb9fa31.js", function(require, module, exports){ 			
"use strict";

System.register(["./texture-barrier-60b5983b.js", "./json-asset-933a1d4c.js"], function (t) {
  "use strict";

  var e, i, n, r, s, h, a, o;
  return {
    setters: [function (t) {
      e = t.c0, i = t.bT, n = t.bU, r = t.c1, s = t.b$;
    }, function (t) {
      h = t.bW, a = t.bX, o = t.aL;
    }],
    execute: function execute() {
      t("l", 4), t("i", 4), t("k", 256);

      var l,
          f,
          u,
          g,
          _,
          c,
          y,
          w,
          b,
          I,
          v,
          d,
          p,
          k = t("c", 32),
          S = (t("b", 33), t("a", 8), t("g", 32768)),
          z = t("h", 1 / 512),
          M = (t("f", -S * z), t("e", (65535 - S) * z), t("m", 0), t("n", 1), t("o", 2), t("p", 3), t("q", 16842753)),
          m = t("r", 16842754),
          B = t("s", 16842755),
          V = t("t", 16842756),
          A = t("j", 16842757),
          C = t("u", 16843025),
          F = function () {
        function t() {
          this.length = 0, this.buffer = new Uint8Array(2048), this._buffView = new DataView(this.buffer.buffer), this._seekPos = 0;
        }

        var e = t.prototype;
        return e.reserve = function (t) {
          if (!(this.buffer.byteLength > t)) {
            for (var e = this.buffer.byteLength; e < t;) {
              e += e;
            }

            for (var i = new Uint8Array(e), n = 0; n < this.length; ++n) {
              i[n] = this.buffer[n];
            }

            this.buffer = i, this._buffView = new DataView(this.buffer.buffer);
          }
        }, e.assign = function (t) {
          this.buffer = t, this.length = t.length, this._seekPos = t.byteOffset, this._buffView = new DataView(t.buffer);
        }, e.writeInt8 = function (t) {
          this.reserve(this.length + 1), this._buffView.setInt8(this.length, t), this.length += 1;
        }, e.writeInt16 = function (t) {
          this.reserve(this.length + 2), this._buffView.setInt16(this.length, t, !0), this.length += 2;
        }, e.writeInt32 = function (t) {
          this.reserve(this.length + 4), this._buffView.setInt32(this.length, t, !0), this.length += 4;
        }, e.writeIntArray = function (t) {
          this.reserve(this.length + 4 * t.length);

          for (var e = 0; e < t.length; ++e) {
            this._buffView.setInt32(this.length + 4 * e, t[e], !0);
          }

          this.length += 4 * t.length;
        }, e.writeFloat = function (t) {
          this.reserve(this.length + 4), this._buffView.setFloat32(this.length, t, !0), this.length += 4;
        }, e.writeFloatArray = function (t) {
          this.reserve(this.length + 4 * t.length);

          for (var e = 0; e < t.length; ++e) {
            this._buffView.setFloat32(this.length + 4 * e, t[e], !0);
          }

          this.length += 4 * t.length;
        }, e.writeString = function (t) {
          this.reserve(this.length + t.length + 4), this._buffView.setInt32(this.length, t.length, !0);

          for (var e = 0; e < t.length; ++e) {
            this._buffView.setInt8(this.length + 4 + e, t.charCodeAt(e));
          }

          this.length += t.length + 4;
        }, e.readInt8 = function () {
          var t = this._buffView.getInt8(this._seekPos);

          return this._seekPos += 1, t;
        }, e.readInt16 = function () {
          var t = this._buffView.getInt16(this._seekPos, !0);

          return this._seekPos += 2, t;
        }, e.readInt = function () {
          var t = this._buffView.getInt32(this._seekPos, !0);

          return this._seekPos += 4, t;
        }, e.readIntArray = function (t) {
          for (var e = 0; e < t.length; ++e) {
            t[e] = this._buffView.getInt32(this._seekPos + 4 * e, !0);
          }

          return this._seekPos += 4 * t.length, t;
        }, e.readFloat = function () {
          var t = this._buffView.getFloat32(this._seekPos, !0);

          return this._seekPos += 4, t;
        }, e.readFloatArray = function (t) {
          for (var e = 0; e < t.length; ++e) {
            t[e] = this._buffView.getFloat32(this._seekPos + 4 * e, !0);
          }

          return this._seekPos += 4 * t.length, t;
        }, e.readString = function () {
          for (var t = this.readInt(), e = "", i = 0; i < t; ++i) {
            e += String.fromCharCode(this.readInt8());
          }

          return e;
        }, t;
      }(),
          P = (t("d", h("cc.TerrainLayerInfo")((u = e((f = function f() {
        r(this, "slot", u, this), r(this, "tileSize", g, this), r(this, "detailMap", _, this), r(this, "normalMap", c, this), r(this, "roughness", y, this), r(this, "metallic", w, this);
      }).prototype, "slot", [a], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 0;
        }
      }), g = e(f.prototype, "tileSize", [a], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 1;
        }
      }), _ = e(f.prototype, "detailMap", [a], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return null;
        }
      }), c = e(f.prototype, "normalMap", [a], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return null;
        }
      }), y = e(f.prototype, "roughness", [a], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 1;
        }
      }), w = e(f.prototype, "metallic", [a], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 0;
        }
      }), l = f)) || l), t("v", h("cc.TerrainLayerBinaryInfo")(b = function b() {
        this.slot = 0, this.tileSize = 1, this.roughness = 1, this.metallic = 0, this.detailMapId = "", this.normalMapId = "";
      }) || b));

      t("T", h("cc.TerrainAsset")((p = function (t) {
        function e() {
          var e;
          return (e = t.call(this) || this)._version = 0, e._data = null, e._tileSize = 1, e._blockCount = [1, 1], e._weightMapSize = 128, e._lightMapSize = 128, e._heights = new Uint16Array(), e._weights = new Uint8Array(), e._layerBuffer = [-1, -1, -1, -1], e._layerBinaryInfos = [], r(e, "_layerInfos", d, s(e)), e;
        }

        i(e, t);
        var h = e.prototype;
        return h.getLayer = function (t, e, i) {
          var n = 4 * (e * this.blockCount[0] + t) + i;
          return t < this.blockCount[0] && e < this.blockCount[1] && n < this._layerBuffer.length ? this._layerBuffer[n] : -1;
        }, h.getHeight = function (t, e) {
          var i = this._blockCount[0] * k + 1;
          return (this._heights[e * i + t] - S) * z;
        }, h.getVertexCountI = function () {
          return this._blockCount.length < 1 ? 0 : this._blockCount[0] * k + 1;
        }, h.getVertexCountJ = function () {
          return this._blockCount.length < 2 ? 0 : this._blockCount[1] * k + 1;
        }, h._setNativeData = function (t) {
          this._data = t;
        }, h._loadNativeData = function (t) {
          if (!t || 0 === t.length) return !1;
          var e = new F();
          if (e.assign(t), this._version = e.readInt(), this._version === C) return !0;
          if (this._version !== M && this._version !== m && this._version !== B && this._version !== V && this._version !== A) return !1;
          this.tileSize = e.readFloat(), e.readIntArray(this._blockCount), this.weightMapSize = e.readInt16(), this.lightMapSize = e.readInt16();
          var i = e.readInt();
          this.heights = new Uint16Array(i);

          for (var n = 0; n < this.heights.length; ++n) {
            this.heights[n] = e.readInt16();
          }

          var r = e.readInt();
          this.weights = new Uint8Array(r);

          for (var s = 0; s < this.weights.length; ++s) {
            this.weights[s] = e.readInt8();
          }

          if (this._version >= m) {
            var h = e.readInt();
            this.layerBuffer = new Array(h);

            for (var a = 0; a < this.layerBuffer.length; ++a) {
              this.layerBuffer[a] = e.readInt16();
            }
          }

          if (this._version >= B) {
            var o = e.readInt();
            this._layerBinaryInfos = new Array(o);

            for (var l = 0; l < this._layerBinaryInfos.length; ++l) {
              this._layerBinaryInfos[l] = new P(), this._layerBinaryInfos[l].slot = e.readInt(), this._layerBinaryInfos[l].tileSize = e.readFloat(), this._layerBinaryInfos[l].detailMapId = e.readString(), this._version >= V && (this._layerBinaryInfos[l].normalMapId = e.readString(), this._layerBinaryInfos[l].roughness = e.readFloat(), this._layerBinaryInfos[l].metallic = e.readFloat());
            }
          }

          return !0;
        }, h._exportNativeData = function () {
          var t = new F();
          t.writeInt32(A), t.writeFloat(this.tileSize), t.writeIntArray(this._blockCount), t.writeInt16(this.weightMapSize), t.writeInt16(this.lightMapSize), t.writeInt32(this.heights.length);

          for (var e = 0; e < this.heights.length; ++e) {
            t.writeInt16(this.heights[e]);
          }

          t.writeInt32(this.weights.length);

          for (var i = 0; i < this.weights.length; ++i) {
            t.writeInt8(this.weights[i]);
          }

          t.writeInt32(this.layerBuffer.length);

          for (var n = 0; n < this.layerBuffer.length; ++n) {
            t.writeInt16(this.layerBuffer[n]);
          }

          var r = [];
          r.length = this.layerInfos.length;

          for (var s = 0; s < r.length; ++s) {
            var h = this.layerInfos[s],
                a = new P();
            a.slot = s, a.tileSize = h.tileSize, a.detailMapId = h.detailMap ? h.detailMap._uuid : "", a.normalMapId = h.normalMap ? h.normalMap._uuid : "", a.metallic = h.metallic, a.roughness = h.roughness, r[s] = a;
          }

          t.writeInt32(r.length);

          for (var o = 0; o < r.length; ++o) {
            t.writeInt32(r[o].slot), t.writeFloat(r[o].tileSize), t.writeString(r[o].detailMapId), t.writeString(r[o].normalMapId), t.writeFloat(r[o].roughness), t.writeFloat(r[o].metallic);
          }

          return t.buffer;
        }, h._exportDefaultNativeData = function () {
          var t = new F();
          return t.writeInt32(C), t.buffer;
        }, n(e, [{
          key: "_nativeAsset",
          get: function get() {
            return this._data.buffer;
          },
          set: function set(t) {
            this._data && this._data.byteLength === t.byteLength ? this._data.set(new Uint8Array(t)) : this._data = new Uint8Array(t), this._loadNativeData(this._data);
          }
        }, {
          key: "version",
          get: function get() {
            return this._version;
          }
        }, {
          key: "tileSize",
          get: function get() {
            return this._tileSize;
          },
          set: function set(t) {
            this._tileSize = t;
          }
        }, {
          key: "blockCount",
          get: function get() {
            return this._blockCount;
          },
          set: function set(t) {
            this._blockCount = t;
          }
        }, {
          key: "lightMapSize",
          get: function get() {
            return this._lightMapSize;
          },
          set: function set(t) {
            this._lightMapSize = t;
          }
        }, {
          key: "weightMapSize",
          get: function get() {
            return this._weightMapSize;
          },
          set: function set(t) {
            this._weightMapSize = t;
          }
        }, {
          key: "heights",
          get: function get() {
            return this._heights;
          },
          set: function set(t) {
            this._heights = t;
          }
        }, {
          key: "weights",
          get: function get() {
            return this._weights;
          },
          set: function set(t) {
            this._weights = t;
          }
        }, {
          key: "layerBuffer",
          get: function get() {
            return this._layerBuffer;
          },
          set: function set(t) {
            this._layerBuffer = t;
          }
        }, {
          key: "layerInfos",
          get: function get() {
            return this._layerInfos;
          },
          set: function set(t) {
            this._layerInfos = t;
          }
        }, {
          key: "layerBinaryInfos",
          get: function get() {
            return this._layerBinaryInfos;
          }
        }]), e;
      }(o), d = e((v = p).prototype, "_layerInfos", [a], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return [];
        }
      }), I = v)) || I);
    }
  };
}); 
 			}); 
		define("__plugin__/wx0446ba2621dda60a/terrain.js", function(require, module, exports){ 			
"use strict";

System.register(["./texture-barrier-60b5983b.js", "./json-asset-933a1d4c.js", "./index-f2b92470.js", "./renderable-component-7c6600ed.js", "./deprecated-26630860.js", "./deprecated-ef6bb945.js", "./terrain-asset-ecb9fa31.js"], function (t) {
  "use strict";

  var e, i, r, n, s, a, o, l, h, u, _, f, c, d, g, p, b, v, y, M, w, m, x, z, k, S, I, C, L, A, E, B, P, R, T, N, D, O, U, H, V, W, F, j, X, G, K, Y, q, Z, $, Q, J, tt, et, it, rt, nt;

  return {
    setters: [function (t) {
      e = t.bU, i = t.c0, r = t.bT, n = t.l, s = t.al, a = t.o, o = t.q, l = t.aC, h = t.a_, u = t.m, _ = t.W, f = t.bG, c = t.bF, d = t.bD, g = t.c1, p = t.bC, b = t.b$;
    }, function (t) {
      v = t.aa, y = t.bW, M = t.aW, w = t.bo, m = t.aO, x = t.T, z = t.Q, k = t.a3, S = t.dT, I = t.aT, C = t.c_, L = t.dy, A = t.V, E = t.bZ, B = t.aV, P = t.cd, R = t.dP, T = t.b$, N = t.a1, D = t.bX, O = t.b6, U = t.cg, H = t.ci, V = t.bm, W = t.dr;
    }, function () {}, function (t) {
      F = t.p, j = t.f;
    }, function (t) {
      X = t.j;
    }, function (t) {
      G = t.d;
    }, function (e) {
      K = e.a, Y = e.b, q = e.c, Z = e.T, $ = e.d, Q = e.e, J = e.f, tt = e.g, et = e.h, it = e.i, rt = e.j, nt = e.k;
      var i = {};
      i.TERRAIN_BLOCK_TILE_COMPLEXITY = e.c, i.TERRAIN_BLOCK_VERTEX_COMPLEXITY = e.b, i.TERRAIN_BLOCK_VERTEX_SIZE = e.a, i.TERRAIN_DATA_VERSION = e.q, i.TERRAIN_DATA_VERSION2 = e.r, i.TERRAIN_DATA_VERSION3 = e.s, i.TERRAIN_DATA_VERSION4 = e.t, i.TERRAIN_DATA_VERSION5 = e.j, i.TERRAIN_DATA_VERSION_DEFAULT = e.u, i.TERRAIN_EAST_INDEX = e.p, i.TERRAIN_HEIGHT_BASE = e.g, i.TERRAIN_HEIGHT_FACTORY = e.h, i.TERRAIN_HEIGHT_FMAX = e.e, i.TERRAIN_HEIGHT_FMIN = e.f, i.TERRAIN_MAX_BLEND_LAYERS = e.i, i.TERRAIN_MAX_LAYER_COUNT = e.k, i.TERRAIN_MAX_LEVELS = e.l, i.TERRAIN_NORTH_INDEX = e.m, i.TERRAIN_SOUTH_INDEX = e.n, i.TERRAIN_WEST_INDEX = e.o, i.TerrainAsset = e.T, i.TerrainLayerBinaryInfo = e.v, i.TerrainLayerInfo = e.d, t(i);
    }],
    execute: function execute() {
      t("HeightField", function () {
        function t(t, e) {
          this.data = new Uint16Array(), this.w = 0, this.h = 0, this.w = t, this.h = e, this.data = new Uint16Array(t * e);

          for (var i = 0; i < t * e; ++i) {
            this.data[i] = 0;
          }
        }

        var e = t.prototype;
        return e.set = function (t, e, i) {
          this.data[e * this.w + t] = i;
        }, e.get = function (t, e) {
          return this.data[e * this.w + t];
        }, e.getClamp = function (t, e) {
          return t = v(t, 0, this.w - 1), e = v(e, 0, this.h - 1), this.get(t, e);
        }, e.getAt = function (t, e) {
          var i = t,
              r = e,
              n = Math.floor(i),
              s = Math.floor(r),
              a = n + 1,
              o = s + 1,
              l = i - n,
              h = r - s;
          n = v(n, 0, this.w - 1), s = v(s, 0, this.h - 1), a = v(a, 0, this.w - 1), o = v(o, 0, this.h - 1);

          var u = this.get(n, s),
              _ = this.get(a, s),
              f = this.get(n, o),
              c = this.get(a, o),
              d = .5 * (_ + f);

          return l + h <= 1 ? c = d + (d - u) : u = d + (d - c), (u * (1 - l) + _ * l) * (1 - h) + (f * (1 - l) + c * l) * h;
        }, t;
      }());

      var st,
          at,
          ot,
          lt,
          ht,
          ut,
          _t,
          ft,
          ct,
          dt,
          gt,
          pt,
          bt,
          vt,
          yt,
          Mt,
          wt,
          mt,
          xt,
          zt,
          kt,
          St,
          It,
          Ct,
          Lt,
          At,
          Et,
          Bt,
          Pt,
          Rt,
          Tt,
          Nt,
          Dt,
          Ot,
          Ut,
          Ht,
          Vt,
          Wt,
          Ft,
          jt,
          Xt,
          Gt,
          Kt,
          Yt,
          qt,
          Zt,
          $t,
          Qt,
          Jt = 33,
          te = 1e14,
          ee = function () {
        function t() {
          this.level = 0, this.north = 0, this.south = 0, this.west = 0, this.east = 0;
        }

        return t.prototype.equals = function (t) {
          return this.level === t.level && this.north === t.north && this.south === t.south && this.west === t.west && this.east === t.east;
        }, t;
      }(),
          ie = function ie() {
        this.size = 0, this.indices = null;
      },
          re = function re() {
        this.key = new ee(), this.start = 0, this.size = 0, this.buffer = null, this.primCount = 0;
      },
          ne = function () {
        function t() {
          this._bodyIndexPool = void 0, this._connecterIndexPool = void 0, this._indexMap = [], this._indexBuffer = new Uint16Array(), this._bodyIndexPool = new Array(4);

          for (var e = 0; e < 4; ++e) {
            this._bodyIndexPool[e] = new ie();
          }

          this._connecterIndexPool = new Array(64);

          for (var i = 0; i < 4; ++i) {
            for (var r = 0; r < 4; ++r) {
              for (var n = 0; n < 4; ++n) {
                this._connecterIndexPool[t.mapIndex(i, r, n)] = new ie();
              }
            }
          }

          for (var s = 0; s < 4; ++s) {
            this._genBodyIndex(s);
          }

          for (var a = 0; a < 4; ++a) {
            for (var o = 0; o < 4; ++o) {
              this._genConnecterIndexNorth(a, o), this._genConnecterIndexSouth(a, o), this._genConnecterIndexWest(a, o), this._genConnecterIndexEast(a, o);
            }
          }

          for (var l = 0; l < 4; ++l) {
            for (var h = 0; h < 4; ++h) {
              if (!(h < l)) for (var u = 0; u < 4; ++u) {
                if (!(u < l)) for (var _ = 0; _ < 4; ++_) {
                  if (!(_ < l)) for (var f = 0; f < 4; ++f) {
                    if (!(f < l)) {
                      var c = new ee();
                      c.level = l, c.north = h, c.south = u, c.west = _, c.east = f, this._genIndexData(c);
                    }
                  }
                }
              }
            }
          }
        }

        t.mapIndex = function (t, e, i) {
          return 16 * t + 4 * e + i;
        };

        var e = t.prototype;
        return e.getIndexData = function (t) {
          for (var e = 0; e < this._indexMap.length; ++e) {
            if (this._indexMap[e].key.equals(t)) return this._indexMap[e];
          }

          return null;
        }, e._genBodyIndex = function (t) {
          var e = 1 << t,
              i = 32 >> t,
              r = 0;

          if (t < 3 && (i -= 2, r = e * Jt + e), 0 !== i && 0 !== i) {
            var n = i * i * 6;
            this._bodyIndexPool[t].indices = new Uint16Array(n);

            for (var s = 0, a = new Uint16Array(n), o = r, l = o + Jt * e, h = 0; h < i; ++h) {
              for (var u = 0; u < i; ++u) {
                a[s++] = l + u * e, a[s++] = l + (u + 1) * e, a[s++] = o + u * e, a[s++] = l + (u + 1) * e, a[s++] = o + (u + 1) * e, a[s++] = o + u * e;
              }

              o += Jt * e, l += Jt * e;
            }

            this._bodyIndexPool[t].size = s, this._bodyIndexPool[t].indices = a;
          }
        }, e._genConnecterIndexNorth = function (e, i) {
          var r = t.mapIndex(e, i, 0);
          if (i < e || 3 === e) return this._connecterIndexPool[r].size = 0, void (this._connecterIndexPool[r].indices = null);
          var n = 1 << e,
              s = 1 << i,
              a = 32 >> e,
              o = 0,
              l = new Uint16Array(2 * a + 2);
          l[o++] = 0, l[o++] = 0;

          for (var h = 1; h < a; ++h) {
            var u = h * n,
                _ = n * Jt + u,
                f = (n - n) * Jt + u / s * s;

            l[o++] = _, l[o++] = f;
          }

          l[o++] = 32, l[o++] = 32, this._connecterIndexPool[r].size = o, this._connecterIndexPool[r].indices = l;
        }, e._genConnecterIndexSouth = function (e, i) {
          var r = t.mapIndex(e, i, 1);
          if (i < e || 3 === e) return this._connecterIndexPool[r].size = 0, void (this._connecterIndexPool[r].indices = null);
          var n = 1 << e,
              s = 1 << i,
              a = 32 >> e,
              o = 0,
              l = new Uint16Array(2 * a + 2);
          l[o++] = 1056, l[o++] = 1056;

          for (var h = 1; h < a; ++h) {
            var u = h * n,
                _ = 32 - n,
                f = (_ + n) * Jt + u / s * s,
                c = _ * Jt + u;

            l[o++] = f, l[o++] = c;
          }

          l[o++] = 1088, l[o++] = 1088, this._connecterIndexPool[r].size = o, this._connecterIndexPool[r].indices = l;
        }, e._genConnecterIndexWest = function (e, i) {
          var r = t.mapIndex(e, i, 2);
          if (i < e || 3 === e) return this._connecterIndexPool[r].size = 0, void (this._connecterIndexPool[r].indices = null);
          var n = 1 << e,
              s = 1 << i,
              a = 32 >> e,
              o = 0,
              l = new Uint16Array(2 * a + 2);
          l[o++] = 0, l[o++] = 0;

          for (var h = 1; h < a; ++h) {
            var u = h * n / s * s * Jt + 0,
                _ = h * n * Jt + n;

            l[o++] = u, l[o++] = _;
          }

          l[o++] = 1056, l[o++] = 1056, this._connecterIndexPool[r].size = o, this._connecterIndexPool[r].indices = l;
        }, e._genConnecterIndexEast = function (e, i) {
          var r = t.mapIndex(e, i, 3);
          if (i < e || 3 === e) return this._connecterIndexPool[r].size = 0, void (this._connecterIndexPool[r].indices = null);
          var n = 1 << e,
              s = 1 << i,
              a = 32 >> e,
              o = 0,
              l = new Uint16Array(2 * a + 2);
          l[o++] = 32, l[o++] = 32;

          for (var h = 1; h < a; ++h) {
            var u = h * n * Jt + (32 - n),
                _ = h * n / s * s * Jt + 32;

            l[o++] = u, l[o++] = _;
          }

          l[o++] = 1088, l[o++] = 1088, this._connecterIndexPool[r].size = o, this._connecterIndexPool[r].indices = l;
        }, e._getConnenterIndex = function (e, i, r) {
          return this._connecterIndexPool[t.mapIndex(e, i, r)];
        }, e._genIndexData = function (t) {
          var e = this.getIndexData(t);
          if (null != e) return e;

          var i = this._bodyIndexPool[t.level],
              r = this._getConnenterIndex(t.level, t.north, 0),
              n = this._getConnenterIndex(t.level, t.south, 1),
              s = this._getConnenterIndex(t.level, t.west, 2),
              a = this._getConnenterIndex(t.level, t.east, 3);

          if ((e = new re()).size = 0, e.primCount = 0, null != i.indices && (e.size += i.size), r.indices && (e.size += 3 * (r.size - 2)), n.indices && (e.size += 3 * (n.size - 2)), s.indices && (e.size += 3 * (s.size - 2)), a.indices && (e.size += 3 * (a.size - 2)), 0 === e.size) return null;
          var o = 0;
          if (e.buffer = new Uint16Array(e.size), e.key.level = t.level, e.key.east = t.east, e.key.west = t.west, e.key.north = t.north, e.key.south = t.south, i.indices) for (var l = 0; l < i.size; ++l) {
            e.buffer[o++] = i.indices[l];
          }
          if (r.indices) for (var h = 0; h < r.size - 2; h += 2) {
            var u = r.indices[h + 0],
                _ = r.indices[h + 1],
                f = r.indices[h + 2],
                c = r.indices[h + 3];
            e.buffer[o++] = u, e.buffer[o++] = f, e.buffer[o++] = _, e.buffer[o++] = f, e.buffer[o++] = c, e.buffer[o++] = _;
          }
          if (n.indices) for (var d = 0; d < n.size - 2; d += 2) {
            var g = n.indices[d + 0],
                p = n.indices[d + 1],
                b = n.indices[d + 2],
                v = n.indices[d + 3];
            e.buffer[o++] = g, e.buffer[o++] = b, e.buffer[o++] = p, e.buffer[o++] = b, e.buffer[o++] = v, e.buffer[o++] = p;
          }
          if (s.indices) for (var y = 0; y < s.size - 2; y += 2) {
            var M = s.indices[y + 0],
                w = s.indices[y + 1],
                m = s.indices[y + 2],
                x = s.indices[y + 3];
            e.buffer[o++] = M, e.buffer[o++] = m, e.buffer[o++] = w, e.buffer[o++] = m, e.buffer[o++] = x, e.buffer[o++] = w;
          }
          if (a.indices) for (var z = 0; z < a.size - 2; z += 2) {
            var k = a.indices[z + 0],
                S = a.indices[z + 1],
                I = a.indices[z + 2],
                C = a.indices[z + 3];
            e.buffer[o++] = k, e.buffer[o++] = I, e.buffer[o++] = S, e.buffer[o++] = I, e.buffer[o++] = C, e.buffer[o++] = S;
          }
          e.primCount = o / 3, e.start = this._indexBuffer.length, this._indexMap.push(e);
          var L = new Uint16Array(e.start + e.size);
          return L.set(this._indexBuffer, 0), L.set(e.buffer, e.start), this._indexBuffer = L, e;
        }, t;
      }(),
          se = t("TerrainInfo", y("cc.TerrainInfo")((_t = function () {
        function t() {
          g(this, "tileSize", ot, this), g(this, "blockCount", lt, this), g(this, "weightMapSize", ht, this), g(this, "lightMapSize", ut, this);
        }

        return e(t, [{
          key: "size",
          get: function get() {
            var t = new N(0, 0);
            return t.width = this.blockCount[0] * q * this.tileSize, t.height = this.blockCount[1] * q * this.tileSize, t;
          }
        }, {
          key: "tileCount",
          get: function get() {
            var t = [0, 0];
            return t[0] = this.blockCount[0] * q, t[1] = this.blockCount[1] * q, t;
          }
        }, {
          key: "vertexCount",
          get: function get() {
            var t = this.tileCount;
            return t[0] += 1, t[1] += 1, t;
          }
        }]), t;
      }(), ot = i((at = _t).prototype, "tileSize", [D, T], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 1;
        }
      }), lt = i(at.prototype, "blockCount", [D, T], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return [1, 1];
        }
      }), ht = i(at.prototype, "weightMapSize", [D, T], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 128;
        }
      }), ut = i(at.prototype, "lightMapSize", [D, T], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 128;
        }
      }), st = at)) || st),
          ae = t("TerrainLayer", y("cc.TerrainLayer")((dt = i((ct = function ct() {
        g(this, "detailMap", dt, this), g(this, "normalMap", gt, this), g(this, "tileSize", pt, this), g(this, "metallic", bt, this), g(this, "roughness", vt, this);
      }).prototype, "detailMap", [D, T], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return null;
        }
      }), gt = i(ct.prototype, "normalMap", [D, T], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return null;
        }
      }), pt = i(ct.prototype, "tileSize", [D, T], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 1;
        }
      }), bt = i(ct.prototype, "metallic", [D, T], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 0;
        }
      }), vt = i(ct.prototype, "roughness", [D, T], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 1;
        }
      }), ft = ct)) || ft),
          oe = function (t) {
        function e() {
          for (var e, i = arguments.length, r = new Array(i), n = 0; n < i; n++) {
            r[n] = arguments[n];
          }

          return (e = t.call.apply(t, [this].concat(r)) || this)._model = null, e._meshData = null, e._brushPass = null, e._brushMaterial = null, e._currentMaterial = null, e._currentMaterialLayers = 0, e;
        }

        r(e, t);
        var i = e.prototype;
        return i.destroy = function () {
          return null != this._model && (n.director.root.destroyModel(this._model), this._model = null), t.prototype.destroy.call(this);
        }, i._destroyModel = function () {
          null != this._model && (n.director.root.destroyModel(this._model), this._model = null);
        }, i._invalidMaterial = function () {
          null != this._currentMaterial && (this._clearMaterials(), this._brushPass = null, this._currentMaterial = null, null != this._model && (this._model.enabled = !1));
        }, i._updateMaterial = function (t, e) {
          if (null == this._meshData || null == this._model) return !1;
          var i = t.getMaxLayer();

          if (null == this._currentMaterial || i !== this._currentMaterialLayers) {
            if (this._currentMaterial = new M(), this._currentMaterial.initialize({
              effectAsset: t.getTerrain().getEffectAsset(),
              defines: t._getMaterialDefines(i)
            }), null !== this._brushMaterial) {
              var r = new M();
              r.copy(this._brushMaterial), this._brushPass = null, null !== r.passes && r.passes.length > 0 && (this._brushPass = r.passes[0], this._currentMaterial.passes.push(this._brushPass), r.passes.pop());
            }

            return e && this._model.initSubModel(0, this._meshData, this._currentMaterial), this.setMaterial(this._currentMaterial, 0), this._currentMaterialLayers = i, this._model.enabled = !0, this._model.receiveShadow = t.getTerrain().receiveShadow, !0;
          }

          return !1;
        }, i._onMaterialModified = function (t, e) {
          null != this._model && this._onRebuildPSO(t, e || this._getBuiltinMaterial());
        }, i._onRebuildPSO = function (t, e) {
          this._model && this._model.setSubModelMaterial(t, e);
        }, i._clearMaterials = function () {
          null != this._model && this._onMaterialModified(0, null);
        }, i._getBuiltinMaterial = function () {
          return w.get("missing-material");
        }, e;
      }(F),
          le = t("TerrainBlockLightmapInfo", y("cc.TerrainBlockLightmapInfo")((wt = i((Mt = function Mt() {
        g(this, "texture", wt, this), g(this, "UOff", mt, this), g(this, "VOff", xt, this), g(this, "UScale", zt, this), g(this, "VScale", kt, this);
      }).prototype, "texture", [D, T], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return null;
        }
      }), mt = i(Mt.prototype, "UOff", [D, T], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 0;
        }
      }), xt = i(Mt.prototype, "VOff", [D, T], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 0;
        }
      }), zt = i(Mt.prototype, "UScale", [D, T], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 0;
        }
      }), kt = i(Mt.prototype, "VScale", [D, T], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 0;
        }
      }), yt = Mt)) || yt),
          he = t("TerrainBlock", function () {
        function t(t, e, i) {
          this._terrain = void 0, this._node = void 0, this._renderable = void 0, this._index = [1, 1], this._weightMap = null, this._lightmapInfo = null, this._lodLevel = 0, this._lodKey = new ee(), this._errorMetrics = [0, 0, 0, 0], this._LevelDistances = [te, te, te, te], this._bbMin = new z(), this._bbMax = new z(), this._terrain = t, this._index[0] = e, this._index[1] = i, this._lightmapInfo = t._getLightmapInfo(e, i), this._node = new O("TerrainBlock"), this._node.setParent(this._terrain.node), this._node.hideFlags |= p.Flags.DontSave | p.Flags.HideInHierarchy, this._node.layer = this._terrain.node.layer, this._renderable = this._node.addComponent(oe);
        }

        var i = t.prototype;
        return i.build = function () {
          var t = G.root.device,
              e = new Float32Array(K * Y * Y);

          this._buildVertexData(e);

          var i = t.createBuffer(new s(a.VERTEX | a.TRANSFER_DST, o.DEVICE, K * Float32Array.BYTES_PER_ELEMENT * Y * Y, K * Float32Array.BYTES_PER_ELEMENT));
          i.update(e), this._buildBoundingBox();
          var r = [new l(h.ATTR_POSITION, u.RGB32F), new l(h.ATTR_NORMAL, u.RGB32F), new l(h.ATTR_TEX_COORD, u.RG32F)];
          this._renderable._meshData = new m([i], r, _.TRIANGLE_LIST, this._terrain._getSharedIndexBuffer(), null, !1), this._renderable._model = n.director.root.createModel(j), this._renderable._model.createBoundingShape(this._bbMin, this._bbMax), this._renderable._model.node = this._renderable._model.transform = this._node, null != this._renderable.node.scene && (this.visible = !0), this._updateWeightMap(), this._updateMaterial(!0), this._updateLodBuffer(e), this._updateIndexBuffer();
        }, i.rebuild = function () {
          this._updateHeight(), this._updateWeightMap(), this._renderable._invalidMaterial(), this._updateMaterial(!1);
        }, i.destroy = function () {
          this.visible = !1, this._renderable._destroyModel(), null != this._node && this._node.isValid && this._node.destroy(), null != this._weightMap && this._weightMap.destroy();
        }, i.update = function () {
          this._updateMaterial(!1);

          var t = this._terrain.useNormalMap,
              e = this._terrain.usePBR,
              i = function i(t) {
            return null !== t ? t.detailMap : null;
          },
              r = function r(t) {
            var e = null !== t ? t.normalMap : null;
            return null === e && (e = n.builtinResMgr.get("normal-texture")), e;
          },
              s = this._renderable._currentMaterial;

          if (null !== s) {
            var a = this.getMaxLayer(),
                o = new x(1, 1, 1, 1),
                l = new x(1, 1, 1, 1),
                h = new x(0, 0, 0, 0);
            if (0 === a) {
              if (-1 !== this.layers[0]) {
                var u = this._terrain.getLayer(this.layers[0]);

                null !== u && (o.x = 1 / u.tileSize, l.x = u.roughness, h.x = u.metallic), s.setProperty("detailMap0", i(u)), t && s.setProperty("normalMap0", r(u));
              } else s.setProperty("detailMap0", n.builtinResMgr.get("default-texture")), t && s.setProperty("normalMap0", n.builtinResMgr.get("normal-texture"));
            } else if (1 === a) {
              var _ = this._terrain.getLayer(this.layers[0]),
                  f = this._terrain.getLayer(this.layers[1]);

              null !== _ && (o.x = 1 / _.tileSize, l.x = _.roughness, h.x = _.metallic), null !== f && (o.y = 1 / f.tileSize, l.y = f.roughness, h.y = f.metallic), s.setProperty("weightMap", this._weightMap), s.setProperty("detailMap0", i(_)), s.setProperty("detailMap1", i(f)), t && (s.setProperty("normalMap0", r(_)), s.setProperty("normalMap1", r(f)));
            } else if (2 === a) {
              var c = this._terrain.getLayer(this.layers[0]),
                  d = this._terrain.getLayer(this.layers[1]),
                  g = this._terrain.getLayer(this.layers[2]);

              null !== c && (o.x = 1 / c.tileSize, l.x = c.roughness, h.x = c.metallic), null !== d && (o.y = 1 / d.tileSize, l.y = d.roughness, h.y = d.metallic), null !== g && (o.z = 1 / g.tileSize, l.z = g.roughness, h.z = g.metallic), s.setProperty("weightMap", this._weightMap), s.setProperty("detailMap0", i(c)), s.setProperty("detailMap1", i(d)), s.setProperty("detailMap2", i(g)), t && (s.setProperty("normalMap0", r(c)), s.setProperty("normalMap1", r(d)), s.setProperty("normalMap2", r(g)));
            } else if (3 === a) {
              var p = this._terrain.getLayer(this.layers[0]),
                  b = this._terrain.getLayer(this.layers[1]),
                  v = this._terrain.getLayer(this.layers[2]),
                  y = this._terrain.getLayer(this.layers[3]);

              null !== p && (o.x = 1 / p.tileSize, l.x = p.roughness, h.x = p.metallic), null !== b && (o.y = 1 / b.tileSize, l.y = b.roughness, h.y = b.metallic), null !== v && (o.z = 1 / v.tileSize, l.z = v.roughness, h.z = v.metallic), null !== y && (o.w = 1 / y.tileSize, l.w = y.roughness, h.w = y.metallic), s.setProperty("weightMap", this._weightMap), s.setProperty("detailMap0", i(p)), s.setProperty("detailMap1", i(b)), s.setProperty("detailMap2", i(v)), s.setProperty("detailMap3", i(y)), t && (s.setProperty("normalMap0", r(p)), s.setProperty("normalMap1", r(b)), s.setProperty("normalMap2", r(v)), s.setProperty("normalMap3", r(y)));
            }
            s.setProperty("UVScale", o), e && (s.setProperty("roughness", l), s.setProperty("metallic", h)), null !== this.lightmap && (s.setProperty("lightMap", this.lightmap), s.setProperty("lightMapUVParam", this.lightmapUVParam));
          }
        }, i._updateLevel = function (t) {
          var e = new z(),
              i = new z();
          z.add(e, this._bbMin, this._terrain.node.getWorldPosition()), z.add(i, this._bbMax, this._terrain.node.getWorldPosition());
          var r = z.distance(e, t),
              n = z.distance(i, t),
              s = Math.min(r, n);

          for (s -= this._terrain.LodBias, this._lodLevel = 0; this._lodLevel < 3 && !(s <= this._LevelDistances[this._lodLevel + 1]);) {
            ++this._lodLevel;
          }
        }, i.setBrushMaterial = function (t) {
          this._renderable._brushMaterial !== t && (this._renderable._invalidMaterial(), this._renderable._brushMaterial = t);
        }, i._getBrushMaterial = function () {
          return this._renderable ? this._renderable._brushMaterial : null;
        }, i._getBrushPass = function () {
          return this._renderable ? this._renderable._brushPass : null;
        }, i.getTerrain = function () {
          return this._terrain;
        }, i.getIndex = function () {
          return this._index;
        }, i.getRect = function () {
          var t = new k();
          return t.x = this._index[0] * q, t.y = this._index[1] * q, t.width = q, t.height = q, t;
        }, i.setLayer = function (t, e) {
          this.layers[t] !== e && (this._terrain.setBlockLayer(this._index[0], this._index[1], t, e), this._renderable._invalidMaterial(), this._updateMaterial(!1));
        }, i.getLayer = function (t) {
          return this.layers[t];
        }, i.getMaxLayer = function () {
          return this.layers[3] >= 0 ? 3 : this.layers[2] >= 0 ? 2 : this.layers[1] >= 0 ? 1 : 0;
        }, i._getMaterialDefines = function (t) {
          return {
            LAYERS: t + 1,
            CC_USE_LIGHTMAP: null !== this.lightmap ? 1 : 0,
            USE_NORMALMAP: this._terrain.useNormalMap ? 1 : 0,
            USE_PBR: this._terrain.usePBR ? 1 : 0
          };
        }, i._invalidMaterial = function () {
          this._renderable._invalidMaterial();
        }, i._updateMaterial = function (t) {
          this._renderable._updateMaterial(this, t) && null !== this.lightmap && this.lightmap.setWrapMode(S.CLAMP_TO_BORDER, S.CLAMP_TO_BORDER);
        }, i._updateHeight = function () {
          if (null != this._renderable._meshData) {
            var t = new Float32Array(K * Y * Y);
            this._buildVertexData(t), this._renderable._meshData.vertexBuffers[0].update(t), this._buildBoundingBox(), this._renderable._model.createBoundingShape(this._bbMin, this._bbMax), this._renderable._model.updateWorldBound(), this._updateLodBuffer(t), this._updateIndexBuffer();
          }
        }, i._updateWeightMap = function () {
          if (0 !== this.getMaxLayer()) {
            null == this._weightMap && (this._weightMap = new I(), this._weightMap.create(this._terrain.weightMapSize, this._terrain.weightMapSize, C.RGBA8888), this._weightMap.setFilters(L.LINEAR, L.LINEAR), this._weightMap.setWrapMode(S.CLAMP_TO_EDGE, S.CLAMP_TO_EDGE));

            for (var t = new Uint8Array(this._terrain.weightMapSize * this._terrain.weightMapSize * 4), e = 0, i = 0; i < this._terrain.weightMapSize; ++i) {
              for (var r = 0; r < this._terrain.weightMapSize; ++r) {
                var n = this._index[0] * this._terrain.weightMapSize + r,
                    s = this._index[1] * this._terrain.weightMapSize + i,
                    a = this._terrain.getWeight(n, s);

                t[4 * e + 0] = Math.floor(255 * a.x), t[4 * e + 1] = Math.floor(255 * a.y), t[4 * e + 2] = Math.floor(255 * a.z), t[4 * e + 3] = Math.floor(255 * a.w), e += 1;
              }
            }

            this._weightMap.uploadData(t);
          } else null != this._weightMap && (this._weightMap.destroy(), this._weightMap = null);
        }, i._updateLightmap = function (t) {
          this._lightmapInfo = t, this._invalidMaterial();
        }, i._updateLod = function () {
          var t = new ee();

          if (t.level = this._lodLevel, t.north = this._lodLevel, t.south = this._lodLevel, t.west = this._lodLevel, t.east = this._lodLevel, this._index[0] > 0) {
            var e = this.getTerrain().getBlock(this._index[0] - 1, this._index[1]);
            t.west = e._lodLevel, t.west < this._lodLevel && (t.west = this._lodLevel);
          }

          if (this._index[0] < this._terrain.info.blockCount[0] - 1) {
            var i = this.getTerrain().getBlock(this._index[0] + 1, this._index[1]);
            t.east = i._lodLevel, t.east < this._lodLevel && (t.east = this._lodLevel);
          }

          if (this._index[1] > 0) {
            var r = this.getTerrain().getBlock(this._index[0], this._index[1] - 1);
            t.north = r._lodLevel, t.north < this._lodLevel && (t.north = this._lodLevel);
          }

          if (this._index[1] < this._terrain.info.blockCount[1] - 1) {
            var n = this.getTerrain().getBlock(this._index[0], this._index[1] + 1);
            t.south = n._lodLevel, t.south < this._lodLevel && (t.south = this._lodLevel);
          }

          this._lodKey.equals(t) || (this._lodKey = t, this._updateIndexBuffer());
        }, i._resetLod = function () {
          var t = new ee();
          t.level = 0, t.north = 0, t.south = 0, t.west = 0, t.east = 0, this._lodKey.equals(t) || (this._lodKey = t, this._updateIndexBuffer());
        }, i._updateIndexBuffer = function () {
          if (null !== this._renderable._meshData && null !== this._renderable._model && 0 !== this._renderable._model.subModels.length) {
            var t = this._terrain._getIndexData(this._lodKey);

            if (null !== t) {
              var e = this._renderable._model.subModels[0];
              e.inputAssembler.firstIndex = t.start, e.inputAssembler.indexCount = t.size;
            }
          }
        }, i._getHeight = function (t, e, i) {
          return i[(Y * e + t) * K + 1];
        }, i._updateLodBuffer = function (t) {
          this._lodLevel = 0, this._lodKey = new ee(), this._calcErrorMetrics(t), this._calcLevelDistances(t);
        }, i._calcErrorMetrics = function (t) {
          this._errorMetrics[0] = 0;

          for (var e = 1; e < 4; ++e) {
            this._errorMetrics[e] = this._calcErrorMetric(e, t);
          }

          for (var i = 2; i < 4; ++i) {
            this._errorMetrics[i] = Math.max(this._errorMetrics[i], this._errorMetrics[i - 1]);
          }
        }, i._calcErrorMetric = function (t, e) {
          for (var i = 0, r = 1 << t, n = Y, s = Y, a = n - 1 >> t, o = s - 1 >> t, l = 0; l < s; l += r) {
            for (var h = 0; h < a; ++h) {
              var u = h * r,
                  _ = u + r,
                  f = (_ + u) / 2,
                  c = this._getHeight(u, l, e),
                  d = this._getHeight(_, l, e),
                  g = this._getHeight(f, l, e),
                  p = (c + d) / 2,
                  b = Math.abs(g - p);

              i = Math.max(i, b);
            }
          }

          for (var v = 0; v < n; v += r) {
            for (var y = 0; y < o; ++y) {
              var M = y * r,
                  w = M + r,
                  m = (M + w) / 2,
                  x = this._getHeight(v, M, e),
                  z = this._getHeight(v, w, e),
                  k = this._getHeight(v, m, e),
                  S = (x + z) / 2,
                  I = Math.abs(k - S);

              i = Math.max(i, I);
            }
          }

          for (var C = 0; C < o; ++C) {
            for (var L = C * r, A = L + r, E = (L + A) / 2, B = 0; B < a; ++B) {
              var P = B * r,
                  R = P + r,
                  T = (P + R) / 2,
                  N = this._getHeight(P, L, e),
                  D = this._getHeight(R, A, e),
                  O = this._getHeight(T, E, e),
                  U = (N + D) / 2,
                  H = Math.abs(O - U);

              i = Math.max(i, H);
            }
          }

          return i;
        }, i._calcLevelDistances = function () {
          for (var t = 1; t < 4; ++t) {
            var e = 96 * this._errorMetrics[t];
            this._LevelDistances[t] = e;
          }
        }, i._buildVertexData = function (t) {
          for (var e = 0, i = 0; i < Y; ++i) {
            for (var r = 0; r < Y; ++r) {
              var n = this._index[0] * q + r,
                  s = this._index[1] * q + i,
                  a = this._terrain.getPosition(n, s),
                  o = this._terrain.getNormal(n, s),
                  l = new A(r / q, i / q);

              t[e++] = a.x, t[e++] = a.y, t[e++] = a.z, t[e++] = o.x, t[e++] = o.y, t[e++] = o.z, t[e++] = l.x, t[e++] = l.y;
            }
          }
        }, i._buildBoundingBox = function () {
          this._bbMin.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), this._bbMax.set(Number.MIN_VALUE, Number.MIN_VALUE, Number.MIN_VALUE);

          for (var t = 0; t < Y; ++t) {
            for (var e = 0; e < Y; ++e) {
              var i = this._index[0] * q + e,
                  r = this._index[1] * q + t,
                  n = this._terrain.getPosition(i, r);

              z.min(this._bbMin, this._bbMin, n), z.max(this._bbMax, this._bbMax, n);
            }
          }
        }, e(t, [{
          key: "valid",
          get: function get() {
            if (null === this._terrain) return !1;

            for (var t = this._terrain.getBlocks(), e = 0; e < t.length; ++e) {
              if (t[e] === this) return !0;
            }

            return !1;
          }
        }, {
          key: "material",
          get: function get() {
            return this._renderable ? this._renderable._currentMaterial : null;
          }
        }, {
          key: "layers",
          get: function get() {
            return this._terrain.getBlockLayers(this._index[0], this._index[1]);
          }
        }, {
          key: "weightmap",
          get: function get() {
            return this._weightMap;
          }
        }, {
          key: "lightmap",
          get: function get() {
            return this._lightmapInfo ? this._lightmapInfo.texture : null;
          }
        }, {
          key: "lightmapUVParam",
          get: function get() {
            return null != this._lightmapInfo ? new x(this._lightmapInfo.UOff, this._lightmapInfo.VOff, this._lightmapInfo.UScale, this._lightmapInfo.VScale) : new x(0, 0, 0, 0);
          }
        }, {
          key: "visible",
          get: function get() {
            return null !== this._renderable._model && null !== this._renderable._model.scene;
          },
          set: function set(t) {
            null !== this._renderable._model && (t ? null != this._terrain.node && null != this._terrain.node.scene && null != this._terrain.node.scene.renderScene && null == this._renderable._model.scene && this._terrain.node.scene.renderScene.addModel(this._renderable._model) : null !== this._renderable._model.scene && this._renderable._model.scene.removeModel(this._renderable._model));
          }
        }]), t;
      }());

      t("Terrain", (St = y("cc.Terrain"), It = U(), Ct = E(Z), Lt = E(B), At = H(), Et = E(le), Bt = E(f), Pt = E(f), Rt = E(f), Tt = E(f), Nt = E(c), Dt = E(Z), Ot = H(), Ut = E(B), Ht = H(), Vt = E(se), St(Wt = It(Wt = P(Wt = R((Qt = function (t) {
        function i() {
          var e;
          e = t.call(this) || this, g(e, "__asset", jt, b(e)), g(e, "_effectAsset", Xt, b(e)), g(e, "_lightmapInfos", Gt, b(e)), g(e, "_receiveShadow", Kt, b(e)), g(e, "_useNormalmap", Yt, b(e)), g(e, "_usePBR", qt, b(e)), g(e, "_lodEnable", Zt, b(e)), g(e, "_lodBias", $t, b(e)), e._buitinAsset = null, e._tileSize = 1, e._blockCount = [1, 1], e._weightMapSize = 128, e._lightMapSize = 128, e._heights = new Uint16Array(), e._weights = new Uint8Array(), e._normals = [], e._layerList = [], e._layerBuffer = [], e._blocks = [], e._lod = new ne(), e._sharedIndexBuffer = null;

          for (var i = 0; i < nt; ++i) {
            e._layerList.push(null);
          }

          return e;
        }

        r(i, t);
        var l = i.prototype;
        return l.build = function (t) {
          return this._tileSize = t.tileSize, this._blockCount[0] = t.blockCount[0], this._blockCount[1] = t.blockCount[1], this._weightMapSize = t.weightMapSize, this._lightMapSize = t.lightMapSize, this._buildImp();
        }, l.rebuild = function (t) {
          for (var e = 0; e < this._blocks.length; ++e) {
            this._blocks[e].destroy();
          }

          this._blocks = [], this._resetLightmap(!1), this._rebuildLayerBuffer(t), this._rebuildHeights(t), this._rebuildWeights(t), this._tileSize = t.tileSize, this._blockCount[0] = t.blockCount[0], this._blockCount[1] = t.blockCount[1], this._weightMapSize = t.weightMapSize, this._lightMapSize = t.lightMapSize, this._buildNormals();

          for (var i = 0; i < this._blockCount[1]; ++i) {
            for (var r = 0; r < this._blockCount[0]; ++r) {
              this._blocks.push(new he(this, r, i));
            }
          }

          for (var n = 0; n < this._blocks.length; ++n) {
            this._blocks[n].build();
          }
        }, l.importHeightField = function (t, e) {
          for (var i = 0, r = 0; r < this.vertexCount[1]; ++r) {
            for (var n = 0; n < this.vertexCount[0]; ++n) {
              var s = n / this.tileCount[0],
                  a = r / this.tileCount[1],
                  o = t.getAt(s * t.w, a * t.h) * e;
              this._heights[i++] = o;
            }
          }

          this._buildNormals();

          for (var l = 0; l < this._blocks.length; ++l) {
            this._blocks[l]._updateHeight();
          }
        }, l.exportHeightField = function (t, e) {
          for (var i = 0, r = 0; r < t.h; ++r) {
            for (var n = 0; n < t.w; ++n) {
              var s = n / (t.w - 1),
                  a = r / (t.h - 1),
                  o = s * this.size.width,
                  l = a * this.size.height,
                  h = this.getHeightAt(o, l);
              null != h && (t.data[i++] = h * e);
            }
          }
        }, l.exportAsset = function () {
          var t = new Z();
          t.tileSize = this.tileSize, t.blockCount = this.blockCount, t.lightMapSize = this.lightMapSize, t.weightMapSize = this.weightMapSize, t.heights = this.heights, t.weights = this.weights, t.layerBuffer = new Array(4 * this._blocks.length);

          for (var e = 0; e < this._blocks.length; ++e) {
            t.layerBuffer[4 * e + 0] = this._blocks[e].layers[0], t.layerBuffer[4 * e + 1] = this._blocks[e].layers[1], t.layerBuffer[4 * e + 2] = this._blocks[e].layers[2], t.layerBuffer[4 * e + 3] = this._blocks[e].layers[3];
          }

          for (var i = 0; i < this._layerList.length; ++i) {
            var r = this._layerList[i];

            if (r && r.detailMap && d(r.detailMap)) {
              var n = new $();
              n.slot = i, n.tileSize = r.tileSize, n.detailMap = r.detailMap, n.normalMap = r.normalMap, n.metallic = r.metallic, n.roughness = r.roughness, t.layerInfos.push(n);
            }
          }

          return t;
        }, l.getEffectAsset = function () {
          return null === this._effectAsset ? n.EffectAsset.get("terrain") : this._effectAsset;
        }, l.onEnable = function () {
          0 === this._blocks.length && this._buildImp();

          for (var t = 0; t < this._blocks.length; ++t) {
            this._blocks[t].visible = !0;
          }

          n.director.root.pipeline.on(X.RENDER_CAMERA_BEGIN, this.onUpdateFromCamera, this);
        }, l.onDisable = function () {
          n.director.root.pipeline.off(X.RENDER_CAMERA_BEGIN, this.onUpdateFromCamera, this);

          for (var t = 0; t < this._blocks.length; ++t) {
            this._blocks[t].visible = !1;
          }
        }, l.onDestroy = function () {
          for (var t = 0; t < this._blocks.length; ++t) {
            this._blocks[t].destroy();
          }

          this._blocks = [];

          for (var e = 0; e < this._layerList.length; ++e) {
            this._layerList[e] = null;
          }

          null != this._sharedIndexBuffer && this._sharedIndexBuffer.destroy();
        }, l.onRestore = function () {
          this.onEnable(), this._buildImp(!0);
        }, l.update = function () {
          for (var t = 0; t < this._blocks.length; ++t) {
            this._blocks[t].update();
          }
        }, l.onUpdateFromCamera = function (t) {
          if (this.lodEnable && t.scene === this._getRenderScene()) {
            for (var e = 0; e < this._blocks.length; ++e) {
              this._blocks[e]._updateLevel(t.position);
            }

            for (var i = 0; i < this._blocks.length; ++i) {
              this._blocks[i]._updateLod();
            }
          }
        }, l.addLayer = function (t) {
          for (var e = 0; e < this._layerList.length; ++e) {
            var i;
            if (null === this._layerList[e] || this._layerList[e] && null === (null === (i = this._layerList[e]) || void 0 === i ? void 0 : i.detailMap)) return this._layerList[e] = t, e;
          }

          return -1;
        }, l.setLayer = function (t, e) {
          this._layerList[t] = e;
        }, l.removeLayer = function (t) {
          this._layerList[t] = null;
        }, l.getLayer = function (t) {
          return -1 === t ? null : this._layerList[t];
        }, l.getPosition = function (t, e) {
          var i = t * this._tileSize,
              r = e * this._tileSize,
              n = this.getHeight(t, e);
          return new z(i, n, r);
        }, l.getHeightField = function () {
          return this._heights;
        }, l.setHeight = function (t, e, i) {
          i = v(i, J, Q), this._heights[e * this.vertexCount[0] + t] = tt + i / et;
        }, l.getHeight = function (t, e) {
          return (this._heights[e * this.vertexCount[0] + t] - tt) * et;
        }, l.getHeightClamp = function (t, e) {
          return t = v(t, 0, this.vertexCount[0] - 1), e = v(e, 0, this.vertexCount[1] - 1), this.getHeight(t, e);
        }, l.getHeightAt = function (t, e) {
          var i = t / this.tileSize,
              r = e / this.tileSize,
              n = Math.floor(i),
              s = Math.floor(r),
              a = n + 1,
              o = s + 1,
              l = i - n,
              h = r - s;
          if (n < 0 || n > this.vertexCount[0] - 1 || s < 0 || s > this.vertexCount[1] - 1) return null;
          n = v(n, 0, this.vertexCount[0] - 1), s = v(s, 0, this.vertexCount[1] - 1), a = v(a, 0, this.vertexCount[0] - 1), o = v(o, 0, this.vertexCount[1] - 1);

          var u = this.getHeight(n, s),
              _ = this.getHeight(a, s),
              f = this.getHeight(n, o),
              c = this.getHeight(a, o),
              d = .5 * (_ + f);

          return l + h <= 1 ? c = d + (d - u) : u = d + (d - c), (u * (1 - l) + _ * l) * (1 - h) + (f * (1 - l) + c * l) * h;
        }, l._setNormal = function (t, e, i) {
          var r = e * this.vertexCount[0] + t;
          this._normals[3 * r + 0] = i.x, this._normals[3 * r + 1] = i.y, this._normals[3 * r + 2] = i.z;
        }, l.getNormal = function (t, e) {
          var i = e * this.vertexCount[0] + t,
              r = new z();
          return r.x = this._normals[3 * i + 0], r.y = this._normals[3 * i + 1], r.z = this._normals[3 * i + 2], r;
        }, l.getNormalAt = function (t, e) {
          var i = t / this.tileSize,
              r = e / this.tileSize,
              n = Math.floor(i),
              s = Math.floor(r),
              a = n + 1,
              o = s + 1,
              l = i - n,
              h = r - s;
          if (n < 0 || n > this.vertexCount[0] - 1 || s < 0 || s > this.vertexCount[1] - 1) return null;
          n = v(n, 0, this.vertexCount[0] - 1), s = v(s, 0, this.vertexCount[1] - 1), a = v(a, 0, this.vertexCount[0] - 1), o = v(o, 0, this.vertexCount[1] - 1);

          var u = this.getNormal(n, s),
              _ = this.getNormal(a, s),
              f = this.getNormal(n, o),
              c = this.getNormal(a, o),
              d = new z();

          z.add(d, _, f).multiplyScalar(.5), l + h <= 1 ? (c.set(d), c.subtract(u), c.add(d)) : (u.set(d), u.subtract(c), u.add(d));
          var g = new z(),
              p = new z(),
              b = new z();
          return z.lerp(g, u, _, l), z.lerp(p, f, c, l), z.lerp(b, g, p, h), b;
        }, l.setWeight = function (t, e, i) {
          var r = e * this._weightMapSize * this._blockCount[0] + t;
          this._weights[4 * r + 0] = 255 * i.x, this._weights[4 * r + 1] = 255 * i.y, this._weights[4 * r + 2] = 255 * i.z, this._weights[4 * r + 3] = 255 * i.w;
        }, l.getWeight = function (t, e) {
          var i = e * this._weightMapSize * this._blockCount[0] + t,
              r = new x();
          return r.x = this._weights[4 * i + 0] / 255, r.y = this._weights[4 * i + 1] / 255, r.z = this._weights[4 * i + 2] / 255, r.w = this._weights[4 * i + 3] / 255, r;
        }, l.getWeightAt = function (t, e) {
          var i = this.weightMapSize * this.blockCount[0],
              r = this.weightMapSize * this.blockCount[1];
          if (0 === i || 0 === r) return null;

          var n = t / i,
              s = e / r,
              a = Math.floor(n),
              o = Math.floor(s),
              l = a + 1,
              h = o + 1,
              u = n - a,
              _ = s - o;

          if (a < 0 || a > i - 1 || o < 0 || o > r - 1) return null;
          a = v(a, 0, i - 1), o = v(o, 0, r - 1), l = v(l, 0, i - 1), h = v(h, 0, r - 1);
          var f = this.getWeight(a, o),
              c = this.getWeight(l, o),
              d = this.getWeight(a, h),
              g = this.getWeight(l, h),
              p = new x();
          x.add(p, c, d).multiplyScalar(.5), u + _ <= 1 ? (g = new x(), x.subtract(g, p, f).add(p)) : (f = new x(), x.subtract(f, p, g).add(p));
          var b = new x(),
              y = new x(),
              M = new x();
          return x.lerp(b, f, c, u), x.lerp(y, d, g, u), x.lerp(M, b, y, _), M;
        }, l.getMaxWeightLayerAt = function (t, e) {
          var i = this.weightMapSize * this.blockCount[0],
              r = this.weightMapSize * this.blockCount[1];
          if (0 === i || 0 === r) return null;
          var n = t / i,
              s = e / r,
              a = Math.floor(n),
              o = Math.floor(s);
          if (a < 0 || a > i - 1 || o < 0 || o > r - 1) return null;

          var l = this.getWeight(a, o),
              h = Math.floor(t / this.weightMapSize),
              u = Math.floor(e / this.weightMapSize),
              _ = this.getBlock(h, u),
              f = 0;

          return l.y > l[f] && -1 !== _.getLayer(1) && (f = 1), l.y > l[f] && -1 !== _.getLayer(2) && (f = 2), l.z > l[f] && -1 !== _.getLayer(3) && (f = 3), f = _.getLayer(f), this.getLayer(f);
        }, l.getBlockLayers = function (t, e) {
          var i = (e * this._blockCount[0] + t) * it;
          return [this._layerBuffer[i], this._layerBuffer[i + 1], this._layerBuffer[i + 2], this._layerBuffer[i + 3]];
        }, l.getBlockLayer = function (t, e, i) {
          var r = (e * this._blockCount[0] + t) * it;
          return this._layerBuffer[r + i];
        }, l.setBlockLayer = function (t, e, i, r) {
          var n = (e * this._blockCount[0] + t) * it;
          this._layerBuffer[n + i] = r;
        }, l.getBlock = function (t, e) {
          return this._blocks[e * this._blockCount[0] + t];
        }, l.getBlocks = function () {
          return this._blocks;
        }, l.rayCheck = function (t, e, i, r) {
          void 0 === r && (r = !0);
          var n = t;
          r && z.subtract(n, t, this.node.getWorldPosition());
          var s = new z();
          s.set(e), s.multiplyScalar(i);
          var a = null;

          if (e.equals(new z(0, 1, 0))) {
            var o = this.getHeightAt(n.x, n.z);
            null != o && n.y <= o && (a = new z(n.x, o, n.z));
          } else if (e.equals(new z(0, -1, 0))) {
            var l = this.getHeightAt(n.x, n.z);
            null != l && n.y >= l && (a = new z(n.x, l, n.z));
          } else {
            for (var h = 0; h++ < 2e3;) {
              var u = this.getHeightAt(n.x, n.z);
              if (null != u && n.y <= u) break;
              n.add(e);
            }

            for (; h++ < 2e3;) {
              var _ = this.getHeightAt(n.x, n.z);

              if (null != _ && n.y <= _) {
                a = new z(n.x, _, n.z);
                break;
              }

              n.add(s);
            }
          }

          return a;
        }, l._getSharedIndexBuffer = function () {
          if (null == this._sharedIndexBuffer) {
            var t = n.director.root.device;
            this._sharedIndexBuffer = t.createBuffer(new s(a.INDEX | a.TRANSFER_DST, o.DEVICE, Uint16Array.BYTES_PER_ELEMENT * this._lod._indexBuffer.length, Uint16Array.BYTES_PER_ELEMENT)), this._sharedIndexBuffer.update(this._lod._indexBuffer);
          }

          return this._sharedIndexBuffer;
        }, l._getIndexData = function (t) {
          return this._lod.getIndexData(t);
        }, l._resetLightmap = function (t) {
          if (this._lightmapInfos.length = 0, t) for (var e = 0; e < this._blockCount[0] * this._blockCount[1]; ++e) {
            this._lightmapInfos.push(new le());
          }
        }, l._updateLightmap = function (t, e, i, r, n, s) {
          this._lightmapInfos[t].texture = e, this._lightmapInfos[t].UOff = i, this._lightmapInfos[t].VOff = r, this._lightmapInfos[t].UScale = n, this._lightmapInfos[t].VScale = s, this._blocks[t]._updateLightmap(this._lightmapInfos[t]);
        }, l._getLightmapInfo = function (t, e) {
          var i = e * this._blockCount[0] + t;
          return i < this._lightmapInfos.length ? this._lightmapInfos[i] : null;
        }, l._calcNormal = function (t, e) {
          var i,
              r,
              n = 1,
              s = this.getPosition(t, e);
          t < this.vertexCount[0] - 1 ? i = this.getPosition(t + 1, e) : (n *= -1, i = this.getPosition(t - 1, e)), e < this.vertexCount[1] - 1 ? r = this.getPosition(t, e + 1) : (n *= -1, r = this.getPosition(t, e - 1)), i.subtract(s), r.subtract(s);
          var a = new z();
          return a.set(r), a.cross(i), a.multiplyScalar(n), a.normalize(), a;
        }, l._buildNormals = function () {
          for (var t = 0, e = 0; e < this.vertexCount[1]; ++e) {
            for (var i = 0; i < this.vertexCount[0]; ++i) {
              var r = this._calcNormal(i, e);

              this._normals[3 * t + 0] = r.x, this._normals[3 * t + 1] = r.y, this._normals[3 * t + 2] = r.z, t += 1;
            }
          }
        }, l._buildImp = function (t) {
          var e = this;

          if (void 0 === t && (t = !1), !this.valid) {
            var i = this.__asset;

            if (this._buitinAsset !== i && (this._buitinAsset = i), !t && null !== i) {
              this._tileSize = i.tileSize, this._blockCount = i.blockCount, this._weightMapSize = i.weightMapSize, this._lightMapSize = i.lightMapSize, this._heights = i.heights, this._weights = i.weights, this._layerBuffer = i.layerBuffer;

              for (var r = 0; r < this._layerList.length; ++r) {
                this._layerList[r] = null;
              }

              if (i.version < rt) for (var s = function s(t) {
                var r = new ae(),
                    s = i.layerBinaryInfos[t];
                r.tileSize = s.tileSize, n.assetManager.loadAny(s.detailMapId, function (t, e) {
                  r.detailMap = e;
                }), "" !== s.normalMapId && n.assetManager.loadAny(s.normalMapId, function (t, e) {
                  r.normalMap = e;
                }), r.roughness = s.roughness, r.metallic = s.metallic, e._layerList[s.slot] = r;
              }, a = 0; a < i.layerBinaryInfos.length; ++a) {
                s(a);
              } else for (var o = 0; o < i.layerInfos.length; ++o) {
                var l = new ae(),
                    h = i.layerInfos[o];
                l.tileSize = h.tileSize, l.detailMap = h.detailMap, l.normalMap = h.normalMap, l.roughness = h.roughness, l.metallic = h.metallic, this._layerList[h.slot] = l;
              }
            }

            if (0 !== this._blockCount[0] && 0 !== this._blockCount[1]) {
              var u = this.vertexCount[0] * this.vertexCount[1];

              if (null === this._heights || this._heights.length !== u) {
                this._heights = new Uint16Array(u), this._normals = new Array(3 * u);

                for (var _ = 0; _ < u; ++_) {
                  this._heights[_] = tt, this._normals[3 * _ + 0] = 0, this._normals[3 * _ + 1] = 1, this._normals[3 * _ + 2] = 0;
                }
              } else this._normals = new Array(3 * u), this._buildNormals();

              var f = this.blockCount[0] * this.blockCount[1] * it;

              if (null === this._layerBuffer || this._layerBuffer.length !== f) {
                this._layerBuffer = new Array(f);

                for (var c = 0; c < f; ++c) {
                  this._layerBuffer[c] = -1;
                }
              }

              var d = this._weightMapSize * this._blockCount[0],
                  g = this._weightMapSize * this._blockCount[1];

              if (this._weights.length !== d * g * 4) {
                this._weights = new Uint8Array(d * g * 4);

                for (var p = 0; p < d * g; ++p) {
                  this._weights[4 * p + 0] = 255, this._weights[4 * p + 1] = 0, this._weights[4 * p + 2] = 0, this._weights[4 * p + 3] = 0;
                }
              }

              for (var b = 0; b < this._blockCount[1]; ++b) {
                for (var v = 0; v < this._blockCount[0]; ++v) {
                  this._blocks.push(new he(this, v, b));
                }
              }

              for (var y = 0; y < this._blocks.length; ++y) {
                this._blocks[y].build();
              }
            }
          }
        }, l._rebuildHeights = function (t) {
          if (this.vertexCount[0] === t.vertexCount[0] && this.vertexCount[1] === t.vertexCount[1]) return !1;

          for (var e = new Uint16Array(t.vertexCount[0] * t.vertexCount[1]), i = 0; i < e.length; ++i) {
            e[i] = tt;
          }

          for (var r = Math.min(this.vertexCount[0], t.vertexCount[0]), n = Math.min(this.vertexCount[1], t.vertexCount[1]), s = 0; s < n; ++s) {
            for (var a = 0; a < r; ++a) {
              var o = s * t.vertexCount[0] + a,
                  l = s * this.vertexCount[0] + a;
              e[o] = this._heights[l];
            }
          }

          return this._heights = e, !0;
        }, l._rebuildLayerBuffer = function (t) {
          if (this.blockCount[0] === t.blockCount[0] && this.blockCount[1] === t.blockCount[1]) return !1;
          var e = [];
          e.length = t.blockCount[0] * t.blockCount[1] * it;

          for (var i = 0; i < e.length; ++i) {
            e[i] = -1;
          }

          for (var r = Math.min(this.blockCount[0], t.blockCount[0]), n = Math.min(this.blockCount[1], t.blockCount[1]), s = 0; s < n; ++s) {
            for (var a = 0; a < r; ++a) {
              for (var o = s * t.blockCount[0] + a, l = s * this.blockCount[0] + a, h = 0; h < it; ++h) {
                e[o * it + h] = this._layerBuffer[l * it + h];
              }
            }
          }

          return this._layerBuffer = e, !0;
        }, l._rebuildWeights = function (t) {
          var e = this,
              i = this._weightMapSize,
              r = this._weightMapSize * this._blockCount[0],
              n = this._weightMapSize * this._blockCount[1],
              s = t.weightMapSize * t.blockCount[0],
              a = t.weightMapSize * t.blockCount[1];
          if (s === r && a === n) return !1;

          for (var o = new Uint8Array(s * a * 4), l = 0; l < s * a; ++l) {
            o[4 * l + 0] = 255, o[4 * l + 1] = 0, o[4 * l + 2] = 0, o[4 * l + 3] = 0;
          }

          for (var h = Math.min(t.blockCount[0], this._blockCount[0]), u = Math.min(t.blockCount[1], this._blockCount[1]), _ = function _(t, e, i) {
            var n = e * r + t,
                s = new x();
            return s.x = i[4 * n + 0] / 255, s.y = i[4 * n + 1] / 255, s.z = i[4 * n + 2] / 255, s.w = i[4 * n + 3] / 255, s;
          }, f = function f(t, r, n, s) {
            var a = Math.floor(t),
                o = Math.floor(r),
                l = Math.min(a + 1, i - 1),
                h = Math.min(o + 1, i - 1),
                u = t - a,
                f = r - o,
                c = _(a + n, o + s, e._weights),
                d = _(l + n, o + s, e._weights),
                g = _(a + n, h + s, e._weights),
                p = _(l + n, h + s, e._weights),
                b = new x();

            x.add(b, d, g).multiplyScalar(.5), u + f <= 1 ? (p.set(b), p.subtract(c), p.add(b)) : (c.set(b), c.subtract(p), c.add(b));
            var v = new x(),
                y = new x(),
                M = new x();
            return x.lerp(v, c, d, u), x.lerp(y, g, p, u), x.lerp(M, v, y, f), M;
          }, c = 0; c < u; ++c) {
            for (var d = 0; d < h; ++d) {
              for (var g = d * i, p = c * i, b = 0; b < t.weightMapSize; ++b) {
                for (var v = 0; v < t.weightMapSize; ++v) {
                  var y = void 0;
                  y = t.weightMapSize === i ? _(v + g, b + p, this._weights) : f(v / (t.weightMapSize - 1) * (i - 1), b / (t.weightMapSize - 1) * (i - 1), g, p, this._weights);
                  var M = d * t.weightMapSize + v,
                      w = (c * t.weightMapSize + b) * s + M;
                  o[4 * w + 0] = 255 * y.x, o[4 * w + 1] = 255 * y.y, o[4 * w + 2] = 255 * y.z, o[4 * w + 3] = 255 * y.w;
                }
              }
            }
          }

          return this._weights = o, !0;
        }, e(i, [{
          key: "_asset",
          get: function get() {
            return this.__asset;
          },
          set: function set(t) {
            if (this.__asset = t, this._buitinAsset !== this.__asset) {
              this._buitinAsset = this.__asset;

              for (var e = 0; e < this._blocks.length; ++e) {
                this._blocks[e].destroy();
              }

              if (this._blocks = [], null === this.__asset) {
                this._effectAsset = null, this._lightmapInfos = [], this._receiveShadow = !1, this._useNormalmap = !1, this._usePBR = !1, this._tileSize = 1, this._blockCount = [1, 1], this._weightMapSize = 128, this._lightMapSize = 128, this._heights = new Uint16Array(), this._weights = new Uint8Array(), this._normals = [], this._layerBuffer = [], this._blocks = [], this._layerList = [];

                for (var i = 0; i < nt; ++i) {
                  this._layerList.push(null);
                }
              }

              n.director.root.device && this._buildImp();
            }
          }
        }, {
          key: "effectAsset",
          get: function get() {
            return this._effectAsset;
          },
          set: function set(t) {
            if (this._effectAsset !== t) {
              this._effectAsset = t;

              for (var e = 0; e < this._blocks.length; ++e) {
                this._blocks[e]._invalidMaterial();
              }
            }
          }
        }, {
          key: "receiveShadow",
          get: function get() {
            return this._receiveShadow;
          },
          set: function set(t) {
            this._receiveShadow = t;

            for (var e = 0; e < this._blocks.length; e++) {
              this._blocks[e]._invalidMaterial();
            }
          }
        }, {
          key: "useNormalMap",
          get: function get() {
            return this._useNormalmap;
          },
          set: function set(t) {
            this._useNormalmap = t;

            for (var e = 0; e < this._blocks.length; e++) {
              this._blocks[e]._invalidMaterial();
            }
          }
        }, {
          key: "usePBR",
          get: function get() {
            return this._usePBR;
          },
          set: function set(t) {
            this._usePBR = t;

            for (var e = 0; e < this._blocks.length; e++) {
              this._blocks[e]._invalidMaterial();
            }
          }
        }, {
          key: "lodEnable",
          get: function get() {
            return this._lodEnable;
          },
          set: function set(t) {
            if (this._lodEnable = t, !this._lodEnable) for (var e = 0; e < this._blocks.length; e++) {
              this._blocks[e]._resetLod();
            }
          }
        }, {
          key: "LodBias",
          get: function get() {
            return this._lodBias;
          },
          set: function set(t) {
            this._lodBias = t;
          }
        }, {
          key: "size",
          get: function get() {
            var t = new N(0, 0);
            return t.width = this.blockCount[0] * q * this.tileSize, t.height = this.blockCount[1] * q * this.tileSize, t;
          }
        }, {
          key: "tileSize",
          get: function get() {
            return this._tileSize;
          }
        }, {
          key: "tileCount",
          get: function get() {
            return [this.blockCount[0] * q, this.blockCount[1] * q];
          }
        }, {
          key: "vertexCount",
          get: function get() {
            var t = this.tileCount;
            return t[0] += 1, t[1] += 1, t;
          }
        }, {
          key: "blockCount",
          get: function get() {
            return this._blockCount;
          }
        }, {
          key: "lightMapSize",
          get: function get() {
            return this._lightMapSize;
          }
        }, {
          key: "weightMapSize",
          get: function get() {
            return this._weightMapSize;
          }
        }, {
          key: "heights",
          get: function get() {
            return this._heights;
          }
        }, {
          key: "weights",
          get: function get() {
            return this._weights;
          }
        }, {
          key: "valid",
          get: function get() {
            return this._blocks.length > 0;
          }
        }, {
          key: "info",
          get: function get() {
            var t = new se();
            return t.tileSize = this.tileSize, t.blockCount[0] = this.blockCount[0], t.blockCount[1] = this.blockCount[1], t.weightMapSize = this.weightMapSize, t.lightMapSize = this.lightMapSize, t;
          }
        }]), i;
      }(V), jt = i((Ft = Qt).prototype, "__asset", [Ct, D, W], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return null;
        }
      }), Xt = i(Ft.prototype, "_effectAsset", [Lt, D, W, At], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return null;
        }
      }), Gt = i(Ft.prototype, "_lightmapInfos", [Et, D, W], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return [];
        }
      }), Kt = i(Ft.prototype, "_receiveShadow", [Bt, D, W], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !1;
        }
      }), Yt = i(Ft.prototype, "_useNormalmap", [Pt, D, W], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !1;
        }
      }), qt = i(Ft.prototype, "_usePBR", [Rt, D, W], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !1;
        }
      }), Zt = i(Ft.prototype, "_lodEnable", [Tt, D, W], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !1;
        }
      }), $t = i(Ft.prototype, "_lodBias", [Nt, D, W], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 0;
        }
      }), i(Ft.prototype, "_asset", [Dt, Ot], Object.getOwnPropertyDescriptor(Ft.prototype, "_asset"), Ft.prototype), i(Ft.prototype, "effectAsset", [Ut, Ht], Object.getOwnPropertyDescriptor(Ft.prototype, "effectAsset"), Ft.prototype), i(Ft.prototype, "receiveShadow", [T], Object.getOwnPropertyDescriptor(Ft.prototype, "receiveShadow"), Ft.prototype), i(Ft.prototype, "useNormalMap", [T], Object.getOwnPropertyDescriptor(Ft.prototype, "useNormalMap"), Ft.prototype), i(Ft.prototype, "usePBR", [T], Object.getOwnPropertyDescriptor(Ft.prototype, "usePBR"), Ft.prototype), i(Ft.prototype, "lodEnable", [T], Object.getOwnPropertyDescriptor(Ft.prototype, "lodEnable"), Ft.prototype), i(Ft.prototype, "LodBias", [T], Object.getOwnPropertyDescriptor(Ft.prototype, "LodBias"), Ft.prototype), i(Ft.prototype, "info", [Vt], Object.getOwnPropertyDescriptor(Ft.prototype, "info"), Ft.prototype), Wt = Ft)) || Wt) || Wt) || Wt) || Wt));
    }
  };
}); 
 			}); 
		define("__plugin__/wx0446ba2621dda60a/texture-barrier-60b5983b.js", function(require, module, exports){ 			
"use strict";

var _typeof2 = require("@babel/runtime/helpers/typeof");

System.register([], function (t) {
  "use strict";

  return {
    execute: function execute() {
      t({
        $: void 0,
        A: void 0,
        E: void 0,
        F: void 0,
        G: void 0,
        H: void 0,
        I: void 0,
        J: void 0,
        K: void 0,
        L: void 0,
        M: void 0,
        N: void 0,
        O: void 0,
        Q: void 0,
        S: void 0,
        T: void 0,
        U: void 0,
        V: void 0,
        W: void 0,
        X: void 0,
        Y: void 0,
        Z: void 0,
        _: O,
        a: T,
        a0: void 0,
        a1: void 0,
        a2: void 0,
        a3: void 0,
        a4: void 0,
        a5: void 0,
        a_: void 0,
        b: N,
        b$: function b$(t) {
          if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t;
        },
        b4: Xr,
        b5: Wr,
        b6: Vr,
        b7: Yr,
        b8: zr,
        bA: Zr,
        bB: _n,
        bD: vn,
        bK: mn,
        bL: I,
        bM: j,
        bN: Y,
        bO: V,
        bP: void 0,
        bS: void 0,
        bT: Z,
        bU: K,
        bW: function bW() {},
        bY: $e,
        bZ: void 0,
        bu: Re,
        bv: pe,
        bw: function bw(t) {
          "__enums__" in t || Pt(t, "__enums__", null, !0);
        },
        c: m,
        c0: function c0(t, e, n, i, r) {
          var o = {};
          return Object.keys(i).forEach(function (t) {
            o[t] = i[t];
          }), o.enumerable = !!o.enumerable, o.configurable = !!o.configurable, ("value" in o || o.initializer) && (o.writable = !0), o = n.slice().reverse().reduce(function (n, i) {
            return i(t, e, n) || n;
          }, o), r && void 0 !== o.initializer && (o.value = o.initializer ? o.initializer.call(r) : void 0, o.initializer = void 0), void 0 === o.initializer && (Object.defineProperty(t, e, o), o = null), o;
        },
        c1: function c1(t, e, n, i) {
          n && Object.defineProperty(t, e, {
            enumerable: n.enumerable,
            configurable: n.configurable,
            writable: n.writable,
            value: n.initializer ? n.initializer.call(i) : void 0
          });
        },
        c3: kt,
        c5: he,
        c8: void 0,
        c9: void 0,
        cC: C,
        cE: Me,
        cF: Qt,
        cH: Wn,
        cI: function cI() {},
        cJ: Tt,
        cK: function cK(t, e) {
          e >= 0 && t.length, t.length;
        },
        cL: vt,
        cM: St,
        cN: Ue,
        cO: Be,
        cS: Fn,
        cU: Ge,
        cV: Pe,
        cW: tt,
        cX: ue,
        ca: void 0,
        cb: void 0,
        cc: void 0,
        cd: void 0,
        ce: function ce(e) {
          var n = "function" == typeof Map ? new Map() : void 0;
          return t("ce", function (t) {
            if (null === t || (e = t, -1 === Function.toString.call(e).indexOf("[native code]"))) return t;
            var e;
            if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function");

            if (void 0 !== n) {
              if (n.has(t)) return n.get(t);
              n.set(t, i);
            }

            function i() {
              return tt(t, arguments, q(this).constructor);
            }

            return i.prototype = Object.create(t.prototype, {
              constructor: {
                value: i,
                enumerable: !1,
                writable: !0,
                configurable: !0
              }
            }), J(i, t);
          })(e);
        },
        cg: ke,
        ci: fe,
        cj: $t,
        ck: Jt,
        cn: function cn(t) {
          var e;
          return null == t || null === (e = t.hasOwnProperty) || void 0 === e ? void 0 : e.call(t, "__values__");
        },
        co: Hn,
        cp: Q,
        cq: kn,
        cr: Et,
        cs: Ft,
        ct: Zt,
        cu: Ut,
        cv: _e,
        cx: Ht,
        d: b,
        e: S,
        f: L,
        g: W,
        i: nt,
        k: void 0,
        m: void 0,
        n: void 0,
        o: void 0,
        p: void 0,
        q: void 0,
        r: void 0,
        s: void 0,
        t: void 0,
        u: void 0,
        v: void 0,
        w: v,
        x: void 0,
        y: void 0,
        z: void 0
      });
      var e = !0,
          n = t("c6", !1),
          i = (t("cz", !1), t("cw", !1)),
          r = t("cG", !1),
          o = t("cR", !1),
          s = t("cP", !0),
          a = t("cQ", !1);
      var u = "undefined" == typeof window ? global : window,
          c = t("l", {
        _global: u
      });
      c.internal = {}, u.CC_BUILD = !0, u.CC_TEST = !1, u.CC_EDITOR = i, u.CC_PREVIEW = r, u.CC_DEV = !1, u.CC_DEBUG = !1, u.CC_JSB = a, u.CC_BYTEDANCE = !1, u.CC_WECHAT = e, u.CC_ALIPAY = n, u.CC_XIAOMI = !1, u.CC_BAIDU = !1, u.CC_COCOSPLAY = !1, u.CC_HUAWEI = !1, u.CC_OPPO = !1, u.CC_VIVO = !1, u.CC_MINIGAME = s, u.CC_RUNTIME_BASED = o, u.CC_SUPPORT_JIT = !1;
      var h = t("bs", "3.5.1");
      u.CocosEngine = c.ENGINE_VERSION = h, u.cc = c;

      var _ = "https://github.com/cocos-creator/engine/blob/develop/EngineErrorMap.md",
          f = null,
          l = console.log.bind(console),
          A = l,
          d = l,
          R = function R(t, e) {
        if (!t) {
          for (var n = arguments.length, i = new Array(n > 2 ? n - 2 : 0), r = 2; r < n; r++) {
            i[r - 2] = arguments[r];
          }

          console.log("ASSERT: " + E.apply(void 0, [e].concat(i)));
        }
      },
          p = l;

      function E(t) {
        for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), i = 1; i < e; i++) {
          n[i - 1] = arguments[i];
        }

        return c.js.formatStr.apply(null, [t].concat(n));
      }

      function T(t) {
        for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), i = 1; i < e; i++) {
          n[i - 1] = arguments[i];
        }

        return l.apply(void 0, [t].concat(n));
      }

      function v(t) {
        for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), i = 1; i < e; i++) {
          n[i - 1] = arguments[i];
        }

        return A.apply(void 0, [t].concat(n));
      }

      function S(t) {
        for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), i = 1; i < e; i++) {
          n[i - 1] = arguments[i];
        }

        return d.apply(void 0, [t].concat(n));
      }

      function N(t, e) {
        for (var n = arguments.length, i = new Array(n > 2 ? n - 2 : 0), r = 2; r < n; r++) {
          i[r - 2] = arguments[r];
        }

        return R.apply(void 0, [t, e].concat(i));
      }

      function I() {
        return p.apply(void 0, arguments);
      }

      function C(t) {
        if (l = A = d = R = p = function p() {}, t !== U.NONE) {
          if (t > U.ERROR) {
            var e = function e(t) {
              if (c.game.canvas) {
                if (!f) {
                  var e = document.createElement("Div");
                  e.setAttribute("id", "logInfoDiv"), e.setAttribute("width", "200"), e.setAttribute("height", c.game.canvas.height);
                  var n = e.style;
                  n.zIndex = "99999", n.position = "absolute", n.top = n.left = "0", (f = document.createElement("textarea")).setAttribute("rows", "20"), f.setAttribute("cols", "30"), f.setAttribute("disabled", "true");
                  var i = f.style;
                  i.backgroundColor = "transparent", i.borderBottom = "1px solid #cccccc", i.borderTopWidth = i.borderLeftWidth = i.borderRightWidth = "0px", i.borderTopStyle = i.borderLeftStyle = i.borderRightStyle = "none", i.padding = "0px", i.margin = "0px", e.appendChild(f), c.game.canvas.parentNode.appendChild(e);
                }

                f.value = f.value + t + "\r\n", f.scrollTop = f.scrollHeight;
              }
            };

            d = function d(t) {
              for (var n = arguments.length, i = new Array(n > 1 ? n - 1 : 0), r = 1; r < n; r++) {
                i[r - 1] = arguments[r];
              }

              e("ERROR :  " + E.apply(void 0, [t].concat(i)));
            }, R = function R(t, n) {
              if (!t) {
                for (var i = arguments.length, r = new Array(i > 2 ? i - 2 : 0), o = 2; o < i; o++) {
                  r[o - 2] = arguments[o];
                }

                e("ASSERT: " + E.apply(void 0, [n].concat(r)));
              }
            }, t !== U.ERROR_FOR_WEB_PAGE && (A = function A(t) {
              for (var n = arguments.length, i = new Array(n > 1 ? n - 1 : 0), r = 1; r < n; r++) {
                i[r - 1] = arguments[r];
              }

              e("WARN :  " + E.apply(void 0, [t].concat(i)));
            }), t === U.INFO_FOR_WEB_PAGE && (l = function l(t) {
              for (var n = arguments.length, i = new Array(n > 1 ? n - 1 : 0), r = 1; r < n; r++) {
                i[r - 1] = arguments[r];
              }

              e(E.apply(void 0, [t].concat(i)));
            });
          } else console && (console.error || (console.error = console.log), console.warn || (console.warn = console.log), d = console.error.bind ? console.error.bind(console) : function (t) {
            for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), i = 1; i < e; i++) {
              n[i - 1] = arguments[i];
            }

            return console.error.apply(console, [t].concat(n));
          }, R = function R(t, e) {
            if (!t) {
              for (var n = arguments.length, i = new Array(n > 2 ? n - 2 : 0), r = 2; r < n; r++) {
                i[r - 2] = arguments[r];
              }

              var o = E.apply(void 0, [e].concat(i));
              throw new Error(o);
            }
          });

          if (t !== U.ERROR && (A = console.warn.bind ? console.warn.bind(console) : function (t) {
            for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), i = 1; i < e; i++) {
              n[i - 1] = arguments[i];
            }

            return console.warn.apply(console, [t].concat(n));
          }), t <= U.INFO && (l = console.log.bind ? console.log.bind(console) : function (t) {
            for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), i = 1; i < e; i++) {
              n[i - 1] = arguments[i];
            }

            return console.log.apply(console, [t].concat(n));
          }), t <= U.VERBOSE && "function" == typeof console.debug) {
            var n = console.debug.bind(console);

            p = function p() {
              return n.apply(void 0, arguments);
            };
          }
        }
      }

      function O(t) {
        S(t.stack || t);
      }

      function y(t) {
        return function (e) {
          for (var n = t + " " + e + ", please go to " + _ + "#" + e + " to see details.", i = arguments.length, r = new Array(i > 1 ? i - 1 : 0), o = 1; o < i; o++) {
            r[o - 1] = arguments[o];
          }

          return 0 === r.length ? n : n + " Arguments: " + r.join(", ");
        };
      }

      var g = y("Log");

      function m(t) {
        for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), i = 1; i < e; i++) {
          n[i - 1] = arguments[i];
        }

        T(g.apply(void 0, [t].concat(n)));
      }

      var B = y("Warning");

      function b(t) {
        for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), i = 1; i < e; i++) {
          n[i - 1] = arguments[i];
        }

        v(B.apply(void 0, [t].concat(n)));
      }

      var M = y("Error");

      function L(t) {
        for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), i = 1; i < e; i++) {
          n[i - 1] = arguments[i];
        }

        S(M.apply(void 0, [t].concat(n)));
      }

      var U,
          G,
          P,
          w,
          D,
          x,
          F,
          k,
          H,
          X = y("Assert");

      function W(t, e) {
        if (!t) {
          for (var n = arguments.length, i = new Array(n > 2 ? n - 2 : 0), r = 2; r < n; r++) {
            i[r - 2] = arguments[r];
          }

          N(!1, X.apply(void 0, [e].concat(i)));
        }
      }

      function V(t) {
        for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), i = 1; i < e; i++) {
          n[i - 1] = arguments[i];
        }

        return M.apply(void 0, [t].concat(n));
      }

      function j() {
        return !!c.profiler && c.profiler.isShowingStats();
      }

      function Y(t) {
        c.profiler && (t ? c.profiler.showStats() : c.profiler.hideStats(), c.game.config.showFPS = !!t);
      }

      function z(t, e) {
        for (var n = 0; n < e.length; n++) {
          var i = e[n];
          i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i);
        }
      }

      function K(t, e, n) {
        return e && z(t.prototype, e), n && z(t, n), t;
      }

      function Q() {
        return (Q = t("cp", Object.assign || function (t) {
          for (var e = 1; e < arguments.length; e++) {
            var n = arguments[e];

            for (var i in n) {
              Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]);
            }
          }

          return t;
        })).apply(this, arguments);
      }

      function Z(t, e) {
        t.prototype = Object.create(e.prototype), t.prototype.constructor = t, J(t, e);
      }

      function q(t) {
        return (q = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
          return t.__proto__ || Object.getPrototypeOf(t);
        })(t);
      }

      function J(t, e) {
        return (J = Object.setPrototypeOf || function (t, e) {
          return t.__proto__ = e, t;
        })(t, e);
      }

      function $() {
        if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
        if (Reflect.construct.sham) return !1;
        if ("function" == typeof Proxy) return !0;

        try {
          return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
        } catch (t) {
          return !1;
        }
      }

      function tt(e, n, i) {
        return (tt = $() ? t("cW", Reflect.construct) : t("cW", function (t, e, n) {
          var i = [null];
          i.push.apply(i, e);
          var r = new (Function.bind.apply(t, i))();
          return n && J(r, n.prototype), r;
        })).apply(null, arguments);
      }

      function et(t, e) {
        (null == e || e > t.length) && (e = t.length);

        for (var n = 0, i = new Array(e); n < e; n++) {
          i[n] = t[n];
        }

        return i;
      }

      function nt(t, e) {
        var n;

        if ("undefined" == typeof Symbol || null == t[Symbol.iterator]) {
          if (Array.isArray(t) || (n = function (t, e) {
            if (t) {
              if ("string" == typeof t) return et(t, e);
              var n = Object.prototype.toString.call(t).slice(8, -1);
              return "Object" === n && t.constructor && (n = t.constructor.name), "Map" === n || "Set" === n ? Array.from(t) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? et(t, e) : void 0;
            }
          }(t)) || e && t && "number" == typeof t.length) {
            n && (t = n);
            var i = 0;
            return function () {
              return i >= t.length ? {
                done: !0
              } : {
                done: !1,
                value: t[i++]
              };
            };
          }

          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }

        return (n = t[Symbol.iterator]()).next.bind(n);
      }

      !function (t) {
        t[t.NONE = 0] = "NONE", t[t.VERBOSE = 1] = "VERBOSE", t[t.INFO = 2] = "INFO", t[t.WARN = 3] = "WARN", t[t.ERROR = 4] = "ERROR", t[t.INFO_FOR_WEB_PAGE = 5] = "INFO_FOR_WEB_PAGE", t[t.WARN_FOR_WEB_PAGE = 6] = "WARN_FOR_WEB_PAGE", t[t.ERROR_FOR_WEB_PAGE = 7] = "ERROR_FOR_WEB_PAGE";
      }(U || (U = t("bP", {}))), t("h", Object.freeze({
        __proto__: null,
        log: T,
        warn: v,
        error: S,
        assert: N,
        debug: I,
        _resetDebugSetting: C,
        _throw: O,
        logID: m,
        warnID: b,
        errorID: L,
        assertID: W,

        get DebugMode() {
          return U;
        },

        getError: V,
        isDisplayStats: j,
        setDisplayStats: Y
      })), function (t) {
        t[t.PORTRAIT = 1] = "PORTRAIT", t[t.PORTRAIT_UPSIDE_DOWN = 2] = "PORTRAIT_UPSIDE_DOWN", t[t.LANDSCAPE_LEFT = 4] = "LANDSCAPE_LEFT", t[t.LANDSCAPE_RIGHT = 8] = "LANDSCAPE_RIGHT", t[t.LANDSCAPE = 12] = "LANDSCAPE", t[t.AUTO = 13] = "AUTO";
      }(G || (G = t("c8", {})));
      var it,
          rt,
          ot = t("c7", {});
      it = ot, rt = wx, Object.keys(rt).forEach(function (t) {
        "function" != typeof rt[t] ? it[t] = rt[t] : it[t] = rt[t].bind(rt);
      }), ot.wx = {}, ot.wx.onKeyDown = null === (P = wx.onKeyDown) || void 0 === P ? void 0 : P.bind(wx), ot.wx.onKeyUp = null === (w = wx.onKeyUp) || void 0 === w ? void 0 : w.bind(wx), ot.wx.onMouseDown = null === (D = wx.onMouseDown) || void 0 === D ? void 0 : D.bind(wx), ot.wx.onMouseMove = null === (x = wx.onMouseMove) || void 0 === x ? void 0 : x.bind(wx), ot.wx.onMouseUp = null === (F = wx.onMouseUp) || void 0 === F ? void 0 : F.bind(wx), ot.wx.onWheel = null === (k = wx.onWheel) || void 0 === k ? void 0 : k.bind(wx);
      var st = wx.getSystemInfoSync();
      ot.testAndUpdateSystemInfoCache = function (t, e) {
        var n = 0,
            i = null;
        i = setInterval(function () {
          var e = wx.getSystemInfoSync();
          st.screenWidth === e.screenWidth && st.screenHeight === e.screenHeight ? ++n >= t && null !== i && (clearInterval(i), i = null) : n = 0, st = e;
        }, e);
      }, ot.testAndUpdateSystemInfoCache(10, 500), null === (H = ot.onWindowResize) || void 0 === H || H.call(ot, function () {
        st = wx.getSystemInfoSync();
      }), ot.getSystemInfoSync = function () {
        return st;
      };
      var at = ot.getSystemInfoSync();
      ot.isDevTool = "devtools" === at.platform, Object.defineProperty(ot, "isLandscape", {
        get: function get() {
          var t = wx.getSystemInfoSync();
          return "string" == typeof t.deviceOrientation ? t.deviceOrientation.startsWith("landscape") : t.screenWidth > t.screenHeight;
        }
      });

      var ut,
          ct,
          ht,
          _t,
          ft = G.LANDSCAPE_RIGHT;

      if ("android" !== at.platform.toLocaleLowerCase() && wx.onDeviceOrientationChange(function (t) {
        "landscape" === t.value ? ft = G.LANDSCAPE_RIGHT : "landscapeReverse" === t.value && (ft = G.LANDSCAPE_LEFT);
      }), Object.defineProperty(ot, "orientation", {
        get: function get() {
          return ot.isLandscape ? ft : G.PORTRAIT;
        }
      }), ot.onAccelerometerChange = function (t) {
        ot.offAccelerometerChange(), ut = function ut(e) {
          var n = e.x,
              i = e.y;

          if (ot.isLandscape) {
            var r = ft === G.LANDSCAPE_RIGHT ? 1 : -1,
                o = n;
            n = -i * r, i = o * r;
          }

          var s = {
            x: n,
            y: i,
            z: e.z
          };
          t(s);
        };
      }, ot.offAccelerometerChange = function () {
        ut && (wx.offAccelerometerChange(ut), ut = void 0);
      }, ot.startAccelerometer = function (t) {
        ut && wx.onAccelerometerChange(ut), wx.startAccelerometer(t);
      }, ot.createInnerAudioContext = (ct = wx, ht = {
        onPlay: !0,
        onPause: !0,
        onStop: !0,
        onSeek: !1
      }, void 0 === (_t = !0) && (_t = !1), function () {
        var t = ct.createInnerAudioContext();

        if (ht.onPlay) {
          var e = t.play,
              n = null;
          Object.defineProperty(t, "onPlay", {
            configurable: !0,
            value: function value(t) {
              n = t;
            }
          }), Object.defineProperty(t, "play", {
            configurable: !0,
            value: function value() {
              e.call(t), n && (_t ? setTimeout(n, 0) : n());
            }
          });
        }

        if (ht.onPause) {
          var i = t.pause,
              r = null;
          Object.defineProperty(t, "onPause", {
            configurable: !0,
            value: function value(t) {
              r = t;
            }
          }), Object.defineProperty(t, "pause", {
            configurable: !0,
            value: function value() {
              i.call(t), r && (_t ? setTimeout(r, 0) : r());
            }
          });
        }

        if (ht.onStop) {
          var o = t.stop,
              s = null;
          Object.defineProperty(t, "onStop", {
            configurable: !0,
            value: function value(t) {
              s = t;
            }
          }), Object.defineProperty(t, "stop", {
            configurable: !0,
            value: function value() {
              o.call(t), s && (_t ? setTimeout(s, 0) : s());
            }
          });
        }

        if (ht.onSeek) {
          var a = t.seek,
              u = null;
          Object.defineProperty(t, "onSeeked", {
            configurable: !0,
            value: function value(t) {
              u = t;
            }
          }), Object.defineProperty(t, "seek", {
            configurable: !0,
            value: function value(e) {
              a.call(t, e), u && (_t ? setTimeout(u, 0) : u());
            }
          });
        }

        return t;
      }), ot.getSafeArea = function () {
        return wx.getSystemInfoSync().safeArea;
      }, "windows" === at.platform && function (t, e) {
        var n = /\d+\.\d+\.\d+/;
        if (!n.test(t) || !n.test(e)) return console.warn("wrong format of version when compare version"), 0;

        for (var i = t.split(".").map(function (t) {
          return Number.parseInt(t);
        }), r = e.split(".").map(function (t) {
          return Number.parseInt(t);
        }), o = 0; o < 3; ++o) {
          var s = i[o],
              a = r[o];
          if (s !== a) return s - a;
        }

        return 0;
      }(at.SDKVersion, "2.16.0") < 0) {
        var lt = canvas;

        if (lt) {
          var At = lt.getContext("webgl"),
              dt = At.useProgram.bind(At);

          At.useProgram = function (t) {
            t && dt(t);
          };
        }
      }

      var Rt = t("cB", function () {
        function t(t) {
          this.i = 0, this.array = t;
        }

        var e = t.prototype;
        return e.remove = function (t) {
          var e = this.array.indexOf(t);
          e >= 0 && this.removeAt(e);
        }, e.removeAt = function (t) {
          this.array.splice(t, 1), t <= this.i && --this.i;
        }, e.fastRemove = function (t) {
          var e = this.array.indexOf(t);
          e >= 0 && this.fastRemoveAt(e);
        }, e.fastRemoveAt = function (t) {
          var e = this.array;
          e[t] = e[e.length - 1], --e.length, t <= this.i && --this.i;
        }, e.push = function (t) {
          this.array.push(t);
        }, K(t, [{
          key: "length",
          get: function get() {
            return this.array.length;
          },
          set: function set(t) {
            this.array.length = t, this.i >= t && (this.i = t - 1);
          }
        }]), t;
      }());

      function pt(t, e) {
        t.splice(e, 1);
      }

      function Et(t, e) {
        var n = t.length;
        e < 0 || e >= n || (t[e] = t[n - 1], t.length = n - 1);
      }

      function Tt(t, e) {
        var n = t.indexOf(e);
        return n >= 0 && (pt(t, n), !0);
      }

      function vt(t, e) {
        var n = t.findIndex(e);

        if (n >= 0) {
          var i = t[n];
          return pt(t, n), i;
        }
      }

      function St(t, e) {
        return t.indexOf(e) >= 0;
      }

      var Nt = Object.freeze({
        __proto__: null,
        removeAt: pt,
        fastRemoveAt: Et,
        remove: Tt,
        fastRemove: function fastRemove(t, e) {
          var n = t.indexOf(e);
          n >= 0 && (t[n] = t[t.length - 1], --t.length);
        },
        removeIf: vt,
        verifyType: function verifyType(t, e) {
          if (t && t.length > 0) for (var n, i = nt(t); !(n = i()).done;) {
            if (!(n.value instanceof e)) return m(1300), !1;
          }
          return !0;
        },
        removeArray: function removeArray(t, e) {
          for (var n = 0, i = e.length; n < i; n++) {
            Tt(t, e[n]);
          }
        },
        appendObjectsAt: function appendObjectsAt(t, e, n) {
          return t.splice.apply(t, [n, 0].concat(e)), t;
        },
        contains: St,
        copy: function copy(t) {
          for (var e = t.length, n = new Array(e), i = 0; i < e; i += 1) {
            n[i] = t[i];
          }

          return n;
        },
        MutableForwardIterator: Rt
      }),
          It = function () {
        function t() {
          this._pools = [], this._lastShrinkPassed = 0, this.shrinkTimeSpan = 5;
        }

        var e = t.prototype;
        return e.addContainer = function (t) {
          -1 === t._poolHandle && (t._poolHandle = this._pools.length, this._pools.push(t));
        }, e.removeContainer = function (t) {
          -1 !== t._poolHandle && (this._pools[this._pools.length - 1]._poolHandle = t._poolHandle, Et(this._pools, t._poolHandle), t._poolHandle = -1);
        }, e.tryShrink = function () {
          for (var t = 0; t < this._pools.length; t++) {
            this._pools[t].tryShrink();
          }
        }, e.update = function (t) {
          this._lastShrinkPassed += t, this._lastShrinkPassed > this.shrinkTimeSpan && (this.tryShrink(), this._lastShrinkPassed -= this.shrinkTimeSpan);
        }, t;
      }(),
          Ct = t("cD", new It()),
          Ot = function () {
        function t() {
          this._poolHandle = -1, Ct.addContainer(this);
        }

        return t.prototype.destroy = function () {
          Ct.removeContainer(this);
        }, t;
      }(),
          yt = t("P", function (t) {
        function e(e, n, i) {
          var r;
          (r = t.call(this) || this)._ctor = void 0, r._elementsPerBatch = void 0, r._nextAvail = void 0, r._freepool = [], r._dtor = void 0, r._ctor = e, r._dtor = i || null, r._elementsPerBatch = Math.max(n, 1), r._nextAvail = r._elementsPerBatch - 1;

          for (var o = 0; o < r._elementsPerBatch; ++o) {
            r._freepool.push(e());
          }

          return r;
        }

        Z(e, t);
        var n = e.prototype;
        return n.alloc = function () {
          if (this._nextAvail < 0) {
            this._freepool.length = this._elementsPerBatch;

            for (var t = 0; t < this._elementsPerBatch; t++) {
              this._freepool[t] = this._ctor();
            }

            this._nextAvail = this._elementsPerBatch - 1;
          }

          return this._freepool[this._nextAvail--];
        }, n.free = function (t) {
          this._freepool[++this._nextAvail] = t;
        }, n.freeArray = function (t) {
          this._freepool.length = this._nextAvail + 1, Array.prototype.push.apply(this._freepool, t), this._nextAvail += t.length;
        }, n.tryShrink = function () {
          if (this._nextAvail >> 1 > this._elementsPerBatch) {
            if (this._dtor) for (var t = this._nextAvail >> 1; t <= this._nextAvail; t++) {
              this._dtor(this._freepool[t]);
            }
            this._freepool.length = this._nextAvail >> 1, this._nextAvail = this._freepool.length - 1;
          }
        }, n.destroy = function () {
          var e = arguments.length > 0 ? arguments[0] : null;
          e && b(14100);
          var n = e || this._dtor;
          if (n) for (var i = 0; i <= this._nextAvail; i++) {
            n(this._freepool[i]);
          }
          this._freepool.length = 0, this._nextAvail = -1, t.prototype.destroy.call(this);
        }, e;
      }(Ot)),
          gt = (t("R", function (t) {
        function e(e, n, i) {
          var r;
          (r = t.call(this) || this)._fn = void 0, r._dtor = null, r._count = 0, r._data = void 0, r._initSize = 0, r._fn = e, r._dtor = i || null, r._data = new Array(n), r._initSize = n;

          for (var o = 0; o < n; ++o) {
            r._data[o] = e();
          }

          return r;
        }

        Z(e, t);
        var n = e.prototype;
        return n.reset = function () {
          this._count = 0;
        }, n.resize = function (t) {
          if (t > this._data.length) for (var e = this._data.length; e < t; ++e) {
            this._data[e] = this._fn();
          }
        }, n.add = function () {
          return this._count >= this._data.length && this.resize(this._data.length << 1), this._data[this._count++];
        }, n.destroy = function () {
          if (this._dtor) for (var e = 0; e < this._data.length; e++) {
            this._dtor(this._data[e]);
          }
          this._data.length = 0, this._count = 0, t.prototype.destroy.call(this);
        }, n.tryShrink = function () {
          if (this._data.length >> 2 > this._count) {
            var t = Math.max(this._initSize, this._data.length >> 1);
            if (this._dtor) for (var e = t; e < this._data.length; e++) {
              this._dtor(this._data[e]);
            }
            this._data.length = t;
          }
        }, n.removeAt = function (t) {
          if (!(t >= this._count)) {
            var e = this._count - 1,
                n = this._data[t];
            this._data[t] = this._data[e], this._data[e] = n, this._count -= 1;
          }
        }, K(e, [{
          key: "length",
          get: function get() {
            return this._count;
          }
        }, {
          key: "data",
          get: function get() {
            return this._data;
          }
        }]), e;
      }(Ot)), t("C", function (t) {
        function e(e, n) {
          var i;
          return (i = t.call(this) || this).array = void 0, i.length = 0, i._compareFn = void 0, i._initSize = 0, i.array = new Array(e), i._initSize = e, i.length = 0, i._compareFn = n, i;
        }

        Z(e, t);
        var n = e.prototype;
        return n.push = function (t) {
          this.array[this.length++] = t;
        }, n.pop = function () {
          return this.array[--this.length];
        }, n.get = function (t) {
          return this.array[t];
        }, n.clear = function () {
          this.length = 0;
        }, n.destroy = function () {
          this.length = 0, this.array.length = 0, t.prototype.destroy.call(this);
        }, n.tryShrink = function () {
          this.array.length >> 2 > this.length && (this.array.length = Math.max(this._initSize, this.array.length >> 1));
        }, n.sort = function () {
          this.array.length = this.length, this.array.sort(this._compareFn);
        }, n.concat = function (t) {
          for (var e = 0; e < t.length; ++e) {
            this.array[this.length++] = t[e];
          }
        }, n.fastRemove = function (t) {
          if (!(t >= this.length || t < 0)) {
            var e = --this.length;
            this.array[t] = this.array[e];
          }
        }, n.indexOf = function (t) {
          for (var e = 0, n = this.length; e < n; ++e) {
            if (this.array[e] === t) return e;
          }

          return -1;
        }, e;
      }(Ot)), t("c4", function () {
        function t(t) {
          this.id = void 0, this.prefix = void 0, this.id = 0 | 998 * Math.random(), this.prefix = t ? t + "." : "";
        }

        return t.prototype.getNewId = function () {
          return this.prefix + ++this.id;
        }, t;
      }()));

      gt.global = new gt("global");
      var mt = new gt("TmpCId."),
          Bt = "undefined" == typeof Symbol ? "__aliases__" : Symbol("[[Aliases]]"),
          bt = "__cid__";

      function Mt(t) {
        return "number" == typeof t || t instanceof Number;
      }

      function Lt(t) {
        return "string" == typeof t || t instanceof String;
      }

      function Ut(t) {
        for (var e in t) {
          return !1;
        }

        return !0;
      }

      var Gt,
          Pt = t("c2", (Gt = {
        value: void 0,
        enumerable: !1,
        writable: !1,
        configurable: !0
      }, function (t, e, n, i, r) {
        Gt.value = n, Gt.writable = i, Gt.enumerable = r, Object.defineProperty(t, e, Gt), Gt.value = void 0;
      })),
          wt = function () {
        var t = {
          get: void 0,
          set: void 0,
          enumerable: !1
        };
        return function (e, n, i, r, o, s) {
          void 0 === o && (o = !1), void 0 === s && (s = !1), "boolean" == typeof r && (o = r, r = void 0), t.get = i, t.set = r, t.enumerable = o, t.configurable = s, Object.defineProperty(e, n, t), t.get = void 0, t.set = void 0;
        };
      }(),
          Dt = function () {
        var t = {
          get: void 0,
          enumerable: !1,
          configurable: !1
        };
        return function (e, n, i, r, o) {
          t.get = i, t.enumerable = r, t.configurable = o, Object.defineProperty(e, n, t), t.get = void 0;
        };
      }(),
          xt = function () {
        var t = {
          set: void 0,
          enumerable: !1,
          configurable: !1
        };
        return function (e, n, i, r, o) {
          t.set = i, t.enumerable = r, t.configurable = o, Object.defineProperty(e, n, t), t.set = void 0;
        };
      }();

      function Ft(t) {
        var e = Object.create(null);
        return t && (e["."] = 1, e["/"] = 1, delete e["."], delete e["/"]), e;
      }

      function kt(t) {
        if ("function" == typeof t) {
          var e = t.prototype;
          if (e && e.hasOwnProperty("__classname__") && e.__classname__) return e.__classname__;
          var n = "";

          if (t.name && (n = t.name), t.toString) {
            var i,
                r = t.toString();
            (i = "[" === r.charAt(0) ? /\[\w+\s*(\w+)\]/.exec(r) : /function\s*(\w+)/.exec(r)) && 2 === i.length && (n = i[1]);
          }

          return "Object" !== n ? n : "";
        }

        return t && t.constructor ? kt(t.constructor) : "";
      }

      function Ht(t, e, n, i) {
        var r = /([^.]+)$/,
            o = r.exec(e)[0],
            s = r.exec(n)[0];

        function a() {
          return this[s];
        }

        i ? wt(t, o, a, function (t) {
          this[s] = t;
        }) : Dt(t, o, a);
      }

      function Xt(t, e, n, i) {
        for (var r in n) {
          Ht(t, e + "." + r, n[r], i);
        }
      }

      var Wt = /(%d)|(%s)/,
          Vt = /%s/;

      function jt(t) {
        for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), i = 1; i < e; i++) {
          n[i - 1] = arguments[i];
        }

        if (0 === arguments.length) return "";
        if (0 === n.length) return "" + t;
        var r = "string" == typeof t && Wt.test(t);
        if (r) for (var o, s = nt(n); !(o = s()).done;) {
          var a = o.value,
              u = "number" == typeof a ? Wt : Vt;

          if (u.test(t)) {
            var c = "" + a;
            t = t.replace(u, c);
          } else t += " " + a;
        } else for (var h, _ = nt(n); !(h = _()).done;) {
          var f = h.value;
          t += " " + f;
        }
        return t;
      }

      function Yt() {
        for (var t = arguments.length - 1, e = new Array(t), n = 0; n < t; ++n) {
          e[n] = arguments[n + 1];
        }

        return e;
      }

      function zt(t, e) {
        for (; t;) {
          var n = Object.getOwnPropertyDescriptor(t, e);
          if (n) return n;
          t = Object.getPrototypeOf(t);
        }

        return null;
      }

      function Kt(t, e, n) {
        var i = zt(e, t);
        i && Object.defineProperty(n, t, i);
      }

      function Qt(t) {
        t = t || {};

        for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), i = 1; i < e; i++) {
          n[i - 1] = arguments[i];
        }

        for (var r = 0, o = n; r < o.length; r++) {
          var s = o[r];

          if (s) {
            if ("object" != _typeof2(s)) {
              L(5402, s);
              continue;
            }

            for (var a in s) {
              a in t || Kt(a, s, t);
            }
          }
        }

        return t;
      }

      function Zt(t) {
        t = t || {};

        for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), i = 1; i < e; i++) {
          n[i - 1] = arguments[i];
        }

        for (var r = 0, o = n; r < o.length; r++) {
          var s = o[r];

          if (s) {
            if ("object" != _typeof2(s)) {
              L(5403, s);
              continue;
            }

            for (var a in s) {
              Kt(a, s, t);
            }
          }
        }

        return t;
      }

      function qt(t, e) {
        for (var n in e) {
          e.hasOwnProperty(n) && (t[n] = e[n]);
        }

        return t.prototype = Object.create(e.prototype, {
          constructor: {
            value: t,
            writable: !0,
            configurable: !0
          }
        }), t;
      }

      function Jt(t) {
        var e = t.prototype,
            n = e && Object.getPrototypeOf(e);
        return n && n.constructor;
      }

      function $t(t, e) {
        if (t && e) {
          if ("function" != typeof t) return !1;
          if ("function" != typeof e) return !1;
          if (t === e) return !0;

          for (;;) {
            if (!(t = Jt(t))) return !1;
            if (t === e) return !0;
          }
        }

        return !1;
      }

      function te(t) {
        for (var e = 0, n = Object.keys(t); e < n.length; e++) {
          delete t[n[e]];
        }
      }

      function ee(t) {
        return "string" != typeof t || t.startsWith(mt.prefix);
      }

      var ne = Ft(!0),
          ie = Ft(!0);

      function re(t, e) {
        return function (n, i) {
          if (i.prototype.hasOwnProperty(t) && delete e[i.prototype[t]], Pt(i.prototype, t, n), n) {
            var r = e[n];
            r && r !== i ? S("A Class already exists with the same " + t + ' : "' + n + '".') : e[n] = i;
          }
        };
      }

      var oe = re("__cid__", ne),
          se = re("__classname__", ie);

      function ae(t, e) {
        if (se(t, e), !e.prototype.hasOwnProperty(bt)) {
          var n = t || mt.getNewId();
          n && oe(n, e);
        }
      }

      function ue(t, e) {
        var n = ie[e],
            i = ne[e],
            r = !0;

        if (n && n !== t && (S('"' + e + '" has already been set as name or alias of another class.'), r = !1), i && i !== t && (S('"' + e + '" has already been set as id or alias of another class.'), r = !1), r) {
          var o = t[Bt];
          o || (o = [], t[Bt] = o), o.push(e), ie[e] = t, ne[e] = t;
        }
      }

      function ce() {
        for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) {
          e[n] = arguments[n];
        }

        for (var i = 0, r = e; i < r.length; i++) {
          var o = r[i],
              s = o.prototype,
              a = s.__cid__;
          a && delete ne[a];
          var u = s.__classname__;
          u && delete ie[u];
          var c = s[Bt];
          if (c) for (var h = 0; h < c.length; ++h) {
            var _ = c[h];
            delete ie[_], delete ne[_];
          }
        }
      }

      function he(t) {
        return ne[t];
      }

      function _e(t) {
        return ie[t];
      }

      function fe(t, e) {
        var n;
        if (e = void 0 === e || e, "function" == typeof t && t.prototype.hasOwnProperty(bt)) return n = t.prototype.__cid__, !e && i && ee(n) ? "" : n;

        if (t && t.constructor) {
          var r = t.constructor.prototype;
          if (r && r.hasOwnProperty(bt)) return n = t.__cid__, !e && i && ee(n) ? "" : n;
        }

        return "";
      }

      var le = t("cf", function () {
        var t = e.prototype;

        function e(t, e) {
          this.count = void 0, this._pool = void 0, this._cleanup = void 0;
          var n = void 0 === e ? t : e,
              i = void 0 === e ? null : t;
          this.count = 0, this._pool = new Array(n), this._cleanup = i;
        }

        return t.get = function () {
          return this._get();
        }, t._get = function () {
          if (this.count > 0) {
            --this.count;
            var t = this._pool[this.count];
            return this._pool[this.count] = null, t;
          }

          return null;
        }, t.put = function (t) {
          var e = this._pool;

          if (this.count < e.length) {
            if (this._cleanup && !1 === this._cleanup(t)) return;
            e[this.count] = t, ++this.count;
          }
        }, t.resize = function (t) {
          t >= 0 && (this._pool.length = t, this.count > t && (this.count = t));
        }, e;
      }()),
          Ae = t("cA", Nt),
          de = t("bX", {
        IDGenerator: gt,
        Pool: le,
        array: Nt,
        isNumber: Mt,
        isString: Lt,
        isEmptyObject: Ut,
        getPropertyDescriptor: zt,
        addon: Qt,
        mixin: Zt,
        extend: qt,
        getSuper: Jt,
        isChildClassOf: $t,
        clear: te,
        value: Pt,
        getset: wt,
        get: Dt,
        set: xt,
        unregisterClass: ce,
        getClassName: kt,
        setClassName: ae,
        setClassAlias: ue,
        getClassByName: _e,

        get _registeredClassNames() {
          return Q({}, ie);
        },

        set _registeredClassNames(t) {
          te(ie), Object.assign(ie, t);
        },

        get _registeredClassIds() {
          return Q({}, ne);
        },

        set _registeredClassIds(t) {
          te(ne), Object.assign(ne, t);
        },

        _getClassId: fe,
        _setClassId: oe,
        _getClassById: he,
        obsolete: Ht,
        obsoletes: Xt,
        formatStr: jt,
        shiftArguments: Yt,
        createMap: Ft
      });

      function Re(t) {
        if ("__bitmask__" in t) return t;
        Pt(t, "__bitmask__", null, !0);

        for (var e = -1, n = Object.keys(t), i = 0; i < n.length; i++) {
          var r = n[i],
              o = t[r];
          if (-1 === o) o = ++e, t[r] = o;else if ("number" == typeof o) e = o;else if ("string" == typeof o && Number.isInteger(parseFloat(r))) continue;
          var s = "" + o;
          r !== s && Pt(t, s, r);
        }

        return t;
      }

      function pe(t) {
        return "__enums__" in t ? t : (Pt(t, "__enums__", null, !0), pe.update(t));
      }

      function Ee(t) {
        t.hasOwnProperty("__enums__");
      }

      function Te(t) {
        Ee(t);
        var e = t.__enums__ || [];

        for (var n in e.length = 0, t) {
          var i = t[n];
          Number.isInteger(i) && e.push({
            name: n,
            value: i
          });
        }

        return e.sort(function (t, e) {
          return t.value - e.value;
        }), t.__enums__ = e, e;
      }

      c.js = de, t("by", Object.freeze({
        __proto__: null,
        array: Ae,
        js: de,
        IDGenerator: gt,
        Pool: le,
        isNumber: Mt,
        isString: Lt,
        isEmptyObject: Ut,
        value: Pt,
        getset: wt,
        get: Dt,
        set: xt,
        createMap: Ft,
        getClassName: kt,
        obsolete: Ht,
        obsoletes: Xt,
        formatStr: jt,
        shiftArguments: Yt,
        getPropertyDescriptor: zt,
        addon: Qt,
        mixin: Zt,
        extend: qt,
        getSuper: Jt,
        isChildClassOf: $t,
        clear: te,
        _idToClass: ne,
        _nameToClass: ie,
        _setClassId: oe,
        setClassName: ae,
        setClassAlias: ue,
        unregisterClass: ce,
        _getClassById: he,
        getClassByName: _e,
        _getClassId: fe
      })), Re.isBitMask = function (t) {
        return t && t.hasOwnProperty("__bitmask__");
      }, Re.getList = function (t) {
        if (t.__bitmask__) return t.__bitmask__;
        var e = t.__bitmask__ = [];

        for (var n in t) {
          var i = t[n];
          Number.isInteger(i) && e.push({
            name: n,
            value: i
          });
        }

        return e.sort(function (t, e) {
          return t.value - e.value;
        }), e;
      }, c.BitMask = Re, pe.update = function (t) {
        for (var e = -1, n = Object.keys(t), i = 0; i < n.length; i++) {
          var r = n[i],
              o = t[r];
          if (-1 === o) o = ++e, t[r] = o;else if ("number" == typeof o) e = o;else if ("string" == typeof o && Number.isInteger(parseFloat(r))) continue;
          var s = "" + o;
          r !== s && Pt(t, s, r);
        }

        return Array.isArray(t.__enums__) && Te(t), t;
      }, pe || (pe = t("bv", {})), pe.isEnum = function (t) {
        return t && t.hasOwnProperty("__enums__");
      }, pe.getList = function (t) {
        return Ee(t), t.__enums__ ? t.__enums__ : Te(t);
      }, c.Enum = pe;
      var ve = t("bx", function () {
        function t() {}

        var e = t.prototype;
        return e.clone = function () {
          return L(100, kt(this) + ".clone"), this;
        }, e.equals = function () {
          return !1;
        }, e.set = function () {
          L(100, kt(this) + ".set");
        }, e.toString = function () {
          return "";
        }, t;
      }());
      ae("cc.ValueType", ve), c.ValueType = ve;
      var Se = t("bQ", {
        SUPPORT_TEXTURE_FORMATS: [".astc", ".pkm", ".pvr", ".webp", ".jpg", ".jpeg", ".bmp", ".png"],
        KEY: {
          none: 0,
          back: 6,
          menu: 18,
          backspace: 8,
          tab: 9,
          enter: 13,
          shift: 16,
          ctrl: 17,
          alt: 18,
          pause: 19,
          capslock: 20,
          escape: 27,
          space: 32,
          pageup: 33,
          pagedown: 34,
          end: 35,
          home: 36,
          left: 37,
          up: 38,
          right: 39,
          down: 40,
          select: 41,
          insert: 45,
          Delete: 46,
          0: 48,
          1: 49,
          2: 50,
          3: 51,
          4: 52,
          5: 53,
          6: 54,
          7: 55,
          8: 56,
          9: 57,
          a: 65,
          b: 66,
          c: 67,
          d: 68,
          e: 69,
          f: 70,
          g: 71,
          h: 72,
          i: 73,
          j: 74,
          k: 75,
          l: 76,
          m: 77,
          n: 78,
          o: 79,
          p: 80,
          q: 81,
          r: 82,
          s: 83,
          t: 84,
          u: 85,
          v: 86,
          w: 87,
          x: 88,
          y: 89,
          z: 90,
          num0: 96,
          num1: 97,
          num2: 98,
          num3: 99,
          num4: 100,
          num5: 101,
          num6: 102,
          num7: 103,
          num8: 104,
          num9: 105,
          "*": 106,
          "+": 107,
          "-": 109,
          numdel: 110,
          "/": 111,
          f1: 112,
          f2: 113,
          f3: 114,
          f4: 115,
          f5: 116,
          f6: 117,
          f7: 118,
          f8: 119,
          f9: 120,
          f10: 121,
          f11: 122,
          f12: 123,
          numlock: 144,
          scrolllock: 145,
          ";": 186,
          semicolon: 186,
          equal: 187,
          "=": 187,
          ",": 188,
          comma: 188,
          dash: 189,
          ".": 190,
          period: 190,
          forwardslash: 191,
          grave: 192,
          "[": 219,
          openbracket: 219,
          backslash: 220,
          "]": 221,
          closebracket: 221,
          quote: 222,
          dpadLeft: 1e3,
          dpadRight: 1001,
          dpadUp: 1003,
          dpadDown: 1004,
          dpadCenter: 1005
        },
        RAD: Math.PI / 180,
        DEG: 180 / Math.PI,
        REPEAT_FOREVER: Number.MAX_VALUE - 1,
        FLT_EPSILON: 1.192092896e-7,
        ORIENTATION_PORTRAIT: 1,
        ORIENTATION_LANDSCAPE: 2,
        ORIENTATION_AUTO: 3,
        ENABLE_TILEDMAP_CULLING: !0,
        TOUCH_TIMEOUT: 5e3,
        ENABLE_TRANSPARENT_CANVAS: !1,
        ENABLE_WEBGL_ANTIALIAS: !0,
        ENABLE_ANTIALIAS_FXAA: !1,
        ENABLE_BLOOM: !1,
        CLEANUP_IMAGE_CACHE: !1,
        ENABLE_MULTI_TOUCH: !0,
        MAX_LABEL_CANVAS_POOL_SIZE: 20,
        ENABLE_WEBGL_HIGHP_STRUCT_VALUES: !1,
        BATCHER2D_MEM_INCREMENT: 144
      });
      c.macro = Se;

      for (var Ne = t("ch", /^(?:cc|dragonBones|sp|ccsg)\..+/), Ie = new Array(123), Ce = 0; Ce < 123; ++Ce) {
        Ie[Ce] = 64;
      }

      for (var Oe = 0; Oe < 64; ++Oe) {
        Ie["ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".charCodeAt(Oe)] = Oe;
      }

      var ye = t("b_", Ie);

      function ge(t, e, n) {
        function i(t, e, n, i) {
          var r = Object.getOwnPropertyDescriptor(t, e);
          if (r) r.get && (t[n] = r.get), r.set && i && (t[i] = r.set);else {
            var o = t[n];
            wt(t, e, o, t[i]);
          }
        }

        for (var r, o = t.prototype, s = 0; s < e.length; s++) {
          var a = (r = e[s])[0].toUpperCase() + r.slice(1);
          i(o, r, "get" + a, "set" + a);
        }

        for (r in n) {
          var u = n[r];
          i(o, r, u[0], u[1]);
        }
      }

      function me(t, e, n, i) {
        var r = t[e];
        r ? Array.isArray(r) ? i ? (r.push(r[0]), r[0] = n) : r.push(n) : t[e] = i ? [n, r] : [r, n] : t[e] = n;
      }

      function Be(t, e) {
        if ("function" == typeof t.contains) return t.contains(e);
        if ("function" == typeof t.compareDocumentPosition) return !!(16 & t.compareDocumentPosition(e));
        var n = e.parentNode;
        if (n) do {
          if (n === t) return !0;
          n = n.parentNode;
        } while (null !== n);
        return !1;
      }

      function be(t) {
        return "object" == (typeof window === "undefined" ? "undefined" : _typeof2(window)) && "function" == typeof Node ? t instanceof Node : t && "object" == _typeof2(t) && "number" == typeof t.nodeType && "string" == typeof t.nodeName;
      }

      function Me(t, e, n) {
        t && setTimeout(function () {
          t(e, n);
        }, 0);
      }

      function Le(t) {
        return !(!t || t.constructor !== Object) && Ut(t);
      }

      function Ue(t, e, n) {
        if (e > n) {
          var i = e;
          e = n, n = i;
        }

        return t < e ? e : t < n ? t : n;
      }

      function Ge(t) {
        return t * Se.RAD;
      }

      function Pe(t) {
        return t * Se.DEG;
      }

      c.misc = {
        BUILTIN_CLASSID_RE: Ne,
        BASE64_VALUES: ye,
        propertyDefine: ge,
        pushToMap: me,
        contains: Be,
        isDomNode: be,
        callInNextTick: Me,
        isPlainEmptyObj_DEV: Le,
        clampf: Ue,
        degreesToRadians: Ge,
        radiansToDegrees: Pe
      }, t("bz", Object.freeze({
        __proto__: null,
        BUILTIN_CLASSID_RE: Ne,
        BASE64_VALUES: ye,
        propertyDefine: ge,
        pushToMap: me,
        contains: Be,
        isDomNode: be,
        callInNextTick: Me,
        tryCatchFunctor_EDITOR: function tryCatchFunctor_EDITOR(t) {
          return Function("target", "try {\n  target." + t + "();\n}\ncatch (e) {\n  cc._throw(e);\n}");
        },
        isPlainEmptyObj_DEV: Le,
        clampf: Ue,
        degreesToRadians: Ge,
        radiansToDegrees: Pe
      }));
      var we = t("cl", "$_$");

      function De(t, e) {
        var n = e ? Object.create(e) : {};
        return Pt(t, "__attrs__", n), n;
      }

      function xe(t) {
        if ("function" != typeof t) return De(t, ke(t.constructor));

        for (var e, n = c.Class.getInheritanceChain(t), i = n.length - 1; i >= 0; i--) {
          var r = n[i];
          r.hasOwnProperty("__attrs__") && r.__attrs__ || De(r, (e = n[i + 1]) && e.__attrs__);
        }

        return De(t, (e = n[0]) && e.__attrs__), t.__attrs__;
      }

      function Fe(t, e) {
        var n = ke(t),
            i = e + we,
            r = {};

        for (var o in n) {
          o.startsWith(i) && (r[o.slice(i.length)] = n[o]);
        }

        return r;
      }

      function ke(t) {
        return t.hasOwnProperty("__attrs__") && t.__attrs__ || xe(t);
      }

      function He(t, e, n, i) {
        ke(t)[e + we + n] = i;
      }

      var Xe = t("cm", function () {
        function t(t, e) {
          this.name = void 0, this.default = void 0, this.name = t, this.default = e;
        }

        return t.prototype.toString = function () {
          return this.name;
        }, t;
      }()),
          We = t("bE", new Xe("Integer", 0));
      c.Integer = We, c.CCInteger = We;
      var Ve = t("bF", new Xe("Float", 0));
      c.Float = Ve, c.CCFloat = Ve;
      var je = t("bG", new Xe("Boolean", !1));
      c.Boolean = je, c.CCBoolean = je;
      var Ye = t("bH", new Xe("String", ""));

      function ze(t, e) {
        return function (n, i) {
          var r = '"' + kt(n) + "." + i + '"',
              o = Fe(n, i),
              s = o.type;

          if (s === We || s === Ve ? s = "Number" : s !== Ye && s !== je || (s = "" + s), s === t) {
            if (o.hasOwnProperty("default")) {
              var a = o.default;

              if (void 0 !== a && !Array.isArray(a) && !Le(a)) {
                var u = _typeof2(a),
                    c = t.toLowerCase();

                if (u === c) {
                  if ("object" === c) {
                    if (!a || a instanceof o.ctor) return;
                    b(3605, r, kt(o.ctor));
                  } else "Number" !== t && b(3606, e, r, t);
                } else {
                  if ("function" === u) return;
                  t === Ye.default && null == a ? b(3607, r) : b(3611, e, r, u);
                }
                delete o.type;
              }
            }
          } else b(3604, r);
        };
      }

      c.String = Ye, c.CCString = Ye;
      var Ke = Object.freeze({
        __proto__: null,
        DELIMETER: we,
        createAttrsSingle: De,
        createAttrs: xe,
        attr: Fe,
        getClassAttrs: ke,
        setClassAttr: He,
        PrimitiveType: Xe,
        CCInteger: We,
        CCFloat: Ve,
        CCBoolean: je,
        CCString: Ye,
        getTypeChecker_ET: ze,
        getObjTypeChecker_ET: function getObjTypeChecker_ET(t) {
          return function (e, n) {
            ze("Object", "type")(e, n);
            var i = ke(e)[n + we + "default"],
                r = c.Class.getDefault(i);

            if (!Array.isArray(r) && $t(t, c.ValueType)) {
              var o = kt(t),
                  s = jt('No need to specify the "type" of "%s.%s" because %s is a child class of ValueType.', kt(e), n, o);
              i ? T(s) : b(3612, s, o, kt(e), n, o);
            }
          };
        }
      }),
          Qe = {
        default: {},
        serializable: {},
        editorOnly: {},
        formerlySerializedAs: {}
      };

      function Ze(t, e, n, i) {
        if (!t.get && !t.set && t.hasOwnProperty("default")) {
          var r = "_N$" + e;
          t.get = function () {
            return this[r];
          }, t.set = function (t) {
            var e = this[r];
            this[r] = t, n.call(this, e);
          };
          var o = {};

          for (var s in i[r] = o, Qe) {
            var a = Qe[s];
            t.hasOwnProperty(s) && (o[s] = t[s], a.canUsedInGet || delete t[s]);
          }
        }
      }

      function qe(t, e, n, i) {
        if (Array.isArray(e)) {
          if (!(e.length > 0)) return L(5508, n, i);
          t.type = e = e[0];
        }

        "function" == typeof e && (e === String ? t.type = c.String : e === Boolean ? t.type = c.Boolean : e === Number && (t.type = c.Float));
      }

      function Je(t, e, n) {
        var i = t ? {
          _short: !0
        } : {
          _short: !0,
          default: e
        };
        return n && (i.type = n), i;
      }

      function $e(t, e) {
        if (!t || t.constructor !== Object) {
          if (Array.isArray(t) && t.length > 0) return Je(e, [], t);

          if ("function" == typeof t) {
            var n = t;
            return Je(e, $t(n, c.ValueType) ? new n() : null, n);
          }

          return Je(e, t instanceof Xe ? t.default : t);
        }

        return null;
      }

      var tn,
          en = [];

      function nn() {
        return en[en.length - 1];
      }

      c._RF = {
        push: function push(t, e, n, i) {
          void 0 === n && (n = e, e = ""), en.push({
            uuid: e,
            script: n,
            module: t,
            exports: t.exports,
            beh: null,
            importMeta: i
          });
        },
        pop: function pop() {
          var t = en.pop(),
              e = t.module,
              n = e.exports;

          if (n === t.exports) {
            for (var i in n) {
              return;
            }

            e.exports = n = t.cls;
          }
        },
        peek: nn
      }, function (t) {
        t[t.STANDALONE = 1] = "STANDALONE", t[t.IMPLICIT_VISIBLE = 2] = "IMPLICIT_VISIBLE", t[t.IMPLICIT_SERIALIZABLE = 4] = "IMPLICIT_SERIALIZABLE";
      }(tn || (tn = t("bZ", {})));
      var rn = we,
          on = {
        datas: null,
        push: function push(t) {
          if (this.datas) this.datas.push(t);else {
            this.datas = [t];
            var e = this;
            setTimeout(function () {
              e.init();
            }, 0);
          }
        },
        init: function init() {
          var t = this.datas;

          if (t) {
            for (var e = 0; e < t.length; ++e) {
              var n = t[e],
                  i = n.cls,
                  r = n.props;
              "function" == typeof r && (r = r());
              var o = kt(i);
              r ? hn(i, o, r, i.$super, n.mixins) : L(3633, o);
            }

            this.datas = null;
          }
        }
      };

      function sn(t, e, n, i) {
        !function (t, e) {
          !function (t, e) {
            t.indexOf(e) < 0 && t.push(e);
          }(t.__props__, e);
        }(t, n), ln(t, i, e, n);
      }

      function an(t, e, n, i) {
        var r = i.get;
        i.set, r && (ln(t, i, e, n), He(t, n, "serializable", !1));
      }

      function un(t) {
        return "function" == typeof t ? t() : t;
      }

      function cn(t, e, n) {
        for (var i in e) {
          t.hasOwnProperty(i) || n && !n(i) || Object.defineProperty(t, i, zt(e, i));
        }
      }

      function hn(t, e, n, i, r) {
        if (t.__props__ = [], i && i.__props__ && (t.__props__ = i.__props__.slice()), r) for (var o = 0; o < r.length; ++o) {
          var s = r[o];
          s.__props__ && (t.__props__ = t.__props__.concat(s.__props__.filter(function (e) {
            return t.__props__.indexOf(e) < 0;
          })));
        }
        if (n) for (var a in function (t, e) {
          for (var n in t) {
            var i = t[n],
                r = $e(i, !1);

            if (r && (i = t[n] = r), i) {
              var o = i.notify;
              o && Ze(i, n, o, t), "type" in i && qe(i, i.type, e, n);
            }
          }
        }(n, e), n) {
          var u = n[a];
          u.get || u.set ? an(t, e, a, u) : sn(t, e, a, u);
        }
        var c = ke(t);
        t.__values__ = t.__props__.filter(function (t) {
          return !1 !== c[t + rn + "serializable"];
        });
      }

      function _n(t) {
        var e = t.name,
            n = t.extends,
            i = t.mixins,
            r = function (t, e, n, i) {
          var r = c.Component,
              o = nn();

          if (o && $t(e, r)) {
            if ($t(o.cls, r)) return L(3615), null;
            t = t || o.script;
          }

          var s = function (t, e, n, i) {
            var r = i.ctor,
                o = [r],
                s = r;
            Pt(s, "__ctors__", o.length > 0 ? o : null, !0);
            var a = s.prototype;

            if (e && (s.$super = e), n) {
              for (var u = n.length - 1; u >= 0; u--) {
                var c = n[u];
                cn(a, c.prototype), _n._isCCClass(c) && cn(ke(s), ke(c));
              }

              a.constructor = s;
            }

            return ae(t, s), s;
          }(t, e, n, i);

          if (o) if ($t(e, r)) {
            var a = o.uuid;
            a && oe(a, s), o.cls = s;
          } else $t(o.cls, r) || (o.cls = s);
          return s;
        }(e, n, i, t);

        e || (e = c.js.getClassName(r)), r._sealed = !0, n && (n._sealed = !1);
        var o = t.properties;
        "function" == typeof o || n && null === n.__props__ || i && i.some(function (t) {
          return null === t.__props__;
        }) ? (on.push({
          cls: r,
          props: o,
          mixins: i
        }), r.__props__ = r.__values__ = null) : hn(r, e, o, n, t.mixins);
        var s = t.editor;
        return s && $t(n, c.Component) && c.Component._registerEditorProps(r, s), r;
      }

      _n._isCCClass = function (t) {
        var e;
        return null == t || null === (e = t.hasOwnProperty) || void 0 === e ? void 0 : e.call(t, "__ctors__");
      }, _n.fastDefine = function (t, e, n) {
        ae(t, e);

        for (var i = e.__props__ = e.__values__ = Object.keys(n), r = ke(e), o = 0; o < i.length; o++) {
          var s = i[o];
          r[s + rn + "visible"] = !1, r[s + rn + "default"] = n[s];
        }
      }, _n.Attr = Ke, _n.attr = Fe, _n.getInheritanceChain = function (t) {
        for (var e = []; t = Jt(t);) {
          t !== Object && e.push(t);
        }

        return e;
      };
      var fn = {
        Integer: "Number",
        Float: "Number",
        Boolean: "Boolean",
        String: "String"
      };

      function ln(t, e, n, i) {
        var r = null,
            o = "";

        function s() {
          return o = i + rn, r = ke(t);
        }

        "type" in e && void 0 === e.type && b(3660, i, n);
        var a = e.type;
        a && (fn[a] ? (r || s())[o + "type"] = a : "Object" === a || ("object" == _typeof2(a) ? pe.isEnum(a) ? ((r || s())[o + "type"] = "Enum", r[o + "enumList"] = pe.getList(a)) : Re.isBitMask(a) && ((r || s())[o + "type"] = "BitMask", r[o + "bitmaskList"] = Re.getList(a)) : "function" == typeof a && ((r || s())[o + "type"] = "Object", r[o + "ctor"] = a))), "default" in e && ((r || s())[o + "default"] = e.default);

        var u,
            c = function c(t, n) {
          if (t in e) {
            var i = e[t];
            _typeof2(i) === n && ((r || s())[o + t] = i);
          }
        };

        e.editorOnly && ((r || s())[o + "editorOnly"] = !0), e.__internalFlags & tn.STANDALONE ? u = !0 === e.serializable || 0 != (e.__internalFlags & tn.IMPLICIT_SERIALIZABLE) : !1 === e.serializable && (u = !1), void 0 !== u && ((r || s())[o + "serializable"] = u), c("formerlySerializedAs", "string");
        var h = e.range;
        h && Array.isArray(h) && h.length >= 2 && ((r || s())[o + "min"] = h[0], r[o + "max"] = h[1], h.length > 2 && (r[o + "step"] = h[2])), c("min", "number"), c("max", "number"), c("step", "number");
      }

      _n.isArray = function (t) {
        return t = un(t), Array.isArray(t);
      }, _n.getDefault = un, _n.escapeForJS = function (t) {
        return JSON.stringify(t).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
      }, _n.IDENTIFIER_RE = /^[A-Za-z_$][0-9A-Za-z_$]*$/, _n.getNewValueTypeCode = !1, c.Class = _n;
      var An,
          dn = t("bI", "__editorExtras__"),
          Rn = 1 << 22,
          pn = [],
          En = t("bC", function () {
        function t(t) {
          void 0 === t && (t = ""), this._objFlags = void 0, this._name = void 0, this._name = t, this._objFlags = 0;
        }

        t._deferredDestroy = function () {
          for (var t = pn.length, e = 0; e < t; ++e) {
            var n = pn[e];
            1 & n._objFlags || n._destroyImmediate();
          }

          t === pn.length ? pn.length = 0 : pn.splice(0, t);
        };

        var e = t.prototype;
        return e.destroy = function () {
          return 1 & this._objFlags ? (b(5e3), !1) : !(4 & this._objFlags || (this._objFlags |= 4, pn.push(this), 0));
        }, e._destruct = function () {
          var t = this.constructor,
              e = t.__destruct__;
          e || (e = function (t, e) {
            var n,
                i = t instanceof c._BaseNode || t instanceof c.Component,
                r = i ? "_id" : null,
                o = {};

            for (n in t) {
              if (t.hasOwnProperty(n)) {
                if (n === r) continue;

                switch (_typeof2(t[n])) {
                  case "string":
                    o[n] = "";
                    break;

                  case "object":
                  case "function":
                    o[n] = null;
                }
              }
            }

            if (_n._isCCClass(e)) for (var s = c.Class.Attr.getClassAttrs(e), a = e.__props__, u = 0; u < a.length; u++) {
              var h = (n = a[u]) + c.Class.Attr.DELIMETER + "default";

              if (h in s) {
                if (i && "_id" === n) continue;

                switch (_typeof2(s[h])) {
                  case "string":
                    o[n] = "";
                    break;

                  case "object":
                  case "function":
                    o[n] = null;
                    break;

                  case "undefined":
                    o[n] = void 0;
                }
              }
            }
            return function (t) {
              for (var e in o) {
                t[e] = o[e];
              }
            };
          }(this, t), Pt(t, "__destruct__", e, !0)), e(this);
        }, e._destroyImmediate = function () {
          1 & this._objFlags ? L(5e3) : (this._onPreDestroy && this._onPreDestroy(), this._destruct(), this._objFlags |= 1);
        }, K(t, [{
          key: "name",
          get: function get() {
            return this._name;
          },
          set: function set(t) {
            this._name = t;
          }
        }, {
          key: "hideFlags",
          get: function get() {
            return this._objFlags & t.Flags.AllHideMasks;
          },
          set: function set(e) {
            var n = e & t.Flags.AllHideMasks;
            this._objFlags = this._objFlags & ~t.Flags.AllHideMasks | n;
          }
        }, {
          key: "replicated",
          get: function get() {
            return !!(this._objFlags & Rn);
          },
          set: function set(t) {
            t ? this._objFlags |= Rn : this._objFlags &= -4194305;
          }
        }, {
          key: "isValid",
          get: function get() {
            return !(1 & this._objFlags);
          }
        }]), t;
      }()),
          Tn = En.prototype;

      function vn(t, e) {
        return "object" == _typeof2(t) ? !(!t || t._objFlags & (e ? 5 : 1)) : void 0 !== t;
      }

      Tn._deserialize = null, Tn._onPreDestroy = null, _n.fastDefine("cc.Object", En, ((An = {
        _name: "",
        _objFlags: 0
      })[dn] = {}, An)), _n.Attr.setClassAttr(En, dn, "editorOnly", !0), _n.Attr.setClassAttr(En, "replicated", "visible", !1), Pt(En, "Flags", {
        Destroyed: 1,
        DontSave: 8,
        EditorOnly: 16,
        Dirty: 32,
        DontDestroy: 64,
        PersistentMask: -4192741,
        Destroying: 128,
        Deactivating: 256,
        LockedInEditor: 512,
        HideInHierarchy: 1024,
        AllHideMasks: 1560,
        IsPreloadStarted: 8192,
        IsOnLoadStarted: 32768,
        IsOnLoadCalled: 16384,
        IsOnEnableCalled: 2048,
        IsStartCalled: 65536,
        IsEditorOnEnableCalled: 4096,
        IsPositionLocked: 1 << 21,
        IsRotationLocked: 1 << 17,
        IsScaleLocked: 1 << 18,
        IsAnchorLocked: 1 << 19,
        IsSizeLocked: 1 << 20
      }), c.isValid = vn, c.Object = En;
      var Sn = Ae.fastRemoveAt;

      function Nn() {}

      var In = function () {
        function t() {
          this.callback = Nn, this.target = void 0, this.once = !1;
        }

        var e = t.prototype;
        return e.set = function (t, e, n) {
          this.callback = t || Nn, this.target = e, this.once = !!n;
        }, e.reset = function () {
          this.target = void 0, this.callback = Nn, this.once = !1;
        }, e.check = function () {
          return !(this.target instanceof En && !vn(this.target, !0));
        }, t;
      }(),
          Cn = new yt(function () {
        return new In();
      }, 32),
          On = function () {
        function t() {
          this.callbackInfos = [], this.isInvoking = !1, this.containCanceled = !1;
        }

        var e = t.prototype;
        return e.removeByCallback = function (t) {
          for (var e = 0; e < this.callbackInfos.length; ++e) {
            var n = this.callbackInfos[e];
            n && n.callback === t && (n.reset(), Cn.free(n), Sn(this.callbackInfos, e), --e);
          }
        }, e.removeByTarget = function (t) {
          for (var e = 0; e < this.callbackInfos.length; ++e) {
            var n = this.callbackInfos[e];
            n && n.target === t && (n.reset(), Cn.free(n), Sn(this.callbackInfos, e), --e);
          }
        }, e.cancel = function (t) {
          var e = this.callbackInfos[t];
          e && (e.reset(), this.isInvoking ? this.callbackInfos[t] = null : Sn(this.callbackInfos, t), Cn.free(e)), this.containCanceled = !0;
        }, e.cancelAll = function () {
          for (var t = 0; t < this.callbackInfos.length; t++) {
            var e = this.callbackInfos[t];
            e && (e.reset(), Cn.free(e), this.callbackInfos[t] = null);
          }

          this.containCanceled = !0;
        }, e.purgeCanceled = function () {
          for (var t = this.callbackInfos.length - 1; t >= 0; --t) {
            this.callbackInfos[t] || Sn(this.callbackInfos, t);
          }

          this.containCanceled = !1;
        }, e.clear = function () {
          this.cancelAll(), this.callbackInfos.length = 0, this.isInvoking = !1, this.containCanceled = !1;
        }, t;
      }(),
          yn = new yt(function () {
        return new On();
      }, 16),
          gn = t("cy", function () {
        function t() {
          this._callbackTable = Ft(!0), this._offCallback = void 0;
        }

        var e = t.prototype;
        return e.on = function (t, e, n, i) {
          if (!this.hasEventListener(t, e, n)) {
            var r = this._callbackTable[t];
            r || (r = this._callbackTable[t] = yn.alloc());
            var o = Cn.alloc();
            o.set(e, n, i), r.callbackInfos.push(o);
          }

          return e;
        }, e.hasEventListener = function (t, e, n) {
          var i = this._callbackTable && this._callbackTable[t];
          if (!i) return !1;
          var r = i.callbackInfos;

          if (!e) {
            if (i.isInvoking) {
              for (var o = 0; o < r.length; ++o) {
                if (r[o]) return !0;
              }

              return !1;
            }

            return r.length > 0;
          }

          for (var s = 0; s < r.length; ++s) {
            var a = r[s];
            if (a && a.check() && a.callback === e && a.target === n) return !0;
          }

          return !1;
        }, e.removeAll = function (t) {
          var e = _typeof2(t);

          if ("string" === e || "number" === e) {
            var n = this._callbackTable && this._callbackTable[t];
            n && (n.isInvoking ? n.cancelAll() : (n.clear(), yn.free(n), delete this._callbackTable[t]));
          } else if (t) for (var i in this._callbackTable) {
            var r = this._callbackTable[i];
            if (r.isInvoking) for (var o = r.callbackInfos, s = 0; s < o.length; ++s) {
              var a = o[s];
              a && a.target === t && r.cancel(s);
            } else r.removeByTarget(t);
          }
        }, e.off = function (t, e, n) {
          var i,
              r = this._callbackTable && this._callbackTable[t];

          if (r) {
            var o = r.callbackInfos;
            if (e) for (var s = 0; s < o.length; ++s) {
              var a = o[s];

              if (a && a.callback === e && a.target === n) {
                r.cancel(s);
                break;
              }
            } else this.removeAll(t);
          }

          null === (i = this._offCallback) || void 0 === i || i.call(this);
        }, e.emit = function (t, e, n, i, r, o) {
          var s = this._callbackTable && this._callbackTable[t];

          if (s) {
            var a = !s.isInvoking;
            s.isInvoking = !0;

            for (var u = s.callbackInfos, c = 0, h = u.length; c < h; ++c) {
              var _ = u[c];

              if (_) {
                var f = _.callback,
                    l = _.target;
                _.once && this.off(t, f, l), _.check() ? l ? f.call(l, e, n, i, r, o) : f(e, n, i, r, o) : this.off(t, f, l);
              }
            }

            a && (s.isInvoking = !1, s.containCanceled && s.purgeCanceled());
          }
        }, e.clear = function () {
          for (var t in this._callbackTable) {
            var e = this._callbackTable[t];
            e && (e.clear(), yn.free(e), delete this._callbackTable[t]);
          }
        }, e._registerOffCallback = function (t) {
          this._offCallback = t;
        }, t;
      }());

      function mn(t) {
        for (var e = function (t) {
          function e() {
            for (var e, n = arguments.length, i = new Array(n), r = 0; r < n; r++) {
              i[r] = arguments[r];
            }

            return (e = t.call.apply(t, [this].concat(i)) || this)._callbackTable = Ft(!0), e;
          }

          Z(e, t);
          var n = e.prototype;
          return n.once = function (t, e, n) {
            return this.on(t, e, n, !0);
          }, n.targetOff = function (t) {
            this.removeAll(t);
          }, e;
        }(t), n = gn.prototype, i = Object.getOwnPropertyNames(n).concat(Object.getOwnPropertySymbols(n)), r = 0; r < i.length; ++r) {
          var o = i[r];

          if (!(o in e.prototype)) {
            var s = Object.getOwnPropertyDescriptor(n, o);
            s && Object.defineProperty(e.prototype, o, s);
          }
        }

        return e;
      }

      var Bn,
          bn,
          Mn,
          Ln,
          Un,
          Gn,
          Pn,
          wn = t("bJ", mn(function () {}));
      c.EventTarget = wn, function (t) {
        t.UNKNOWN = "unknown", t.WECHAT = "wechat", t.ANDROID = "androidbrowser", t.IE = "ie", t.EDGE = "edge", t.QQ = "qqbrowser", t.MOBILE_QQ = "mqqbrowser", t.UC = "ucbrowser", t.UCBS = "ucbs", t.BROWSER_360 = "360browser", t.BAIDU_APP = "baiduboxapp", t.BAIDU = "baidubrowser", t.MAXTHON = "maxthon", t.OPERA = "opera", t.OUPENG = "oupeng", t.MIUI = "miuibrowser", t.FIREFOX = "firefox", t.SAFARI = "safari", t.CHROME = "chrome", t.LIEBAO = "liebao", t.QZONE = "qzone", t.SOUGOU = "sogou", t.HUAWEI = "huawei";
      }(Bn || (Bn = t("cd", {}))), function (t) {
        t.UNKNOWN = "unknown", t.ENGLISH = "en", t.CHINESE = "zh", t.FRENCH = "fr", t.ITALIAN = "it", t.GERMAN = "de", t.SPANISH = "es", t.DUTCH = "du", t.RUSSIAN = "ru", t.KOREAN = "ko", t.JAPANESE = "ja", t.HUNGARIAN = "hu", t.PORTUGUESE = "pt", t.ARABIC = "ar", t.NORWEGIAN = "no", t.POLISH = "pl", t.TURKISH = "tr", t.UKRAINIAN = "uk", t.ROMANIAN = "ro", t.BULGARIAN = "bg";
      }(bn || (bn = t("cb", {}))), function (t) {
        t[t.NONE = 0] = "NONE", t[t.LAN = 1] = "LAN", t[t.WWAN = 2] = "WWAN";
      }(Mn || (Mn = t("ca", {}))), function (t) {
        t.UNKNOWN = "Unknown", t.IOS = "iOS", t.ANDROID = "Android", t.WINDOWS = "Windows", t.LINUX = "Linux", t.OSX = "OS X", t.OHOS = "OHOS";
      }(Ln || (Ln = t("bS", {}))), function (t) {
        t.UNKNOWN = "UNKNOWN", t.EDITOR_PAGE = "EDITOR_PAGE", t.EDITOR_CORE = "EDITOR_CORE", t.MOBILE_BROWSER = "MOBILE_BROWSER", t.DESKTOP_BROWSER = "DESKTOP_BROWSER", t.WIN32 = "WIN32", t.ANDROID = "ANDROID", t.IOS = "IOS", t.MACOS = "MACOS", t.OHOS = "OHOS", t.WECHAT_GAME = "WECHAT_GAME", t.BAIDU_MINI_GAME = "BAIDU_MINI_GAME", t.XIAOMI_QUICK_GAME = "XIAOMI_QUICK_GAME", t.ALIPAY_MINI_GAME = "ALIPAY_MINI_GAME", t.BYTEDANCE_MINI_GAME = "BYTEDANCE_MINI_GAME", t.OPPO_MINI_GAME = "OPPO_MINI_GAME", t.VIVO_MINI_GAME = "VIVO_MINI_GAME", t.HUAWEI_QUICK_GAME = "HUAWEI_QUICK_GAME", t.COCOSPLAY = "COCOSPLAY", t.LINKSURE_MINI_GAME = "LINKSURE_MINI_GAME", t.QTT_MINI_GAME = "QTT_MINI_GAME";
      }(Un || (Un = t("cc", {}))), function (t) {
        t.WEBP = "WEBP", t.IMAGE_BITMAP = "IMAGE_BITMAP", t.WEB_VIEW = "WEB_VIEW", t.VIDEO_PLAYER = "VIDEO_PLAYER", t.SAFE_AREA = "SAFE_AREA", t.INPUT_TOUCH = "INPUT_TOUCH", t.EVENT_KEYBOARD = "EVENT_KEYBOARD", t.EVENT_MOUSE = "EVENT_MOUSE", t.EVENT_TOUCH = "EVENT_TOUCH", t.EVENT_ACCELEROMETER = "EVENT_ACCELEROMETER";
      }(Gn || (Gn = t("c9", {}))), Pn = Un.WECHAT_GAME;

      var Dn = function (t) {
        function n() {
          var n, i;
          (i = t.call(this) || this).networkType = void 0, i.isNative = void 0, i.isBrowser = void 0, i.isMobile = void 0, i.isLittleEndian = void 0, i.platform = void 0, i.language = void 0, i.nativeLanguage = void 0, i.os = void 0, i.osVersion = void 0, i.osMainVersion = void 0, i.browserType = void 0, i.browserVersion = void 0, i._featureMap = void 0;
          var r,
              o = ot.getSystemInfoSync();
          i.networkType = Mn.LAN, i.isNative = !1, i.isBrowser = !1, i.isLittleEndian = (r = new ArrayBuffer(2), new DataView(r).setInt16(0, 256, !0), 256 === new Int16Array(r)[0]), i.nativeLanguage = o.language, i.language = o.language.substr(0, 2);
          var s = o.platform.toLocaleLowerCase();
          i.os = "android" === s ? Ln.ANDROID : "ios" === s ? Ln.IOS : "windows" === s ? Ln.WINDOWS : Ln.UNKNOWN;
          var a = o.system.toLowerCase();
          "android p" === a && (a = "android p 9.0");
          var u = /[\d.]+/.exec(a);
          i.osVersion = u ? u[0] : a, i.osMainVersion = parseInt(i.osVersion), i.platform = Pn, i.isMobile = i.os !== Ln.WINDOWS, i.browserType = Bn.UNKNOWN, i.browserVersion = "";
          var c,
              h = document.createElement("canvas");

          try {
            c = h.toDataURL("image/webp").startsWith("data:image/webp");
          } catch (t) {
            c = !1;
          }

          var _ = i.os === Ln.WINDOWS && !ot.isDevTool;

          return i._featureMap = ((n = {})[Gn.WEBP] = c, n[Gn.IMAGE_BITMAP] = !1, n[Gn.WEB_VIEW] = !1, n[Gn.VIDEO_PLAYER] = e, n[Gn.SAFE_AREA] = e, n[Gn.INPUT_TOUCH] = !_, n[Gn.EVENT_KEYBOARD] = _, n[Gn.EVENT_MOUSE] = _, n[Gn.EVENT_TOUCH] = !0, n[Gn.EVENT_ACCELEROMETER] = !_, n), i._registerEvent(), i;
        }

        Z(n, t);
        var i = n.prototype;
        return i._registerEvent = function () {
          var t = this;
          ot.onHide(function () {
            t.emit("hide");
          }), ot.onShow(function () {
            t.emit("show");
          });
        }, i.hasFeature = function (t) {
          return this._featureMap[t];
        }, i.getBatteryLevel = function () {
          return ot.getBatteryInfoSync().level / 100;
        }, i.triggerGC = function () {
          ot.triggerGC();
        }, i.openURL = function () {}, i.now = function () {
          return Date.now ? Date.now() : +new Date();
        }, i.restartJSVM = function () {}, i.close = function () {}, n;
      }(wn),
          xn = (t("bR", new Dn()), t("cT", 2147483647));

      function Fn(t) {
        return (t > 0) - (t < 0);
      }

      function kn(t) {
        var e, n;
        return e = (t > 65535) << 4, e |= n = ((t >>>= e) > 255) << 3, e |= n = ((t >>>= n) > 15) << 2, (e |= n = ((t >>>= n) > 3) << 1) | (t >>>= n) >> 1;
      }

      function Hn(t) {
        return 16843009 * ((t = (858993459 & (t -= t >>> 1 & 1431655765)) + (t >>> 2 & 858993459)) + (t >>> 4) & 252645135) >>> 24;
      }

      function Xn(t) {
        var e = 32;
        return (t &= -t) && e--, 65535 & t && (e -= 16), 16711935 & t && (e -= 8), 252645135 & t && (e -= 4), 858993459 & t && (e -= 2), 1431655765 & t && (e -= 1), e;
      }

      function Wn(t) {
        return --t, t |= t >>> 1, t |= t >>> 2, t |= t >>> 4, t |= t >>> 8, 1 + (t |= t >>> 16);
      }

      var Vn = new Array(256);
      !function (t) {
        for (var e = 0; e < 256; ++e) {
          var n = e,
              i = e,
              r = 7;

          for (n >>>= 1; n; n >>>= 1) {
            i <<= 1, i |= 1 & n, --r;
          }

          t[e] = i << r & 255;
        }
      }(Vn), t("bt", Object.freeze({
        __proto__: null,
        INT_BITS: 32,
        INT_MAX: xn,
        INT_MIN: -2147483648,
        sign: Fn,
        abs: function abs(t) {
          var e = t >> 31;
          return (t ^ e) - e;
        },
        min: function min(t, e) {
          return e ^ (t ^ e) & -(t < e);
        },
        max: function max(t, e) {
          return t ^ (t ^ e) & -(t < e);
        },
        isPow2: function isPow2(t) {
          return !(t & t - 1 || !t);
        },
        log2: kn,
        log10: function log10(t) {
          return t >= 1e9 ? 9 : t >= 1e8 ? 8 : t >= 1e7 ? 7 : t >= 1e6 ? 6 : t >= 1e5 ? 5 : t >= 1e4 ? 4 : t >= 1e3 ? 3 : t >= 100 ? 2 : t >= 10 ? 1 : 0;
        },
        popCount: Hn,
        countTrailingZeros: Xn,
        nextPow2: Wn,
        prevPow2: function prevPow2(t) {
          return t |= t >>> 1, t |= t >>> 2, t |= t >>> 4, t |= t >>> 8, (t |= t >>> 16) - (t >>> 1);
        },
        parity: function parity(t) {
          return t ^= t >>> 16, t ^= t >>> 8, t ^= t >>> 4, 27030 >>> (t &= 15) & 1;
        },
        reverse: function reverse(t) {
          return Vn[255 & t] << 24 | Vn[t >>> 8 & 255] << 16 | Vn[t >>> 16 & 255] << 8 | Vn[t >>> 24 & 255];
        },
        interleave2: function interleave2(t, e) {
          return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t &= 65535) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e &= 65535) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1;
        },
        deinterleave2: function deinterleave2(t, e) {
          return (t = 65535 & ((t = 16711935 & ((t = 252645135 & ((t = 858993459 & ((t = t >>> e & 1431655765) | t >>> 1)) | t >>> 2)) | t >>> 4)) | t >>> 16)) << 16 >> 16;
        },
        interleave3: function interleave3(t, e, n) {
          return t = 1227133513 & ((t = 3272356035 & ((t = 251719695 & ((t = 4278190335 & ((t &= 1023) | t << 16)) | t << 8)) | t << 4)) | t << 2), (t |= (e = 1227133513 & ((e = 3272356035 & ((e = 251719695 & ((e = 4278190335 & ((e &= 1023) | e << 16)) | e << 8)) | e << 4)) | e << 2)) << 1) | (n = 1227133513 & ((n = 3272356035 & ((n = 251719695 & ((n = 4278190335 & ((n &= 1023) | n << 16)) | n << 8)) | n << 4)) | n << 2)) << 2;
        },
        deinterleave3: function deinterleave3(t, e) {
          return (t = 1023 & ((t = 4278190335 & ((t = 251719695 & ((t = 3272356035 & ((t = t >>> e & 1227133513) | t >>> 2)) | t >>> 4)) | t >>> 8)) | t >>> 16)) << 22 >> 22;
        },
        nextCombination: function nextCombination(t) {
          var e = t | t - 1;
          return e + 1 | (~e & -~e) - 1 >>> Xn(t) + 1;
        }
      }));

      var jn,
          Yn,
          zn,
          Kn,
          Qn,
          Zn,
          qn,
          Jn,
          $n,
          ti,
          ei,
          ni,
          ii,
          ri,
          oi,
          si,
          ai,
          ui,
          ci,
          hi,
          _i,
          fi,
          li,
          Ai,
          di,
          Ri,
          pi,
          Ei,
          Ti,
          vi,
          Si,
          Ni,
          Ii,
          Ci,
          Oi,
          yi,
          gi,
          mi,
          Bi,
          bi,
          Mi,
          Li,
          Ui = function Ui(t, e, n) {
        for (var i = 0; i < e.length; ++i) {
          t.length <= i && t.push(new n()), t[i].copy(e[i]);
        }

        t.length = e.length;
      };

      !function (t) {
        t[t.UNKNOWN = 0] = "UNKNOWN", t[t.SWAPCHAIN = 1] = "SWAPCHAIN", t[t.BUFFER = 2] = "BUFFER", t[t.TEXTURE = 3] = "TEXTURE", t[t.RENDER_PASS = 4] = "RENDER_PASS", t[t.FRAMEBUFFER = 5] = "FRAMEBUFFER", t[t.SAMPLER = 6] = "SAMPLER", t[t.SHADER = 7] = "SHADER", t[t.DESCRIPTOR_SET_LAYOUT = 8] = "DESCRIPTOR_SET_LAYOUT", t[t.PIPELINE_LAYOUT = 9] = "PIPELINE_LAYOUT", t[t.PIPELINE_STATE = 10] = "PIPELINE_STATE", t[t.DESCRIPTOR_SET = 11] = "DESCRIPTOR_SET", t[t.INPUT_ASSEMBLER = 12] = "INPUT_ASSEMBLER", t[t.COMMAND_BUFFER = 13] = "COMMAND_BUFFER", t[t.QUEUE = 14] = "QUEUE", t[t.QUERY_POOL = 15] = "QUERY_POOL", t[t.GLOBAL_BARRIER = 16] = "GLOBAL_BARRIER", t[t.TEXTURE_BARRIER = 17] = "TEXTURE_BARRIER", t[t.BUFFER_BARRIER = 18] = "BUFFER_BARRIER", t[t.COUNT = 19] = "COUNT";
      }(jn || (jn = t("O", {}))), function (t) {
        t[t.UNREADY = 0] = "UNREADY", t[t.FAILED = 1] = "FAILED", t[t.SUCCESS = 2] = "SUCCESS";
      }(Yn || (Yn = t("S", {}))), function (t) {
        t[t.UNKNOWN = 0] = "UNKNOWN", t[t.GLES2 = 1] = "GLES2", t[t.GLES3 = 2] = "GLES3", t[t.METAL = 3] = "METAL", t[t.VULKAN = 4] = "VULKAN", t[t.NVN = 5] = "NVN", t[t.WEBGL = 6] = "WEBGL", t[t.WEBGL2 = 7] = "WEBGL2", t[t.WEBGPU = 8] = "WEBGPU";
      }(zn || (zn = t("A", {}))), function (t) {
        t[t.IDENTITY = 0] = "IDENTITY", t[t.ROTATE_90 = 1] = "ROTATE_90", t[t.ROTATE_180 = 2] = "ROTATE_180", t[t.ROTATE_270 = 3] = "ROTATE_270";
      }(Kn || (Kn = t("k", {}))), function (t) {
        t[t.ELEMENT_INDEX_UINT = 0] = "ELEMENT_INDEX_UINT", t[t.INSTANCED_ARRAYS = 1] = "INSTANCED_ARRAYS", t[t.MULTIPLE_RENDER_TARGETS = 2] = "MULTIPLE_RENDER_TARGETS", t[t.BLEND_MINMAX = 3] = "BLEND_MINMAX", t[t.COMPUTE_SHADER = 4] = "COMPUTE_SHADER", t[t.INPUT_ATTACHMENT_BENEFIT = 5] = "INPUT_ATTACHMENT_BENEFIT", t[t.COUNT = 6] = "COUNT";
      }(Qn || (Qn = t("F", {}))), function (t) {
        t[t.UNKNOWN = 0] = "UNKNOWN", t[t.A8 = 1] = "A8", t[t.L8 = 2] = "L8", t[t.LA8 = 3] = "LA8", t[t.R8 = 4] = "R8", t[t.R8SN = 5] = "R8SN", t[t.R8UI = 6] = "R8UI", t[t.R8I = 7] = "R8I", t[t.R16F = 8] = "R16F", t[t.R16UI = 9] = "R16UI", t[t.R16I = 10] = "R16I", t[t.R32F = 11] = "R32F", t[t.R32UI = 12] = "R32UI", t[t.R32I = 13] = "R32I", t[t.RG8 = 14] = "RG8", t[t.RG8SN = 15] = "RG8SN", t[t.RG8UI = 16] = "RG8UI", t[t.RG8I = 17] = "RG8I", t[t.RG16F = 18] = "RG16F", t[t.RG16UI = 19] = "RG16UI", t[t.RG16I = 20] = "RG16I", t[t.RG32F = 21] = "RG32F", t[t.RG32UI = 22] = "RG32UI", t[t.RG32I = 23] = "RG32I", t[t.RGB8 = 24] = "RGB8", t[t.SRGB8 = 25] = "SRGB8", t[t.RGB8SN = 26] = "RGB8SN", t[t.RGB8UI = 27] = "RGB8UI", t[t.RGB8I = 28] = "RGB8I", t[t.RGB16F = 29] = "RGB16F", t[t.RGB16UI = 30] = "RGB16UI", t[t.RGB16I = 31] = "RGB16I", t[t.RGB32F = 32] = "RGB32F", t[t.RGB32UI = 33] = "RGB32UI", t[t.RGB32I = 34] = "RGB32I", t[t.RGBA8 = 35] = "RGBA8", t[t.BGRA8 = 36] = "BGRA8", t[t.SRGB8_A8 = 37] = "SRGB8_A8", t[t.RGBA8SN = 38] = "RGBA8SN", t[t.RGBA8UI = 39] = "RGBA8UI", t[t.RGBA8I = 40] = "RGBA8I", t[t.RGBA16F = 41] = "RGBA16F", t[t.RGBA16UI = 42] = "RGBA16UI", t[t.RGBA16I = 43] = "RGBA16I", t[t.RGBA32F = 44] = "RGBA32F", t[t.RGBA32UI = 45] = "RGBA32UI", t[t.RGBA32I = 46] = "RGBA32I", t[t.R5G6B5 = 47] = "R5G6B5", t[t.R11G11B10F = 48] = "R11G11B10F", t[t.RGB5A1 = 49] = "RGB5A1", t[t.RGBA4 = 50] = "RGBA4", t[t.RGB10A2 = 51] = "RGB10A2", t[t.RGB10A2UI = 52] = "RGB10A2UI", t[t.RGB9E5 = 53] = "RGB9E5", t[t.DEPTH = 54] = "DEPTH", t[t.DEPTH_STENCIL = 55] = "DEPTH_STENCIL", t[t.BC1 = 56] = "BC1", t[t.BC1_ALPHA = 57] = "BC1_ALPHA", t[t.BC1_SRGB = 58] = "BC1_SRGB", t[t.BC1_SRGB_ALPHA = 59] = "BC1_SRGB_ALPHA", t[t.BC2 = 60] = "BC2", t[t.BC2_SRGB = 61] = "BC2_SRGB", t[t.BC3 = 62] = "BC3", t[t.BC3_SRGB = 63] = "BC3_SRGB", t[t.BC4 = 64] = "BC4", t[t.BC4_SNORM = 65] = "BC4_SNORM", t[t.BC5 = 66] = "BC5", t[t.BC5_SNORM = 67] = "BC5_SNORM", t[t.BC6H_UF16 = 68] = "BC6H_UF16", t[t.BC6H_SF16 = 69] = "BC6H_SF16", t[t.BC7 = 70] = "BC7", t[t.BC7_SRGB = 71] = "BC7_SRGB", t[t.ETC_RGB8 = 72] = "ETC_RGB8", t[t.ETC2_RGB8 = 73] = "ETC2_RGB8", t[t.ETC2_SRGB8 = 74] = "ETC2_SRGB8", t[t.ETC2_RGB8_A1 = 75] = "ETC2_RGB8_A1", t[t.ETC2_SRGB8_A1 = 76] = "ETC2_SRGB8_A1", t[t.ETC2_RGBA8 = 77] = "ETC2_RGBA8", t[t.ETC2_SRGB8_A8 = 78] = "ETC2_SRGB8_A8", t[t.EAC_R11 = 79] = "EAC_R11", t[t.EAC_R11SN = 80] = "EAC_R11SN", t[t.EAC_RG11 = 81] = "EAC_RG11", t[t.EAC_RG11SN = 82] = "EAC_RG11SN", t[t.PVRTC_RGB2 = 83] = "PVRTC_RGB2", t[t.PVRTC_RGBA2 = 84] = "PVRTC_RGBA2", t[t.PVRTC_RGB4 = 85] = "PVRTC_RGB4", t[t.PVRTC_RGBA4 = 86] = "PVRTC_RGBA4", t[t.PVRTC2_2BPP = 87] = "PVRTC2_2BPP", t[t.PVRTC2_4BPP = 88] = "PVRTC2_4BPP", t[t.ASTC_RGBA_4X4 = 89] = "ASTC_RGBA_4X4", t[t.ASTC_RGBA_5X4 = 90] = "ASTC_RGBA_5X4", t[t.ASTC_RGBA_5X5 = 91] = "ASTC_RGBA_5X5", t[t.ASTC_RGBA_6X5 = 92] = "ASTC_RGBA_6X5", t[t.ASTC_RGBA_6X6 = 93] = "ASTC_RGBA_6X6", t[t.ASTC_RGBA_8X5 = 94] = "ASTC_RGBA_8X5", t[t.ASTC_RGBA_8X6 = 95] = "ASTC_RGBA_8X6", t[t.ASTC_RGBA_8X8 = 96] = "ASTC_RGBA_8X8", t[t.ASTC_RGBA_10X5 = 97] = "ASTC_RGBA_10X5", t[t.ASTC_RGBA_10X6 = 98] = "ASTC_RGBA_10X6", t[t.ASTC_RGBA_10X8 = 99] = "ASTC_RGBA_10X8", t[t.ASTC_RGBA_10X10 = 100] = "ASTC_RGBA_10X10", t[t.ASTC_RGBA_12X10 = 101] = "ASTC_RGBA_12X10", t[t.ASTC_RGBA_12X12 = 102] = "ASTC_RGBA_12X12", t[t.ASTC_SRGBA_4X4 = 103] = "ASTC_SRGBA_4X4", t[t.ASTC_SRGBA_5X4 = 104] = "ASTC_SRGBA_5X4", t[t.ASTC_SRGBA_5X5 = 105] = "ASTC_SRGBA_5X5", t[t.ASTC_SRGBA_6X5 = 106] = "ASTC_SRGBA_6X5", t[t.ASTC_SRGBA_6X6 = 107] = "ASTC_SRGBA_6X6", t[t.ASTC_SRGBA_8X5 = 108] = "ASTC_SRGBA_8X5", t[t.ASTC_SRGBA_8X6 = 109] = "ASTC_SRGBA_8X6", t[t.ASTC_SRGBA_8X8 = 110] = "ASTC_SRGBA_8X8", t[t.ASTC_SRGBA_10X5 = 111] = "ASTC_SRGBA_10X5", t[t.ASTC_SRGBA_10X6 = 112] = "ASTC_SRGBA_10X6", t[t.ASTC_SRGBA_10X8 = 113] = "ASTC_SRGBA_10X8", t[t.ASTC_SRGBA_10X10 = 114] = "ASTC_SRGBA_10X10", t[t.ASTC_SRGBA_12X10 = 115] = "ASTC_SRGBA_12X10", t[t.ASTC_SRGBA_12X12 = 116] = "ASTC_SRGBA_12X12", t[t.COUNT = 117] = "COUNT";
      }(Zn || (Zn = t("m", {}))), function (t) {
        t[t.NONE = 0] = "NONE", t[t.UNORM = 1] = "UNORM", t[t.SNORM = 2] = "SNORM", t[t.UINT = 3] = "UINT", t[t.INT = 4] = "INT", t[t.UFLOAT = 5] = "UFLOAT", t[t.FLOAT = 6] = "FLOAT";
      }(qn || (qn = t("n", {}))), function (t) {
        t[t.UNKNOWN = 0] = "UNKNOWN", t[t.BOOL = 1] = "BOOL", t[t.BOOL2 = 2] = "BOOL2", t[t.BOOL3 = 3] = "BOOL3", t[t.BOOL4 = 4] = "BOOL4", t[t.INT = 5] = "INT", t[t.INT2 = 6] = "INT2", t[t.INT3 = 7] = "INT3", t[t.INT4 = 8] = "INT4", t[t.UINT = 9] = "UINT", t[t.UINT2 = 10] = "UINT2", t[t.UINT3 = 11] = "UINT3", t[t.UINT4 = 12] = "UINT4", t[t.FLOAT = 13] = "FLOAT", t[t.FLOAT2 = 14] = "FLOAT2", t[t.FLOAT3 = 15] = "FLOAT3", t[t.FLOAT4 = 16] = "FLOAT4", t[t.MAT2 = 17] = "MAT2", t[t.MAT2X3 = 18] = "MAT2X3", t[t.MAT2X4 = 19] = "MAT2X4", t[t.MAT3X2 = 20] = "MAT3X2", t[t.MAT3 = 21] = "MAT3", t[t.MAT3X4 = 22] = "MAT3X4", t[t.MAT4X2 = 23] = "MAT4X2", t[t.MAT4X3 = 24] = "MAT4X3", t[t.MAT4 = 25] = "MAT4", t[t.SAMPLER1D = 26] = "SAMPLER1D", t[t.SAMPLER1D_ARRAY = 27] = "SAMPLER1D_ARRAY", t[t.SAMPLER2D = 28] = "SAMPLER2D", t[t.SAMPLER2D_ARRAY = 29] = "SAMPLER2D_ARRAY", t[t.SAMPLER3D = 30] = "SAMPLER3D", t[t.SAMPLER_CUBE = 31] = "SAMPLER_CUBE", t[t.SAMPLER = 32] = "SAMPLER", t[t.TEXTURE1D = 33] = "TEXTURE1D", t[t.TEXTURE1D_ARRAY = 34] = "TEXTURE1D_ARRAY", t[t.TEXTURE2D = 35] = "TEXTURE2D", t[t.TEXTURE2D_ARRAY = 36] = "TEXTURE2D_ARRAY", t[t.TEXTURE3D = 37] = "TEXTURE3D", t[t.TEXTURE_CUBE = 38] = "TEXTURE_CUBE", t[t.IMAGE1D = 39] = "IMAGE1D", t[t.IMAGE1D_ARRAY = 40] = "IMAGE1D_ARRAY", t[t.IMAGE2D = 41] = "IMAGE2D", t[t.IMAGE2D_ARRAY = 42] = "IMAGE2D_ARRAY", t[t.IMAGE3D = 43] = "IMAGE3D", t[t.IMAGE_CUBE = 44] = "IMAGE_CUBE", t[t.SUBPASS_INPUT = 45] = "SUBPASS_INPUT", t[t.COUNT = 46] = "COUNT";
      }(Jn || (Jn = t("T", {}))), function (t) {
        t[t.NONE = 0] = "NONE", t[t.TRANSFER_SRC = 1] = "TRANSFER_SRC", t[t.TRANSFER_DST = 2] = "TRANSFER_DST", t[t.INDEX = 4] = "INDEX", t[t.VERTEX = 8] = "VERTEX", t[t.UNIFORM = 16] = "UNIFORM", t[t.STORAGE = 32] = "STORAGE", t[t.INDIRECT = 64] = "INDIRECT";
      }($n || ($n = t("o", {}))), function (t) {
        t[t.NONE = 0] = "NONE";
      }(ti || (ti = t("p", {}))), function (t) {
        t[t.NONE = 0] = "NONE", t[t.READ_ONLY = 1] = "READ_ONLY", t[t.WRITE_ONLY = 2] = "WRITE_ONLY", t[t.READ_WRITE = 3] = "READ_WRITE";
      }(ei || (ei = t("M", {}))), function (t) {
        t[t.NONE = 0] = "NONE", t[t.DEVICE = 1] = "DEVICE", t[t.HOST = 2] = "HOST";
      }(ni || (ni = t("q", {}))), function (t) {
        t[t.TEX1D = 0] = "TEX1D", t[t.TEX2D = 1] = "TEX2D", t[t.TEX3D = 2] = "TEX3D", t[t.CUBE = 3] = "CUBE", t[t.TEX1D_ARRAY = 4] = "TEX1D_ARRAY", t[t.TEX2D_ARRAY = 5] = "TEX2D_ARRAY";
      }(ii || (ii = t("r", {}))), function (t) {
        t[t.NONE = 0] = "NONE", t[t.TRANSFER_SRC = 1] = "TRANSFER_SRC", t[t.TRANSFER_DST = 2] = "TRANSFER_DST", t[t.SAMPLED = 4] = "SAMPLED", t[t.STORAGE = 8] = "STORAGE", t[t.COLOR_ATTACHMENT = 16] = "COLOR_ATTACHMENT", t[t.DEPTH_STENCIL_ATTACHMENT = 32] = "DEPTH_STENCIL_ATTACHMENT", t[t.INPUT_ATTACHMENT = 64] = "INPUT_ATTACHMENT";
      }(ri || (ri = t("s", {}))), function (t) {
        t[t.NONE = 0] = "NONE", t[t.GEN_MIPMAP = 1] = "GEN_MIPMAP", t[t.GENERAL_LAYOUT = 2] = "GENERAL_LAYOUT";
      }(oi || (oi = t("t", {}))), function (t) {
        t[t.NONE = 0] = "NONE", t[t.RENDER_TARGET = 1] = "RENDER_TARGET", t[t.SAMPLED_TEXTURE = 2] = "SAMPLED_TEXTURE", t[t.LINEAR_FILTER = 4] = "LINEAR_FILTER", t[t.STORAGE_TEXTURE = 8] = "STORAGE_TEXTURE", t[t.VERTEX_ATTRIBUTE = 16] = "VERTEX_ATTRIBUTE";
      }(si || (si = t("u", {}))), function (t) {
        t[t.ONE = 0] = "ONE", t[t.MULTIPLE_PERFORMANCE = 1] = "MULTIPLE_PERFORMANCE", t[t.MULTIPLE_BALANCE = 2] = "MULTIPLE_BALANCE", t[t.MULTIPLE_QUALITY = 3] = "MULTIPLE_QUALITY";
      }(ai || (ai = t("v", {}))), function (t) {
        t[t.OFF = 0] = "OFF", t[t.ON = 1] = "ON", t[t.RELAXED = 2] = "RELAXED", t[t.MAILBOX = 3] = "MAILBOX", t[t.HALF = 4] = "HALF";
      }(ui || (ui = t("V", {}))), function (t) {
        t[t.NONE = 0] = "NONE", t[t.POINT = 1] = "POINT", t[t.LINEAR = 2] = "LINEAR", t[t.ANISOTROPIC = 3] = "ANISOTROPIC";
      }(ci || (ci = t("x", {}))), function (t) {
        t[t.WRAP = 0] = "WRAP", t[t.MIRROR = 1] = "MIRROR", t[t.CLAMP = 2] = "CLAMP", t[t.BORDER = 3] = "BORDER";
      }(hi || (hi = t("y", {}))), function (t) {
        t[t.NEVER = 0] = "NEVER", t[t.LESS = 1] = "LESS", t[t.EQUAL = 2] = "EQUAL", t[t.LESS_EQUAL = 3] = "LESS_EQUAL", t[t.GREATER = 4] = "GREATER", t[t.NOT_EQUAL = 5] = "NOT_EQUAL", t[t.GREATER_EQUAL = 6] = "GREATER_EQUAL", t[t.ALWAYS = 7] = "ALWAYS";
      }(_i || (_i = t("z", {}))), function (t) {
        t[t.ZERO = 0] = "ZERO", t[t.KEEP = 1] = "KEEP", t[t.REPLACE = 2] = "REPLACE", t[t.INCR = 3] = "INCR", t[t.DECR = 4] = "DECR", t[t.INVERT = 5] = "INVERT", t[t.INCR_WRAP = 6] = "INCR_WRAP", t[t.DECR_WRAP = 7] = "DECR_WRAP";
      }(fi || (fi = t("E", {}))), function (t) {
        t[t.ZERO = 0] = "ZERO", t[t.ONE = 1] = "ONE", t[t.SRC_ALPHA = 2] = "SRC_ALPHA", t[t.DST_ALPHA = 3] = "DST_ALPHA", t[t.ONE_MINUS_SRC_ALPHA = 4] = "ONE_MINUS_SRC_ALPHA", t[t.ONE_MINUS_DST_ALPHA = 5] = "ONE_MINUS_DST_ALPHA", t[t.SRC_COLOR = 6] = "SRC_COLOR", t[t.DST_COLOR = 7] = "DST_COLOR", t[t.ONE_MINUS_SRC_COLOR = 8] = "ONE_MINUS_SRC_COLOR", t[t.ONE_MINUS_DST_COLOR = 9] = "ONE_MINUS_DST_COLOR", t[t.SRC_ALPHA_SATURATE = 10] = "SRC_ALPHA_SATURATE", t[t.CONSTANT_COLOR = 11] = "CONSTANT_COLOR", t[t.ONE_MINUS_CONSTANT_COLOR = 12] = "ONE_MINUS_CONSTANT_COLOR", t[t.CONSTANT_ALPHA = 13] = "CONSTANT_ALPHA", t[t.ONE_MINUS_CONSTANT_ALPHA = 14] = "ONE_MINUS_CONSTANT_ALPHA";
      }(li || (li = t("G", {}))), function (t) {
        t[t.ADD = 0] = "ADD", t[t.SUB = 1] = "SUB", t[t.REV_SUB = 2] = "REV_SUB", t[t.MIN = 3] = "MIN", t[t.MAX = 4] = "MAX";
      }(Ai || (Ai = t("H", {}))), function (t) {
        t[t.NONE = 0] = "NONE", t[t.R = 1] = "R", t[t.G = 2] = "G", t[t.B = 4] = "B", t[t.A = 8] = "A", t[t.ALL = 15] = "ALL";
      }(di || (di = t("I", {}))), function (t) {
        t[t.NONE = 0] = "NONE", t[t.VERTEX = 1] = "VERTEX", t[t.CONTROL = 2] = "CONTROL", t[t.EVALUATION = 4] = "EVALUATION", t[t.GEOMETRY = 8] = "GEOMETRY", t[t.FRAGMENT = 16] = "FRAGMENT", t[t.COMPUTE = 32] = "COMPUTE", t[t.ALL = 63] = "ALL";
      }(Ri || (Ri = t("J", {}))), function (t) {
        t[t.LOAD = 0] = "LOAD", t[t.CLEAR = 1] = "CLEAR", t[t.DISCARD = 2] = "DISCARD";
      }(pi || (pi = t("L", {}))), function (t) {
        t[t.STORE = 0] = "STORE", t[t.DISCARD = 1] = "DISCARD";
      }(Ei || (Ei = t("K", {}))), function (t) {
        t[t.NONE = 0] = "NONE", t[t.INDIRECT_BUFFER = 1] = "INDIRECT_BUFFER", t[t.INDEX_BUFFER = 2] = "INDEX_BUFFER", t[t.VERTEX_BUFFER = 4] = "VERTEX_BUFFER", t[t.VERTEX_SHADER_READ_UNIFORM_BUFFER = 8] = "VERTEX_SHADER_READ_UNIFORM_BUFFER", t[t.VERTEX_SHADER_READ_TEXTURE = 16] = "VERTEX_SHADER_READ_TEXTURE", t[t.VERTEX_SHADER_READ_OTHER = 32] = "VERTEX_SHADER_READ_OTHER", t[t.FRAGMENT_SHADER_READ_UNIFORM_BUFFER = 64] = "FRAGMENT_SHADER_READ_UNIFORM_BUFFER", t[t.FRAGMENT_SHADER_READ_TEXTURE = 128] = "FRAGMENT_SHADER_READ_TEXTURE", t[t.FRAGMENT_SHADER_READ_COLOR_INPUT_ATTACHMENT = 256] = "FRAGMENT_SHADER_READ_COLOR_INPUT_ATTACHMENT", t[t.FRAGMENT_SHADER_READ_DEPTH_STENCIL_INPUT_ATTACHMENT = 512] = "FRAGMENT_SHADER_READ_DEPTH_STENCIL_INPUT_ATTACHMENT", t[t.FRAGMENT_SHADER_READ_OTHER = 1024] = "FRAGMENT_SHADER_READ_OTHER", t[t.COLOR_ATTACHMENT_READ = 2048] = "COLOR_ATTACHMENT_READ", t[t.DEPTH_STENCIL_ATTACHMENT_READ = 4096] = "DEPTH_STENCIL_ATTACHMENT_READ", t[t.COMPUTE_SHADER_READ_UNIFORM_BUFFER = 8192] = "COMPUTE_SHADER_READ_UNIFORM_BUFFER", t[t.COMPUTE_SHADER_READ_TEXTURE = 16384] = "COMPUTE_SHADER_READ_TEXTURE", t[t.COMPUTE_SHADER_READ_OTHER = 32768] = "COMPUTE_SHADER_READ_OTHER", t[t.TRANSFER_READ = 65536] = "TRANSFER_READ", t[t.HOST_READ = 131072] = "HOST_READ", t[t.PRESENT = 262144] = "PRESENT", t[t.VERTEX_SHADER_WRITE = 524288] = "VERTEX_SHADER_WRITE", t[t.FRAGMENT_SHADER_WRITE = 1048576] = "FRAGMENT_SHADER_WRITE", t[t.COLOR_ATTACHMENT_WRITE = 2097152] = "COLOR_ATTACHMENT_WRITE", t[t.DEPTH_STENCIL_ATTACHMENT_WRITE = 4194304] = "DEPTH_STENCIL_ATTACHMENT_WRITE", t[t.COMPUTE_SHADER_WRITE = 8388608] = "COMPUTE_SHADER_WRITE", t[t.TRANSFER_WRITE = 16777216] = "TRANSFER_WRITE", t[t.HOST_PREINITIALIZED = 33554432] = "HOST_PREINITIALIZED", t[t.HOST_WRITE = 67108864] = "HOST_WRITE";
      }(Ti || (Ti = t("N", {}))), function (t) {
        t[t.NONE = 0] = "NONE", t[t.SAMPLE_ZERO = 1] = "SAMPLE_ZERO", t[t.AVERAGE = 2] = "AVERAGE", t[t.MIN = 3] = "MIN", t[t.MAX = 4] = "MAX";
      }(vi || (vi = t("Q", {}))), function (t) {
        t[t.GRAPHICS = 0] = "GRAPHICS", t[t.COMPUTE = 1] = "COMPUTE", t[t.RAY_TRACING = 2] = "RAY_TRACING";
      }(Si || (Si = t("U", {}))), function (t) {
        t[t.POINT_LIST = 0] = "POINT_LIST", t[t.LINE_LIST = 1] = "LINE_LIST", t[t.LINE_STRIP = 2] = "LINE_STRIP", t[t.LINE_LOOP = 3] = "LINE_LOOP", t[t.LINE_LIST_ADJACENCY = 4] = "LINE_LIST_ADJACENCY", t[t.LINE_STRIP_ADJACENCY = 5] = "LINE_STRIP_ADJACENCY", t[t.ISO_LINE_LIST = 6] = "ISO_LINE_LIST", t[t.TRIANGLE_LIST = 7] = "TRIANGLE_LIST", t[t.TRIANGLE_STRIP = 8] = "TRIANGLE_STRIP", t[t.TRIANGLE_FAN = 9] = "TRIANGLE_FAN", t[t.TRIANGLE_LIST_ADJACENCY = 10] = "TRIANGLE_LIST_ADJACENCY", t[t.TRIANGLE_STRIP_ADJACENCY = 11] = "TRIANGLE_STRIP_ADJACENCY", t[t.TRIANGLE_PATCH_ADJACENCY = 12] = "TRIANGLE_PATCH_ADJACENCY", t[t.QUAD_PATCH_LIST = 13] = "QUAD_PATCH_LIST";
      }(Ni || (Ni = t("W", {}))), function (t) {
        t[t.FILL = 0] = "FILL", t[t.POINT = 1] = "POINT", t[t.LINE = 2] = "LINE";
      }(Ii || (Ii = t("X", {}))), function (t) {
        t[t.GOURAND = 0] = "GOURAND", t[t.FLAT = 1] = "FLAT";
      }(Ci || (Ci = t("Y", {}))), function (t) {
        t[t.NONE = 0] = "NONE", t[t.FRONT = 1] = "FRONT", t[t.BACK = 2] = "BACK";
      }(Oi || (Oi = t("Z", {}))), function (t) {
        t[t.NONE = 0] = "NONE", t[t.LINE_WIDTH = 1] = "LINE_WIDTH", t[t.DEPTH_BIAS = 2] = "DEPTH_BIAS", t[t.BLEND_CONSTANTS = 4] = "BLEND_CONSTANTS", t[t.DEPTH_BOUNDS = 8] = "DEPTH_BOUNDS", t[t.STENCIL_WRITE_MASK = 16] = "STENCIL_WRITE_MASK", t[t.STENCIL_COMPARE_MASK = 32] = "STENCIL_COMPARE_MASK";
      }(yi || (yi = t("$", {}))), function (t) {
        t[t.FRONT = 1] = "FRONT", t[t.BACK = 2] = "BACK", t[t.ALL = 3] = "ALL";
      }(gi || (gi = t("a0", {}))), function (t) {
        t[t.UNKNOWN = 0] = "UNKNOWN", t[t.UNIFORM_BUFFER = 1] = "UNIFORM_BUFFER", t[t.DYNAMIC_UNIFORM_BUFFER = 2] = "DYNAMIC_UNIFORM_BUFFER", t[t.STORAGE_BUFFER = 4] = "STORAGE_BUFFER", t[t.DYNAMIC_STORAGE_BUFFER = 8] = "DYNAMIC_STORAGE_BUFFER", t[t.SAMPLER_TEXTURE = 16] = "SAMPLER_TEXTURE", t[t.SAMPLER = 32] = "SAMPLER", t[t.TEXTURE = 64] = "TEXTURE", t[t.STORAGE_IMAGE = 128] = "STORAGE_IMAGE", t[t.INPUT_ATTACHMENT = 256] = "INPUT_ATTACHMENT";
      }(mi || (mi = t("a1", {}))), function (t) {
        t[t.GRAPHICS = 0] = "GRAPHICS", t[t.COMPUTE = 1] = "COMPUTE", t[t.TRANSFER = 2] = "TRANSFER";
      }(Bi || (Bi = t("a2", {}))), function (t) {
        t[t.OCCLUSION = 0] = "OCCLUSION", t[t.PIPELINE_STATISTICS = 1] = "PIPELINE_STATISTICS", t[t.TIMESTAMP = 2] = "TIMESTAMP";
      }(bi || (bi = t("a3", {}))), function (t) {
        t[t.PRIMARY = 0] = "PRIMARY", t[t.SECONDARY = 1] = "SECONDARY";
      }(Mi || (Mi = t("a4", {}))), function (t) {
        t[t.NONE = 0] = "NONE", t[t.COLOR = 1] = "COLOR", t[t.DEPTH = 2] = "DEPTH", t[t.STENCIL = 4] = "STENCIL", t[t.DEPTH_STENCIL = 6] = "DEPTH_STENCIL", t[t.ALL = 7] = "ALL";
      }(Li || (Li = t("a5", {})));

      var Gi,
          Pi = t("a6", function () {
        function t(t, e, n) {
          void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === n && (n = 0), this.x = t, this.y = e, this.z = n;
        }

        return t.prototype.copy = function (t) {
          return this.x = t.x, this.y = t.y, this.z = t.z, this;
        }, t;
      }()),
          wi = t("a7", function () {
        function t(t, e, n, i, r, o, s, a, u, c, h, _, f, l, A, d, R, p, E, T, v, S) {
          void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === n && (n = 0), void 0 === i && (i = 0), void 0 === r && (r = 0), void 0 === o && (o = 0), void 0 === s && (s = 0), void 0 === a && (a = 0), void 0 === u && (u = 0), void 0 === c && (c = 0), void 0 === h && (h = 0), void 0 === _ && (_ = 0), void 0 === f && (f = 0), void 0 === l && (l = 1), void 0 === A && (A = 0), void 0 === d && (d = 0), void 0 === R && (R = new Pi()), void 0 === p && (p = new Pi()), void 0 === E && (E = !1), void 0 === T && (T = -1), void 0 === v && (v = 1), void 0 === S && (S = 1), this.maxVertexAttributes = t, this.maxVertexUniformVectors = e, this.maxFragmentUniformVectors = n, this.maxTextureUnits = i, this.maxImageUnits = r, this.maxVertexTextureUnits = o, this.maxColorRenderTargets = s, this.maxShaderStorageBufferBindings = a, this.maxShaderStorageBlockSize = u, this.maxUniformBufferBindings = c, this.maxUniformBlockSize = h, this.maxTextureSize = _, this.maxCubeMapTextureSize = f, this.uboOffsetAlignment = l, this.maxComputeSharedMemorySize = A, this.maxComputeWorkGroupInvocations = d, this.maxComputeWorkGroupSize = R, this.maxComputeWorkGroupCount = p, this.supportQuery = E, this.clipSpaceMinZ = T, this.screenSpaceSignY = v, this.clipSpaceSignY = S;
        }

        return t.prototype.copy = function (t) {
          return this.maxVertexAttributes = t.maxVertexAttributes, this.maxVertexUniformVectors = t.maxVertexUniformVectors, this.maxFragmentUniformVectors = t.maxFragmentUniformVectors, this.maxTextureUnits = t.maxTextureUnits, this.maxImageUnits = t.maxImageUnits, this.maxVertexTextureUnits = t.maxVertexTextureUnits, this.maxColorRenderTargets = t.maxColorRenderTargets, this.maxShaderStorageBufferBindings = t.maxShaderStorageBufferBindings, this.maxShaderStorageBlockSize = t.maxShaderStorageBlockSize, this.maxUniformBufferBindings = t.maxUniformBufferBindings, this.maxUniformBlockSize = t.maxUniformBlockSize, this.maxTextureSize = t.maxTextureSize, this.maxCubeMapTextureSize = t.maxCubeMapTextureSize, this.uboOffsetAlignment = t.uboOffsetAlignment, this.maxComputeSharedMemorySize = t.maxComputeSharedMemorySize, this.maxComputeWorkGroupInvocations = t.maxComputeWorkGroupInvocations, this.maxComputeWorkGroupSize.copy(t.maxComputeWorkGroupSize), this.maxComputeWorkGroupCount.copy(t.maxComputeWorkGroupCount), this.supportQuery = t.supportQuery, this.clipSpaceMinZ = t.clipSpaceMinZ, this.screenSpaceSignY = t.screenSpaceSignY, this.clipSpaceSignY = t.clipSpaceSignY, this;
        }, t;
      }()),
          Di = t("a8", function () {
        function t(t, e, n) {
          void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === n && (n = 0), this.x = t, this.y = e, this.z = n;
        }

        return t.prototype.copy = function (t) {
          return this.x = t.x, this.y = t.y, this.z = t.z, this;
        }, t;
      }()),
          xi = t("a9", function () {
        function t(t, e, n, i) {
          void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === n && (n = 0), void 0 === i && (i = 0), this.x = t, this.y = e, this.width = n, this.height = i;
        }

        return t.prototype.copy = function (t) {
          return this.x = t.x, this.y = t.y, this.width = t.width, this.height = t.height, this;
        }, t;
      }()),
          Fi = t("aa", function () {
        function t(t, e, n) {
          void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === n && (n = 1), this.width = t, this.height = e, this.depth = n;
        }

        return t.prototype.copy = function (t) {
          return this.width = t.width, this.height = t.height, this.depth = t.depth, this;
        }, t;
      }()),
          ki = t("ab", function () {
        function t(t, e, n) {
          void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === n && (n = 1), this.mipLevel = t, this.baseArrayLayer = e, this.layerCount = n;
        }

        return t.prototype.copy = function (t) {
          return this.mipLevel = t.mipLevel, this.baseArrayLayer = t.baseArrayLayer, this.layerCount = t.layerCount, this;
        }, t;
      }()),
          Hi = t("ac", function () {
        function t(t, e, n, i) {
          void 0 === t && (t = 0), void 0 === e && (e = 1), void 0 === n && (n = 0), void 0 === i && (i = 1), this.baseMipLevel = t, this.levelCount = e, this.baseArrayLayer = n, this.layerCount = i;
        }

        return t.prototype.copy = function (t) {
          return this.baseMipLevel = t.baseMipLevel, this.levelCount = t.levelCount, this.baseArrayLayer = t.baseArrayLayer, this.layerCount = t.layerCount, this;
        }, t;
      }()),
          Xi = t("ad", function () {
        function t(t, e, n, i, r) {
          void 0 === t && (t = new ki()), void 0 === e && (e = new Di()), void 0 === n && (n = new ki()), void 0 === i && (i = new Di()), void 0 === r && (r = new Fi()), this.srcSubres = t, this.srcOffset = e, this.dstSubres = n, this.dstOffset = i, this.extent = r;
        }

        return t.prototype.copy = function (t) {
          return this.srcSubres.copy(t.srcSubres), this.srcOffset.copy(t.srcOffset), this.dstSubres.copy(t.dstSubres), this.dstOffset.copy(t.dstOffset), this.extent.copy(t.extent), this;
        }, t;
      }()),
          Wi = t("ae", function () {
        function t(t, e, n, i, r, o) {
          void 0 === t && (t = new ki()), void 0 === e && (e = new Di()), void 0 === n && (n = new Fi()), void 0 === i && (i = new ki()), void 0 === r && (r = new Di()), void 0 === o && (o = new Fi()), this.srcSubres = t, this.srcOffset = e, this.srcExtent = n, this.dstSubres = i, this.dstOffset = r, this.dstExtent = o;
        }

        return t.prototype.copy = function (t) {
          return this.srcSubres.copy(t.srcSubres), this.srcOffset.copy(t.srcOffset), this.srcExtent.copy(t.srcExtent), this.dstSubres.copy(t.dstSubres), this.dstOffset.copy(t.dstOffset), this.dstExtent.copy(t.dstExtent), this;
        }, t;
      }()),
          Vi = t("af", function () {
        function t(t, e, n, i, r) {
          void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === n && (n = new Di()), void 0 === i && (i = new Fi()), void 0 === r && (r = new ki()), this.buffStride = t, this.buffTexHeight = e, this.texOffset = n, this.texExtent = i, this.texSubres = r;
        }

        return t.prototype.copy = function (t) {
          return this.buffStride = t.buffStride, this.buffTexHeight = t.buffTexHeight, this.texOffset.copy(t.texOffset), this.texExtent.copy(t.texExtent), this.texSubres.copy(t.texSubres), this;
        }, t;
      }()),
          ji = t("ag", function () {
        function t(t, e, n, i, r, o) {
          void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === n && (n = 0), void 0 === i && (i = 0), void 0 === r && (r = 0), void 0 === o && (o = 1), this.left = t, this.top = e, this.width = n, this.height = i, this.minDepth = r, this.maxDepth = o;
        }

        return t.prototype.copy = function (t) {
          return this.left = t.left, this.top = t.top, this.width = t.width, this.height = t.height, this.minDepth = t.minDepth, this.maxDepth = t.maxDepth, this;
        }, t;
      }()),
          Yi = t("ah", function () {
        function t(t, e, n, i) {
          void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === n && (n = 0), void 0 === i && (i = 0), this.x = t, this.y = e, this.z = n, this.w = i;
        }

        return t.prototype.copy = function (t) {
          return this.x = t.x, this.y = t.y, this.z = t.z, this.w = t.w, this;
        }, t;
      }()),
          zi = t("ai", function () {
        function t(t, e, n, i, r, o, s, a) {
          void 0 === t && (t = [0]), void 0 === e && (e = [0]), void 0 === n && (n = [0]), void 0 === i && (i = [0]), void 0 === r && (r = [0]), void 0 === o && (o = [0]), void 0 === s && (s = [0]), void 0 === a && (a = [0]), this.maxBlockCounts = t, this.maxSamplerTextureCounts = e, this.maxSamplerCounts = n, this.maxTextureCounts = i, this.maxBufferCounts = r, this.maxImageCounts = o, this.maxSubpassInputCounts = s, this.setIndices = a;
        }

        return t.prototype.copy = function (t) {
          return this.maxBlockCounts = t.maxBlockCounts.slice(), this.maxSamplerTextureCounts = t.maxSamplerTextureCounts.slice(), this.maxSamplerCounts = t.maxSamplerCounts.slice(), this.maxTextureCounts = t.maxTextureCounts.slice(), this.maxBufferCounts = t.maxBufferCounts.slice(), this.maxImageCounts = t.maxImageCounts.slice(), this.maxSubpassInputCounts = t.maxSubpassInputCounts.slice(), this.setIndices = t.setIndices.slice(), this;
        }, t;
      }()),
          Ki = t("aj", function () {
        function t(t, e, n, i) {
          void 0 === t && (t = null), void 0 === e && (e = ui.ON), void 0 === n && (n = 0), void 0 === i && (i = 0), this.windowHandle = t, this.vsyncMode = e, this.width = n, this.height = i;
        }

        return t.prototype.copy = function (t) {
          return this.windowHandle = t.windowHandle, this.vsyncMode = t.vsyncMode, this.width = t.width, this.height = t.height, this;
        }, t;
      }()),
          Qi = t("ak", function () {
        function t(t) {
          void 0 === t && (t = new zi()), this.bindingMappingInfo = t;
        }

        return t.prototype.copy = function (t) {
          return this.bindingMappingInfo.copy(t.bindingMappingInfo), this;
        }, t;
      }()),
          Zi = t("al", function () {
        function t(t, e, n, i, r) {
          void 0 === t && (t = $n.NONE), void 0 === e && (e = ni.NONE), void 0 === n && (n = 0), void 0 === i && (i = 1), void 0 === r && (r = ti.NONE), this.usage = t, this.memUsage = e, this.size = n, this.stride = i, this.flags = r;
        }

        return t.prototype.copy = function (t) {
          return this.usage = t.usage, this.memUsage = t.memUsage, this.size = t.size, this.stride = t.stride, this.flags = t.flags, this;
        }, t;
      }()),
          qi = t("am", function () {
        function t(t, e, n) {
          void 0 === t && (t = null), void 0 === e && (e = 0), void 0 === n && (n = 0), this.buffer = t, this.offset = e, this.range = n;
        }

        return t.prototype.copy = function (t) {
          return this.buffer = t.buffer, this.offset = t.offset, this.range = t.range, this;
        }, t;
      }()),
          Ji = t("an", function () {
        function t(t, e, n, i, r, o, s) {
          void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === n && (n = 0), void 0 === i && (i = 0), void 0 === r && (r = 0), void 0 === o && (o = 0), void 0 === s && (s = 0), this.vertexCount = t, this.firstVertex = e, this.indexCount = n, this.firstIndex = i, this.vertexOffset = r, this.instanceCount = o, this.firstInstance = s;
        }

        return t.prototype.copy = function (t) {
          return this.vertexCount = t.vertexCount, this.firstVertex = t.firstVertex, this.indexCount = t.indexCount, this.firstIndex = t.firstIndex, this.vertexOffset = t.vertexOffset, this.instanceCount = t.instanceCount, this.firstInstance = t.firstInstance, this;
        }, t;
      }()),
          $i = t("ao", function () {
        function t(t, e, n, i, r) {
          void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === n && (n = 0), void 0 === i && (i = null), void 0 === r && (r = 0), this.groupCountX = t, this.groupCountY = e, this.groupCountZ = n, this.indirectBuffer = i, this.indirectOffset = r;
        }

        return t.prototype.copy = function (t) {
          return this.groupCountX = t.groupCountX, this.groupCountY = t.groupCountY, this.groupCountZ = t.groupCountZ, this.indirectBuffer = t.indirectBuffer, this.indirectOffset = t.indirectOffset, this;
        }, t;
      }()),
          tr = t("ap", function () {
        function t(t) {
          void 0 === t && (t = []), this.drawInfos = t;
        }

        return t.prototype.copy = function (t) {
          return Ui(this.drawInfos, t.drawInfos, Ji), this;
        }, t;
      }()),
          er = t("aq", function () {
        function t(t, e, n, i, r, o, s, a, u, c, h) {
          void 0 === t && (t = ii.TEX2D), void 0 === e && (e = ri.NONE), void 0 === n && (n = Zn.UNKNOWN), void 0 === i && (i = 0), void 0 === r && (r = 0), void 0 === o && (o = oi.NONE), void 0 === s && (s = 1), void 0 === a && (a = 1), void 0 === u && (u = ai.ONE), void 0 === c && (c = 1), void 0 === h && (h = 0), this.type = t, this.usage = e, this.format = n, this.width = i, this.height = r, this.flags = o, this.layerCount = s, this.levelCount = a, this.samples = u, this.depth = c, this.externalRes = h;
        }

        return t.prototype.copy = function (t) {
          return this.type = t.type, this.usage = t.usage, this.format = t.format, this.width = t.width, this.height = t.height, this.flags = t.flags, this.layerCount = t.layerCount, this.levelCount = t.levelCount, this.samples = t.samples, this.depth = t.depth, this.externalRes = t.externalRes, this;
        }, t;
      }()),
          nr = t("ar", function () {
        function t(t, e, n, i, r, o, s) {
          void 0 === t && (t = null), void 0 === e && (e = ii.TEX2D), void 0 === n && (n = Zn.UNKNOWN), void 0 === i && (i = 0), void 0 === r && (r = 1), void 0 === o && (o = 0), void 0 === s && (s = 1), this.texture = t, this.type = e, this.format = n, this.baseLevel = i, this.levelCount = r, this.baseLayer = o, this.layerCount = s;
        }

        return t.prototype.copy = function (t) {
          return this.texture = t.texture, this.type = t.type, this.format = t.format, this.baseLevel = t.baseLevel, this.levelCount = t.levelCount, this.baseLayer = t.baseLayer, this.layerCount = t.layerCount, this;
        }, t;
      }()),
          ir = t("as", function () {
        function t(t, e, n, i, r, o, s, a) {
          void 0 === t && (t = ci.LINEAR), void 0 === e && (e = ci.LINEAR), void 0 === n && (n = ci.NONE), void 0 === i && (i = hi.WRAP), void 0 === r && (r = hi.WRAP), void 0 === o && (o = hi.WRAP), void 0 === s && (s = 0), void 0 === a && (a = _i.ALWAYS), this.minFilter = t, this.magFilter = e, this.mipFilter = n, this.addressU = i, this.addressV = r, this.addressW = o, this.maxAnisotropy = s, this.cmpFunc = a;
        }

        return t.prototype.copy = function (t) {
          return this.minFilter = t.minFilter, this.magFilter = t.magFilter, this.mipFilter = t.mipFilter, this.addressU = t.addressU, this.addressV = t.addressV, this.addressW = t.addressW, this.maxAnisotropy = t.maxAnisotropy, this.cmpFunc = t.cmpFunc, this;
        }, t;
      }()),
          rr = t("at", function () {
        function t(t, e, n) {
          void 0 === t && (t = ""), void 0 === e && (e = Jn.UNKNOWN), void 0 === n && (n = 0), this.name = t, this.type = e, this.count = n;
        }

        return t.prototype.copy = function (t) {
          return this.name = t.name, this.type = t.type, this.count = t.count, this;
        }, t;
      }()),
          or = t("au", function () {
        function t(t, e, n, i, r) {
          void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === n && (n = ""), void 0 === i && (i = []), void 0 === r && (r = 0), this.set = t, this.binding = e, this.name = n, this.members = i, this.count = r;
        }

        return t.prototype.copy = function (t) {
          return this.set = t.set, this.binding = t.binding, this.name = t.name, Ui(this.members, t.members, rr), this.count = t.count, this;
        }, t;
      }()),
          sr = t("av", function () {
        function t(t, e, n, i, r) {
          void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === n && (n = ""), void 0 === i && (i = Jn.UNKNOWN), void 0 === r && (r = 0), this.set = t, this.binding = e, this.name = n, this.type = i, this.count = r;
        }

        return t.prototype.copy = function (t) {
          return this.set = t.set, this.binding = t.binding, this.name = t.name, this.type = t.type, this.count = t.count, this;
        }, t;
      }()),
          ar = t("aw", function () {
        function t(t, e, n, i) {
          void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === n && (n = ""), void 0 === i && (i = 0), this.set = t, this.binding = e, this.name = n, this.count = i;
        }

        return t.prototype.copy = function (t) {
          return this.set = t.set, this.binding = t.binding, this.name = t.name, this.count = t.count, this;
        }, t;
      }()),
          ur = t("ax", function () {
        function t(t, e, n, i, r) {
          void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === n && (n = ""), void 0 === i && (i = Jn.UNKNOWN), void 0 === r && (r = 0), this.set = t, this.binding = e, this.name = n, this.type = i, this.count = r;
        }

        return t.prototype.copy = function (t) {
          return this.set = t.set, this.binding = t.binding, this.name = t.name, this.type = t.type, this.count = t.count, this;
        }, t;
      }()),
          cr = t("ay", function () {
        function t(t, e, n, i, r, o) {
          void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === n && (n = ""), void 0 === i && (i = Jn.UNKNOWN), void 0 === r && (r = 0), void 0 === o && (o = ei.READ_WRITE), this.set = t, this.binding = e, this.name = n, this.type = i, this.count = r, this.memoryAccess = o;
        }

        return t.prototype.copy = function (t) {
          return this.set = t.set, this.binding = t.binding, this.name = t.name, this.type = t.type, this.count = t.count, this.memoryAccess = t.memoryAccess, this;
        }, t;
      }()),
          hr = t("az", function () {
        function t(t, e, n, i, r) {
          void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === n && (n = ""), void 0 === i && (i = 0), void 0 === r && (r = ei.READ_WRITE), this.set = t, this.binding = e, this.name = n, this.count = i, this.memoryAccess = r;
        }

        return t.prototype.copy = function (t) {
          return this.set = t.set, this.binding = t.binding, this.name = t.name, this.count = t.count, this.memoryAccess = t.memoryAccess, this;
        }, t;
      }()),
          _r = t("aA", function () {
        function t(t, e, n, i) {
          void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === n && (n = ""), void 0 === i && (i = 0), this.set = t, this.binding = e, this.name = n, this.count = i;
        }

        return t.prototype.copy = function (t) {
          return this.set = t.set, this.binding = t.binding, this.name = t.name, this.count = t.count, this;
        }, t;
      }()),
          fr = t("aB", function () {
        function t(t, e) {
          void 0 === t && (t = Ri.NONE), void 0 === e && (e = ""), this.stage = t, this.source = e;
        }

        return t.prototype.copy = function (t) {
          return this.stage = t.stage, this.source = t.source, this;
        }, t;
      }()),
          lr = t("aC", function () {
        function t(t, e, n, i, r, o) {
          void 0 === t && (t = ""), void 0 === e && (e = Zn.UNKNOWN), void 0 === n && (n = !1), void 0 === i && (i = 0), void 0 === r && (r = !1), void 0 === o && (o = 0), this.name = t, this.format = e, this.isNormalized = n, this.stream = i, this.isInstanced = r, this.location = o;
        }

        return t.prototype.copy = function (t) {
          return this.name = t.name, this.format = t.format, this.isNormalized = t.isNormalized, this.stream = t.stream, this.isInstanced = t.isInstanced, this.location = t.location, this;
        }, t;
      }()),
          Ar = t("aD", function () {
        function t(t, e, n, i, r, o, s, a, u, c) {
          void 0 === t && (t = ""), void 0 === e && (e = []), void 0 === n && (n = []), void 0 === i && (i = []), void 0 === r && (r = []), void 0 === o && (o = []), void 0 === s && (s = []), void 0 === a && (a = []), void 0 === u && (u = []), void 0 === c && (c = []), this.name = t, this.stages = e, this.attributes = n, this.blocks = i, this.buffers = r, this.samplerTextures = o, this.samplers = s, this.textures = a, this.images = u, this.subpassInputs = c;
        }

        return t.prototype.copy = function (t) {
          return this.name = t.name, Ui(this.stages, t.stages, fr), Ui(this.attributes, t.attributes, lr), Ui(this.blocks, t.blocks, or), Ui(this.buffers, t.buffers, hr), Ui(this.samplerTextures, t.samplerTextures, sr), Ui(this.samplers, t.samplers, ar), Ui(this.textures, t.textures, ur), Ui(this.images, t.images, cr), Ui(this.subpassInputs, t.subpassInputs, _r), this;
        }, t;
      }()),
          dr = t("aE", function () {
        function t(t, e, n, i) {
          void 0 === t && (t = []), void 0 === e && (e = []), void 0 === n && (n = null), void 0 === i && (i = null), this.attributes = t, this.vertexBuffers = e, this.indexBuffer = n, this.indirectBuffer = i;
        }

        return t.prototype.copy = function (t) {
          return Ui(this.attributes, t.attributes, lr), this.vertexBuffers = t.vertexBuffers.slice(), this.indexBuffer = t.indexBuffer, this.indirectBuffer = t.indirectBuffer, this;
        }, t;
      }()),
          Rr = t("aF", function () {
        function t(t, e, n, i, r, o) {
          void 0 === t && (t = Zn.UNKNOWN), void 0 === e && (e = ai.ONE), void 0 === n && (n = pi.CLEAR), void 0 === i && (i = Ei.STORE), void 0 === r && (r = null), void 0 === o && (o = !1), this.format = t, this.sampleCount = e, this.loadOp = n, this.storeOp = i, this.barrier = r, this.isGeneralLayout = o;
        }

        return t.prototype.copy = function (t) {
          return this.format = t.format, this.sampleCount = t.sampleCount, this.loadOp = t.loadOp, this.storeOp = t.storeOp, this.barrier = t.barrier, this.isGeneralLayout = t.isGeneralLayout, this;
        }, t;
      }()),
          pr = t("aG", function () {
        function t(t, e, n, i, r, o, s, a) {
          void 0 === t && (t = Zn.UNKNOWN), void 0 === e && (e = ai.ONE), void 0 === n && (n = pi.CLEAR), void 0 === i && (i = Ei.STORE), void 0 === r && (r = pi.CLEAR), void 0 === o && (o = Ei.STORE), void 0 === s && (s = null), void 0 === a && (a = !1), this.format = t, this.sampleCount = e, this.depthLoadOp = n, this.depthStoreOp = i, this.stencilLoadOp = r, this.stencilStoreOp = o, this.barrier = s, this.isGeneralLayout = a;
        }

        return t.prototype.copy = function (t) {
          return this.format = t.format, this.sampleCount = t.sampleCount, this.depthLoadOp = t.depthLoadOp, this.depthStoreOp = t.depthStoreOp, this.stencilLoadOp = t.stencilLoadOp, this.stencilStoreOp = t.stencilStoreOp, this.barrier = t.barrier, this.isGeneralLayout = t.isGeneralLayout, this;
        }, t;
      }()),
          Er = t("aH", function () {
        function t(t, e, n, i, r, o, s, a) {
          void 0 === t && (t = []), void 0 === e && (e = []), void 0 === n && (n = []), void 0 === i && (i = []), void 0 === r && (r = -1), void 0 === o && (o = -1), void 0 === s && (s = vi.NONE), void 0 === a && (a = vi.NONE), this.inputs = t, this.colors = e, this.resolves = n, this.preserves = i, this.depthStencil = r, this.depthStencilResolve = o, this.depthResolveMode = s, this.stencilResolveMode = a;
        }

        return t.prototype.copy = function (t) {
          return this.inputs = t.inputs.slice(), this.colors = t.colors.slice(), this.resolves = t.resolves.slice(), this.preserves = t.preserves.slice(), this.depthStencil = t.depthStencil, this.depthStencilResolve = t.depthStencilResolve, this.depthResolveMode = t.depthResolveMode, this.stencilResolveMode = t.stencilResolveMode, this;
        }, t;
      }()),
          Tr = t("aI", function () {
        function t(t, e, n) {
          void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === n && (n = null), this.srcSubpass = t, this.dstSubpass = e, this.barrier = n;
        }

        return t.prototype.copy = function (t) {
          return this.srcSubpass = t.srcSubpass, this.dstSubpass = t.dstSubpass, this.barrier = t.barrier, this;
        }, t;
      }()),
          vr = t("aJ", function () {
        function t(t, e, n, i) {
          void 0 === t && (t = []), void 0 === e && (e = new pr()), void 0 === n && (n = []), void 0 === i && (i = []), this.colorAttachments = t, this.depthStencilAttachment = e, this.subpasses = n, this.dependencies = i;
        }

        return t.prototype.copy = function (t) {
          return Ui(this.colorAttachments, t.colorAttachments, Rr), this.depthStencilAttachment.copy(t.depthStencilAttachment), Ui(this.subpasses, t.subpasses, Er), Ui(this.dependencies, t.dependencies, Tr), this;
        }, t;
      }()),
          Sr = t("aK", function () {
        function t(t, e) {
          void 0 === t && (t = Ti.NONE), void 0 === e && (e = Ti.NONE), this.prevAccesses = t, this.nextAccesses = e;
        }

        return t.prototype.copy = function (t) {
          return this.prevAccesses = t.prevAccesses, this.nextAccesses = t.nextAccesses, this;
        }, t;
      }()),
          Nr = t("aL", function () {
        function t(t, e, n, i, r) {
          void 0 === t && (t = Ti.NONE), void 0 === e && (e = Ti.NONE), void 0 === n && (n = !1), void 0 === i && (i = null), void 0 === r && (r = null), this.prevAccesses = t, this.nextAccesses = e, this.discardContents = n, this.srcQueue = i, this.dstQueue = r;
        }

        return t.prototype.copy = function (t) {
          return this.prevAccesses = t.prevAccesses, this.nextAccesses = t.nextAccesses, this.discardContents = t.discardContents, this.srcQueue = t.srcQueue, this.dstQueue = t.dstQueue, this;
        }, t;
      }()),
          Ir = t("aM", function () {
        function t(t, e, n) {
          void 0 === t && (t = null), void 0 === e && (e = []), void 0 === n && (n = null), this.renderPass = t, this.colorTextures = e, this.depthStencilTexture = n;
        }

        return t.prototype.copy = function (t) {
          return this.renderPass = t.renderPass, this.colorTextures = t.colorTextures.slice(), this.depthStencilTexture = t.depthStencilTexture, this;
        }, t;
      }()),
          Cr = t("aN", function () {
        function t(t, e, n, i, r) {
          void 0 === t && (t = -1), void 0 === e && (e = mi.UNKNOWN), void 0 === n && (n = 0), void 0 === i && (i = Ri.NONE), void 0 === r && (r = []), this.binding = t, this.descriptorType = e, this.count = n, this.stageFlags = i, this.immutableSamplers = r;
        }

        return t.prototype.copy = function (t) {
          return this.binding = t.binding, this.descriptorType = t.descriptorType, this.count = t.count, this.stageFlags = t.stageFlags, this.immutableSamplers = t.immutableSamplers.slice(), this;
        }, t;
      }()),
          Or = t("aO", function () {
        function t(t) {
          void 0 === t && (t = []), this.bindings = t;
        }

        return t.prototype.copy = function (t) {
          return Ui(this.bindings, t.bindings, Cr), this;
        }, t;
      }()),
          yr = t("aP", function () {
        function t(t) {
          void 0 === t && (t = null), this.layout = t;
        }

        return t.prototype.copy = function (t) {
          return this.layout = t.layout, this;
        }, t;
      }()),
          gr = t("aQ", function () {
        function t(t) {
          void 0 === t && (t = []), this.setLayouts = t;
        }

        return t.prototype.copy = function (t) {
          return this.setLayouts = t.setLayouts.slice(), this;
        }, t;
      }()),
          mr = t("aR", function () {
        function t(t) {
          void 0 === t && (t = []), this.attributes = t;
        }

        return t.prototype.copy = function (t) {
          return Ui(this.attributes, t.attributes, lr), this;
        }, t;
      }()),
          Br = t("aS", function () {
        function t(t, e) {
          void 0 === t && (t = null), void 0 === e && (e = Mi.PRIMARY), this.queue = t, this.type = e;
        }

        return t.prototype.copy = function (t) {
          return this.queue = t.queue, this.type = t.type, this;
        }, t;
      }()),
          br = t("aT", function () {
        function t(t) {
          void 0 === t && (t = Bi.GRAPHICS), this.type = t;
        }

        return t.prototype.copy = function (t) {
          return this.type = t.type, this;
        }, t;
      }()),
          Mr = t("aU", function () {
        function t(t, e, n) {
          void 0 === t && (t = bi.OCCLUSION), void 0 === e && (e = 32767), void 0 === n && (n = !0), this.type = t, this.maxQueryObjects = e, this.forceWait = n;
        }

        return t.prototype.copy = function (t) {
          return this.type = t.type, this.maxQueryObjects = t.maxQueryObjects, this.forceWait = t.forceWait, this;
        }, t;
      }()),
          Lr = t("aV", function (t, e, n, i, r, o, s, a) {
        void 0 === t && (t = ""), void 0 === e && (e = 0), void 0 === n && (n = 0), void 0 === i && (i = qn.NONE), void 0 === r && (r = !1), void 0 === o && (o = !1), void 0 === s && (s = !1), void 0 === a && (a = !1), this.name = t, this.size = e, this.count = n, this.type = i, this.hasAlpha = r, this.hasDepth = o, this.hasStencil = s, this.isCompressed = a;
      }),
          Ur = t("aW", function () {
        function t(t, e) {
          void 0 === t && (t = 0), void 0 === e && (e = 0), this.bufferSize = t, this.textureSize = e;
        }

        return t.prototype.copy = function (t) {
          return this.bufferSize = t.bufferSize, this.textureSize = t.textureSize, this;
        }, t;
      }()),
          Gr = t("aX", function () {
        function t(t, e, n) {
          void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === n && (n = 0), this.writeMask = t, this.compareMask = e, this.reference = n;
        }

        return t.prototype.copy = function (t) {
          return this.writeMask = t.writeMask, this.compareMask = t.compareMask, this.reference = t.reference, this;
        }, t;
      }()),
          Pr = t("aY", function () {
        function t(t, e, n, i, r, o, s, a, u, c, h) {
          void 0 === t && (t = new ji()), void 0 === e && (e = new xi()), void 0 === n && (n = new Yi()), void 0 === i && (i = 1), void 0 === r && (r = 0), void 0 === o && (o = 0), void 0 === s && (s = 0), void 0 === a && (a = 0), void 0 === u && (u = 0), void 0 === c && (c = new Gr()), void 0 === h && (h = new Gr()), this.viewport = t, this.scissor = e, this.blendConstant = n, this.lineWidth = i, this.depthBiasConstant = r, this.depthBiasClamp = o, this.depthBiasSlope = s, this.depthMinBounds = a, this.depthMaxBounds = u, this.stencilStatesFront = c, this.stencilStatesBack = h;
        }

        return t.prototype.copy = function (t) {
          return this.viewport.copy(t.viewport), this.scissor.copy(t.scissor), this.blendConstant.copy(t.blendConstant), this.lineWidth = t.lineWidth, this.depthBiasConstant = t.depthBiasConstant, this.depthBiasClamp = t.depthBiasClamp, this.depthBiasSlope = t.depthBiasSlope, this.depthMinBounds = t.depthMinBounds, this.depthMaxBounds = t.depthMaxBounds, this.stencilStatesFront.copy(t.stencilStatesFront), this.stencilStatesBack.copy(t.stencilStatesBack), this;
        }, t;
      }()),
          wr = t("aZ", function () {
        function t(e) {
          this._objectType = jn.UNKNOWN, this._objectID = 0, this._typedID = 0, this._objectType = e, this._objectID = t._idTable[jn.UNKNOWN]++, this._typedID = t._idTable[e]++;
        }

        return K(t, [{
          key: "objectType",
          get: function get() {
            return this._objectType;
          }
        }, {
          key: "objectID",
          get: function get() {
            return this._objectID;
          }
        }, {
          key: "typedID",
          get: function get() {
            return this._typedID;
          }
        }]), t;
      }());

      wr._idTable = Array(jn.COUNT).fill(65536), function (t) {
        t.ATTR_POSITION = "a_position", t.ATTR_NORMAL = "a_normal", t.ATTR_TANGENT = "a_tangent", t.ATTR_BITANGENT = "a_bitangent", t.ATTR_WEIGHTS = "a_weights", t.ATTR_JOINTS = "a_joints", t.ATTR_COLOR = "a_color", t.ATTR_COLOR1 = "a_color1", t.ATTR_COLOR2 = "a_color2", t.ATTR_TEX_COORD = "a_texCoord", t.ATTR_TEX_COORD1 = "a_texCoord1", t.ATTR_TEX_COORD2 = "a_texCoord2", t.ATTR_TEX_COORD3 = "a_texCoord3", t.ATTR_TEX_COORD4 = "a_texCoord4", t.ATTR_TEX_COORD5 = "a_texCoord5", t.ATTR_TEX_COORD6 = "a_texCoord6", t.ATTR_TEX_COORD7 = "a_texCoord7", t.ATTR_TEX_COORD8 = "a_texCoord8", t.ATTR_BATCH_ID = "a_batch_id", t.ATTR_BATCH_UV = "a_batch_uv";
      }(Gi || (Gi = t("a_", {})));
      var Dr = t("a$", Object.freeze([new Lr("UNKNOWN", 0, 0, qn.NONE, !1, !1, !1, !1), new Lr("A8", 1, 1, qn.UNORM, !0, !1, !1, !1), new Lr("L8", 1, 1, qn.UNORM, !1, !1, !1, !1), new Lr("LA8", 1, 2, qn.UNORM, !0, !1, !1, !1), new Lr("R8", 1, 1, qn.UNORM, !1, !1, !1, !1), new Lr("R8SN", 1, 1, qn.SNORM, !1, !1, !1, !1), new Lr("R8UI", 1, 1, qn.UINT, !1, !1, !1, !1), new Lr("R8I", 1, 1, qn.INT, !1, !1, !1, !1), new Lr("R16F", 2, 1, qn.FLOAT, !1, !1, !1, !1), new Lr("R16UI", 2, 1, qn.UINT, !1, !1, !1, !1), new Lr("R16I", 2, 1, qn.INT, !1, !1, !1, !1), new Lr("R32F", 4, 1, qn.FLOAT, !1, !1, !1, !1), new Lr("R32UI", 4, 1, qn.UINT, !1, !1, !1, !1), new Lr("R32I", 4, 1, qn.INT, !1, !1, !1, !1), new Lr("RG8", 2, 2, qn.UNORM, !1, !1, !1, !1), new Lr("RG8SN", 2, 2, qn.SNORM, !1, !1, !1, !1), new Lr("RG8UI", 2, 2, qn.UINT, !1, !1, !1, !1), new Lr("RG8I", 2, 2, qn.INT, !1, !1, !1, !1), new Lr("RG16F", 4, 2, qn.FLOAT, !1, !1, !1, !1), new Lr("RG16UI", 4, 2, qn.UINT, !1, !1, !1, !1), new Lr("RG16I", 4, 2, qn.INT, !1, !1, !1, !1), new Lr("RG32F", 8, 2, qn.FLOAT, !1, !1, !1, !1), new Lr("RG32UI", 8, 2, qn.UINT, !1, !1, !1, !1), new Lr("RG32I", 8, 2, qn.INT, !1, !1, !1, !1), new Lr("RGB8", 3, 3, qn.UNORM, !1, !1, !1, !1), new Lr("SRGB8", 3, 3, qn.UNORM, !1, !1, !1, !1), new Lr("RGB8SN", 3, 3, qn.SNORM, !1, !1, !1, !1), new Lr("RGB8UI", 3, 3, qn.UINT, !1, !1, !1, !1), new Lr("RGB8I", 3, 3, qn.INT, !1, !1, !1, !1), new Lr("RGB16F", 6, 3, qn.FLOAT, !1, !1, !1, !1), new Lr("RGB16UI", 6, 3, qn.UINT, !1, !1, !1, !1), new Lr("RGB16I", 6, 3, qn.INT, !1, !1, !1, !1), new Lr("RGB32F", 12, 3, qn.FLOAT, !1, !1, !1, !1), new Lr("RGB32UI", 12, 3, qn.UINT, !1, !1, !1, !1), new Lr("RGB32I", 12, 3, qn.INT, !1, !1, !1, !1), new Lr("RGBA8", 4, 4, qn.UNORM, !0, !1, !1, !1), new Lr("BGRA8", 4, 4, qn.UNORM, !0, !1, !1, !1), new Lr("SRGB8_A8", 4, 4, qn.UNORM, !0, !1, !1, !1), new Lr("RGBA8SN", 4, 4, qn.SNORM, !0, !1, !1, !1), new Lr("RGBA8UI", 4, 4, qn.UINT, !0, !1, !1, !1), new Lr("RGBA8I", 4, 4, qn.INT, !0, !1, !1, !1), new Lr("RGBA16F", 8, 4, qn.FLOAT, !0, !1, !1, !1), new Lr("RGBA16UI", 8, 4, qn.UINT, !0, !1, !1, !1), new Lr("RGBA16I", 8, 4, qn.INT, !0, !1, !1, !1), new Lr("RGBA32F", 16, 4, qn.FLOAT, !0, !1, !1, !1), new Lr("RGBA32UI", 16, 4, qn.UINT, !0, !1, !1, !1), new Lr("RGBA32I", 16, 4, qn.INT, !0, !1, !1, !1), new Lr("R5G6B5", 2, 3, qn.UNORM, !1, !1, !1, !1), new Lr("R11G11B10F", 4, 3, qn.FLOAT, !1, !1, !1, !1), new Lr("RGB5A1", 2, 4, qn.UNORM, !0, !1, !1, !1), new Lr("RGBA4", 2, 4, qn.UNORM, !0, !1, !1, !1), new Lr("RGB10A2", 2, 4, qn.UNORM, !0, !1, !1, !1), new Lr("RGB10A2UI", 2, 4, qn.UINT, !0, !1, !1, !1), new Lr("RGB9E5", 2, 4, qn.FLOAT, !0, !1, !1, !1), new Lr("DEPTH", 4, 1, qn.FLOAT, !1, !0, !1, !1), new Lr("DEPTH_STENCIL", 5, 2, qn.FLOAT, !1, !0, !0, !1), new Lr("BC1", 1, 3, qn.UNORM, !1, !1, !1, !0), new Lr("BC1_ALPHA", 1, 4, qn.UNORM, !0, !1, !1, !0), new Lr("BC1_SRGB", 1, 3, qn.UNORM, !1, !1, !1, !0), new Lr("BC1_SRGB_ALPHA", 1, 4, qn.UNORM, !0, !1, !1, !0), new Lr("BC2", 1, 4, qn.UNORM, !0, !1, !1, !0), new Lr("BC2_SRGB", 1, 4, qn.UNORM, !0, !1, !1, !0), new Lr("BC3", 1, 4, qn.UNORM, !0, !1, !1, !0), new Lr("BC3_SRGB", 1, 4, qn.UNORM, !0, !1, !1, !0), new Lr("BC4", 1, 1, qn.UNORM, !1, !1, !1, !0), new Lr("BC4_SNORM", 1, 1, qn.SNORM, !1, !1, !1, !0), new Lr("BC5", 1, 2, qn.UNORM, !1, !1, !1, !0), new Lr("BC5_SNORM", 1, 2, qn.SNORM, !1, !1, !1, !0), new Lr("BC6H_UF16", 1, 3, qn.UFLOAT, !1, !1, !1, !0), new Lr("BC6H_SF16", 1, 3, qn.FLOAT, !1, !1, !1, !0), new Lr("BC7", 1, 4, qn.UNORM, !0, !1, !1, !0), new Lr("BC7_SRGB", 1, 4, qn.UNORM, !0, !1, !1, !0), new Lr("ETC_RGB8", 1, 3, qn.UNORM, !1, !1, !1, !0), new Lr("ETC2_RGB8", 1, 3, qn.UNORM, !1, !1, !1, !0), new Lr("ETC2_SRGB8", 1, 3, qn.UNORM, !1, !1, !1, !0), new Lr("ETC2_RGB8_A1", 1, 4, qn.UNORM, !0, !1, !1, !0), new Lr("ETC2_SRGB8_A1", 1, 4, qn.UNORM, !0, !1, !1, !0), new Lr("ETC2_RGBA8", 2, 4, qn.UNORM, !0, !1, !1, !0), new Lr("ETC2_SRGB8_A8", 2, 4, qn.UNORM, !0, !1, !1, !0), new Lr("EAC_R11", 1, 1, qn.UNORM, !1, !1, !1, !0), new Lr("EAC_R11SN", 1, 1, qn.SNORM, !1, !1, !1, !0), new Lr("EAC_RG11", 2, 2, qn.UNORM, !1, !1, !1, !0), new Lr("EAC_RG11SN", 2, 2, qn.SNORM, !1, !1, !1, !0), new Lr("PVRTC_RGB2", 2, 3, qn.UNORM, !1, !1, !1, !0), new Lr("PVRTC_RGBA2", 2, 4, qn.UNORM, !0, !1, !1, !0), new Lr("PVRTC_RGB4", 2, 3, qn.UNORM, !1, !1, !1, !0), new Lr("PVRTC_RGBA4", 2, 4, qn.UNORM, !0, !1, !1, !0), new Lr("PVRTC2_2BPP", 2, 4, qn.UNORM, !0, !1, !1, !0), new Lr("PVRTC2_4BPP", 2, 4, qn.UNORM, !0, !1, !1, !0), new Lr("ASTC_RGBA_4x4", 1, 4, qn.UNORM, !0, !1, !1, !0), new Lr("ASTC_RGBA_5x4", 1, 4, qn.UNORM, !0, !1, !1, !0), new Lr("ASTC_RGBA_5x5", 1, 4, qn.UNORM, !0, !1, !1, !0), new Lr("ASTC_RGBA_6x5", 1, 4, qn.UNORM, !0, !1, !1, !0), new Lr("ASTC_RGBA_6x6", 1, 4, qn.UNORM, !0, !1, !1, !0), new Lr("ASTC_RGBA_8x5", 1, 4, qn.UNORM, !0, !1, !1, !0), new Lr("ASTC_RGBA_8x6", 1, 4, qn.UNORM, !0, !1, !1, !0), new Lr("ASTC_RGBA_8x8", 1, 4, qn.UNORM, !0, !1, !1, !0), new Lr("ASTC_RGBA_10x5", 1, 4, qn.UNORM, !0, !1, !1, !0), new Lr("ASTC_RGBA_10x6", 1, 4, qn.UNORM, !0, !1, !1, !0), new Lr("ASTC_RGBA_10x8", 1, 4, qn.UNORM, !0, !1, !1, !0), new Lr("ASTC_RGBA_10x10", 1, 4, qn.UNORM, !0, !1, !1, !0), new Lr("ASTC_RGBA_12x10", 1, 4, qn.UNORM, !0, !1, !1, !0), new Lr("ASTC_RGBA_12x12", 1, 4, qn.UNORM, !0, !1, !1, !0), new Lr("ASTC_SRGBA_4x4", 1, 4, qn.UNORM, !0, !1, !1, !0), new Lr("ASTC_SRGBA_5x4", 1, 4, qn.UNORM, !0, !1, !1, !0), new Lr("ASTC_SRGBA_5x5", 1, 4, qn.UNORM, !0, !1, !1, !0), new Lr("ASTC_SRGBA_6x5", 1, 4, qn.UNORM, !0, !1, !1, !0), new Lr("ASTC_SRGBA_6x6", 1, 4, qn.UNORM, !0, !1, !1, !0), new Lr("ASTC_SRGBA_8x5", 1, 4, qn.UNORM, !0, !1, !1, !0), new Lr("ASTC_SRGBA_8x6", 1, 4, qn.UNORM, !0, !1, !1, !0), new Lr("ASTC_SRGBA_8x8", 1, 4, qn.UNORM, !0, !1, !1, !0), new Lr("ASTC_SRGBA_10x5", 1, 4, qn.UNORM, !0, !1, !1, !0), new Lr("ASTC_SRGBA_10x6", 1, 4, qn.UNORM, !0, !1, !1, !0), new Lr("ASTC_SRGBA_10x8", 1, 4, qn.UNORM, !0, !1, !1, !0), new Lr("ASTC_SRGBA_10x10", 1, 4, qn.UNORM, !0, !1, !1, !0), new Lr("ASTC_SRGBA_12x10", 1, 4, qn.UNORM, !0, !1, !1, !0), new Lr("ASTC_SRGBA_12x12", 1, 4, qn.UNORM, !0, !1, !1, !0)])),
          xr = t("b0", mi.UNIFORM_BUFFER | mi.DYNAMIC_UNIFORM_BUFFER | mi.STORAGE_BUFFER | mi.DYNAMIC_STORAGE_BUFFER),
          Fr = t("b1", mi.SAMPLER_TEXTURE | mi.SAMPLER | mi.TEXTURE | mi.STORAGE_IMAGE | mi.INPUT_ATTACHMENT),
          kr = t("b2", mi.DYNAMIC_STORAGE_BUFFER | mi.DYNAMIC_UNIFORM_BUFFER),
          Hr = t("b3", 28);

      function Xr(t) {
        return t > 0 && 0 == (t & t - 1);
      }

      function Wr(t, e, n, i) {
        if (!Dr[t].isCompressed) return e * n * i * Dr[t].size;

        switch (t) {
          case Zn.BC1:
          case Zn.BC1_ALPHA:
          case Zn.BC1_SRGB:
          case Zn.BC1_SRGB_ALPHA:
            return Math.ceil(e / 4) * Math.ceil(n / 4) * 8 * i;

          case Zn.BC2:
          case Zn.BC2_SRGB:
          case Zn.BC3:
          case Zn.BC3_SRGB:
          case Zn.BC4:
          case Zn.BC4_SNORM:
          case Zn.BC6H_SF16:
          case Zn.BC6H_UF16:
          case Zn.BC7:
          case Zn.BC7_SRGB:
            return Math.ceil(e / 4) * Math.ceil(n / 4) * 16 * i;

          case Zn.BC5:
          case Zn.BC5_SNORM:
            return Math.ceil(e / 4) * Math.ceil(n / 4) * 32 * i;

          case Zn.ETC_RGB8:
          case Zn.ETC2_RGB8:
          case Zn.ETC2_SRGB8:
          case Zn.ETC2_RGB8_A1:
          case Zn.EAC_R11:
          case Zn.EAC_R11SN:
            return Math.ceil(e / 4) * Math.ceil(n / 4) * 8 * i;

          case Zn.ETC2_RGBA8:
          case Zn.ETC2_SRGB8_A1:
          case Zn.EAC_RG11:
          case Zn.EAC_RG11SN:
            return Math.ceil(e / 4) * Math.ceil(n / 4) * 16 * i;

          case Zn.PVRTC_RGB2:
          case Zn.PVRTC_RGBA2:
          case Zn.PVRTC2_2BPP:
            return Math.ceil(Math.max(e, 16) * Math.max(n, 8) / 4) * i;

          case Zn.PVRTC_RGB4:
          case Zn.PVRTC_RGBA4:
          case Zn.PVRTC2_4BPP:
            return Math.ceil(Math.max(e, 8) * Math.max(n, 8) / 2) * i;

          case Zn.ASTC_RGBA_4X4:
          case Zn.ASTC_SRGBA_4X4:
            return Math.ceil(e / 4) * Math.ceil(n / 4) * 16 * i;

          case Zn.ASTC_RGBA_5X4:
          case Zn.ASTC_SRGBA_5X4:
            return Math.ceil(e / 5) * Math.ceil(n / 4) * 16 * i;

          case Zn.ASTC_RGBA_5X5:
          case Zn.ASTC_SRGBA_5X5:
            return Math.ceil(e / 5) * Math.ceil(n / 5) * 16 * i;

          case Zn.ASTC_RGBA_6X5:
          case Zn.ASTC_SRGBA_6X5:
            return Math.ceil(e / 6) * Math.ceil(n / 5) * 16 * i;

          case Zn.ASTC_RGBA_6X6:
          case Zn.ASTC_SRGBA_6X6:
            return Math.ceil(e / 6) * Math.ceil(n / 6) * 16 * i;

          case Zn.ASTC_RGBA_8X5:
          case Zn.ASTC_SRGBA_8X5:
            return Math.ceil(e / 8) * Math.ceil(n / 5) * 16 * i;

          case Zn.ASTC_RGBA_8X6:
          case Zn.ASTC_SRGBA_8X6:
            return Math.ceil(e / 8) * Math.ceil(n / 6) * 16 * i;

          case Zn.ASTC_RGBA_8X8:
          case Zn.ASTC_SRGBA_8X8:
            return Math.ceil(e / 8) * Math.ceil(n / 8) * 16 * i;

          case Zn.ASTC_RGBA_10X5:
          case Zn.ASTC_SRGBA_10X5:
            return Math.ceil(e / 10) * Math.ceil(n / 5) * 16 * i;

          case Zn.ASTC_RGBA_10X6:
          case Zn.ASTC_SRGBA_10X6:
            return Math.ceil(e / 10) * Math.ceil(n / 6) * 16 * i;

          case Zn.ASTC_RGBA_10X8:
          case Zn.ASTC_SRGBA_10X8:
            return Math.ceil(e / 10) * Math.ceil(n / 8) * 16 * i;

          case Zn.ASTC_RGBA_10X10:
          case Zn.ASTC_SRGBA_10X10:
            return Math.ceil(e / 10) * Math.ceil(n / 10) * 16 * i;

          case Zn.ASTC_RGBA_12X10:
          case Zn.ASTC_SRGBA_12X10:
            return Math.ceil(e / 12) * Math.ceil(n / 10) * 16 * i;

          case Zn.ASTC_RGBA_12X12:
          case Zn.ASTC_SRGBA_12X12:
            return Math.ceil(e / 12) * Math.ceil(n / 12) * 16 * i;

          default:
            return 0;
        }
      }

      function Vr(t, e, n, i, r) {
        for (var o = 0, s = 0; s < r; ++s) {
          o += Wr(t, e, n, i), e = Math.max(e >> 1, 1), n = Math.max(n >> 1, 1);
        }

        return o;
      }

      var jr = [0, 4, 8, 12, 16, 4, 8, 12, 16, 4, 8, 12, 16, 4, 8, 12, 16, 16, 24, 32, 24, 36, 48, 32, 48, 64, 4, 4, 4, 4, 4, 4];

      function Yr(t) {
        return jr[t] || 0;
      }

      function zr(t) {
        var e = t.size / t.count;

        switch (t.type) {
          case qn.UNORM:
          case qn.UINT:
            switch (e) {
              case 1:
                return Uint8Array;

              case 2:
                return Uint16Array;

              case 4:
                return Uint32Array;
            }

            break;

          case qn.SNORM:
          case qn.INT:
            switch (e) {
              case 1:
                return Int8Array;

              case 2:
                return Int16Array;

              case 4:
                return Int32Array;
            }

            break;

          case qn.FLOAT:
            return Float32Array;
        }

        return Float32Array;
      }

      t("bV", Object.freeze({
        __proto__: null,

        get ObjectType() {
          return jn;
        },

        get Status() {
          return Yn;
        },

        get API() {
          return zn;
        },

        get SurfaceTransform() {
          return Kn;
        },

        get Feature() {
          return Qn;
        },

        get Format() {
          return Zn;
        },

        get FormatType() {
          return qn;
        },

        get Type() {
          return Jn;
        },

        get BufferUsageBit() {
          return $n;
        },

        get BufferFlagBit() {
          return ti;
        },

        get MemoryAccessBit() {
          return ei;
        },

        get MemoryUsageBit() {
          return ni;
        },

        get TextureType() {
          return ii;
        },

        get TextureUsageBit() {
          return ri;
        },

        get TextureFlagBit() {
          return oi;
        },

        get FormatFeatureBit() {
          return si;
        },

        get SampleCount() {
          return ai;
        },

        get VsyncMode() {
          return ui;
        },

        get Filter() {
          return ci;
        },

        get Address() {
          return hi;
        },

        get ComparisonFunc() {
          return _i;
        },

        get StencilOp() {
          return fi;
        },

        get BlendFactor() {
          return li;
        },

        get BlendOp() {
          return Ai;
        },

        get ColorMask() {
          return di;
        },

        get ShaderStageFlagBit() {
          return Ri;
        },

        get LoadOp() {
          return pi;
        },

        get StoreOp() {
          return Ei;
        },

        get AccessFlagBit() {
          return Ti;
        },

        get ResolveMode() {
          return vi;
        },

        get PipelineBindPoint() {
          return Si;
        },

        get PrimitiveMode() {
          return Ni;
        },

        get PolygonMode() {
          return Ii;
        },

        get ShadeModel() {
          return Ci;
        },

        get CullMode() {
          return Oi;
        },

        get DynamicStateFlagBit() {
          return yi;
        },

        get StencilFace() {
          return gi;
        },

        get DescriptorType() {
          return mi;
        },

        get QueueType() {
          return Bi;
        },

        get QueryType() {
          return bi;
        },

        get CommandBufferType() {
          return Mi;
        },

        get ClearFlagBit() {
          return Li;
        },

        Size: Pi,
        DeviceCaps: wi,
        Offset: Di,
        Rect: xi,
        Extent: Fi,
        TextureSubresLayers: ki,
        TextureSubresRange: Hi,
        TextureCopy: Xi,
        TextureBlit: Wi,
        BufferTextureCopy: Vi,
        Viewport: ji,
        Color: Yi,
        BindingMappingInfo: zi,
        SwapchainInfo: Ki,
        DeviceInfo: Qi,
        BufferInfo: Zi,
        BufferViewInfo: qi,
        DrawInfo: Ji,
        DispatchInfo: $i,
        IndirectBuffer: tr,
        TextureInfo: er,
        TextureViewInfo: nr,
        SamplerInfo: ir,
        Uniform: rr,
        UniformBlock: or,
        UniformSamplerTexture: sr,
        UniformSampler: ar,
        UniformTexture: ur,
        UniformStorageImage: cr,
        UniformStorageBuffer: hr,
        UniformInputAttachment: _r,
        ShaderStage: fr,
        Attribute: lr,
        ShaderInfo: Ar,
        InputAssemblerInfo: dr,
        ColorAttachment: Rr,
        DepthStencilAttachment: pr,
        SubpassInfo: Er,
        SubpassDependency: Tr,
        RenderPassInfo: vr,
        GeneralBarrierInfo: Sr,
        TextureBarrierInfo: Nr,
        FramebufferInfo: Ir,
        DescriptorSetLayoutBinding: Cr,
        DescriptorSetLayoutInfo: Or,
        DescriptorSetInfo: yr,
        PipelineLayoutInfo: gr,
        InputState: mr,
        CommandBufferInfo: Br,
        QueueInfo: br,
        QueryPoolInfo: Mr,
        FormatInfo: Lr,
        MemoryStatus: Ur,
        DynamicStencilStates: Gr,
        DynamicStates: Pr,
        GFXObject: wr,

        get AttributeName() {
          return Gi;
        },

        FormatInfos: Dr,
        DESCRIPTOR_BUFFER_TYPE: xr,
        DESCRIPTOR_SAMPLER_TYPE: Fr,
        DESCRIPTOR_DYNAMIC_TYPE: kr,
        DRAW_INFO_SIZE: Hr,
        IsPowerOf2: Xr,
        FormatSize: Wr,
        FormatSurfaceSize: Vr,
        GetTypeSize: Yr,
        getTypedArrayConstructor: zr
      })), t("B", function (t) {
        function e() {
          var e;
          return (e = t.call(this, jn.BUFFER) || this)._usage = $n.NONE, e._memUsage = ni.NONE, e._size = 0, e._stride = 1, e._count = 0, e._flags = ti.NONE, e._isBufferView = !1, e;
        }

        return Z(e, t), K(e, [{
          key: "usage",
          get: function get() {
            return this._usage;
          }
        }, {
          key: "memUsage",
          get: function get() {
            return this._memUsage;
          }
        }, {
          key: "size",
          get: function get() {
            return this._size;
          }
        }, {
          key: "stride",
          get: function get() {
            return this._stride;
          }
        }, {
          key: "count",
          get: function get() {
            return this._count;
          }
        }, {
          key: "flags",
          get: function get() {
            return this._flags;
          }
        }]), e;
      }(wr)), t("j", function (t) {
        function e() {
          var e;
          return (e = t.call(this, jn.COMMAND_BUFFER) || this)._queue = null, e._type = Mi.PRIMARY, e._numDrawCalls = 0, e._numInstances = 0, e._numTris = 0, e;
        }

        return Z(e, t), K(e, [{
          key: "type",
          get: function get() {
            return this._type;
          }
        }, {
          key: "queue",
          get: function get() {
            return this._queue;
          }
        }, {
          key: "numDrawCalls",
          get: function get() {
            return this._numDrawCalls;
          }
        }, {
          key: "numInstances",
          get: function get() {
            return this._numInstances;
          }
        }, {
          key: "numTris",
          get: function get() {
            return this._numTris;
          }
        }]), e;
      }(wr)), t("b9", function () {
        function t() {
          this._gfxAPI = zn.UNKNOWN, this._renderer = "", this._vendor = "", this._features = new Array(Qn.COUNT), this._formatFeatures = new Array(Zn.COUNT), this._queue = null, this._cmdBuff = null, this._numDrawCalls = 0, this._numInstances = 0, this._numTris = 0, this._memoryStatus = new Ur(), this._caps = new wi(), this._bindingMappingInfo = new zi(), this._samplers = new Map(), this._generalBarrierss = new Map(), this._textureBarriers = new Map();
        }

        var e = t.prototype;
        return e.hasFeature = function (t) {
          return this._features[t];
        }, e.getFormatFeatures = function (t) {
          return this._formatFeatures[t];
        }, K(t, [{
          key: "gfxAPI",
          get: function get() {
            return this._gfxAPI;
          }
        }, {
          key: "queue",
          get: function get() {
            return this._queue;
          }
        }, {
          key: "commandBuffer",
          get: function get() {
            return this._cmdBuff;
          }
        }, {
          key: "renderer",
          get: function get() {
            return this._renderer;
          }
        }, {
          key: "vendor",
          get: function get() {
            return this._vendor;
          }
        }, {
          key: "numDrawCalls",
          get: function get() {
            return this._numDrawCalls;
          }
        }, {
          key: "numInstances",
          get: function get() {
            return this._numInstances;
          }
        }, {
          key: "numTris",
          get: function get() {
            return this._numTris;
          }
        }, {
          key: "memoryStatus",
          get: function get() {
            return this._memoryStatus;
          }
        }, {
          key: "capabilities",
          get: function get() {
            return this._caps;
          }
        }, {
          key: "bindingMappingInfo",
          get: function get() {
            return this._bindingMappingInfo;
          }
        }]), t;
      }()).canvas = void 0, t("ba", function (t) {
        function e() {
          var e;
          return (e = t.call(this, jn.SWAPCHAIN) || this)._transform = Kn.IDENTITY, e._colorTexture = null, e._depthStencilTexture = null, e;
        }

        return Z(e, t), K(e, [{
          key: "colorTexture",
          get: function get() {
            return this._colorTexture;
          }
        }, {
          key: "depthStencilTexture",
          get: function get() {
            return this._depthStencilTexture;
          }
        }, {
          key: "surfaceTransform",
          get: function get() {
            return this._transform;
          }
        }, {
          key: "width",
          get: function get() {
            return this._colorTexture.width;
          }
        }, {
          key: "height",
          get: function get() {
            return this._colorTexture.height;
          }
        }]), e;
      }(wr)), t("bb", function (t) {
        function e() {
          var e;
          return (e = t.call(this, jn.FRAMEBUFFER) || this)._renderPass = null, e._colorTextures = [], e._depthStencilTexture = null, e;
        }

        return Z(e, t), K(e, [{
          key: "renderPass",
          get: function get() {
            return this._renderPass;
          }
        }, {
          key: "colorTextures",
          get: function get() {
            return this._colorTextures;
          }
        }, {
          key: "depthStencilTexture",
          get: function get() {
            return this._depthStencilTexture;
          }
        }]), e;
      }(wr));
      var Kr = String.prototype.charCodeAt;

      function Qr(t) {
        return this[t];
      }

      function Zr(t, e) {
        for (var n = t.length, i = e ^ n, r = 0, o = "string" == typeof t ? Kr : Qr; n >= 4;) {
          var s = 255 & o.call(t, r) | (255 & o.call(t, ++r)) << 8 | (255 & o.call(t, ++r)) << 16 | (255 & o.call(t, ++r)) << 24;
          s = 1540483477 * (65535 & s) + ((1540483477 * (s >>> 16) & 65535) << 16), i = 1540483477 * (65535 & i) + ((1540483477 * (i >>> 16) & 65535) << 16) ^ (s = 1540483477 * (65535 & (s ^= s >>> 24)) + ((1540483477 * (s >>> 16) & 65535) << 16)), n -= 4, ++r;
        }

        switch (n) {
          case 3:
            i ^= (255 & o.call(t, r + 2)) << 16;

          case 2:
            i ^= (255 & o.call(t, r + 1)) << 8;

          case 1:
            i = 1540483477 * (65535 & (i ^= 255 & o.call(t, r))) + ((1540483477 * (i >>> 16) & 65535) << 16);
        }

        return i = 1540483477 * (65535 & (i ^= i >>> 13)) + ((1540483477 * (i >>> 16) & 65535) << 16), (i ^= i >>> 15) >>> 0;
      }

      t("bc", function (t) {
        function e() {
          var e;
          return (e = t.call(this, jn.INPUT_ASSEMBLER) || this)._attributes = [], e._attributesHash = 0, e._vertexBuffers = [], e._indexBuffer = null, e._indirectBuffer = null, e._drawInfo = new Ji(), e;
        }

        Z(e, t);
        var n = e.prototype;
        return n.getVertexBuffer = function (t) {
          return void 0 === t && (t = 0), t < this._vertexBuffers.length ? this._vertexBuffers[t] : null;
        }, n.computeAttributesHash = function () {
          for (var t = "attrs", e = 0; e < this.attributes.length; ++e) {
            var n = this.attributes[e];
            t += "," + n.name + "," + n.format + "," + n.isNormalized + "," + n.stream + "," + n.isInstanced;
          }

          return Zr(t, 666);
        }, K(e, [{
          key: "attributes",
          get: function get() {
            return this._attributes;
          }
        }, {
          key: "vertexBuffers",
          get: function get() {
            return this._vertexBuffers;
          }
        }, {
          key: "indexBuffer",
          get: function get() {
            return this._indexBuffer;
          }
        }, {
          key: "indirectBuffer",
          get: function get() {
            return this._indirectBuffer;
          }
        }, {
          key: "attributesHash",
          get: function get() {
            return this._attributesHash;
          }
        }, {
          key: "vertexCount",
          get: function get() {
            return this._drawInfo.vertexCount;
          },
          set: function set(t) {
            this._drawInfo.vertexCount = t;
          }
        }, {
          key: "firstVertex",
          get: function get() {
            return this._drawInfo.firstVertex;
          },
          set: function set(t) {
            this._drawInfo.firstVertex = t;
          }
        }, {
          key: "indexCount",
          get: function get() {
            return this._drawInfo.indexCount;
          },
          set: function set(t) {
            this._drawInfo.indexCount = t;
          }
        }, {
          key: "firstIndex",
          get: function get() {
            return this._drawInfo.firstIndex;
          },
          set: function set(t) {
            this._drawInfo.firstIndex = t;
          }
        }, {
          key: "vertexOffset",
          get: function get() {
            return this._drawInfo.vertexOffset;
          },
          set: function set(t) {
            this._drawInfo.vertexOffset = t;
          }
        }, {
          key: "instanceCount",
          get: function get() {
            return this._drawInfo.instanceCount;
          },
          set: function set(t) {
            this._drawInfo.instanceCount = t;
          }
        }, {
          key: "firstInstance",
          get: function get() {
            return this._drawInfo.firstInstance;
          },
          set: function set(t) {
            this._drawInfo.firstInstance = t;
          }
        }, {
          key: "drawInfo",
          get: function get() {
            return this._drawInfo;
          }
        }]), e;
      }(wr)), t("D", function (t) {
        function e() {
          var e;
          return (e = t.call(this, jn.DESCRIPTOR_SET) || this)._layout = null, e._buffers = [], e._textures = [], e._samplers = [], e._isDirty = !1, e;
        }

        Z(e, t);
        var n = e.prototype;
        return n.bindBuffer = function (t, e, n) {
          void 0 === n && (n = 0);
          var i = this._layout.bindingIndices[t],
              r = this._layout.bindings[i];

          if (r && r.descriptorType & xr) {
            var o = this._layout.descriptorIndices[t];
            this._buffers[o + n] !== e && (this._buffers[o + n] = e, this._isDirty = !0);
          }
        }, n.bindSampler = function (t, e, n) {
          void 0 === n && (n = 0);
          var i = this._layout.bindingIndices[t],
              r = this._layout.bindings[i];

          if (r && r.descriptorType & Fr) {
            var o = this._layout.descriptorIndices[t];
            this._samplers[o + n] !== e && (this._samplers[o + n] = e, this._isDirty = !0);
          }
        }, n.bindTexture = function (t, e, n) {
          void 0 === n && (n = 0);
          var i = this._layout.bindingIndices[t],
              r = this._layout.bindings[i];

          if (r && r.descriptorType & Fr) {
            var o = this._layout.descriptorIndices[t];
            this._textures[o + n] !== e && (this._textures[o + n] = e, this._isDirty = !0);
          }
        }, n.getBuffer = function (t, e) {
          void 0 === e && (e = 0);
          var n = this._layout.descriptorIndices[t];
          return this._buffers[n + e];
        }, n.getSampler = function (t, e) {
          void 0 === e && (e = 0);
          var n = this._layout.descriptorIndices[t];
          return this._samplers[n + e];
        }, n.getTexture = function (t, e) {
          void 0 === e && (e = 0);
          var n = this._layout.descriptorIndices[t];
          return this._textures[n + e];
        }, K(e, [{
          key: "layout",
          get: function get() {
            return this._layout;
          }
        }]), e;
      }(wr)), t("bd", function (t) {
        function e() {
          var e;
          return (e = t.call(this, jn.DESCRIPTOR_SET_LAYOUT) || this)._bindings = [], e._bindingIndices = [], e._descriptorIndices = [], e;
        }

        return Z(e, t), K(e, [{
          key: "bindings",
          get: function get() {
            return this._bindings;
          }
        }, {
          key: "bindingIndices",
          get: function get() {
            return this._bindingIndices;
          }
        }, {
          key: "descriptorIndices",
          get: function get() {
            return this._descriptorIndices;
          }
        }]), e;
      }(wr)), t("be", function (t) {
        function e() {
          var e;
          return (e = t.call(this, jn.PIPELINE_LAYOUT) || this)._setLayouts = [], e;
        }

        return Z(e, t), K(e, [{
          key: "setLayouts",
          get: function get() {
            return this._setLayouts;
          }
        }]), e;
      }(wr));
      var qr = t("bf", function () {
        function t(t, e, n, i, r, o, s, a, u, c, h, _) {
          void 0 === t && (t = !1), void 0 === e && (e = Ii.FILL), void 0 === n && (n = Ci.GOURAND), void 0 === i && (i = Oi.BACK), void 0 === r && (r = !0), void 0 === o && (o = !1), void 0 === s && (s = 0), void 0 === a && (a = 0), void 0 === u && (u = 0), void 0 === c && (c = !0), void 0 === h && (h = !1), void 0 === _ && (_ = 1), this.isDiscard = t, this.polygonMode = e, this.shadeModel = n, this.cullMode = i, this.isFrontFaceCCW = r, this.depthBiasEnabled = o, this.depthBias = s, this.depthBiasClamp = a, this.depthBiasSlop = u, this.isDepthClip = c, this.isMultisample = h, this.lineWidth = _;
        }

        var e = t.prototype;
        return e.reset = function () {
          this.isDiscard = !1, this.polygonMode = Ii.FILL, this.shadeModel = Ci.GOURAND, this.cullMode = Oi.BACK, this.isFrontFaceCCW = !0, this.depthBiasEnabled = !1, this.depthBias = 0, this.depthBiasClamp = 0, this.depthBiasSlop = 0, this.isDepthClip = !0, this.isMultisample = !1, this.lineWidth = 1;
        }, e.assign = function (t) {
          Object.assign(this, t);
        }, e.destroy = function () {}, K(t, [{
          key: "native",
          get: function get() {
            return this;
          }
        }]), t;
      }()),
          Jr = t("bg", function () {
        function t(t, e, n, i, r, o, s, a, u, c, h, _, f, l, A, d, R, p, E) {
          void 0 === t && (t = !0), void 0 === e && (e = !0), void 0 === n && (n = _i.LESS), void 0 === i && (i = !1), void 0 === r && (r = _i.ALWAYS), void 0 === o && (o = 65535), void 0 === s && (s = 65535), void 0 === a && (a = fi.KEEP), void 0 === u && (u = fi.KEEP), void 0 === c && (c = fi.KEEP), void 0 === h && (h = 1), void 0 === _ && (_ = !1), void 0 === f && (f = _i.ALWAYS), void 0 === l && (l = 65535), void 0 === A && (A = 65535), void 0 === d && (d = fi.KEEP), void 0 === R && (R = fi.KEEP), void 0 === p && (p = fi.KEEP), void 0 === E && (E = 1), this.depthTest = t, this.depthWrite = e, this.depthFunc = n, this.stencilTestFront = i, this.stencilFuncFront = r, this.stencilReadMaskFront = o, this.stencilWriteMaskFront = s, this.stencilFailOpFront = a, this.stencilZFailOpFront = u, this.stencilPassOpFront = c, this.stencilRefFront = h, this.stencilTestBack = _, this.stencilFuncBack = f, this.stencilReadMaskBack = l, this.stencilWriteMaskBack = A, this.stencilFailOpBack = d, this.stencilZFailOpBack = R, this.stencilPassOpBack = p, this.stencilRefBack = E;
        }

        var e = t.prototype;
        return e.reset = function () {
          this.depthTest = !0, this.depthWrite = !0, this.depthFunc = _i.LESS, this.stencilTestFront = !1, this.stencilFuncFront = _i.ALWAYS, this.stencilReadMaskFront = 65535, this.stencilWriteMaskFront = 65535, this.stencilFailOpFront = fi.KEEP, this.stencilZFailOpFront = fi.KEEP, this.stencilPassOpFront = fi.KEEP, this.stencilRefFront = 1, this.stencilTestBack = !1, this.stencilFuncBack = _i.ALWAYS, this.stencilReadMaskBack = 65535, this.stencilWriteMaskBack = 65535, this.stencilFailOpBack = fi.KEEP, this.stencilZFailOpBack = fi.KEEP, this.stencilPassOpBack = fi.KEEP, this.stencilRefBack = 1;
        }, e.assign = function (t) {
          Object.assign(this, t);
        }, e.destroy = function () {}, K(t, [{
          key: "native",
          get: function get() {
            return this;
          }
        }]), t;
      }()),
          $r = t("bh", function () {
        function t(t, e, n, i, r, o, s, a) {
          void 0 === t && (t = !1), void 0 === e && (e = li.ONE), void 0 === n && (n = li.ZERO), void 0 === i && (i = Ai.ADD), void 0 === r && (r = li.ONE), void 0 === o && (o = li.ZERO), void 0 === s && (s = Ai.ADD), void 0 === a && (a = di.ALL), this.blend = t, this.blendSrc = e, this.blendDst = n, this.blendEq = i, this.blendSrcAlpha = r, this.blendDstAlpha = o, this.blendAlphaEq = s, this.blendColorMask = a;
        }

        var e = t.prototype;
        return e.reset = function () {
          this.blend = !1, this.blendSrc = li.ONE, this.blendDst = li.ZERO, this.blendEq = Ai.ADD, this.blendSrcAlpha = li.ONE, this.blendDstAlpha = li.ZERO, this.blendAlphaEq = Ai.ADD, this.blendColorMask = di.ALL;
        }, e.assign = function (t) {
          Object.assign(this, t);
        }, e.destroy = function () {}, t;
      }()),
          to = t("bi", function () {
        function t(t, e, n, i) {
          void 0 === t && (t = !1), void 0 === e && (e = !1), void 0 === n && (n = new Yi()), void 0 === i && (i = [new $r()]), this.isA2C = t, this.isIndepend = e, this.blendColor = n, this.targets = i;
        }

        var e = t.prototype;
        return e.setTarget = function (t, e) {
          var n = this.targets[t];
          n || (n = this.targets[t] = new $r()), Object.assign(n, e);
        }, e.reset = function () {
          this.isA2C = !1, this.isIndepend = !1, this.blendColor.x = 0, this.blendColor.y = 0, this.blendColor.z = 0, this.blendColor.w = 0, this.targets.length = 1, this.targets[0].reset();
        }, e.destroy = function () {}, K(t, [{
          key: "native",
          get: function get() {
            return this;
          }
        }]), t;
      }());
      t("bj", function (t, e, n, i, r, o, s, a, u, c) {
        void 0 === t && (t = null), void 0 === e && (e = null), void 0 === n && (n = null), void 0 === i && (i = new mr()), void 0 === r && (r = new qr()), void 0 === o && (o = new Jr()), void 0 === s && (s = new to()), void 0 === a && (a = Ni.TRIANGLE_LIST), void 0 === u && (u = yi.NONE), void 0 === c && (c = Si.GRAPHICS), this.shader = t, this.pipelineLayout = e, this.renderPass = n, this.inputState = i, this.rasterizerState = r, this.depthStencilState = o, this.blendState = s, this.primitive = a, this.dynamicStates = u, this.bindPoint = c;
      }), t("bk", function (t) {
        function e() {
          var e;
          return (e = t.call(this, jn.PIPELINE_STATE) || this)._shader = null, e._pipelineLayout = null, e._primitive = Ni.TRIANGLE_LIST, e._is = null, e._rs = new qr(), e._dss = new Jr(), e._bs = new to(), e._dynamicStates = yi.NONE, e._renderPass = null, e;
        }

        return Z(e, t), K(e, [{
          key: "shader",
          get: function get() {
            return this._shader;
          }
        }, {
          key: "pipelineLayout",
          get: function get() {
            return this._pipelineLayout;
          }
        }, {
          key: "primitive",
          get: function get() {
            return this._primitive;
          }
        }, {
          key: "rasterizerState",
          get: function get() {
            return this._rs;
          }
        }, {
          key: "depthStencilState",
          get: function get() {
            return this._dss;
          }
        }, {
          key: "blendState",
          get: function get() {
            return this._bs;
          }
        }, {
          key: "inputState",
          get: function get() {
            return this._is;
          }
        }, {
          key: "dynamicStates",
          get: function get() {
            return this._dynamicStates;
          }
        }, {
          key: "renderPass",
          get: function get() {
            return this._renderPass;
          }
        }]), e;
      }(wr)), t("bl", function (t) {
        function e() {
          var e;
          return (e = t.call(this, jn.QUEUE) || this)._type = Bi.GRAPHICS, e;
        }

        return Z(e, t), K(e, [{
          key: "type",
          get: function get() {
            return this._type;
          }
        }]), e;
      }(wr)), t("bm", function (t) {
        function e() {
          var e;
          return (e = t.call(this, jn.RENDER_PASS) || this)._colorInfos = [], e._depthStencilInfo = null, e._subpasses = [], e._hash = 0, e;
        }

        return Z(e, t), e.prototype.computeHash = function () {
          var t = "";
          if (this._subpasses.length) for (var e = 0; e < this._subpasses.length; ++e) {
            var n = this._subpasses[e];

            if (n.inputs.length) {
              t += "ia";

              for (var i = 0; i < n.inputs.length; ++i) {
                var r = this._colorInfos[n.inputs[i]];
                t += "," + r.format + "," + r.sampleCount;
              }
            }

            if (n.colors.length) {
              t += "ca";

              for (var o = 0; o < n.inputs.length; ++o) {
                var s = this._colorInfos[n.inputs[o]];
                t += "," + s.format + "," + s.sampleCount;
              }
            }

            if (n.depthStencil >= 0) {
              var a = this._colorInfos[n.depthStencil];
              t += "ds," + a.format + "," + a.sampleCount;
            }
          } else {
            t += "ca";

            for (var u = 0; u < this._colorInfos.length; ++u) {
              var c = this._colorInfos[u];
              t += "," + c.format + "," + c.sampleCount;
            }

            var h = this._depthStencilInfo;
            h && (t += "ds," + h.format + "," + h.sampleCount);
          }
          return Zr(t, 666);
        }, K(e, [{
          key: "colorAttachments",
          get: function get() {
            return this._colorInfos;
          }
        }, {
          key: "depthStencilAttachment",
          get: function get() {
            return this._depthStencilInfo;
          }
        }, {
          key: "subPasses",
          get: function get() {
            return this._subpasses;
          }
        }, {
          key: "hash",
          get: function get() {
            return this._hash;
          }
        }]), e;
      }(wr)), t("bn", function (t) {
        function e(e, n) {
          var i;
          return (i = t.call(this, jn.SAMPLER) || this)._info = new ir(), i._hash = 0, i._info.copy(e), i._hash = n, i;
        }

        return Z(e, t), e.computeHash = function (t) {
          var e = t.minFilter;
          return e |= t.magFilter << 2, e |= t.mipFilter << 4, e |= t.addressU << 6, e |= t.addressV << 8, e |= t.addressW << 10, (e |= t.maxAnisotropy << 12) | t.cmpFunc << 16;
        }, e.unpackFromHash = function (t) {
          var e = new ir();
          return e.minFilter = (3 & t) >> 0, e.magFilter = (3 & t) >> 2, e.mipFilter = (3 & t) >> 4, e.addressU = (3 & t) >> 6, e.addressV = (3 & t) >> 8, e.addressW = (3 & t) >> 10, e.maxAnisotropy = (15 & t) >> 12, e.cmpFunc = (7 & t) >> 16, e;
        }, K(e, [{
          key: "info",
          get: function get() {
            return this._info;
          }
        }, {
          key: "hash",
          get: function get() {
            return this._hash;
          }
        }]), e;
      }(wr)), t("bo", function (t) {
        function e() {
          var e;
          return (e = t.call(this, jn.SHADER) || this)._name = "", e._stages = [], e._attributes = [], e._blocks = [], e._samplers = [], e;
        }

        return Z(e, t), K(e, [{
          key: "name",
          get: function get() {
            return this._name;
          }
        }, {
          key: "attributes",
          get: function get() {
            return this._attributes;
          }
        }, {
          key: "blocks",
          get: function get() {
            return this._blocks;
          }
        }, {
          key: "samplers",
          get: function get() {
            return this._samplers;
          }
        }]), e;
      }(wr)), t("bp", function (t) {
        function e() {
          var e;
          return (e = t.call(this, jn.TEXTURE) || this)._info = new er(), e._viewInfo = new nr(), e._isPowerOf2 = !1, e._isTextureView = !1, e._size = 0, e;
        }

        return Z(e, t), e.getLevelCount = function (t, e) {
          return Math.floor(Math.log2(Math.max(t, e)));
        }, K(e, [{
          key: "type",
          get: function get() {
            return this._info.type;
          }
        }, {
          key: "usage",
          get: function get() {
            return this._info.usage;
          }
        }, {
          key: "format",
          get: function get() {
            return this._info.format;
          }
        }, {
          key: "width",
          get: function get() {
            return this._info.width;
          }
        }, {
          key: "height",
          get: function get() {
            return this._info.height;
          }
        }, {
          key: "depth",
          get: function get() {
            return this._info.depth;
          }
        }, {
          key: "layerCount",
          get: function get() {
            return this._info.layerCount;
          }
        }, {
          key: "levelCount",
          get: function get() {
            return this._info.levelCount;
          }
        }, {
          key: "samples",
          get: function get() {
            return this._info.samples;
          }
        }, {
          key: "flags",
          get: function get() {
            return this._info.flags;
          }
        }, {
          key: "size",
          get: function get() {
            return this._size;
          }
        }, {
          key: "info",
          get: function get() {
            return this._info;
          }
        }, {
          key: "viewInfo",
          get: function get() {
            return this._viewInfo;
          }
        }, {
          key: "isTextureView",
          get: function get() {
            return this._isTextureView;
          }
        }]), e;
      }(wr)), t("bq", function (t) {
        function e(e, n) {
          var i;
          return (i = t.call(this, jn.GLOBAL_BARRIER) || this)._info = new Sr(), i._hash = 0, i._info.copy(e), i._hash = n, i;
        }

        return Z(e, t), e.computeHash = function (t) {
          return Zr(t.prevAccesses + " " + t.nextAccesses, 666);
        }, K(e, [{
          key: "info",
          get: function get() {
            return this._info;
          }
        }, {
          key: "hash",
          get: function get() {
            return this._hash;
          }
        }]), e;
      }(wr)), t("br", function (t) {
        function e(e, n) {
          var i;
          return (i = t.call(this, jn.TEXTURE_BARRIER) || this)._info = new Nr(), i._hash = 0, i._info.copy(e), i._hash = n, i;
        }

        return Z(e, t), e.computeHash = function (t) {
          var e = t.prevAccesses + " " + t.nextAccesses;
          return e += t.discardContents, e += t.srcQueue ? t.srcQueue.type : 0, Zr(e += t.dstQueue ? t.dstQueue.type : 0, 666);
        }, K(e, [{
          key: "info",
          get: function get() {
            return this._info;
          }
        }, {
          key: "hash",
          get: function get() {
            return this._hash;
          }
        }]), e;
      }(wr));
    }
  };
}); 
 			}); 
		define("__plugin__/wx0446ba2621dda60a/tiled-map.js", function(require, module, exports){ 			
"use strict";

System.register(["./texture-barrier-60b5983b.js", "./json-asset-933a1d4c.js", "./index-f2b92470.js", "./renderable-component-7c6600ed.js", "./deprecated-26630860.js", "./deprecated-ef6bb945.js", "./sprite-frame-1edab3eb.js", "./sprite-827770a8.js", "./renderable-2d-e2838949.js", "./deprecated-5f7f37d5.js", "./ZipUtils-3ae2be0b.js"], function (t) {
  "use strict";

  var e, i, r, s, n, o, a, h, l, u, g, f, d, _, p, c, m, y, v, A, w, b, S, x, T, I, C, D, N, O, P, E, G, z, F, L, R, M, X, U, H, j, B, k, Y, V, Z;

  return {
    setters: [function (t) {
      e = t.bw, i = t.c, r = t.f, s = t.bU, n = t.bE, o = t.bT, a = t.w, h = t.c0, l = t.c1, u = t.b$, g = t.bG, f = t.bC, d = t.G, _ = t.bH, p = t.i, c = t.cw;
    }, function (t) {
      m = t.V, y = t.a5, v = t.a1, A = t.a3, w = t.bW, b = t.bZ, S = t.cd, x = t.cg, T = t.ch, I = t.dQ, C = t.bm, D = t.Z, N = t.Q, O = t.dR, P = t.b6, E = t.aQ, G = t.aL, z = t.bX, F = t.b0, L = t.b$, R = t.bY;
    }, function (t) {
      M = t.S;
    }, function () {}, function () {}, function (t) {
      X = t.d;
    }, function (t) {
      U = t.S;
    }, function (t) {
      H = t.c, j = t.a;
    }, function (t) {
      B = t.U, k = t.M, Y = t.R;
    }, function () {}, function (t) {
      V = t.c, Z = t._;
    }],
    execute: function execute() {
      var K, W, q, J, Q, $, tt;
      !function (t) {
        t[t.ORTHO = 0] = "ORTHO", t[t.HEX = 1] = "HEX", t[t.ISO = 2] = "ISO";
      }(K || (K = {})), e(K), function (t) {
        t[t.NONE = 0] = "NONE", t[t.MAP = 1] = "MAP", t[t.LAYER = 2] = "LAYER", t[t.OBJECTGROUP = 3] = "OBJECTGROUP", t[t.OBJECT = 4] = "OBJECT", t[t.TILE = 5] = "TILE";
      }(W || (W = {})), e(W), function (t) {
        t[t.HORIZONTAL = 2147483648] = "HORIZONTAL", t[t.VERTICAL = 1073741824] = "VERTICAL", t[t.DIAGONAL = 536870912] = "DIAGONAL", t[t.FLIPPED_ALL = 4026531840] = "FLIPPED_ALL", t[t.FLIPPED_MASK = 268435455] = "FLIPPED_MASK";
      }(q || (q = {})), e(q), function (t) {
        t[t.STAGGERAXIS_X = 0] = "STAGGERAXIS_X", t[t.STAGGERAXIS_Y = 1] = "STAGGERAXIS_Y";
      }(J || (J = {})), e(J), function (t) {
        t[t.STAGGERINDEX_ODD = 0] = "STAGGERINDEX_ODD", t[t.STAGGERINDEX_EVEN = 1] = "STAGGERINDEX_EVEN";
      }(Q || (Q = {})), e(Q), function (t) {
        t[t.RightDown = 0] = "RightDown", t[t.RightUp = 1] = "RightUp", t[t.LeftDown = 2] = "LeftDown", t[t.LeftUp = 3] = "LeftUp";
      }($ || ($ = {})), e($), function (t) {
        t[t.RECT = 0] = "RECT", t[t.ELLIPSE = 1] = "ELLIPSE", t[t.POLYGON = 2] = "POLYGON", t[t.POLYLINE = 3] = "POLYLINE", t[t.IMAGE = 4] = "IMAGE", t[t.TEXT = 5] = "TEXT";
      }(tt || (tt = {})), e(tt);

      var et = function () {
        function t() {
          this.name = "", this.firstGid = 0, this.spacing = 0, this.margin = 0, this.sourceImage = void 0, this.imageName = null, this.imageSize = new v(0, 0), this.tileOffset = new m(0, 0), this._tileSize = new v(0, 0), this.collection = !1;
        }

        return t.prototype.rectForGID = function (t, e) {
          var i = e || new A(0, 0, 0, 0);
          i.width = this._tileSize.width, i.height = this._tileSize.height;
          var r = t;
          r &= q.FLIPPED_MASK, r -= this.firstGid;
          var s = Math.floor((this.imageSize.width - 2 * this.margin + this.spacing) / (this._tileSize.width + this.spacing));
          return i.x = Math.round(r % s * (this._tileSize.width + this.spacing) + this.margin), i.y = Math.round(Math.floor(r / s) * (this._tileSize.height + this.spacing) + this.margin), i;
        }, t;
      }(),
          it = function () {
        function t() {
          this.properties = {}, this.name = "", this.objects = [], this.visible = !0, this.opacity = 0, this.color = new y(255, 255, 255, 255), this.offset = new m(0, 0), this.draworder = "topdown", this.tintColor = null;
        }

        var e = t.prototype;
        return e.getProperties = function () {
          return this.properties;
        }, e.setProperties = function (t) {
          this.properties = t;
        }, t;
      }(),
          rt = function () {
        function t() {
          this.properties = {}, this.name = "", this.layerSize = null, this.tiles = [], this.visible = !0, this.opacity = 0, this.ownTiles = !0, this.minGID = 1e5, this.maxGID = 0, this.offset = new m(0, 0), this.tintColor = null;
        }

        var e = t.prototype;
        return e.getProperties = function () {
          return this.properties;
        }, e.setProperties = function (t) {
          this.properties = t;
        }, t;
      }();

      rt.ATTRIB_NONE = 1, rt.ATTRIB_BASE64 = 2, rt.ATTRIB_GZIP = 4, rt.ATTRIB_ZLIB = 8;

      var st = function st() {
        this.name = "", this.visible = !0, this.width = 0, this.height = 0, this.offset = new m(0, 0), this.opacity = 0, this.trans = new y(255, 255, 255, 255), this.sourceImage = void 0, this.tintColor = null;
      };

      function nt(t) {
        var e = H.HorizontalAlign;

        switch (t) {
          case "center":
            return e.CENTER;

          case "right":
            return e.RIGHT;

          default:
            return e.LEFT;
        }
      }

      function ot(t) {
        var e = H.VerticalAlign;

        switch (t) {
          case "center":
            return e.CENTER;

          case "bottom":
            return e.BOTTOM;

          default:
            return e.TOP;
        }
      }

      function at(t) {
        if (!t) return new y(0, 0, 0, 255);

        if (8 === (t = -1 !== t.indexOf("#") ? t.substring(1) : t).length) {
          var e = parseInt(t.substr(0, 2), 16) || 255,
              i = parseInt(t.substr(2, 2), 16) || 0,
              r = parseInt(t.substr(4, 2), 16) || 0,
              s = parseInt(t.substr(6, 2), 16) || 0;
          return new y(i, r, s, e);
        }

        var n = parseInt(t.substr(0, 2), 16) || 0,
            o = parseInt(t.substr(2, 2), 16) || 0,
            a = parseInt(t.substr(4, 2), 16) || 0;
        return new y(n, o, a, 255);
      }

      function ht(t, e) {
        for (var i = [], r = t.getElementsByTagName("properties"), s = 0; s < r.length; ++s) {
          for (var n = r[s].getElementsByTagName("property"), o = 0; o < n.length; ++o) {
            i.push(n[o]);
          }
        }

        e = e || {};

        for (var a = 0; a < i.length; a++) {
          var h = i[a],
              l = h.getAttribute("name"),
              u = h.getAttribute("type") || "string",
              g = h.getAttribute("value");
          "int" === u ? g = parseInt(g) : "float" === u ? g = parseFloat(g) : "bool" === u ? g = "true" === g : "color" === u && (g = at(g)), e[l] = g;
        }

        return e;
      }

      var lt,
          ut,
          gt,
          ft,
          dt,
          _t,
          pt,
          ct,
          mt,
          yt,
          vt,
          At,
          wt,
          bt,
          St,
          xt,
          Tt = function () {
        function t(t, e, i, r, s) {
          this.properties = {}, this.orientation = null, this.parentElement = null, this.parentGID = 0, this.layerAttrs = 0, this.storingCharacters = !1, this.currentString = null, this.renderOrder = $.RightDown, this._supportVersion = [1, 4, 0], this._objectGroups = [], this._allChildren = [], this._mapSize = new v(0, 0), this._tileSize = new v(0, 0), this._layers = [], this._tilesets = [], this._imageLayers = [], this._tileProperties = new Map(), this._tileAnimations = {}, this._tsxContentMap = null, this._spriteFrameMap = null, this._spfSizeMap = {}, this._staggerAxis = null, this._staggerIndex = null, this._hexSideLength = 0, this._imageLayerSPF = null, this.initWithXML(t, e, i, r, s);
        }

        var e = t.prototype;
        return e.getOrientation = function () {
          return this.orientation;
        }, e.setOrientation = function (t) {
          this.orientation = t;
        }, e.getStaggerAxis = function () {
          return this._staggerAxis;
        }, e.setStaggerAxis = function (t) {
          this._staggerAxis = t;
        }, e.getStaggerIndex = function () {
          return this._staggerIndex;
        }, e.setStaggerIndex = function (t) {
          this._staggerIndex = t;
        }, e.getHexSideLength = function () {
          return this._hexSideLength;
        }, e.setHexSideLength = function (t) {
          this._hexSideLength = t;
        }, e.getMapSize = function () {
          return new v(this._mapSize.width, this._mapSize.height);
        }, e.setMapSize = function (t) {
          this._mapSize.width = t.width, this._mapSize.height = t.height;
        }, e.getTileSize = function () {
          return new v(this._tileSize.width, this._tileSize.height);
        }, e.setTileSize = function (t) {
          this._tileSize.width = t.width, this._tileSize.height = t.height;
        }, e.getLayers = function () {
          return this._layers;
        }, e.setLayers = function (t) {
          this._allChildren.push(t), this._layers.push(t);
        }, e.getImageLayers = function () {
          return this._imageLayers;
        }, e.setImageLayers = function (t) {
          this._allChildren.push(t), this._imageLayers.push(t);
        }, e.getTilesets = function () {
          return this._tilesets;
        }, e.setTilesets = function (t) {
          this._tilesets.push(t);
        }, e.getObjectGroups = function () {
          return this._objectGroups;
        }, e.setObjectGroups = function (t) {
          this._allChildren.push(t), this._objectGroups.push(t);
        }, e.getAllChildren = function () {
          return this._allChildren;
        }, e.getParentElement = function () {
          return this.parentElement;
        }, e.setParentElement = function (t) {
          this.parentElement = t;
        }, e.getParentGID = function () {
          return this.parentGID;
        }, e.setParentGID = function (t) {
          this.parentGID = t;
        }, e.getLayerAttribs = function () {
          return this.layerAttrs;
        }, e.setLayerAttribs = function (t) {
          this.layerAttrs = t;
        }, e.getStoringCharacters = function () {
          return this.storingCharacters;
        }, e.setStoringCharacters = function (t) {
          this.storingCharacters = t;
        }, e.getProperties = function () {
          return this.properties;
        }, e.setProperties = function (t) {
          this.properties = t;
        }, e.initWithXML = function (t, e, i, r, s) {
          return this._tilesets.length = 0, this._layers.length = 0, this._imageLayers.length = 0, this._tsxContentMap = e, this._spriteFrameMap = i, this._imageLayerSPF = s, this._spfSizeMap = r, this._objectGroups.length = 0, this._allChildren.length = 0, this.properties = {}, this._tileProperties = new Map(), this._tileAnimations = new Map(), this.currentString = "", this.storingCharacters = !1, this.layerAttrs = rt.ATTRIB_NONE, this.parentElement = null, this.parseXMLString(t);
        }, e.parseXMLString = function (e, s) {
          var n,
              o = new M().parse(e).documentElement,
              a = o.getAttribute("orientation"),
              h = o.getAttribute("staggeraxis"),
              l = o.getAttribute("staggerindex"),
              u = o.getAttribute("hexsidelength"),
              g = o.getAttribute("renderorder"),
              f = o.getAttribute("version") || "1.0.0";

          if ("map" === o.nodeName) {
            var d = f.split("."),
                _ = this._supportVersion;

            for (n = 0; n < _.length; n++) {
              var p = parseInt(d[n]) || 0;

              if (_[n] < p) {
                i(7216, f);
                break;
              }
            }

            "orthogonal" === a ? this.orientation = K.ORTHO : "isometric" === a ? this.orientation = K.ISO : "hexagonal" === a ? this.orientation = K.HEX : null !== a && i(7217, a), this.renderOrder = "right-up" === g ? $.RightUp : "left-up" === g ? $.LeftUp : "left-down" === g ? $.LeftDown : $.RightDown, "x" === h ? this.setStaggerAxis(J.STAGGERAXIS_X) : "y" === h && this.setStaggerAxis(J.STAGGERAXIS_Y), "odd" === l ? this.setStaggerIndex(Q.STAGGERINDEX_ODD) : "even" === l && this.setStaggerIndex(Q.STAGGERINDEX_EVEN), u && this.setHexSideLength(parseFloat(u));
            var c = new v(0, 0);
            c.width = parseFloat(o.getAttribute("width")), c.height = parseFloat(o.getAttribute("height")), this.setMapSize(c), (c = new v(0, 0)).width = parseFloat(o.getAttribute("tilewidth")), c.height = parseFloat(o.getAttribute("tileheight")), this.setTileSize(c), this.properties = ht(o);
          }

          var m = o.getElementsByTagName("tileset");

          for ("map" !== o.nodeName && (m = []).push(o), n = 0; n < m.length; n++) {
            var y = m[n],
                A = y.getAttribute("source");

            if (A) {
              var w = parseInt(y.getAttribute("firstgid")),
                  b = this._tsxContentMap[A];
              b && this.parseXMLString(b, w);
            } else {
              var S = y.getElementsByTagName("image"),
                  x = S.length > 1,
                  T = S[0],
                  I = T.getAttribute("source");
              I = I.replace(/\\/g, "/");
              var C = y.getElementsByTagName("tile"),
                  D = C && C.length || 1,
                  N = null,
                  O = y.getAttribute("name") || "",
                  P = parseInt(y.getAttribute("spacing")) || 0,
                  E = parseInt(y.getAttribute("margin")) || 0,
                  G = s || parseInt(y.getAttribute("firstgid")) || 0,
                  z = new v(0, 0);
              z.width = parseFloat(y.getAttribute("tilewidth")), z.height = parseFloat(y.getAttribute("tileheight"));
              var F = y.getElementsByTagName("tileoffset")[0],
                  L = 0,
                  R = 0;
              F && (L = parseFloat(F.getAttribute("x")) || 0, R = parseFloat(F.getAttribute("y")) || 0);

              for (var X = null, U = 0; U < D; U++) {
                var H = S[U] ? S[U] : T;

                if (H) {
                  var j = H.getAttribute("source");

                  if (j = j.replace(/\\/g, "/"), !X || x) {
                    if ((X = new et()).name = O, X.firstGid = G & q.FLIPPED_MASK, X.tileOffset.x = L, X.tileOffset.y = R, X.collection = x, !x && (X.imageName = j, X.imageSize.width = parseFloat(H.getAttribute("width")) || 0, X.imageSize.height = parseFloat(H.getAttribute("height")) || 0, X.sourceImage = this._spriteFrameMap[j], !X.sourceImage)) {
                      var B = t.getNameWithPostfix(j);

                      if (X.imageName = B, X.sourceImage = this._spriteFrameMap[B], !X.sourceImage) {
                        var k = t.getShortName(j);
                        X.imageName = k, X.sourceImage = this._spriteFrameMap[k], X.sourceImage || (console.error("[error]: " + k + " not find in [" + Object.keys(this._spriteFrameMap).join(", ") + "]"), r(7221, j), console.warn("Please try asset type of " + j + " to 'sprite-frame'"));
                      }
                    }

                    X.spacing = P, X.margin = E, X._tileSize.width = z.width, X._tileSize.height = z.height, this.setTilesets(X);
                  }

                  if (N = C && C[U]) {
                    this.parentGID = G + (parseInt(N.getAttribute("id")) || 0);
                    var Y = N.getElementsByTagName("image");

                    if (Y && Y.length > 0) {
                      var V = Y[0],
                          Z = V.getAttribute("source");

                      if (Z = Z.replace(/\\/g, "/"), X.imageName = Z, X.imageSize.width = parseFloat(V.getAttribute("width")) || 0, X.imageSize.height = parseFloat(V.getAttribute("height")) || 0, X._tileSize.width = X.imageSize.width, X._tileSize.height = X.imageSize.height, X.sourceImage = this._spriteFrameMap[Z], !X.sourceImage) {
                        var W = t.getNameWithPostfix(Z);

                        if (X.imageName = W, X.sourceImage = this._spriteFrameMap[W], !X.sourceImage) {
                          var tt = t.getShortName(Z);
                          X.imageName = tt, X.sourceImage = this._spriteFrameMap[tt], X.sourceImage || (r(7221, Z), console.warn("Please try asset type of " + Z + " to 'sprite-frame'"));
                        }
                      }

                      X.firstGid = this.parentGID & q.FLIPPED_MASK;
                    }

                    var it = (q.FLIPPED_MASK & this.parentGID) >>> 0;

                    this._tileProperties.set(it, ht(N));

                    var rt = N.getElementsByTagName("animation");

                    if (rt && rt.length > 0) {
                      var st = rt[0].getElementsByTagName("frame"),
                          nt = {
                        frames: [],
                        dt: 0,
                        frameIdx: 0
                      };

                      this._tileAnimations.set(it, nt);

                      for (var ot = nt.frames, at = 0; at < st.length; at++) {
                        var lt = st[at],
                            ut = G + (parseInt(lt.getAttribute("tileid")) || 0),
                            gt = parseFloat(lt.getAttribute("duration")) || 0;
                        ot.push({
                          tileid: ut,
                          duration: gt / 1e3,
                          grid: null
                        });
                      }
                    }
                  }
                }
              }
            }
          }

          var ft = o.childNodes;

          for (n = 0; n < ft.length; n++) {
            var dt = ft[n];

            if (!this._shouldIgnoreNode(dt)) {
              if ("imagelayer" === dt.nodeName) {
                var _t = this._parseImageLayer(dt);

                _t && this.setImageLayers(_t);
              }

              if ("layer" === dt.nodeName) {
                var pt = this._parseLayer(dt);

                this.setLayers(pt);
              }

              if ("objectgroup" === dt.nodeName) {
                var ct = this._parseObjectGroup(dt);

                this.setObjectGroups(ct);
              }
            }
          }

          return o;
        }, e._shouldIgnoreNode = function (t) {
          return 3 === t.nodeType || 8 === t.nodeType || 4 === t.nodeType;
        }, e._parseImageLayer = function (t) {
          var e = t.getElementsByTagName("image");
          if (!e || 0 === e.length) return null;
          var i = new st();
          i.name = t.getAttribute("name"), i.offset.x = parseFloat(t.getAttribute("offsetx")) || 0, i.offset.y = parseFloat(t.getAttribute("offsety")) || 0;
          var s = t.getAttribute("visible");
          i.visible = !("0" === s);
          var n = t.getAttribute("opacity");
          i.opacity = n ? Math.round(255 * parseFloat(n)) : 255;
          var o = t.getAttribute("tintcolor");
          i.tintColor = o ? at(o) : null;
          var a = e[0],
              h = a.getAttribute("source");
          return i.sourceImage = this._imageLayerSPF[h], i.width = parseInt(a.getAttribute("width")) || 0, i.height = parseInt(a.getAttribute("height")) || 0, i.trans = at(a.getAttribute("trans")), i.sourceImage ? i : (r(7221, h), console.warn("Please try asset type of " + h + " to 'sprite-frame'"), null);
        }, e._parseLayer = function (t) {
          var e = t.getElementsByTagName("data")[0],
              r = new rt();
          r.name = t.getAttribute("name");
          var s = new v(0, 0);
          s.width = parseFloat(t.getAttribute("width")), s.height = parseFloat(t.getAttribute("height")), r.layerSize = s;
          var n = t.getAttribute("visible");
          r.visible = !("0" === n);
          var o = t.getAttribute("opacity");
          r.opacity = o ? Math.round(255 * parseFloat(o)) : 255, r.offset = new m(parseFloat(t.getAttribute("offsetx")) || 0, parseFloat(t.getAttribute("offsety")) || 0);
          var a = t.getAttribute("tintcolor");
          r.tintColor = a ? at(a) : null;

          for (var h = "", l = 0; l < e.childNodes.length; l++) {
            h += e.childNodes[l].nodeValue;
          }

          h = h.trim();
          var u,
              g = e.getAttribute("compression"),
              f = e.getAttribute("encoding");
          if (g && "gzip" !== g && "zlib" !== g) return i(7218), null;

          switch (g) {
            case "gzip":
              u = V.unzipBase64AsArray(h, 4);
              break;

            case "zlib":
              u = function (t) {
                if (t.length % 4 != 0) return null;

                for (var e = t.length / 4, i = window.Uint32Array ? new Uint32Array(e) : [], r = 0; r < e; r++) {
                  var s = 4 * r;
                  i[r] = t[s] + 256 * t[s + 1] + 65536 * t[s + 2] + t[s + 3] * (1 << 24);
                }

                return i;
              }(new Z.Inflate(V.Base64.decodeAsArray(h, 1)).decompress());

              break;

            case null:
            case "":
              if ("base64" === f) u = V.Base64.decodeAsArray(h, 4);else if ("csv" === f) {
                u = [];

                for (var d = h.split(","), _ = 0; _ < d.length; _++) {
                  u.push(parseInt(d[_]));
                }
              } else {
                var p = e.getElementsByTagName("tile");
                u = [];

                for (var c = 0; c < p.length; c++) {
                  u.push(parseInt(p[c].getAttribute("gid")));
                }
              }
              break;

            default:
              this.layerAttrs === rt.ATTRIB_NONE && i(7219);
          }

          return u && (r.tiles = new Uint32Array(u)), r.properties = ht(t), r;
        }, e._parseObjectGroup = function (t) {
          var e = new it();
          e.name = t.getAttribute("name") || "", e.offset = new m(parseFloat(t.getAttribute("offsetx")), parseFloat(t.getAttribute("offsety")));
          var i = t.getAttribute("opacity");
          e.opacity = i ? Math.round(255 * parseFloat(i)) : 255;
          var r = t.getAttribute("tintcolor");
          e.tintColor = r ? at(r) : null;
          var s = t.getAttribute("visible");
          s && 0 === parseInt(s) && (e.visible = !1);
          var n = t.getAttribute("color");
          n && e.color.fromHEX(n);
          var o = t.getAttribute("draworder");
          o && (e.draworder = o), e.setProperties(ht(t));
          var a = t.getElementsByTagName("object");

          if (a) {
            for (var h = 0; h < a.length; h++) {
              var l = a[h],
                  u = {};
              u.id = l.getAttribute("id") || h, u.name = l.getAttribute("name") || "", u.width = parseFloat(l.getAttribute("width")) || 0, u.height = parseFloat(l.getAttribute("height")) || 0, u.x = parseFloat(l.getAttribute("x")) || 0, u.y = parseFloat(l.getAttribute("y")) || 0, u.rotation = parseFloat(l.getAttribute("rotation")) || 0, ht(l, u);
              var g = l.getAttribute("visible");
              u.visible = !(g && 0 === parseInt(g));
              var f = l.getElementsByTagName("text");

              if (f && f.length > 0) {
                var d = f[0];
                u.type = tt.TEXT, u.wrap = "1" === d.getAttribute("wrap"), u.color = at(d.getAttribute("color")), u.halign = nt(d.getAttribute("halign")), u.valign = ot(d.getAttribute("valign")), u.pixelsize = parseInt(d.getAttribute("pixelsize")) || 16, u.text = d.childNodes[0].nodeValue;
              }

              var _ = l.getAttribute("gid");

              _ && (u.gid = parseInt(_), u.type = tt.IMAGE);
              var p = l.getElementsByTagName("ellipse");
              p && p.length > 0 && (u.type = tt.ELLIPSE);
              var c = l.getElementsByTagName("polygon");

              if (c && c.length > 0) {
                u.type = tt.POLYGON;
                var y = c[0].getAttribute("points");
                y && (u.points = this._parsePointsString(y));
              }

              var v = l.getElementsByTagName("polyline");

              if (v && v.length > 0) {
                u.type = tt.POLYLINE;
                var A = v[0].getAttribute("points");
                A && (u.polylinePoints = this._parsePointsString(A));
              }

              u.type || (u.type = tt.RECT), e.objects.push(u);
            }

            "index" !== o && e.objects.sort(function (t, e) {
              return t.y - e.y;
            });
          }

          return e;
        }, e._parsePointsString = function (t) {
          if (!t) return null;

          for (var e = [], i = t.split(" "), r = 0; r < i.length; r++) {
            var s = i[r].split(",");
            e.push({
              x: parseFloat(s[0]),
              y: parseFloat(s[1])
            });
          }

          return e;
        }, e.setTileAnimations = function (t) {
          this._tileAnimations = t;
        }, e.getTileAnimations = function () {
          return this._tileAnimations;
        }, e.getTileProperties = function () {
          return this._tileProperties;
        }, e.setTileProperties = function (t) {
          this._tileProperties = t;
        }, e.getCurrentString = function () {
          return this.currentString;
        }, e.setCurrentString = function (t) {
          this.currentString = t;
        }, t.getNameWithPostfix = function (t) {
          var e = (t = t.replace(/\\/g, "/")).lastIndexOf("/") + 1,
              i = t.length;
          return t.substring(e, i);
        }, t.getShortName = function (t) {
          var e = (t = t.replace(/\\/g, "/")).lastIndexOf("/") + 1,
              i = t.lastIndexOf(".");
          return i = i < 0 ? t.length : i, t.substring(e, i);
        }, s(t, [{
          key: "mapSize",
          get: function get() {
            return this._mapSize;
          }
        }, {
          key: "tileSize",
          get: function get() {
            return this._tileSize;
          }
        }, {
          key: "mapWidth",
          get: function get() {
            return this._mapSize.width;
          },
          set: function set(t) {
            this._mapSize.width = t;
          }
        }, {
          key: "mapHeight",
          get: function get() {
            return this._mapSize.height;
          },
          set: function set(t) {
            this._mapSize.height = t;
          }
        }, {
          key: "tileWidth",
          get: function get() {
            return this._tileSize.width;
          },
          set: function set(t) {
            this._tileSize.width = t;
          }
        }, {
          key: "tileHeight",
          get: function get() {
            return this._tileSize.height;
          },
          set: function set(t) {
            this._tileSize.height = t;
          }
        }]), t;
      }(),
          It = t("TiledTile", (lt = w("cc.TiledTile"), ut = x(), gt = T(), ft = I(B), dt = b(n), _t = b(n), pt = b(n), ct = b(n), mt = b(n), lt(yt = ut(yt = gt(yt = ft(yt = S((bt = function (t) {
        function e() {
          var e;
          return (e = t.call(this) || this)._layer = null, l(e, "_x", At, u(e)), l(e, "_y", wt, u(e)), e;
        }

        o(e, t);
        var i = e.prototype;
        return i.onEnable = function () {
          var t = this.node.parent;
          this._layer = t.getComponent("cc.TiledLayer"), this._resetTile(), this.updateInfo();
        }, i.onDisable = function () {
          this._resetTile();
        }, i._resetTile = function () {
          this._layer && this._layer.getTiledTileAt(this._x, this._y) === this && this._layer.setTiledTileAt(this._x, this._y, null);
        }, i.updateInfo = function () {
          if (this._layer) {
            var t = this._x,
                e = this._y;
            if (this._layer.getTiledTileAt(t, e)) a("There is already a TiledTile at [%s, %s]", t, e);else {
              var i = this._layer.getPositionAt(t, e);

              this.node.setPosition(i.x, i.y), this._layer.setTiledTileAt(t, e, this);
            }
          }
        }, s(e, [{
          key: "x",
          get: function get() {
            return this._x;
          },
          set: function set(t) {
            t !== this._x && (this._layer && this._layer.isInvalidPosition(t, this._y) ? a("Invalid x, the valid value is between [%s] ~ [%s]", 0, this._layer.layerSize.width) : (this._resetTile(), this._x = t, this.updateInfo()));
          }
        }, {
          key: "y",
          get: function get() {
            return this._y;
          },
          set: function set(t) {
            t !== this._y && (this._layer && this._layer.isInvalidPosition(this._x, t) ? a("Invalid y, the valid value is between [%s] ~ [%s]", 0, this._layer.layerSize.height) : (this._resetTile(), this._y = t, this.updateInfo()));
          }
        }, {
          key: "grid",
          get: function get() {
            return this._layer ? this._layer.getTileGIDAt(this._x, this._y) : 0;
          },
          set: function set(t) {
            this._layer && this._layer.setTileGIDAt(t, this._x, this._y);
          }
        }]), e;
      }(C), At = h((vt = bt).prototype, "_x", [dt], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 0;
        }
      }), wt = h(vt.prototype, "_y", [_t], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 0;
        }
      }), h(vt.prototype, "x", [pt], Object.getOwnPropertyDescriptor(vt.prototype, "x"), vt.prototype), h(vt.prototype, "y", [ct], Object.getOwnPropertyDescriptor(vt.prototype, "y"), vt.prototype), h(vt.prototype, "grid", [mt], Object.getOwnPropertyDescriptor(vt.prototype, "grid"), vt.prototype), yt = vt)) || yt) || yt) || yt) || yt) || yt));

      function Ct(t, e, i) {
        var r = i || t.sourceImage,
            s = r.texture,
            n = t.collection;

        if (!t.imageSize.width || !t.imageSize.height) {
          var o = t.sourceImage;
          t.imageSize.width = o.width, t.imageSize.height = o.height;
        }

        var a = t.imageSize.width,
            h = t.imageSize.height,
            l = t._tileSize.width,
            u = t._tileSize.height,
            g = r.width,
            f = r.height,
            d = t.spacing,
            _ = t.margin,
            p = 1;

        if (!n) {
          var c = Math.floor((a - 2 * _ + d) / (l + d)),
              m = Math.floor((h - 2 * _ + d) / (u + d));
          p = Math.max(1, m * c);
        }

        for (var y = t.firstGid, v = null, w = !!e.get(y), b = t.firstGid + p, S = y; S < b && (w && !e.get(S) && (w = !1), w || !e.get(S)); ++S) {
          if (v = {
            tileset: t,
            x: 0,
            y: 0,
            width: l,
            height: u,
            t: 0,
            l: 0,
            r: 0,
            b: 0,
            cx: 0,
            cy: 0,
            offsetX: 0,
            offsetY: 0,
            rotated: !1,
            gid: S,
            spriteFrame: r,
            texture: s
          }, t.rectForGID(S, v), !i || p > 1) {
            if (i) {
              v._name = i.name;
              var x = i.unbiasUV[0],
                  T = i.rotated ? i.unbiasUV[1] : i.unbiasUV[5];
              v.l = x + (v.x + .5) / g, v.t = T + (v.y + .5) / f, v.r = x + (v.x + v.width - .5) / g, v.b = T + (v.y + v.height - .5) / f, v._rect = new A(v.x, v.y, v.width, v.height);
            } else v.l = v.x / g, v.t = v.y / f, v.r = (v.x + v.width) / g, v.b = (v.y + v.height) / f, v._rect = new A(v.x, v.y, v.width, v.height);
          } else i.rotated ? (v._rotated = !0, v._name = i.name, v._rect = i.getRect(), v.l = i.unbiasUV[0], v.t = i.unbiasUV[1], v.r = i.unbiasUV[4], v.b = i.unbiasUV[3]) : (v._name = i.name, v._rect = i.getRect(), v.l = i.unbiasUV[0], v.t = i.unbiasUV[5], v.r = i.unbiasUV[2], v.b = i.unbiasUV[1]);
          v.cx = (v.l + v.r) / 2, v.cy = (v.t + v.b) / 2, e.set(S, v);
        }
      }

      for (var Dt, Nt, Ot, Pt, Et, Gt, zt, Ft, Lt, Rt, Mt, Xt, Ut, Ht, jt, Bt, kt, Yt, Vt, Zt, Kt, Wt, qt, Jt, Qt, $t, te, ee, ie, re, se, ne, oe, ae, he, le, ue, ge, fe, de = new D(), _e = new m(), pe = new N(), ce = new N(), me = {
        row: 0,
        col: 0
      }, ye = t("TiledUserNodeData", w("cc.TiledUserNodeData")(St = function (t) {
        function e() {
          var e;
          return (e = t.call(this) || this)._index = -1, e._row = -1, e._col = -1, e._tiledLayer = null, e;
        }

        return o(e, t), e;
      }(C)) || St), ve = t("TiledLayer", w("cc.TiledLayer")(xt = function (t) {
        function e() {
          var e;
          return (e = t.call(this) || this)._userNodeGrid = {}, e._userNodeMap = {}, e._userNodeDirty = !1, e.tiledTiles = [], e._viewPort = {
            x: -1,
            y: -1,
            width: -1,
            height: -1
          }, e._cullingRect = {
            leftDown: {
              row: -1,
              col: -1
            },
            rightTop: {
              row: -1,
              col: -1
            }
          }, e._cullingDirty = !0, e._rightTop = {
            row: -1,
            col: -1
          }, e._layerInfo = null, e._mapInfo = null, e._topOffset = 0, e._downOffset = 0, e._leftOffset = 0, e._rightOffset = 0, e.tiles = [], e.vertices = [], e._verticesDirty = !0, e._layerName = "", e._layerSize = void 0, e._minGID = void 0, e._maxGID = void 0, e._layerOrientation = null, e._opacity = void 0, e._tintColor = void 0, e.texGrids = null, e._textures = [], e._tilesets = [], e._leftDownToCenterX = 0, e._leftDownToCenterY = 0, e._hasTiledNodeGrid = !1, e._hasAniGrid = !1, e._animations = null, e._enableCulling = void 0, e.colorChanged = !1, e._properties = void 0, e.renderOrder = void 0, e._staggerAxis = void 0, e._staggerIndex = void 0, e._hexSideLength = void 0, e._mapTileSize = void 0, e._odd_even = void 0, e._diffX1 = void 0, e._diffY1 = void 0, e._useAutomaticVertexZ = void 0, e._vertexZvalue = void 0, e._offset = void 0, e._meshRenderDataArray = null, e._meshRenderDataArrayIdx = 0, e;
        }

        o(e, t);
        var r = e.prototype;
        return r.hasTiledNode = function () {
          return this._hasTiledNodeGrid;
        }, r.hasAnimation = function () {
          return this._hasAniGrid;
        }, r.addUserNode = function (t) {
          var e = t.getComponent(ye);
          return e ? (a("CCTiledLayer:addUserNode node has been added"), !1) : (e = t.addComponent(ye), t.parent = this.node, this._userNodeMap[t.uuid] = e, e._row = -1, e._col = -1, e._tiledLayer = this, this._nodeLocalPosToLayerPos(t.getPosition(), _e), this._positionToRowCol(_e.x, _e.y, me), this._addUserNodeToGrid(e, me), this._updateCullingOffsetByUserNode(t), t.on(O.TRANSFORM_CHANGED, this._userNodePosChange, e), t.on(O.SIZE_CHANGED, this._userNodeSizeChange, e), !0);
        }, r.removeUserNode = function (t) {
          var e = t.getComponent(ye);
          return e ? (t.off(O.TRANSFORM_CHANGED, this._userNodePosChange, e), t.off(O.SIZE_CHANGED, this._userNodeSizeChange, e), this._removeUserNodeFromGrid(e), delete this._userNodeMap[t.uuid], t._removeComponent(e), e.destroy(), t.removeFromParent(), !0) : (a("CCTiledLayer:removeUserNode node is not exist"), !1);
        }, r.destroyUserNode = function (t) {
          this.removeUserNode(t), t.destroy();
        }, r._nodeLocalPosToLayerPos = function (t, e) {
          e.x = t.x + this._leftDownToCenterX, e.y = t.y + this._leftDownToCenterY;
        }, r.getNodesByRowCol = function (t, e) {
          var i = this._userNodeGrid[t];
          return i ? i[e] : null;
        }, r.getNodesCountByRow = function (t) {
          var e = this._userNodeGrid[t];
          return e ? e.count : 0;
        }, r._updateAllUserNode = function () {
          for (var t in this._userNodeGrid = {}, this._userNodeMap) {
            var e = this._userNodeMap[t];
            this._nodeLocalPosToLayerPos(e.node.getPosition(), _e), this._positionToRowCol(_e.x, _e.y, me), this._addUserNodeToGrid(e, me), this._updateCullingOffsetByUserNode(e.node);
          }
        }, r._updateCullingOffsetByUserNode = function (t) {
          var e = t._uiProps.uiTransformComp.contentSize;
          this._topOffset < e.height && (this._topOffset = e.height), this._downOffset < e.height && (this._downOffset = e.height), this._leftOffset < e.width && (this._leftOffset = e.width), this._rightOffset < e.width && (this._rightOffset = e.width);
        }, r._userNodeSizeChange = function () {
          var t = this.node,
              e = this._tiledLayer;
          e._updateCullingOffsetByUserNode(t), e._userNodeDirty = !0, e.markForUpdateRenderData();
        }, r._userNodePosChange = function () {
          var t = this,
              e = t.node,
              i = t._tiledLayer;
          i._nodeLocalPosToLayerPos(e.getPosition(), _e), i._positionToRowCol(_e.x, _e.y, me), i._limitInLayer(me), me.row === t._row && me.col === t._col || (i._removeUserNodeFromGrid(t), i._addUserNodeToGrid(t, me));
        }, r._removeUserNodeFromGrid = function (t) {
          var e = t._row,
              i = t._col,
              r = t._index,
              s = this._userNodeGrid[e],
              n = s && s[i];
          n && (s.count--, n.count--, n.list[r] = null, n.count <= 0 && (n.list.length = 0, n.count = 0)), t._row = -1, t._col = -1, t._index = -1, this._userNodeDirty = !0, this.markForUpdateRenderData();
        }, r._limitInLayer = function (t) {
          var e = t.row,
              i = t.col;
          e < 0 && (t.row = 0), e > this._rightTop.row && (t.row = this._rightTop.row), i < 0 && (t.col = 0), i > this._rightTop.col && (t.col = this._rightTop.col);
        }, r._addUserNodeToGrid = function (t, e) {
          var i = e.row,
              r = e.col,
              s = this._userNodeGrid[i] = this._userNodeGrid[i] || {
            count: 0
          },
              n = s[r] = s[r] || {
            count: 0,
            list: []
          };
          t._row = i, t._col = r, t._index = n.list.length, s.count++, n.count++, n.list.push(t), this._userNodeDirty = !0;
        }, r.isUserNodeDirty = function () {
          return this._userNodeDirty;
        }, r.setUserNodeDirty = function (t) {
          this._userNodeDirty = t;
        }, r.onEnable = function () {
          t.prototype.onEnable.call(this), this.node.on(O.ANCHOR_CHANGED, this._syncAnchorPoint, this), this.node.on(O.TRANSFORM_CHANGED, this.updateCulling, this), this.node.on(O.SIZE_CHANGED, this.updateCulling, this), this.node.parent.on(O.TRANSFORM_CHANGED, this.updateCulling, this), this.node.parent.on(O.SIZE_CHANGED, this.updateCulling, this), this.markForUpdateRenderData(), this.scheduleOnce(this.updateCulling.bind(this));
        }, r.onDisable = function () {
          var e, i;
          t.prototype.onDisable.call(this), null === (e = this.node.parent) || void 0 === e || e.off(O.SIZE_CHANGED, this.updateCulling, this), null === (i = this.node.parent) || void 0 === i || i.off(O.TRANSFORM_CHANGED, this.updateCulling, this), this.node.off(O.SIZE_CHANGED, this.updateCulling, this), this.node.off(O.TRANSFORM_CHANGED, this.updateCulling, this), this.node.off(O.ANCHOR_CHANGED, this._syncAnchorPoint, this);
        }, r._syncAnchorPoint = function () {
          var t = this.node,
              e = t._uiProps.uiTransformComp,
              i = t.getScale();
          this._leftDownToCenterX = e.width * e.anchorX * i.x, this._leftDownToCenterY = e.height * e.anchorY * i.y, this._cullingDirty = !0, this.markForUpdateRenderData();
        }, r.getLayerName = function () {
          return this._layerName;
        }, r.setLayerName = function (t) {
          this._layerName = t;
        }, r.getProperty = function (t) {
          return this._properties[t];
        }, r.getPositionAt = function (t, e) {
          var i;

          switch (void 0 !== e ? (i = Math.floor(t), e = Math.floor(e)) : (i = Math.floor(t.x), e = Math.floor(t.y)), this._layerOrientation) {
            case K.ORTHO:
              return this._positionForOrthoAt(i, e);

            case K.ISO:
              return this._positionForIsoAt(i, e);

            case K.HEX:
              return this._positionForHexAt(i, e);
          }

          return null;
        }, r.isInvalidPosition = function (t, e) {
          return t >= this._layerSize.width || e >= this._layerSize.height || t < 0 || e < 0;
        }, r._positionForIsoAt = function (t, e) {
          var i = 0,
              r = 0,
              s = Math.floor(t) + Math.floor(e) * this._layerSize.width,
              n = this.tiles[s];

          if (n) {
            var o = (n & q.FLIPPED_MASK) >>> 0,
                a = this.texGrids.get(o).tileset.tileOffset;
            i = a.x, r = a.y;
          }

          return new m(.5 * this._mapTileSize.width * (this._layerSize.height + t - e - 1) + i, .5 * this._mapTileSize.height * (this._layerSize.width - t + this._layerSize.height - e - 2) - r);
        }, r._positionForOrthoAt = function (t, e) {
          var i = 0,
              r = 0,
              s = Math.floor(t) + Math.floor(e) * this._layerSize.width,
              n = this.tiles[s];

          if (n) {
            var o = (n & q.FLIPPED_MASK) >>> 0,
                a = this.texGrids.get(o).tileset.tileOffset;
            i = a.x, r = a.y;
          }

          return new m(t * this._mapTileSize.width + i, (this._layerSize.height - e - 1) * this._mapTileSize.height - r);
        }, r._positionForHexAt = function (t, e) {
          var i,
              r = this._mapTileSize.width,
              s = this._mapTileSize.height,
              n = this._layerSize.height,
              o = Math.floor(t) + Math.floor(e) * this._layerSize.width,
              a = (this.tiles[o] & q.FLIPPED_MASK) >>> 0;

          i = this.texGrids.get(a) ? this.texGrids.get(a).tileset.tileOffset : {
            x: 0,
            y: 0
          };
          var h = this._staggerIndex === Q.STAGGERINDEX_ODD ? 1 : -1,
              l = 0,
              u = 0,
              g = 0,
              f = 0;

          switch (this._staggerAxis) {
            case J.STAGGERAXIS_Y:
              g = 0, e % 2 == 1 && (g = r / 2 * h), l = t * r + g + i.x, u = (n - e - 1) * (s - (s - this._hexSideLength) / 2) - i.y;
              break;

            case J.STAGGERAXIS_X:
              f = 0, t % 2 == 1 && (f = s / 2 * -h), l = t * (r - (r - this._hexSideLength) / 2) + i.x, u = (n - e - 1) * s + f - i.y;
          }

          return new m(l, u);
        }, r.setTilesGIDAt = function (t, e, i, r) {
          if (t && 0 !== t.length && !(r <= 0)) {
            i < 0 && (i = 0), e < 0 && (e = 0);

            for (var s = 0, n = e + r, o = i;; o++) {
              for (var a = e; a < n; a++) {
                if (s >= t.length) return;
                this._updateTileForGID(t[s], a, o), s++;
              }
            }
          }
        }, r.setTileGIDAt = function (t, e, r, s) {
          var n = (t & q.FLIPPED_MASK) >>> 0;
          if (e = Math.floor(e), r = Math.floor(r), this.isInvalidPosition(e, r)) throw new Error("cc.TiledLayer.setTileGIDAt(): invalid position");
          this.tiles && this._tilesets && 0 !== this._tilesets.length ? 0 !== n && n < this._tilesets[0].firstGid ? i(7239, t) : (s = s || 0, this._updateTileForGID((n | s) >>> 0, e, r)) : i(7238);
        }, r._updateTileForGID = function (t, e, i) {
          var r = 0 | e + i * this._layerSize.width;

          if (!(r >= this.tiles.length) && t !== this.tiles[r]) {
            var s = (t & q.FLIPPED_MASK) >>> 0;
            this.texGrids.get(s) ? (this.tiles[r] = t, this._updateVertex(e, i)) : this.tiles[r] = 0, this._cullingDirty = !0;
          }
        }, r.getTileGIDAt = function (t, e) {
          if (this.isInvalidPosition(t, e)) throw new Error("cc.TiledLayer.getTileGIDAt(): invalid position");
          if (!this.tiles) return i(7237), null;

          var r = Math.floor(t) + Math.floor(e) * this._layerSize.width;

          return (this.tiles[r] & q.FLIPPED_MASK) >>> 0;
        }, r.getTileFlagsAt = function (t, e) {
          if (this.isInvalidPosition(t, e)) throw new Error("TiledLayer.getTileFlagsAt: invalid position");
          if (!this.tiles) return i(7240), null;

          var r = Math.floor(t) + Math.floor(e) * this._layerSize.width;

          return (this.tiles[r] & q.FLIPPED_ALL) >>> 0;
        }, r.setCullingDirty = function (t) {
          this._cullingDirty = t;
        }, r.isCullingDirty = function () {
          return this._cullingDirty;
        }, r.updateViewPort = function (t, e, i, r) {
          if (this._viewPort.width !== i || this._viewPort.height !== r || this._viewPort.x !== t || this._viewPort.y !== e) {
            this._viewPort.x = t, this._viewPort.y = e, this._viewPort.width = i, this._viewPort.height = r;
            var s = 1;
            this._layerOrientation === K.ISO && (s = 2);
            var n = this._viewPort.x - this._offset.x + this._leftDownToCenterX,
                o = this._viewPort.y - this._offset.y + this._leftDownToCenterY,
                a = n - this._leftOffset,
                h = o - this._downOffset,
                l = n + i + this._rightOffset,
                u = o + r + this._topOffset,
                g = this._cullingRect.leftDown,
                f = this._cullingRect.rightTop;
            a < 0 && (a = 0), h < 0 && (h = 0), this._positionToRowCol(a, h, me), me.row -= s, me.col -= s, me.row = me.row > 0 ? me.row : 0, me.col = me.col > 0 ? me.col : 0, me.row === g.row && me.col === g.col || (g.row = me.row, g.col = me.col, this._cullingDirty = !0), l < 0 || u < 0 ? (me.row = -1, me.col = -1) : (this._positionToRowCol(l, u, me), me.row++, me.col++), me.row > this._rightTop.row && (me.row = this._rightTop.row), me.col > this._rightTop.col && (me.col = this._rightTop.col), me.row === f.row && me.col === f.col || (f.row = me.row, f.col = me.col, this._cullingDirty = !0, this.markForUpdateRenderData());
          }
        }, r._positionToRowCol = function (t, e, i) {
          var r = this._mapTileSize.width,
              s = this._mapTileSize.height,
              n = .5 * r,
              o = .5 * s,
              a = 0,
              h = 0,
              l = 0,
              u = 0,
              g = this._staggerAxis;

          switch (this._layerOrientation) {
            case K.ORTHO:
              h = Math.floor(t / r), a = Math.floor(e / s);
              break;

            case K.ISO:
              h = Math.floor(t / n), a = Math.floor(e / o);
              break;

            case K.HEX:
              g === J.STAGGERAXIS_Y ? (l = (a = Math.floor(e / (s - this._diffY1))) % 2 == 1 ? n * this._odd_even : 0, h = Math.floor((t - l) / r)) : (u = (h = Math.floor(t / (r - this._diffX1))) % 2 == 1 ? o * -this._odd_even : 0, a = Math.floor((e - u) / s));
          }

          return i.row = a, i.col = h, i;
        }, r.updateCulling = function () {
          if (this._enableCulling) {
            this.node.updateWorldTransform(), D.invert(de, this.node.getWorldMatrix());
            var t = X.root.batcher2D.getFirstRenderCamera(this.node);
            t && (pe.x = 0, pe.y = 0, pe.z = 0, ce.x = t.width, ce.y = t.height, ce.z = 0, t.screenToWorld(pe, pe), t.screenToWorld(ce, ce), N.transformMat4(pe, pe, de), N.transformMat4(ce, ce, de), this.updateViewPort(pe.x, pe.y, ce.x - pe.x, ce.y - pe.y));
          }
        }, r.getLayerOrientation = function () {
          return this._layerOrientation;
        }, r.getProperties = function () {
          return this._properties;
        }, r._updateVertex = function (t, e) {
          var i = q.FLIPPED_MASK,
              r = this.vertices,
              s = this._layerOrientation,
              n = this.tiles;

          if (n) {
            var o,
                a,
                h,
                l,
                u = this._rightTop,
                g = this._mapTileSize.width,
                f = this._mapTileSize.height,
                d = .5 * g,
                _ = .5 * f,
                p = this._layerSize.height,
                c = this._layerSize.width,
                m = this.texGrids,
                y = 0,
                v = 0;

            s === K.HEX && (o = this._staggerAxis, a = this._diffX1, h = this._diffY1, l = this._odd_even);
            var A,
                w,
                b,
                S = 0,
                x = 0,
                T = 0,
                I = 0,
                C = e * c + t;
            A = (n[C] & i) >>> 0;
            var D = m.get(A);

            if (D) {
              switch (this._animations.get(A) && (this._hasAniGrid = this._hasAniGrid || !0), s) {
                case K.ORTHO:
                  y = (S = t) * g, v = (x = p - e - 1) * f;
                  break;

                case K.ISO:
                  y = d * (S = p + t - e - 1), v = _ * (x = p + c - t - e - 2);
                  break;

                case K.HEX:
                  y = t * (g - a) + (o === J.STAGGERAXIS_Y && e % 2 == 1 ? d * l : 0), v = (p - e - 1) * (f - h) + (o === J.STAGGERAXIS_X && t % 2 == 1 ? _ * -l : 0), S = t, x = p - e - 1;
              }

              var N = r[x] = r[x] || {
                minCol: 0,
                maxCol: 0
              },
                  O = N[S] = N[S] || {};
              N.minCol > S && (N.minCol = S), N.maxCol < S && (N.maxCol = S), u.row < x && (u.row = x, s === K.ISO && (u.row += 1)), u.col < S && (u.col = S, s === K.ISO && (u.col += 1));
              var P = D.tileset.tileOffset;
              y += this._offset.x + P.x + D.offsetX, v += this._offset.y - P.y - D.offsetY, T = (T = -P.y + D.tileset._tileSize.height - f) < 0 ? 0 : T, w = P.y < 0 ? 0 : P.y, b = -P.x < 0 ? 0 : -P.x, I = (I = P.x + D.tileset._tileSize.width - g) < 0 ? 0 : I, this._rightOffset < b && (this._rightOffset = b), this._leftOffset < I && (this._leftOffset = I), this._topOffset < w && (this._topOffset = w), this._downOffset < T && (this._downOffset = T), O.left = y, O.bottom = v, O.index = C, this._cullingDirty = !0;
            }
          }
        }, r._updateVertices = function () {
          if (this.vertices.length = 0, this.tiles) {
            var t = this._rightTop;
            t.row = -1, t.col = -1;
            var e = this._layerSize.height,
                i = this._layerSize.width;
            this._topOffset = 0, this._downOffset = 0, this._leftOffset = 0, this._rightOffset = 0, this._hasAniGrid = !1;

            for (var r = 0; r < e; ++r) {
              for (var s = 0; s < i; ++s) {
                this._updateVertex(s, r);
              }
            }

            this._verticesDirty = !1;
          }
        }, r.getTiledTileAt = function (t, e, r) {
          if (this.isInvalidPosition(t, e)) throw new Error("TiledLayer.getTiledTileAt: invalid position");
          if (!this.tiles) return i(7236), null;

          var s = Math.floor(t) + Math.floor(e) * this._layerSize.width,
              n = this.tiledTiles[s];

          if (!n && r) {
            var o = new P();
            return (n = o.addComponent(It))._x = t, n._y = e, n._layer = this, n.updateInfo(), o.parent = this.node, n;
          }

          return n;
        }, r.setTiledTileAt = function (t, e, r) {
          if (this.isInvalidPosition(t, e)) throw new Error("TiledLayer.setTiledTileAt: invalid position");
          if (!this.tiles) return i(7236), null;

          var s = Math.floor(t) + Math.floor(e) * this._layerSize.width;

          return this.tiledTiles[s] = r, this._cullingDirty = !0, this._hasTiledNodeGrid = !!r || this.tiledTiles.some(function (t) {
            return !!t;
          }), r;
        }, r.getTexture = function (t) {
          return t = t || 0, this._textures && t >= 0 && this._textures.length > t ? this._textures[t] : null;
        }, r.getTextures = function () {
          return this._textures;
        }, r.setTexture = function (t) {
          this.setTextures([t]);
        }, r.setTextures = function (t) {
          this._textures = t, this.markForUpdateRenderData();
        }, r.getLayerSize = function () {
          return this._layerSize;
        }, r.getMapTileSize = function () {
          return this._mapTileSize;
        }, r.getTileSet = function (t) {
          return t = t || 0, this._tilesets && t >= 0 && this._tilesets.length > t ? this._tilesets[t] : null;
        }, r.getTileSets = function () {
          return this._tilesets;
        }, r.setTileSet = function (t) {
          this.setTileSets([t]);
        }, r.setTileSets = function (t) {
          this._tilesets = t;
          var e = this._textures = [],
              i = this.texGrids;
          i.clear();

          for (var r = 0; r < t.length; r++) {
            var s = t[r];
            s && (e[r] = s.sourceImage);
          }

          for (var n = 0, o = t.length; n < o; ++n) {
            var a = t[n];
            a && Ct(a, i, a.sourceImage);
          }

          this._prepareToRender();
        }, r.init = function (t, e, i, r, s) {
          this._cullingDirty = !0, this._layerInfo = t, this._mapInfo = e;
          var n = t.layerSize;
          this._layerName = t.name, this.tiles = t.tiles, this._properties = t.properties, this._layerSize = n, this._minGID = t.minGID, this._maxGID = t.maxGID, this._opacity = t.opacity, t.tintColor && (this._tintColor = t.tintColor), this.renderOrder = e.renderOrder, this._staggerAxis = e.getStaggerAxis(), this._staggerIndex = e.getStaggerIndex(), this._hexSideLength = e.getHexSideLength(), this._animations = e.getTileAnimations(), this._tilesets = i, this._textures = r, this.texGrids = s, this._layerOrientation = e.orientation, this._mapTileSize = e.getTileSize();
          var o = this._mapTileSize.width,
              a = this._mapTileSize.height,
              h = this._layerSize.width,
              l = this._layerSize.height;

          if (this._layerOrientation === K.HEX) {
            var u = 0,
                g = 0;
            this._odd_even = this._staggerIndex === Q.STAGGERINDEX_ODD ? 1 : -1, this._staggerAxis === J.STAGGERAXIS_X ? (this._diffX1 = (o - this._hexSideLength) / 2, this._diffY1 = 0, g = a * (l + .5), u = (o + this._hexSideLength) * Math.floor(h / 2) + o * (h % 2)) : (this._diffX1 = 0, this._diffY1 = (a - this._hexSideLength) / 2, u = o * (h + .5), g = (a + this._hexSideLength) * Math.floor(l / 2) + a * (l % 2)), this.node._uiProps.uiTransformComp.setContentSize(u, g);
          } else if (this._layerOrientation === K.ISO) {
            var f = h + l;

            this.node._uiProps.uiTransformComp.setContentSize(.5 * o * f, .5 * a * f);
          } else this.node._uiProps.uiTransformComp.setContentSize(h * o, l * a);

          this._offset = new m(t.offset.x, -t.offset.y), this._useAutomaticVertexZ = !1, this._vertexZvalue = 0, this._syncAnchorPoint(), this._prepareToRender();
        }, r._prepareToRender = function () {
          this._updateVertices(), this._updateAllUserNode();
        }, r.requestMeshRenderData = function () {
          this._meshRenderDataArray || (this._meshRenderDataArray = []);

          for (var t = this._meshRenderDataArray; t.length > 0 && t[t.length - 1].subNodes && 0 === t[t.length - 1].subNodes.length;) {
            t.pop();
          }

          if (t.length > 0) {
            var e = t[t.length - 1];
            if (e.renderData && 0 === e.renderData.vertexCount) return e;
          }

          var i = k.add(),
              r = {
            renderData: i,
            texture: null
          };
          return i.material = this.getRenderMaterial(0), this._meshRenderDataArray.push(r), r;
        }, r.requestSubNodesData = function () {
          this._meshRenderDataArray || (this._meshRenderDataArray = []);
          var t = this._meshRenderDataArray;
          if (t.length > 0 && t[t.length - 1].subNodes && 0 === t[t.length - 1].subNodes.length) return t[t.length - 1];
          var e = {
            subNodes: []
          };
          return this._meshRenderDataArray.push(e), e;
        }, r.destroyRenderData = function () {
          this._meshRenderDataArray && (this._meshRenderDataArray.forEach(function (t) {
            var e = t.renderData;
            e && k.remove(e);
          }), this._meshRenderDataArray.length = 0), t.prototype.destroyRenderData.call(this);
        }, r._flushAssembler = function () {
          var t = e.Assembler.getAssembler(this);
          this._assembler !== t && (this._assembler = t), this._meshRenderDataArray || this._assembler && this._assembler.createData && (this._assembler.createData(this), this.markForUpdateRenderData(), this._updateColor());
        }, r._render = function (t) {
          if (this._meshRenderDataArray) {
            for (var e = 0; e < this._meshRenderDataArray.length; e++) {
              this._meshRenderDataArrayIdx = e;
              var i = this._meshRenderDataArray[e];
              i.subNodes ? i.subNodes.forEach(function (e) {
                e && t.walk(e.node);
              }) : i.texture && t.commitComp(this, i.renderData, i.texture, this._assembler, null);
            }

            this.node._static = !0;
          }
        }, s(e, [{
          key: "cullingRect",
          get: function get() {
            return this._cullingRect;
          }
        }, {
          key: "rightTop",
          get: function get() {
            return this._rightTop;
          }
        }, {
          key: "layerSize",
          get: function get() {
            return this._layerSize;
          }
        }, {
          key: "meshRenderDataArray",
          get: function get() {
            return this._meshRenderDataArray;
          }
        }, {
          key: "leftDownToCenterX",
          get: function get() {
            return this._leftDownToCenterX;
          }
        }, {
          key: "leftDownToCenterY",
          get: function get() {
            return this._leftDownToCenterY;
          }
        }, {
          key: "enableCulling",
          get: function get() {
            return this._enableCulling;
          },
          set: function set(t) {
            this._enableCulling !== t && (this._enableCulling = t, this._cullingDirty = !0, this.markForUpdateRenderData());
          }
        }]), e;
      }(Y)) || xt), Ae = t("TiledObjectGroup", (Dt = w("cc.TiledObjectGroup"), Nt = x(), Ot = I(B), Pt = b(g), Dt(Et = Nt(Et = Ot((zt = function (t) {
        function e() {
          for (var e, i = arguments.length, r = new Array(i), s = 0; s < i; s++) {
            r[s] = arguments[s];
          }

          return (e = t.call.apply(t, [this].concat(r)) || this)._premultiplyAlpha = !1, e._groupName = void 0, e._positionOffset = void 0, e._mapInfo = void 0, e._properties = void 0, e._offset = void 0, e._opacity = void 0, e._tintColor = null, e._animations = void 0, e._hasAniObj = void 0, e._texGrids = void 0, e.aniObjects = void 0, e._objects = [], e;
        }

        o(e, t);
        var i = e.prototype;
        return i.getPositionOffset = function () {
          return this._positionOffset;
        }, i.getProperties = function () {
          return this._properties;
        }, i.getGroupName = function () {
          return this._groupName;
        }, i.getProperty = function (t) {
          return this._properties[t.toString()];
        }, i.getObject = function (t) {
          for (var e = 0, i = this._objects.length; e < i; e++) {
            var r = this._objects[e];
            if (r && r.name === t) return r;
          }

          return null;
        }, i.getObjects = function () {
          return this._objects;
        }, i._init = function (t, e, i) {
          var r = q.FLIPPED_MASK,
              s = q.HORIZONTAL,
              n = q.VERTICAL;
          this._groupName = t.name, this._positionOffset = t.offset, this._mapInfo = e, this._properties = t.getProperties(), this._offset = new m(t.offset.x, -t.offset.y), this._opacity = t.opacity, t.tintColor && (this._tintColor = t.tintColor), this._texGrids = i, this._animations = e.getTileAnimations(), this.aniObjects = [], this._hasAniObj = !1;
          var o = e.mapSize,
              a = e.tileSize,
              h = 0,
              l = 0,
              u = new y(),
              g = K.ISO === e.orientation;
          if (e.orientation === K.HEX) e.getStaggerAxis() === J.STAGGERAXIS_X ? (l = a.height * (o.height + .5), h = (a.width + e.getHexSideLength()) * Math.floor(o.width / 2) + a.width * (o.width % 2)) : (h = a.width * (o.width + .5), l = (a.height + e.getHexSideLength()) * Math.floor(o.height / 2) + a.height * (o.height % 2));else if (g) {
            var _ = o.width + o.height;

            h = .5 * a.width * _, l = .5 * a.height * _;
          } else h = o.width * a.width, l = o.height * a.height;
          var p = this.node._uiProps.uiTransformComp;
          p.setContentSize(h, l);

          for (var c = h * p.anchorX, v = l * (1 - p.anchorY), A = t.objects, w = {}, b = 0, S = A.length; b < S; b++) {
            var x = A[b],
                T = x.type;
            x.offset = new m(x.x, x.y);
            var I = x.points || x.polylinePoints;
            if (I) for (var C = 0; C < I.length; C++) {
              I[C].y *= -1;
            }

            if (g) {
              var D = x.x / a.height,
                  N = x.y / a.height;
              x.x = .5 * a.width * (o.height + D - N), x.y = .5 * a.height * (o.width + o.height - D - N);
            } else x.y = l - x.y;

            if (T === tt.TEXT) {
              var O = "text" + x.id;
              w[O] = !0;
              var E = this.node.getChildByName(O);
              E || (E = new P()), E.setRotationFromEuler(0, 0, -x.rotation), E.setPosition(x.x - c, x.y - v), E.name = O, E.parent = this.node, E.setSiblingIndex(b);
              var G = E.getComponent(H);
              G || (G = E.addComponent(H));
              var z = E._uiProps.uiTransformComp;
              E.active = x.visible, z.anchorX = 0, z.anchorY = 1, this._tintColor ? (u.set(this._tintColor), u.a *= this._opacity / 255, G.color.set(u)) : G.color.a *= this._opacity / 255, G.overflow = H.Overflow.SHRINK, G.lineHeight = x.height, G.string = x.text, G.horizontalAlign = x.halign, G.verticalAlign = x.valign, G.fontSize = x.pixelsize, z.setContentSize(x.width, x.height);
            } else if (T === tt.IMAGE) {
              var F = x.gid,
                  L = (F & r) >>> 0,
                  R = i.get(L);
              if (!R) continue;
              var M = R.tileset,
                  X = "img" + x.id;
              w[X] = !0;
              var B = this.node.getChildByName(X);
              x.width = x.width || R.width, x.height = x.height || R.height, B && B._objFlags & f.Flags.HideInHierarchy && (B.removeFromParent(), B.hideFlags |= f.Flags.DontSave, B.destroy(), B = null), B || (B = new P()), this._animations.get(L) && (this.aniObjects.push({
                object: x,
                imgNode: B,
                gridGID: L
              }), this._hasAniObj = !0);
              var k = M.tileOffset.x,
                  Y = M.tileOffset.y;
              B.active = x.visible, B.setRotationFromEuler(0, 0, -x.rotation), B.setPosition(x.x - c, x.y - v), B.name = X, B.parent = this.node, B.setSiblingIndex(b);
              var V = B.getComponent(j);
              V || (V = B.addComponent(j));
              var Z = B._uiProps.uiTransformComp;
              g ? (Z.anchorX = .5 + k / x.width, Z.anchorY = Y / x.height) : (Z.anchorX = k / x.width, Z.anchorY = Y / x.height), this._tintColor ? (u.set(this._tintColor), u.a *= this._opacity / 255, V.color.set(u)) : V.color.a *= this._opacity / 255, V.sizeMode = j.SizeMode.CUSTOM, V._srcBlendFactor = this._premultiplyAlpha ? d.ONE : d.SRC_ALPHA, V._dstBlendFactor = d.ONE_MINUS_SRC_ALPHA, V._updateBlendFunc();
              var W = R.spriteFrame;
              W = W ? W.clone() : new U(), (F & s) >>> 0 && (W.flipUVX = !W.flipUVX), (F & n) >>> 0 && (W.flipUVY = !W.flipUVY), W.rotated = R._rotated, W.rect = R._rect, V.spriteFrame = W, Z.setContentSize(x.width, x.height), V.markForUpdateRenderData();
            }
          }

          this._objects = A;

          for (var Q = this.node.children, $ = /^(?:img|text)\d+$/, et = 0, it = Q.length; et < it; et++) {
            var rt = Q[et],
                st = rt.name;
            $.test(st) && !w[st] && rt.destroy();
          }
        }, i.update = function () {
          if (this._hasAniObj) for (var t = this.aniObjects, e = this._texGrids, i = K.ISO === this._mapInfo.orientation, r = 0, s = t.length; r < s; r++) {
            var n = t[r],
                o = n.gridGID,
                a = e.get(o);

            if (a) {
              var h = a.tileset,
                  l = n.object,
                  u = n.imgNode,
                  g = h.tileOffset.x,
                  f = h.tileOffset.y,
                  d = u._uiProps.uiTransformComp;
              i ? (d.anchorX = .5 + g / l.width, d.anchorY = f / l.height) : (d.anchorX = g / l.width, d.anchorY = f / l.height);

              var _ = u.getComponent(j),
                  p = _.spriteFrame;

              p.rotated = a._rotated, p.rect = a._rect, _.spriteFrame = p, _.markForUpdateRenderData();
            }
          }
        }, s(e, [{
          key: "premultiplyAlpha",
          get: function get() {
            return this._premultiplyAlpha;
          },
          set: function set(t) {
            this._premultiplyAlpha = t;
          }
        }, {
          key: "offset",
          get: function get() {
            return this._offset;
          }
        }]), e;
      }(C), h((Gt = zt).prototype, "premultiplyAlpha", [Pt], Object.getOwnPropertyDescriptor(Gt.prototype, "premultiplyAlpha"), Gt.prototype), Et = Gt)) || Et) || Et) || Et)), we = t("TiledMapAsset", (Ft = w("cc.TiledMapAsset"), Lt = b([E]), Rt = b([_]), Mt = b([U]), Xt = b([U]), Ut = b([_]), Ht = b([_]), jt = b([v]), Ft(($t = function (t) {
        function e() {
          for (var e, i = arguments.length, r = new Array(i), s = 0; s < i; s++) {
            r[s] = arguments[s];
          }

          return e = t.call.apply(t, [this].concat(r)) || this, l(e, "tmxXmlStr", Yt, u(e)), l(e, "tsxFiles", Vt, u(e)), l(e, "tsxFileNames", Zt, u(e)), l(e, "spriteFrames", Kt, u(e)), l(e, "imageLayerSpriteFrame", Wt, u(e)), l(e, "imageLayerSpriteFrameNames", qt, u(e)), l(e, "spriteFrameNames", Jt, u(e)), l(e, "spriteFrameSizes", Qt, u(e)), e;
        }

        return o(e, t), e;
      }(G), Yt = h((kt = $t).prototype, "tmxXmlStr", [z], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return "";
        }
      }), Vt = h(kt.prototype, "tsxFiles", [z, Lt], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return [];
        }
      }), Zt = h(kt.prototype, "tsxFileNames", [z, Rt], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return [];
        }
      }), Kt = h(kt.prototype, "spriteFrames", [z, Mt], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return [];
        }
      }), Wt = h(kt.prototype, "imageLayerSpriteFrame", [z, Xt], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return [];
        }
      }), qt = h(kt.prototype, "imageLayerSpriteFrameNames", [z, Ut], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return [];
        }
      }), Jt = h(kt.prototype, "spriteFrameNames", [z, Ht], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return [];
        }
      }), Qt = h(kt.prototype, "spriteFrameSizes", [z, jt], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return [];
        }
      }), Bt = kt)) || Bt)), be = (t("TiledMap", (te = w("cc.TiledMap"), ee = x(), ie = T(), re = I(B), se = b(we), ne = R(), te(oe = ee(oe = ie(oe = re(oe = S((fe = ge = function (t) {
        function e() {
          for (var e, i = arguments.length, r = new Array(i), s = 0; s < i; s++) {
            r[s] = arguments[s];
          }

          return (e = t.call.apply(t, [this].concat(r)) || this)._texGrids = new Map(), e._textures = [], e._tilesets = [], e._animations = new Map(), e._imageLayers = [], e._layers = [], e._groups = [], e._images = [], e._properties = {}, e._tileProperties = new Map(), e._mapInfo = null, e._mapSize = new v(0, 0), e._tileSize = new v(0, 0), e._mapOrientation = K.ORTHO, e._isApplied = !1, l(e, "_tmxFile", he, u(e)), l(e, "_enableCulling", le, u(e)), l(e, "cleanupImageCache", ue, u(e)), e;
        }

        o(e, t);
        var r = e.prototype;
        return r.getMapSize = function () {
          return this._mapSize;
        }, r.getTileSize = function () {
          return this._tileSize;
        }, r.getMapOrientation = function () {
          return this._mapOrientation;
        }, r.getObjectGroups = function () {
          return this._groups;
        }, r.getObjectGroup = function (t) {
          for (var e = this._groups, i = 0, r = e.length; i < r; i++) {
            var s = e[i];
            if (s && s.getGroupName() === t) return s;
          }

          return null;
        }, r.getProperties = function () {
          return this._properties;
        }, r.getLayers = function () {
          return this._layers;
        }, r.getLayer = function (t) {
          for (var e = this._layers, i = 0, r = e.length; i < r; i++) {
            var s = e[i];
            if (s && s.getLayerName() === t) return s;
          }

          return null;
        }, r._changeLayer = function (t, e) {
          for (var i = this._layers, r = 0, s = i.length; r < s; r++) {
            var n = i[r];
            if (n && n.getLayerName() === t) return void (i[r] = e);
          }
        }, r.getProperty = function (t) {
          return this._properties[t.toString()];
        }, r.getPropertiesForGID = function (t) {
          return this._tileProperties.get(t);
        }, r.__preload = function () {
          this._tmxFile && !1 === this._isApplied && (this._applyFile(), this._isApplied = !0);
        }, r.onEnable = function () {
          this.node.on(O.ANCHOR_CHANGED, this._syncAnchorPoint, this);
        }, r.onDisable = function () {
          this.node.off(O.ANCHOR_CHANGED, this._syncAnchorPoint, this);
        }, r._applyFile = function () {
          var t = [],
              e = {},
              r = this._tmxFile;

          if (r) {
            for (var s = r.spriteFrameNames, n = r.spriteFrameSizes, o = r.spriteFrames, a = {}, h = {}, l = 0; l < s.length; ++l) {
              var u = s[l];
              h[u] = n[l], t[l] = o[l];
              var g = t[l];
              g && (e[g.name] = g, a[u] = g);
            }

            var f = {},
                d = r.imageLayerSpriteFrame;
            s = r.imageLayerSpriteFrameNames;

            for (var _ = 0; _ < d.length; ++_) {
              f[s[_]] = d[_];
            }

            for (var p = r.tsxFileNames, c = r.tsxFiles, m = {}, y = 0; y < p.length; ++y) {
              p[y].length > 0 && (m[p[y]] = c[y].text);
            }

            var v = new Tt(r.tmxXmlStr, m, a, h, f),
                A = v.getTilesets();
            A && 0 !== A.length || i(7241), this._buildWithMapInfo(v);
          } else this._releaseMapInfo();
        }, r._releaseMapInfo = function () {
          for (var t = this._layers, e = 0, i = t.length; e < i; e++) {
            var r, s;
            null === (r = t[e].node.parent) || void 0 === r || r.off(O.SIZE_CHANGED, t[e].updateCulling, t[e]), null === (s = t[e].node.parent) || void 0 === s || s.off(O.TRANSFORM_CHANGED, t[e].updateCulling, t[e]), t[e].node.removeFromParent(), t[e].node.destroy();
          }

          t.length = 0;

          for (var n = this._groups, o = 0, a = n.length; o < a; o++) {
            n[o].node.removeFromParent(), n[o].node.destroy();
          }

          n.length = 0;

          for (var h = this._images, l = 0, u = h.length; l < u; l++) {
            h[l].removeFromParent(), h[l].destroy();
          }

          h.length = 0;
        }, r._syncAnchorPoint = function () {
          var t,
              e,
              i = this.node._uiProps.uiTransformComp.anchorPoint,
              r = this.node._uiProps.uiTransformComp.width * i.x,
              s = this.node._uiProps.uiTransformComp.height * (1 - i.y);

          for (t = 0, e = this._layers.length; t < e; t++) {
            this._layers[t].node._uiProps.uiTransformComp.setAnchorPoint(i);
          }

          for (t = 0, e = this._groups.length; t < e; t++) {
            var n = this._groups[t],
                o = n.node._uiProps.uiTransformComp;
            o.anchorX = .5, o.anchorY = .5;
            var a = n.offset.x - r + o.width * o.anchorX,
                h = n.offset.y + s - o.height * o.anchorY;
            n.node.setPosition(a, h);
          }

          for (t = 0, e = this._images.length; t < e; t++) {
            var l = this._images[t]._uiProps.uiTransformComp;
            l.anchorX = .5, l.anchorY = .5;
            var u = this._images[t]._offset.x - r + l.width * l.anchorX,
                g = this._images[t]._offset.y + s - l.height * l.anchorY;

            this._images[t].setPosition(u, g);
          }
        }, r._fillAniGrids = function (t, e) {
          for (var i, r = p(e.keys()); !(i = r()).done;) {
            var s = i.value,
                n = e.get(s);
            if (n) for (var o = n.frames, a = 0; a < o.length; a++) {
              var h = o[a];
              h.grid = t.get(h.tileid);
            }
          }
        }, r._buildLayerAndGroup = function () {
          var t = this._tilesets,
              e = this._texGrids,
              i = this._animations;
          e.clear();

          for (var r = 0, s = t.length; r < s; ++r) {
            var n = t[r];
            n && (n.sourceImage ? Ct(n, e, n.sourceImage) : console.warn("Can't find the spriteFrame of tilesets " + r));
          }

          this._fillAniGrids(e, i);

          for (var o = this._layers, a = this._groups, h = this._images, l = {}, u = 0, g = o.length; u < g; u++) {
            l[o[u].node.name] = !0;
          }

          for (var f = 0, d = a.length; f < d; f++) {
            l[a[f].node.name] = !0;
          }

          for (var _ = 0, p = h.length; _ < p; _++) {
            l[h[_].name] = !0;
          }

          o = this._layers = [], a = this._groups = [], h = this._images = [];
          var c = this._mapInfo,
              y = this.node,
              v = c.getAllChildren(),
              A = this._textures,
              w = 0,
              b = 0;
          if (v && v.length > 0) for (var S = 0, x = v.length; S < x; S++) {
            var T = v[S],
                I = T.name,
                C = this.node.getChildByName(I);

            if (l[I] = !1, C || ((C = new P()).name = I, C.layer = y.layer, y.addChild(C)), C.setSiblingIndex(S), C.active = T.visible, T instanceof rt) {
              var D = C.getComponent(ve);
              D || (D = C.addComponent(ve)), D.init(T, c, t, A, e), D.enableCulling = this._enableCulling, T.ownTiles = !1, o.push(D);
            } else if (T instanceof it) {
              var N = C.getComponent(Ae);
              N || (N = C.addComponent(Ae)), N._init(T, c, e), a.push(N);
            } else if (T instanceof st) {
              var O = T.sourceImage;
              C.layerInfo = T, C._offset = new m(T.offset.x, -T.offset.y);
              var E = C.getComponent(j);
              E || (E = C.addComponent(j)), E.color.a *= T.opacity, E.spriteFrame = O;
              var G = O.width,
                  z = O.height;
              O.original && (G = O.originalSize.width, z = O.originalSize.height), C._uiProps.uiTransformComp.setContentSize(G, z), h.push(C);
            }

            w = Math.max(w, C._uiProps.uiTransformComp.width), b = Math.max(b, C._uiProps.uiTransformComp.height);
          }

          for (var F = y.children, L = 0, R = F.length; L < R; L++) {
            var M = F[L];
            l[M.name] && M.destroy();
          }

          this.node._uiProps.uiTransformComp.setContentSize(w, b), this._syncAnchorPoint();
        }, r._buildWithMapInfo = function (t) {
          var e = this;
          this._mapInfo = t, this._mapSize = t.getMapSize(), this._tileSize = t.getTileSize(), this._mapOrientation = t.orientation, this._properties = t.properties, this._tileProperties = t.getTileProperties(), this._imageLayers = t.getImageLayers(), this._animations = t.getTileAnimations(), this._tilesets = t.getTilesets();
          var i = this._tilesets;
          this._textures.length = 0;

          for (var r = [], s = 0, n = i.length; s < n; ++s) {
            var o = i[s];
            o && o.sourceImage && (this._textures[s] = o.sourceImage, r.push(o.sourceImage));
          }

          for (var a = 0; a < this._imageLayers.length; a++) {
            var h = this._imageLayers[a];
            h && h.sourceImage && r.push(h.sourceImage);
          }

          this._buildLayerAndGroup(), this.cleanupImageCache && this._textures.forEach(function (t) {
            e.doCleanupImageCache(t);
          });
        }, r.doCleanupImageCache = function (t) {
          t._image instanceof HTMLImageElement ? t._image.src = "" : F.hasFeature(F.Feature.IMAGE_BITMAP) && t._image instanceof ImageBitmap && t._image.close && t._image.close(), t._image = null;
        }, r.lateUpdate = function (t) {
          for (var e, i = this._animations, r = this._texGrids, s = p(i.keys()); !(e = s()).done;) {
            var n = e.value,
                o = i.get(n),
                a = o.frames,
                h = a[o.frameIdx];
            o.dt += t, h.duration < o.dt && (o.dt = 0, o.frameIdx++, o.frameIdx >= a.length && (o.frameIdx = 0), h = a[o.frameIdx]), r.set(n, h.grid);
          }

          for (var l = this.getLayers(), u = 0, g = l.length; u < g; u++) {
            var f = l[u];
            (f.hasAnimation() || f.node.hasChangedFlags) && f.markForUpdateRenderData();
          }
        }, s(e, [{
          key: "tmxAsset",
          get: function get() {
            return this._tmxFile;
          },
          set: function set(t) {
            (this._tmxFile !== t || c) && (this._tmxFile = t, this._applyFile(), this._isApplied = !0);
          }
        }, {
          key: "enableCulling",
          get: function get() {
            return this._enableCulling;
          },
          set: function set(t) {
            this._enableCulling = t;

            for (var e = this._layers, i = 0; i < e.length; ++i) {
              e[i].enableCulling = t;
            }
          }
        }]), e;
      }(C), ge.Orientation = K, ge.Property = W, ge.TileFlag = q, ge.StaggerAxis = J, ge.StaggerIndex = Q, ge.TMXObjectType = tt, ge.RenderOrder = $, he = h((ae = fe).prototype, "_tmxFile", [z], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return null;
        }
      }), h(ae.prototype, "tmxAsset", [se, ne], Object.getOwnPropertyDescriptor(ae.prototype, "tmxAsset"), ae.prototype), le = h(ae.prototype, "_enableCulling", [z], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !0;
        }
      }), h(ae.prototype, "enableCulling", [L], Object.getOwnPropertyDescriptor(ae.prototype, "enableCulling"), ae.prototype), ue = h(ae.prototype, "cleanupImageCache", [z], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !0;
        }
      }), oe = ae)) || oe) || oe) || oe) || oe) || oe)), Math.ceil(10922.5)), Se = [], xe = 0; xe < 4; xe++) {
        Se.push(new N());
      }

      var Te,
          Ie,
          Ce = new D(),
          De = new N(),
          Ne = {
        row: 0,
        col: 0
      },
          Oe = {
        x: 0,
        y: 0
      },
          Pe = {
        x: 0,
        y: 0
      },
          Ee = {
        x: 0,
        y: 0
      },
          Ge = {
        x: 0,
        y: 0
      },
          ze = 0,
          Fe = 0,
          Le = 0,
          Re = 0,
          Me = {
        createData: function createData(t) {
          var e = t.requestMeshRenderData();
          return t.rightTop.col * t.rightTop.row * 4 > 65535 && console.error("Vertex count exceeds 65535"), e;
        },
        updateRenderData: function updateRenderData(t) {
          t.updateCulling();
          var e = t.requestMeshRenderData();

          if (Le = t.leftDownToCenterX, Re = t.leftDownToCenterY, Te = e, t.colorChanged || t.isCullingDirty() || t.isUserNodeDirty() || t.hasAnimation() || t.hasTiledNode() || t.node.hasChangedFlags) {
            var i, r;

            if (t.colorChanged = !1, t.destroyRenderData(), t.enableCulling) {
              var s = t.cullingRect;
              i = s.leftDown, r = s.rightTop;
            } else i = Ne, r = t.rightTop;

            switch (t.renderOrder) {
              case $.RightDown:
                He(i, r, -1, 1, t);
                break;

              case $.LeftDown:
                He(i, r, -1, -1, t);
                break;

              case $.RightUp:
                He(i, r, 1, 1, t);
                break;

              case $.LeftUp:
              default:
                He(i, r, 1, -1, t);
            }

            t.setCullingDirty(!1), t.setUserNodeDirty(!1);
          }

          Te = null;
        },
        updateColor: function updateColor(t) {
          var e = t.color,
              i = new Float32Array(4);
          i[0] = e.r / 255, i[1] = e.g / 255, i[2] = e.b / 255, i[3] = e.a / 255;
          var r = t.meshRenderDataArray;
          if (r) for (var s, n = p(r); !(s = n()).done;) {
            var o = s.value;
            if (o.renderData) for (var a = o.renderData, h = a.vData, l = a.vertexStart, u = a.vertexCount; l < u; l++) {
              h.set(i, 9 * l + 5);
            }
          }
        },
        fillBuffers: function fillBuffers(t) {
          if (t && t.meshRenderDataArray) for (var e = t.meshRenderDataArray[t._meshRenderDataArrayIdx].renderData, i = e.iData, r = 0, s = 0, n = e.vertexCount / 4, o = 0; o < n; o += 1) {
            i[r] = s, i[r + 1] = s + 1, i[r + 2] = s + 2, i[r + 3] = s + 2, i[r + 4] = s + 1, i[r + 5] = s + 3, r += 6, s += 4;
          }
        }
      };

      function Xe(t, e) {
        var i;
        t._rotated ? (Oe.x = t.r, Oe.y = t.t, Pe.x = t.l, Pe.y = t.t, Ee.x = t.r, Ee.y = t.b, Ge.x = t.l, Ge.y = t.b) : (Oe.x = t.l, Oe.y = t.t, Pe.x = t.l, Pe.y = t.b, Ee.x = t.r, Ee.y = t.t, Ge.x = t.r, Ge.y = t.b), (e & q.DIAGONAL) >>> 0 && (i = Pe, Pe = Ee, Ee = i), (e & q.HORIZONTAL) >>> 0 && (i = Oe, Oe = Ee, Ee = i, i = Pe, Pe = Ge, Ge = i), (e & q.VERTICAL) >>> 0 && (i = Oe, Oe = Pe, Pe = i, i = Ee, Ee = Ge, Ge = i);
      }

      function Ue(t, e, i) {
        t || (t = e.texture), Te.texture || (Te.texture = t), (Te = i.requestMeshRenderData()).texture = e.texture;
      }

      function He(t, e, i, r, s) {
        if (!(!Te || e.row < 0 || e.col < 0)) {
          Te.renderData || (Te = s.requestMeshRenderData());
          var n = Te.renderData.vData,
              o = s.node.worldMatrix;
          ze = 0, Fe = 0;

          var a,
              h,
              l,
              u,
              g,
              f,
              d,
              _,
              p,
              c = s.tiledTiles,
              m = s.texGrids,
              y = s.tiles,
              v = 18,
              A = 27,
              w = s.vertices,
              b = 0,
              S = 0,
              x = 0,
              T = 0,
              I = 0,
              C = null,
              D = 0,
              N = !0;

          Ie = Xe;
          var O = new Float32Array(4);

          for (O[0] = s.color.r / 255, O[1] = s.color.g / 255, O[2] = s.color.b / 255, O[3] = s.color.a / 255, -1 === i ? (u = e.row, g = t.row) : (u = t.row, g = e.row); (g - u) * i >= 0; u += i) {
            for (a = w[u], D = s.getNodesCountByRow(u), N = a && 0 === D, 1 === r ? (h = N && t.col < a.minCol ? a.minCol : t.col, l = N && e.col > a.maxCol ? a.maxCol : e.col) : (h = N && e.col > a.maxCol ? a.maxCol : e.col, l = N && t.col < a.minCol ? a.minCol : t.col); (l - h) * r >= 0; h += r) {
              if (f = a && a[h], D > 0) {
                var P = s.requestSubNodesData(),
                    E = s.getNodesByRowCol(u, h);
                E && E.count > 0 && (P.subNodes = s.getNodesByRowCol(u, h).list, C = null, Te = s.requestMeshRenderData());
              }

              if (f && (b = y[f.index], _ = m.get((b & q.FLIPPED_MASK) >>> 0))) {
                C !== _.texture && (Ue(C, _, s), C = _.texture), d = _.tileset._tileSize, S = f.left - Le, x = f.bottom - Re, T = S + d.width, I = x + d.height, p = c[f.index];
                var G = Te.renderData;
                G.reserve(4, 0), Fe = 9 * G.vertexCount, n = G.vData, p ? p.node.active && je(p.node, O, n, S, T, I, x, !1) : (Se[0].x = S, Se[0].y = I, Se[1].x = S, Se[1].y = x, Se[2].x = T, Se[2].y = I, Se[3].x = T, Se[3].y = x, Se[0].transformMat4(o), n[Fe] = Se[0].x, n[Fe + 1] = Se[0].y, n[Fe + 2] = Se[0].z, Se[1].transformMat4(o), n[Fe + 9] = Se[1].x, n[Fe + 9 + 1] = Se[1].y, n[Fe + 9 + 2] = Se[1].z, Se[2].transformMat4(o), n[Fe + v] = Se[2].x, n[Fe + v + 1] = Se[2].y, n[Fe + v + 2] = Se[2].z, Se[3].transformMat4(o), n[Fe + A] = Se[3].x, n[Fe + A + 1] = Se[3].y, n[Fe + A + 2] = Se[3].z, n.set(O, Fe + 5), n.set(O, Fe + 9 + 5), n.set(O, Fe + v + 5), n.set(O, Fe + A + 5)), Ie(_, b), n[Fe + 3] = Oe.x, n[Fe + 4] = Oe.y, n[Fe + 9 + 3] = Pe.x, n[Fe + 9 + 4] = Pe.y, n[Fe + v + 3] = Ee.x, n[Fe + v + 4] = Ee.y, n[Fe + A + 3] = Ge.x, n[Fe + A + 4] = Ge.y, ze++, G.request(4, 6), G.resize(G.vertexCount, G.indexCount), ze >= be && (Ue(C, _, s), C = _.texture);
              }
            }
          }
        }
      }

      function je(t, e, i, r, s, n, o, a) {
        var h = 18,
            l = 27;
        t.updateWorldTransform(), D.fromRTS(Ce, t.rotation, t.position, t.scale), N.set(De, -(r + Le), -(o + Re), 0), D.transform(Ce, Ce, De), D.multiply(Ce, t.parent.worldMatrix, Ce);
        var u = Ce,
            g = u.m12,
            f = u.m13,
            d = u.m00,
            _ = u.m01,
            p = u.m04,
            c = u.m05,
            m = 1 === d && 0 === _ && 0 === p && 1 === c;

        if (a) {
          var y = (r + s) / 2,
              v = (n + o) / 2;
          m ? (i[Fe] = y + g, i[Fe + 1] = n + f, i[Fe + 9] = r + g, i[Fe + 9 + 1] = v + f, i[Fe + h] = s + g, i[Fe + h + 1] = v + f, i[Fe + l] = y + g, i[Fe + l + 1] = o + f) : (i[Fe] = y * d + n * p + g, i[Fe + 1] = y * _ + n * c + f, i[Fe + 9] = r * d + v * p + g, i[Fe + 9 + 1] = r * _ + v * c + f, i[Fe + h] = s * d + v * p + g, i[Fe + h + 1] = s * _ + v * c + f, i[Fe + l] = y * d + o * p + g, i[Fe + l + 1] = y * _ + o * c + f);
        } else m ? (i[Fe] = r + g, i[Fe + 1] = n + f, i[Fe + 9] = r + g, i[Fe + 9 + 1] = o + f, i[Fe + h] = s + g, i[Fe + h + 1] = n + f, i[Fe + l] = s + g, i[Fe + l + 1] = o + f) : (i[Fe] = r * d + n * p + g, i[Fe + 1] = r * _ + n * c + f, i[Fe + 9] = r * d + o * p + g, i[Fe + 9 + 1] = r * _ + o * c + f, i[Fe + h] = s * d + n * p + g, i[Fe + h + 1] = s * _ + n * c + f, i[Fe + l] = s * d + o * p + g, i[Fe + l + 1] = s * _ + o * c + f);

        i.set(e, Fe + 5), i.set(e, Fe + 9 + 5), i.set(e, Fe + h + 5), i.set(e, Fe + l + 5);
      }

      var Be = t("tiledLayerAssembler", {
        getAssembler: function getAssembler() {
          return Me;
        }
      });
      ve.Assembler = Be;
    }
  };
}); 
 			}); 
		define("__plugin__/wx0446ba2621dda60a/tween.js", function(require, module, exports){ 			
"use strict";

var _typeof2 = require("@babel/runtime/helpers/typeof");

System.register(["./texture-barrier-60b5983b.js", "./json-asset-933a1d4c.js", "./index-f2b92470.js", "./renderable-component-7c6600ed.js", "./deprecated-26630860.js", "./deprecated-ef6bb945.js"], function (t) {
  "use strict";

  var n, e, i, r, s, o, a, c, u, h, l, _, p, f, g, v;

  return {
    setters: [function (t) {
      n = t.c, e = t.bT, i = t.f, r = t.l, s = t.bC, o = t.bU, a = t.bQ, c = t.b$, u = t.d, h = t.w, l = t.bs;
    }, function (t) {
      _ = t.dD;
    }, function () {}, function (t) {
      p = t.p;
    }, function () {}, function (t) {
      f = t.d, g = t.D, v = t.a;
    }],
    execute: function execute() {
      t({
        tween: P,
        tweenUtil: V
      });

      var d = function () {
        function t() {
          this.originalTarget = null, this.target = null, this.tag = t.TAG_INVALID;
        }

        var e = t.prototype;
        return e.clone = function () {
          var n = new t();
          return n.originalTarget = null, n.target = null, n.tag = this.tag, n;
        }, e.isDone = function () {
          return !0;
        }, e.startWithTarget = function (t) {
          this.originalTarget = t, this.target = t;
        }, e.stop = function () {
          this.target = null;
        }, e.step = function () {
          n(1006);
        }, e.update = function () {
          n(1007);
        }, e.getTarget = function () {
          return this.target;
        }, e.setTarget = function (t) {
          this.target = t;
        }, e.getOriginalTarget = function () {
          return this.originalTarget;
        }, e.setOriginalTarget = function (t) {
          this.originalTarget = t;
        }, e.getTag = function () {
          return this.tag;
        }, e.setTag = function (t) {
          this.tag = t;
        }, e.reverse = function () {
          return n(1008), null;
        }, e.retain = function () {}, e.release = function () {}, t;
      }();

      d.TAG_INVALID = -1;

      var A = function (t) {
        function n() {
          for (var n, e = arguments.length, i = new Array(e), r = 0; r < e; r++) {
            i[r] = arguments[r];
          }

          return (n = t.call.apply(t, [this].concat(i)) || this)._duration = 0, n._timesForRepeat = 1, n;
        }

        e(n, t);
        var i = n.prototype;
        return i.getDuration = function () {
          return this._duration * (this._timesForRepeat || 1);
        }, i.setDuration = function (t) {
          this._duration = t;
        }, i.clone = function () {
          return new n();
        }, n;
      }(d),
          T = (function (t) {
        function n(n, e) {
          var i;
          return void 0 === e && (e = 1), (i = t.call(this) || this)._speed = 0, i._innerAction = null, n && i.initWithAction(n, e), i;
        }

        e(n, t);
        var r = n.prototype;
        r.getSpeed = function () {
          return this._speed;
        }, r.setSpeed = function (t) {
          this._speed = t;
        }, r.initWithAction = function (t, n) {
          return t ? (this._innerAction = t, this._speed = n, !0) : (i(1021), !1);
        }, r.clone = function () {
          var t = new n();
          return t.initWithAction(this._innerAction.clone(), this._speed), t;
        }, r.startWithTarget = function (t) {
          d.prototype.startWithTarget.call(this, t), this._innerAction.startWithTarget(t);
        }, r.stop = function () {
          this._innerAction.stop(), d.prototype.stop.call(this);
        }, r.step = function (t) {
          this._innerAction.step(t * this._speed);
        }, r.isDone = function () {
          return this._innerAction.isDone();
        }, r.reverse = function () {
          return new n(this._innerAction.reverse(), this._speed);
        }, r.setInnerAction = function (t) {
          this._innerAction !== t && (this._innerAction = t);
        }, r.getInnerAction = function () {
          return this._innerAction;
        };
      }(d), 0),
          w = function w() {
        this.actions = [], this.target = null, this.actionIndex = 0, this.currentAction = null, this.paused = !1, this.lock = !1;
      },
          y = function () {
        function t() {
          this._hashTargets = new Map(), this._arrayTargets = [], this._elementPool = [];
        }

        var e = t.prototype;
        return e._searchElementByTarget = function (t, n) {
          for (var e = 0; e < t.length; e++) {
            if (n === t[e].target) return t[e];
          }

          return null;
        }, e._getElement = function (t, n) {
          var e = this._elementPool.pop();

          return e || (e = new w()), e.target = t, e.paused = !!n, e;
        }, e._putElement = function (t) {
          t.actions.length = 0, t.actionIndex = 0, t.currentAction = null, t.paused = !1, t.target = null, t.lock = !1, this._elementPool.push(t);
        }, e.addAction = function (t, n, e) {
          if (t && n) {
            null == n.uuid && (n.uuid = "_TWEEN_UUID_" + T++);

            var r = this._hashTargets.get(n);

            r ? r.actions || (r.actions = []) : (r = this._getElement(n, e), this._hashTargets.set(n, r), this._arrayTargets.push(r)), r.target = n, r.actions.push(t), t.startWithTarget(n);
          } else i(1e3);
        }, e.removeAllActions = function () {
          for (var t = this._arrayTargets, n = 0; n < t.length; n++) {
            var e = t[n];
            e && this._putElement(e);
          }

          this._arrayTargets.length = 0, this._hashTargets = new Map();
        }, e.removeAllActionsFromTarget = function (t) {
          if (null != t) {
            var n = this._hashTargets.get(t);

            n && (n.actions.length = 0, this._deleteHashElement(n));
          }
        }, e.removeAction = function (t) {
          if (null != t) {
            var n = t.getOriginalTarget(),
                e = this._hashTargets.get(n);

            if (e) for (var i = 0; i < e.actions.length; i++) {
              if (e.actions[i] === t) {
                e.actions.splice(i, 1), e.actionIndex >= i && e.actionIndex--;
                break;
              }
            }
          }
        }, e._removeActionByTag = function (t, n, e) {
          for (var i = 0, r = n.actions.length; i < r; ++i) {
            var s = n.actions[i];

            if (s && s.getTag() === t) {
              if (e && s.getOriginalTarget() !== e) continue;

              this._removeActionAtIndex(i, n);

              break;
            }
          }
        }, e._removeAllActionsByTag = function (t, n, e) {
          for (var i = n.actions.length - 1; i >= 0; --i) {
            var r = n.actions[i];

            if (r && r.getTag() === t) {
              if (e && r.getOriginalTarget() !== e) continue;

              this._removeActionAtIndex(i, n);
            }
          }
        }, e.removeActionByTag = function (t, e) {
          var i = this;
          t === d.TAG_INVALID && n(1002);
          var r = this._hashTargets;

          if (e) {
            var s = r.get(e);
            s && this._removeActionByTag(t, s, e);
          } else r.forEach(function (n) {
            i._removeActionByTag(t, n);
          });
        }, e.removeAllActionsByTag = function (t, e) {
          var i = this;
          t === d.TAG_INVALID && n(1002);
          var r = this._hashTargets;

          if (e) {
            var s = r.get(e);
            s && this._removeAllActionsByTag(t, s, e);
          } else r.forEach(function (n) {
            i._removeAllActionsByTag(t, n);
          });
        }, e.getActionByTag = function (t, e) {
          t === d.TAG_INVALID && n(1004);

          var i = this._hashTargets.get(e);

          if (i) {
            if (null != i.actions) for (var r = 0; r < i.actions.length; ++r) {
              var s = i.actions[r];
              if (s && s.getTag() === t) return s;
            }
            n(1005, t);
          }

          return null;
        }, e.getNumberOfRunningActionsInTarget = function (t) {
          var n = this._hashTargets.get(t);

          return n && n.actions ? n.actions.length : 0;
        }, e.pauseTarget = function (t) {
          var n = this._hashTargets.get(t);

          n && (n.paused = !0);
        }, e.resumeTarget = function (t) {
          var n = this._hashTargets.get(t);

          n && (n.paused = !1);
        }, e.pauseAllRunningActions = function () {
          for (var t = [], n = this._arrayTargets, e = 0; e < n.length; e++) {
            var i = n[e];
            i && !i.paused && (i.paused = !0, t.push(i.target));
          }

          return t;
        }, e.resumeTargets = function (t) {
          if (t) for (var n = 0; n < t.length; n++) {
            t[n] && this.resumeTarget(t[n]);
          }
        }, e.pauseTargets = function (t) {
          if (t) for (var n = 0; n < t.length; n++) {
            t[n] && this.pauseTarget(t[n]);
          }
        }, e.purgeSharedManager = function () {
          r.director.getScheduler().unscheduleUpdate(this);
        }, e._removeActionAtIndex = function (t, n) {
          n.actions[t], n.actions.splice(t, 1), n.actionIndex >= t && n.actionIndex--, 0 === n.actions.length && this._deleteHashElement(n);
        }, e._deleteHashElement = function (t) {
          var n = !1;

          if (t && !t.lock && this._hashTargets.get(t.target)) {
            this._hashTargets.delete(t.target);

            for (var e = this._arrayTargets, i = 0, r = e.length; i < r; i++) {
              if (e[i] === t) {
                e.splice(i, 1);
                break;
              }
            }

            this._putElement(t), n = !0;
          }

          return n;
        }, e.update = function (t) {
          for (var n, e = this._arrayTargets, i = 0; i < e.length; i++) {
            this._currentTarget = e[i];
            var r = (n = this._currentTarget).target;
            if (r instanceof s && !r.isValid) this.removeAllActionsFromTarget(r), i--;else {
              if (!n.paused && n.actions) {
                for (n.lock = !0, n.actionIndex = 0; n.actionIndex < n.actions.length; n.actionIndex++) {
                  if (n.currentAction = n.actions[n.actionIndex], n.currentAction) {
                    if (n.currentAction.step(t * (n.currentAction._speedMethod ? n.currentAction._speed : 1)), n.currentAction && n.currentAction.isDone()) {
                      n.currentAction.stop();
                      var o = n.currentAction;
                      n.currentAction = null, this.removeAction(o);
                    }

                    n.currentAction = null;
                  }
                }

                n.lock = !1;
              }

              0 === n.actions.length && this._deleteHashElement(n) && i--;
            }
          }
        }, t;
      }(),
          m = t("TweenSystem", function (t) {
        function n() {
          for (var n, e = arguments.length, i = new Array(e), r = 0; r < e; r++) {
            i[r] = arguments[r];
          }

          return (n = t.call.apply(t, [this].concat(i)) || this).actionMgr = new y(), n;
        }

        return e(n, t), n.prototype.update = function (t) {
          this.actionMgr.update(t);
        }, o(n, [{
          key: "ActionManager",
          get: function get() {
            return this.actionMgr;
          }
        }]), n;
      }(v));

      m.ID = "TWEEN", m.instance = void 0, f.on(g.EVENT_INIT, function () {
        var t = new m();
        m.instance = t, f.registerSystem(m.ID, t, v.Priority.MEDIUM);
      });

      var W = function (t) {
        function n() {
          return t.apply(this, arguments) || this;
        }

        e(n, t);
        var i = n.prototype;
        return i.isDone = function () {
          return !0;
        }, i.step = function () {
          this.update(1);
        }, i.update = function () {}, i.reverse = function () {
          return this.clone();
        }, i.clone = function () {
          return new n();
        }, n;
      }(A),
          D = function (t) {
        function n() {
          return t.apply(this, arguments) || this;
        }

        e(n, t);
        var i = n.prototype;
        return i.update = function () {
          for (var t = this.target.getComponentsInChildren(p), n = 0; n < t.length; ++n) {
            t[n].enabled = !0;
          }
        }, i.reverse = function () {
          return new I();
        }, i.clone = function () {
          return new n();
        }, n;
      }(W),
          I = function (t) {
        function n() {
          return t.apply(this, arguments) || this;
        }

        e(n, t);
        var i = n.prototype;
        return i.update = function () {
          for (var t = this.target.getComponentsInChildren(p), n = 0; n < t.length; ++n) {
            t[n].enabled = !1;
          }
        }, i.reverse = function () {
          return new D();
        }, i.clone = function () {
          return new n();
        }, n;
      }(W);

      !function (t) {
        function n() {
          return t.apply(this, arguments) || this;
        }

        e(n, t);
        var i = n.prototype;
        i.update = function () {
          for (var t = this.target.getComponentsInChildren(p), n = 0; n < t.length; ++n) {
            var e = t[n];
            e.enabled = !e.enabled;
          }
        }, i.reverse = function () {
          return new n();
        }, i.clone = function () {
          return new n();
        };
      }(W);

      var b = function (t) {
        function n(n) {
          var e;
          return (e = t.call(this) || this)._isNeedCleanUp = !0, void 0 !== n && e.init(n), e;
        }

        e(n, t);
        var i = n.prototype;
        return i.update = function () {
          this.target.removeFromParent(), this._isNeedCleanUp && this.target.destroy();
        }, i.init = function (t) {
          return this._isNeedCleanUp = t, !0;
        }, i.reverse = function () {
          return new n(this._isNeedCleanUp);
        }, i.clone = function () {
          return new n(this._isNeedCleanUp);
        }, n;
      }(W),
          E = function (t) {
        function n(n, e, i) {
          var r;
          return (r = t.call(this) || this)._selectorTarget = null, r._function = null, r._data = null, r.initWithFunction(n, e, i), r;
        }

        e(n, t);
        var i = n.prototype;
        return i.initWithFunction = function (t, n, e) {
          return t && (this._function = t), n && (this._selectorTarget = n), void 0 !== e && (this._data = e), !0;
        }, i.execute = function () {
          this._function && this._function.call(this._selectorTarget, this.target, this._data);
        }, i.update = function () {
          this.execute();
        }, i.getTargetCallback = function () {
          return this._selectorTarget;
        }, i.setTargetCallback = function (t) {
          t !== this._selectorTarget && (this._selectorTarget && (this._selectorTarget = null), this._selectorTarget = t);
        }, i.clone = function () {
          var t = new n();
          return t.initWithFunction(this._function, this._selectorTarget, this._data), t;
        }, n;
      }(W),
          M = function (t) {
        function i(n) {
          var e;
          return (e = t.call(this) || this).MAX_VALUE = 2, e._elapsed = 0, e._firstTick = !1, e._easeList = [], e._speed = 1, e._repeatForever = !1, e._repeatMethod = !1, e._speedMethod = !1, void 0 === n || isNaN(n) || e.initWithDuration(n), e;
        }

        e(i, t);
        var r = i.prototype;
        return r.getElapsed = function () {
          return this._elapsed;
        }, r.initWithDuration = function (t) {
          return this._duration = 0 === t ? a.FLT_EPSILON : t, this._elapsed = 0, this._firstTick = !0, !0;
        }, r.isDone = function () {
          return this._elapsed >= this._duration;
        }, r._cloneDecoration = function (t) {
          t._repeatForever = this._repeatForever, t._speed = this._speed, t._timesForRepeat = this._timesForRepeat, t._easeList = this._easeList, t._speedMethod = this._speedMethod, t._repeatMethod = this._repeatMethod;
        }, r._reverseEaseList = function (t) {
          if (this._easeList) {
            t._easeList = [];

            for (var n = 0; n < this._easeList.length; n++) {
              t._easeList.push(this._easeList[n]);
            }
          }
        }, r.clone = function () {
          var t = new i(this._duration);
          return this._cloneDecoration(t), t;
        }, r.easing = function (t) {
          this._easeList ? this._easeList.length = 0 : this._easeList = [];

          for (var n = 0; n < arguments.length; n++) {
            this._easeList.push(arguments[n]);
          }

          return this;
        }, r._computeEaseTime = function (t) {
          return t;
        }, r.step = function (t) {
          this._firstTick ? (this._firstTick = !1, this._elapsed = 0) : this._elapsed += t;
          var n = this._elapsed / (this._duration > 1.192092896e-7 ? this._duration : 1.192092896e-7);
          n = n < 1 ? n : 1, this.update(n > 0 ? n : 0), this._repeatMethod && this._timesForRepeat > 1 && this.isDone() && (this._repeatForever || this._timesForRepeat--, this.startWithTarget(this.target), this.step(this._elapsed - this._duration));
        }, r.startWithTarget = function (t) {
          d.prototype.startWithTarget.call(this, t), this._elapsed = 0, this._firstTick = !0;
        }, r.reverse = function () {
          return n(1010), this;
        }, r.setAmplitudeRate = function () {
          n(1011);
        }, r.getAmplitudeRate = function () {
          return n(1012), 0;
        }, r.speed = function (t) {
          return t <= 0 ? (n(1013), this) : (this._speedMethod = !0, this._speed *= t, this);
        }, r.getSpeed = function () {
          return this._speed;
        }, r.setSpeed = function (t) {
          return this._speed = t, this;
        }, r.repeat = function (t) {
          return t = Math.round(t), isNaN(t) || t < 1 ? (n(1014), this) : (this._repeatMethod = !0, this._timesForRepeat *= t, this);
        }, r.repeatForever = function () {
          return this._repeatMethod = !0, this._timesForRepeat = this.MAX_VALUE, this._repeatForever = !0, this;
        }, i;
      }(A),
          L = function (t) {
        function r(e) {
          var s;
          (s = t.call(this) || this)._actions = [], s._split = 0, s._last = 0, s._reversed = !1;
          var o = e instanceof Array ? e : arguments;
          if (1 === o.length) return i(1019), c(s);
          var a = o.length - 1;

          if (a >= 0 && null == o[a] && n(1015), a >= 0) {
            for (var u, h = o[0], l = 1; l < a; l++) {
              o[l] && (u = h, h = r._actionOneTwo(u, o[l]));
            }

            s.initWithTwoActions(h, o[a]);
          }

          return s;
        }

        e(r, t);
        var s = r.prototype;
        return s.initWithTwoActions = function (t, n) {
          if (!t || !n) return i(1025), !1;
          var e = t._duration,
              r = n._duration,
              s = (e *= t._repeatMethod ? t._timesForRepeat : 1) + (r *= n._repeatMethod ? n._timesForRepeat : 1);
          return this.initWithDuration(s), this._actions[0] = t, this._actions[1] = n, !0;
        }, s.clone = function () {
          var t = new r();
          return this._cloneDecoration(t), t.initWithTwoActions(this._actions[0].clone(), this._actions[1].clone()), t;
        }, s.startWithTarget = function (t) {
          M.prototype.startWithTarget.call(this, t), this._split = this._actions[0]._duration / this._duration, this._split *= this._actions[0]._repeatMethod ? this._actions[0]._timesForRepeat : 1, this._last = -1;
        }, s.stop = function () {
          -1 !== this._last && this._actions[this._last].stop(), d.prototype.stop.call(this);
        }, s.update = function (t) {
          var n,
              e,
              i = 0,
              r = this._split,
              s = this._actions,
              o = this._last;
          (t = this._computeEaseTime(t)) < r ? (n = 0 !== r ? t / r : 1, 0 === i && 1 === o && this._reversed && (s[1].update(0), s[1].stop())) : (i = 1, n = 1 === r ? 1 : (t - r) / (1 - r), -1 === o && (s[0].startWithTarget(this.target), s[0].update(1), s[0].stop()), 0 === o && (s[0].update(1), s[0].stop())), e = s[i], o === i && e.isDone() || (o !== i && e.startWithTarget(this.target), n *= e._timesForRepeat, e.update(n > 1 ? n % 1 : n), this._last = i);
        }, s.reverse = function () {
          var t = r._actionOneTwo(this._actions[1].reverse(), this._actions[0].reverse());

          return this._cloneDecoration(t), this._reverseEaseList(t), t._reversed = !0, t;
        }, r;
      }(M);

      function F(t) {
        var e = t instanceof Array ? t : arguments;
        if (1 === e.length) return i(1019), null;
        var r = e.length - 1;
        r >= 0 && null == e[r] && n(1015);
        var s = null;

        if (r >= 0) {
          s = e[0];

          for (var o = 1; o <= r; o++) {
            e[o] && (s = L._actionOneTwo(s, e[o]));
          }
        }

        return s;
      }

      L._actionOneTwo = function (t, n) {
        var e = new L();
        return e.initWithTwoActions(t, n), e;
      };

      var x = function (t) {
        function n(n, e) {
          var i;
          return (i = t.call(this) || this)._times = 0, i._total = 0, i._nextDt = 0, i._actionInstant = !1, i._innerAction = null, void 0 !== e && i.initWithAction(n, e), i;
        }

        e(n, t);
        var i = n.prototype;
        return i.initWithAction = function (t, n) {
          var e = t._duration * n;
          return !!this.initWithDuration(e) && (this._times = n, this._innerAction = t, t instanceof W && (this._actionInstant = !0, this._times -= 1), this._total = 0, !0);
        }, i.clone = function () {
          var t = new n();
          return this._cloneDecoration(t), t.initWithAction(this._innerAction.clone(), this._times), t;
        }, i.startWithTarget = function (t) {
          this._total = 0, this._nextDt = this._innerAction._duration / this._duration, M.prototype.startWithTarget.call(this, t), this._innerAction.startWithTarget(t);
        }, i.stop = function () {
          this._innerAction.stop(), d.prototype.stop.call(this);
        }, i.update = function (t) {
          t = this._computeEaseTime(t);
          var n = this._innerAction,
              e = this._duration,
              i = this._times,
              r = this._nextDt;

          if (t >= r) {
            for (; t > r && this._total < i;) {
              n.update(1), this._total++, n.stop(), n.startWithTarget(this.target), r += n._duration / e, this._nextDt = r > 1 ? 1 : r;
            }

            t >= 1 && this._total < i && (n.update(1), this._total++), this._actionInstant || (this._total === i ? n.stop() : n.update(t - (r - n._duration / e)));
          } else n.update(t * i % 1);
        }, i.isDone = function () {
          return this._total === this._times;
        }, i.reverse = function () {
          var t = new n(this._innerAction.reverse(), this._times);
          return this._cloneDecoration(t), this._reverseEaseList(t), t;
        }, i.setInnerAction = function (t) {
          this._innerAction !== t && (this._innerAction = t);
        }, i.getInnerAction = function () {
          return this._innerAction;
        }, n;
      }(M),
          N = function (t) {
        function n(n) {
          var e;
          return (e = t.call(this) || this)._innerAction = null, n && e.initWithAction(n), e;
        }

        e(n, t);
        var r = n.prototype;
        return r.initWithAction = function (t) {
          return t ? (this._innerAction = t, !0) : (i(1026), !1);
        }, r.clone = function () {
          var t = new n();
          return this._cloneDecoration(t), t.initWithAction(this._innerAction.clone()), t;
        }, r.startWithTarget = function (t) {
          M.prototype.startWithTarget.call(this, t), this._innerAction.startWithTarget(t);
        }, r.step = function (t) {
          var n = this._innerAction;
          n.step(t), n.isDone() && (n.startWithTarget(this.target), n.step(n.getElapsed() - n._duration));
        }, r.isDone = function () {
          return !1;
        }, r.reverse = function () {
          var t = new n(this._innerAction.reverse());
          return this._cloneDecoration(t), this._reverseEaseList(t), t;
        }, r.setInnerAction = function (t) {
          this._innerAction !== t && (this._innerAction = t);
        }, r.getInnerAction = function () {
          return this._innerAction;
        }, n;
      }(M),
          O = function (t) {
        function r(e) {
          var s;
          (s = t.call(this) || this)._one = null, s._two = null;
          var o = e instanceof Array ? e : arguments;
          if (1 === o.length) return i(1020), c(s);
          var a = o.length - 1;

          if (a >= 0 && null == o[a] && n(1015), a >= 0) {
            for (var u, h = o[0], l = 1; l < a; l++) {
              o[l] && (u = h, h = r._actionOneTwo(u, o[l]));
            }

            s.initWithTwoActions(h, o[a]);
          }

          return s;
        }

        e(r, t);
        var s = r.prototype;
        return s.initWithTwoActions = function (t, n) {
          if (!t || !n) return i(1027), !1;
          var e = !1,
              r = t._duration,
              s = n._duration;
          return this.initWithDuration(Math.max(r, s)) && (this._one = t, this._two = n, r > s ? this._two = L._actionOneTwo(n, S(r - s)) : r < s && (this._one = L._actionOneTwo(t, S(s - r))), e = !0), e;
        }, s.clone = function () {
          var t = new r();
          return this._cloneDecoration(t), t.initWithTwoActions(this._one.clone(), this._two.clone()), t;
        }, s.startWithTarget = function (t) {
          M.prototype.startWithTarget.call(this, t), this._one.startWithTarget(t), this._two.startWithTarget(t);
        }, s.stop = function () {
          this._one.stop(), this._two.stop(), d.prototype.stop.call(this);
        }, s.update = function (t) {
          t = this._computeEaseTime(t), this._one && this._one.update(t), this._two && this._two.update(t);
        }, s.reverse = function () {
          var t = r._actionOneTwo(this._one.reverse(), this._two.reverse());

          return this._cloneDecoration(t), this._reverseEaseList(t), t;
        }, r;
      }(M);

      function k(t) {
        var e = t instanceof Array ? t : arguments;
        if (1 === e.length) return i(1020), null;
        e.length > 0 && null == e[e.length - 1] && n(1015);

        for (var r = e[0], s = 1; s < e.length; s++) {
          null != e[s] && (r = O._actionOneTwo(r, e[s]));
        }

        return r;
      }

      O._actionOneTwo = function (t, n) {
        var e = new O();
        return e.initWithTwoActions(t, n), e;
      };

      var C = function (t) {
        function n() {
          return t.apply(this, arguments) || this;
        }

        e(n, t);
        var i = n.prototype;
        return i.update = function () {}, i.reverse = function () {
          var t = new n(this._duration);
          return this._cloneDecoration(t), this._reverseEaseList(t), t;
        }, i.clone = function () {
          var t = new n();
          return this._cloneDecoration(t), t.initWithDuration(this._duration), t;
        }, n;
      }(M);

      function S(t) {
        return new C(t);
      }

      var U = function (t) {
        function n(n) {
          var e;
          return (e = t.call(this) || this)._other = null, n && e.initWithAction(n), e;
        }

        e(n, t);
        var r = n.prototype;
        return r.initWithAction = function (t) {
          return t ? t === this._other ? (i(1029), !1) : !!M.prototype.initWithDuration.call(this, t._duration) && (this._other = t, !0) : (i(1028), !1);
        }, r.clone = function () {
          var t = new n();
          return this._cloneDecoration(t), t.initWithAction(this._other.clone()), t;
        }, r.startWithTarget = function (t) {
          M.prototype.startWithTarget.call(this, t), this._other.startWithTarget(t);
        }, r.update = function (t) {
          t = this._computeEaseTime(t), this._other && this._other.update(1 - t);
        }, r.reverse = function () {
          return this._other.clone();
        }, r.stop = function () {
          this._other.stop(), d.prototype.stop.call(this);
        }, n;
      }(M),
          R = t("TweenAction", function (t) {
        function n(n, e, i) {
          var r;
          if ((r = t.call(this) || this)._opts = void 0, r._props = void 0, r._originProps = void 0, null == i) i = Object.create(null);else if (function (t) {
            var n = " [Tween:] ",
                e = " option is not support in v + " + l,
                i = t;
            i.delay && h(n + "delay" + e), i.repeat && h(n + "repeat" + e), i.repeatDelay && h(n + "repeatDelay" + e), i.interpolation && h(n + "interpolation" + e), i.onStop && h(n + "onStop" + e);
          }(i), i.easing && "string" == typeof i.easing && (i.easing = function (t) {
            var n = t.charAt(0);

            if (/[A-Z]/.test(n)) {
              var e = (t = t.replace(n, n.toLowerCase())).split("-");

              if (2 === e.length) {
                var i = e[0];
                if ("linear" === i) t = "linear";else {
                  var r = e[1];

                  switch (i) {
                    case "quadratic":
                      t = "quad" + r;
                      break;

                    case "quartic":
                      t = "quart" + r;
                      break;

                    case "quintic":
                      t = "quint" + r;
                      break;

                    case "sinusoidal":
                      t = "sine" + r;
                      break;

                    case "exponential":
                      t = "expo" + r;
                      break;

                    case "circular":
                      t = "circ" + r;
                      break;

                    default:
                      t = i + r;
                  }
                }
              }
            }

            return t;
          }(i.easing)), i.progress || (i.progress = r.progress), i.easing && "string" == typeof i.easing) {
            var s = i.easing;
            i.easing = _[s], i.easing || u(1031, s);
          }

          for (var o in r._opts = i, r._props = Object.create(null), e) {
            if (e.hasOwnProperty(o)) {
              var a = e[o];

              if ("function" == typeof a && (a = a()), null != a && "string" != typeof a) {
                var c = void 0,
                    p = void 0;
                void 0 !== a.value && (a.easing || a.progress) && ("string" == typeof a.easing ? (c = _[a.easing]) || u(1031, a.easing) : c = a.easing, p = a.progress, a = a.value);
                var f = Object.create(null);
                f.value = a, f.easing = c, f.progress = p, r._props[o] = f;
              }
            }
          }

          return r._originProps = e, r.initWithDuration(n), r;
        }

        e(n, t);
        var i = n.prototype;
        return i.clone = function () {
          var t = new n(this._duration, this._originProps, this._opts);
          return this._cloneDecoration(t), t;
        }, i.startWithTarget = function (t) {
          M.prototype.startWithTarget.call(this, t);
          var n = !!this._opts.relative,
              e = this._props;

          for (var i in e) {
            var r = t[i];

            if (void 0 !== r) {
              var s = e[i],
                  o = s.value;
              if ("number" == typeof r) s.start = r, s.current = r, s.end = n ? r + o : o;else if ("object" == _typeof2(r)) for (var a in null == s.start && (s.start = {}, s.current = {}, s.end = {}), o) {
                isNaN(r[a]) || (s.start[a] = r[a], s.current[a] = r[a], s.end[a] = n ? r[a] + o[a] : o[a]);
              }
            }
          }

          this._opts.onStart && this._opts.onStart(this.target);
        }, i.update = function (t) {
          var n = this.target;

          if (n) {
            var e = this._props,
                i = this._opts,
                r = t;
            i.easing && (r = i.easing(t));
            var s = i.progress;

            for (var o in e) {
              var a = e[o],
                  c = a.easing ? a.easing(t) : r,
                  u = a.progress ? a.progress : s,
                  h = a.start,
                  l = a.end;
              if ("number" == typeof h) a.current = u(h, l, a.current, c);else if ("object" == _typeof2(h)) for (var _ in h) {
                a.current[_] = u(h[_], l[_], a.current[_], c);
              }
              n[o] = a.current;
            }

            i.onUpdate && i.onUpdate(this.target, t), 1 === t && i.onComplete && i.onComplete(this.target);
          }
        }, i.progress = function (t, n, e, i) {
          return t + (n - t) * i;
        }, n;
      }(M)),
          j = function (t) {
        function n(n) {
          var e;
          return (e = t.call(this) || this)._props = void 0, e._props = {}, void 0 !== n && e.init(n), e;
        }

        e(n, t);
        var i = n.prototype;
        return i.init = function (t) {
          for (var n in t) {
            this._props[n] = t[n];
          }

          return !0;
        }, i.update = function () {
          var t = this._props,
              n = this.target;

          for (var e in t) {
            n[e] = t[e];
          }
        }, i.clone = function () {
          var t = new n();
          return t.init(this._props), t;
        }, n;
      }(W),
          B = t("Tween", function () {
        function t(t) {
          this._actions = [], this._finalAction = null, this._target = null, this._tag = d.TAG_INVALID, this._target = void 0 === t ? null : t;
        }

        var n = t.prototype;
        return n.tag = function (t) {
          return this._tag = t, this;
        }, n.then = function (t) {
          return t instanceof d ? this._actions.push(t.clone()) : this._actions.push(t._union()), this;
        }, n.target = function (t) {
          return this._target = t, this;
        }, n.start = function () {
          return this._target ? (this._finalAction && m.instance.ActionManager.removeAction(this._finalAction), this._finalAction = this._union(), this._finalAction.setTag(this._tag), m.instance.ActionManager.addAction(this._finalAction, this._target, !1), this) : (h("Please set target to tween first"), this);
        }, n.stop = function () {
          return this._finalAction && m.instance.ActionManager.removeAction(this._finalAction), this;
        }, n.clone = function (t) {
          var n = this._union();

          return P(t).then(n.clone());
        }, n.union = function () {
          var t = this._union();

          return this._actions.length = 0, this._actions.push(t), this;
        }, n.to = function (t, n, e) {
          (e = e || Object.create(null)).relative = !1;
          var i = new R(t, n, e);
          return this._actions.push(i), this;
        }, n.by = function (t, n, e) {
          (e = e || Object.create(null)).relative = !0;
          var i = new R(t, n, e);
          return this._actions.push(i), this;
        }, n.set = function (t) {
          var n = new j(t);
          return this._actions.push(n), this;
        }, n.delay = function (t) {
          var n = S(t);
          return this._actions.push(n), this;
        }, n.call = function (t) {
          var n = new E(t, undefined, undefined);
          return this._actions.push(n), this;
        }, n.sequence = function () {
          var n = t._wrappedSequence.apply(t, arguments);

          return this._actions.push(n), this;
        }, n.parallel = function () {
          var n = t._wrappedParallel.apply(t, arguments);

          return this._actions.push(n), this;
        }, n.repeat = function (n, e) {
          if (n === 1 / 0) return this.repeatForever(e);
          var i,
              r = this._actions;
          return i = e instanceof t ? e._union() : r.pop(), r.push(function (t, n) {
            return new x(t, n);
          }(i, n)), this;
        }, n.repeatForever = function (n) {
          var e,
              i = this._actions;
          return e = n instanceof t ? n._union() : i.pop(), i.push(function (t) {
            return new N(t);
          }(e)), this;
        }, n.reverseTime = function (n) {
          var e,
              i = this._actions;
          return e = n instanceof t ? n._union() : i.pop(), i.push(function (t) {
            return new U(t);
          }(e)), this;
        }, n.hide = function () {
          var t = new I();
          return this._actions.push(t), this;
        }, n.show = function () {
          var t = new D();
          return this._actions.push(t), this;
        }, n.removeSelf = function () {
          var t = new b(!1);
          return this._actions.push(t), this;
        }, t.stopAll = function () {
          m.instance.ActionManager.removeAllActions();
        }, t.stopAllByTag = function (t, n) {
          m.instance.ActionManager.removeAllActionsByTag(t, n);
        }, t.stopAllByTarget = function (t) {
          m.instance.ActionManager.removeAllActionsFromTarget(t);
        }, n._union = function () {
          var t = this._actions;
          return 1 === t.length ? t[0] : F(t);
        }, n._destroy = function () {
          this.stop();
        }, t._wrappedSequence = function () {
          var n = t._tmp_args;
          n.length = 0;

          for (var e = arguments.length, i = 0; i < e; i++) {
            var r = n[i] = i < 0 || arguments.length <= i ? void 0 : arguments[i];
            r instanceof t && (n[i] = r._union());
          }

          return F.apply(F, n);
        }, t._wrappedParallel = function () {
          var n = t._tmp_args;
          n.length = 0;

          for (var e = arguments.length, i = 0; i < e; i++) {
            var r = n[i] = i < 0 || arguments.length <= i ? void 0 : arguments[i];
            r instanceof t && (n[i] = r._union());
          }

          return k.apply(k, n);
        }, t;
      }());

      function P(t) {
        return new B(t);
      }

      function V(t) {
        return h("tweenUtil' is deprecated, please use 'tween' instead "), new B(t);
      }

      B._tmp_args = [], r.Tween = B, r.tween = P, r.tweenUtil = V;
    }
  };
}); 
 			}); 
		define("__plugin__/wx0446ba2621dda60a/ui.js", function(require, module, exports){ 			
"use strict";

var _typeof2 = require("@babel/runtime/helpers/typeof");

System.register(["./texture-barrier-60b5983b.js", "./json-asset-933a1d4c.js", "./index-f2b92470.js", "./renderable-component-7c6600ed.js", "./deprecated-26630860.js", "./deprecated-ef6bb945.js", "./sprite-frame-1edab3eb.js", "./sprite-827770a8.js", "./renderable-2d-e2838949.js", "./deprecated-5f7f37d5.js"], function (t) {
  "use strict";

  var e, i, o, n, r, s, a, h, l, c, u, _, p, d, g, f, y, b, T, m, v, C, S, E, O, A, w, L, D, P, I, z, R, x, B, N, H, M, k, V, F, G, j, U, W, Z, Y, X, q, K, Q, $, J, tt, et, it, ot, nt, rt, st, at, ht, lt, ct, ut, _t, pt, dt, gt, ft, yt, bt, Tt, mt, vt, Ct;

  return {
    setters: [function (t) {
      e = t.bw, i = t.bT, o = t.bU, n = t.c0, r = t.l, s = t.c1, a = t.b$, h = t.bv, l = t.cO, c = t.bS, u = t.cd, _ = t.cP, p = t.cQ, d = t.cR, g = t.w, f = t.i, y = t.c, b = t.cw, T = t.d, m = t.cA, v = t.c7, C = t.bC, S = t.bX;
    }, function (t) {
      E = t.a5, O = t.bW, A = t.bZ, w = t.b6, L = t.cd, D = t.ac, P = t.dR, I = t.Q, z = t.ce, R = t.cg, x = t.ds, B = t.ch, N = t.dQ, H = t.bY, M = t.cc, k = t.dY, V = t.dZ, F = t.bm, G = t.bX, j = t.Z, U = t.b0, W = t.ca, Z = t.bD, Y = t.a1, X = t.ci, q = t.V, K = t.ab, Q = t.di, $ = t.dj, J = t.bB, tt = t.bw, et = t.bx, it = t.b$, ot = t.b7, nt = t.d_, rt = t.dz, st = t.aS, at = t.aT;
    }, function () {}, function () {}, function (t) {
      ht = t.g, lt = t.v, ct = t.k, ut = t.V;
    }, function (t) {
      _t = t.E, pt = t.d, dt = t.D, gt = t.C;
    }, function (t) {
      ft = t.S;
    }, function (t) {
      yt = t.a, bt = t.B, Tt = t.c, mt = t.V;
    }, function (t) {
      vt = t.R, Ct = t.U;
    }, function () {}],
    execute: function execute() {
      var St,
          Et,
          Ot,
          At,
          wt,
          Lt,
          Dt,
          Pt,
          It,
          zt,
          Rt,
          xt,
          Bt,
          Nt,
          Ht,
          Mt,
          kt,
          Vt,
          Ft,
          Gt,
          jt,
          Ut,
          Wt,
          Zt,
          Yt,
          Xt,
          qt,
          Kt,
          Qt,
          $t,
          Jt,
          te,
          ee,
          ie,
          oe,
          ne,
          re,
          se,
          ae,
          he,
          le,
          ce,
          ue,
          _e,
          pe,
          de,
          ge,
          fe,
          ye,
          be,
          Te,
          me,
          ve,
          Ce,
          Se,
          Ee,
          Oe,
          Ae,
          we,
          Le,
          De,
          Pe,
          Ie,
          ze = new E();

      !function (t) {
        t[t.NONE = 0] = "NONE", t[t.COLOR = 1] = "COLOR", t[t.SPRITE = 2] = "SPRITE", t[t.SCALE = 3] = "SCALE";
      }(De || (De = {})), e(De), function (t) {
        t.NORMAL = "normal", t.HOVER = "hover", t.PRESSED = "pressed", t.DISABLED = "disabled";
      }(Pe || (Pe = {})), function (t) {
        t.CLICK = "click";
      }(Ie || (Ie = {}));
      var Re,
          xe = (St = O("cc.Button"), Et = R(), Ot = x(110), At = B(), wt = N(Ct), Lt = A(w), Dt = H(), Pt = M(), It = H(), zt = M(), Rt = A(De), xt = H(), Bt = M(), Nt = H(), Ht = M(), Mt = H(), kt = M(), Vt = H(), Ft = M(), Gt = H(), jt = M(), Ut = k(), Wt = V(), Zt = H(), Yt = M(), Xt = H(), qt = M(), Kt = A(ft), Qt = H(), $t = M(), Jt = A(ft), te = H(), ee = M(), ie = A(ft), oe = H(), ne = M(), re = A(ft), se = H(), ae = M(), he = A([_t]), le = H(), ce = M(), Re = St(ue = Et(ue = Ot(ue = At(ue = wt(ue = L((Le = we = function (t) {
        function e() {
          for (var e, i = arguments.length, o = new Array(i), n = 0; n < i; n++) {
            o[n] = arguments[n];
          }

          return e = t.call.apply(t, [this].concat(o)) || this, s(e, "clickEvents", pe, a(e)), s(e, "_interactable", de, a(e)), s(e, "_transition", ge, a(e)), s(e, "_normalColor", fe, a(e)), s(e, "_hoverColor", ye, a(e)), s(e, "_pressedColor", be, a(e)), s(e, "_disabledColor", Te, a(e)), s(e, "_normalSprite", me, a(e)), s(e, "_hoverSprite", ve, a(e)), s(e, "_pressedSprite", Ce, a(e)), s(e, "_disabledSprite", Se, a(e)), s(e, "_duration", Ee, a(e)), s(e, "_zoomScale", Oe, a(e)), s(e, "_target", Ae, a(e)), e._pressed = !1, e._hovered = !1, e._fromColor = new E(), e._toColor = new E(), e._time = 0, e._transitionFinished = !0, e._fromScale = new I(), e._toScale = new I(), e._originalScale = null, e._sprite = null, e._targetScale = new I(), e;
        }

        i(e, t);
        var n = e.prototype;
        return n.__preload = function () {
          this.target || (this.target = this.node);
          var t = this.node.getComponent(yt);
          t && (this._normalSprite = t.spriteFrame), this._applyTarget(), this._resetState();
        }, n.onEnable = function () {
          this._registerNodeEvent();
        }, n.onDisable = function () {
          this._resetState(), this._unregisterNodeEvent();
        }, n.onDestroy = function () {
          this.target.isValid && this._unregisterTargetEvent(this.target);
        }, n.update = function (t) {
          var e = this.target;

          if (!this._transitionFinished && e && (this._transition === De.COLOR || this._transition === De.SCALE)) {
            this._time += t;
            var i = 1;

            if (this._duration > 0 && (i = this._time / this._duration), i >= 1 && (i = 1), this._transition === De.COLOR) {
              var o = e._uiProps.uiComp;
              E.lerp(ze, this._fromColor, this._toColor, i), o && (o.color = ze);
            } else this.transition === De.SCALE && (e.getScale(this._targetScale), this._targetScale.x = D(this._fromScale.x, this._toScale.x, i), this._targetScale.y = D(this._fromScale.y, this._toScale.y, i), e.setScale(this._targetScale));

            1 === i && (this._transitionFinished = !0);
          }
        }, n._resizeNodeToTargetNode = function () {
          this.target && this.target._uiProps.uiTransformComp;
        }, n._resetState = function () {
          this._pressed = !1, this._hovered = !1;
          var t = this.target;

          if (t) {
            var e = this._transition;

            if (e === De.COLOR && this._interactable) {
              var i = t.getComponent(vt);
              i && (i.color = this._normalColor);
            } else e === De.SCALE && this._originalScale && t.setScale(this._originalScale);

            this._transitionFinished = !0;
          }
        }, n._registerNodeEvent = function () {
          this.node.on(P.TOUCH_START, this._onTouchBegan, this), this.node.on(P.TOUCH_MOVE, this._onTouchMove, this), this.node.on(P.TOUCH_END, this._onTouchEnded, this), this.node.on(P.TOUCH_CANCEL, this._onTouchCancel, this), this.node.on(P.MOUSE_ENTER, this._onMouseMoveIn, this), this.node.on(P.MOUSE_LEAVE, this._onMouseMoveOut, this);
        }, n._registerTargetEvent = function (t) {
          t.on(P.TRANSFORM_CHANGED, this._onTargetTransformChanged, this);
        }, n._unregisterNodeEvent = function () {
          this.node.off(P.TOUCH_START, this._onTouchBegan, this), this.node.off(P.TOUCH_MOVE, this._onTouchMove, this), this.node.off(P.TOUCH_END, this._onTouchEnded, this), this.node.off(P.TOUCH_CANCEL, this._onTouchCancel, this), this.node.off(P.MOUSE_ENTER, this._onMouseMoveIn, this), this.node.off(P.MOUSE_LEAVE, this._onMouseMoveOut, this);
        }, n._unregisterTargetEvent = function (t) {
          t.off(P.TRANSFORM_CHANGED);
        }, n._getTargetSprite = function (t) {
          var e = null;
          return t && (e = t.getComponent(yt)), e;
        }, n._applyTarget = function () {
          this.target && (this._sprite = this._getTargetSprite(this.target), this._originalScale || (this._originalScale = new I()), I.copy(this._originalScale, this.target.getScale()), this._registerTargetEvent(this.target));
        }, n._onTargetSpriteFrameChanged = function (t) {
          this._transition === De.SPRITE && this._setCurrentStateSpriteFrame(t.spriteFrame);
        }, n._setCurrentStateSpriteFrame = function (t) {
          if (t) switch (this._getButtonState()) {
            case Pe.NORMAL:
              this._normalSprite = t;
              break;

            case Pe.HOVER:
              this._hoverSprite = t;
              break;

            case Pe.PRESSED:
              this._pressedSprite = t;
              break;

            case Pe.DISABLED:
              this._disabledSprite = t;
          }
        }, n._onTargetColorChanged = function (t) {
          this._transition === De.COLOR && this._setCurrentStateColor(t);
        }, n._setCurrentStateColor = function (t) {
          switch (this._getButtonState()) {
            case Pe.NORMAL:
              this._normalColor = t;
              break;

            case Pe.HOVER:
              this._hoverColor = t;
              break;

            case Pe.PRESSED:
              this._pressedColor = t;
              break;

            case Pe.DISABLED:
              this._disabledColor = t;
          }
        }, n._onTargetTransformChanged = function (t) {
          t & z.SCALE && this._originalScale && this._transition === De.SCALE && this._transitionFinished && I.copy(this._originalScale, this.target.getScale());
        }, n._onTouchBegan = function (t) {
          this._interactable && this.enabledInHierarchy && (this._pressed = !0, this._updateState(), t && (t.propagationStopped = !0));
        }, n._onTouchMove = function (t) {
          if (this._interactable && this.enabledInHierarchy && this._pressed && t) {
            var e = t.touch;

            if (e) {
              var i,
                  o = this.node._uiProps.uiTransformComp.hitTest(e.getLocation());

              this._transition === De.SCALE && this.target && this._originalScale ? o ? (I.copy(this._fromScale, this._originalScale), I.multiplyScalar(this._toScale, this._originalScale, this._zoomScale), this._transitionFinished = !1) : (this._time = 0, this._transitionFinished = !0, this.target.setScale(this._originalScale)) : (i = o ? Pe.PRESSED : Pe.NORMAL, this._applyTransition(i)), t && (t.propagationStopped = !0);
            }
          }
        }, n._onTouchEnded = function (t) {
          this._interactable && this.enabledInHierarchy && (this._pressed && (_t.emitEvents(this.clickEvents, t), this.node.emit(Ie.CLICK, this)), this._pressed = !1, this._updateState(), t && (t.propagationStopped = !0));
        }, n._onTouchCancel = function () {
          this._interactable && this.enabledInHierarchy && (this._pressed = !1, this._updateState());
        }, n._onMouseMoveIn = function () {
          !this._pressed && this.interactable && this.enabledInHierarchy && (this._transition !== De.SPRITE || this._hoverSprite) && (this._hovered || (this._hovered = !0, this._updateState()));
        }, n._onMouseMoveOut = function () {
          this._hovered && (this._hovered = !1, this._updateState());
        }, n._updateState = function () {
          var t = this._getButtonState();

          this._applyTransition(t);
        }, n._getButtonState = function () {
          var t = Pe.NORMAL;
          return this._interactable ? this._pressed ? t = Pe.PRESSED : this._hovered && (t = Pe.HOVER) : t = Pe.DISABLED, t.toString();
        }, n._updateColorTransition = function (t) {
          var e,
              i = this[t + "Color"],
              o = null === (e = this.target) || void 0 === e ? void 0 : e.getComponent(vt);
          o && (t === Pe.DISABLED ? o.color = i : (this._fromColor = o.color.clone(), this._toColor = i, this._time = 0, this._transitionFinished = !1));
        }, n._updateSpriteTransition = function (t) {
          var e = this[t + "Sprite"];
          this._sprite && e && (this._sprite.spriteFrame = e);
        }, n._updateScaleTransition = function (t) {
          this._interactable && (t === Pe.PRESSED ? this._zoomUp() : this._zoomBack());
        }, n._zoomUp = function () {
          this._originalScale && (I.copy(this._fromScale, this._originalScale), I.multiplyScalar(this._toScale, this._originalScale, this._zoomScale), this._time = 0, this._transitionFinished = !1);
        }, n._zoomBack = function () {
          this.target && this._originalScale && (I.copy(this._fromScale, this.target.getScale()), I.copy(this._toScale, this._originalScale), this._time = 0, this._transitionFinished = !1);
        }, n._applyTransition = function (t) {
          var e = this._transition;
          e === De.COLOR ? this._updateColorTransition(t) : e === De.SPRITE ? this._updateSpriteTransition(t) : e === De.SCALE && this._updateScaleTransition(t);
        }, o(e, [{
          key: "target",
          get: function get() {
            return this._target || this.node;
          },
          set: function set(t) {
            this._target !== t && (this._target && this._unregisterTargetEvent(this._target), this._target = t, this._applyTarget());
          }
        }, {
          key: "interactable",
          get: function get() {
            return this._interactable;
          },
          set: function set(t) {
            this._interactable !== t && (this._interactable = t, this._updateState(), this._interactable || this._resetState());
          }
        }, {
          key: "_resizeToTarget",
          set: function set(t) {
            t && this._resizeNodeToTargetNode();
          }
        }, {
          key: "transition",
          get: function get() {
            return this._transition;
          },
          set: function set(t) {
            this._transition !== t && (this._transition === De.COLOR ? this._updateColorTransition(Pe.NORMAL) : this._transition === De.SPRITE && this._updateSpriteTransition(Pe.NORMAL), this._transition = t, this._updateState());
          }
        }, {
          key: "normalColor",
          get: function get() {
            return this._normalColor;
          },
          set: function set(t) {
            this._normalColor !== t && (this._normalColor.set(t), this._updateState());
          }
        }, {
          key: "pressedColor",
          get: function get() {
            return this._pressedColor;
          },
          set: function set(t) {
            this._pressedColor !== t && this._pressedColor.set(t);
          }
        }, {
          key: "hoverColor",
          get: function get() {
            return this._hoverColor;
          },
          set: function set(t) {
            this._hoverColor !== t && this._hoverColor.set(t);
          }
        }, {
          key: "disabledColor",
          get: function get() {
            return this._disabledColor;
          },
          set: function set(t) {
            this._disabledColor !== t && (this._disabledColor.set(t), this._updateState());
          }
        }, {
          key: "duration",
          get: function get() {
            return this._duration;
          },
          set: function set(t) {
            this._duration !== t && (this._duration = t);
          }
        }, {
          key: "zoomScale",
          get: function get() {
            return this._zoomScale;
          },
          set: function set(t) {
            this._zoomScale !== t && (this._zoomScale = t);
          }
        }, {
          key: "normalSprite",
          get: function get() {
            return this._normalSprite;
          },
          set: function set(t) {
            if (this._normalSprite !== t) {
              this._normalSprite = t;
              var e = this.node.getComponent(yt);
              e && (e.spriteFrame = t), this._updateState();
            }
          }
        }, {
          key: "pressedSprite",
          get: function get() {
            return this._pressedSprite;
          },
          set: function set(t) {
            this._pressedSprite !== t && (this._pressedSprite = t, this._updateState());
          }
        }, {
          key: "hoverSprite",
          get: function get() {
            return this._hoverSprite;
          },
          set: function set(t) {
            this._hoverSprite !== t && (this._hoverSprite = t, this._updateState());
          }
        }, {
          key: "disabledSprite",
          get: function get() {
            return this._disabledSprite;
          },
          set: function set(t) {
            this._disabledSprite !== t && (this._disabledSprite = t, this._updateState());
          }
        }]), e;
      }(F), we.Transition = De, we.EventType = Ie, n((_e = Le).prototype, "target", [Lt, Dt, Pt], Object.getOwnPropertyDescriptor(_e.prototype, "target"), _e.prototype), n(_e.prototype, "interactable", [It, zt], Object.getOwnPropertyDescriptor(_e.prototype, "interactable"), _e.prototype), n(_e.prototype, "transition", [Rt, xt, Bt], Object.getOwnPropertyDescriptor(_e.prototype, "transition"), _e.prototype), n(_e.prototype, "normalColor", [Nt, Ht], Object.getOwnPropertyDescriptor(_e.prototype, "normalColor"), _e.prototype), n(_e.prototype, "pressedColor", [Mt, kt], Object.getOwnPropertyDescriptor(_e.prototype, "pressedColor"), _e.prototype), n(_e.prototype, "hoverColor", [Vt, Ft], Object.getOwnPropertyDescriptor(_e.prototype, "hoverColor"), _e.prototype), n(_e.prototype, "disabledColor", [Gt, jt], Object.getOwnPropertyDescriptor(_e.prototype, "disabledColor"), _e.prototype), n(_e.prototype, "duration", [Ut, Wt, Zt, Yt], Object.getOwnPropertyDescriptor(_e.prototype, "duration"), _e.prototype), n(_e.prototype, "zoomScale", [Xt, qt], Object.getOwnPropertyDescriptor(_e.prototype, "zoomScale"), _e.prototype), n(_e.prototype, "normalSprite", [Kt, Qt, $t], Object.getOwnPropertyDescriptor(_e.prototype, "normalSprite"), _e.prototype), n(_e.prototype, "pressedSprite", [Jt, te, ee], Object.getOwnPropertyDescriptor(_e.prototype, "pressedSprite"), _e.prototype), n(_e.prototype, "hoverSprite", [ie, oe, ne], Object.getOwnPropertyDescriptor(_e.prototype, "hoverSprite"), _e.prototype), n(_e.prototype, "disabledSprite", [re, se, ae], Object.getOwnPropertyDescriptor(_e.prototype, "disabledSprite"), _e.prototype), pe = n(_e.prototype, "clickEvents", [he, G, le, ce], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return [];
        }
      }), de = n(_e.prototype, "_interactable", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !0;
        }
      }), ge = n(_e.prototype, "_transition", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return De.NONE;
        }
      }), fe = n(_e.prototype, "_normalColor", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return E.WHITE.clone();
        }
      }), ye = n(_e.prototype, "_hoverColor", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return new E(211, 211, 211, 255);
        }
      }), be = n(_e.prototype, "_pressedColor", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return E.WHITE.clone();
        }
      }), Te = n(_e.prototype, "_disabledColor", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return new E(124, 124, 124, 255);
        }
      }), me = n(_e.prototype, "_normalSprite", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return null;
        }
      }), ve = n(_e.prototype, "_hoverSprite", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return null;
        }
      }), Ce = n(_e.prototype, "_pressedSprite", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return null;
        }
      }), Se = n(_e.prototype, "_disabledSprite", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return null;
        }
      }), Ee = n(_e.prototype, "_duration", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return .1;
        }
      }), Oe = n(_e.prototype, "_zoomScale", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 1.2;
        }
      }), Ae = n(_e.prototype, "_target", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return null;
        }
      }), ue = _e)) || ue) || ue) || ue) || ue) || ue) || ue, t({
        Button: Re,
        ButtonComponent: Re
      }), Re);
      r.Button = xe;

      var Be,
          Ne,
          He,
          Me = function () {
        function t() {}

        return t.add = function (t) {
          var e = this._tabIndexList;
          -1 === e.indexOf(t) && e.push(t);
        }, t.remove = function (t) {
          var e = this._tabIndexList,
              i = e.indexOf(t);
          -1 !== i && e.splice(i, 1);
        }, t.resort = function () {
          this._tabIndexList.sort(function (t, e) {
            return t._delegate.tabIndex - e._delegate.tabIndex;
          });
        }, t.next = function (t) {
          var e = this._tabIndexList,
              i = e.indexOf(t);

          if (t.setFocus(!1), -1 !== i) {
            var o = e[i + 1];
            o && o._delegate.tabIndex >= 0 && o.setFocus(!0);
          }
        }, t;
      }();

      Me._tabIndexList = [], function (t) {
        t[t.DEFAULT = 0] = "DEFAULT", t[t.DONE = 1] = "DONE", t[t.SEND = 2] = "SEND", t[t.SEARCH = 3] = "SEARCH", t[t.GO = 4] = "GO", t[t.NEXT = 5] = "NEXT";
      }(Be || (Be = {})), h(Be), function (t) {
        t[t.ANY = 0] = "ANY", t[t.EMAIL_ADDR = 1] = "EMAIL_ADDR", t[t.NUMERIC = 2] = "NUMERIC", t[t.PHONE_NUMBER = 3] = "PHONE_NUMBER", t[t.URL = 4] = "URL", t[t.DECIMAL = 5] = "DECIMAL", t[t.SINGLE_LINE = 6] = "SINGLE_LINE";
      }(Ne || (Ne = {})), h(Ne), function (t) {
        t[t.PASSWORD = 0] = "PASSWORD", t[t.SENSITIVE = 1] = "SENSITIVE", t[t.INITIAL_CAPS_WORD = 2] = "INITIAL_CAPS_WORD", t[t.INITIAL_CAPS_SENTENCE = 3] = "INITIAL_CAPS_SENTENCE", t[t.INITIAL_CAPS_ALL_CHARACTERS = 4] = "INITIAL_CAPS_ALL_CHARACTERS", t[t.DEFAULT = 5] = "DEFAULT";
      }(He || (He = {})), h(He);

      var ke,
          Ve,
          Fe,
          Ge,
          je,
          Ue,
          We,
          Ze,
          Ye,
          Xe,
          qe,
          Ke,
          Qe,
          $e,
          Je,
          ti,
          ei,
          ii,
          oi,
          ni,
          ri,
          si,
          ai,
          hi,
          li,
          ci,
          ui,
          _i,
          pi,
          di,
          gi,
          fi,
          yi,
          bi,
          Ti,
          mi,
          vi,
          Ci,
          Si,
          Ei,
          Oi,
          Ai,
          wi,
          Li,
          Di,
          Pi,
          Ii,
          zi,
          Ri,
          xi,
          Bi,
          Ni,
          Hi,
          Mi,
          ki,
          Vi,
          Fi,
          Gi,
          ji,
          Ui,
          Wi,
          Zi = function () {
        function t() {
          this._editing = !1, this._delegate = null;
        }

        var e = t.prototype;
        return e.init = function () {}, e.onEnable = function () {}, e.update = function () {}, e.onDisable = function () {
          this._editing && this.endEditing();
        }, e.clear = function () {
          this._delegate = null;
        }, e.setTabIndex = function () {}, e.setSize = function () {}, e.setFocus = function (t) {
          t ? this.beginEditing() : this.endEditing();
        }, e.isFocused = function () {
          return this._editing;
        }, e.beginEditing = function () {}, e.endEditing = function () {}, t;
      }(),
          Yi = new j(),
          Xi = new j(),
          qi = new I(),
          Ki = null,
          Qi = 0,
          $i = function (t) {
        function e() {
          for (var e, i = arguments.length, o = new Array(i), n = 0; n < i; n++) {
            o[n] = arguments[n];
          }

          return (e = t.call.apply(t, [this].concat(o)) || this)._delegate = null, e._inputMode = -1, e._inputFlag = -1, e._returnType = -1, e.__eventListeners = {}, e.__autoResize = !1, e.__orientationChanged = void 0, e._edTxt = null, e._isTextArea = !1, e._textLabelFont = null, e._textLabelFontSize = null, e._textLabelFontColor = null, e._textLabelAlign = null, e._placeholderLabelFont = null, e._placeholderLabelFontSize = null, e._placeholderLabelFontColor = null, e._placeholderLabelAlign = null, e._placeholderLineHeight = null, e._placeholderStyleSheet = null, e._domId = "EditBoxId_" + ++Qi, e;
        }

        i(e, t);
        var o = e.prototype;
        return o.init = function (t) {
          t && (this._delegate = t, t.inputMode === Ne.ANY ? this._createTextArea() : this._createInput(), Me.add(this), this.setTabIndex(t.tabIndex), this._initStyleSheet(), this._registerEventListeners(), this._addDomToGameContainer());
        }, o.clear = function () {
          this._removeEventListeners(), this._removeDomFromGameContainer(), Me.remove(this), Ki === this && (Ki = null), this._delegate = null;
        }, o.update = function () {
          this._updateMatrix();
        }, o.setTabIndex = function (t) {
          this._edTxt.tabIndex = t, Me.resort();
        }, o.setSize = function (t, e) {
          var i = this._edTxt;
          i && (i.style.width = t + "px", i.style.height = e + "px");
        }, o.beginEditing = function () {
          Ki && Ki !== this && Ki.setFocus(!1), this._editing = !0, Ki = this, this._delegate._editBoxEditingDidBegan(), this._showDom(), this._edTxt.focus();
        }, o.endEditing = function () {
          this._edTxt.blur();
        }, o._createInput = function () {
          this._isTextArea = !1, this._edTxt = document.createElement("input");
        }, o._createTextArea = function () {
          this._isTextArea = !0, this._edTxt = document.createElement("textarea");
        }, o._addDomToGameContainer = function () {
          r.GAME_VIEW && this._edTxt ? (r.gameView.container.appendChild(this._edTxt), r.gameView.head.appendChild(this._placeholderStyleSheet)) : ht.container && this._edTxt && (ht.container.appendChild(this._edTxt), document.head.appendChild(this._placeholderStyleSheet));
        }, o._removeDomFromGameContainer = function () {
          (r.GAME_VIEW ? l(r.gameView.container, this._edTxt) : l(ht.container, this._edTxt)) && this._edTxt && (r.GAME_VIEW ? r.gameView.container.removeChild(this._edTxt) : ht.container.removeChild(this._edTxt)), (r.GAME_VIEW ? l(r.gameView.head, this._placeholderStyleSheet) : l(document.head, this._placeholderStyleSheet)) && (r.GAME_VIEW ? r.gameView.head.removeChild(this._placeholderStyleSheet) : document.head.removeChild(this._placeholderStyleSheet)), this._edTxt = null, this._placeholderStyleSheet = null;
        }, o._showDom = function () {
          this._updateMaxLength(), this._updateInputType(), this._updateStyleSheet(), this._edTxt && this._delegate && (this._edTxt.style.display = "", this._delegate._hideLabels()), U.isMobile && this._showDomOnMobile();
        }, o._hideDom = function () {
          var t = this._edTxt;
          t && this._delegate && (t.style.display = "none", this._delegate._showLabels()), U.isMobile && this._hideDomOnMobile();
        }, o._showDomOnMobile = function () {
          U.os !== c.ANDROID && U.os !== c.OHOS || (W.handleResizeEvent = !1, this._adjustWindowScroll());
        }, o._hideDomOnMobile = function () {
          U.os !== c.ANDROID && U.os !== c.OHOS || (W.handleResizeEvent = !0), this._scrollBackWindow();
        }, o._adjustWindowScroll = function () {
          var t = this;
          setTimeout(function () {
            window.scrollY < 40 && t._edTxt.scrollIntoView({
              block: "start",
              inline: "nearest",
              behavior: "smooth"
            });
          }, 400);
        }, o._scrollBackWindow = function () {
          setTimeout(function () {
            U.browserType !== u.WECHAT || U.os !== c.IOS ? window.scrollTo(0, 0) : window.top && window.top.scrollTo(0, 0);
          }, 400);
        }, o._updateMatrix = function () {
          if (this._edTxt) {
            var t = this._delegate.node,
                e = lt.getScaleX(),
                i = lt.getScaleY(),
                o = 1,
                n = 1;
            r.GAME_VIEW && (o = r.gameView.canvas.width / r.game.canvas.width, n = r.gameView.canvas.height / r.game.canvas.height), e *= o, i *= n;
            var s = lt.getViewportRect(),
                a = W.devicePixelRatio;
            t.getWorldMatrix(Yi);
            var h = t._uiProps.uiTransformComp;

            if (h && I.set(qi, -h.anchorX * h.width, -h.anchorY * h.height, qi.z), j.transform(Yi, Yi, qi), t._uiProps.uiTransformComp) {
              var l = pt.root.batcher2D.getFirstRenderCamera(t);

              if (l) {
                l.node.getWorldRT(Xi);
                var c = Xi.m12,
                    u = Xi.m13,
                    _ = ct.center;
                Xi.m12 = _.x - (Xi.m00 * c + Xi.m04 * u), Xi.m13 = _.y - (Xi.m01 * c + Xi.m05 * u), j.multiply(Xi, Xi, Yi), e /= a, i /= a;
                var p = r.GAME_VIEW ? r.gameView.container : ht.container,
                    d = Xi.m00 * e,
                    g = Yi.m01,
                    f = Yi.m04,
                    y = Xi.m05 * i,
                    b = parseInt(p && p.style.paddingLeft || "0");
                b += s.x * o / a;
                var T = parseInt(p && p.style.paddingBottom || "0");
                T += s.y / a;
                var m = "matrix(" + d + "," + -g + "," + -f + "," + y + "," + (Xi.m12 * e + b) + "," + -(Xi.m13 * i + T) + ")";
                this._edTxt.style.transform = m, this._edTxt.style["-webkit-transform"] = m, this._edTxt.style["transform-origin"] = "0px 100% 0px", this._edTxt.style["-webkit-transform-origin"] = "0px 100% 0px";
              }
            }
          }
        }, o._updateInputType = function () {
          var t = this._delegate,
              e = t.inputMode,
              i = t.inputFlag,
              o = t.returnType,
              n = this._edTxt;

          if (this._inputMode !== e || this._inputFlag !== i || this._returnType !== o) {
            if (this._inputMode = e, this._inputFlag = i, this._returnType = o, this._isTextArea) {
              var r = "none";
              return i === He.INITIAL_CAPS_ALL_CHARACTERS ? r = "uppercase" : i === He.INITIAL_CAPS_WORD && (r = "capitalize"), void (n.style.textTransform = r);
            }

            if (n = n, i === He.PASSWORD) return n.type = "password", void (n.style.textTransform = "none");
            var s = n.type;
            e === Ne.EMAIL_ADDR ? s = "email" : e === Ne.NUMERIC || e === Ne.DECIMAL ? s = "number" : e === Ne.PHONE_NUMBER ? (s = "number", n.pattern = "[0-9]*", n.addEventListener("wheel", function () {
              return !1;
            })) : e === Ne.URL ? s = "url" : (s = "text", o === Be.SEARCH && (s = "search")), n.type = s;
            var a = "none";
            i === He.INITIAL_CAPS_ALL_CHARACTERS ? a = "uppercase" : i === He.INITIAL_CAPS_WORD && (a = "capitalize"), n.style.textTransform = a;
          }
        }, o._updateMaxLength = function () {
          var t = this._delegate.maxLength;
          t < 0 && (t = 65535), this._edTxt.maxLength = t;
        }, o._initStyleSheet = function () {
          if (this._edTxt) {
            var t = this._edTxt;
            t.style.color = "#000000", t.style.border = "0px", t.style.background = "transparent", t.style.width = "100%", t.style.height = "100%", t.style.outline = "medium", t.style.padding = "0", t.style.textTransform = "none", t.style.display = "none", t.style.position = "absolute", t.style.bottom = "0px", t.style.left = "2px", t.className = "cocosEditBox", t.style.fontFamily = "Arial", t.id = this._domId, this._isTextArea ? (t.style.resize = "none", t.style.overflowY = "scroll") : ((t = t).type = "text", t.style["-moz-appearance"] = "textfield"), this._placeholderStyleSheet = document.createElement("style");
          }
        }, o._updateStyleSheet = function () {
          var t = this._delegate,
              e = this._edTxt;
          e && t && (e.value = t.string, e.placeholder = t.placeholder, this._updateTextLabel(t.textLabel), this._updatePlaceholderLabel(t.placeholderLabel));
        }, o._updateTextLabel = function (t) {
          if (t) {
            var e = t.font;
            e = !e || e instanceof bt ? t.fontFamily : e._fontFamily;
            var i = t.fontSize * t.node.scale.y;

            if ((this._textLabelFont !== e || this._textLabelFontSize !== i || this._textLabelFontColor !== t.fontColor || this._textLabelAlign !== t.horizontalAlign) && (this._textLabelFont = e, this._textLabelFontSize = i, this._textLabelFontColor = t.fontColor, this._textLabelAlign = t.horizontalAlign, this._edTxt)) {
              var o = this._edTxt;

              switch (o.style.fontSize = i + "px", o.style.color = t.color.toCSS(), o.style.fontFamily = e, t.horizontalAlign) {
                case Tt.HorizontalAlign.LEFT:
                  o.style.textAlign = "left";
                  break;

                case Tt.HorizontalAlign.CENTER:
                  o.style.textAlign = "center";
                  break;

                case Tt.HorizontalAlign.RIGHT:
                  o.style.textAlign = "right";
              }
            }
          }
        }, o._updatePlaceholderLabel = function (t) {
          if (t) {
            var e = t.font;
            e = !e || e instanceof bt ? t.fontFamily : t.font._fontFamily;
            var i = t.fontSize * t.node.scale.y;

            if (this._placeholderLabelFont !== e || this._placeholderLabelFontSize !== i || this._placeholderLabelFontColor !== t.fontColor || this._placeholderLabelAlign !== t.horizontalAlign || this._placeholderLineHeight !== t.fontSize) {
              this._placeholderLabelFont = e, this._placeholderLabelFontSize = i, this._placeholderLabelFontColor = t.fontColor, this._placeholderLabelAlign = t.horizontalAlign, this._placeholderLineHeight = t.fontSize;
              var o = this._placeholderStyleSheet,
                  n = t.color.toCSS(),
                  r = t.fontSize,
                  s = "";

              switch (t.horizontalAlign) {
                case Tt.HorizontalAlign.LEFT:
                  s = "left";
                  break;

                case Tt.HorizontalAlign.CENTER:
                  s = "center";
                  break;

                case Tt.HorizontalAlign.RIGHT:
                  s = "right";
              }

              o.innerHTML = "#" + this._domId + "::-webkit-input-placeholder{text-transform: initial;-family: " + e + ";font-size: " + i + "px;color: " + n + ";line-height: " + r + "px;text-align: " + s + ";}#" + this._domId + "::-moz-placeholder{text-transform: initial;-family: " + e + ";font-size: " + i + "px;color: " + n + ";line-height: " + r + "px;text-align: " + s + ";}#" + this._domId + "::-ms-input-placeholder{text-transform: initial;-family: " + e + ";font-size: " + i + "px;color: " + n + ";line-height: " + r + "px;text-align: " + s + ";}", U.browserType === u.EDGE && (o.innerHTML += "#" + this._domId + "::-ms-clear{display: none;}");
            }
          }
        }, o._registerEventListeners = function () {
          var t = this;

          if (this._edTxt) {
            var e = this._edTxt,
                i = !1,
                o = this.__eventListeners;
            o.compositionStart = function () {
              i = !0;
            }, o.compositionEnd = function () {
              i = !1, t._delegate._editBoxTextChanged(e.value);
            }, o.onInput = function () {
              if (!i) {
                var o = t._delegate,
                    n = o.maxLength;
                n >= 0 && (e.value = e.value.slice(0, n)), o._editBoxTextChanged(e.value);
              }
            }, o.onClick = function () {
              t._editing && U.isMobile && t._adjustWindowScroll();
            }, o.onKeydown = function (i) {
              i.keyCode === Z.ENTER ? (i.propagationStopped = !0, t._delegate._editBoxEditingReturn(), t._isTextArea || e.blur()) : i.keyCode === Z.TAB && (i.propagationStopped = !0, i.preventDefault(), Me.next(t));
            }, o.onBlur = function () {
              U.isMobile && i && o.compositionEnd(), t._editing = !1, Ki = null, t._hideDom(), t._delegate._editBoxEditingDidEnded();
            }, e.addEventListener("compositionstart", o.compositionStart), e.addEventListener("compositionend", o.compositionEnd), e.addEventListener("input", o.onInput), e.addEventListener("keydown", o.onKeydown), e.addEventListener("blur", o.onBlur), e.addEventListener("touchstart", o.onClick);
          }
        }, o._removeEventListeners = function () {
          if (this._edTxt) {
            var t = this._edTxt,
                e = this.__eventListeners;
            t.removeEventListener("compositionstart", e.compositionStart), t.removeEventListener("compositionend", e.compositionEnd), t.removeEventListener("input", e.onInput), t.removeEventListener("keydown", e.onKeydown), t.removeEventListener("blur", e.onBlur), t.removeEventListener("touchstart", e.onClick), e.compositionStart = null, e.compositionEnd = null, e.onInput = null, e.onKeydown = null, e.onBlur = null, e.onClick = null;
          }
        }, e;
      }(Zi);

      !function (t) {
        t.EDITING_DID_BEGAN = "editing-did-began", t.EDITING_DID_ENDED = "editing-did-ended", t.TEXT_CHANGED = "text-changed", t.EDITING_RETURN = "editing-return";
      }(Wi || (Wi = {}));

      var Ji,
          to,
          eo,
          io,
          oo,
          no,
          ro,
          so,
          ao,
          ho,
          lo,
          co,
          uo,
          _o,
          po,
          go,
          fo,
          yo,
          bo,
          To,
          mo,
          vo,
          Co,
          So,
          Eo,
          Oo,
          Ao,
          wo,
          Lo,
          Do,
          Po,
          Io,
          zo,
          Ro,
          xo,
          Bo,
          No,
          Ho,
          Mo,
          ko,
          Vo,
          Fo,
          Go,
          jo,
          Uo,
          Wo,
          Zo,
          Yo,
          Xo,
          qo,
          Ko,
          Qo,
          $o,
          Jo,
          tn,
          en,
          on,
          nn,
          rn,
          sn,
          an,
          hn = function (e) {
        return t({
          EditBox: e,
          EditBoxComponent: e
        }), e;
      }((ke = O("cc.EditBox"), Ve = R(), Fe = x(110), Ge = B(), je = N(Ct), Ue = H(), We = M(), Ze = H(), Ye = M(), Xe = A(Tt), qe = H(), Ke = M(), Qe = A(Tt), $e = H(), Je = M(), ti = A(ft), ei = H(), ii = M(), oi = A(He), ni = H(), ri = M(), si = A(Ne), ai = H(), hi = M(), li = A(Be), ci = H(), ui = M(), _i = H(), pi = M(), di = H(), gi = M(), fi = A([_t]), yi = H(), bi = M(), Ti = A([_t]), mi = H(), vi = M(), Ci = A([_t]), Si = H(), Ei = M(), Oi = A([_t]), Ai = H(), wi = M(), ke(Li = Ve(Li = Fe(Li = Ge(Li = je(Li = L((Ui = ji = function (t) {
        function e() {
          for (var e, i = arguments.length, o = new Array(i), n = 0; n < i; n++) {
            o[n] = arguments[n];
          }

          return e = t.call.apply(t, [this].concat(o)) || this, s(e, "editingDidBegan", Pi, a(e)), s(e, "textChanged", Ii, a(e)), s(e, "editingDidEnded", zi, a(e)), s(e, "editingReturn", Ri, a(e)), e._impl = null, e._background = null, s(e, "_textLabel", xi, a(e)), s(e, "_placeholderLabel", Bi, a(e)), s(e, "_returnType", Ni, a(e)), s(e, "_string", Hi, a(e)), s(e, "_tabIndex", Mi, a(e)), s(e, "_backgroundImage", ki, a(e)), s(e, "_inputFlag", Vi, a(e)), s(e, "_inputMode", Fi, a(e)), s(e, "_maxLength", Gi, a(e)), e._isLabelVisible = !1, e;
        }

        i(e, t);
        var n = e.prototype;
        return n.__preload = function () {
          this._init();
        }, n.onEnable = function () {
          this._registerEvent(), this._ensureBackgroundSprite(), this._impl && this._impl.onEnable();
        }, n.update = function () {
          this._impl && this._impl.update();
        }, n.onDisable = function () {
          this._unregisterEvent(), this._unregisterBackgroundEvent(), this._impl && this._impl.onDisable();
        }, n.onDestroy = function () {
          this._impl && this._impl.clear();
        }, n.setFocus = function () {
          this._impl && this._impl.setFocus(!0);
        }, n.focus = function () {
          this._impl && this._impl.setFocus(!0);
        }, n.blur = function () {
          this._impl && this._impl.setFocus(!1);
        }, n.isFocused = function () {
          return !!this._impl && this._impl.isFocused();
        }, n._editBoxEditingDidBegan = function () {
          _t.emitEvents(this.editingDidBegan, this), this.node.emit(Wi.EDITING_DID_BEGAN, this);
        }, n._editBoxEditingDidEnded = function () {
          _t.emitEvents(this.editingDidEnded, this), this.node.emit(Wi.EDITING_DID_ENDED, this);
        }, n._editBoxTextChanged = function (t) {
          t = this._updateLabelStringStyle(t, !0), this.string = t, _t.emitEvents(this.textChanged, t, this), this.node.emit(Wi.TEXT_CHANGED, this);
        }, n._editBoxEditingReturn = function () {
          _t.emitEvents(this.editingReturn, this), this.node.emit(Wi.EDITING_RETURN, this);
        }, n._showLabels = function () {
          this._isLabelVisible = !0, this._updateLabels();
        }, n._hideLabels = function () {
          this._isLabelVisible = !1, this._textLabel && (this._textLabel.node.active = !1), this._placeholderLabel && (this._placeholderLabel.node.active = !1);
        }, n._onTouchBegan = function (t) {
          t.propagationStopped = !0;
        }, n._onTouchCancel = function (t) {
          t.propagationStopped = !0;
        }, n._onTouchEnded = function (t) {
          this._impl && this._impl.beginEditing(), t.propagationStopped = !0;
        }, n._init = function () {
          this._updatePlaceholderLabel(), this._updateTextLabel(), this._isLabelVisible = !0, this.node.on(P.SIZE_CHANGED, this._resizeChildNodes, this), (this._impl = new e._EditBoxImpl()).init(this), this._updateString(this._string), this._syncSize();
        }, n._ensureBackgroundSprite = function () {
          if (!this._background) {
            var t = this.node.getComponent(yt);
            t || (t = this.node.addComponent(yt)), t !== this._background && (t.type = yt.Type.SLICED, t.spriteFrame = this._backgroundImage, this._background = t, this._registerBackgroundEvent());
          }
        }, n._updateTextLabel = function () {
          var t = this._textLabel;

          if (!t) {
            var e = this.node.getChildByName("TEXT_LABEL");
            e || ((e = new w("TEXT_LABEL")).layer = this.node.layer), (t = e.getComponent(Tt)) || (t = e.addComponent(Tt)), e.parent = this.node, this._textLabel = t;
          }

          this._textLabel.node._uiProps.uiTransformComp.setAnchorPoint(0, 1), t.overflow = Tt.Overflow.CLAMP, this._inputMode === Ne.ANY ? (t.verticalAlign = mt.TOP, t.enableWrapText = !0) : t.enableWrapText = !1, t.string = this._updateLabelStringStyle(this._string);
        }, n._updatePlaceholderLabel = function () {
          var t = this._placeholderLabel;

          if (!t) {
            var e = this.node.getChildByName("PLACEHOLDER_LABEL");
            e || ((e = new w("PLACEHOLDER_LABEL")).layer = this.node.layer), (t = e.getComponent(Tt)) || (t = e.addComponent(Tt)), e.parent = this.node, this._placeholderLabel = t;
          }

          this._placeholderLabel.node._uiProps.uiTransformComp.setAnchorPoint(0, 1), this._inputMode === Ne.ANY ? (t.verticalAlign = mt.TOP, t.enableWrapText = !0) : t.enableWrapText = !1, t.string = this.placeholder;
        }, n._syncSize = function () {
          var t = this.node._uiProps.uiTransformComp,
              e = t.contentSize;

          if (this._background) {
            var i = this._background.node._uiProps.uiTransformComp;
            i.anchorPoint = t.anchorPoint, i.setContentSize(e);
          }

          this._updateLabelPosition(e), this._impl && this._impl.setSize(e.width, e.height);
        }, n._updateLabels = function () {
          if (this._isLabelVisible) {
            var t = this._string;
            this._textLabel && (this._textLabel.node.active = "" !== t), this._placeholderLabel && (this._placeholderLabel.node.active = "" === t);
          }
        }, n._updateString = function (t) {
          var e = this._textLabel;

          if (e) {
            var i = t;
            i && (i = this._updateLabelStringStyle(i)), e.string = i, this._updateLabels();
          }
        }, n._updateLabelStringStyle = function (t, e) {
          void 0 === e && (e = !1);
          var i,
              o = this._inputFlag;
          if (e || o !== He.PASSWORD) o === He.INITIAL_CAPS_ALL_CHARACTERS ? t = t.toUpperCase() : o === He.INITIAL_CAPS_WORD ? t = t.replace(/(?:^|\s)\S/g, function (t) {
            return t.toUpperCase();
          }) : o === He.INITIAL_CAPS_SENTENCE && (t = (i = t).charAt(0).toUpperCase() + i.slice(1));else {
            for (var n = "", r = t.length, s = 0; s < r; ++s) {
              n += "";
            }

            t = n;
          }
          return t;
        }, n._registerEvent = function () {
          this.node.on(P.TOUCH_START, this._onTouchBegan, this), this.node.on(P.TOUCH_END, this._onTouchEnded, this);
        }, n._unregisterEvent = function () {
          this.node.off(P.TOUCH_START, this._onTouchBegan, this), this.node.off(P.TOUCH_END, this._onTouchEnded, this);
        }, n._onBackgroundSpriteFrameChanged = function () {
          this._background && (this.backgroundImage = this._background.spriteFrame);
        }, n._registerBackgroundEvent = function () {
          var t = this._background && this._background.node;
          null == t || t.on(yt.EventType.SPRITE_FRAME_CHANGED, this._onBackgroundSpriteFrameChanged, this);
        }, n._unregisterBackgroundEvent = function () {
          var t = this._background && this._background.node;
          null == t || t.off(yt.EventType.SPRITE_FRAME_CHANGED, this._onBackgroundSpriteFrameChanged, this);
        }, n._updateLabelPosition = function (t) {
          var e = this.node._uiProps.uiTransformComp,
              i = -e.anchorX * e.width,
              o = -e.anchorY * e.height,
              n = this._placeholderLabel,
              r = this._textLabel;
          r && (r.node._uiProps.uiTransformComp.setContentSize(t.width - 2, t.height), r.node.setPosition(i + 2, o + t.height, r.node.position.z), this._inputMode === Ne.ANY && (r.verticalAlign = mt.TOP), r.enableWrapText = this._inputMode === Ne.ANY), n && (n.node._uiProps.uiTransformComp.setContentSize(t.width - 2, t.height), n.lineHeight = t.height, n.node.setPosition(i + 2, o + t.height, n.node.position.z), this._inputMode === Ne.ANY && (n.verticalAlign = mt.TOP), n.enableWrapText = this._inputMode === Ne.ANY);
        }, n._resizeChildNodes = function () {
          var t = this.node._uiProps.uiTransformComp,
              e = this._textLabel && this._textLabel.node;
          e && (e.setPosition(-t.width / 2, t.height / 2, e.position.z), e._uiProps.uiTransformComp.setContentSize(t.contentSize));
          var i = this._placeholderLabel && this._placeholderLabel.node;
          i && (i.setPosition(-t.width / 2, t.height / 2, i.position.z), i._uiProps.uiTransformComp.setContentSize(t.contentSize));
          var o = this._background && this._background.node;
          o && o._uiProps.uiTransformComp.setContentSize(t.contentSize), this._syncSize();
        }, o(e, [{
          key: "string",
          get: function get() {
            return this._string;
          },
          set: function set(t) {
            this._maxLength >= 0 && t.length >= this._maxLength && (t = t.slice(0, this._maxLength)), this._string !== t && (this._string = t, this._updateString(t));
          }
        }, {
          key: "placeholder",
          get: function get() {
            return this._placeholderLabel ? this._placeholderLabel.string : "";
          },
          set: function set(t) {
            this._placeholderLabel && (this._placeholderLabel.string = t);
          }
        }, {
          key: "textLabel",
          get: function get() {
            return this._textLabel;
          },
          set: function set(t) {
            this._textLabel !== t && (this._textLabel = t, this._textLabel && (this._updateTextLabel(), this._updateLabels()));
          }
        }, {
          key: "placeholderLabel",
          get: function get() {
            return this._placeholderLabel;
          },
          set: function set(t) {
            this._placeholderLabel !== t && (this._placeholderLabel = t, this._placeholderLabel && (this._updatePlaceholderLabel(), this._updateLabels()));
          }
        }, {
          key: "backgroundImage",
          get: function get() {
            return this._backgroundImage;
          },
          set: function set(t) {
            this._backgroundImage !== t && (this._backgroundImage = t, this._ensureBackgroundSprite(), this._background.spriteFrame = t);
          }
        }, {
          key: "inputFlag",
          get: function get() {
            return this._inputFlag;
          },
          set: function set(t) {
            this._inputFlag !== t && (this._inputFlag = t, this._updateString(this._string));
          }
        }, {
          key: "inputMode",
          get: function get() {
            return this._inputMode;
          },
          set: function set(t) {
            this._inputMode !== t && (this._inputMode = t, this._updateTextLabel(), this._updatePlaceholderLabel());
          }
        }, {
          key: "returnType",
          get: function get() {
            return this._returnType;
          },
          set: function set(t) {
            this._returnType = t;
          }
        }, {
          key: "maxLength",
          get: function get() {
            return this._maxLength;
          },
          set: function set(t) {
            this._maxLength = t;
          }
        }, {
          key: "tabIndex",
          get: function get() {
            return this._tabIndex;
          },
          set: function set(t) {
            this._tabIndex !== t && (this._tabIndex = t, this._impl && this._impl.setTabIndex(t));
          }
        }]), e;
      }(F), ji._EditBoxImpl = Zi, ji.KeyboardReturnType = Be, ji.InputFlag = He, ji.InputMode = Ne, ji.EventType = Wi, n((Di = Ui).prototype, "string", [Ue, We], Object.getOwnPropertyDescriptor(Di.prototype, "string"), Di.prototype), n(Di.prototype, "placeholder", [Ze, Ye], Object.getOwnPropertyDescriptor(Di.prototype, "placeholder"), Di.prototype), n(Di.prototype, "textLabel", [Xe, qe, Ke], Object.getOwnPropertyDescriptor(Di.prototype, "textLabel"), Di.prototype), n(Di.prototype, "placeholderLabel", [Qe, $e, Je], Object.getOwnPropertyDescriptor(Di.prototype, "placeholderLabel"), Di.prototype), n(Di.prototype, "backgroundImage", [ti, ei, ii], Object.getOwnPropertyDescriptor(Di.prototype, "backgroundImage"), Di.prototype), n(Di.prototype, "inputFlag", [oi, ni, ri], Object.getOwnPropertyDescriptor(Di.prototype, "inputFlag"), Di.prototype), n(Di.prototype, "inputMode", [si, ai, hi], Object.getOwnPropertyDescriptor(Di.prototype, "inputMode"), Di.prototype), n(Di.prototype, "returnType", [li, ci, ui], Object.getOwnPropertyDescriptor(Di.prototype, "returnType"), Di.prototype), n(Di.prototype, "maxLength", [_i, pi], Object.getOwnPropertyDescriptor(Di.prototype, "maxLength"), Di.prototype), n(Di.prototype, "tabIndex", [di, gi], Object.getOwnPropertyDescriptor(Di.prototype, "tabIndex"), Di.prototype), Pi = n(Di.prototype, "editingDidBegan", [fi, G, yi, bi], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return [];
        }
      }), Ii = n(Di.prototype, "textChanged", [Ti, G, mi, vi], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return [];
        }
      }), zi = n(Di.prototype, "editingDidEnded", [Ci, G, Si, Ei], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return [];
        }
      }), Ri = n(Di.prototype, "editingReturn", [Oi, G, Ai, wi], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return [];
        }
      }), xi = n(Di.prototype, "_textLabel", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return null;
        }
      }), Bi = n(Di.prototype, "_placeholderLabel", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return null;
        }
      }), Ni = n(Di.prototype, "_returnType", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return Be.DEFAULT;
        }
      }), Hi = n(Di.prototype, "_string", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return "";
        }
      }), Mi = n(Di.prototype, "_tabIndex", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 0;
        }
      }), ki = n(Di.prototype, "_backgroundImage", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return null;
        }
      }), Vi = n(Di.prototype, "_inputFlag", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return He.DEFAULT;
        }
      }), Fi = n(Di.prototype, "_inputMode", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return Ne.ANY;
        }
      }), Gi = n(Di.prototype, "_maxLength", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 20;
        }
      }), Li = Di)) || Li) || Li) || Li) || Li) || Li) || Li));

      "object" != (typeof window === "undefined" ? "undefined" : _typeof2(window)) || "object" != (typeof document === "undefined" ? "undefined" : _typeof2(document)) || _ || p || d || (hn._EditBoxImpl = $i), r.internal.EditBox = hn, function (t) {
        t[t.NONE = 0] = "NONE", t[t.HORIZONTAL = 1] = "HORIZONTAL", t[t.VERTICAL = 2] = "VERTICAL", t[t.GRID = 3] = "GRID";
      }(en || (en = {})), e(en), function (t) {
        t[t.NONE = 0] = "NONE", t[t.CONTAINER = 1] = "CONTAINER", t[t.CHILDREN = 2] = "CHILDREN";
      }(on || (on = {})), e(on), function (t) {
        t[t.HORIZONTAL = 0] = "HORIZONTAL", t[t.VERTICAL = 1] = "VERTICAL";
      }(nn || (nn = {})), e(nn), function (t) {
        t[t.BOTTOM_TO_TOP = 0] = "BOTTOM_TO_TOP", t[t.TOP_TO_BOTTOM = 1] = "TOP_TO_BOTTOM";
      }(rn || (rn = {})), e(rn), function (t) {
        t[t.LEFT_TO_RIGHT = 0] = "LEFT_TO_RIGHT", t[t.RIGHT_TO_LEFT = 1] = "RIGHT_TO_LEFT";
      }(sn || (sn = {})), e(sn), function (t) {
        t[t.NONE = 0] = "NONE", t[t.FIXED_ROW = 1] = "FIXED_ROW", t[t.FIXED_COL = 2] = "FIXED_COL";
      }(an || (an = {})), e(an);

      var ln,
          cn,
          un,
          _n,
          pn,
          dn,
          gn,
          fn,
          yn,
          bn,
          Tn,
          mn,
          vn,
          Cn,
          Sn,
          En,
          On,
          An,
          wn,
          Ln,
          Dn,
          Pn,
          In,
          zn = new I(),
          Rn = function (e) {
        return t({
          Layout: e,
          LayoutComponent: e
        }), e;
      }((Ji = O("cc.Layout"), to = R(), eo = x(110), io = B(), oo = N(Ct), no = X(), ro = M(), so = X(), ao = M(), ho = A(en), lo = H(), co = M(), uo = A(on), _o = X(), po = M(), go = X(), fo = M(), yo = A(nn), bo = M(), To = M(), mo = M(), vo = M(), Co = M(), So = M(), Eo = M(), Oo = A(rn), Ao = M(), wo = A(sn), Lo = M(), Do = A(an), Po = X(), Io = M(), zo = X(), Ro = M(), xo = M(), Ji(Bo = to(Bo = eo(Bo = io(Bo = oo(Bo = L((tn = Jo = function (t) {
        function e() {
          for (var e, i = arguments.length, o = new Array(i), n = 0; n < i; n++) {
            o[n] = arguments[n];
          }

          return e = t.call.apply(t, [this].concat(o)) || this, s(e, "_resizeMode", Ho, a(e)), s(e, "_layoutType", Mo, a(e)), s(e, "_cellSize", ko, a(e)), s(e, "_startAxis", Vo, a(e)), s(e, "_paddingLeft", Fo, a(e)), s(e, "_paddingRight", Go, a(e)), s(e, "_paddingTop", jo, a(e)), s(e, "_paddingBottom", Uo, a(e)), s(e, "_spacingX", Wo, a(e)), s(e, "_spacingY", Zo, a(e)), s(e, "_verticalDirection", Yo, a(e)), s(e, "_horizontalDirection", Xo, a(e)), s(e, "_constraint", qo, a(e)), s(e, "_constraintNum", Ko, a(e)), s(e, "_affectedByScale", Qo, a(e)), s(e, "_isAlign", $o, a(e)), e._layoutSize = new Y(300, 200), e._layoutDirty = !0, e._childrenDirty = !1, e._usefulLayoutObj = [], e._init = !1, e;
        }

        i(e, t);
        var n = e.prototype;
        return n.updateLayout = function (t) {
          void 0 === t && (t = !1), (this._layoutDirty || t) && this.node.children.length > 0 && (this._doLayout(), this._layoutDirty = !1);
        }, n.onEnable = function () {
          this._addEventListeners();

          var t = this.node._uiProps.uiTransformComp;
          t.contentSize.equals(Y.ZERO) && t.setContentSize(this._layoutSize), this._childrenChanged();
        }, n.onDisable = function () {
          this._usefulLayoutObj.length = 0, this._removeEventListeners();
        }, n._checkUsefulObj = function () {
          this._usefulLayoutObj.length = 0;

          for (var t = this.node.children, e = 0; e < t.length; ++e) {
            var i = t[e],
                o = i._uiProps.uiTransformComp;
            i.activeInHierarchy && o && this._usefulLayoutObj.push(o);
          }
        }, n._addEventListeners = function () {
          pt.on(dt.EVENT_AFTER_UPDATE, this.updateLayout, this), this.node.on(P.SIZE_CHANGED, this._resized, this), this.node.on(P.ANCHOR_CHANGED, this._doLayoutDirty, this), this.node.on(P.CHILD_ADDED, this._childAdded, this), this.node.on(P.CHILD_REMOVED, this._childRemoved, this), this.node.on(P.SIBLING_ORDER_CHANGED, this._childrenChanged, this), this.node.on("childrenSiblingOrderChanged", this.updateLayout, this), this._addChildrenEventListeners();
        }, n._removeEventListeners = function () {
          pt.off(dt.EVENT_AFTER_UPDATE, this.updateLayout, this), this.node.off(P.SIZE_CHANGED, this._resized, this), this.node.off(P.ANCHOR_CHANGED, this._doLayoutDirty, this), this.node.off(P.CHILD_ADDED, this._childAdded, this), this.node.off(P.CHILD_REMOVED, this._childRemoved, this), this.node.off(P.SIBLING_ORDER_CHANGED, this._childrenChanged, this), this.node.off("childrenSiblingOrderChanged", this.updateLayout, this), this._removeChildrenEventListeners();
        }, n._addChildrenEventListeners = function () {
          for (var t = this.node.children, e = 0; e < t.length; ++e) {
            var i = t[e];
            i.on(P.SIZE_CHANGED, this._doLayoutDirty, this), i.on(P.TRANSFORM_CHANGED, this._transformDirty, this), i.on(P.ANCHOR_CHANGED, this._doLayoutDirty, this), i.on(P.ACTIVE_IN_HIERARCHY_CHANGED, this._childrenChanged, this);
          }
        }, n._removeChildrenEventListeners = function () {
          for (var t = this.node.children, e = 0; e < t.length; ++e) {
            var i = t[e];
            i.off(P.SIZE_CHANGED, this._doLayoutDirty, this), i.off(P.TRANSFORM_CHANGED, this._transformDirty, this), i.off(P.ANCHOR_CHANGED, this._doLayoutDirty, this), i.off(P.ACTIVE_IN_HIERARCHY_CHANGED, this._childrenChanged, this);
          }
        }, n._childAdded = function (t) {
          t.on(P.SIZE_CHANGED, this._doLayoutDirty, this), t.on(P.TRANSFORM_CHANGED, this._transformDirty, this), t.on(P.ANCHOR_CHANGED, this._doLayoutDirty, this), t.on(P.ACTIVE_IN_HIERARCHY_CHANGED, this._childrenChanged, this), this._childrenChanged();
        }, n._childRemoved = function (t) {
          t.off(P.SIZE_CHANGED, this._doLayoutDirty, this), t.off(P.TRANSFORM_CHANGED, this._transformDirty, this), t.off(P.ANCHOR_CHANGED, this._doLayoutDirty, this), t.off(P.ACTIVE_IN_HIERARCHY_CHANGED, this._childrenChanged, this), this._childrenChanged();
        }, n._resized = function () {
          this._layoutSize.set(this.node._uiProps.uiTransformComp.contentSize), this._doLayoutDirty();
        }, n._doLayoutHorizontally = function (t, e, i, o) {
          var n = this.node._uiProps.uiTransformComp.anchorPoint,
              r = this._getFixedBreakingNum(),
              s = 1,
              a = this._paddingLeft;

          this._horizontalDirection === sn.RIGHT_TO_LEFT && (s = -1, a = this._paddingRight);

          var h = (this._horizontalDirection - n.x) * t + s * a,
              l = h - s * this._spacingX,
              c = 0,
              u = 0,
              _ = 0,
              p = 0,
              d = !1,
              g = this._usefulLayoutObj.length,
              f = this._cellSize.width,
              y = this._getPaddingH();

          this._layoutType !== en.GRID && this._resizeMode === on.CHILDREN && (f = (t - y - (g - 1) * this._spacingX) / g);

          for (var b = this._usefulLayoutObj, T = 0; T < b.length; ++T) {
            var m = b[T],
                v = m.node,
                C = v.scale,
                S = this._getUsedScaleValue(C.x),
                E = this._getUsedScaleValue(C.y);

            this._resizeMode === on.CHILDREN && (m.width = f / S, this._layoutType === en.GRID && (m.height = this._cellSize.height / E));
            var O = Math.abs(this._horizontalDirection - m.anchorX),
                A = m.width * S,
                w = m.height * E;
            w > _ && (p = Math.max(_, p), u = _ || w, _ = w), l += s * (O * A + this._spacingX);
            var L = s * (1 - O) * A;

            if (e) {
              if (r > 0) (d = T / r > 0 && T % r == 0) && (u = _ > w ? _ : u);else if (A > t - y) l > h + s * O * A && (d = !0);else {
                var D = (1 - this._horizontalDirection - n.x) * t,
                    P = l + L + s * (s > 0 ? this._paddingRight : this._paddingLeft);
                d = Math.abs(P) > Math.abs(D);
              }
              d && (l = h + s * O * A, w !== _ && (u = _), c += u + this._spacingY, u = _ = w);
            }

            var I = i(v, m, c);
            o && v.setPosition(l, I), l += L;
          }

          return u = Math.max(u, _), Math.max(p, c + u) + this._getPaddingV();
        }, n._doLayoutVertically = function (t, e, i, o) {
          var n = this.node._uiProps.uiTransformComp.anchorPoint,
              r = this._getFixedBreakingNum(),
              s = 1,
              a = this._paddingBottom;

          this._verticalDirection === rn.TOP_TO_BOTTOM && (s = -1, a = this._paddingTop);

          var h = (this._verticalDirection - n.y) * t + s * a,
              l = h - s * this._spacingY,
              c = 0,
              u = 0,
              _ = 0,
              p = 0,
              d = !1,
              g = this._usefulLayoutObj.length,
              f = this._cellSize.height,
              y = this._getPaddingV();

          this._layoutType !== en.GRID && this._resizeMode === on.CHILDREN && (f = (t - y - (g - 1) * this._spacingY) / g);

          for (var b = this._usefulLayoutObj, T = 0; T < b.length; ++T) {
            var m = b[T],
                v = m.node,
                C = v.scale,
                S = this._getUsedScaleValue(C.x),
                E = this._getUsedScaleValue(C.y);

            this._resizeMode === on.CHILDREN && (m.height = f / E, this._layoutType === en.GRID && (m.width = this._cellSize.width / S));
            var O = Math.abs(this._verticalDirection - m.anchorY),
                A = m.width * S,
                w = m.height * E;
            A > c && (u = Math.max(c, u), _ = c || A, c = A), l += s * (O * w + this._spacingY);
            var L = s * (1 - O) * w;

            if (e) {
              if (r > 0) (d = T / r > 0 && T % r == 0) && (_ = c > w ? c : _);else if (w > t - y) l > h + s * O * w && (d = !0);else {
                var D = (1 - this._verticalDirection - n.y) * t,
                    P = l + L + s * (s > 0 ? this._paddingTop : this._paddingBottom);
                d = Math.abs(P) > Math.abs(D);
              }
              d && (l = h + s * O * w, A !== c && (_ = c), p += _ + this._spacingX, _ = c = A);
            }

            var I = i(v, m, p);
            o && (v.getPosition(zn), v.setPosition(I, l, zn.z)), l += L;
          }

          return _ = Math.max(_, c), Math.max(u, p + _) + this._getPaddingH();
        }, n._doLayoutGridAxisHorizontal = function (t, e) {
          var i = this,
              o = e.width,
              n = 1,
              r = -t.y * e.height,
              s = this._paddingBottom;
          this._verticalDirection === rn.TOP_TO_BOTTOM && (n = -1, r = (1 - t.y) * e.height, s = this._paddingTop);

          var a = function a(t, e, o) {
            return r + n * (o + (1 - e.anchorY) * e.height * i._getUsedScaleValue(t.scale.y) + s);
          },
              h = 0;

          this._resizeMode === on.CONTAINER && (h = this._doLayoutHorizontally(o, !0, a, !1), r = -t.y * h, this._verticalDirection === rn.TOP_TO_BOTTOM && (n = -1, r = (1 - t.y) * h)), this._doLayoutHorizontally(o, !0, a, !0), this._resizeMode === on.CONTAINER && this.node._uiProps.uiTransformComp.setContentSize(o, h);
        }, n._doLayoutGridAxisVertical = function (t, e) {
          var i = this,
              o = e.height,
              n = 1,
              r = -t.x * e.width,
              s = this._paddingLeft;
          this._horizontalDirection === sn.RIGHT_TO_LEFT && (n = -1, r = (1 - t.x) * e.width, s = this._paddingRight);

          var a = function a(t, e, o) {
            return r + n * (o + (1 - e.anchorX) * e.width * i._getUsedScaleValue(t.scale.x) + s);
          },
              h = 0;

          this._resizeMode === on.CONTAINER && (h = this._doLayoutVertically(o, !0, a, !1), r = -t.x * h, this._horizontalDirection === sn.RIGHT_TO_LEFT && (n = -1, r = (1 - t.x) * h)), this._doLayoutVertically(o, !0, a, !0), this._resizeMode === on.CONTAINER && this.node._uiProps.uiTransformComp.setContentSize(h, o);
        }, n._doLayoutGrid = function () {
          var t = this.node._uiProps.uiTransformComp,
              e = t.anchorPoint,
              i = t.contentSize;
          this.startAxis === nn.HORIZONTAL ? this._doLayoutGridAxisHorizontal(e, i) : this.startAxis === nn.VERTICAL && this._doLayoutGridAxisVertical(e, i);
        }, n._getHorizontalBaseWidth = function () {
          var t = this._usefulLayoutObj,
              e = 0,
              i = t.length;

          if (this._resizeMode === on.CONTAINER) {
            for (var o = 0; o < t.length; ++o) {
              var n = t[o],
                  r = n.node.scale;
              e += n.width * this._getUsedScaleValue(r.x);
            }

            e += (i - 1) * this._spacingX + this._getPaddingH();
          } else e = this.node._uiProps.uiTransformComp.width;

          return e;
        }, n._getVerticalBaseHeight = function () {
          var t = this._usefulLayoutObj,
              e = 0,
              i = t.length;

          if (this._resizeMode === on.CONTAINER) {
            for (var o = 0; o < t.length; ++o) {
              var n = t[o],
                  r = n.node.scale;
              e += n.height * this._getUsedScaleValue(r.y);
            }

            e += (i - 1) * this._spacingY + this._getPaddingV();
          } else e = this.node._uiProps.uiTransformComp.height;

          return e;
        }, n._doLayout = function () {
          var t = this;

          if (this._init && !this._childrenDirty || (this._checkUsefulObj(), this._init = !0, this._childrenDirty = !1), this._layoutType === en.HORIZONTAL) {
            var e = this._getHorizontalBaseWidth();

            this._doLayoutHorizontally(e, !1, function (e) {
              return (t._isAlign ? I.ZERO : e.position).y;
            }, !0), this.node._uiProps.uiTransformComp.width = e;
          } else if (this._layoutType === en.VERTICAL) {
            var i = this._getVerticalBaseHeight();

            this._doLayoutVertically(i, !1, function (e) {
              return (t._isAlign ? I.ZERO : e.position).x;
            }, !0), this.node._uiProps.uiTransformComp.height = i;
          } else this._layoutType === en.GRID && this._doLayoutGrid();
        }, n._getUsedScaleValue = function (t) {
          return this._affectedByScale ? Math.abs(t) : 1;
        }, n._transformDirty = function (t) {
          t & z.SCALE && t & z.POSITION && this._affectedByScale && this._doLayoutDirty();
        }, n._doLayoutDirty = function () {
          this._layoutDirty = !0;
        }, n._childrenChanged = function () {
          this._childrenDirty = !0, this._doLayoutDirty();
        }, n._getPaddingH = function () {
          return this._paddingLeft + this._paddingRight;
        }, n._getPaddingV = function () {
          return this._paddingTop + this._paddingBottom;
        }, n._getFixedBreakingNum = function () {
          if (this._layoutType !== en.GRID || this._constraint === an.NONE || this._constraintNum <= 0) return 0;
          var t = this._constraint === an.FIXED_ROW ? Math.ceil(this._usefulLayoutObj.length / this._constraintNum) : this._constraintNum;
          return this._startAxis === nn.VERTICAL && (t = this._constraint === an.FIXED_COL ? Math.ceil(this._usefulLayoutObj.length / this._constraintNum) : this._constraintNum), t;
        }, o(e, [{
          key: "alignHorizontal",
          get: function get() {
            return this._isAlign;
          },
          set: function set(t) {
            this._layoutType === en.HORIZONTAL && (this._isAlign = t, this._doLayoutDirty());
          }
        }, {
          key: "alignVertical",
          get: function get() {
            return this._isAlign;
          },
          set: function set(t) {
            this._layoutType === en.VERTICAL && (this._isAlign = t, this._doLayoutDirty());
          }
        }, {
          key: "type",
          get: function get() {
            return this._layoutType;
          },
          set: function set(t) {
            this._layoutType = t, this._doLayoutDirty();
          }
        }, {
          key: "resizeMode",
          get: function get() {
            return this._resizeMode;
          },
          set: function set(t) {
            this._layoutType !== en.NONE && (this._resizeMode = t, this._doLayoutDirty());
          }
        }, {
          key: "cellSize",
          get: function get() {
            return this._cellSize;
          },
          set: function set(t) {
            this._cellSize !== t && (this._cellSize.set(t), this._doLayoutDirty());
          }
        }, {
          key: "startAxis",
          get: function get() {
            return this._startAxis;
          },
          set: function set(t) {
            this._startAxis !== t && (this._startAxis = t, this._doLayoutDirty());
          }
        }, {
          key: "paddingLeft",
          get: function get() {
            return this._paddingLeft;
          },
          set: function set(t) {
            this._paddingLeft !== t && (this._paddingLeft = t, this._doLayoutDirty());
          }
        }, {
          key: "paddingRight",
          get: function get() {
            return this._paddingRight;
          },
          set: function set(t) {
            this._paddingRight !== t && (this._paddingRight = t, this._doLayoutDirty());
          }
        }, {
          key: "paddingTop",
          get: function get() {
            return this._paddingTop;
          },
          set: function set(t) {
            this._paddingTop !== t && (this._paddingTop = t, this._doLayoutDirty());
          }
        }, {
          key: "paddingBottom",
          get: function get() {
            return this._paddingBottom;
          },
          set: function set(t) {
            this._paddingBottom !== t && (this._paddingBottom = t, this._doLayoutDirty());
          }
        }, {
          key: "spacingX",
          get: function get() {
            return this._spacingX;
          },
          set: function set(t) {
            this._spacingX !== t && (this._spacingX = t, this._doLayoutDirty());
          }
        }, {
          key: "spacingY",
          get: function get() {
            return this._spacingY;
          },
          set: function set(t) {
            this._spacingY !== t && (this._spacingY = t, this._doLayoutDirty());
          }
        }, {
          key: "verticalDirection",
          get: function get() {
            return this._verticalDirection;
          },
          set: function set(t) {
            this._verticalDirection !== t && (this._verticalDirection = t, this._doLayoutDirty());
          }
        }, {
          key: "horizontalDirection",
          get: function get() {
            return this._horizontalDirection;
          },
          set: function set(t) {
            this._horizontalDirection !== t && (this._horizontalDirection = t, this._doLayoutDirty());
          }
        }, {
          key: "padding",
          get: function get() {
            return this._paddingLeft;
          },
          set: function set(t) {
            this.paddingLeft === t && this._paddingRight === t && this._paddingTop === t && this._paddingBottom === t || (this._paddingLeft = this._paddingRight = this._paddingTop = this._paddingBottom = t, this._doLayoutDirty());
          }
        }, {
          key: "constraint",
          get: function get() {
            return this._constraint;
          },
          set: function set(t) {
            this._layoutType !== en.NONE && this._constraint !== t && (this._constraint = t, this._doLayoutDirty());
          }
        }, {
          key: "constraintNum",
          get: function get() {
            return this._constraintNum;
          },
          set: function set(t) {
            this._constraint !== an.NONE && this._constraintNum !== t && (t <= 0 && g("Limit values to be greater than 0"), this._constraintNum = t, this._doLayoutDirty());
          }
        }, {
          key: "affectedByScale",
          get: function get() {
            return this._affectedByScale;
          },
          set: function set(t) {
            this._affectedByScale = t, this._doLayoutDirty();
          }
        }]), e;
      }(F), Jo.Type = en, Jo.VerticalDirection = rn, Jo.HorizontalDirection = sn, Jo.ResizeMode = on, Jo.AxisDirection = nn, Jo.Constraint = an, n((No = tn).prototype, "alignHorizontal", [no, ro], Object.getOwnPropertyDescriptor(No.prototype, "alignHorizontal"), No.prototype), n(No.prototype, "alignVertical", [so, ao], Object.getOwnPropertyDescriptor(No.prototype, "alignVertical"), No.prototype), n(No.prototype, "type", [ho, lo, co], Object.getOwnPropertyDescriptor(No.prototype, "type"), No.prototype), n(No.prototype, "resizeMode", [uo, _o, po], Object.getOwnPropertyDescriptor(No.prototype, "resizeMode"), No.prototype), n(No.prototype, "cellSize", [go, fo], Object.getOwnPropertyDescriptor(No.prototype, "cellSize"), No.prototype), n(No.prototype, "startAxis", [yo, bo], Object.getOwnPropertyDescriptor(No.prototype, "startAxis"), No.prototype), n(No.prototype, "paddingLeft", [To], Object.getOwnPropertyDescriptor(No.prototype, "paddingLeft"), No.prototype), n(No.prototype, "paddingRight", [mo], Object.getOwnPropertyDescriptor(No.prototype, "paddingRight"), No.prototype), n(No.prototype, "paddingTop", [vo], Object.getOwnPropertyDescriptor(No.prototype, "paddingTop"), No.prototype), n(No.prototype, "paddingBottom", [Co], Object.getOwnPropertyDescriptor(No.prototype, "paddingBottom"), No.prototype), n(No.prototype, "spacingX", [So], Object.getOwnPropertyDescriptor(No.prototype, "spacingX"), No.prototype), n(No.prototype, "spacingY", [Eo], Object.getOwnPropertyDescriptor(No.prototype, "spacingY"), No.prototype), n(No.prototype, "verticalDirection", [Oo, Ao], Object.getOwnPropertyDescriptor(No.prototype, "verticalDirection"), No.prototype), n(No.prototype, "horizontalDirection", [wo, Lo], Object.getOwnPropertyDescriptor(No.prototype, "horizontalDirection"), No.prototype), n(No.prototype, "constraint", [Do, Po, Io], Object.getOwnPropertyDescriptor(No.prototype, "constraint"), No.prototype), n(No.prototype, "constraintNum", [zo, Ro], Object.getOwnPropertyDescriptor(No.prototype, "constraintNum"), No.prototype), n(No.prototype, "affectedByScale", [xo], Object.getOwnPropertyDescriptor(No.prototype, "affectedByScale"), No.prototype), Ho = n(No.prototype, "_resizeMode", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return on.NONE;
        }
      }), Mo = n(No.prototype, "_layoutType", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return en.NONE;
        }
      }), ko = n(No.prototype, "_cellSize", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return new Y(40, 40);
        }
      }), Vo = n(No.prototype, "_startAxis", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return nn.HORIZONTAL;
        }
      }), Fo = n(No.prototype, "_paddingLeft", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 0;
        }
      }), Go = n(No.prototype, "_paddingRight", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 0;
        }
      }), jo = n(No.prototype, "_paddingTop", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 0;
        }
      }), Uo = n(No.prototype, "_paddingBottom", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 0;
        }
      }), Wo = n(No.prototype, "_spacingX", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 0;
        }
      }), Zo = n(No.prototype, "_spacingY", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 0;
        }
      }), Yo = n(No.prototype, "_verticalDirection", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return rn.TOP_TO_BOTTOM;
        }
      }), Xo = n(No.prototype, "_horizontalDirection", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return sn.LEFT_TO_RIGHT;
        }
      }), qo = n(No.prototype, "_constraint", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return an.NONE;
        }
      }), Ko = n(No.prototype, "_constraintNum", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 2;
        }
      }), Qo = n(No.prototype, "_affectedByScale", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !1;
        }
      }), $o = n(No.prototype, "_isAlign", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !1;
        }
      }), Bo = No)) || Bo) || Bo) || Bo) || Bo) || Bo) || Bo));

      r.Layout = Rn, function (t) {
        t[t.HORIZONTAL = 0] = "HORIZONTAL", t[t.VERTICAL = 1] = "VERTICAL", t[t.FILLED = 2] = "FILLED";
      }(In || (In = {})), h(In);

      var xn,
          Bn,
          Nn,
          Hn,
          Mn,
          kn,
          Vn,
          Fn,
          Gn,
          jn,
          Un,
          Wn,
          Zn,
          Yn,
          Xn,
          qn,
          Kn,
          Qn,
          $n,
          Jn,
          tr,
          er,
          ir,
          or,
          nr = function (e) {
        return t({
          ProgressBar: e,
          ProgressBarComponent: e
        }), e;
      }((ln = O("cc.ProgressBar"), cn = R(), un = x(110), _n = B(), pn = N(Ct), dn = A(yt), gn = M(), fn = A(In), yn = M(), bn = M(), Tn = $(), mn = M(), vn = M(), ln(Cn = cn(Cn = un(Cn = _n(Cn = pn((Pn = Dn = function (t) {
        function e() {
          for (var e, i = arguments.length, o = new Array(i), n = 0; n < i; n++) {
            o[n] = arguments[n];
          }

          return e = t.call.apply(t, [this].concat(o)) || this, s(e, "_barSprite", En, a(e)), s(e, "_mode", On, a(e)), s(e, "_totalLength", An, a(e)), s(e, "_progress", wn, a(e)), s(e, "_reverse", Ln, a(e)), e;
        }

        i(e, t);
        var n = e.prototype;
        return n._initBarSprite = function () {
          if (this._barSprite) {
            var t = this._barSprite.node;
            if (!t) return;
            var e = this.node._uiProps.uiTransformComp,
                i = e.contentSize,
                o = e.anchorPoint,
                n = t._uiProps.uiTransformComp.contentSize;

            if (this._barSprite.fillType === yt.FillType.RADIAL && (this._mode = In.FILLED), this._mode === In.HORIZONTAL ? this.totalLength = n.width : this._mode === In.VERTICAL ? this.totalLength = n.height : this.totalLength = this._barSprite.fillRange, t.parent === this.node) {
              var r = -i.width * o.x;
              t.setPosition(r, 0, 0);
            }
          }
        }, n._updateBarStatus = function () {
          if (this._barSprite) {
            var t = this._barSprite.node;
            if (!t) return;
            var e = t._uiProps.uiTransformComp,
                i = e.anchorPoint,
                o = e.contentSize,
                n = t.getPosition(),
                r = new q(0, .5),
                s = K(this._progress),
                a = this._totalLength * s,
                h = o,
                l = 0,
                c = 0;

            switch (this._mode) {
              case In.HORIZONTAL:
                this._reverse && (r = new q(1, .5)), h = new Y(a, o.height), l = this._totalLength, c = o.height;
                break;

              case In.VERTICAL:
                r = this._reverse ? new q(.5, 1) : new q(.5, 0), h = new Y(o.width, a), l = o.width, c = this._totalLength;
            }

            if (this._mode === In.FILLED) this._barSprite.type !== yt.Type.FILLED ? g("ProgressBar FILLED mode only works when barSprite's Type is FILLED!") : (this._reverse && (a *= -1), this._barSprite.fillRange = a);else if (this._barSprite.type !== yt.Type.FILLED) {
              var u = r.x - i.x,
                  _ = r.y - i.y,
                  p = new I(l * u, c * _, 0);

              t.setPosition(n.x + p.x, n.y + p.y, n.z), e.setAnchorPoint(r), e.setContentSize(h);
            } else g("ProgressBar non-FILLED mode only works when barSprite's Type is non-FILLED!");
          }
        }, o(e, [{
          key: "barSprite",
          get: function get() {
            return this._barSprite;
          },
          set: function set(t) {
            this._barSprite !== t && (this._barSprite = t, this._initBarSprite());
          }
        }, {
          key: "mode",
          get: function get() {
            return this._mode;
          },
          set: function set(t) {
            if (this._mode !== t && (this._mode = t, this._barSprite)) {
              var e = this._barSprite.node;
              if (!e) return;
              var i = e._uiProps.uiTransformComp.contentSize;
              this._mode === In.HORIZONTAL ? this.totalLength = i.width : this._mode === In.VERTICAL ? this.totalLength = i.height : this._mode === In.FILLED && (this.totalLength = this._barSprite.fillRange);
            }
          }
        }, {
          key: "totalLength",
          get: function get() {
            return this._totalLength;
          },
          set: function set(t) {
            this._mode === In.FILLED && (t = K(t)), this._totalLength !== t && (this._totalLength = t, this._updateBarStatus());
          }
        }, {
          key: "progress",
          get: function get() {
            return this._progress;
          },
          set: function set(t) {
            this._progress !== t && (this._progress = t, this._updateBarStatus());
          }
        }, {
          key: "reverse",
          get: function get() {
            return this._reverse;
          },
          set: function set(t) {
            this._reverse !== t && (this._reverse = t, this._barSprite && (this._barSprite.fillStart = 1 - this._barSprite.fillStart), this._updateBarStatus());
          }
        }]), e;
      }(F), Dn.Mode = In, n((Sn = Pn).prototype, "barSprite", [dn, gn], Object.getOwnPropertyDescriptor(Sn.prototype, "barSprite"), Sn.prototype), n(Sn.prototype, "mode", [fn, yn], Object.getOwnPropertyDescriptor(Sn.prototype, "mode"), Sn.prototype), n(Sn.prototype, "totalLength", [bn], Object.getOwnPropertyDescriptor(Sn.prototype, "totalLength"), Sn.prototype), n(Sn.prototype, "progress", [Tn, Q, mn], Object.getOwnPropertyDescriptor(Sn.prototype, "progress"), Sn.prototype), n(Sn.prototype, "reverse", [vn], Object.getOwnPropertyDescriptor(Sn.prototype, "reverse"), Sn.prototype), En = n(Sn.prototype, "_barSprite", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return null;
        }
      }), On = n(Sn.prototype, "_mode", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return In.HORIZONTAL;
        }
      }), An = n(Sn.prototype, "_totalLength", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 1;
        }
      }), wn = n(Sn.prototype, "_progress", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return .1;
        }
      }), Ln = n(Sn.prototype, "_reverse", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !1;
        }
      }), Cn = Sn)) || Cn) || Cn) || Cn) || Cn) || Cn));

      r.ProgressBar = nr;
      var rr,
          sr = new I(),
          ar = new I(),
          hr = new I(),
          lr = new q(),
          cr = new E(),
          ur = new q();
      !function (t) {
        t[t.HORIZONTAL = 0] = "HORIZONTAL", t[t.VERTICAL = 1] = "VERTICAL";
      }(rr || (rr = {})), e(rr);

      var _r,
          pr = function (e) {
        return t({
          ScrollBar: e,
          ScrollBarComponent: e
        }), e;
      }((xn = O("cc.ScrollBar"), Bn = R(), Nn = x(110), Hn = B(), Mn = N(Ct), kn = A(yt), Vn = H(), Fn = M(), Gn = A(rr), jn = H(), Un = M(), Wn = H(), Zn = M(), Yn = H(), Xn = M(), xn(qn = Bn(qn = Nn(qn = Hn(qn = Mn((or = ir = function (t) {
        function e() {
          for (var e, i = arguments.length, o = new Array(i), n = 0; n < i; n++) {
            o[n] = arguments[n];
          }

          return e = t.call.apply(t, [this].concat(o)) || this, s(e, "_scrollView", Qn, a(e)), s(e, "_handle", $n, a(e)), s(e, "_direction", Jn, a(e)), s(e, "_enableAutoHide", tr, a(e)), s(e, "_autoHideTime", er, a(e)), e._touching = !1, e._opacity = 255, e._autoHideRemainingTime = 0, e;
        }

        i(e, t);
        var n = e.prototype;
        return n.hide = function () {
          this._autoHideRemainingTime = 0, this._setOpacity(0);
        }, n.show = function () {
          this._autoHideRemainingTime = this._autoHideTime, this._setOpacity(this._opacity);
        }, n.onScroll = function (t) {
          if (this._scrollView) {
            var e = this._scrollView.content;

            if (e) {
              var i = e._uiProps.uiTransformComp.contentSize,
                  o = this._scrollView.node._uiProps.uiTransformComp.contentSize,
                  n = this.node._uiProps.uiTransformComp.contentSize;

              if (!this._conditionalDisableScrollBar(i, o)) {
                this._enableAutoHide && (this._autoHideRemainingTime = this._autoHideTime, this._setOpacity(this._opacity));
                var r = 0,
                    s = 0,
                    a = 0,
                    h = 0,
                    l = 0,
                    c = ur;
                c.set(0, 0), this._direction === rr.HORIZONTAL ? (r = i.width, s = o.width, l = n.width, a = t.x, this._convertToScrollViewSpace(c, e), h = -c.x) : this._direction === rr.VERTICAL && (r = i.height, s = o.height, l = n.height, a = t.y, this._convertToScrollViewSpace(c, e), h = -c.y);

                var u = this._calculateLength(r, s, l, a),
                    _ = ur;

                this._calculatePosition(_, r, s, l, h, a, u), this._updateLength(u), this._updateHandlerPosition(_);
              }
            }
          }
        }, n.setScrollView = function (t) {
          this._scrollView = t;
        }, n.onTouchBegan = function () {
          this._enableAutoHide && (this._touching = !0);
        }, n.onTouchEnded = function () {
          if (this._enableAutoHide && (this._touching = !1, !(this._autoHideTime <= 0))) {
            if (this._scrollView) {
              var t = this._scrollView.content;

              if (t) {
                var e = t._uiProps.uiTransformComp.contentSize,
                    i = this._scrollView.node._uiProps.uiTransformComp.contentSize;
                if (this._conditionalDisableScrollBar(e, i)) return;
              }
            }

            this._autoHideRemainingTime = this._autoHideTime;
          }
        }, n.onEnable = function () {
          var t = this.node.getComponent(yt);
          t && (this._opacity = t.color.a);
        }, n.start = function () {
          this._enableAutoHide && this._setOpacity(0);
        }, n.update = function (t) {
          this._processAutoHide(t);
        }, n._convertToScrollViewSpace = function (t, e) {
          var i = this._scrollView && this._scrollView.node._uiProps.uiTransformComp,
              o = e._uiProps.uiTransformComp;

          if (i && o) {
            sr.set(-o.anchorX * o.width, -o.anchorY * o.height, 0), o.convertToWorldSpaceAR(sr, ar);
            var n = i.convertToNodeSpaceAR(ar);
            n.x += i.anchorX * i.width, n.y += i.anchorY * i.height, t.set(n.x, n.y);
          } else t.set(q.ZERO);
        }, n._setOpacity = function (t) {
          if (this._handle) {
            var e = this.node.getComponent(yt);
            e && (cr.set(e.color), cr.a = t, e.color = cr), (e = this._handle.getComponent(yt)) && (cr.set(e.color), cr.a = t, e.color = cr);
          }
        }, n._updateHandlerPosition = function (t) {
          if (this._handle) {
            var e = hr;
            this._fixupHandlerPosition(e), this._handle.node.setPosition(t.x + e.x, t.y + e.y, e.z);
          }
        }, n._fixupHandlerPosition = function (t) {
          var e = this.node._uiProps.uiTransformComp,
              i = e.contentSize,
              o = e.anchorPoint,
              n = this.handle.node._uiProps.uiTransformComp.contentSize,
              r = this.handle.node.parent;
          I.set(sr, -i.width * o.x, -i.height * o.y, 0);

          var s = this.node._uiProps.uiTransformComp.convertToWorldSpaceAR(sr, ar),
              a = t;

          a.set(0, 0, 0), r._uiProps.uiTransformComp.convertToNodeSpaceAR(s, a), this.direction === rr.HORIZONTAL ? a.set(a.x, a.y + (i.height - n.height) / 2, a.z) : this.direction === rr.VERTICAL && a.set(a.x + (i.width - n.width) / 2, a.y, a.z), this.handle.node.setPosition(a);
        }, n._conditionalDisableScrollBar = function (t, e) {
          return t.width <= e.width && this._direction === rr.HORIZONTAL || t.height <= e.height && this._direction === rr.VERTICAL;
        }, n._calculateLength = function (t, e, i, o) {
          var n = t;
          return o && (n += 20 * (o > 0 ? o : -o)), i * (e / n);
        }, n._calculatePosition = function (t, e, i, o, n, r, s) {
          var a = e - i;
          r && (a += Math.abs(r));
          var h = 0;
          a && (h = K(h = n / a));
          var l = (o - s) * h;
          this._direction === rr.VERTICAL ? t.set(0, l) : t.set(l, 0);
        }, n._updateLength = function (t) {
          if (this._handle) {
            var e = this._handle.node._uiProps.uiTransformComp,
                i = e.contentSize,
                o = e.anchorPoint;
            o.x === lr.x && o.y === lr.y || e.setAnchorPoint(lr), this._direction === rr.HORIZONTAL ? e.setContentSize(t, i.height) : e.setContentSize(i.width, t);
          }
        }, n._processAutoHide = function (t) {
          if (this._enableAutoHide && !(this._autoHideRemainingTime <= 0) && !this._touching && (this._autoHideRemainingTime -= t, this._autoHideRemainingTime <= this._autoHideTime)) {
            this._autoHideRemainingTime = Math.max(0, this._autoHideRemainingTime);
            var e = this._opacity * (this._autoHideRemainingTime / this._autoHideTime);

            this._setOpacity(e);
          }
        }, o(e, [{
          key: "handle",
          get: function get() {
            return this._handle;
          },
          set: function set(t) {
            this._handle !== t && (this._handle = t, this.onScroll(q.ZERO));
          }
        }, {
          key: "direction",
          get: function get() {
            return this._direction;
          },
          set: function set(t) {
            this._direction !== t && (this._direction = t, this.onScroll(q.ZERO));
          }
        }, {
          key: "enableAutoHide",
          get: function get() {
            return this._enableAutoHide;
          },
          set: function set(t) {
            this._enableAutoHide !== t && (this._enableAutoHide = t, this._enableAutoHide && this._setOpacity(0));
          }
        }, {
          key: "autoHideTime",
          get: function get() {
            return this._autoHideTime;
          },
          set: function set(t) {
            this._autoHideTime !== t && (this._autoHideTime = t);
          }
        }]), e;
      }(F), ir.Direction = rr, n((Kn = or).prototype, "handle", [kn, Vn, Fn], Object.getOwnPropertyDescriptor(Kn.prototype, "handle"), Kn.prototype), n(Kn.prototype, "direction", [Gn, jn, Un], Object.getOwnPropertyDescriptor(Kn.prototype, "direction"), Kn.prototype), n(Kn.prototype, "enableAutoHide", [Wn, Zn], Object.getOwnPropertyDescriptor(Kn.prototype, "enableAutoHide"), Kn.prototype), n(Kn.prototype, "autoHideTime", [Yn, Xn], Object.getOwnPropertyDescriptor(Kn.prototype, "autoHideTime"), Kn.prototype), Qn = n(Kn.prototype, "_scrollView", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return null;
        }
      }), $n = n(Kn.prototype, "_handle", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return null;
        }
      }), Jn = n(Kn.prototype, "_direction", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return rr.HORIZONTAL;
        }
      }), tr = n(Kn.prototype, "_enableAutoHide", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !1;
        }
      }), er = n(Kn.prototype, "_autoHideTime", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 1;
        }
      }), qn = Kn)) || qn) || qn) || qn) || qn) || qn));

      r.ScrollBar = pr;
      var dr,
          gr,
          fr,
          yr,
          br,
          Tr,
          mr,
          vr,
          Cr,
          Sr,
          Er,
          Or,
          Ar,
          wr,
          Lr,
          Dr,
          Pr,
          Ir,
          zr,
          Rr,
          xr,
          Br,
          Nr,
          Hr,
          Mr,
          kr,
          Vr,
          Fr,
          Gr,
          jr,
          Ur,
          Wr,
          Zr,
          Yr,
          Xr,
          qr,
          Kr,
          Qr,
          $r,
          Jr,
          ts,
          es,
          is,
          os,
          ns,
          rs,
          ss,
          as,
          hs = t("ViewGroup", O("cc.ViewGroup")(_r = x(110)(_r = function (t) {
        function e() {
          return t.apply(this, arguments) || this;
        }

        return i(e, t), e;
      }(F)) || _r) || _r);
      r.ViewGroup = hs;

      var ls,
          cs = 1e-4,
          us = new I(),
          _s = new I(),
          ps = new q(),
          ds = new q(),
          gs = function gs() {
        return new Date().getMilliseconds();
      },
          fs = {
        "scroll-to-top": 0,
        "scroll-to-bottom": 1,
        "scroll-to-left": 2,
        "scroll-to-right": 3,
        scrolling: 4,
        "bounce-bottom": 6,
        "bounce-left": 7,
        "bounce-right": 8,
        "bounce-top": 5,
        "scroll-ended": 9,
        "touch-up": 10,
        "scroll-ended-with-threshold": 11,
        "scroll-began": 12
      };

      !function (t) {
        t.SCROLL_TO_TOP = "scroll-to-top", t.SCROLL_TO_BOTTOM = "scroll-to-bottom", t.SCROLL_TO_LEFT = "scroll-to-left", t.SCROLL_TO_RIGHT = "scroll-to-right", t.SCROLL_BEGAN = "scroll-began", t.SCROLL_ENDED = "scroll-ended", t.BOUNCE_TOP = "bounce-top", t.BOUNCE_BOTTOM = "bounce-bottom", t.BOUNCE_LEFT = "bounce-left", t.BOUNCE_RIGHT = "bounce-right", t.SCROLLING = "scrolling", t.SCROLL_ENG_WITH_THRESHOLD = "scroll-ended-with-threshold", t.TOUCH_UP = "touch-up";
      }(ls || (ls = {}));

      var ys,
          bs,
          Ts,
          ms,
          vs,
          Cs,
          Ss,
          Es,
          Os,
          As,
          ws,
          Ls,
          Ds,
          Ps,
          Is,
          zs,
          Rs,
          xs,
          Bs,
          Ns,
          Hs,
          Ms = function (e) {
        return t({
          ScrollView: e,
          ScrollViewComponent: e
        }), e;
      }((dr = O("cc.ScrollView"), gr = R(), fr = x(110), yr = B(), br = N(Ct), Tr = $(), mr = H(), vr = M(), Cr = $(), Sr = H(), Er = M(), Or = H(), Ar = M(), wr = H(), Lr = M(), Dr = A(w), Pr = H(), Ir = M(), zr = H(), Rr = M(), xr = A(pr), Br = H(), Nr = M(), Hr = H(), Mr = M(), kr = A(pr), Vr = H(), Fr = M(), Gr = H(), jr = M(), Ur = A([_t]), Wr = H(), Zr = M(), dr(Yr = gr(Yr = fr(Yr = yr(Yr = br((as = ss = function (t) {
        function e() {
          for (var e, i = arguments.length, o = new Array(i), n = 0; n < i; n++) {
            o[n] = arguments[n];
          }

          return e = t.call.apply(t, [this].concat(o)) || this, s(e, "bounceDuration", qr, a(e)), s(e, "brake", Kr, a(e)), s(e, "elastic", Qr, a(e)), s(e, "inertia", $r, a(e)), s(e, "horizontal", Jr, a(e)), s(e, "vertical", ts, a(e)), s(e, "cancelInnerEvents", es, a(e)), s(e, "scrollEvents", is, a(e)), e._autoScrolling = !1, e._scrolling = !1, s(e, "_content", os, a(e)), s(e, "_horizontalScrollBar", ns, a(e)), s(e, "_verticalScrollBar", rs, a(e)), e._topBoundary = 0, e._bottomBoundary = 0, e._leftBoundary = 0, e._rightBoundary = 0, e._touchMoveDisplacements = [], e._touchMoveTimeDeltas = [], e._touchMovePreviousTimestamp = 0, e._touchMoved = !1, e._autoScrollAttenuate = !1, e._autoScrollStartPosition = new I(), e._autoScrollTargetDelta = new I(), e._autoScrollTotalTime = 0, e._autoScrollAccumulatedTime = 0, e._autoScrollCurrentlyOutOfBoundary = !1, e._autoScrollBraking = !1, e._autoScrollBrakingStartPosition = new I(), e._outOfBoundaryAmount = new I(), e._outOfBoundaryAmountDirty = !0, e._stopMouseWheel = !1, e._mouseWheelEventElapsedTime = 0, e._isScrollEndedWithThresholdEventFired = !1, e._scrollEventEmitMask = 0, e._isBouncing = !1, e._contentPos = new I(), e._deltaPos = new I(), e;
        }

        i(e, t);
        var n = e.prototype;
        return n.scrollToBottom = function (t, e) {
          void 0 === e && (e = !0);

          var i = this._calculateMovePercentDelta({
            anchor: new q(0, 0),
            applyToHorizontal: !1,
            applyToVertical: !0
          });

          t ? this._startAutoScroll(i, t, !1 !== e) : this._moveContent(i, !0);
        }, n.scrollToTop = function (t, e) {
          void 0 === e && (e = !0);

          var i = this._calculateMovePercentDelta({
            anchor: new q(0, 1),
            applyToHorizontal: !1,
            applyToVertical: !0
          });

          t ? this._startAutoScroll(i, t, !1 !== e) : this._moveContent(i);
        }, n.scrollToLeft = function (t, e) {
          void 0 === e && (e = !0);

          var i = this._calculateMovePercentDelta({
            anchor: new q(0, 0),
            applyToHorizontal: !0,
            applyToVertical: !1
          });

          t ? this._startAutoScroll(i, t, !1 !== e) : this._moveContent(i);
        }, n.scrollToRight = function (t, e) {
          void 0 === e && (e = !0);

          var i = this._calculateMovePercentDelta({
            anchor: new q(1, 0),
            applyToHorizontal: !0,
            applyToVertical: !1
          });

          t ? this._startAutoScroll(i, t, !1 !== e) : this._moveContent(i);
        }, n.scrollToTopLeft = function (t, e) {
          void 0 === e && (e = !0);

          var i = this._calculateMovePercentDelta({
            anchor: new q(0, 1),
            applyToHorizontal: !0,
            applyToVertical: !0
          });

          t ? this._startAutoScroll(i, t, !1 !== e) : this._moveContent(i);
        }, n.scrollToTopRight = function (t, e) {
          void 0 === e && (e = !0);

          var i = this._calculateMovePercentDelta({
            anchor: new q(1, 1),
            applyToHorizontal: !0,
            applyToVertical: !0
          });

          t ? this._startAutoScroll(i, t, !1 !== e) : this._moveContent(i);
        }, n.scrollToBottomLeft = function (t, e) {
          void 0 === e && (e = !0);

          var i = this._calculateMovePercentDelta({
            anchor: new q(0, 0),
            applyToHorizontal: !0,
            applyToVertical: !0
          });

          t ? this._startAutoScroll(i, t, !1 !== e) : this._moveContent(i);
        }, n.scrollToBottomRight = function (t, e) {
          void 0 === e && (e = !0);

          var i = this._calculateMovePercentDelta({
            anchor: new q(1, 0),
            applyToHorizontal: !0,
            applyToVertical: !0
          });

          t ? this._startAutoScroll(i, t, !1 !== e) : this._moveContent(i);
        }, n.scrollToOffset = function (t, e, i) {
          void 0 === i && (i = !0);
          var o = this.getMaxScrollOffset(),
              n = new q(0, 0);
          0 === o.x ? n.x = 0 : n.x = t.x / o.x, 0 === o.y ? n.y = 1 : n.y = (o.y - t.y) / o.y, this.scrollTo(n, e, i);
        }, n.getScrollOffset = function () {
          var t = this._getContentTopBoundary() - this._topBoundary,
              e = this._getContentLeftBoundary() - this._leftBoundary;

          return new q(e, t);
        }, n.getMaxScrollOffset = function () {
          if (!this._content || !this.view) return q.ZERO;
          var t = this._content._uiProps.uiTransformComp.contentSize,
              e = t.width - this.view.width,
              i = t.height - this.view.height;
          return new q(e = e >= 0 ? e : 0, i = i >= 0 ? i : 0);
        }, n.scrollToPercentHorizontal = function (t, e, i) {
          var o = this._calculateMovePercentDelta({
            anchor: new q(t, 0),
            applyToHorizontal: !0,
            applyToVertical: !1
          });

          e ? this._startAutoScroll(o, e, !1 !== i) : this._moveContent(o);
        }, n.scrollTo = function (t, e, i) {
          var o = this._calculateMovePercentDelta({
            anchor: new q(t),
            applyToHorizontal: !0,
            applyToVertical: !0
          });

          e ? this._startAutoScroll(o, e, i) : this._moveContent(o);
        }, n.scrollToPercentVertical = function (t, e, i) {
          var o = this._calculateMovePercentDelta({
            anchor: new q(0, t),
            applyToHorizontal: !1,
            applyToVertical: !0
          });

          e ? this._startAutoScroll(o, e, i) : this._moveContent(o);
        }, n.stopAutoScroll = function () {
          this._autoScrolling = !1, this._autoScrollAccumulatedTime = this._autoScrollTotalTime;
        }, n.setContentPosition = function (t) {
          this._setContentPosition(t);
        }, n._setContentPosition = function (t) {
          if (this._content) {
            var e = this._getContentPosition();

            Math.abs(t.x - e.x) < cs && Math.abs(t.y - e.y) < cs || (this._content.setPosition(t), this._outOfBoundaryAmountDirty = !0);
          }
        }, n.getContentPosition = function () {
          return this._getContentPosition();
        }, n._getContentPosition = function () {
          return this._content ? (this._contentPos.set(this._content.position), this._contentPos) : I.ZERO.clone();
        }, n.isScrolling = function () {
          return this._scrolling;
        }, n.isAutoScrolling = function () {
          return this._autoScrolling;
        }, n.getScrollEndedEventTiming = function () {
          return cs;
        }, n.start = function () {
          this._calculateBoundary(), this._content && pt.once(dt.EVENT_BEFORE_DRAW, this._adjustContentOutOfBoundary, this);
        }, n.onEnable = function () {
          this._registerEvent(), this._content && (this._content.on(P.SIZE_CHANGED, this._calculateBoundary, this), this._content.on(P.TRANSFORM_CHANGED, this._scaleChanged, this), this.view && (this.view.node.on(P.TRANSFORM_CHANGED, this._scaleChanged, this), this.view.node.on(P.SIZE_CHANGED, this._calculateBoundary, this))), this._calculateBoundary(), this._updateScrollBarState();
        }, n.update = function (t) {
          this._autoScrolling && this._processAutoScrolling(t);
        }, n.onDisable = function () {
          this._unregisterEvent(), this._content && (this._content.off(P.SIZE_CHANGED, this._calculateBoundary, this), this._content.off(P.TRANSFORM_CHANGED, this._scaleChanged, this), this.view && (this.view.node.off(P.TRANSFORM_CHANGED, this._scaleChanged, this), this.view.node.off(P.SIZE_CHANGED, this._calculateBoundary, this))), this._hideScrollBar(), this.stopAutoScroll();
        }, n._registerEvent = function () {
          this.node.on(P.TOUCH_START, this._onTouchBegan, this, !0), this.node.on(P.TOUCH_MOVE, this._onTouchMoved, this, !0), this.node.on(P.TOUCH_END, this._onTouchEnded, this, !0), this.node.on(P.TOUCH_CANCEL, this._onTouchCancelled, this, !0), this.node.on(P.MOUSE_WHEEL, this._onMouseWheel, this, !0);
        }, n._unregisterEvent = function () {
          this.node.off(P.TOUCH_START, this._onTouchBegan, this, !0), this.node.off(P.TOUCH_MOVE, this._onTouchMoved, this, !0), this.node.off(P.TOUCH_END, this._onTouchEnded, this, !0), this.node.off(P.TOUCH_CANCEL, this._onTouchCancelled, this, !0), this.node.off(P.MOUSE_WHEEL, this._onMouseWheel, this, !0);
        }, n._onMouseWheel = function (t, e) {
          if (this.enabledInHierarchy && !this._hasNestedViewGroup(t, e)) {
            var i = new I(),
                o = t.getScrollY();
            this.vertical ? i.set(0, -.1 * o, 0) : this.horizontal && i.set(-.1 * o, 0, 0), this._mouseWheelEventElapsedTime = 0, this._processDeltaMove(i), this._stopMouseWheel || (this._handlePressLogic(), this.schedule(this._checkMouseWheel, 1 / 60, NaN, 0), this._stopMouseWheel = !0), this._stopPropagationIfTargetIsMe(t);
          }
        }, n._onTouchBegan = function (t, e) {
          this.enabledInHierarchy && this._content && (this._hasNestedViewGroup(t, e) || (this._handlePressLogic(), this._touchMoved = !1, this._stopPropagationIfTargetIsMe(t)));
        }, n._onTouchMoved = function (t, e) {
          if (this.enabledInHierarchy && this._content && !this._hasNestedViewGroup(t, e)) {
            var i = t.touch;

            if (this._handleMoveLogic(i), this.cancelInnerEvents) {
              var o = i.getUILocation(ps);

              if (o.subtract(i.getUIStartLocation(ds)), o.length() > 7 && !this._touchMoved && t.target !== this.node) {
                var n = new J(t.getTouches(), t.bubbles, tt.TOUCH_CANCEL);
                n.touch = t.touch, n.simulate = !0, t.target.dispatchEvent(n), this._touchMoved = !0;
              }

              this._stopPropagationIfTargetIsMe(t);
            }
          }
        }, n._onTouchEnded = function (t, e) {
          if (this.enabledInHierarchy && this._content && t && !this._hasNestedViewGroup(t, e)) {
            this._dispatchEvent(ls.TOUCH_UP);

            var i = t.touch;
            this._handleReleaseLogic(i), this._touchMoved ? t.propagationStopped = !0 : this._stopPropagationIfTargetIsMe(t);
          }
        }, n._onTouchCancelled = function (t, e) {
          if (this.enabledInHierarchy && this._content && !this._hasNestedViewGroup(t, e)) {
            if (t && !t.simulate) {
              var i = t.touch;

              this._handleReleaseLogic(i);
            }

            this._stopPropagationIfTargetIsMe(t);
          }
        }, n._calculateBoundary = function () {
          if (this._content && this.view) {
            var t = this._content.getComponent(Rn);

            t && t.enabledInHierarchy && t.updateLayout();
            var e = this.view,
                i = e.width * e.anchorX,
                o = e.height * e.anchorY;
            this._leftBoundary = -i, this._bottomBoundary = -o, this._rightBoundary = this._leftBoundary + e.width, this._topBoundary = this._bottomBoundary + e.height, this._moveContentToTopLeft(e.contentSize);
          }
        }, n._hasNestedViewGroup = function (t, e) {
          if (!t || t.eventPhase !== et.CAPTURING_PHASE) return !1;
          if (e) for (var i, o = f(e); !(i = o()).done;) {
            var n = i.value;
            if (this.node === n) return !(!t.target || !t.target.getComponent(hs));
            if (n.getComponent(hs)) return !0;
          }
          return !1;
        }, n._startInertiaScroll = function (t) {
          var e = new I(t);
          e.multiplyScalar(.7), this._startAttenuatingAutoScroll(e, t);
        }, n._calculateAttenuatedFactor = function (t) {
          return this.brake <= 0 ? 1 - this.brake : (1 - this.brake) * (1 / (1 + 14e-6 * t + t * t * 8e-9));
        }, n._startAttenuatingAutoScroll = function (t, e) {
          var i = t.clone();

          if (i.normalize(), this._content && this.view) {
            var o = this._content._uiProps.uiTransformComp.contentSize,
                n = this.view.contentSize,
                r = o.width - n.width,
                s = o.height - n.height,
                a = this._calculateAttenuatedFactor(r),
                h = this._calculateAttenuatedFactor(s);

            i.x = i.x * r * (1 - this.brake) * a, i.y = i.y * s * h * (1 - this.brake), i.z = 0;
          }

          var l = t.length(),
              c = i.length() / l;

          if (i.add(t), this.brake > 0 && c > 7) {
            c = Math.sqrt(c);
            var u = t.clone();
            u.multiplyScalar(c), i.set(u), i.add(t);
          }

          var _ = this._calculateAutoScrollTimeByInitialSpeed(e.length());

          this.brake > 0 && c > 3 && (_ *= c = 3), 0 === this.brake && c > 1 && (_ *= c), this._startAutoScroll(i, _, !0);
        }, n._calculateAutoScrollTimeByInitialSpeed = function (t) {
          return Math.sqrt(Math.sqrt(t / 5));
        }, n._startAutoScroll = function (t, e, i) {
          void 0 === i && (i = !1);

          var o = this._flattenVectorByDirection(t);

          this._autoScrolling = !0, this._autoScrollTargetDelta = o, this._autoScrollAttenuate = i, I.copy(this._autoScrollStartPosition, this._getContentPosition()), this._autoScrollTotalTime = e, this._autoScrollAccumulatedTime = 0, this._autoScrollBraking = !1, this._isScrollEndedWithThresholdEventFired = !1, this._autoScrollBrakingStartPosition.set(0, 0, 0), this._getHowMuchOutOfBoundary().equals(I.ZERO, cs) || (this._autoScrollCurrentlyOutOfBoundary = !0);
        }, n._calculateTouchMoveVelocity = function () {
          var t = new I(),
              e = 0;
          if ((e = this._touchMoveTimeDeltas.reduce(function (t, e) {
            return t + e;
          }, e)) <= 0 || e >= .5) t.set(I.ZERO);else {
            var i = new I();
            i = this._touchMoveDisplacements.reduce(function (t, e) {
              return t.add(e), t;
            }, i), t.set(i.x * (1 - this.brake) / e, i.y * (1 - this.brake) / e, i.z);
          }
          return t;
        }, n._flattenVectorByDirection = function (t) {
          var e = t;
          return e.x = this.horizontal ? e.x : 0, e.y = this.vertical ? e.y : 0, e;
        }, n._moveContent = function (t, e) {
          var i = this._flattenVectorByDirection(t);

          us.set(this._getContentPosition()), us.add(i), us.set(Math.round(1e4 * us.x) * cs, Math.round(1e4 * us.y) * cs, us.z), this._setContentPosition(us);

          var o = this._getHowMuchOutOfBoundary();

          ps.set(o.x, o.y), this._updateScrollBar(ps), this.elastic && e && this._startBounceBackIfNeeded();
        }, n._getContentLeftBoundary = function () {
          if (!this._content) return -1;

          var t = this._getContentPosition(),
              e = this._content._uiProps.uiTransformComp;

          return t.x - e.anchorX * e.width;
        }, n._getContentRightBoundary = function () {
          if (!this._content) return -1;
          var t = this._content._uiProps.uiTransformComp;
          return this._getContentLeftBoundary() + t.width;
        }, n._getContentTopBoundary = function () {
          if (!this._content) return -1;
          var t = this._content._uiProps.uiTransformComp;
          return this._getContentBottomBoundary() + t.height;
        }, n._getContentBottomBoundary = function () {
          if (!this._content) return -1;

          var t = this._getContentPosition(),
              e = this._content._uiProps.uiTransformComp;

          return t.y - e.anchorY * e.height;
        }, n._getHowMuchOutOfBoundary = function (t) {
          if ((t = t || new I()).equals(I.ZERO, cs) && !this._outOfBoundaryAmountDirty) return this._outOfBoundaryAmount;

          var e = new I(),
              i = this._getContentLeftBoundary(),
              o = this._getContentRightBoundary();

          i + t.x > this._leftBoundary ? e.x = this._leftBoundary - (i + t.x) : o + t.x < this._rightBoundary && (e.x = this._rightBoundary - (o + t.x));

          var n = this._getContentTopBoundary(),
              r = this._getContentBottomBoundary();

          return n + t.y < this._topBoundary ? e.y = this._topBoundary - (n + t.y) : r + t.y > this._bottomBoundary && (e.y = this._bottomBoundary - (r + t.y)), t.equals(I.ZERO, cs) && (this._outOfBoundaryAmount = e, this._outOfBoundaryAmountDirty = !1), this._clampDelta(e), e;
        }, n._updateScrollBar = function (t) {
          this._horizontalScrollBar && this._horizontalScrollBar.onScroll(t), this.verticalScrollBar && this.verticalScrollBar.onScroll(t);
        }, n._onScrollBarTouchBegan = function () {
          this._horizontalScrollBar && this._horizontalScrollBar.onTouchBegan(), this.verticalScrollBar && this.verticalScrollBar.onTouchBegan();
        }, n._onScrollBarTouchEnded = function () {
          this._horizontalScrollBar && this._horizontalScrollBar.onTouchEnded(), this.verticalScrollBar && this.verticalScrollBar.onTouchEnded();
        }, n._dispatchEvent = function (t) {
          if (t === ls.SCROLL_ENDED) this._scrollEventEmitMask = 0;else if (t === ls.SCROLL_TO_TOP || t === ls.SCROLL_TO_BOTTOM || t === ls.SCROLL_TO_LEFT || t === ls.SCROLL_TO_RIGHT) {
            var e = 1 << fs[t];
            if (this._scrollEventEmitMask & e) return;
            this._scrollEventEmitMask |= e;
          }
          _t.emitEvents(this.scrollEvents, this, fs[t]), this.node.emit(t, this);
        }, n._adjustContentOutOfBoundary = function () {
          if (this._content && (this._outOfBoundaryAmountDirty = !0, this._isOutOfBoundary())) {
            var t = this._getHowMuchOutOfBoundary();

            us.set(this._getContentPosition()), us.add(t), this._content.setPosition(us), this._updateScrollBar(q.ZERO);
          }
        }, n._hideScrollBar = function () {
          this._horizontalScrollBar && this._horizontalScrollBar.hide(), this._verticalScrollBar && this._verticalScrollBar.hide();
        }, n._updateScrollBarState = function () {
          if (this._content && this.view) {
            var t = this.view,
                e = this._content._uiProps.uiTransformComp;
            this.verticalScrollBar && (e.height < t.height ? this.verticalScrollBar.hide() : this.verticalScrollBar.show()), this.horizontalScrollBar && (e.width < t.width ? this.horizontalScrollBar.hide() : this.horizontalScrollBar.show());
          }
        }, n._stopPropagationIfTargetIsMe = function (t) {
          t.eventPhase === et.AT_TARGET && t.target === this.node && (t.propagationStopped = !0);
        }, n._processDeltaMove = function (t) {
          this._scrollChildren(t), this._gatherTouchMove(t);
        }, n._handleMoveLogic = function (t) {
          this._getLocalAxisAlignDelta(this._deltaPos, t), this._processDeltaMove(this._deltaPos);
        }, n._handleReleaseLogic = function (t) {
          this._getLocalAxisAlignDelta(this._deltaPos, t), this._gatherTouchMove(this._deltaPos), this._processInertiaScroll(), this._scrolling && (this._scrolling = !1, this._autoScrolling || this._dispatchEvent(ls.SCROLL_ENDED));
        }, n._getLocalAxisAlignDelta = function (t, e) {
          var i = this.node._uiProps.uiTransformComp,
              o = new I();
          i && (e.getUILocation(ps), e.getUIPreviousLocation(ds), us.set(ps.x, ps.y, 0), _s.set(ds.x, ds.y, 0), i.convertToNodeSpaceAR(us, us), i.convertToNodeSpaceAR(_s, _s), I.subtract(o, us, _s)), t.set(o);
        }, n._scrollChildren = function (t) {
          this._clampDelta(t);

          var e,
              i = t;
          this.elastic && (e = this._getHowMuchOutOfBoundary(), i.x *= 0 === e.x ? 1 : .5, i.y *= 0 === e.y ? 1 : .5), this.elastic || (e = this._getHowMuchOutOfBoundary(i), i.add(e));
          var o = "",
              n = "";

          if (this._content) {
            var r = this._content._uiProps.uiTransformComp,
                s = r.anchorX,
                a = r.anchorY,
                h = r.width,
                l = r.height,
                c = this._content.position || I.ZERO;
            this.vertical && (i.y > 0 ? c.y - a * l + i.y >= this._bottomBoundary && (o = ls.SCROLL_TO_BOTTOM) : i.y < 0 && c.y - a * l + l + i.y <= this._topBoundary && (o = ls.SCROLL_TO_TOP)), this.horizontal && (i.x < 0 ? c.x - s * h + h + i.x <= this._rightBoundary && (n = ls.SCROLL_TO_RIGHT) : i.x > 0 && c.x - s * h + i.x >= this._leftBoundary && (n = ls.SCROLL_TO_LEFT));
          }

          this._moveContent(i, !1), (this.horizontal && 0 !== i.x || this.vertical && 0 !== i.y) && (this._scrolling || (this._scrolling = !0, this._dispatchEvent(ls.SCROLL_BEGAN)), this._dispatchEvent(ls.SCROLLING)), "" !== o && this._dispatchEvent(o), "" !== n && this._dispatchEvent(n);
        }, n._handlePressLogic = function () {
          this._autoScrolling && this._dispatchEvent(ls.SCROLL_ENDED), this._autoScrolling = !1, this._isBouncing = !1, this._touchMovePreviousTimestamp = gs(), this._touchMoveDisplacements.length = 0, this._touchMoveTimeDeltas.length = 0, this._onScrollBarTouchBegan();
        }, n._clampDelta = function (t) {
          if (this._content && this.view) {
            var e = this.view.contentSize,
                i = this._content._uiProps.uiTransformComp;
            i.width < e.width && (t.x = 0), i.height < e.height && (t.y = 0);
          }
        }, n._gatherTouchMove = function (t) {
          var e = t.clone();

          for (this._clampDelta(e); this._touchMoveDisplacements.length >= 5;) {
            this._touchMoveDisplacements.shift(), this._touchMoveTimeDeltas.shift();
          }

          this._touchMoveDisplacements.push(e);

          var i = gs();
          this._touchMoveTimeDeltas.push((i - this._touchMovePreviousTimestamp) / 1e3), this._touchMovePreviousTimestamp = i;
        }, n._startBounceBackIfNeeded = function () {
          if (!this.elastic) return !1;

          var t = this._getHowMuchOutOfBoundary();

          if (this._clampDelta(t), t.equals(I.ZERO, cs)) return !1;
          var e = Math.max(this.bounceDuration, 0);
          return this._startAutoScroll(t, e, !0), this._isBouncing || (t.y > 0 && this._dispatchEvent(ls.BOUNCE_TOP), t.y < 0 && this._dispatchEvent(ls.BOUNCE_BOTTOM), t.x > 0 && this._dispatchEvent(ls.BOUNCE_RIGHT), t.x < 0 && this._dispatchEvent(ls.BOUNCE_LEFT), this._isBouncing = !0), !0;
        }, n._processInertiaScroll = function () {
          if (!this._startBounceBackIfNeeded() && this.inertia) {
            var t = this._calculateTouchMoveVelocity();

            !t.equals(us, cs) && this.brake < 1 && this._startInertiaScroll(t);
          }

          this._onScrollBarTouchEnded();
        }, n._isOutOfBoundary = function () {
          return !this._getHowMuchOutOfBoundary().equals(I.ZERO, cs);
        }, n._isNecessaryAutoScrollBrake = function () {
          if (this._autoScrollBraking) return !0;

          if (this._isOutOfBoundary()) {
            if (!this._autoScrollCurrentlyOutOfBoundary) return this._autoScrollCurrentlyOutOfBoundary = !0, this._autoScrollBraking = !0, I.copy(this._autoScrollBrakingStartPosition, this._getContentPosition()), !0;
          } else this._autoScrollCurrentlyOutOfBoundary = !1;

          return !1;
        }, n._processAutoScrolling = function (t) {
          var e = this._isNecessaryAutoScrollBrake(),
              i = e ? .05 : 1;

          this._autoScrollAccumulatedTime += t * (1 / i);
          var o,
              n = Math.min(1, this._autoScrollAccumulatedTime / this._autoScrollTotalTime);
          this._autoScrollAttenuate && (o = n, n = (o -= 1) * o * o * o * o + 1);

          var r = this._autoScrollTargetDelta.clone();

          r.multiplyScalar(n);

          var s = this._autoScrollStartPosition.clone();

          s.add(r);
          var a = Math.abs(n - 1) <= cs;

          if (Math.abs(n - 1) <= this.getScrollEndedEventTiming() && !this._isScrollEndedWithThresholdEventFired && (this._dispatchEvent(ls.SCROLL_ENG_WITH_THRESHOLD), this._isScrollEndedWithThresholdEventFired = !0), this.elastic) {
            var h = s.clone();
            h.subtract(this._autoScrollBrakingStartPosition), e && h.multiplyScalar(i), s.set(this._autoScrollBrakingStartPosition), s.add(h);
          } else {
            var l = s.clone();
            l.subtract(this.getContentPosition());

            var c = this._getHowMuchOutOfBoundary(l);

            c.equals(I.ZERO, cs) || (s.add(c), a = !0);
          }

          a && (this._autoScrolling = !1);
          var u = s.clone();
          u.subtract(this._getContentPosition()), this._clampDelta(u), this._moveContent(u, a), this._dispatchEvent(ls.SCROLLING), this._autoScrolling || (this._isBouncing = !1, this._scrolling = !1, this._dispatchEvent(ls.SCROLL_ENDED));
        }, n._checkMouseWheel = function (t) {
          if (!this._getHowMuchOutOfBoundary().equals(I.ZERO, cs)) return this._processInertiaScroll(), this.unschedule(this._checkMouseWheel), this._dispatchEvent(ls.SCROLL_ENDED), void (this._stopMouseWheel = !1);
          this._mouseWheelEventElapsedTime += t, this._mouseWheelEventElapsedTime > .1 && (this._onScrollBarTouchEnded(), this.unschedule(this._checkMouseWheel), this._dispatchEvent(ls.SCROLL_ENDED), this._stopMouseWheel = !1);
        }, n._calculateMovePercentDelta = function (t) {
          var e = t.anchor,
              i = t.applyToHorizontal,
              o = t.applyToVertical;
          this._calculateBoundary(), e.clampf(q.ZERO, q.ONE);

          var n = this._getContentBottomBoundary() - this._bottomBoundary;

          n = -n;

          var r = this._getContentLeftBoundary() - this._leftBoundary;

          r = -r;
          var s = new I();

          if (this._content && this.view) {
            var a = 0,
                h = this._content._uiProps.uiTransformComp.contentSize,
                l = this.view.contentSize;
            i && (a = h.width - l.width, s.x = r - a * e.x), o && (a = h.height - l.height, s.y = n - a * e.y);
          }

          return s;
        }, n._moveContentToTopLeft = function (t) {
          var e = this._getContentBottomBoundary() - this._bottomBoundary;

          e = -e;

          var i = new I(),
              o = 0,
              n = this._getContentLeftBoundary() - this._leftBoundary;

          if (n = -n, this._content) {
            var r = this._content._uiProps.uiTransformComp.contentSize;
            r.height < t.height && (o = r.height - t.height, i.y = e - o), r.width < t.width && (o = r.width - t.width, i.x = n);
          }

          this._updateScrollBarState(), this._moveContent(i), this._adjustContentOutOfBoundary();
        }, n._scaleChanged = function (t) {
          t === z.SCALE && this._calculateBoundary();
        }, o(e, [{
          key: "content",
          get: function get() {
            return this._content;
          },
          set: function set(t) {
            if (this._content !== t) {
              var e = t && t.parent && t.parent._uiProps.uiTransformComp;
              !t || t && e ? (this._content = t, this._calculateBoundary()) : y(4302);
            }
          }
        }, {
          key: "horizontalScrollBar",
          get: function get() {
            return this._horizontalScrollBar;
          },
          set: function set(t) {
            this._horizontalScrollBar !== t && (this._horizontalScrollBar = t, this._horizontalScrollBar && (this._horizontalScrollBar.setScrollView(this), this._updateScrollBar(q.ZERO)));
          }
        }, {
          key: "verticalScrollBar",
          get: function get() {
            return this._verticalScrollBar;
          },
          set: function set(t) {
            this._verticalScrollBar !== t && (this._verticalScrollBar = t, this._verticalScrollBar && (this._verticalScrollBar.setScrollView(this), this._updateScrollBar(q.ZERO)));
          }
        }, {
          key: "view",
          get: function get() {
            var t = this._content && this._content.parent;
            return t ? t._uiProps.uiTransformComp : null;
          }
        }]), e;
      }(hs), ss.EventType = ls, qr = n((Xr = as).prototype, "bounceDuration", [G, Tr, mr, vr], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 1;
        }
      }), Kr = n(Xr.prototype, "brake", [G, Cr, Sr, Er], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return .5;
        }
      }), Qr = n(Xr.prototype, "elastic", [G, Or, Ar], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !0;
        }
      }), $r = n(Xr.prototype, "inertia", [G, wr, Lr], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !0;
        }
      }), n(Xr.prototype, "content", [Dr, Pr, Ir], Object.getOwnPropertyDescriptor(Xr.prototype, "content"), Xr.prototype), Jr = n(Xr.prototype, "horizontal", [G, zr, Rr], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !0;
        }
      }), n(Xr.prototype, "horizontalScrollBar", [xr, Br, Nr], Object.getOwnPropertyDescriptor(Xr.prototype, "horizontalScrollBar"), Xr.prototype), ts = n(Xr.prototype, "vertical", [G, Hr, Mr], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !0;
        }
      }), n(Xr.prototype, "verticalScrollBar", [kr, Vr, Fr], Object.getOwnPropertyDescriptor(Xr.prototype, "verticalScrollBar"), Xr.prototype), es = n(Xr.prototype, "cancelInnerEvents", [G, Gr, jr], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !0;
        }
      }), is = n(Xr.prototype, "scrollEvents", [Ur, G, Wr, Zr], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return [];
        }
      }), os = n(Xr.prototype, "_content", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return null;
        }
      }), ns = n(Xr.prototype, "_horizontalScrollBar", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return null;
        }
      }), rs = n(Xr.prototype, "_verticalScrollBar", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return null;
        }
      }), Yr = Xr)) || Yr) || Yr) || Yr) || Yr) || Yr));

      r.ScrollView = Ms;
      var ks,
          Vs = new I();
      !function (t) {
        t[t.Horizontal = 0] = "Horizontal", t[t.Vertical = 1] = "Vertical";
      }(ks || (ks = {})), e(ks);

      var Fs,
          Gs,
          js,
          Us,
          Ws,
          Zs,
          Ys,
          Xs,
          qs,
          Ks,
          Qs,
          $s,
          Js,
          ta,
          ea,
          ia,
          oa,
          na,
          ra,
          sa,
          aa = function (e) {
        return t({
          Slider: e,
          SliderComponent: e
        }), e;
      }((ys = O("cc.Slider"), bs = R(), Ts = x(110), ms = B(), vs = N(Ct), Cs = A(yt), Ss = M(), Es = A(ks), Os = M(), As = $(), ws = M(), Ls = A([_t]), Ds = M(), ys(Ps = bs(Ps = Ts(Ps = ms(Ps = vs((Hs = Ns = function (t) {
        function e() {
          for (var e, i = arguments.length, o = new Array(i), n = 0; n < i; n++) {
            o[n] = arguments[n];
          }

          return e = t.call.apply(t, [this].concat(o)) || this, s(e, "slideEvents", zs, a(e)), s(e, "_handle", Rs, a(e)), s(e, "_direction", xs, a(e)), s(e, "_progress", Bs, a(e)), e._offset = new I(), e._dragging = !1, e._touchHandle = !1, e._handleLocalPos = new I(), e._touchPos = new I(), e;
        }

        i(e, t);
        var n = e.prototype;
        return n.__preload = function () {
          this._updateHandlePosition();
        }, n.onEnable = function () {
          this._updateHandlePosition(), this.node.on(P.TOUCH_START, this._onTouchBegan, this), this.node.on(P.TOUCH_MOVE, this._onTouchMoved, this), this.node.on(P.TOUCH_END, this._onTouchEnded, this), this.node.on(P.TOUCH_CANCEL, this._onTouchCancelled, this), this._handle && this._handle.isValid && (this._handle.node.on(P.TOUCH_START, this._onHandleDragStart, this), this._handle.node.on(P.TOUCH_MOVE, this._onTouchMoved, this), this._handle.node.on(P.TOUCH_END, this._onTouchEnded, this));
        }, n.onDisable = function () {
          this.node.off(P.TOUCH_START, this._onTouchBegan, this), this.node.off(P.TOUCH_MOVE, this._onTouchMoved, this), this.node.off(P.TOUCH_END, this._onTouchEnded, this), this.node.off(P.TOUCH_CANCEL, this._onTouchCancelled, this), this._handle && this._handle.isValid && (this._handle.node.off(P.TOUCH_START, this._onHandleDragStart, this), this._handle.node.off(P.TOUCH_MOVE, this._onTouchMoved, this), this._handle.node.off(P.TOUCH_END, this._onTouchEnded, this));
        }, n._onHandleDragStart = function (t) {
          if (t && this._handle && this._handle.node._uiProps.uiTransformComp) {
            this._dragging = !0, this._touchHandle = !0;
            var e = t.touch.getUILocation();
            I.set(this._touchPos, e.x, e.y, 0), this._handle.node._uiProps.uiTransformComp.convertToNodeSpaceAR(this._touchPos, this._offset), t.propagationStopped = !0;
          }
        }, n._onTouchBegan = function (t) {
          this._handle && t && (this._dragging = !0, this._touchHandle || this._handleSliderLogic(t.touch), t.propagationStopped = !0);
        }, n._onTouchMoved = function (t) {
          this._dragging && t && (this._handleSliderLogic(t.touch), t.propagationStopped = !0);
        }, n._onTouchEnded = function (t) {
          this._dragging = !1, this._touchHandle = !1, this._offset = new I(), t && (t.propagationStopped = !0);
        }, n._onTouchCancelled = function (t) {
          this._dragging = !1, t && (t.propagationStopped = !0);
        }, n._handleSliderLogic = function (t) {
          this._updateProgress(t), this._emitSlideEvent();
        }, n._emitSlideEvent = function () {
          _t.emitEvents(this.slideEvents, this), this.node.emit("slide", this);
        }, n._updateProgress = function (t) {
          if (this._handle && t) {
            var e = t.getUILocation();
            I.set(this._touchPos, e.x, e.y, 0);
            var i = this.node._uiProps.uiTransformComp,
                o = i.convertToNodeSpaceAR(this._touchPos, Vs);
            this.direction === ks.Horizontal ? this.progress = K(.5 + (o.x - this._offset.x) / i.width) : this.progress = K(.5 + (o.y - this._offset.y) / i.height);
          }
        }, n._updateHandlePosition = function () {
          if (this._handle) {
            this._handleLocalPos.set(this._handle.node.getPosition());

            var t = this.node._uiProps.uiTransformComp;
            this._direction === ks.Horizontal ? this._handleLocalPos.x = -t.width * t.anchorX + this.progress * t.width : this._handleLocalPos.y = -t.height * t.anchorY + this.progress * t.height, this._handle.node.setPosition(this._handleLocalPos);
          }
        }, n._changeLayout = function () {
          var t = this.node._uiProps.uiTransformComp,
              e = t.contentSize;

          if (t.setContentSize(e.height, e.width), this._handle) {
            var i = this._handle.node.position;
            this._direction === ks.Horizontal ? this._handle.node.setPosition(i.x, 0, i.z) : this._handle.node.setPosition(0, i.y, i.z), this._updateHandlePosition();
          }
        }, o(e, [{
          key: "handle",
          get: function get() {
            return this._handle;
          },
          set: function set(t) {
            this._handle !== t && (this._handle = t);
          }
        }, {
          key: "direction",
          get: function get() {
            return this._direction;
          },
          set: function set(t) {
            this._direction !== t && (this._direction = t, this._changeLayout());
          }
        }, {
          key: "progress",
          get: function get() {
            return this._progress;
          },
          set: function set(t) {
            this._progress !== t && (this._progress = t, this._updateHandlePosition());
          }
        }]), e;
      }(F), Ns.Direction = ks, n((Is = Hs).prototype, "handle", [Cs, Ss], Object.getOwnPropertyDescriptor(Is.prototype, "handle"), Is.prototype), n(Is.prototype, "direction", [Es, Os], Object.getOwnPropertyDescriptor(Is.prototype, "direction"), Is.prototype), n(Is.prototype, "progress", [Q, As, ws], Object.getOwnPropertyDescriptor(Is.prototype, "progress"), Is.prototype), zs = n(Is.prototype, "slideEvents", [Ls, G, Ds], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return [];
        }
      }), Rs = n(Is.prototype, "_handle", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return null;
        }
      }), xs = n(Is.prototype, "_direction", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return ks.Horizontal;
        }
      }), Bs = n(Is.prototype, "_progress", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return .1;
        }
      }), Ps = Is)) || Ps) || Ps) || Ps) || Ps) || Ps));

      function ha() {
        for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++) {
          e[i] = arguments[i];
        }

        return Object.assign.apply(Object, [{}].concat(e));
      }

      r.Slider = aa, function (t) {
        t.TOGGLE = "toggle";
      }(sa || (sa = {}));

      var la,
          ca,
          ua,
          _a,
          pa,
          da,
          ga,
          fa,
          ya,
          ba,
          Ta,
          ma,
          va = function (e) {
        return t({
          Toggle: e,
          ToggleComponent: e
        }), e;
      }((Fs = O("cc.Toggle"), Gs = R(), js = x(110), Us = B(), Ws = N(Ct), Zs = H(), Ys = M(), Xs = A(yt), qs = H(), Ks = M(), Qs = A([_t]), $s = M(), Fs(Js = Gs(Js = js(Js = Us(Js = Ws((ra = na = function (t) {
        function e() {
          for (var e, i = arguments.length, o = new Array(i), n = 0; n < i; n++) {
            o[n] = arguments[n];
          }

          return e = t.call.apply(t, [this].concat(o)) || this, s(e, "checkEvents", ea, a(e)), s(e, "_isChecked", ia, a(e)), s(e, "_checkMark", oa, a(e)), e;
        }

        i(e, t);
        var n = e.prototype;
        return n._internalToggle = function () {
          this.isChecked = !this.isChecked;
        }, n._set = function (t, e) {
          if (void 0 === e && (e = !0), this._isChecked != t) {
            this._isChecked = t;
            var i = this._toggleContainer;
            i && i.enabled && this.enabled && (t || !i.anyTogglesChecked() && !i.allowSwitchOff) && (this._isChecked = !0, i.notifyToggleCheck(this, e)), this.playEffect(), e && this._emitToggleEvents();
          }
        }, n.playEffect = function () {
          this._checkMark && (this._checkMark.node.active = this._isChecked);
        }, n.setIsCheckedWithoutNotify = function (t) {
          this._set(t, !1);
        }, n.onEnable = function () {
          t.prototype.onEnable.call(this), this.playEffect(), this.node.on(e.EventType.CLICK, this._internalToggle, this);
        }, n.onDisable = function () {
          t.prototype.onDisable.call(this), this.node.off(e.EventType.CLICK, this._internalToggle, this);
        }, n.OnDestroy = function () {
          var t = this._toggleContainer;
          t && t.ensureValidState();
        }, n._emitToggleEvents = function () {
          this.node.emit(e.EventType.TOGGLE, this), this.checkEvents && _t.emitEvents(this.checkEvents, this);
        }, o(e, [{
          key: "isChecked",
          get: function get() {
            return this._isChecked;
          },
          set: function set(t) {
            this._set(t);
          }
        }, {
          key: "checkMark",
          get: function get() {
            return this._checkMark;
          },
          set: function set(t) {
            this._checkMark !== t && (this._checkMark = t);
          }
        }, {
          key: "_resizeToTarget",
          set: function set(t) {
            t && this._resizeNodeToTargetNode();
          }
        }, {
          key: "_toggleContainer",
          get: function get() {
            var t = this.node.parent;
            return r.Node.isNode(t) ? t.getComponent("cc.ToggleContainer") : null;
          }
        }]), e;
      }(xe), na.EventType = ha(sa, Ie), n((ta = ra).prototype, "isChecked", [Zs, Ys], Object.getOwnPropertyDescriptor(ta.prototype, "isChecked"), ta.prototype), n(ta.prototype, "checkMark", [Xs, qs, Ks], Object.getOwnPropertyDescriptor(ta.prototype, "checkMark"), ta.prototype), ea = n(ta.prototype, "checkEvents", [Qs, G, $s], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return [];
        }
      }), ia = n(ta.prototype, "_isChecked", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !0;
        }
      }), oa = n(ta.prototype, "_checkMark", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return null;
        }
      }), Js = ta)) || Js) || Js) || Js) || Js) || Js));

      r.Toggle = va;

      var Ca,
          Sa,
          Ea,
          Oa,
          Aa,
          wa,
          La,
          Da,
          Pa,
          Ia,
          za,
          Ra,
          xa,
          Ba,
          Na,
          Ha,
          Ma,
          ka,
          Va,
          Fa,
          Ga,
          ja,
          Ua,
          Wa,
          Za,
          Ya,
          Xa,
          qa,
          Ka,
          Qa,
          $a,
          Ja,
          th,
          eh,
          ih,
          oh,
          nh,
          rh,
          sh,
          ah,
          hh,
          lh,
          ch,
          uh,
          _h,
          ph = function (e) {
        return t({
          ToggleContainer: e,
          ToggleContainerComponent: e
        }), e;
      }((la = O("cc.ToggleContainer"), ca = R(), ua = x(110), _a = B(), pa = M(), da = A([_t]), ga = M(), la(fa = ca(fa = ua(fa = _a(fa = L((ma = function (t) {
        function e() {
          for (var e, i = arguments.length, o = new Array(i), n = 0; n < i; n++) {
            o[n] = arguments[n];
          }

          return e = t.call.apply(t, [this].concat(o)) || this, s(e, "_allowSwitchOff", ba, a(e)), s(e, "checkEvents", Ta, a(e)), e;
        }

        i(e, t);
        var n = e.prototype;
        return n.onEnable = function () {
          this.ensureValidState(), this.node.on(P.CHILD_ADDED, this.ensureValidState, this), this.node.on(P.CHILD_REMOVED, this.ensureValidState, this);
        }, n.onDisable = function () {
          this.node.off(P.CHILD_ADDED, this.ensureValidState, this), this.node.off(P.CHILD_REMOVED, this.ensureValidState, this);
        }, n.activeToggles = function () {
          return this.toggleItems.filter(function (t) {
            return t.isChecked;
          });
        }, n.anyTogglesChecked = function () {
          return !!this.toggleItems.find(function (t) {
            return t.isChecked;
          });
        }, n.notifyToggleCheck = function (t, e) {
          if (void 0 === e && (e = !0), this.enabledInHierarchy) {
            for (var i = 0; i < this.toggleItems.length; i++) {
              var o = this.toggleItems[i];
              o !== t && (e ? o.isChecked = !1 : o.setIsCheckedWithoutNotify(!1));
            }

            this.checkEvents && r.Component.EventHandler.emitEvents(this.checkEvents, t);
          }
        }, n.ensureValidState = function () {
          var t = this.toggleItems;

          if (!this._allowSwitchOff && !this.anyTogglesChecked() && 0 !== t.length) {
            var e = t[0];
            e.isChecked = !0, this.notifyToggleCheck(e);
          }

          var i = this.activeToggles();
          if (i.length > 1) for (var o = i[0], n = 0; n < i.length; ++n) {
            var r = i[n];
            r !== o && (r.isChecked = !1);
          }
        }, o(e, [{
          key: "allowSwitchOff",
          get: function get() {
            return this._allowSwitchOff;
          },
          set: function set(t) {
            this._allowSwitchOff = t;
          }
        }, {
          key: "toggleItems",
          get: function get() {
            return this.node.children.map(function (t) {
              var e = t.getComponent("cc.Toggle");
              return e && e.enabled ? e : null;
            }).filter(Boolean);
          }
        }]), e;
      }(F), ba = n((ya = ma).prototype, "_allowSwitchOff", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !1;
        }
      }), n(ya.prototype, "allowSwitchOff", [pa], Object.getOwnPropertyDescriptor(ya.prototype, "allowSwitchOff"), ya.prototype), Ta = n(ya.prototype, "checkEvents", [da, G, ga], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return [];
        }
      }), fa = ya)) || fa) || fa) || fa) || fa) || fa));

      r.ToggleContainer = ph;
      var dh,
          gh,
          fh = new q();

      function yh(t) {
        return t instanceof ot ? ct : t._uiProps.uiTransformComp ? t._uiProps.uiTransformComp.contentSize : Y.ZERO;
      }

      function bh(t, e, i, o) {
        t.parent ? fh.set(t.parent.getScale().x, t.parent.getScale().y) : fh.set(0, 0);

        for (var n = fh.x, r = fh.y, s = 0, a = 0, h = t.parent;;) {
          if (!h) return i.x = i.y = 0, void (o.x = o.y = 1);
          var l = h.getPosition();
          if (s += l.x, a += l.y, (h = h.parent) === e) break;
          h ? fh.set(h.getScale().x, h.getScale().y) : fh.set(0, 0);
          var c = fh.x,
              u = fh.y;
          s *= c, a *= u, n *= c, r *= u;
        }

        o.x = 0 !== n ? 1 / n : 1, o.y = 0 !== r ? 1 / r : 1, i.x = -s, i.y = -a;
      }

      !function (t) {
        t[t.ONCE = 0] = "ONCE", t[t.ALWAYS = 1] = "ALWAYS", t[t.ON_WINDOW_RESIZE = 2] = "ON_WINDOW_RESIZE";
      }(dh || (dh = {})), e(dh), function (t) {
        t[t.TOP = 1] = "TOP", t[t.MID = 2] = "MID", t[t.BOT = 4] = "BOT", t[t.LEFT = 8] = "LEFT", t[t.CENTER = 16] = "CENTER", t[t.RIGHT = 32] = "RIGHT", t[t.HORIZONTAL = 56] = "HORIZONTAL", t[t.VERTICAL = 7] = "VERTICAL";
      }(gh || (gh = {}));

      var Th,
          mh,
          vh,
          Ch,
          Sh,
          Eh,
          Oh,
          Ah,
          wh,
          Lh,
          Dh,
          Ph,
          Ih,
          zh,
          Rh,
          xh,
          Bh,
          Nh,
          Hh,
          Mh = gh.TOP | gh.BOT,
          kh = gh.LEFT | gh.RIGHT,
          Vh = function (e) {
        return t({
          Widget: e,
          WidgetComponent: e
        }), e;
      }((Ca = O("cc.Widget"), Sa = R(), Ea = x(110), Oa = B(), Aa = N(Ct), wa = A(w), La = M(), Da = M(), Pa = M(), Ia = M(), za = M(), Ra = M(), xa = M(), Ba = X(), Na = X(), Ha = M(), Ma = M(), ka = M(), Va = M(), Fa = M(), Ga = M(), ja = A(dh), Ua = M(), Ca(Wa = Sa(Wa = Ea(Wa = Oa(Wa = Aa(Wa = L((_h = uh = function (t) {
        function e() {
          for (var e, i = arguments.length, o = new Array(i), n = 0; n < i; n++) {
            o[n] = arguments[n];
          }

          return (e = t.call.apply(t, [this].concat(o)) || this)._lastPos = new I(), e._lastSize = new Y(), e._dirty = !0, e._hadAlignOnce = !1, s(e, "_alignFlags", Ya, a(e)), s(e, "_target", Xa, a(e)), s(e, "_left", qa, a(e)), s(e, "_right", Ka, a(e)), s(e, "_top", Qa, a(e)), s(e, "_bottom", $a, a(e)), s(e, "_horizontalCenter", Ja, a(e)), s(e, "_verticalCenter", th, a(e)), s(e, "_isAbsLeft", eh, a(e)), s(e, "_isAbsRight", ih, a(e)), s(e, "_isAbsTop", oh, a(e)), s(e, "_isAbsBottom", nh, a(e)), s(e, "_isAbsHorizontalCenter", rh, a(e)), s(e, "_isAbsVerticalCenter", sh, a(e)), s(e, "_originalWidth", ah, a(e)), s(e, "_originalHeight", hh, a(e)), s(e, "_alignMode", lh, a(e)), s(e, "_lockFlags", ch, a(e)), e;
        }

        i(e, t);
        var n = e.prototype;
        return n.updateAlignment = function () {
          r._widgetManager.updateAlignment(this.node);
        }, n._validateTargetInDEV = function () {}, n.setDirty = function () {
          this._recursiveDirty();
        }, n.onEnable = function () {
          this.node.getPosition(this._lastPos), this._lastSize.set(this.node._uiProps.uiTransformComp.contentSize), r._widgetManager.add(this), this._hadAlignOnce = !1, this._registerEvent(), this._registerTargetEvents();
        }, n.onDisable = function () {
          r._widgetManager.remove(this), this._unregisterEvent(), this._unregisterTargetEvents();
        }, n.onDestroy = function () {
          this._removeParentEvent();
        }, n._adjustWidgetToAllowMovingInEditor = function () {}, n._adjustWidgetToAllowResizingInEditor = function () {}, n._adjustWidgetToAnchorChanged = function () {
          this.setDirty();
        }, n._adjustTargetToParentChanged = function (t) {
          t && this._unregisterOldParentEvents(t), this.node.getParent() && this._registerTargetEvents(), this._setDirtyByMode();
        }, n._registerEvent = function () {
          this.node.on(P.TRANSFORM_CHANGED, this._setDirtyByMode, this), this.node.on(P.SIZE_CHANGED, this._setDirtyByMode, this), this.node.on(P.ANCHOR_CHANGED, this._adjustWidgetToAnchorChanged, this), this.node.on(P.PARENT_CHANGED, this._adjustTargetToParentChanged, this);
        }, n._unregisterEvent = function () {
          this.node.off(P.TRANSFORM_CHANGED, this._setDirtyByMode, this), this.node.off(P.SIZE_CHANGED, this._setDirtyByMode, this), this.node.off(P.ANCHOR_CHANGED, this._adjustWidgetToAnchorChanged, this);
        }, n._removeParentEvent = function () {
          this.node.off(P.PARENT_CHANGED, this._adjustTargetToParentChanged, this);
        }, n._autoChangedValue = function (t, e) {
          if ((this._alignFlags & t) > 0) {
            var i = this.node.parent && this.node.parent._uiProps,
                o = i && i.uiTransformComp,
                n = o ? o.contentSize : ct;
            this.isAlignLeft && t === gh.LEFT ? this._left = e ? this._left * n.width : this._left / n.width : this.isAlignRight && t === gh.RIGHT ? this._right = e ? this._right * n.width : this._right / n.width : this.isAlignHorizontalCenter && t === gh.CENTER ? this._horizontalCenter = e ? this._horizontalCenter * n.width : this._horizontalCenter / n.width : this.isAlignTop && t === gh.TOP ? this._top = e ? this._top * n.height : this._top / n.height : this.isAlignBottom && t === gh.BOT ? this._bottom = e ? this._bottom * n.height : this._bottom / n.height : this.isAbsoluteVerticalCenter && t === gh.MID && (this._verticalCenter = this._verticalCenter / n.height), this._recursiveDirty();
          }
        }, n._registerTargetEvents = function () {
          var t = this._target || this.node.parent;
          t && t.getComponent(Ct) && (t.on(P.TRANSFORM_CHANGED, this._setDirtyByMode, this), t.on(P.SIZE_CHANGED, this._setDirtyByMode, this), t.on(P.ANCHOR_CHANGED, this._setDirtyByMode, this));
        }, n._unregisterTargetEvents = function () {
          var t = this._target || this.node.parent;
          t && (t.off(P.TRANSFORM_CHANGED, this._setDirtyByMode, this), t.off(P.SIZE_CHANGED, this._setDirtyByMode, this), t.off(P.ANCHOR_CHANGED, this._setDirtyByMode, this));
        }, n._unregisterOldParentEvents = function (t) {
          var e = this._target || t;
          e && (e.off(P.TRANSFORM_CHANGED, this._setDirtyByMode, this), e.off(P.SIZE_CHANGED, this._setDirtyByMode, this));
        }, n._setDirtyByMode = function () {
          (this.alignMode === dh.ALWAYS || b) && this._recursiveDirty();
        }, n._setAlign = function (t, e) {
          if (e !== (this._alignFlags & t) > 0) {
            var i = (t & kh) > 0,
                o = this.node._uiProps.uiTransformComp;
            e ? (this._alignFlags |= t, i ? (this.isAlignHorizontalCenter = !1, this.isStretchWidth && (this._originalWidth = o.width)) : (this.isAlignVerticalCenter = !1, this.isStretchHeight && (this._originalHeight = o.height))) : (i ? this.isStretchWidth && (o.width = this._originalWidth) : this.isStretchHeight && (o.height = this._originalHeight), this._alignFlags &= ~t);
          }
        }, n._recursiveDirty = function () {
          this._dirty || (this._dirty = !0);
        }, o(e, [{
          key: "target",
          get: function get() {
            return this._target;
          },
          set: function set(t) {
            this._target !== t && (this._unregisterTargetEvents(), this._target = t, this._registerTargetEvents(), this._validateTargetInDEV(), this._recursiveDirty());
          }
        }, {
          key: "isAlignTop",
          get: function get() {
            return (this._alignFlags & gh.TOP) > 0;
          },
          set: function set(t) {
            this._setAlign(gh.TOP, t), this._recursiveDirty();
          }
        }, {
          key: "isAlignBottom",
          get: function get() {
            return (this._alignFlags & gh.BOT) > 0;
          },
          set: function set(t) {
            this._setAlign(gh.BOT, t), this._recursiveDirty();
          }
        }, {
          key: "isAlignLeft",
          get: function get() {
            return (this._alignFlags & gh.LEFT) > 0;
          },
          set: function set(t) {
            this._setAlign(gh.LEFT, t), this._recursiveDirty();
          }
        }, {
          key: "isAlignRight",
          get: function get() {
            return (this._alignFlags & gh.RIGHT) > 0;
          },
          set: function set(t) {
            this._setAlign(gh.RIGHT, t), this._recursiveDirty();
          }
        }, {
          key: "isAlignVerticalCenter",
          get: function get() {
            return (this._alignFlags & gh.MID) > 0;
          },
          set: function set(t) {
            t ? (this.isAlignTop = !1, this.isAlignBottom = !1, this._alignFlags |= gh.MID) : this._alignFlags &= ~gh.MID, this._recursiveDirty();
          }
        }, {
          key: "isAlignHorizontalCenter",
          get: function get() {
            return (this._alignFlags & gh.CENTER) > 0;
          },
          set: function set(t) {
            t ? (this.isAlignLeft = !1, this.isAlignRight = !1, this._alignFlags |= gh.CENTER) : this._alignFlags &= ~gh.CENTER, this._recursiveDirty();
          }
        }, {
          key: "isStretchWidth",
          get: function get() {
            return (this._alignFlags & kh) === kh;
          }
        }, {
          key: "isStretchHeight",
          get: function get() {
            return (this._alignFlags & Mh) === Mh;
          }
        }, {
          key: "top",
          get: function get() {
            return this._top;
          },
          set: function set(t) {
            this._top = t, this._recursiveDirty();
          }
        }, {
          key: "editorTop",
          get: function get() {
            return this._isAbsTop ? this._top : 100 * this._top;
          },
          set: function set(t) {
            this._top = this._isAbsTop ? t : t / 100, this._recursiveDirty();
          }
        }, {
          key: "bottom",
          get: function get() {
            return this._bottom;
          },
          set: function set(t) {
            this._bottom = t, this._recursiveDirty();
          }
        }, {
          key: "editorBottom",
          get: function get() {
            return this._isAbsBottom ? this._bottom : 100 * this._bottom;
          },
          set: function set(t) {
            this._bottom = this._isAbsBottom ? t : t / 100, this._recursiveDirty();
          }
        }, {
          key: "left",
          get: function get() {
            return this._left;
          },
          set: function set(t) {
            this._left = t, this._recursiveDirty();
          }
        }, {
          key: "editorLeft",
          get: function get() {
            return this._isAbsLeft ? this._left : 100 * this._left;
          },
          set: function set(t) {
            this._left = this._isAbsLeft ? t : t / 100, this._recursiveDirty();
          }
        }, {
          key: "right",
          get: function get() {
            return this._right;
          },
          set: function set(t) {
            this._right = t, this._recursiveDirty();
          }
        }, {
          key: "editorRight",
          get: function get() {
            return this._isAbsRight ? this._right : 100 * this._right;
          },
          set: function set(t) {
            this._right = this._isAbsRight ? t : t / 100, this._recursiveDirty();
          }
        }, {
          key: "horizontalCenter",
          get: function get() {
            return this._horizontalCenter;
          },
          set: function set(t) {
            this._horizontalCenter = t, this._recursiveDirty();
          }
        }, {
          key: "editorHorizontalCenter",
          get: function get() {
            return this._isAbsHorizontalCenter ? this._horizontalCenter : 100 * this._horizontalCenter;
          },
          set: function set(t) {
            this._horizontalCenter = this._isAbsHorizontalCenter ? t : t / 100, this._recursiveDirty();
          }
        }, {
          key: "verticalCenter",
          get: function get() {
            return this._verticalCenter;
          },
          set: function set(t) {
            this._verticalCenter = t, this._recursiveDirty();
          }
        }, {
          key: "editorVerticalCenter",
          get: function get() {
            return this._isAbsVerticalCenter ? this._verticalCenter : 100 * this._verticalCenter;
          },
          set: function set(t) {
            this._verticalCenter = this._isAbsVerticalCenter ? t : t / 100, this._recursiveDirty();
          }
        }, {
          key: "isAbsoluteTop",
          get: function get() {
            return this._isAbsTop;
          },
          set: function set(t) {
            this._isAbsTop !== t && (this._isAbsTop = t, this._autoChangedValue(gh.TOP, this._isAbsTop));
          }
        }, {
          key: "isAbsoluteBottom",
          get: function get() {
            return this._isAbsBottom;
          },
          set: function set(t) {
            this._isAbsBottom !== t && (this._isAbsBottom = t, this._autoChangedValue(gh.BOT, this._isAbsBottom));
          }
        }, {
          key: "isAbsoluteLeft",
          get: function get() {
            return this._isAbsLeft;
          },
          set: function set(t) {
            this._isAbsLeft !== t && (this._isAbsLeft = t, this._autoChangedValue(gh.LEFT, this._isAbsLeft));
          }
        }, {
          key: "isAbsoluteRight",
          get: function get() {
            return this._isAbsRight;
          },
          set: function set(t) {
            this._isAbsRight !== t && (this._isAbsRight = t, this._autoChangedValue(gh.RIGHT, this._isAbsRight));
          }
        }, {
          key: "isAbsoluteHorizontalCenter",
          get: function get() {
            return this._isAbsHorizontalCenter;
          },
          set: function set(t) {
            this._isAbsHorizontalCenter !== t && (this._isAbsHorizontalCenter = t, this._autoChangedValue(gh.CENTER, this._isAbsHorizontalCenter));
          }
        }, {
          key: "isAbsoluteVerticalCenter",
          get: function get() {
            return this._isAbsVerticalCenter;
          },
          set: function set(t) {
            this._isAbsVerticalCenter !== t && (this._isAbsVerticalCenter = t, this._autoChangedValue(gh.MID, this._isAbsVerticalCenter));
          }
        }, {
          key: "alignMode",
          get: function get() {
            return this._alignMode;
          },
          set: function set(t) {
            this._alignMode = t, this._recursiveDirty();
          }
        }, {
          key: "alignFlags",
          get: function get() {
            return this._alignFlags;
          },
          set: function set(t) {
            this._alignFlags !== t && (this._alignFlags = t, this._recursiveDirty());
          }
        }]), e;
      }(F), uh.AlignMode = dh, n((Za = _h).prototype, "target", [wa, La], Object.getOwnPropertyDescriptor(Za.prototype, "target"), Za.prototype), n(Za.prototype, "isAlignTop", [Da], Object.getOwnPropertyDescriptor(Za.prototype, "isAlignTop"), Za.prototype), n(Za.prototype, "isAlignBottom", [Pa], Object.getOwnPropertyDescriptor(Za.prototype, "isAlignBottom"), Za.prototype), n(Za.prototype, "isAlignLeft", [Ia], Object.getOwnPropertyDescriptor(Za.prototype, "isAlignLeft"), Za.prototype), n(Za.prototype, "isAlignRight", [za], Object.getOwnPropertyDescriptor(Za.prototype, "isAlignRight"), Za.prototype), n(Za.prototype, "isAlignVerticalCenter", [Ra], Object.getOwnPropertyDescriptor(Za.prototype, "isAlignVerticalCenter"), Za.prototype), n(Za.prototype, "isAlignHorizontalCenter", [xa], Object.getOwnPropertyDescriptor(Za.prototype, "isAlignHorizontalCenter"), Za.prototype), n(Za.prototype, "isStretchWidth", [Ba], Object.getOwnPropertyDescriptor(Za.prototype, "isStretchWidth"), Za.prototype), n(Za.prototype, "isStretchHeight", [Na], Object.getOwnPropertyDescriptor(Za.prototype, "isStretchHeight"), Za.prototype), n(Za.prototype, "top", [Ha], Object.getOwnPropertyDescriptor(Za.prototype, "top"), Za.prototype), n(Za.prototype, "editorTop", [it], Object.getOwnPropertyDescriptor(Za.prototype, "editorTop"), Za.prototype), n(Za.prototype, "bottom", [Ma], Object.getOwnPropertyDescriptor(Za.prototype, "bottom"), Za.prototype), n(Za.prototype, "editorBottom", [it], Object.getOwnPropertyDescriptor(Za.prototype, "editorBottom"), Za.prototype), n(Za.prototype, "left", [ka], Object.getOwnPropertyDescriptor(Za.prototype, "left"), Za.prototype), n(Za.prototype, "editorLeft", [it], Object.getOwnPropertyDescriptor(Za.prototype, "editorLeft"), Za.prototype), n(Za.prototype, "right", [Va], Object.getOwnPropertyDescriptor(Za.prototype, "right"), Za.prototype), n(Za.prototype, "editorRight", [it], Object.getOwnPropertyDescriptor(Za.prototype, "editorRight"), Za.prototype), n(Za.prototype, "horizontalCenter", [Fa], Object.getOwnPropertyDescriptor(Za.prototype, "horizontalCenter"), Za.prototype), n(Za.prototype, "editorHorizontalCenter", [it], Object.getOwnPropertyDescriptor(Za.prototype, "editorHorizontalCenter"), Za.prototype), n(Za.prototype, "verticalCenter", [Ga], Object.getOwnPropertyDescriptor(Za.prototype, "verticalCenter"), Za.prototype), n(Za.prototype, "editorVerticalCenter", [it], Object.getOwnPropertyDescriptor(Za.prototype, "editorVerticalCenter"), Za.prototype), n(Za.prototype, "isAbsoluteTop", [it], Object.getOwnPropertyDescriptor(Za.prototype, "isAbsoluteTop"), Za.prototype), n(Za.prototype, "isAbsoluteBottom", [it], Object.getOwnPropertyDescriptor(Za.prototype, "isAbsoluteBottom"), Za.prototype), n(Za.prototype, "isAbsoluteLeft", [it], Object.getOwnPropertyDescriptor(Za.prototype, "isAbsoluteLeft"), Za.prototype), n(Za.prototype, "isAbsoluteRight", [it], Object.getOwnPropertyDescriptor(Za.prototype, "isAbsoluteRight"), Za.prototype), n(Za.prototype, "isAbsoluteHorizontalCenter", [it], Object.getOwnPropertyDescriptor(Za.prototype, "isAbsoluteHorizontalCenter"), Za.prototype), n(Za.prototype, "isAbsoluteVerticalCenter", [it], Object.getOwnPropertyDescriptor(Za.prototype, "isAbsoluteVerticalCenter"), Za.prototype), n(Za.prototype, "alignMode", [ja, Ua], Object.getOwnPropertyDescriptor(Za.prototype, "alignMode"), Za.prototype), n(Za.prototype, "alignFlags", [it], Object.getOwnPropertyDescriptor(Za.prototype, "alignFlags"), Za.prototype), Ya = n(Za.prototype, "_alignFlags", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 0;
        }
      }), Xa = n(Za.prototype, "_target", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return null;
        }
      }), qa = n(Za.prototype, "_left", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 0;
        }
      }), Ka = n(Za.prototype, "_right", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 0;
        }
      }), Qa = n(Za.prototype, "_top", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 0;
        }
      }), $a = n(Za.prototype, "_bottom", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 0;
        }
      }), Ja = n(Za.prototype, "_horizontalCenter", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 0;
        }
      }), th = n(Za.prototype, "_verticalCenter", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 0;
        }
      }), eh = n(Za.prototype, "_isAbsLeft", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !0;
        }
      }), ih = n(Za.prototype, "_isAbsRight", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !0;
        }
      }), oh = n(Za.prototype, "_isAbsTop", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !0;
        }
      }), nh = n(Za.prototype, "_isAbsBottom", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !0;
        }
      }), rh = n(Za.prototype, "_isAbsHorizontalCenter", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !0;
        }
      }), sh = n(Za.prototype, "_isAbsVerticalCenter", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !0;
        }
      }), ah = n(Za.prototype, "_originalWidth", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 0;
        }
      }), hh = n(Za.prototype, "_originalHeight", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 0;
        }
      }), lh = n(Za.prototype, "_alignMode", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return dh.ON_WINDOW_RESIZE;
        }
      }), ch = n(Za.prototype, "_lockFlags", [G, nt], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 0;
        }
      }), Wa = Za)) || Wa) || Wa) || Wa) || Wa) || Wa) || Wa));

      r.internal.computeInverseTransForTarget = bh, r.internal.getReadonlyNodeSize = yh, r.Widget = Vh;
      var Fh,
          Gh = new E();
      !function (t) {
        t[t.HORIZONTAL = 0] = "HORIZONTAL", t[t.VERTICAL = 1] = "VERTICAL";
      }(Fh || (Fh = {})), e(Fh);

      var jh,
          Uh,
          Wh,
          Zh,
          Yh,
          Xh,
          qh,
          Kh,
          Qh,
          $h,
          Jh,
          tl,
          el,
          il,
          ol,
          nl,
          rl,
          sl,
          al,
          hl,
          ll,
          cl,
          ul,
          _l,
          pl,
          dl,
          gl,
          fl,
          yl,
          bl,
          Tl,
          ml,
          vl,
          Cl,
          Sl,
          El,
          Ol,
          Al,
          wl,
          Ll,
          Dl,
          Pl,
          Il,
          zl = function (e) {
        return t({
          PageViewIndicator: e,
          PageViewIndicatorComponent: e
        }), e;
      }((Th = O("cc.PageViewIndicator"), mh = R(), vh = x(110), Ch = B(), Sh = A(ft), Eh = M(), Oh = A(Fh), Ah = M(), wh = A(Y), Lh = M(), Dh = M(), Th(Ph = mh(Ph = vh(Ph = Ch((Hh = Nh = function (t) {
        function e() {
          for (var e, i = arguments.length, o = new Array(i), n = 0; n < i; n++) {
            o[n] = arguments[n];
          }

          return e = t.call.apply(t, [this].concat(o)) || this, s(e, "spacing", zh, a(e)), s(e, "_spriteFrame", Rh, a(e)), s(e, "_direction", xh, a(e)), s(e, "_cellSize", Bh, a(e)), e._layout = null, e._pageView = null, e._indicators = [], e;
        }

        i(e, t);
        var n = e.prototype;
        return n.onLoad = function () {
          this._updateLayout();
        }, n.setPageView = function (t) {
          this._pageView = t, this._refresh();
        }, n._updateLayout = function () {
          this._layout = this.getComponent(Rn), this._layout || (this._layout = this.addComponent(Rn));
          var t = this._layout;
          this.direction === Fh.HORIZONTAL ? (t.type = Rn.Type.HORIZONTAL, t.spacingX = this.spacing) : this.direction === Fh.VERTICAL && (t.type = Rn.Type.VERTICAL, t.spacingY = this.spacing), t.resizeMode = Rn.ResizeMode.CONTAINER;
        }, n._createIndicator = function () {
          var t = new w();
          t.layer = this.node.layer;
          var e = t.addComponent(yt);
          return e.spriteFrame = this.spriteFrame, e.sizeMode = yt.SizeMode.CUSTOM, t.parent = this.node, t._uiProps.uiTransformComp.setContentSize(this._cellSize), t;
        }, n._changedState = function () {
          var t = this._indicators;

          if (0 !== t.length && this._pageView) {
            var e = this._pageView.curPageIdx;

            if (!(e >= t.length)) {
              for (var i = 0; i < t.length; ++i) {
                var o = t[i];

                if (o._uiProps.uiComp) {
                  var n = o._uiProps.uiComp;
                  Gh.set(n.color), Gh.a = 127.5, n.color = Gh;
                }
              }

              if (t[e]._uiProps.uiComp) {
                var r = t[e]._uiProps.uiComp;
                Gh.set(r.color), Gh.a = 255, r.color = Gh;
              }
            }
          }
        }, n._refresh = function () {
          if (this._pageView) {
            var t = this._indicators,
                e = this._pageView.getPages();

            if (e.length !== t.length) {
              var i = 0;
              if (e.length > t.length) for (i = 0; i < e.length; ++i) {
                t[i] || (t[i] = this._createIndicator());
              } else for (i = t.length - e.length; i > 0; --i) {
                var o = t[i - 1];
                this.node.removeChild(o), t.splice(i - 1, 1);
              }
              this._layout && this._layout.enabledInHierarchy && this._layout.updateLayout(), this._changedState();
            }
          }
        }, o(e, [{
          key: "spriteFrame",
          get: function get() {
            return this._spriteFrame;
          },
          set: function set(t) {
            this._spriteFrame !== t && (this._spriteFrame = t);
          }
        }, {
          key: "direction",
          get: function get() {
            return this._direction;
          },
          set: function set(t) {
            this._direction !== t && (this._direction = t);
          }
        }, {
          key: "cellSize",
          get: function get() {
            return this._cellSize;
          },
          set: function set(t) {
            this._cellSize !== t && (this._cellSize = t);
          }
        }]), e;
      }(F), Nh.Direction = Fh, n((Ih = Hh).prototype, "spriteFrame", [Sh, Eh], Object.getOwnPropertyDescriptor(Ih.prototype, "spriteFrame"), Ih.prototype), n(Ih.prototype, "direction", [Oh, Ah], Object.getOwnPropertyDescriptor(Ih.prototype, "direction"), Ih.prototype), n(Ih.prototype, "cellSize", [wh, Lh], Object.getOwnPropertyDescriptor(Ih.prototype, "cellSize"), Ih.prototype), zh = n(Ih.prototype, "spacing", [G, Dh], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 0;
        }
      }), Rh = n(Ih.prototype, "_spriteFrame", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return null;
        }
      }), xh = n(Ih.prototype, "_direction", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return Fh.HORIZONTAL;
        }
      }), Bh = n(Ih.prototype, "_cellSize", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return new Y(20, 20);
        }
      }), Ph = Ih)) || Ph) || Ph) || Ph) || Ph));

      r.PageViewIndicator = zl;
      var Rl,
          xl,
          Bl,
          Nl = new q();
      !function (t) {
        t[t.Unified = 0] = "Unified", t[t.Free = 1] = "Free";
      }(Rl || (Rl = {})), e(Rl), function (t) {
        t[t.Horizontal = 0] = "Horizontal", t[t.Vertical = 1] = "Vertical";
      }(xl || (xl = {})), e(xl), function (t) {
        t.PAGE_TURNING = "page-turning";
      }(Bl || (Bl = {}));

      var Hl = function (e) {
        return t({
          PageView: e,
          PageViewComponent: e
        }), e;
      }((jh = O("cc.PageView"), Uh = R(), Wh = x(110), Zh = B(), Yh = A(Rl), Xh = M(), qh = A(xl), Kh = M(), Qh = $(), $h = M(), Jh = $(), tl = M(), el = A(zl), il = M(), ol = M(), nl = A(pr), rl = X(), sl = A(pr), al = X(), hl = X(), ll = X(), cl = X(), ul = A([_t]), _l = X(), pl = M(), dl = A([_t]), gl = M(), jh(fl = Uh(fl = Wh(fl = Zh((Il = Pl = function (t) {
        function e() {
          for (var e, i = arguments.length, o = new Array(i), n = 0; n < i; n++) {
            o[n] = arguments[n];
          }

          return e = t.call.apply(t, [this].concat(o)) || this, s(e, "autoPageTurningThreshold", bl, a(e)), s(e, "horizontal", Tl, a(e)), s(e, "vertical", ml, a(e)), s(e, "cancelInnerEvents", vl, a(e)), s(e, "scrollEvents", Cl, a(e)), s(e, "pageTurningSpeed", Sl, a(e)), s(e, "pageEvents", El, a(e)), s(e, "_sizeMode", Ol, a(e)), s(e, "_direction", Al, a(e)), s(e, "_scrollThreshold", wl, a(e)), s(e, "_pageTurningEventTiming", Ll, a(e)), s(e, "_indicator", Dl, a(e)), e._curPageIdx = 0, e._lastPageIdx = 0, e._pages = [], e._initContentPos = new I(), e._scrollCenterOffsetX = [], e._scrollCenterOffsetY = [], e._touchBeganPosition = new q(), e._touchEndPosition = new q(), e;
        }

        i(e, t);
        var n = e.prototype;
        return n.onEnable = function () {
          t.prototype.onEnable.call(this), this.node.on(P.SIZE_CHANGED, this._updateAllPagesSize, this), this.node.on(e.EventType.SCROLL_ENG_WITH_THRESHOLD, this._dispatchPageTurningEvent, this);
        }, n.onDisable = function () {
          t.prototype.onDisable.call(this), this.node.off(P.SIZE_CHANGED, this._updateAllPagesSize, this), this.node.off(e.EventType.SCROLL_ENG_WITH_THRESHOLD, this._dispatchPageTurningEvent, this);
        }, n.onLoad = function () {
          this._initPages(), this.indicator && this.indicator.setPageView(this);
        }, n.getCurrentPageIndex = function () {
          return this._curPageIdx;
        }, n.setCurrentPageIndex = function (t) {
          this.scrollToPage(t, 1);
        }, n.getPages = function () {
          return this._pages;
        }, n.addPage = function (t) {
          t && -1 === this._pages.indexOf(t) && this.content && (t._uiProps.uiTransformComp ? (this.content.addChild(t), this._pages.push(t), this._updatePageView()) : y(4301));
        }, n.insertPage = function (t, e) {
          if (!(e < 0) && t && -1 === this._pages.indexOf(t) && this.content) if (e >= this._pages.length) this.addPage(t);else {
            if (!t._uiProps.uiTransformComp) return void y(4301);
            this._pages.splice(e, 0, t), this.content.insertChild(t, e), this._updatePageView();
          }
        }, n.removePage = function (t) {
          if (t && this.content) {
            var e = this._pages.indexOf(t);

            -1 !== e ? this.removePageAtIndex(e) : T(4300, t.name);
          }
        }, n.removePageAtIndex = function (t) {
          var e = this._pages;

          if (!(t < 0 || t >= e.length)) {
            var i = e[t];
            i && this.content && (this.content.removeChild(i), e.splice(t, 1), this._updatePageView());
          }
        }, n.removeAllPages = function () {
          if (this.content) {
            for (var t = this._pages, e = 0, i = t.length; e < i; e++) {
              this.content.removeChild(t[e]);
            }

            this._pages.length = 0, this._updatePageView();
          }
        }, n.scrollToPage = function (t, e) {
          void 0 === e && (e = .3), t < 0 || t >= this._pages.length || (this._curPageIdx = t, this.scrollToOffset(this._moveOffsetValue(t), e, !0), this.indicator && this.indicator._changedState());
        }, n.getScrollEndedEventTiming = function () {
          return this.pageTurningEventTiming;
        }, n._updatePageView = function () {
          if (this.content) {
            var t = this.content.getComponent(Rn);
            t && t.enabled && t.updateLayout();
            var e = this._pages.length;
            this._curPageIdx >= e && (this._curPageIdx = 0 === e ? 0 : e - 1, this._lastPageIdx = this._curPageIdx);

            for (var i = this._initContentPos, o = 0; o < e; ++o) {
              var n = this._pages[o].position;
              this.direction === xl.Horizontal ? this._scrollCenterOffsetX[o] = Math.abs(i.x + n.x) : this._scrollCenterOffsetY[o] = Math.abs(i.y + n.y);
            }

            this.indicator && this.indicator._refresh();
          }
        }, n._updateAllPagesSize = function () {
          var t = this.view;
          if (this.content && t && this._sizeMode === Rl.Unified) for (var e = this._pages, i = t.contentSize, o = 0, n = e.length; o < n; o++) {
            e[o]._uiProps.uiTransformComp.setContentSize(i);
          }
        }, n._handleReleaseLogic = function () {
          this._autoScrollToPage(), this._scrolling && (this._scrolling = !1, this._autoScrolling || this._dispatchEvent(e.EventType.SCROLL_ENDED));
        }, n._onTouchBegan = function (e, i) {
          e.touch.getUILocation(Nl), q.set(this._touchBeganPosition, Nl.x, Nl.y), t.prototype._onTouchBegan.call(this, e, i);
        }, n._onTouchMoved = function (e, i) {
          t.prototype._onTouchMoved.call(this, e, i);
        }, n._onTouchEnded = function (e, i) {
          e.touch.getUILocation(Nl), q.set(this._touchEndPosition, Nl.x, Nl.y), t.prototype._onTouchEnded.call(this, e, i);
        }, n._onTouchCancelled = function (e, i) {
          e.touch.getUILocation(Nl), q.set(this._touchEndPosition, Nl.x, Nl.y), t.prototype._onTouchCancelled.call(this, e, i);
        }, n._onMouseWheel = function () {}, n._syncScrollDirection = function () {
          this.horizontal = this.direction === xl.Horizontal, this.vertical = this.direction === xl.Vertical;
        }, n._syncSizeMode = function () {
          var t = this.view;

          if (this.content && t) {
            var e = this.content.getComponent(Rn);

            if (e) {
              if (this._sizeMode === Rl.Free && this._pages.length > 0) {
                var i = this._pages[0]._uiProps.uiTransformComp,
                    o = this._pages[this._pages.length - 1]._uiProps.uiTransformComp;
                this.direction === xl.Horizontal ? (e.paddingLeft = (t.width - i.width) / 2, e.paddingRight = (t.width - o.width) / 2) : this.direction === xl.Vertical && (e.paddingTop = (t.height - i.height) / 2, e.paddingBottom = (t.height - o.height) / 2);
              }

              e.updateLayout();
            }
          }
        }, n._initPages = function () {
          if (this.content) {
            this._initContentPos = this.content.position;

            for (var t = this.content.children, e = 0; e < t.length; ++e) {
              var i = t[e];
              this._pages.indexOf(i) >= 0 || this._pages.push(i);
            }

            this._syncScrollDirection(), this._syncSizeMode(), this._updatePageView();
          }
        }, n._dispatchPageTurningEvent = function () {
          this._lastPageIdx !== this._curPageIdx && (this._lastPageIdx = this._curPageIdx, _t.emitEvents(this.pageEvents, this, Bl.PAGE_TURNING), this.node.emit(Bl.PAGE_TURNING, this));
        }, n._isQuicklyScrollable = function (t) {
          if (this.direction === xl.Horizontal) {
            if (Math.abs(t.x) > this.autoPageTurningThreshold) return !0;
          } else if (this.direction === xl.Vertical && Math.abs(t.y) > this.autoPageTurningThreshold) return !0;

          return !1;
        }, n._moveOffsetValue = function (t) {
          var e = new q();
          if (this._sizeMode === Rl.Free) this.direction === xl.Horizontal ? e.x = this._scrollCenterOffsetX[t] : this.direction === xl.Vertical && (e.y = this._scrollCenterOffsetY[t]);else {
            var i = this.view;
            if (!i) return e;
            this.direction === xl.Horizontal ? e.x = t * i.width : this.direction === xl.Vertical && (e.y = t * i.height);
          }
          return e;
        }, n._getDragDirection = function (t) {
          return this._direction === xl.Horizontal ? 0 === t.x ? 0 : t.x > 0 ? 1 : -1 : 0 === t.y ? 0 : t.y < 0 ? 1 : -1;
        }, n._isScrollable = function (t, e, i) {
          if (this._sizeMode === Rl.Free) {
            var o = 0,
                n = 0;
            if (this.direction === xl.Horizontal) return o = this._scrollCenterOffsetX[e], n = this._scrollCenterOffsetX[i], Math.abs(t.x) >= Math.abs(o - n) * this.scrollThreshold;
            if (this.direction === xl.Vertical) return o = this._scrollCenterOffsetY[e], n = this._scrollCenterOffsetY[i], Math.abs(t.y) >= Math.abs(o - n) * this.scrollThreshold;
          } else {
            var r = this.view;
            if (!r) return !1;
            if (this.direction === xl.Horizontal) return Math.abs(t.x) >= r.width * this.scrollThreshold;
            if (this.direction === xl.Vertical) return Math.abs(t.y) >= r.height * this.scrollThreshold;
          }

          return !1;
        }, n._autoScrollToPage = function () {
          if (this._startBounceBackIfNeeded()) {
            var t = this._getHowMuchOutOfBoundary();

            this._clampDelta(t), (t.x > 0 || t.y < 0) && (this._curPageIdx = 0 === this._pages.length ? 0 : this._pages.length - 1), (t.x < 0 || t.y > 0) && (this._curPageIdx = 0), this.indicator && this.indicator._changedState();
          } else {
            var e = new q();
            q.subtract(e, this._touchBeganPosition, this._touchEndPosition);

            var i = this._curPageIdx,
                o = i + this._getDragDirection(e),
                n = this.pageTurningSpeed * Math.abs(i - o);

            if (o < this._pages.length) {
              if (this._isScrollable(e, i, o)) return void this.scrollToPage(o, n);

              var r = this._calculateTouchMoveVelocity();

              if (this._isQuicklyScrollable(r)) return void this.scrollToPage(o, n);
            }

            this.scrollToPage(i, n);
          }
        }, o(e, [{
          key: "sizeMode",
          get: function get() {
            return this._sizeMode;
          },
          set: function set(t) {
            this._sizeMode !== t && (this._sizeMode = t, this._syncSizeMode());
          }
        }, {
          key: "direction",
          get: function get() {
            return this._direction;
          },
          set: function set(t) {
            this._direction !== t && (this._direction = t, this._syncScrollDirection());
          }
        }, {
          key: "scrollThreshold",
          get: function get() {
            return this._scrollThreshold;
          },
          set: function set(t) {
            this._scrollThreshold !== t && (this._scrollThreshold = t);
          }
        }, {
          key: "pageTurningEventTiming",
          get: function get() {
            return this._pageTurningEventTiming;
          },
          set: function set(t) {
            this._pageTurningEventTiming !== t && (this._pageTurningEventTiming = t);
          }
        }, {
          key: "indicator",
          get: function get() {
            return this._indicator;
          },
          set: function set(t) {
            this._indicator !== t && (this._indicator = t, this.indicator && this.indicator.setPageView(this));
          }
        }, {
          key: "curPageIdx",
          get: function get() {
            return this._curPageIdx;
          }
        }, {
          key: "verticalScrollBar",
          get: function get() {
            return t.prototype.verticalScrollBar;
          },
          set: function set(t) {
            this.verticalScrollBar = t;
          }
        }, {
          key: "horizontalScrollBar",
          get: function get() {
            return t.prototype.horizontalScrollBar;
          },
          set: function set(t) {
            this.horizontalScrollBar = t;
          }
        }]), e;
      }(Ms), Pl.SizeMode = Rl, Pl.Direction = xl, Pl.EventType = ha(Bl, ls), n((yl = Il).prototype, "sizeMode", [Yh, Xh], Object.getOwnPropertyDescriptor(yl.prototype, "sizeMode"), yl.prototype), n(yl.prototype, "direction", [qh, Kh], Object.getOwnPropertyDescriptor(yl.prototype, "direction"), yl.prototype), n(yl.prototype, "scrollThreshold", [Q, Qh, $h], Object.getOwnPropertyDescriptor(yl.prototype, "scrollThreshold"), yl.prototype), n(yl.prototype, "pageTurningEventTiming", [Q, Jh, tl], Object.getOwnPropertyDescriptor(yl.prototype, "pageTurningEventTiming"), yl.prototype), n(yl.prototype, "indicator", [el, il], Object.getOwnPropertyDescriptor(yl.prototype, "indicator"), yl.prototype), bl = n(yl.prototype, "autoPageTurningThreshold", [G, ol], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 100;
        }
      }), n(yl.prototype, "verticalScrollBar", [nl, rt, rl], Object.getOwnPropertyDescriptor(yl.prototype, "verticalScrollBar"), yl.prototype), n(yl.prototype, "horizontalScrollBar", [sl, rt, al], Object.getOwnPropertyDescriptor(yl.prototype, "horizontalScrollBar"), yl.prototype), Tl = n(yl.prototype, "horizontal", [rt, G, hl], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !0;
        }
      }), ml = n(yl.prototype, "vertical", [rt, G, ll], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !0;
        }
      }), vl = n(yl.prototype, "cancelInnerEvents", [rt, G, cl], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !0;
        }
      }), Cl = n(yl.prototype, "scrollEvents", [ul, G, rt, _l], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return [];
        }
      }), Sl = n(yl.prototype, "pageTurningSpeed", [G, it, pl], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return .3;
        }
      }), El = n(yl.prototype, "pageEvents", [dl, G, gl], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return [];
        }
      }), Ol = n(yl.prototype, "_sizeMode", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return Rl.Unified;
        }
      }), Al = n(yl.prototype, "_direction", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return xl.Horizontal;
        }
      }), wl = n(yl.prototype, "_scrollThreshold", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return .5;
        }
      }), Ll = n(yl.prototype, "_pageTurningEventTiming", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return .1;
        }
      }), Dl = n(yl.prototype, "_indicator", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return null;
        }
      }), fl = yl)) || fl) || fl) || fl) || fl));

      r.PageView = Hl;
      var Ml = new I(),
          kl = new q(),
          Vl = new q(),
          Fl = new q(1, 1),
          Gl = new q(),
          jl = new q();

      function Ul(t, e) {
        if (!e._hadAlignOnce) {
          e.alignMode === dh.ONCE && (e._hadAlignOnce = !0);
          var i,
              o = e.target,
              n = Vl,
              r = Fl;
          o ? bh(t, i = o, n, r) : i = t.parent;
          var s = yh(i),
              a = i instanceof ot || !i.getComponent(Ct),
              h = a ? kl : i.getComponent(Ct).anchorPoint,
              l = a;
          t.getPosition(Ml);
          var c = t._uiProps.uiTransformComp,
              u = Ml.x,
              _ = Ml.y,
              p = c.anchorPoint,
              d = t.getScale();

          if (e.alignFlags & gh.HORIZONTAL) {
            var g = 0,
                f = 0,
                y = s.width;
            l ? (g = ct.left.x, f = ct.right.x) : f = (g = -h.x * y) + y, g += e.isAbsoluteLeft ? e.left : e.left * y, f -= e.isAbsoluteRight ? e.right : e.right * y, o && (g += n.x, g *= r.x, f += n.x, f *= r.x);
            var b = 0,
                T = p.x,
                m = d.x;
            if (m < 0 && (T = 1 - T, m = -m), e.isStretchWidth) b = f - g, 0 !== m && (c.width = b / m), u = g + T * b;else if (b = c.width * m, e.isAlignHorizontalCenter) {
              var v = e.isAbsoluteHorizontalCenter ? e.horizontalCenter : e.horizontalCenter * y,
                  C = (.5 - h.x) * s.width;
              o && (v *= r.x, C += n.x, C *= r.x), u = C + (T - .5) * b + v;
            } else u = e.isAlignLeft ? g + T * b : f + (T - 1) * b;
            e._lastSize.width = b;
          }

          if (e.alignFlags & gh.VERTICAL) {
            var S = 0,
                E = 0,
                O = s.height;
            l ? (E = ct.bottom.y, S = ct.top.y) : S = (E = -h.y * O) + O, E += e.isAbsoluteBottom ? e.bottom : e.bottom * O, S -= e.isAbsoluteTop ? e.top : e.top * O, o && (E += n.y, E *= r.y, S += n.y, S *= r.y);
            var A = 0,
                w = p.y,
                L = d.y;
            if (L < 0 && (w = 1 - w, L = -L), e.isStretchHeight) A = S - E, 0 !== L && (c.height = A / L), _ = E + w * A;else if (A = c.height * L, e.isAlignVerticalCenter) {
              var D = e.isAbsoluteVerticalCenter ? e.verticalCenter : e.verticalCenter * O,
                  P = (.5 - h.y) * s.height;
              o && (D *= r.y, P += n.y, P *= r.y), _ = P + (w - .5) * A + D;
            } else _ = e.isAlignBottom ? E + w * A : S + (w - 1) * A;
            e._lastSize.height = A;
          }

          t.setPosition(u, _, Ml.z), I.set(e._lastPos, u, _, Ml.z);
        }
      }

      function Wl(t) {
        var e = t.getComponent(Vh);

        if (e && e.enabled) {
          if (!r.isValid(t, !0)) return;
          Jl.push(e);
        }

        for (var i, o = t.children, n = f(o); !(i = n()).done;) {
          var s = i.value;
          s.active && Wl(s);
        }
      }

      function Zl() {
        var t = pt.getScene();

        if (t) {
          tc.isAligning = !0, tc._nodesOrderDirty && (Jl.length = 0, Wl(t), tc._nodesOrderDirty = !1);
          var e = null,
              i = tc._activeWidgetsIterator;

          for (i.i = 0; i.i < Jl.length; ++i.i) {
            (e = Jl[i.i])._dirty && (Ul(e.node, e), e._dirty = !1);
          }

          tc.isAligning = !1;
        }
      }

      var Yl,
          Xl,
          ql,
          Kl,
          Ql,
          $l,
          Jl = [],
          tc = t("widgetManager", r._widgetManager = {
        isAligning: !1,
        _nodesOrderDirty: !1,
        _activeWidgetsIterator: new m.MutableForwardIterator(Jl),
        animationState: null,
        init: function init() {
          pt.on(dt.EVENT_AFTER_SCENE_LAUNCH, Zl), pt.on(dt.EVENT_AFTER_UPDATE, Zl), ut.instance.on("design-resolution-changed", this.onResized, this);
          var t = this.onResized.bind(this);
          ut.instance.on("canvas-resize", t), W.on("orientation-change", t);
        },
        add: function add() {
          this._nodesOrderDirty = !0;
        },
        remove: function remove(t) {
          this._activeWidgetsIterator.remove(t);
        },
        onResized: function onResized() {
          var t = pt.getScene();
          t && this.refreshWidgetOnResized(t);
        },
        refreshWidgetOnResized: function refreshWidgetOnResized(t) {
          var e = w.isNode(t) && t.getComponent(Vh);
          e && e.enabled && (e.alignMode === dh.ON_WINDOW_RESIZE || e.alignMode === dh.ALWAYS) && e.setDirty();

          for (var i, o = t.children, n = f(o); !(i = n()).done;) {
            var r = i.value;
            this.refreshWidgetOnResized(r);
          }
        },
        updateOffsetsToStayPut: function updateOffsetsToStayPut(t, e) {
          function i(t, e) {
            return Math.abs(t - e) > 1e-10 ? e : t;
          }

          var o = t.node,
              n = o.parent;

          if (n) {
            var r = Gl;
            r.set(0, 0);
            var s = jl;
            if (s.set(1, 1), t.target && bh(o, n = t.target, r, s), !e) return;

            var a = n._uiProps && n._uiProps.uiTransformComp,
                h = a ? a.anchorPoint : kl,
                l = o._uiProps.uiTransformComp,
                c = yh(n),
                u = l.anchorPoint,
                _ = o.getPosition(),
                p = gh,
                d = o.getScale(),
                g = 0;

            if (e & p.LEFT) {
              var f = -h.x * c.width;
              f += r.x, f *= s.x, g = _.x - u.x * l.width * Math.abs(d.x) - f, t.isAbsoluteLeft || (g /= c.width), g /= s.x, t.left = i(t.left, g);
            }

            if (e & p.RIGHT) {
              var y = (1 - h.x) * c.width;
              y += r.x, g = (y *= s.x) - (_.x + (1 - u.x) * l.width * Math.abs(d.x)), t.isAbsoluteRight || (g /= c.width), g /= s.x, t.right = i(t.right, g);
            }

            if (e & p.TOP) {
              var b = (1 - h.y) * c.height;
              b += r.y, g = (b *= s.y) - (_.y + (1 - u.y) * l.height * Math.abs(d.y)), t.isAbsoluteTop || (g /= c.height), g /= s.y, t.top = i(t.top, g);
            }

            if (e & p.BOT) {
              var T = -h.y * c.height;
              T += r.y, T *= s.y, g = _.y - u.y * l.height * Math.abs(d.y) - T, t.isAbsoluteBottom || (g /= c.height), g /= s.y, t.bottom = i(t.bottom, g);
            }
          }
        },
        updateAlignment: function t(e) {
          var i = e.parent;
          i && w.isNode(i) && t(i);
          var o = e.getComponent(Vh);
          o && i && Ul(e, o);
        },
        AlignMode: dh,
        AlignFlags: gh
      });
      pt.on(dt.EVENT_INIT, function () {
        tc.init();
      });

      var ec,
          ic,
          oc,
          nc,
          rc,
          sc,
          ac,
          hc,
          lc,
          cc,
          uc,
          _c,
          pc,
          dc,
          gc,
          fc,
          yc,
          bc,
          Tc,
          mc,
          vc = function (e) {
        return t({
          SafeArea: e,
          SafeAreaComponent: e
        }), e;
      }((Yl = O("cc.SafeArea"), Xl = R(), ql = x(110), Kl = B(), Ql = N(Vh), Yl($l = Xl($l = ql($l = L($l = Kl($l = Ql($l = function (t) {
        function e() {
          return t.apply(this, arguments) || this;
        }

        i(e, t);
        var o = e.prototype;
        return o.onEnable = function () {
          this.updateArea(), W.on("window-resize", this.updateArea, this), W.on("orientation-change", this.updateArea, this);
        }, o.onDisable = function () {
          W.off("window-resize", this.updateArea, this), W.off("orientation-change", this.updateArea, this);
        }, o.updateArea = function () {
          var t = this.node.getComponent(Vh),
              e = this.node.getComponent(Ct);

          if (t && e) {
            t.updateAlignment();
            var i = this.node.position.clone(),
                o = e.anchorPoint.clone();
            t.isAlignTop = t.isAlignBottom = t.isAlignLeft = t.isAlignRight = !0;
            var n = lt.getVisibleSize(),
                r = n.width,
                s = n.height,
                a = U.getSafeAreaRect();
            t.top = s - a.y - a.height, t.bottom = a.y, t.left = a.x, t.right = r - a.x - a.width, t.updateAlignment();
            var h = this.node.position.clone(),
                l = o.x - (h.x - i.x) / e.width,
                c = o.y - (h.y - i.y) / e.height;
            e.setAnchorPoint(l, c), tc.add(t);
          }
        }, e;
      }(F)) || $l) || $l) || $l) || $l) || $l) || $l));

      r.SafeArea = vc;

      var Cc,
          Sc = function (e) {
        return t({
          UICoordinateTracker: e,
          UICoordinateTrackerComponent: e
        }), e;
      }((ec = O("cc.UICoordinateTracker"), ic = R(), oc = B(), nc = x(110), rc = A(w), sc = M(), ac = A(gt), hc = M(), lc = M(), cc = M(), uc = A([_t]), _c = M(), ec(pc = ic(pc = oc(pc = nc((mc = function (t) {
        function e() {
          for (var e, i = arguments.length, o = new Array(i), n = 0; n < i; n++) {
            o[n] = arguments[n];
          }

          return e = t.call.apply(t, [this].concat(o)) || this, s(e, "syncEvents", gc, a(e)), s(e, "_target", fc, a(e)), s(e, "_camera", yc, a(e)), s(e, "_useScale", bc, a(e)), s(e, "_distance", Tc, a(e)), e._transformPos = new I(), e._viewPos = new I(), e._canMove = !0, e._lastWPos = new I(), e._lastCameraPos = new I(), e;
        }

        i(e, t);
        var n = e.prototype;
        return n.onEnable = function () {
          this._checkCanMove();
        }, n.update = function () {
          var t = this.node.worldPosition,
              e = this._camera;

          if (this._canMove && e && e.camera && (!this._lastWPos.equals(t) || !this._lastCameraPos.equals(e.node.worldPosition)) && (this._lastWPos.set(t), this._lastCameraPos.set(e.node.worldPosition), e.camera.update(), e.convertToUINode(t, this._target, this._transformPos), this._useScale && I.transformMat4(this._viewPos, this.node.worldPosition, e.camera.matView), this.syncEvents.length > 0)) {
            var i = this._distance / Math.abs(this._viewPos.z);

            _t.emitEvents(this.syncEvents, this._transformPos, i);
          }
        }, n._checkCanMove = function () {
          this._canMove = !(!this._camera || !this._target);
        }, o(e, [{
          key: "target",
          get: function get() {
            return this._target;
          },
          set: function set(t) {
            this._target !== t && (this._target = t, this._checkCanMove());
          }
        }, {
          key: "camera",
          get: function get() {
            return this._camera;
          },
          set: function set(t) {
            this._camera !== t && (this._camera = t, this._checkCanMove());
          }
        }, {
          key: "useScale",
          get: function get() {
            return this._useScale;
          },
          set: function set(t) {
            this._useScale !== t && (this._useScale = t);
          }
        }, {
          key: "distance",
          get: function get() {
            return this._distance;
          },
          set: function set(t) {
            this._distance !== t && (this._distance = t);
          }
        }]), e;
      }(F), n((dc = mc).prototype, "target", [rc, sc], Object.getOwnPropertyDescriptor(dc.prototype, "target"), dc.prototype), n(dc.prototype, "camera", [ac, hc], Object.getOwnPropertyDescriptor(dc.prototype, "camera"), dc.prototype), n(dc.prototype, "useScale", [lc], Object.getOwnPropertyDescriptor(dc.prototype, "useScale"), dc.prototype), n(dc.prototype, "distance", [cc], Object.getOwnPropertyDescriptor(dc.prototype, "distance"), dc.prototype), gc = n(dc.prototype, "syncEvents", [uc, G, _c], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return [];
        }
      }), fc = n(dc.prototype, "_target", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return null;
        }
      }), yc = n(dc.prototype, "_camera", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return null;
        }
      }), bc = n(dc.prototype, "_useScale", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !0;
        }
      }), Tc = n(dc.prototype, "_distance", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 1;
        }
      }), pc = dc)) || pc) || pc) || pc) || pc)),
          Ec = [P.TOUCH_START, P.TOUCH_END, P.TOUCH_MOVE, P.MOUSE_DOWN, P.MOUSE_MOVE, P.MOUSE_UP, P.MOUSE_ENTER, P.MOUSE_LEAVE, P.MOUSE_WHEEL];

      function Oc(t) {
        t.propagationStopped = !0;
      }

      var Ac,
          wc,
          Lc,
          Dc,
          Pc,
          Ic,
          zc,
          Rc,
          xc,
          Bc,
          Nc,
          Hc,
          Mc,
          kc = function (e) {
        return t({
          BlockInputEvents: e,
          BlockInputEventsComponent: e
        }), e;
      }(O("cc.BlockInputEvents")(Cc = R()(Cc = B()(Cc = function (t) {
        function e() {
          return t.apply(this, arguments) || this;
        }

        i(e, t);
        var o = e.prototype;
        return o.onEnable = function () {
          for (var t = 0; t < Ec.length; t++) {
            this.node.on(Ec[t], Oc, this);
          }
        }, o.onDisable = function () {
          for (var t = 0; t < Ec.length; t++) {
            this.node.off(Ec[t], Oc, this);
          }
        }, e;
      }(F)) || Cc) || Cc) || Cc),
          Vc = t("SubContextView", (Ac = O("cc.SubContextView"), wc = R(), Lc = x(110), Dc = N(Ct), Pc = B(), Ic = M(), zc = M(), Ac(Rc = wc(Rc = Lc(Rc = Dc(Rc = Pc((Hc = function (t) {
        function e() {
          var e;
          return e = t.call(this) || this, s(e, "_fps", Bc, a(e)), e._sprite = void 0, e._imageAsset = void 0, e._texture = void 0, e._updatedTime = 0, e._updateInterval = 0, e._openDataContext = void 0, e._content = void 0, s(e, "_designResolutionSize", Nc, a(e)), e._content = new w("content"), e._content.hideFlags |= C.Flags.DontSave | C.Flags.HideInHierarchy, e._sprite = null, e._imageAsset = new st(), e._openDataContext = null, e._updatedTime = performance.now(), e._texture = new at(), e;
        }

        i(e, t);
        var n = e.prototype;
        return n.onLoad = function () {
          v.getOpenDataContext ? (this._updateInterval = 1e3 / this._fps, this._openDataContext = v.getOpenDataContext(), this._initSharedCanvas(), this._initContentNode(), this._updateSubContextView(), this._updateContentLayer()) : this.enabled = !1;
        }, n.onEnable = function () {
          this._registerNodeEvent();
        }, n.onDisable = function () {
          this._unregisterNodeEvent();
        }, n._initSharedCanvas = function () {
          if (this._openDataContext) {
            var t = this._openDataContext.canvas,
                e = this._designResolutionSize.width,
                i = this._designResolutionSize.height,
                o = 513;

            if (e <= o && i <= o) {
              var n = o / e,
                  r = o / i,
                  s = n < r ? n : r;
              e *= s, i *= s;
            }

            t.width = e, t.height = i;
          }
        }, n._initContentNode = function () {
          if (this._openDataContext) {
            var t = this._openDataContext.canvas,
                e = this._imageAsset;
            if (e.reset(t), this._texture.image = e, this._texture.create(t.width, t.height), this._sprite = this._content.getComponent(yt), this._sprite || (this._sprite = this._content.addComponent(yt)), this._sprite.spriteFrame) this._sprite.spriteFrame.texture = this._texture;else {
              var i = new ft();
              i.texture = this._texture, this._sprite.spriteFrame = i;
            }
            this._content.parent = this.node;
          }
        }, n._updateSubContextView = function () {
          if (this._openDataContext) {
            var t = this.node.getComponent(Ct),
                e = this._content.getComponent(Ct),
                i = t.width / e.width,
                o = t.height / e.height,
                n = i > o ? o : i;

            e.width *= n, e.height *= n;

            var r = lt.getViewportRect(),
                s = e.getBoundingBoxToWorld(),
                a = lt.getVisibleSize(),
                h = W.devicePixelRatio,
                l = (r.width * (s.x / a.width) + r.x) / h,
                c = (r.height * (s.y / a.height) + r.y) / h,
                u = r.width * (s.width / a.width) / h,
                _ = r.height * (s.height / a.height) / h;

            this._openDataContext.postMessage({
              fromEngine: !0,
              type: "engine",
              event: "viewport",
              x: l,
              y: c,
              width: u,
              height: _
            });
          }
        }, n._updateSubContextTexture = function () {
          var t = this._imageAsset;

          if (t && this._openDataContext && !(t.width <= 0 || t.height <= 0)) {
            var e = this._openDataContext.canvas;
            t.reset(e), (e.width > t.width || e.height > t.height) && this._texture.create(e.width, e.height), this._texture.uploadData(e);
          }
        }, n._registerNodeEvent = function () {
          this.node.on(P.TRANSFORM_CHANGED, this._updateSubContextView, this), this.node.on(P.SIZE_CHANGED, this._updateSubContextView, this), this.node.on(P.LAYER_CHANGED, this._updateContentLayer, this);
        }, n._unregisterNodeEvent = function () {
          this.node.off(P.TRANSFORM_CHANGED, this._updateSubContextView, this), this.node.off(P.SIZE_CHANGED, this._updateSubContextView, this), this.node.off(P.LAYER_CHANGED, this._updateContentLayer, this);
        }, n._updateContentLayer = function () {
          this._content.layer = this.node.layer;
        }, n.update = function (t) {
          void 0 === t ? this._updateSubContextTexture() : performance.now() - this._updatedTime >= this._updateInterval && (this._updatedTime += this._updateInterval, this._updateSubContextTexture());
        }, n.onDestroy = function () {
          this._content.destroy(), this._texture.destroy(), this._sprite && this._sprite.destroy(), this._imageAsset.destroy(), this._openDataContext = null;
        }, o(e, [{
          key: "designResolutionSize",
          get: function get() {
            return this._designResolutionSize;
          },
          set: function set() {}
        }, {
          key: "fps",
          get: function get() {
            return this._fps;
          },
          set: function set(t) {
            this._fps !== t && (this._fps = t, this._updateInterval = 1e3 / t);
          }
        }]), e;
      }(F), n((xc = Hc).prototype, "designResolutionSize", [Ic], Object.getOwnPropertyDescriptor(xc.prototype, "designResolutionSize"), xc.prototype), n(xc.prototype, "fps", [zc], Object.getOwnPropertyDescriptor(xc.prototype, "fps"), xc.prototype), Bc = n(xc.prototype, "_fps", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 60;
        }
      }), Nc = n(xc.prototype, "_designResolutionSize", [G], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return new Y(640, 960);
        }
      }), Rc = xc)) || Rc) || Rc) || Rc) || Rc) || Rc));

      r.SubContextView = Vc;
      var Fc = t("UIReorderComponent", O("cc.UIReorderComponent")(Mc = function Mc() {
        T(1408, "UIReorderComponent");
      }) || Mc);
      r.UIReorderComponent = Fc, r.ButtonComponent = xe, S.setClassAlias(xe, "cc.ButtonComponent"), r.EditBoxComponent = hn, S.setClassAlias(hn, "cc.EditBoxComponent"), r.LayoutComponent = Rn, S.setClassAlias(Rn, "cc.LayoutComponent"), r.ProgressBarComponent = nr, S.setClassAlias(nr, "cc.ProgressBarComponent"), r.ScrollViewComponent = Ms, S.setClassAlias(Ms, "cc.ScrollViewComponent"), r.ScrollBarComponent = pr, S.setClassAlias(pr, "cc.ScrollBarComponent"), r.SliderComponent = aa, S.setClassAlias(aa, "cc.SliderComponent"), r.ToggleComponent = va, S.setClassAlias(va, "cc.ToggleComponent"), r.ToggleContainerComponent = ph, S.setClassAlias(ph, "cc.ToggleContainerComponent"), r.WidgetComponent = Vh, S.setClassAlias(Vh, "cc.WidgetComponent"), r.PageViewComponent = Hl, S.setClassAlias(Hl, "cc.PageViewComponent"), r.PageViewIndicatorComponent = zl, S.setClassAlias(zl, "cc.PageViewIndicatorComponent"), r.SafeAreaComponent = vc, S.setClassAlias(vc, "cc.SafeAreaComponent"), S.setClassAlias(Sc, "cc.UICoordinateTrackerComponent"), r.BlockInputEventsComponent = kc, S.setClassAlias(kc, "cc.BlockInputEventsComponent");
    }
  };
}); 
 			}); 
		define("__plugin__/wx0446ba2621dda60a/video.js", function(require, module, exports){ 			
"use strict";

System.register(["./texture-barrier-60b5983b.js", "./json-asset-933a1d4c.js", "./index-f2b92470.js", "./renderable-component-7c6600ed.js", "./deprecated-26630860.js", "./deprecated-ef6bb945.js", "./renderable-2d-e2838949.js", "./deprecated-5f7f37d5.js"], function (t) {
  "use strict";

  var e, i, n, s, o, r, a, l, h, c, p, u, _, d, y, m, f, v, b, E, A, g, O, w, P, T, k, L, R, S, D, C, U, M, V, F, N, H, I, x;

  return {
    setters: [function (t) {
      e = t.bT, i = t.bU, n = t.c0, s = t.c1, o = t.b$, r = t.a, a = t.bv, l = t.e, h = t.l, c = t.cd, p = t.w, u = t.bS, _ = t.cO, d = t.a5;
    }, function (t) {
      y = t.bW, m = t.aL, f = t.bX, v = t.$, b = t.b0, E = t.a$, A = t.ca, g = t.bZ, O = t.cd, w = t.di, P = t.cg, T = t.ch, k = t.dQ, L = t.cc, R = t.dj, S = t.aa, D = t.bm, C = t.bY, U = t.ax;
    }, function (t) {
      M = t.d, V = t.f;
    }, function () {}, function (t) {
      F = t.g, N = t.k;
    }, function (t) {
      H = t.d, I = t.E;
    }, function (t) {
      x = t.U;
    }, function () {}],
    execute: function execute() {
      var j,
          B,
          G,
          Y,
          z = t("VideoClip", y("cc.VideoClip")((Y = function (t) {
        function n() {
          var e;
          return e = t.call(this) || this, s(e, "_duration", G, o(e)), e._video = null, e;
        }

        return e(n, t), i(n, [{
          key: "_nativeAsset",
          get: function get() {
            return this._video;
          },
          set: function set(t) {
            this._video = t, this._duration = t ? t.duration : 0;
          }
        }]), n;
      }(m), G = n((B = Y).prototype, "_duration", [f], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 0;
        }
      }), j = B)) || j);

      function W(t, e, i) {
        var n = document.createElement("video"),
            s = document.createElement("source");
        n.appendChild(s);
        var o = new XMLHttpRequest();
        o.open("GET", t, !0), o.responseType = "blob", o.onload = function () {
          200 === this.status || 0 === this.status ? (s.src = URL.createObjectURL(this.response), i(null, n)) : i(new Error(o.status + "(no response)"));
        }, o.onerror = function () {
          var e = "load video failure - " + t;
          r(e), i(new Error(e));
        }, o.send();
      }

      function K(t, e, i, n) {
        var s = new z();
        s._nativeUrl = t, s._nativeAsset = e, n(null, s);
      }

      M.register({
        ".mp4": W,
        ".avi": W,
        ".mov": W,
        ".mpg": W,
        ".mpeg": W,
        ".rm": W,
        ".rmvb": W
      }), V.register({
        ".mp4": K,
        ".avi": K,
        ".mov": K,
        ".mpg": K,
        ".mpeg": K,
        ".rm": K,
        ".rmvb": K
      });
      var q,
          Q,
          $ = a({
        REMOTE: 0,
        LOCAL: 1
      });
      !function (t) {
        t.NONE = "none", t.PLAYING = "playing", t.PAUSED = "paused", t.STOPPED = "stopped", t.COMPLETED = "completed", t.META_LOADED = "meta-loaded", t.READY_TO_PLAY = "ready-to-play", t.ERROR = "error", t.CLICKED = "clicked";
      }(q || (q = {})), function (t) {
        t[t.HAVE_NOTHING = 0] = "HAVE_NOTHING", t[t.HAVE_METADATA = 1] = "HAVE_METADATA", t[t.HAVE_CURRENT_DATA = 2] = "HAVE_CURRENT_DATA", t[t.HAVE_FUTURE_DATA = 3] = "HAVE_FUTURE_DATA", t[t.HAVE_ENOUGH_DATA = 4] = "HAVE_ENOUGH_DATA";
      }(Q || (Q = {}));

      var X = function () {
        function t(t) {
          var e = this;
          this._componentEventList = new Map(), this._state = q.NONE, this._video = null, this._onHide = void 0, this._onShow = void 0, this._interrupted = !1, this._loaded = !1, this._loadedMeta = !1, this._ignorePause = !1, this._fullScreenOnAwake = !1, this._visible = !0, this._playing = !1, this._cachedCurrentTime = -1, this._waitingFullscreen = !1, this._waitingPlay = !1, this._keepAspectRatio = !1, this._component = null, this._uiTrans = null, this._node = null, this._stayOnBottom = !1, this._dirty = !1, this._forceUpdate = !1, this._w = 0, this._h = 0, this._m00 = 0, this._m01 = 0, this._m04 = 0, this._m05 = 0, this._m12 = 0, this._m13 = 0, this._component = t, this._node = t.node, this._uiTrans = t.node.getComponent(x), this._onHide = function () {
            e.video && e._state === q.PLAYING && (e.video.pause(), e._interrupted = !0);
          }, this._onShow = function () {
            e._interrupted && e.video && (e.video.play(), e._interrupted = !1);
          }, h.game.on(h.Game.EVENT_HIDE, this._onHide), h.game.on(h.Game.EVENT_SHOW, this._onShow);
        }

        var e = t.prototype;
        return e.onLoadedMetadata = function (t) {
          this._loadedMeta = !0, this._forceUpdate = !0, this._visible ? this.enable() : this.disable(), this.dispatchEvent(q.META_LOADED);
          var e = t.target;
          this._keepAspectRatio && e && this.syncUITransform(e.videoWidth, e.videoHeight), this.delayedFullScreen(), this.delayedPlay();
        }, e.onCanPlay = function () {
          this._loaded = !0, this.dispatchEvent(q.READY_TO_PLAY);
        }, e.onPlay = function () {
          this._playing = !0, this.dispatchEvent(q.PLAYING);
        }, e.onPlaying = function () {
          this.dispatchEvent(q.PLAYING);
        }, e.onPause = function () {
          this._ignorePause ? this._ignorePause = !1 : (this._playing = !1, this.dispatchEvent(q.PAUSED));
        }, e.onStoped = function () {
          this._playing = !1, this._ignorePause = !1, this.dispatchEvent(q.STOPPED);
        }, e.onEnded = function () {
          this.dispatchEvent(q.COMPLETED);
        }, e.onClick = function () {
          this.dispatchEvent(q.CLICKED);
        }, e.onError = function (t) {
          this.dispatchEvent(q.ERROR);
          var e = t.target;
          e && e.error && l("Error " + e.error.code + "; details: " + e.error.message);
        }, e.play = function () {
          this._loadedMeta || this._loaded ? this.canPlay() : this._waitingPlay = !0;
        }, e.delayedPlay = function () {
          this._waitingPlay && (this.canPlay(), this._waitingPlay = !1);
        }, e.syncFullScreenOnAwake = function (t) {
          this._fullScreenOnAwake = t, this._loadedMeta || this._loaded ? this.canFullScreen(t) : this._waitingFullscreen = !0;
        }, e.delayedFullScreen = function () {
          this._waitingFullscreen && (this.canFullScreen(this._fullScreenOnAwake), this._waitingFullscreen = !1);
        }, e.dispatchEvent = function (t) {
          var e = this._componentEventList.get(t);

          e && (this._state = t, e.call(this));
        }, e.syncUITransform = function (t, e) {
          this._uiTrans && (this._uiTrans.width = t, this._uiTrans.height = e);
        }, e.syncCurrentTime = function () {
          this.video && -1 !== this._cachedCurrentTime && this.video.currentTime !== this._cachedCurrentTime && (this.seekTo(this._cachedCurrentTime), this._cachedCurrentTime = -1);
        }, e.destroy = function () {
          this.removeVideoPlayer(), this._componentEventList.clear(), h.game.off(h.Game.EVENT_HIDE, this._onHide), h.game.off(h.Game.EVENT_SHOW, this._onShow);
        }, i(t, [{
          key: "fullScreenOnAwake",
          get: function get() {
            return this._fullScreenOnAwake;
          }
        }, {
          key: "loaded",
          get: function get() {
            return this._loaded;
          }
        }, {
          key: "componentEventList",
          get: function get() {
            return this._componentEventList;
          }
        }, {
          key: "video",
          get: function get() {
            return this._video;
          }
        }, {
          key: "state",
          get: function get() {
            return this._state;
          }
        }, {
          key: "isPlaying",
          get: function get() {
            return this._playing;
          }
        }, {
          key: "UICamera",
          get: function get() {
            return H.root.batcher2D.getFirstRenderCamera(this._node);
          }
        }]), t;
      }();

      h.internal.VideoPlayerImpl = X;

      var Z,
          J,
          tt,
          et,
          it,
          nt,
          st,
          ot,
          rt,
          at,
          lt,
          ht,
          ct,
          pt,
          ut,
          _t,
          dt,
          yt,
          mt,
          ft,
          vt,
          bt,
          Et,
          At,
          gt,
          Ot,
          wt,
          Pt,
          Tt,
          kt,
          Lt,
          Rt,
          St,
          Dt,
          Ct,
          Ut,
          Mt,
          Vt,
          Ft,
          Nt = -Math.pow(2, 15),
          Ht = v(),
          It = function (t) {
        function i(e) {
          var i;
          return (i = t.call(this, e) || this)._eventList = new Map(), i._clearColorA = -1, i._clearFlag = void 0, i;
        }

        e(i, t);
        var n = i.prototype;
        return n.addListener = function (t, e) {
          this._video && (this._eventList.set(t, e), this._video.addEventListener(t, e));
        }, n.removeAllListeners = function () {
          var t = this;
          this._eventList.forEach(function (e, i) {
            t._video && t._video.removeEventListener(i, e);
          }), this._eventList.clear();
        }, n.canPlay = function () {
          var t = this;

          if (this.video) {
            var e = this.video.play();
            window.Promise && e instanceof Promise && e.catch(function () {}).then(function () {
              t.syncCurrentTime();
            });
          }
        }, n.pause = function () {
          this.video && (this.video.pause(), this._cachedCurrentTime = this.video.currentTime);
        }, n.resume = function () {
          this.play();
        }, n.stop = function () {
          var t = this;
          this.video && (this._ignorePause = !0, this.video.currentTime = 0, this.video.pause(), this._cachedCurrentTime = 0, setTimeout(function () {
            t._ignorePause = !1, t.dispatchEvent(q.STOPPED);
          }, 0));
        }, n.syncClip = function (t) {
          this.removeVideoPlayer(), t && this.createVideoPlayer(t.nativeUrl);
        }, n.syncURL = function (t) {
          this.removeVideoPlayer(), t && this.createVideoPlayer(t);
        }, n.syncPlaybackRate = function (t) {
          b.browserType !== c.UC ? this.video && (this.video.playbackRate = t) : p("playbackRate is not supported by the uc mobile browser.");
        }, n.syncVolume = function (t) {
          this.video && (this.video.volume = t);
        }, n.syncMute = function (t) {
          this.video && (this.video.muted = t);
        }, n.syncLoop = function (t) {
          this.video && (this.video.loop = t);
        }, n.getDuration = function () {
          return this.video ? this.video.duration : 0;
        }, n.getCurrentTime = function () {
          return this.video ? this.video.currentTime : -1;
        }, n.seekTo = function (t) {
          this.video && (this.video.currentTime = t);
        }, n.canFullScreen = function (t) {
          var e = this,
              i = this._video;
          if (i && i.readyState === Q.HAVE_ENOUGH_DATA) return b.os === u.IOS && b.isBrowser ? (t ? i.webkitEnterFullscreen && i.webkitEnterFullscreen() : i.webkitExitFullscreen && i.webkitExitFullscreen(), void (this._fullScreenOnAwake = i.webkitDisplayingFullscreen)) : E.supportsFullScreen ? void (t ? (b.browserType === c.IE && (i.style.transform = ""), i.setAttribute("x5-video-player-fullscreen", "true"), E.requestFullScreen(i, function (t) {
            var n = b.browserType === c.IE ? t.msFullscreenElement : t.fullscreenElement;
            e._fullScreenOnAwake = n === i;
          }, function () {
            e._fullScreenOnAwake = !1;
          })) : (i.removeAttribute("x5-video-player-fullscreen"), E.exitFullScreen())) : (this._fullScreenOnAwake = t, this._forceUpdate = !0, void this.syncMatrix());
        }, n.syncStayOnBottom = function (t) {
          this._video && (this._video.style["z-index"] = t ? Nt : 0, this._stayOnBottom = t), this._dirty = !0;
        }, n.syncKeepAspectRatio = function (t) {
          this._keepAspectRatio = t, t && this._loadedMeta && this._video && this.syncUITransform(this._video.videoWidth, this._video.videoHeight);
        }, n.removeVideoPlayer = function () {
          var t = this._video;
          t && _(F.container, t) && (F.container.removeChild(t), this.removeAllListeners()), this._cachedCurrentTime = 0, this._playing = !1, this._loaded = !1, this._loadedMeta = !1, this._video = null;
        }, n.createVideoPlayer = function (t) {
          var e = this._video = document.createElement("video");
          e.className = "cocosVideo", e.style.visibility = "hidden", e.style.position = "absolute", e.style.bottom = "0px", e.style.left = "0px", e.style["transform-origin"] = "0px 100% 0px", e.style["-webkit-transform-origin"] = "0px 100% 0px", e.setAttribute("preload", "auto"), e.setAttribute("webkit-playsinline", ""), e.setAttribute("x5-playsinline", ""), e.setAttribute("playsinline", ""), this._bindDomEvent(), F.container.appendChild(e);
          var i = document.createElement("source");
          e.appendChild(i), i.src = t;
        }, n._bindDomEvent = function () {
          this._video, this.addListener("loadedmetadata", this.onLoadedMetadata.bind(this)), this.addListener("canplay", this.onCanPlay.bind(this)), this.addListener("canplaythrough", this.onCanPlay.bind(this)), this.addListener("play", this.onPlay.bind(this)), this.addListener("playing", this.onPlaying.bind(this)), this.addListener("pause", this.onPause.bind(this)), this.addListener("click", this.onClick.bind(this)), this.addListener("ended", this.onEnded.bind(this)), this.addListener("error", this.onError.bind(this));
        }, n.onCanPlay = function (e) {
          var i = e.target;
          if (!this._loaded || !i) switch (i.readyState) {
            case Q.HAVE_METADATA:
            case Q.HAVE_ENOUGH_DATA:
              t.prototype.onCanPlay.call(this, e);
          }
        }, n.enable = function () {
          if (this._video) {
            if (this._visible = !0, "visible" === this._video.style.visibility) return;
            this._video.style.visibility = "visible";
          }
        }, n.disable = function (t) {
          if (this._video) {
            if (!t && this._playing && this._video.pause(), this._visible = !1, "hidden" === this._video.style.visibility) return;
            this._video.style.visibility = "hidden";
          }
        }, n.syncMatrix = function () {
          if (this._video && this._visible && this._component) {
            var t = this.UICamera;

            if (t && !E.fullScreen()) {
              this._dirty && (this._dirty = !1, this._stayOnBottom ? (this._clearColorA = t.clearColor.w, this._clearFlag = t.clearFlag, t.clearColor.w = 0, t.clearFlag = d.ALL) : this._clearFlag && (t.clearColor.w = this._clearColorA, t.clearFlag = this._clearFlag, this._clearColorA = -1, this._clearFlag = null)), this._component.node.getWorldMatrix(Ht), t.update(!0), t.worldMatrixToScreen(Ht, Ht, F.canvas.width, F.canvas.height);
              var e = 0,
                  i = 0;

              if (this._fullScreenOnAwake ? (e = N.width, i = N.height) : (e = this._uiTrans.contentSize.width, i = this._uiTrans.contentSize.height), this._forceUpdate || this._m00 !== Ht.m00 || this._m01 !== Ht.m01 || this._m04 !== Ht.m04 || this._m05 !== Ht.m05 || this._m12 !== Ht.m12 || this._m13 !== Ht.m13 || this._w !== e || this._h !== i) {
                this._m00 = Ht.m00, this._m01 = Ht.m01, this._m04 = Ht.m04, this._m05 = Ht.m05, this._m12 = Ht.m12, this._m13 = Ht.m13, this._w = e, this._h = i;
                var n = A.devicePixelRatio,
                    s = 1 / n,
                    o = 1 / n,
                    r = F.container,
                    a = Ht.m00 * s,
                    l = Ht.m01,
                    h = Ht.m04,
                    u = Ht.m05 * o;
                this._video.style.width = this._w + "px", this._video.style.height = this._h + "px", b.browserType !== c.MOBILE_QQ ? this._video.style.objectFit = this._keepAspectRatio ? "none" : "fill" : p("keepAspectRatio is not supported by the qq mobile browser.");

                var _ = this._w * s,
                    y = this._h * o,
                    m = this._uiTrans.anchorPoint,
                    f = m.x,
                    v = m.y,
                    g = _ * Ht.m00 * f,
                    O = y * Ht.m05 * v,
                    w = r && r.style.paddingLeft ? parseInt(r.style.paddingLeft) : 0,
                    P = r && r.style.paddingBottom ? parseInt(r.style.paddingBottom) : 0,
                    T = "matrix(" + a + "," + -l + "," + -h + "," + u + "," + (Ht.m12 * s - g + w) + "," + -(Ht.m13 * o - O + P) + ")";

                this._video.style.transform = T, this._video.style["-webkit-transform"] = T, b.browserType !== c.IE && (this._forceUpdate = !1);
              }
            }
          }
        }, i;
      }(X),
          xt = function () {
        function t() {}

        return t.getImpl = function (t) {
          return new It(t);
        }, t;
      }();

      h.internal.VideoPlayerImplManager = xt;
      var jt = t("VideoPlayer", (Z = y("cc.VideoPlayer"), J = P(), tt = T(), et = k(x), it = g(z), nt = g($), st = L(), ot = L(), rt = g(z), at = L(), lt = L(), ht = R(), ct = L(), pt = R(), ut = L(), _t = L(), dt = L(), yt = L(), mt = L(), ft = L(), vt = g([I]), bt = C(), Et = L(), Z(At = J(At = tt(At = et(At = O((Ft = Vt = function (t) {
        function n() {
          for (var e, i = arguments.length, n = new Array(i), r = 0; r < i; r++) {
            n[r] = arguments[r];
          }

          return e = t.call.apply(t, [this].concat(n)) || this, s(e, "_resourceType", Ot, o(e)), s(e, "_remoteURL", wt, o(e)), s(e, "_clip", Pt, o(e)), s(e, "_playOnAwake", Tt, o(e)), s(e, "_volume", kt, o(e)), s(e, "_mute", Lt, o(e)), s(e, "_playbackRate", Rt, o(e)), s(e, "_loop", St, o(e)), s(e, "_fullScreenOnAwake", Dt, o(e)), s(e, "_stayOnBottom", Ct, o(e)), s(e, "_keepAspectRatio", Ut, o(e)), e._impl = null, e._cachedCurrentTime = 0, s(e, "videoPlayerEvent", Mt, o(e)), e;
        }

        e(n, t);
        var r = n.prototype;
        return r.syncSource = function () {
          this._impl && (this._resourceType === $.REMOTE ? this._impl.syncURL(this._remoteURL) : this._impl.syncClip(this._clip));
        }, r.__preload = function () {
          this._impl = xt.getImpl(this), this.syncSource(), this._impl.syncLoop(this._loop), this._impl.syncVolume(this._volume), this._impl.syncMute(this._mute), this._impl.seekTo(this._cachedCurrentTime), this._impl.syncPlaybackRate(this._playbackRate), this._impl.syncStayOnBottom(this._stayOnBottom), this._impl.syncKeepAspectRatio(this._keepAspectRatio), this._impl.syncFullScreenOnAwake(this._fullScreenOnAwake), this._impl.componentEventList.set(q.META_LOADED, this.onMetaLoaded.bind(this)), this._impl.componentEventList.set(q.READY_TO_PLAY, this.onReadyToPlay.bind(this)), this._impl.componentEventList.set(q.PLAYING, this.onPlaying.bind(this)), this._impl.componentEventList.set(q.PAUSED, this.onPaused.bind(this)), this._impl.componentEventList.set(q.STOPPED, this.onStopped.bind(this)), this._impl.componentEventList.set(q.COMPLETED, this.onCompleted.bind(this)), this._impl.componentEventList.set(q.ERROR, this.onError.bind(this)), this._playOnAwake && this._impl.loaded && this.play();
        }, r.onEnable = function () {
          this._impl && this._impl.enable();
        }, r.onDisable = function () {
          this._impl && this._impl.disable();
        }, r.onDestroy = function () {
          this._impl && (this._impl.destroy(), this._impl = null);
        }, r.update = function () {
          this._impl && this._impl.syncMatrix();
        }, r.onMetaLoaded = function () {
          I.emitEvents(this.videoPlayerEvent, this, q.META_LOADED), this.node.emit("meta-loaded", this);
        }, r.onReadyToPlay = function () {
          this._playOnAwake && !this.isPlaying && this.play(), I.emitEvents(this.videoPlayerEvent, this, q.READY_TO_PLAY), this.node.emit(q.READY_TO_PLAY, this);
        }, r.onPlaying = function () {
          I.emitEvents(this.videoPlayerEvent, this, q.PLAYING), this.node.emit(q.PLAYING, this);
        }, r.onPaused = function () {
          I.emitEvents(this.videoPlayerEvent, this, q.PAUSED), this.node.emit(q.PAUSED, this);
        }, r.onStopped = function () {
          I.emitEvents(this.videoPlayerEvent, this, q.STOPPED), this.node.emit(q.STOPPED, this);
        }, r.onCompleted = function () {
          I.emitEvents(this.videoPlayerEvent, this, q.COMPLETED), this.node.emit(q.COMPLETED, this);
        }, r.onError = function () {
          I.emitEvents(this.videoPlayerEvent, this, q.ERROR), this.node.emit(q.ERROR, this);
        }, r.play = function () {
          this._impl && this._impl.play();
        }, r.resume = function () {
          this._impl && this._impl.resume();
        }, r.pause = function () {
          this._impl && this._impl.pause();
        }, r.stop = function () {
          this._impl && this._impl.stop();
        }, i(n, [{
          key: "resourceType",
          get: function get() {
            return this._resourceType;
          },
          set: function set(t) {
            this._resourceType !== t && (this._resourceType = t, this.syncSource());
          }
        }, {
          key: "remoteURL",
          get: function get() {
            return this._remoteURL;
          },
          set: function set(t) {
            this._remoteURL !== t && (this._remoteURL = t, this.syncSource());
          }
        }, {
          key: "clip",
          get: function get() {
            return this._clip;
          },
          set: function set(t) {
            this._clip !== t && (this._clip = t, this.syncSource());
          }
        }, {
          key: "playOnAwake",
          get: function get() {
            return this._playOnAwake;
          },
          set: function set(t) {
            this._playOnAwake = t;
          }
        }, {
          key: "playbackRate",
          get: function get() {
            return this._playbackRate;
          },
          set: function set(t) {
            this._playbackRate = t, this._impl && this._impl.syncPlaybackRate(t);
          }
        }, {
          key: "volume",
          get: function get() {
            return this._volume;
          },
          set: function set(t) {
            this._volume = t, this._impl && this._impl.syncVolume(t);
          }
        }, {
          key: "mute",
          get: function get() {
            return this._mute;
          },
          set: function set(t) {
            this._mute = t, this._impl && this._impl.syncMute(t);
          }
        }, {
          key: "loop",
          get: function get() {
            return this._loop;
          },
          set: function set(t) {
            this._loop = t, this._impl && this._impl.syncLoop(t);
          }
        }, {
          key: "keepAspectRatio",
          get: function get() {
            return this._keepAspectRatio;
          },
          set: function set(t) {
            this._keepAspectRatio !== t && (this._keepAspectRatio = t, this._impl && this._impl.syncKeepAspectRatio(t));
          }
        }, {
          key: "fullScreenOnAwake",
          get: function get() {
            return this._impl ? (this._fullScreenOnAwake = this._impl.fullScreenOnAwake, this._fullScreenOnAwake) : this._fullScreenOnAwake;
          },
          set: function set(t) {
            this._fullScreenOnAwake !== t && (this._fullScreenOnAwake = t, this._impl && this._impl.syncFullScreenOnAwake(t));
          }
        }, {
          key: "stayOnBottom",
          get: function get() {
            return this._stayOnBottom;
          },
          set: function set(t) {
            this._stayOnBottom !== t && (this._stayOnBottom = t, this._impl && this._impl.syncStayOnBottom(t));
          }
        }, {
          key: "nativeVideo",
          get: function get() {
            return this._impl && this._impl.video || null;
          }
        }, {
          key: "currentTime",
          get: function get() {
            return this._impl ? this._impl.getCurrentTime() : this._cachedCurrentTime;
          },
          set: function set(t) {
            Number.isNaN(t) ? p("illegal video time! value:" + t) : (t = S(t, 0, this.duration), this._cachedCurrentTime = t, this._impl && this._impl.seekTo(t));
          }
        }, {
          key: "duration",
          get: function get() {
            return this._impl ? this._impl.getDuration() : 0;
          }
        }, {
          key: "state",
          get: function get() {
            return this._impl ? this._impl.state : q.NONE;
          }
        }, {
          key: "isPlaying",
          get: function get() {
            return !!this._impl && this._impl.isPlaying;
          }
        }]), n;
      }(D), Vt.EventType = q, Vt.ResourceType = $, Ot = n((gt = Ft).prototype, "_resourceType", [f], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return $.LOCAL;
        }
      }), wt = n(gt.prototype, "_remoteURL", [f], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return "";
        }
      }), Pt = n(gt.prototype, "_clip", [it, f], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return null;
        }
      }), Tt = n(gt.prototype, "_playOnAwake", [f], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !0;
        }
      }), kt = n(gt.prototype, "_volume", [f], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 1;
        }
      }), Lt = n(gt.prototype, "_mute", [f], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !1;
        }
      }), Rt = n(gt.prototype, "_playbackRate", [f], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return 1;
        }
      }), St = n(gt.prototype, "_loop", [f], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !1;
        }
      }), Dt = n(gt.prototype, "_fullScreenOnAwake", [f], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !1;
        }
      }), Ct = n(gt.prototype, "_stayOnBottom", [f], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !1;
        }
      }), Ut = n(gt.prototype, "_keepAspectRatio", [f], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return !0;
        }
      }), n(gt.prototype, "resourceType", [nt, st], Object.getOwnPropertyDescriptor(gt.prototype, "resourceType"), gt.prototype), n(gt.prototype, "remoteURL", [ot], Object.getOwnPropertyDescriptor(gt.prototype, "remoteURL"), gt.prototype), n(gt.prototype, "clip", [rt, at], Object.getOwnPropertyDescriptor(gt.prototype, "clip"), gt.prototype), n(gt.prototype, "playOnAwake", [lt], Object.getOwnPropertyDescriptor(gt.prototype, "playOnAwake"), gt.prototype), n(gt.prototype, "playbackRate", [w, ht, ct], Object.getOwnPropertyDescriptor(gt.prototype, "playbackRate"), gt.prototype), n(gt.prototype, "volume", [w, pt, ut], Object.getOwnPropertyDescriptor(gt.prototype, "volume"), gt.prototype), n(gt.prototype, "mute", [_t], Object.getOwnPropertyDescriptor(gt.prototype, "mute"), gt.prototype), n(gt.prototype, "loop", [dt], Object.getOwnPropertyDescriptor(gt.prototype, "loop"), gt.prototype), n(gt.prototype, "keepAspectRatio", [yt], Object.getOwnPropertyDescriptor(gt.prototype, "keepAspectRatio"), gt.prototype), n(gt.prototype, "fullScreenOnAwake", [mt], Object.getOwnPropertyDescriptor(gt.prototype, "fullScreenOnAwake"), gt.prototype), n(gt.prototype, "stayOnBottom", [ft], Object.getOwnPropertyDescriptor(gt.prototype, "stayOnBottom"), gt.prototype), Mt = n(gt.prototype, "videoPlayerEvent", [f, vt, bt, Et], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return [];
        }
      }), At = gt)) || At) || At) || At) || At) || At));
      h.internal.VideoPlayer = jt, U(jt.prototype, "VideoPlayer.prototype", [{
        name: "onPasued",
        newName: "onPaused"
      }]);
    }
  };
}); 
 			}); 
		define("__plugin__/wx0446ba2621dda60a/webview.js", function(require, module, exports){ 			
"use strict";

System.register(["./texture-barrier-60b5983b.js", "./json-asset-933a1d4c.js", "./index-f2b92470.js", "./renderable-component-7c6600ed.js", "./deprecated-26630860.js", "./deprecated-ef6bb945.js", "./renderable-2d-e2838949.js", "./deprecated-5f7f37d5.js"], function (t) {
  "use strict";

  var e, i, n, s, r, o, h, a, l, c, p, m, u, _, d, f, w, v, b, y, E, g, L, O, D;

  return {
    setters: [function (t) {
      e = t.bU, i = t.l, n = t.bT, s = t.cO, r = t.e, o = t.w, h = t.c0, a = t.c1, l = t.b$;
    }, function (t) {
      c = t.$, p = t.ca, m = t.bW, u = t.bZ, _ = t.cd, d = t.cg, f = t.ch, w = t.dQ, v = t.cc, b = t.bm, y = t.bX, E = t.bY;
    }, function () {}, function () {}, function (t) {
      g = t.g;
    }, function (t) {
      L = t.d, O = t.E;
    }, function (t) {
      D = t.U;
    }, function () {}],
    execute: function execute() {
      var R;
      !function (t) {
        t.NONE = "none", t.LOADING = "loading", t.LOADED = "loaded", t.ERROR = "error";
      }(R || (R = {}));

      var x = function () {
        function t(t) {
          this._componentEventList = new Map(), this._state = R.NONE, this._wrapper = void 0, this._webview = null, this._loaded = !1, this._forceUpdate = !1, this._component = null, this._uiTrans = null, this._node = null, this._w = 0, this._h = 0, this._m00 = 0, this._m01 = 0, this._m04 = 0, this._m05 = 0, this._m12 = 0, this._m13 = 0, this._component = t, this._node = t.node, this._uiTrans = t.node.getComponent(D), this.reset(), this.createWebView();
        }

        var i = t.prototype;
        return i.reset = function () {
          this._wrapper = null, this._webview = null, this._loaded = !1, this._w = 0, this._h = 0, this._m00 = 0, this._m01 = 0, this._m04 = 0, this._m05 = 0, this._m12 = 0, this._m13 = 0, this._state = R.NONE, this._forceUpdate = !1;
        }, i.dispatchEvent = function (t) {
          var e = this._componentEventList.get(t);

          if (e) {
            this._state = t;

            for (var i = arguments.length, n = new Array(i > 1 ? i - 1 : 0), s = 1; s < i; s++) {
              n[s - 1] = arguments[s];
            }

            e.call(this, n);
          }
        }, i.destroy = function () {
          this.removeWebView(), this._wrapper = null, this._webview = null, this._loaded = !1, this._component = null, this._uiTrans = null, this._forceUpdate = !1, this._componentEventList.clear();
        }, e(t, [{
          key: "loaded",
          get: function get() {
            return this._loaded;
          }
        }, {
          key: "componentEventList",
          get: function get() {
            return this._componentEventList;
          }
        }, {
          key: "webview",
          get: function get() {
            return this._webview;
          }
        }, {
          key: "state",
          get: function get() {
            return this._state;
          }
        }, {
          key: "UICamera",
          get: function get() {
            return L.root.batcher2D.getFirstRenderCamera(this._node);
          }
        }]), t;
      }();

      i.internal.WebViewImpl = x;

      var I,
          k,
          T,
          A,
          N,
          U,
          W,
          S,
          j,
          C,
          V,
          J,
          M,
          G,
          z = c(),
          B = function (t) {
        function e(e) {
          return t.call(this, e) || this;
        }

        n(e, t);
        var i = e.prototype;
        return i._bindDomEvent = function () {
          var t = this;
          this.webview && this.webview.addEventListener("load", function (e) {
            t._forceUpdate = !0, t.dispatchEvent(R.LOADED);
            var i = e.target,
                n = i.contentDocument && i.contentDocument.body;
            n && n.innerHTML.includes("404") && t.dispatchEvent(R.ERROR, n.innerHTML);
          });
        }, i.loadURL = function (t) {
          this.webview && (this.webview.src = t, this.dispatchEvent(R.LOADING));
        }, i.createWebView = function () {
          var t = document.createElement("div");
          this._wrapper = t, t.id = "webview-wrapper", t.style["-webkit-overflow"] = "auto", t.style["-webkit-overflow-scrolling"] = "touch", t.style.position = "absolute", t.style.bottom = "0px", t.style.left = "0px", t.style.transformOrigin = "0px 100% 0px", t.style["-webkit-transform-origin"] = "0px 100% 0px", g.container.appendChild(t);
          var e = document.createElement("iframe");
          this._webview = e, e.id = "webview", e.style.border = "none", e.style.width = "100%", e.style.height = "100%", t.appendChild(e), this._bindDomEvent();
        }, i.removeWebView = function () {
          var t = this._wrapper;
          s(g.container, t) && g.container.removeChild(t), this.reset();
        }, i.enable = function () {
          this._wrapper && (this._wrapper.style.visibility = "visible");
        }, i.disable = function () {
          this._wrapper && (this._wrapper.style.visibility = "hidden");
        }, i.evaluateJS = function (t) {
          if (this.webview) {
            var e = this.webview.contentWindow;
            if (e) try {
              e.eval(t);
            } catch (t) {
              this.dispatchEvent(R.ERROR, t), r(t);
            }
          }
        }, i.setOnJSCallback = function () {
          o("The platform does not support");
        }, i.setJavascriptInterfaceScheme = function () {
          o("The platform does not support");
        }, i.syncMatrix = function () {
          if (this._wrapper && this._uiTrans && this._component && "hidden" !== this._wrapper.style.visibility) {
            var t = this.UICamera;

            if (t) {
              this._component.node.getWorldMatrix(z), t.update(!0), t.worldMatrixToScreen(z, z, g.canvas.width, g.canvas.height);
              var e = this._uiTrans.contentSize,
                  i = e.width,
                  n = e.height;

              if (this._forceUpdate || this._m00 !== z.m00 || this._m01 !== z.m01 || this._m04 !== z.m04 || this._m05 !== z.m05 || this._m12 !== z.m12 || this._m13 !== z.m13 || this._w !== i || this._h !== n) {
                this._m00 = z.m00, this._m01 = z.m01, this._m04 = z.m04, this._m05 = z.m05, this._m12 = z.m12, this._m13 = z.m13, this._w = i, this._h = n;
                var s = p.devicePixelRatio,
                    r = 1 / s,
                    o = 1 / s,
                    h = g.container,
                    a = z.m00 * r,
                    l = z.m01,
                    c = z.m04,
                    m = z.m05 * o;
                this._wrapper.style.width = i + "px", this._wrapper.style.height = n + "px";

                var u = this._w * r,
                    _ = this._h * o,
                    d = u * z.m00 * this._uiTrans.anchorX,
                    f = _ * z.m05 * this._uiTrans.anchorY,
                    w = h && h.style.paddingLeft ? parseInt(h.style.paddingLeft) : 0,
                    v = h && h.style.paddingBottom ? parseInt(h.style.paddingBottom) : 0,
                    b = "matrix(" + a + "," + -l + "," + -c + "," + m + "," + (z.m12 * r - d + w) + "," + -(z.m13 * o - f + v) + ")";

                this._wrapper.style.transform = b, this._wrapper.style["-webkit-transform"] = b, this._forceUpdate = !1;
              }
            }
          }
        }, e;
      }(x),
          H = function () {
        function t() {}

        return t.getImpl = function (t) {
          return new B(t);
        }, t;
      }();

      i.internal.WebViewImplManager = H;
      var P = t("WebView", (I = m("cc.WebView"), k = d(), T = f(), A = w(D), N = v(), U = u([O]), W = E(), S = v(), I(j = k(j = T(j = A(j = _((G = M = function (t) {
        function i() {
          for (var e, i = arguments.length, n = new Array(i), s = 0; s < i; s++) {
            n[s] = arguments[s];
          }

          return e = t.call.apply(t, [this].concat(n)) || this, a(e, "_url", V, l(e)), e._impl = null, a(e, "webviewEvents", J, l(e)), e;
        }

        n(i, t);
        var s = i.prototype;
        return s.setJavascriptInterfaceScheme = function (t) {
          this._impl && this._impl.setJavascriptInterfaceScheme(t);
        }, s.setOnJSCallback = function (t) {
          this._impl && this._impl.setOnJSCallback(t);
        }, s.evaluateJS = function (t) {
          this._impl && this._impl.evaluateJS(t);
        }, s.__preload = function () {
          this._impl = H.getImpl(this), this._impl.componentEventList.set(R.LOADING, this.onLoading.bind(this)), this._impl.componentEventList.set(R.LOADED, this.onLoaded.bind(this)), this._impl.componentEventList.set(R.ERROR, this.onError.bind(this)), this._impl.loadURL(this._url);
        }, s.onLoading = function () {
          O.emitEvents(this.webviewEvents, this, R.LOADING), this.node.emit(R.LOADING, this);
        }, s.onLoaded = function () {
          O.emitEvents(this.webviewEvents, this, R.LOADED), this.node.emit(R.LOADED, this);
        }, s.onError = function () {
          for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++) {
            e[i] = arguments[i];
          }

          O.emitEvents(this.webviewEvents, this, R.ERROR, e), this.node.emit(R.ERROR, this, e);
        }, s.onEnable = function () {
          this._impl && this._impl.enable();
        }, s.onDisable = function () {
          this._impl && this._impl.disable();
        }, s.onDestroy = function () {
          this._impl && (this._impl.destroy(), this._impl = null);
        }, s.update = function () {
          this._impl && this._impl.syncMatrix();
        }, e(i, [{
          key: "url",
          get: function get() {
            return this._url;
          },
          set: function set(t) {
            this._url = t, this._impl && this._impl.loadURL(t);
          }
        }, {
          key: "nativeWebView",
          get: function get() {
            return this._impl && this._impl.webview || null;
          }
        }, {
          key: "state",
          get: function get() {
            return this._impl ? this._impl.state : R.NONE;
          }
        }]), i;
      }(b), M.EventType = R, V = h((C = G).prototype, "_url", [y], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return "https://cocos.com";
        }
      }), h(C.prototype, "url", [N], Object.getOwnPropertyDescriptor(C.prototype, "url"), C.prototype), J = h(C.prototype, "webviewEvents", [y, U, W, S], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
          return [];
        }
      }), j = C)) || j) || j) || j) || j) || j));
      i.internal.WebView = P;
    }
  };
}); 
 			}); 
	