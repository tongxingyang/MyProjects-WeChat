var t = require("../../@babel/runtime/helpers/interopRequireDefault"), e = t(require("../../@babel/runtime/helpers/assertThisInitialized")), i = t(require("../../@babel/runtime/helpers/get")), a = t(require("../../@babel/runtime/helpers/possibleConstructorReturn")), r = t(require("../../@babel/runtime/helpers/getPrototypeOf")), s = t(require("../../@babel/runtime/helpers/inherits")), n = t(require("../../@babel/runtime/helpers/createClass")), h = t(require("../../@babel/runtime/helpers/classCallCheck"));

function l(t) {
    return function() {
        var e, i = (0, r.default)(t);
        if (o()) {
            var s = (0, r.default)(this).constructor;
            e = Reflect.construct(i, arguments, s);
        } else e = i.apply(this, arguments);
        return (0, a.default)(this, e);
    };
}

function o() {
    if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
    if (Reflect.construct.sham) return !1;
    if ("function" == typeof Proxy) return !0;
    try {
        return Date.prototype.toString.call(Reflect.construct(Date, [], function() {})), 
        !0;
    } catch (t) {
        t = VM2_INTERNAL_STATE_DO_NOT_USE_OR_PROGRAM_WILL_FAIL.handleException(t);
        return !1;
    }
}

!function(t, a) {
    var o = function t() {
        (0, h.default)(this, t);
    };
    o.Skeleton = null, o.AnimationTemplet = null, o.Templet = null;
    var u = function t() {
        (0, h.default)(this, t);
    }, c = function t() {
        (0, h.default)(this, t);
    }, d = function t() {
        (0, h.default)(this, t);
    }, _ = function() {
        function t() {
            (0, h.default)(this, t);
        }
        return (0, n.default)(t, null, [ {
            key: "parse",
            value: function(t, e) {
                var i, r, s, n, h, l, _, p = e.__getBuffer(), f = e.readUTFString();
                t._aniClassName = f;
                var y, m = e.readUTFString().split("\n"), g = e.getUint8(), v = e.getUint32(), x = e.getUint32();
                v > 0 && (y = p.slice(v, x));
                var M = new a.Byte(y);
                for (x > 0 && (t._publicExtData = p.slice(x, p.byteLength)), t._useParent = !!e.getUint8(), 
                t._anis.length = g, i = 0; i < g; i++) {
                    var D = t._anis[i] = new u();
                    D.nodes = [];
                    var k = D.name = m[e.getUint16()];
                    t._aniMap[k] = i, D.bone3DMap = {}, D.playTime = e.getFloat32();
                    var I = D.nodes.length = e.getUint8();
                    for (D.totalKeyframeDatasLength = 0, r = 0; r < I; r++) {
                        var A = D.nodes[r] = new c();
                        A.childs = [];
                        var T = e.getInt16();
                        T >= 0 && (A.name = m[T], D.bone3DMap[A.name] = r), A.keyFrame = [], A.parentIndex = e.getInt16(), 
                        -1 == A.parentIndex ? A.parent = null : A.parent = D.nodes[A.parentIndex], A.lerpType = e.getUint8();
                        var S = e.getUint32();
                        M.pos = S;
                        var b = A.keyframeWidth = M.getUint16();
                        if (D.totalKeyframeDatasLength += b, 0 === A.lerpType || 1 === A.lerpType) for (A.interpolationMethod = [], 
                        A.interpolationMethod.length = b, s = 0; s < b; s++) A.interpolationMethod[s] = o.AnimationTemplet.interpolation[M.getUint8()];
                        null != A.parent && A.parent.childs.push(A);
                        var C = e.getUint16();
                        C > 0 && (A.extenData = p.slice(e.pos, e.pos + C), e.pos += C);
                        var F = e.getUint16();
                        A.keyFrame.length = F;
                        var w, P = 0;
                        for (s = 0, n = F; s < n; s++) {
                            if ((w = A.keyFrame[s] = new d()).duration = e.getFloat32(), w.startTime = P, 2 === A.lerpType) {
                                w.interpolationData = [];
                                var L, U = e.getUint8();
                                switch (L = e.getFloat32()) {
                                  case 254:
                                    for (w.interpolationData.length = b, _ = 0; _ < b; _++) w.interpolationData[_] = 0;
                                    break;

                                  case 255:
                                    for (w.interpolationData.length = b, _ = 0; _ < b; _++) w.interpolationData[_] = 5;
                                    break;

                                  default:
                                    for (w.interpolationData.push(L), l = 1; l < U; l++) w.interpolationData.push(e.getFloat32());
                                }
                            }
                            for (w.data = new Float32Array(b), w.dData = new Float32Array(b), w.nextData = new Float32Array(b), 
                            h = 0; h < b; h++) w.data[h] = e.getFloat32(), w.data[h] > -1e-8 && w.data[h] < 1e-8 && (w.data[h] = 0);
                            P += w.duration;
                        }
                        w.startTime = D.playTime, A.playTime = D.playTime, t._calculateKeyFrame(A, F, b);
                    }
                }
            }
        } ]), t;
    }(), p = function() {
        function t() {
            (0, h.default)(this, t);
        }
        return (0, n.default)(t, null, [ {
            key: "READ_DATA",
            value: function() {
                t._DATA.offset = t._reader.getUint32(), t._DATA.size = t._reader.getUint32();
            }
        }, {
            key: "READ_BLOCK",
            value: function() {
                for (var e = t._BLOCK.count = t._reader.getUint16(), i = t._BLOCK.blockStarts = [], a = t._BLOCK.blockLengths = [], r = 0; r < e; r++) i.push(t._reader.getUint32()), 
                a.push(t._reader.getUint32());
            }
        }, {
            key: "READ_STRINGS",
            value: function() {
                var e = t._reader.getUint32(), i = t._reader.getUint16(), a = t._reader.pos;
                t._reader.pos = e + t._DATA.offset;
                for (var r = 0; r < i; r++) t._strings[r] = t._reader.readUTFString();
                t._reader.pos = a;
            }
        }, {
            key: "parse",
            value: function(e, i) {
                t._templet = e, t._reader = i, i.__getBuffer(), t.READ_DATA(), t.READ_BLOCK(), t.READ_STRINGS();
                for (var a = 0, r = t._BLOCK.count; a < r; a++) {
                    var s = i.getUint16(), n = t._strings[s], h = t["READ_" + n];
                    if (null == h) throw new Error("model file err,no this function:" + s + " " + n);
                    h.call(null);
                }
            }
        }, {
            key: "READ_ANIMATIONS",
            value: function() {
                var e, i, a, r, s = t._reader, n = s.__getBuffer(), h = s.getUint16(), l = [];
                for (l.length = h, e = 0; e < h; e++) l[e] = o.AnimationTemplet.interpolation[s.getByte()];
                var _ = s.getUint8();
                for (t._templet._anis.length = _, e = 0; e < _; e++) {
                    var p = t._templet._anis[e] = new u();
                    p.nodes = [];
                    var f = p.name = t._strings[s.getUint16()];
                    t._templet._aniMap[f] = e, p.bone3DMap = {}, p.playTime = s.getFloat32();
                    var y = p.nodes.length = s.getInt16();
                    for (p.totalKeyframeDatasLength = 0, i = 0; i < y; i++) {
                        var m = p.nodes[i] = new c();
                        m.keyframeWidth = h, m.childs = [];
                        var g = s.getUint16();
                        g >= 0 && (m.name = t._strings[g], p.bone3DMap[m.name] = i), m.keyFrame = [], m.parentIndex = s.getInt16(), 
                        -1 == m.parentIndex ? m.parent = null : m.parent = p.nodes[m.parentIndex], p.totalKeyframeDatasLength += h, 
                        m.interpolationMethod = l, null != m.parent && m.parent.childs.push(m);
                        var v = s.getUint16();
                        m.keyFrame.length = v;
                        var x = null, M = null;
                        for (a = 0, r = v; a < r; a++) {
                            (x = m.keyFrame[a] = new d()).startTime = s.getFloat32(), M && (M.duration = x.startTime - M.startTime), 
                            x.dData = new Float32Array(h), x.nextData = new Float32Array(h);
                            var D = t._DATA.offset, k = s.getUint32(), I = 4 * h, A = n.slice(D + k, D + k + I);
                            x.data = new Float32Array(A), M = x;
                        }
                        x.duration = 0, m.playTime = p.playTime, t._templet._calculateKeyFrame(m, v, h);
                    }
                }
            }
        } ]), t;
    }();
    p._strings = [], p._BLOCK = {
        count: 0
    }, p._DATA = {
        offset: 0,
        size: 0
    };
    var f = function t() {
        (0, h.default)(this, t);
    };
    f.stopped = 0, f.paused = 1, f.playing = 2;
    var y = function(t) {
        (0, s.default)(i, t);
        var e = l(i);
        function i() {
            var t;
            return (0, h.default)(this, i), (t = e.call(this)).isCache = !0, t.playbackRate = 1, 
            t._destroyed = !1, t._currentAnimationClipIndex = -1, t._currentKeyframeIndex = -1, 
            t._currentTime = 0, t._overallDuration = Number.MAX_VALUE, t._stopWhenCircleFinish = !1, 
            t._elapsedPlaybackTime = 0, t._startUpdateLoopCount = -1, t._cachePlayRate = 1, 
            t.cacheFrameRate = 60, t.returnToZeroStopped = !1, t;
        }
        return (0, n.default)(i, [ {
            key: "_onTempletLoadedComputeFullKeyframeIndices",
            value: function(t, e, i) {
                this._templet === i && this._cachePlayRate === t && this._cacheFrameRate === e && this._computeFullKeyframeIndices();
            }
        }, {
            key: "_computeFullKeyframeIndices",
            value: function() {}
        }, {
            key: "_onAnimationTempletLoaded",
            value: function() {
                this.destroyed || this._calculatePlayDuration();
            }
        }, {
            key: "_calculatePlayDuration",
            value: function() {
                if (this.state !== f.stopped) {
                    var t = this._templet.getAniDuration(this._currentAnimationClipIndex);
                    0 === this._playEnd && (this._playEnd = t), this._playEnd > t && (this._playEnd = t), 
                    this._playDuration = this._playEnd - this._playStart;
                }
            }
        }, {
            key: "_setPlayParams",
            value: function(t, e) {
                this._currentTime = t, this._currentKeyframeIndex = Math.floor(this.currentPlayTime / e + .01), 
                this._currentFrameTime = this._currentKeyframeIndex * e;
            }
        }, {
            key: "_setPlayParamsWhenStop",
            value: function(t, e) {
                var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : -1;
                this._currentTime = t;
                var a = i > 0 ? i : t;
                this._currentKeyframeIndex = Math.floor(a / e + .01), this._currentKeyframeIndex = Math.floor(t / e + .01), 
                this._currentFrameTime = this._currentKeyframeIndex * e, this._currentAnimationClipIndex = -1;
            }
        }, {
            key: "_update",
            value: function(t) {
                if (-1 !== this._currentAnimationClipIndex && !this._paused && this._templet) {
                    var e = this._cacheFrameRateInterval * this._cachePlayRate, i = 0;
                    this._startUpdateLoopCount !== a.Stat.loopCount && (i = t * this.playbackRate, this._elapsedPlaybackTime += i);
                    var r = this.playDuration;
                    if (i += this._currentTime, 0 !== this._overallDuration && this._elapsedPlaybackTime >= this._overallDuration || 0 === this._overallDuration && this._elapsedPlaybackTime >= r || 0 === this._overallDuration && i >= this.playEnd) return this._setPlayParamsWhenStop(r, e, this.playEnd), 
                    void this.event(a.Event.STOPPED);
                    if (r > 0) {
                        if (i >= r) return this._stopWhenCircleFinish ? (this._setPlayParamsWhenStop(r, e), 
                        this._stopWhenCircleFinish = !1, void this.event(a.Event.STOPPED)) : (i %= r, this._setPlayParams(i, e), 
                        void this.event(a.Event.COMPLETE));
                        this._setPlayParams(i, e);
                    } else {
                        if (this._stopWhenCircleFinish) return this._setPlayParamsWhenStop(r, e), this._stopWhenCircleFinish = !1, 
                        void this.event(a.Event.STOPPED);
                        this._currentTime = this._currentFrameTime = this._currentKeyframeIndex = 0, this.event(a.Event.COMPLETE);
                    }
                }
            }
        }, {
            key: "_destroy",
            value: function() {
                this.offAll(), this._templet = null, this._destroyed = !0;
            }
        }, {
            key: "play",
            value: function() {
                var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1, i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 2147483647, r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0, s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0;
                if (!this._templet) throw new Error("AnimationPlayer:templet must not be null,maybe you need to set url.");
                if (i < 0 || r < 0 || s < 0) throw new Error("AnimationPlayer:overallDuration,playStart and playEnd must large than zero.");
                if (0 !== s && r > s) throw new Error("AnimationPlayer:start must less than end.");
                this._currentTime = 0, this._currentFrameTime = 0, this._elapsedPlaybackTime = 0, 
                this.playbackRate = e, this._overallDuration = i, this._playStart = r, this._playEnd = s, 
                this._paused = !1, this._currentAnimationClipIndex = t, this._currentKeyframeIndex = 0, 
                this._startUpdateLoopCount = a.Stat.loopCount, this.event(a.Event.PLAYED), this._calculatePlayDuration(), 
                this._update(0);
            }
        }, {
            key: "playByFrame",
            value: function() {
                var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1, i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 2147483647, a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0, r = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0, s = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 30, n = 1e3 / s;
                this.play(t, e, i, a * n, r * n);
            }
        }, {
            key: "stop",
            value: function() {
                var t = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
                t ? (this._currentTime = this._currentFrameTime = this._currentKeyframeIndex = 0, 
                this._currentAnimationClipIndex = -1, this.event(a.Event.STOPPED)) : this._stopWhenCircleFinish = !0;
            }
        }, {
            key: "destroy",
            value: function() {}
        }, {
            key: "templet",
            get: function() {
                return this._templet;
            },
            set: function(t) {
                this.state !== f.stopped && this.stop(!0), this._templet !== t && (this._templet = t, 
                this._computeFullKeyframeIndices());
            }
        }, {
            key: "playStart",
            get: function() {
                return this._playStart;
            }
        }, {
            key: "playEnd",
            get: function() {
                return this._playEnd;
            }
        }, {
            key: "playDuration",
            get: function() {
                return this._playDuration;
            }
        }, {
            key: "overallDuration",
            get: function() {
                return this._overallDuration;
            }
        }, {
            key: "currentAnimationClipIndex",
            get: function() {
                return this._currentAnimationClipIndex;
            }
        }, {
            key: "currentKeyframeIndex",
            get: function() {
                return this._currentKeyframeIndex;
            }
        }, {
            key: "currentPlayTime",
            get: function() {
                return this._currentTime + this._playStart;
            }
        }, {
            key: "currentFrameTime",
            get: function() {
                return this._currentFrameTime;
            }
        }, {
            key: "cachePlayRate",
            get: function() {
                return this._cachePlayRate;
            },
            set: function(t) {
                this._cachePlayRate !== t && (this._cachePlayRate = t, this._templet && this._computeFullKeyframeIndices());
            }
        }, {
            key: "cacheFrameRate",
            get: function() {
                return this._cacheFrameRate;
            },
            set: function(t) {
                this._cacheFrameRate !== t && (this._cacheFrameRate = t, this._cacheFrameRateInterval = 1e3 / this._cacheFrameRate, 
                this._templet && this._computeFullKeyframeIndices());
            }
        }, {
            key: "currentTime",
            set: function(t) {
                if (-1 !== this._currentAnimationClipIndex && this._templet) {
                    if (t < this._playStart || t > this._playEnd) throw new Error("AnimationPlayer:value must large than playStartTime,small than playEndTime.");
                    this._startUpdateLoopCount = a.Stat.loopCount;
                    var e = this._cacheFrameRateInterval * this._cachePlayRate;
                    this._currentTime = t, this._currentKeyframeIndex = Math.floor(this.currentPlayTime / e), 
                    this._currentFrameTime = this._currentKeyframeIndex * e;
                }
            }
        }, {
            key: "paused",
            get: function() {
                return this._paused;
            },
            set: function(t) {
                this._paused = t, t && this.event(a.Event.PAUSED);
            }
        }, {
            key: "cacheFrameRateInterval",
            get: function() {
                return this._cacheFrameRateInterval;
            }
        }, {
            key: "state",
            get: function() {
                return -1 === this._currentAnimationClipIndex ? f.stopped : this._paused ? f.paused : f.playing;
            }
        }, {
            key: "destroyed",
            get: function() {
                return this._destroyed;
            }
        } ]), i;
    }(a.EventDispatcher), m = function() {
        function t() {
            (0, h.default)(this, t);
        }
        return (0, n.default)(t, null, [ {
            key: "getBezierRate",
            value: function(e, i, a, r, s) {
                var n = t._getBezierParamKey(i, a, r, s), h = 100 * n + e;
                if (t._bezierResultCache[h]) return t._bezierResultCache[h];
                var l, o, u = t._getBezierPoints(i, a, r, s, n);
                for (o = u.length, l = 0; l < o; l += 2) if (e <= u[l]) return t._bezierResultCache[h] = u[l + 1], 
                u[l + 1];
                return t._bezierResultCache[h] = 1, 1;
            }
        }, {
            key: "_getBezierParamKey",
            value: function(t, e, i, a) {
                return 100 * (100 * (100 * (100 * t + e) + i) + a);
            }
        }, {
            key: "_getBezierPoints",
            value: function(e, i, r, s, n) {
                return t._bezierPointsCache[n] ? t._bezierPointsCache[n] : (h = [ 0, 0, e, i, r, s, 1, 1 ], 
                l = new a.Bezier().getBezierPoints(h, 100, 3), t._bezierPointsCache[n] = l, l);
                var h, l;
            }
        } ]), t;
    }();
    m._bezierResultCache = {}, m._bezierPointsCache = {};
    var g = function(t) {
        (0, s.default)(i, t);
        var e = l(i);
        function i() {
            var t;
            return (0, h.default)(this, i), (t = e.call(this))._anis = [], t._aniMap = {}, t.unfixedLastAniIndex = -1, 
            t._fullFrames = null, t._boneCurKeyFrm = [], t;
        }
        return (0, n.default)(i, [ {
            key: "parse",
            value: function(t) {
                var e = new a.Byte(t);
                this._aniVersion = e.readUTFString(), _.parse(this, e);
            }
        }, {
            key: "_calculateKeyFrame",
            value: function(t, e, i) {
                var a = t.keyFrame;
                a[e] = a[0];
                for (var r = 0; r < e; r++) for (var s = a[r], n = 0; n < i; n++) s.dData[n] = 0 === s.duration ? 0 : (a[r + 1].data[n] - s.data[n]) / s.duration, 
                s.nextData[n] = a[r + 1].data[n];
                a.length--;
            }
        }, {
            key: "_onAsynLoaded",
            value: function(t) {
                var e = new a.Byte(t);
                switch (this._aniVersion = e.readUTFString(), this._aniVersion) {
                  case "LAYAANIMATION:02":
                    p.parse(this, e);
                    break;

                  default:
                    _.parse(this, e);
                }
            }
        }, {
            key: "getAnimationCount",
            value: function() {
                return this._anis.length;
            }
        }, {
            key: "getAnimation",
            value: function(t) {
                return this._anis[t];
            }
        }, {
            key: "getAniDuration",
            value: function(t) {
                return this._anis[t].playTime;
            }
        }, {
            key: "getNodes",
            value: function(t) {
                return this._anis[t].nodes;
            }
        }, {
            key: "getNodeIndexWithName",
            value: function(t, e) {
                return this._anis[t].bone3DMap[e];
            }
        }, {
            key: "getNodeCount",
            value: function(t) {
                return this._anis[t].nodes.length;
            }
        }, {
            key: "getTotalkeyframesLength",
            value: function(t) {
                return this._anis[t].totalKeyframeDatasLength;
            }
        }, {
            key: "getPublicExtData",
            value: function() {
                return this._publicExtData;
            }
        }, {
            key: "getAnimationDataWithCache",
            value: function(t, e, i, a) {
                var r = e[i];
                if (r) {
                    var s = r[t];
                    return s ? s[a] : null;
                }
                return null;
            }
        }, {
            key: "setAnimationDataWithCache",
            value: function(t, e, i, a, r) {
                var s = e[i] || (e[i] = {});
                (s[t] || (s[t] = []))[a] = r;
            }
        }, {
            key: "getNodeKeyFrame",
            value: function(t, e, i) {
                var a = this._boneCurKeyFrm[e], r = t.length;
                (null == a || a >= r) && (a = this._boneCurKeyFrm[e] = 0);
                var s = t[a], n = i - s.startTime;
                if (0 == n || n > 0 && s.duration > n) return a;
                var h = 0;
                if (n > 0) {
                    for (i += .01, h = a + 1; h < r; h++) if ((s = t[h]).startTime <= i && s.startTime + s.duration > i) return this._boneCurKeyFrm[e] = h, 
                    h;
                    return r - 1;
                }
                for (h = 0; h < a; h++) if ((s = t[h]).startTime <= i && s.startTime + s.duration > i) return this._boneCurKeyFrm[e] = h, 
                h;
                return a;
            }
        }, {
            key: "getOriginalData",
            value: function(t, e, a, r, s) {
                var n = this._anis[t].nodes, h = this._boneCurKeyFrm;
                h.length < n.length && (h.length = n.length);
                for (var l = 0, o = 0, u = n.length, c = 0; o < u; o++) {
                    var d, _ = n[o], p = _.keyFrame;
                    d = p[this.getNodeKeyFrame(p, o, s)], _.dataOffset = c;
                    var f = s - d.startTime, y = _.lerpType;
                    if (y) switch (y) {
                      case 0:
                      case 1:
                        for (l = 0; l < _.keyframeWidth; ) l += _.interpolationMethod[l](_, l, e, c + l, d.data, f, d.dData, d.duration, d.nextData);
                        break;

                      case 2:
                        var m = d.interpolationData, g = m.length, v = 0;
                        for (l = 0; l < g; ) {
                            var x = m[l];
                            switch (x) {
                              case 6:
                              case 7:
                                l += i.interpolation[x](_, v, e, c + v, d.data, f, d.dData, d.duration, d.nextData, m, l + 1);
                                break;

                              default:
                                l += i.interpolation[x](_, v, e, c + v, d.data, f, d.dData, d.duration, d.nextData);
                            }
                            v++;
                        }
                    } else for (l = 0; l < _.keyframeWidth; ) l += _.interpolationMethod[l](_, l, e, c + l, d.data, f, d.dData, d.duration, d.nextData);
                    c += _.keyframeWidth;
                }
            }
        }, {
            key: "getNodesCurrentFrameIndex",
            value: function(t, e) {
                var i = this._anis[t].nodes;
                t !== this.unfixedLastAniIndex && (this.unfixedCurrentFrameIndexes = new Uint32Array(i.length), 
                this.unfixedCurrentTimes = new Float32Array(i.length), this.unfixedLastAniIndex = t);
                for (var a = 0, r = i.length; a < r; a++) {
                    var s = i[a];
                    for (e < this.unfixedCurrentTimes[a] && (this.unfixedCurrentFrameIndexes[a] = 0), 
                    this.unfixedCurrentTimes[a] = e; this.unfixedCurrentFrameIndexes[a] < s.keyFrame.length && !(s.keyFrame[this.unfixedCurrentFrameIndexes[a]].startTime > this.unfixedCurrentTimes[a]); ) this.unfixedCurrentFrameIndexes[a]++;
                    this.unfixedCurrentFrameIndexes[a]--;
                }
                return this.unfixedCurrentFrameIndexes;
            }
        }, {
            key: "getOriginalDataUnfixedRate",
            value: function(t, e, a) {
                var r = this._anis[t].nodes;
                t !== this.unfixedLastAniIndex && (this.unfixedCurrentFrameIndexes = new Uint32Array(r.length), 
                this.unfixedCurrentTimes = new Float32Array(r.length), this.unfixedKeyframes = [], 
                this.unfixedLastAniIndex = t);
                for (var s = 0, n = 0, h = r.length, l = 0; n < h; n++) {
                    var o = r[n];
                    for (a < this.unfixedCurrentTimes[n] && (this.unfixedCurrentFrameIndexes[n] = 0), 
                    this.unfixedCurrentTimes[n] = a; this.unfixedCurrentFrameIndexes[n] < o.keyFrame.length && !(o.keyFrame[this.unfixedCurrentFrameIndexes[n]].startTime > this.unfixedCurrentTimes[n]); ) this.unfixedKeyframes[n] = o.keyFrame[this.unfixedCurrentFrameIndexes[n]], 
                    this.unfixedCurrentFrameIndexes[n]++;
                    var u = this.unfixedKeyframes[n];
                    o.dataOffset = l;
                    var c = a - u.startTime;
                    if (o.lerpType) switch (o.lerpType) {
                      case 0:
                      case 1:
                        for (s = 0; s < o.keyframeWidth; ) s += o.interpolationMethod[s](o, s, e, l + s, u.data, c, u.dData, u.duration, u.nextData);
                        break;

                      case 2:
                        var d = u.interpolationData, _ = d.length, p = 0;
                        for (s = 0; s < _; ) {
                            var f = d[s];
                            switch (f) {
                              case 6:
                              case 7:
                                s += i.interpolation[f](o, p, e, l + p, u.data, c, u.dData, u.duration, u.nextData, d, s + 1);
                                break;

                              default:
                                s += i.interpolation[f](o, p, e, l + p, u.data, c, u.dData, u.duration, u.nextData);
                            }
                            p++;
                        }
                    } else for (s = 0; s < o.keyframeWidth; ) s += o.interpolationMethod[s](o, s, e, l + s, u.data, c, u.dData, u.duration, u.nextData);
                    l += o.keyframeWidth;
                }
            }
        } ], [ {
            key: "_LinearInterpolation_0",
            value: function(t, e, i, a, r, s, n, h, l) {
                return i[a] = r[e] + s * n[e], 1;
            }
        }, {
            key: "_QuaternionInterpolation_1",
            value: function(t, e, i, r, s, n, h, l, o) {
                var u = 0 === l ? 0 : n / l;
                return a.MathUtil.slerpQuaternionArray(s, e, o, e, u, i, r), 4;
            }
        }, {
            key: "_AngleInterpolation_2",
            value: function(t, e, i, a, r, s, n, h, l) {
                return 0;
            }
        }, {
            key: "_RadiansInterpolation_3",
            value: function(t, e, i, a, r, s, n, h, l) {
                return 0;
            }
        }, {
            key: "_Matrix4x4Interpolation_4",
            value: function(t, e, i, a, r, s, n, h, l) {
                for (var o = 0; o < 16; o++, e++) i[a + o] = r[e] + s * n[e];
                return 16;
            }
        }, {
            key: "_NoInterpolation_5",
            value: function(t, e, i, a, r, s, n, h, l) {
                return i[a] = r[e], 1;
            }
        }, {
            key: "_BezierInterpolation_6",
            value: function(t, e, i, a, r, s, n, h, l) {
                var o = arguments.length > 9 && void 0 !== arguments[9] ? arguments[9] : null, u = arguments.length > 10 && void 0 !== arguments[10] ? arguments[10] : 0;
                return i[a] = r[e] + (l[e] - r[e]) * m.getBezierRate(s / h, o[u], o[u + 1], o[u + 2], o[u + 3]), 
                5;
            }
        }, {
            key: "_BezierInterpolation_7",
            value: function(t, e, i, a, r, s, n, h, l) {
                var o = arguments.length > 9 && void 0 !== arguments[9] ? arguments[9] : null, u = arguments.length > 10 && void 0 !== arguments[10] ? arguments[10] : 0;
                return i[a] = o[u + 4] + o[u + 5] * m.getBezierRate((.001 * s + o[u + 6]) / o[u + 7], o[u], o[u + 1], o[u + 2], o[u + 3]), 
                9;
            }
        } ]), i;
    }(a.Resource);
    g.interpolation = [ g._LinearInterpolation_0, g._QuaternionInterpolation_1, g._AngleInterpolation_2, g._RadiansInterpolation_3, g._Matrix4x4Interpolation_4, g._NoInterpolation_5, g._BezierInterpolation_6, g._BezierInterpolation_7 ], 
    o.AnimationTemplet = g;
    var v = function(t) {
        (0, s.default)(i, t);
        var e = l(i);
        function i() {
            return (0, h.default)(this, i), e.apply(this, arguments);
        }
        return (0, n.default)(i, [ {
            key: "drawSkin",
            value: function(t, e) {
                this.drawTriangles(t.texture, 0, 0, t.vertices, t.uvs, t.indexes, t.transform || a.Matrix.EMPTY, e);
            }
        } ], [ {
            key: "create",
            value: function() {
                return i._caches.pop() || new i();
            }
        }, {
            key: "recycle",
            value: function(t) {
                t.clear(), i._caches.push(t);
            }
        } ]), i;
    }(a.Graphics);
    v._caches = [];
    var x = function() {
        function t() {
            (0, h.default)(this, t), this.skX = 0, this.skY = 0, this.scX = 1, this.scY = 1, 
            this.x = 0, this.y = 0, this.skewX = 0, this.skewY = 0;
        }
        return (0, n.default)(t, [ {
            key: "initData",
            value: function(t) {
                null != t.x && (this.x = t.x), null != t.y && (this.y = t.y), null != t.skX && (this.skX = t.skX), 
                null != t.skY && (this.skY = t.skY), null != t.scX && (this.scX = t.scX), null != t.scY && (this.scY = t.scY);
            }
        }, {
            key: "getMatrix",
            value: function() {
                var t;
                return (t = this.mMatrix ? this.mMatrix : this.mMatrix = new a.Matrix()).identity(), 
                t.scale(this.scX, this.scY), (this.skewX || this.skewY) && this.skew(t, this.skewX * Math.PI / 180, this.skewY * Math.PI / 180), 
                t.rotate(this.skX * Math.PI / 180), t.translate(this.x, this.y), t;
            }
        }, {
            key: "skew",
            value: function(t, e, i) {
                var a = Math.sin(i), r = Math.cos(i), s = Math.sin(e), n = Math.cos(e);
                return t.setTo(t.a * n - t.b * a, t.a * s + t.b * r, t.c * n - t.d * a, t.c * s + t.d * r, t.tx * n - t.ty * a, t.tx * s + t.ty * r), 
                t;
            }
        } ]), t;
    }(), M = function() {
        function t() {
            (0, h.default)(this, t), this.length = 10, this.resultTransform = new x(), this.resultMatrix = new a.Matrix(), 
            this.inheritScale = !0, this.inheritRotation = !0, this.d = -1, this._children = [];
        }
        return (0, n.default)(t, [ {
            key: "setTempMatrix",
            value: function(t) {
                this._tempMatrix = t;
                var e, i = 0;
                for (i = 0, e = this._children.length; i < e; i++) this._children[i].setTempMatrix(this._tempMatrix);
            }
        }, {
            key: "update",
            value: function() {
                var t, e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
                if (this.rotation = this.transform.skX, e) t = this.resultTransform.getMatrix(), 
                a.Matrix.mul(t, e, this.resultMatrix), this.resultRotation = this.rotation; else if (this.resultRotation = this.rotation + this.parentBone.resultRotation, 
                this.parentBone) if (this.inheritRotation && this.inheritScale) t = this.resultTransform.getMatrix(), 
                a.Matrix.mul(t, this.parentBone.resultMatrix, this.resultMatrix); else {
                    var i, r, s, n = this.parentBone, h = this.parentBone.resultMatrix;
                    t = this.resultTransform.getMatrix();
                    var l = h.a * t.tx + h.c * t.ty + h.tx, o = h.b * t.tx + h.d * t.ty + h.ty, u = new a.Matrix();
                    this.inheritRotation ? (i = Math.atan2(n.resultMatrix.b, n.resultMatrix.a), r = Math.cos(i), 
                    s = Math.sin(i), u.setTo(r, s, -s, r, 0, 0), a.Matrix.mul(this._tempMatrix, u, a.Matrix.TEMP), 
                    a.Matrix.TEMP.copyTo(u), t = this.resultTransform.getMatrix(), a.Matrix.mul(t, u, this.resultMatrix), 
                    this.resultTransform.scX * this.resultTransform.scY < 0 && this.resultMatrix.rotate(.5 * Math.PI), 
                    this.resultMatrix.tx = l, this.resultMatrix.ty = o) : (this.inheritScale, t = this.resultTransform.getMatrix(), 
                    a.Matrix.TEMP.identity(), a.Matrix.TEMP.d = this.d, a.Matrix.mul(t, a.Matrix.TEMP, this.resultMatrix), 
                    this.resultMatrix.tx = l, this.resultMatrix.ty = o);
                } else (t = this.resultTransform.getMatrix()).copyTo(this.resultMatrix);
                var c, d = 0;
                for (d = 0, c = this._children.length; d < c; d++) this._children[d].update();
            }
        }, {
            key: "updateChild",
            value: function() {
                var t, e = 0;
                for (e = 0, t = this._children.length; e < t; e++) this._children[e].update();
            }
        }, {
            key: "setRotation",
            value: function(t) {
                this._sprite && (this._sprite.rotation = 180 * t / Math.PI);
            }
        }, {
            key: "updateDraw",
            value: function(e, i) {
                t.ShowBones && !t.ShowBones[this.name] || (this._sprite ? (this._sprite.x = e + this.resultMatrix.tx, 
                this._sprite.y = i + this.resultMatrix.ty) : (this._sprite = new a.Sprite(), this._sprite.graphics.drawCircle(0, 0, 5, "#ff0000"), 
                this._sprite.graphics.drawLine(0, 0, this.length, 0, "#00ff00"), this._sprite.graphics.fillText(this.name, 0, 0, "20px Arial", "#00ff00", "center"), 
                a.ILaya.stage.addChild(this._sprite), this._sprite.x = e + this.resultMatrix.tx, 
                this._sprite.y = i + this.resultMatrix.ty));
                var r, s = 0;
                for (s = 0, r = this._children.length; s < r; s++) this._children[s].updateDraw(e, i);
            }
        }, {
            key: "addChild",
            value: function(t) {
                this._children.push(t), t.parentBone = this;
            }
        }, {
            key: "findBone",
            value: function(t) {
                if (this.name == t) return this;
                var e, i, a;
                for (e = 0, i = this._children.length; e < i; e++) if (a = this._children[e].findBone(t)) return a;
                return null;
            }
        }, {
            key: "localToWorld",
            value: function(t) {
                var e = t[0], i = t[1];
                t[0] = e * this.resultMatrix.a + i * this.resultMatrix.c + this.resultMatrix.tx, 
                t[1] = e * this.resultMatrix.b + i * this.resultMatrix.d + this.resultMatrix.ty;
            }
        } ]), t;
    }();
    M.ShowBones = {};
    var D = function() {
        function t() {
            (0, h.default)(this, t);
        }
        return (0, n.default)(t, null, [ {
            key: "getRelativeUV",
            value: function(t, e) {
                var i, a, r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, s = t[0], n = t[2] - t[0], h = t[1], l = t[5] - t[1];
                r || (r = []), r.length = e.length, a = r.length;
                var o = 1 / n, u = 1 / l;
                for (i = 0; i < a; i += 2) r[i] = (e[i] - s) * o, r[i + 1] = (e[i + 1] - h) * u;
                return r;
            }
        }, {
            key: "getAbsoluteUV",
            value: function(t, e) {
                var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
                if (0 == t[0] && 0 == t[1] && 1 == t[4] && 1 == t[5]) return i ? (a.Utils.copyArray(i, e), 
                i) : e;
                var r, s, n = t[0], h = t[2] - t[0], l = t[1], o = t[5] - t[1];
                for (i || (i = []), i.length = e.length, s = i.length, r = 0; r < s; r += 2) i[r] = e[r] * h + n, 
                i[r + 1] = e[r + 1] * o + l;
                return i;
            }
        } ]), t;
    }(), k = function() {
        function t() {
            (0, h.default)(this, t), this.uvs = new Float32Array([ 0, 0, 1, 0, 1, 1, 0, 1 ]), 
            this.vertices = new Float32Array([ 0, 0, 100, 0, 100, 100, 0, 100 ]), this.indexes = new Uint16Array([ 0, 1, 3, 3, 1, 2 ]), 
            this.useUvTransform = !1, this.canvasPadding = 1;
        }
        return (0, n.default)(t, [ {
            key: "getBounds",
            value: function() {
                return a.Rectangle._getWrapRec(this.vertices);
            }
        } ]), t;
    }(), I = function(t) {
        (0, s.default)(i, t);
        var e = l(i);
        function i() {
            return (0, h.default)(this, i), e.call(this);
        }
        return (0, n.default)(i, [ {
            key: "init2",
            value: function(t, e, i, a) {
                this.transform && (this.transform = null);
                var r = e || [ 0, 1, 3, 3, 1, 2 ];
                this.texture = t, this.indexes = new Uint16Array(r), this.vertices = new Float32Array(i), 
                this.uvs = new Float32Array(a);
            }
        } ]), i;
    }(k), A = function() {
        function t() {
            (0, h.default)(this, t), this.srcDisplayIndex = -1, this.type = "src", this.displayIndex = -1, 
            this.originalIndex = -1, this._replaceDic = {};
        }
        return (0, n.default)(t, [ {
            key: "showSlotData",
            value: function(t) {
                var e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
                this.currSlotData = t, e && (this.displayIndex = this.srcDisplayIndex), this.currDisplayData = null, 
                this.currTexture = null;
            }
        }, {
            key: "showDisplayByName",
            value: function(t) {
                this.currSlotData && this.showDisplayByIndex(this.currSlotData.getDisplayByName(t));
            }
        }, {
            key: "replaceDisplayByName",
            value: function(t, e) {
                var i, a;
                this.currSlotData && (i = this.currSlotData.getDisplayByName(t), a = this.currSlotData.getDisplayByName(e), 
                this.replaceDisplayByIndex(i, a));
            }
        }, {
            key: "replaceDisplayByIndex",
            value: function(t, e) {
                this.currSlotData && (this._replaceDic[t] = e, this.originalIndex == t && this.showDisplayByIndex(t));
            }
        }, {
            key: "showDisplayByIndex",
            value: function(t) {
                if (this.originalIndex = t, null != this._replaceDic[t] && (t = this._replaceDic[t]), 
                this.currSlotData && t > -1 && t < this.currSlotData.displayArr.length) {
                    if (this.displayIndex = t, this.currDisplayData = this.currSlotData.displayArr[t], 
                    this.currDisplayData) {
                        var e = this.currDisplayData.name;
                        this.currTexture = this.templet.getTexture(e), this.currTexture && 0 == this.currDisplayData.type && this.currDisplayData.uvs && (this.currTexture = this.currDisplayData.createTexture(this.currTexture));
                    }
                } else this.displayIndex = -1, this.currDisplayData = null, this.currTexture = null;
            }
        }, {
            key: "replaceSkin",
            value: function(t) {
                this._diyTexture = t, this._curDiyUV && (this._curDiyUV.length = 0), this.currDisplayData && this._diyTexture == this.currDisplayData.texture && (this._diyTexture = null);
            }
        }, {
            key: "setParentMatrix",
            value: function(t) {
                this._parentMatrix = t;
            }
        }, {
            key: "getSaveVerticle",
            value: function(e) {
                return t.useSameMatrixAndVerticle && this._preGraphicVerticle && t.isSameArr(e, this._preGraphicVerticle) ? e = this._preGraphicVerticle : (e = a.ILaya.Utils.copyArray([], e), 
                this._preGraphicVerticle = e), e;
            }
        }, {
            key: "getSaveMatrix",
            value: function(e) {
                if (t.useSameMatrixAndVerticle && this._preGraphicMatrix && t.isSameMatrix(e, this._preGraphicMatrix)) e = this._preGraphicMatrix; else {
                    var i = e.clone();
                    e = i, this._preGraphicMatrix = e;
                }
                return e;
            }
        }, {
            key: "draw",
            value: function(e, i) {
                var r = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], s = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
                if ((null != this._diyTexture || null != this.currTexture) && null != this.currDisplayData || this.currDisplayData && 3 == this.currDisplayData.type) {
                    var n, h = this.currTexture;
                    switch (this._diyTexture && (h = this._diyTexture), this.currDisplayData.type) {
                      case 0:
                        if (e) {
                            var l = this.getDisplayMatrix();
                            if (this._parentMatrix) {
                                var o = !1;
                                if (l) {
                                    var u;
                                    if (a.Matrix.mul(l, this._parentMatrix, a.Matrix.TEMP), r ? (null == this._resultMatrix && (this._resultMatrix = new a.Matrix()), 
                                    u = this._resultMatrix) : u = t._tempResultMatrix, this._diyTexture && this.currDisplayData.uvs) {
                                        var c = t._tempMatrix;
                                        c.identity(), this.currDisplayData.uvs[1] > this.currDisplayData.uvs[5] && (c.d = -1), 
                                        this.currDisplayData.uvs[0] > this.currDisplayData.uvs[4] && this.currDisplayData.uvs[1] > this.currDisplayData.uvs[5] && (o = !0, 
                                        c.rotate(-Math.PI / 2)), a.Matrix.mul(c, a.Matrix.TEMP, u);
                                    } else a.Matrix.TEMP.copyTo(u);
                                    r || (u = this.getSaveMatrix(u)), u._checkTransform(), o ? e.drawTexture(h, -this.currDisplayData.height / 2, -this.currDisplayData.width / 2, this.currDisplayData.height, this.currDisplayData.width, u, s) : e.drawTexture(h, -this.currDisplayData.width / 2, -this.currDisplayData.height / 2, this.currDisplayData.width, this.currDisplayData.height, u, s);
                                }
                            }
                        }
                        break;

                      case 1:
                        if (r ? (null == this._skinSprite && (this._skinSprite = t.createSkinMesh()), n = this._skinSprite) : n = t.createSkinMesh(), 
                        null == n) return;
                        var d;
                        if (null == this.currDisplayData.bones) {
                            var _, p = this.currDisplayData.weights;
                            this.deformData && (p = this.deformData), this._diyTexture ? (this._curDiyUV || (this._curDiyUV = []), 
                            0 == this._curDiyUV.length && (this._curDiyUV = D.getRelativeUV(this.currTexture.uv, this.currDisplayData.uvs, this._curDiyUV), 
                            this._curDiyUV = D.getAbsoluteUV(this._diyTexture.uv, this._curDiyUV, this._curDiyUV)), 
                            _ = this._curDiyUV) : _ = this.currDisplayData.uvs, this._mVerticleArr = p, this.currDisplayData.triangles.length, 
                            d = this.currDisplayData.triangles, this.deformData && (r || (this._mVerticleArr = this.getSaveVerticle(this._mVerticleArr))), 
                            n.init2(h, d, this._mVerticleArr, _);
                            var f, y = this.getDisplayMatrix();
                            this._parentMatrix && y && (a.Matrix.mul(y, this._parentMatrix, a.Matrix.TEMP), 
                            r ? (null == this._resultMatrix && (this._resultMatrix = new a.Matrix()), f = this._resultMatrix) : f = t._tempResultMatrix, 
                            a.Matrix.TEMP.copyTo(f), r || (f = this.getSaveMatrix(f)), n.transform = f);
                        } else this.skinMesh(i, n);
                        e.drawSkin(n, s);
                        break;

                      case 2:
                        if (r ? (null == this._skinSprite && (this._skinSprite = t.createSkinMesh()), n = this._skinSprite) : n = t.createSkinMesh(), 
                        null == n) return;
                        this.skinMesh(i, n), e.drawSkin(n, s);
                    }
                }
            }
        }, {
            key: "skinMesh",
            value: function(e, i) {
                var a, r = this.currTexture, s = this.currDisplayData.bones;
                this._diyTexture ? (r = this._diyTexture, this._curDiyUV || (this._curDiyUV = []), 
                0 == this._curDiyUV.length && (this._curDiyUV = D.getRelativeUV(this.currTexture.uv, this.currDisplayData.uvs, this._curDiyUV), 
                this._curDiyUV = D.getAbsoluteUV(this._diyTexture.uv, this._curDiyUV, this._curDiyUV)), 
                a = this._curDiyUV) : a = this.currDisplayData.uvs;
                var n, h, l, o, u, c = this.currDisplayData.weights, d = this.currDisplayData.triangles, _ = 0, p = 0, f = 0, y = 0, m = 0, g = 0, v = 0;
                if (t._tempVerticleArr.length = 0, u = t._tempVerticleArr, this.deformData && this.deformData.length > 0) {
                    var x = 0;
                    for (g = 0, v = s.length; g < v; ) {
                        for (f = s[g++] + g, _ = 0, p = 0; g < f; g++) h = e[s[g]], l = c[y] + this.deformData[x++], 
                        o = c[y + 1] + this.deformData[x++], m = c[y + 2], _ += (l * h.a + o * h.c + h.tx) * m, 
                        p += (l * h.b + o * h.d + h.ty) * m, y += 3;
                        u.push(_, p);
                    }
                } else for (g = 0, v = s.length; g < v; ) {
                    for (f = s[g++] + g, _ = 0, p = 0; g < f; g++) h = e[s[g]], l = c[y], o = c[y + 1], 
                    m = c[y + 2], _ += (l * h.a + o * h.c + h.tx) * m, p += (l * h.b + o * h.d + h.ty) * m, 
                    y += 3;
                    u.push(_, p);
                }
                this._mVerticleArr = u, n = d, this._mVerticleArr = this.getSaveVerticle(this._mVerticleArr), 
                i.init2(r, n, this._mVerticleArr, a);
            }
        }, {
            key: "drawBonePoint",
            value: function(t) {
                t && this._parentMatrix && t.drawCircle(this._parentMatrix.tx, this._parentMatrix.ty, 5, "#ff0000");
            }
        }, {
            key: "getDisplayMatrix",
            value: function() {
                return this.currDisplayData ? this.currDisplayData.transform.getMatrix() : null;
            }
        }, {
            key: "getMatrix",
            value: function() {
                return this._resultMatrix;
            }
        }, {
            key: "copy",
            value: function() {
                var e = new t();
                return e.type = "copy", e.name = this.name, e.attachmentName = this.attachmentName, 
                e.srcDisplayIndex = this.srcDisplayIndex, e.parent = this.parent, e.displayIndex = this.displayIndex, 
                e.templet = this.templet, e.currSlotData = this.currSlotData, e.currTexture = this.currTexture, 
                e.currDisplayData = this.currDisplayData, e;
            }
        } ], [ {
            key: "createSkinMesh",
            value: function() {
                return new I();
            }
        }, {
            key: "isSameArr",
            value: function(t, e) {
                if (t.length != e.length) return !1;
                var i, a;
                for (a = t.length, i = 0; i < a; i++) if (t[i] != e[i]) return !1;
                return !0;
            }
        }, {
            key: "isSameMatrix",
            value: function(t, e) {
                return t.a == e.a && t.b == e.b && t.c == e.c && t.d == e.d && Math.abs(t.tx - e.tx) < 1e-5 && Math.abs(t.ty - e.ty) < 1e-5;
            }
        } ]), t;
    }();
    A._tempMatrix = new a.Matrix(), A._tempResultMatrix = new a.Matrix(), A.useSameMatrixAndVerticle = !0, 
    A._tempVerticleArr = [];
    var T = function t() {
        (0, h.default)(this, t), this.deformSlotDataList = [];
    }, S = function t() {
        (0, h.default)(this, t), this.deformSlotDisplayList = [];
    }, b = function() {
        function t() {
            (0, h.default)(this, t), this.slotIndex = -1, this.timeList = [], this.vectices = [], 
            this.tweenKeyList = [], this.frameIndex = 0;
        }
        return (0, n.default)(t, [ {
            key: "binarySearch1",
            value: function(t, e) {
                var i = 0, a = t.length - 2;
                if (0 == a) return 1;
                for (var r = a >>> 1; ;) {
                    if (t[Math.floor(r + 1)] <= e ? i = r + 1 : a = r, i == a) return i + 1;
                    r = i + a >>> 1;
                }
                return 0;
            }
        }, {
            key: "apply",
            value: function(t, e) {
                var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
                if (t += .05, !(this.timeList.length <= 0)) {
                    var a = 0;
                    if (!(t < this.timeList[0])) {
                        var r = this.vectices[0].length, s = [], n = this.binarySearch1(this.timeList, t);
                        if (this.frameIndex = n, t >= this.timeList[this.timeList.length - 1]) {
                            var h = this.vectices[this.vectices.length - 1];
                            if (i < 1) for (a = 0; a < r; a++) s[a] += (h[a] - s[a]) * i; else for (a = 0; a < r; a++) s[a] = h[a];
                            this.deformData = s;
                        } else {
                            var l, o = this.vectices[this.frameIndex - 1], u = this.vectices[this.frameIndex], c = this.timeList[this.frameIndex - 1], d = this.timeList[this.frameIndex];
                            for (i = this.tweenKeyList[n - 1] ? (t - c) / (d - c) : 0, a = 0; a < r; a++) l = o[a], 
                            s[a] = l + (u[a] - l) * i;
                            this.deformData = s;
                        }
                    }
                }
            }
        } ]), t;
    }(), C = function t() {
        (0, h.default)(this, t), this.drawOrder = [];
    }, F = function t() {
        (0, h.default)(this, t);
    }, w = function() {
        function t(e, i) {
            (0, h.default)(this, t), this.isSpine = !0, this.isDebug = !1, this._targetBone = i[e.targetBoneIndex], 
            this.isSpine = e.isSpine, null == this._bones && (this._bones = []), this._bones.length = 0;
            for (var a = 0, r = e.boneIndexs.length; a < r; a++) this._bones.push(i[e.boneIndexs[a]]);
            this.name = e.name, this.mix = e.mix, this.bendDirection = e.bendDirection;
        }
        return (0, n.default)(t, [ {
            key: "apply",
            value: function() {
                switch (this._bones.length) {
                  case 1:
                    this._applyIk1(this._bones[0], this._targetBone.resultMatrix.tx, this._targetBone.resultMatrix.ty, this.mix);
                    break;

                  case 2:
                    this.isSpine ? this._applyIk2(this._bones[0], this._bones[1], this._targetBone.resultMatrix.tx, this._targetBone.resultMatrix.ty, this.bendDirection, this.mix) : this._applyIk3(this._bones[0], this._bones[1], this._targetBone.resultMatrix.tx, this._targetBone.resultMatrix.ty, this.bendDirection, this.mix);
                }
            }
        }, {
            key: "_applyIk1",
            value: function(e, i, a, r) {
                var s = e.parentBone, n = 1 / (s.resultMatrix.a * s.resultMatrix.d - s.resultMatrix.b * s.resultMatrix.c), h = i - s.resultMatrix.tx, l = a - s.resultMatrix.ty, o = (h * s.resultMatrix.d - l * s.resultMatrix.c) * n - e.transform.x, u = (l * s.resultMatrix.a - h * s.resultMatrix.b) * n - e.transform.y, c = Math.atan2(u, o) * t.radDeg - 0 - e.transform.skX;
                e.transform.scX < 0 && (c += 180), c > 180 ? c -= 360 : c < -180 && (c += 360), 
                e.transform.skX = e.transform.skY = e.transform.skX + c * r, e.update();
            }
        }, {
            key: "updatePos",
            value: function(t, e) {
                this._sp && this._sp.pos(t, e);
            }
        }, {
            key: "_applyIk2",
            value: function(e, i, r, s, n, h) {
                if (0 != h) {
                    var l, o, u, c = e.resultTransform.x, d = e.resultTransform.y, _ = e.transform.scX, p = e.transform.scY, f = i.transform.scX;
                    _ < 0 ? (_ = -_, l = 180, u = -1) : (l = 0, u = 1), p < 0 && (p = -p, u = -u), f < 0 ? (f = -f, 
                    o = 180) : o = 0;
                    var y, m, g, v = i.resultTransform.x, x = e.resultMatrix.a, M = e.resultMatrix.c, D = e.resultMatrix.b, k = e.resultMatrix.d, I = Math.abs(_ - p) <= 1e-4;
                    I ? (m = x * v + M * (y = i.resultTransform.y) + e.resultMatrix.tx, g = D * v + k * y + e.resultMatrix.ty) : (y = 0, 
                    m = x * v + e.resultMatrix.tx, g = D * v + e.resultMatrix.ty), this.isDebug && (this._sp || (this._sp = new a.Sprite(), 
                    a.ILaya.stage.addChild(this._sp)), this._sp.graphics.clear(), this._sp.graphics.drawCircle(r, s, 15, "#ffff00"), 
                    this._sp.graphics.drawCircle(m, g, 15, "#ff00ff")), e.setRotation(Math.atan2(g - e.resultMatrix.ty, m - e.resultMatrix.tx));
                    var A = e.parentBone;
                    x = A.resultMatrix.a, M = A.resultMatrix.c, D = A.resultMatrix.b;
                    var T, S, b = 1 / (x * (k = A.resultMatrix.d) - M * D), C = r - A.resultMatrix.tx, F = s - A.resultMatrix.ty, w = (C * k - F * M) * b - c, P = (F * x - C * D) * b - d, L = ((C = m - A.resultMatrix.tx) * k - (F = g - A.resultMatrix.ty) * M) * b - c, U = (F * x - C * D) * b - d, B = Math.sqrt(L * L + U * U), E = i.length * f;
                    if (I) {
                        var R = (w * w + P * P - B * B - (E *= _) * E) / (2 * B * E);
                        R < -1 ? R = -1 : R > 1 && (R = 1), S = Math.acos(R) * n, x = B + E * R, M = E * Math.sin(S), 
                        T = Math.atan2(P * x - w * M, w * x + P * M);
                    } else {
                        var N = (x = _ * E) * x, O = (M = p * E) * M, V = w * w + P * P, Y = Math.atan2(P, w), K = -2 * O * B, X = O - N;
                        if ((k = K * K - 4 * X * (D = O * B * B + N * V - N * O)) > 0) {
                            var W = Math.sqrt(k);
                            K < 0 && (W = -W);
                            var q = (W = -(K + W) / 2) / X, z = D / W, G = Math.abs(q) < Math.abs(z) ? q : z;
                            G * G <= V && (F = Math.sqrt(V - G * G) * n, T = Y - Math.atan2(F, G), S = Math.atan2(F / p, (G - B) / _));
                        }
                        var H = 0, Q = Number.MAX_VALUE, Z = 0, j = 0, J = 0, $ = 0, tt = 0, et = 0;
                        (k = (C = B + x) * C) > $ && (J = 0, $ = k, tt = C), (k = (C = B - x) * C) < Q && (H = Math.PI, 
                        Q = k, Z = C);
                        var it = Math.acos(-x * B / (N - O));
                        (k = (C = x * Math.cos(it) + B) * C + (F = M * Math.sin(it)) * F) < Q && (H = it, 
                        Q = k, Z = C, j = F), k > $ && (J = it, $ = k, tt = C, et = F), V <= (Q + $) / 2 ? (T = Y - Math.atan2(j * n, Z), 
                        S = H * n) : (T = Y - Math.atan2(et * n, tt), S = J * n);
                    }
                    var at = Math.atan2(y, v) * u, rt = e.resultTransform.skX;
                    (T = (T - at) * t.radDeg + l - rt) > 180 ? T -= 360 : T < -180 && (T += 360), e.resultTransform.x = c, 
                    e.resultTransform.y = d, e.resultTransform.skX = e.resultTransform.skY = rt + T * h, 
                    rt = i.resultTransform.skX, rt %= 360, (S = ((S + at) * t.radDeg - 0) * u + o - rt) > 180 ? S -= 360 : S < -180 && (S += 360), 
                    i.resultTransform.x = v, i.resultTransform.y = y, i.resultTransform.skX = i.resultTransform.skY = i.resultTransform.skY + S * h, 
                    e.update();
                }
            }
        }, {
            key: "_applyIk3",
            value: function(e, i, r, s, n, h) {
                if (0 != h) {
                    var l, o, u, c, d, _, p = i.resultMatrix.a * i.length, f = i.resultMatrix.b * i.length, y = p * p + f * f, m = Math.sqrt(y), g = e.resultMatrix.tx, v = e.resultMatrix.ty, x = i.resultMatrix.tx, M = i.resultMatrix.ty, D = x - g, k = M - v, I = D * D + k * k, A = Math.sqrt(I), T = (D = r - e.resultMatrix.tx) * D + (k = s - e.resultMatrix.ty) * k, S = Math.sqrt(T);
                    if (m + A <= S || S + m <= A || S + A <= m) {
                        var b;
                        x = g + (b = m + A <= S ? 1 : -1) * (r - g) * A / S, M = v + b * (s - v) * A / S;
                    } else {
                        var C = (I - y + T) / (2 * T), F = Math.sqrt(I - C * C * T) / S, w = g + D * C, P = v + k * C, L = -k * F, U = D * F;
                        n > 0 ? (x = w - L, M = P - U) : (x = w + L, M = P + U);
                    }
                    l = x, o = M, this.isDebug && (this._sp || (this._sp = new a.Sprite(), a.ILaya.stage.addChild(this._sp)), 
                    this._sp.graphics.clear(), this._sp.graphics.drawCircle(g, v, 15, "#ff00ff"), this._sp.graphics.drawCircle(r, s, 15, "#ffff00"), 
                    this._sp.graphics.drawCircle(l, o, 15, "#ff00ff")), u = Math.atan2(o - e.resultMatrix.ty, l - e.resultMatrix.tx), 
                    e.setRotation(u), (c = t._tempMatrix).identity(), c.rotate(u), c.scale(e.resultMatrix.getScaleX(), e.resultMatrix.getScaleY()), 
                    c.translate(e.resultMatrix.tx, e.resultMatrix.ty), c.copyTo(e.resultMatrix), e.updateChild(), 
                    d = Math.atan2(s - o, r - l), i.setRotation(d), (_ = t._tempMatrix).identity(), 
                    _.rotate(d), _.scale(i.resultMatrix.getScaleX(), i.resultMatrix.getScaleY()), _.translate(l, o), 
                    c.copyTo(i.resultMatrix), i.updateChild();
                }
            }
        } ]), t;
    }();
    w.radDeg = 180 / Math.PI, w.degRad = Math.PI / 180, w._tempMatrix = new a.Matrix();
    var P = function t() {
        (0, h.default)(this, t), this.boneNames = [], this.bendDirection = 1, this.mix = 1, 
        this.isSpine = !0, this.targetBoneIndex = -1, this.boneIndexs = [];
    }, L = function() {
        function t(e, i) {
            (0, h.default)(this, t), this._debugKey = !1, this._segments = [], this._curves = [], 
            this.data = e, this.position = e.position, this.spacing = e.spacing, this.rotateMix = e.rotateMix, 
            this.translateMix = e.translateMix, this.bones = [];
            for (var a = this.data.bones, r = 0, s = a.length; r < s; r++) this.bones.push(i[a[r]]);
        }
        return (0, n.default)(t, [ {
            key: "apply",
            value: function(t, e) {
                if (this.target) {
                    var i = this.translateMix, a = this.translateMix, r = a > 0, s = this.data.spacingMode, n = "length" == s, h = this.data.rotateMode, l = "tangent" == h, o = "chainScale" == h, u = [], c = this.bones.length, d = l ? c : c + 1, _ = [];
                    this._spaces = _, _[0] = this.position;
                    var p = this.spacing;
                    if (o || n) for (var f = 0, y = d - 1; f < y; ) {
                        var m = this.bones[f], g = m.length, v = g * m.resultMatrix.a, x = g * m.resultMatrix.b;
                        g = Math.sqrt(v * v + x * x), o && (u[f] = g), _[++f] = n ? Math.max(0, g + p) : p;
                    } else for (f = 1; f < d; f++) _[f] = p;
                    var M = this.computeWorldPositions(this.target, t, e, d, l, "percent" == this.data.positionMode, "percent" == s);
                    if (this._debugKey) {
                        for (f = 0; f < M.length; f++) e.drawCircle(M[f++], M[f++], 5, "#00ff00");
                        var D = [];
                        for (f = 0; f < M.length; f++) D.push(M[f++], M[f++]);
                        e.drawLines(0, 0, D, "#ff0000");
                    }
                    var k, I = M[0], A = M[1], T = this.data.offsetRotation, S = "chain" == h && 0 == T;
                    for (f = 0, k = 3; f < c; f++, k += 3) {
                        (m = this.bones[f]).resultMatrix.tx += (I - m.resultMatrix.tx) * i, m.resultMatrix.ty += (A - m.resultMatrix.ty) * i;
                        var b = (v = M[k]) - I, C = (x = M[k + 1]) - A;
                        if (o && 0 != (g = u[f])) {
                            var F = (Math.sqrt(b * b + C * C) / g - 1) * a + 1;
                            m.resultMatrix.a *= F, m.resultMatrix.c *= F;
                        }
                        if (I = v, A = x, r) {
                            var w, P, L, U = m.resultMatrix.a, B = m.resultMatrix.c, E = m.resultMatrix.b, R = m.resultMatrix.d;
                            w = l ? M[k - 1] : 0 == _[f + 1] ? M[k + 2] : Math.atan2(C, b), w -= Math.atan2(E, U) - T / 180 * Math.PI, 
                            S && (P = Math.cos(w), L = Math.sin(w), I += ((g = m.length) * (P * U - L * E) - b) * a, 
                            A += (g * (L * U + P * E) - C) * a), w > Math.PI ? w -= 2 * Math.PI : w < -Math.PI && (w += 2 * Math.PI), 
                            w *= a, P = Math.cos(w), L = Math.sin(w), m.resultMatrix.a = P * U - L * E, m.resultMatrix.c = P * B - L * R, 
                            m.resultMatrix.b = L * U + P * E, m.resultMatrix.d = L * B + P * R;
                        }
                    }
                }
            }
        }, {
            key: "computeWorldVertices2",
            value: function(e, i, a, r, s, n) {
                var h, l, o, u = e.currDisplayData.bones, c = e.currDisplayData.weights, d = e.currDisplayData.triangles, _ = 0, p = 0, f = 0, y = 0, m = 0, g = 0, v = 0, x = 0, M = 0, D = 0;
                if (null != u) {
                    for (_ = 0; _ < a; _ += 2) p += (y = u[p]) + 1, f += y;
                    var k = i;
                    for (m = n, g = 3 * f; m < r; m += 2) {
                        for (v = 0, x = 0, y = u[p++], y += p; p < y; p++, g += 3) {
                            h = k[u[p]].resultMatrix, M = c[g], D = c[g + 1];
                            var I = c[g + 2];
                            v += (M * h.a + D * h.c + h.tx) * I, x += (M * h.b + D * h.d + h.ty) * I;
                        }
                        s[m] = v, s[m + 1] = x;
                    }
                } else {
                    var A, T;
                    if (d || (d = c), e.deformData && (d = e.deformData), A = e.parent, i) for (o = i.length, 
                    _ = 0; _ < o; _++) if (i[_].name == A) {
                        l = i[_];
                        break;
                    }
                    l && (T = l.resultMatrix), T || (T = t._tempMt);
                    var S = T.tx, b = T.ty, C = T.a, F = T.b, w = T.c, P = T.d;
                    for (l && (P *= l.d), p = a, m = n; m < r; p += 2, m += 2) M = d[p], D = d[p + 1], 
                    s[m] = M * C + D * F + S, s[m + 1] = -(M * w + D * P + b);
                }
            }
        }, {
            key: "computeWorldPositions",
            value: function(t, e, i, a, r, s, n) {
                t.currDisplayData.bones, t.currDisplayData.weights, t.currDisplayData.triangles;
                var h, l, o, u, c, d, _, p, f = [], y = 0, m = t.currDisplayData.verLen, g = this.position, v = this._spaces, x = [], M = m / 6, D = -1;
                if (M--, m -= 4, this.computeWorldVertices2(t, e, 2, m, f, 0), this._debugKey) for (y = 0; y < f.length; ) i.drawCircle(f[y++], f[y++], 10, "#ff0000");
                h = f, this._curves.length = M;
                var k = this._curves;
                l = 0;
                var I, A, T, S, b, C, F, w, P, L = h[0], U = h[1], B = 0, E = 0, R = 0, N = 0, O = 0, V = 0;
                for (y = 0, P = 2; y < M; y++, P += 6) b = 2 * (I = .1875 * (L - 2 * (B = h[P]) + (R = h[P + 2]))) + (T = .09375 * (3 * (B - R) - L + (O = h[P + 4]))), 
                C = 2 * (A = .1875 * (U - 2 * (E = h[P + 1]) + (N = h[P + 3]))) + (S = .09375 * (3 * (E - N) - U + (V = h[P + 5]))), 
                F = .75 * (B - L) + I + .16666667 * T, w = .75 * (E - U) + A + .16666667 * S, l += Math.sqrt(F * F + w * w), 
                F += b, w += C, b += T, C += S, l += Math.sqrt(F * F + w * w), F += b, w += C, l += Math.sqrt(F * F + w * w), 
                F += b + T, w += C + S, l += Math.sqrt(F * F + w * w), k[y] = l, L = O, U = V;
                if (s && (g *= l), n) for (y = 0; y < a; y++) v[y] *= l;
                var Y, K = this._segments, X = 0;
                for (y = 0, o = 0, u = 0, Y = 0; y < a; y++, o += 3) if ((c = g += d = v[y]) < 0) this.addBeforePosition(c, h, 0, x, o); else if (c > l) this.addAfterPosition(c - l, h, m - 4, x, o); else {
                    for (;;u++) if (!(c > (p = k[u]))) {
                        0 == u ? c /= p : c = (c - (_ = k[u - 1])) / (p - _);
                        break;
                    }
                    if (u != D) {
                        D = u;
                        var W = 6 * u;
                        for (b = 2 * (I = .03 * ((L = h[W]) - 2 * (B = h[W + 2]) + (R = h[W + 4]))) + (T = .006 * (3 * (B - R) - L + (O = h[W + 6]))), 
                        C = 2 * (A = .03 * ((U = h[W + 1]) - 2 * (E = h[W + 3]) + (N = h[W + 5]))) + (S = .006 * (3 * (E - N) - U + (V = h[W + 7]))), 
                        F = .3 * (B - L) + I + .16666667 * T, w = .3 * (E - U) + A + .16666667 * S, X = Math.sqrt(F * F + w * w), 
                        K[0] = X, W = 1; W < 8; W++) F += b, w += C, b += T, C += S, X += Math.sqrt(F * F + w * w), 
                        K[W] = X;
                        F += b, w += C, X += Math.sqrt(F * F + w * w), K[8] = X, F += b + T, w += C + S, 
                        X += Math.sqrt(F * F + w * w), K[9] = X, Y = 0;
                    }
                    for (c *= X; ;Y++) if (!(c > (p = K[Y]))) {
                        0 == Y ? c /= p : c = Y + (c - (_ = K[Y - 1])) / (p - _);
                        break;
                    }
                    this.addCurvePosition(.1 * c, L, U, B, E, R, N, O, V, x, o, r || y > 0 && 0 == d);
                }
                return x;
            }
        }, {
            key: "addBeforePosition",
            value: function(t, e, i, a, r) {
                var s = e[i], n = e[i + 1], h = e[i + 2] - s, l = e[i + 3] - n, o = Math.atan2(l, h);
                a[r] = s + t * Math.cos(o), a[r + 1] = n + t * Math.sin(o), a[r + 2] = o;
            }
        }, {
            key: "addAfterPosition",
            value: function(t, e, i, a, r) {
                var s = e[i + 2], n = e[i + 3], h = s - e[i], l = n - e[i + 1], o = Math.atan2(l, h);
                a[r] = s + t * Math.cos(o), a[r + 1] = n + t * Math.sin(o), a[r + 2] = o;
            }
        }, {
            key: "addCurvePosition",
            value: function(t, e, i, a, r, s, n, h, l, o, u, c) {
                0 == t && (t = 1e-4);
                var d = t * t, _ = d * t, p = 1 - t, f = p * p, y = f * p, m = p * t, g = 3 * m, v = p * g, x = g * t, M = e * y + a * v + s * x + h * _, D = i * y + r * v + n * x + l * _;
                o[u] = M, o[u + 1] = D, o[u + 2] = c ? Math.atan2(D - (i * f + r * m * 2 + n * d), M - (e * f + a * m * 2 + s * d)) : 0;
            }
        } ]), t;
    }();
    L.BEFORE = -2, L.AFTER = -3, L._tempMt = new a.Matrix();
    var U = function t() {
        (0, h.default)(this, t), this.bones = [];
    }, B = function() {
        function t(e, i) {
            var a, r;
            for ((0, h.default)(this, t), this._temp = [], this._data = e, null == this._bones && (this._bones = []), 
            this.target = i[e.targetIndex], a = 0, r = e.boneIndexs.length; a < r; a++) this._bones.push(i[e.boneIndexs[a]]);
            this.rotateMix = e.rotateMix, this.translateMix = e.translateMix, this.scaleMix = e.scaleMix, 
            this.shearMix = e.shearMix;
        }
        return (0, n.default)(t, [ {
            key: "apply",
            value: function() {
                for (var t, e = this.target.resultMatrix.a, i = this.target.resultMatrix.b, a = this.target.resultMatrix.c, r = this.target.resultMatrix.d, s = 0, n = this._bones.length; s < n; s++) {
                    if (t = this._bones[s], this.rotateMix > 0) {
                        var h = t.resultMatrix.a, l = t.resultMatrix.b, o = t.resultMatrix.c, u = t.resultMatrix.d, c = Math.atan2(a, e) - Math.atan2(o, h) + this._data.offsetRotation * Math.PI / 180;
                        c > Math.PI ? c -= 2 * Math.PI : c < -Math.PI && (c += 2 * Math.PI), c *= this.rotateMix;
                        var d = Math.cos(c), _ = Math.sin(c);
                        t.resultMatrix.a = d * h - _ * o, t.resultMatrix.b = d * l - _ * u, t.resultMatrix.c = _ * h + d * o, 
                        t.resultMatrix.d = _ * l + d * u;
                    }
                    if (this.translateMix && (this._temp[0] = this._data.offsetX, this._temp[1] = this._data.offsetY, 
                    this.target.localToWorld(this._temp), t.resultMatrix.tx += (this._temp[0] - t.resultMatrix.tx) * this.translateMix, 
                    t.resultMatrix.ty += (this._temp[1] - t.resultMatrix.ty) * this.translateMix, t.updateChild()), 
                    this.scaleMix > 0) {
                        var p = Math.sqrt(t.resultMatrix.a * t.resultMatrix.a + t.resultMatrix.c * t.resultMatrix.c), f = Math.sqrt(e * e + a * a), y = p > 1e-5 ? (p + (f - p + this._data.offsetScaleX) * this.scaleMix) / p : 0;
                        t.resultMatrix.a *= y, t.resultMatrix.c *= y, p = Math.sqrt(t.resultMatrix.b * t.resultMatrix.b + t.resultMatrix.d * t.resultMatrix.d), 
                        f = Math.sqrt(i * i + r * r), y = p > 1e-5 ? (p + (f - p + this._data.offsetScaleY) * this.scaleMix) / p : 0, 
                        t.resultMatrix.b *= y, t.resultMatrix.d *= y;
                    }
                    if (this.shearMix > 0) {
                        l = t.resultMatrix.b, u = t.resultMatrix.d;
                        var m = Math.atan2(u, l);
                        (c = Math.atan2(r, i) - Math.atan2(a, e) - (m - Math.atan2(t.resultMatrix.c, t.resultMatrix.a))) > Math.PI ? c -= 2 * Math.PI : c < -Math.PI && (c += 2 * Math.PI), 
                        c = m + (c + this._data.offsetShearY * Math.PI / 180) * this.shearMix, y = Math.sqrt(l * l + u * u), 
                        t.resultMatrix.b = Math.cos(c) * y, t.resultMatrix.d = Math.sin(c) * y;
                    }
                }
            }
        } ]), t;
    }(), E = function(t) {
        (0, s.default)(u, t);
        var e = l(u);
        function u() {
            var t, i = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, a = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
            return (0, h.default)(this, u), (t = e.call(this))._boneMatrixArray = [], t._lastTime = 0, 
            t._currAniIndex = -1, t._pause = !0, t._aniClipIndex = -1, t._clipIndex = -1, t._skinIndex = 0, 
            t._skinName = "default", t._aniMode = 0, t._index = -1, t._total = -1, t._indexControl = !1, 
            t._eventIndex = 0, t._drawOrderIndex = 0, t._drawOrder = null, t._lastAniClipIndex = -1, 
            t._lastUpdateAniClipIndex = -1, t._playAudio = !0, t._soundChannelArr = [], i && t.init(i, a), 
            t;
        }
        return (0, n.default)(u, [ {
            key: "init",
            value: function(t) {
                var e, i, r, s, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, h = 0;
                if (1 == n) for (this._graphicsCache = [], h = 0, e = t.getAnimationCount(); h < e; h++) this._graphicsCache.push([]);
                if (this._yReverseMatrix = t.yReverseMatrix, this._aniMode = n, this._templet = t, 
                this._templet._addReference(1), this._player = new y(), this._player.cacheFrameRate = t.rate, 
                this._player.templet = t, this._player.play(), this._parseSrcBoneMatrix(), this._boneList = t.mBoneArr, 
                this._rootBone = t.mRootBone, this._aniSectionDic = t.aniSectionDic, t.ikArr.length > 0) for (this._ikArr = [], 
                h = 0, e = t.ikArr.length; h < e; h++) this._ikArr.push(new w(t.ikArr[h], this._boneList));
                if (t.pathArr.length > 0) for (null == this._pathDic && (this._pathDic = {}), h = 0, 
                e = t.pathArr.length; h < e; h++) i = t.pathArr[h], r = new L(i, this._boneList), 
                (s = this._boneSlotDic[i.name]) && ((r = new L(i, this._boneList)).target = s), 
                this._pathDic[i.name] = r;
                if (t.tfArr.length > 0) for (this._tfArr = [], h = 0, e = t.tfArr.length; h < e; h++) this._tfArr.push(new B(t.tfArr[h], this._boneList));
                if (t.skinDataArray.length > 0) {
                    var l = this._templet.skinDataArray[this._skinIndex];
                    this._skinName = l.name;
                }
                this._player.on(a.Event.PLAYED, this, this._onPlay), this._player.on(a.Event.STOPPED, this, this._onStop), 
                this._player.on(a.Event.PAUSED, this, this._onPause);
            }
        }, {
            key: "load",
            value: function(t) {
                var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                this._aniPath = t, this._complete = e, this._loadAniMode = i, a.ILaya.loader.load([ {
                    url: t,
                    type: a.ILaya.Loader.BUFFER
                } ], a.Handler.create(this, this._onLoaded));
            }
        }, {
            key: "_onLoaded",
            value: function() {
                var t, e = a.ILaya.Loader.getRes(this._aniPath);
                null != e && (null == o.Templet.TEMPLET_DICTIONARY && (o.Templet.TEMPLET_DICTIONARY = {}), 
                (t = o.Templet.TEMPLET_DICTIONARY[this._aniPath]) ? t.isParseFail ? this._parseFail() : t.isParserComplete ? this._parseComplete() : (t.on(a.Event.COMPLETE, this, this._parseComplete), 
                t.on(a.Event.ERROR, this, this._parseFail)) : ((t = new o.Templet())._setCreateURL(this._aniPath), 
                o.Templet.TEMPLET_DICTIONARY[this._aniPath] = t, t.on(a.Event.COMPLETE, this, this._parseComplete), 
                t.on(a.Event.ERROR, this, this._parseFail), t.isParserComplete = !1, t.parseData(null, e)));
            }
        }, {
            key: "_parseComplete",
            value: function() {
                var t = o.Templet.TEMPLET_DICTIONARY[this._aniPath];
                t && (this.init(t, this._loadAniMode), this.play(0, !0)), this._complete && this._complete.runWith(this);
            }
        }, {
            key: "_parseFail",
            value: function() {
                console.log("[Error]:" + this._aniPath + "解析失败");
            }
        }, {
            key: "_onPlay",
            value: function() {
                this.event(a.Event.PLAYED);
            }
        }, {
            key: "_onStop",
            value: function() {
                var t, e = this._templet.eventAniArr[this._aniClipIndex];
                if (e && this._eventIndex < e.length) for (;this._eventIndex < e.length; this._eventIndex++) (t = e[this._eventIndex]).time >= this._player.playStart && t.time <= this._player.playEnd && this.event(a.Event.LABEL, t);
                this._drawOrder = null, this.event(a.Event.STOPPED);
            }
        }, {
            key: "_onPause",
            value: function() {
                this.event(a.Event.PAUSED);
            }
        }, {
            key: "_parseSrcBoneMatrix",
            value: function() {
                var t = 0, e = 0;
                for (e = this._templet.srcBoneMatrixArr.length, t = 0; t < e; t++) this._boneMatrixArray.push(new a.Matrix());
                if (0 == this._aniMode) this._boneSlotDic = this._templet.boneSlotDic, this._bindBoneBoneSlotDic = this._templet.bindBoneBoneSlotDic, 
                this._boneSlotArray = this._templet.boneSlotArray; else {
                    null == this._boneSlotDic && (this._boneSlotDic = {}), null == this._bindBoneBoneSlotDic && (this._bindBoneBoneSlotDic = {}), 
                    null == this._boneSlotArray && (this._boneSlotArray = []);
                    var i, r, s = this._templet.boneSlotArray;
                    for (t = 0, e = s.length; t < e; t++) i = s[t], null == (r = this._bindBoneBoneSlotDic[i.parent]) && (this._bindBoneBoneSlotDic[i.parent] = r = []), 
                    this._boneSlotDic[i.name] = i = i.copy(), r.push(i), this._boneSlotArray.push(i);
                }
            }
        }, {
            key: "_emitMissedEvents",
            value: function(t, e) {
                var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, r = this._templet.eventAniArr[this._player.currentAnimationClipIndex];
                if (r) {
                    var s, n, h = 0;
                    for (s = r.length, h = i; h < s; h++) (n = r[h]).time >= this._player.playStart && n.time <= this._player.playEnd && this.event(a.Event.LABEL, n);
                }
            }
        }, {
            key: "_update",
            value: function() {
                var t = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
                if (!(t && this._pause || t && this._indexControl)) {
                    var e = this.timer.currTimer, i = this._player.currentKeyframeIndex, r = e - this._lastTime;
                    if (t ? this._player._update(r) : i = -1, this._lastTime = e, this._player && (this._index = this._clipIndex = this._player.currentKeyframeIndex, 
                    !(this._index < 0 || r > 0 && this._clipIndex == i && this._lastUpdateAniClipIndex == this._aniClipIndex))) {
                        this._lastUpdateAniClipIndex = this._aniClipIndex, i > this._clipIndex && 0 != this._eventIndex && (this._emitMissedEvents(this._player.playStart, this._player.playEnd, this._eventIndex), 
                        this._eventIndex = 0);
                        var s, n, h = this._templet.eventAniArr[this._aniClipIndex];
                        if (h && this._eventIndex < h.length) {
                            var l = h[this._eventIndex];
                            l.time >= this._player.playStart && l.time <= this._player.playEnd ? this._player.currentPlayTime >= l.time && (this.event(a.Event.LABEL, l), 
                            this._eventIndex++, this._playAudio && l.audioValue && "null" !== l.audioValue && "undefined" !== l.audioValue && (s = a.SoundManager.playSound(this._player.templet._path + l.audioValue, 1, a.Handler.create(this, this._onAniSoundStoped)), 
                            a.SoundManager.playbackRate = this._player.playbackRate, s && this._soundChannelArr.push(s))) : l.time < this._player.playStart && this._playAudio && l.audioValue && "null" !== l.audioValue && "undefined" !== l.audioValue ? (this._eventIndex++, 
                            s = a.SoundManager.playSound(this._player.templet._path + l.audioValue, 1, a.Handler.create(this, this._onAniSoundStoped), null, (this._player.currentPlayTime - l.time) / 1e3), 
                            a.SoundManager.playbackRate = this._player.playbackRate, s && this._soundChannelArr.push(s)) : this._eventIndex++;
                        }
                        0 == this._aniMode ? (n = this._templet.getGrahicsDataWithCache(this._aniClipIndex, this._clipIndex) || this._createGraphics()) && this.graphics != n && (this.graphics = n) : 1 == this._aniMode ? (n = this._getGrahicsDataWithCache(this._aniClipIndex, this._clipIndex) || this._createGraphics()) && this.graphics != n && (this.graphics = n) : this._createGraphics();
                    }
                }
            }
        }, {
            key: "_onAniSoundStoped",
            value: function(t) {
                for (var e, i = this._soundChannelArr.length, a = 0; a < i; a++) ((e = this._soundChannelArr[a]).isStopped || t) && (!e.isStopped && e.stop(), 
                this._soundChannelArr.splice(a, 1), i--, a--);
            }
        }, {
            key: "_createGraphics",
            value: function() {
                var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : -1;
                -1 == t && (t = this._clipIndex);
                var e, i = t * this._player.cacheFrameRateInterval, r = this._templet.drawOrderAniArr[this._aniClipIndex];
                if (r && r.length > 0) for (this._drawOrderIndex = 0, e = r[this._drawOrderIndex]; i >= e.time && (this._drawOrder = e.drawOrder, 
                this._drawOrderIndex++, !(this._drawOrderIndex >= r.length)); ) e = r[this._drawOrderIndex];
                0 == this._aniMode || 1 == this._aniMode ? this.graphics = v.create() : this.graphics instanceof v ? this.graphics.clear() : this.graphics = v.create();
                var s = this.graphics, n = this._templet.getNodes(this._aniClipIndex), h = 0 == this._player.state;
                this._templet.getOriginalData(this._aniClipIndex, this._curOriginalData, null, t, h ? i + this._player.cacheFrameRateInterval : i);
                var l, o, u, c, d = this._aniSectionDic[this._aniClipIndex], _ = 0, p = 0, f = 0, y = 0, m = 0, g = this._templet.srcBoneMatrixArr.length, x = this._curOriginalData;
                for (p = 0, m = d[0]; p < g; p++) {
                    var M = (c = this._boneList[p]).resultTransform;
                    u = this._templet.srcBoneMatrixArr[p], M.scX = u.scX * x[_++], M.skX = u.skX + x[_++], 
                    M.skY = u.skY + x[_++], M.scY = u.scY * x[_++], M.x = u.x + x[_++], M.y = u.y + x[_++], 
                    8 === this._templet.tMatrixDataLen && (M.skewX = u.skewX + x[_++], M.skewY = u.skewY + x[_++]);
                }
                var D, k = {}, I = {};
                for (m += d[1]; p < m; p++) k[(D = n[p]).name] = x[_++], I[D.name] = x[_++], _ += 4;
                var A, T, S = {}, b = {};
                for (m += d[2]; p < m; p++) S[(D = n[p]).name] = x[_++], b[D.name] = x[_++], _ += 4;
                if (this._pathDic) for (m += d[3]; p < m; p++) if (D = n[p], A = this._pathDic[D.name]) switch (new a.Byte(D.extenData).getByte()) {
                  case 1:
                    A.position = x[_++];
                    break;

                  case 2:
                    A.spacing = x[_++];
                    break;

                  case 3:
                    A.rotateMix = x[_++], A.translateMix = x[_++];
                }
                if (this._rootBone.update(this._yReverseMatrix || a.Matrix.TEMP.identity()), this._ikArr) for (p = 0, 
                m = this._ikArr.length; p < m; p++) (T = this._ikArr[p]).name in S && (T.bendDirection = S[T.name]), 
                T.name in b && (T.mix = b[T.name]), T.apply();
                if (this._pathDic) for (var C in this._pathDic) (A = this._pathDic[C]).apply(this._boneList, s);
                if (this._tfArr) for (p = 0, y = this._tfArr.length; p < y; p++) this._tfArr[p].apply();
                for (p = 0, y = this._boneList.length; p < y; p++) if (c = this._boneList[p], o = this._bindBoneBoneSlotDic[c.name], 
                c.resultMatrix.copyTo(this._boneMatrixArray[p]), o) for (f = 0, m = o.length; f < m; f++) (l = o[f]) && l.setParentMatrix(c.resultMatrix);
                var F, w, P, L, U = {}, B = this._templet.deformAniArr;
                if (B && B.length > 0) {
                    if (this._lastAniClipIndex != this._aniClipIndex) for (this._lastAniClipIndex = this._aniClipIndex, 
                    p = 0, m = this._boneSlotArray.length; p < m; p++) (l = this._boneSlotArray[p]).deformData = null;
                    var E, R = B[this._aniClipIndex];
                    for (E in F = R.default, this._setDeform(F, U, this._boneSlotArray, i), R) "default" != E && E != this._skinName && (F = R[E], 
                    this._setDeform(F, U, this._boneSlotArray, i));
                    F = R[this._skinName], this._setDeform(F, U, this._boneSlotArray, i);
                }
                if (this._drawOrder) for (p = 0, m = this._drawOrder.length; p < m; p++) w = k[(l = this._boneSlotArray[this._drawOrder[p]]).name], 
                P = I[l.name], isNaN(w) || -2 == w || (this._templet.attachmentNames ? l.showDisplayByName(this._templet.attachmentNames[w]) : l.showDisplayByIndex(w)), 
                U[this._drawOrder[p]] ? (L = U[this._drawOrder[p]], l.currDisplayData && L[l.currDisplayData.attachmentName] ? l.deformData = L[l.currDisplayData.attachmentName] : l.deformData = null) : l.deformData = null, 
                isNaN(P) ? l.draw(s, this._boneMatrixArray, 2 == this._aniMode) : l.draw(s, this._boneMatrixArray, 2 == this._aniMode, P); else for (p = 0, 
                m = this._boneSlotArray.length; p < m; p++) w = k[(l = this._boneSlotArray[p]).name], 
                P = I[l.name], isNaN(w) || -2 == w || (this._templet.attachmentNames ? l.showDisplayByName(this._templet.attachmentNames[w]) : l.showDisplayByIndex(w)), 
                U[p] ? (L = U[p], l.currDisplayData && L[l.currDisplayData.attachmentName] ? l.deformData = L[l.currDisplayData.attachmentName] : l.deformData = null) : l.deformData = null, 
                isNaN(P) ? l.draw(s, this._boneMatrixArray, 2 == this._aniMode) : l.draw(s, this._boneMatrixArray, 2 == this._aniMode, P);
                return 0 == this._aniMode ? (this._templet.setGrahicsDataWithCache(this._aniClipIndex, t, s), 
                this._checkIsAllParsed(this._aniClipIndex)) : 1 == this._aniMode && this._setGrahicsDataWithCache(this._aniClipIndex, t, s), 
                s;
            }
        }, {
            key: "_checkIsAllParsed",
            value: function(t) {
                var e, i;
                for (i = Math.floor(.01 + this._templet.getAniDuration(t) / 1e3 * this._player.cacheFrameRate), 
                e = 0; e < i; e++) if (!this._templet.getGrahicsDataWithCache(t, e)) return;
                this._templet.getGrahicsDataWithCache(t, i) ? this._templet.deleteAniData(t) : this._createGraphics(i);
            }
        }, {
            key: "_setDeform",
            value: function(t, e, i, a) {
                var r, s, n, h, l, o;
                if (t && t) for (h = 0, l = t.deformSlotDataList.length; h < l; h++) for (r = t.deformSlotDataList[h], 
                o = 0; o < r.deformSlotDisplayList.length; o++) n = i[(s = r.deformSlotDisplayList[o]).slotIndex], 
                s.apply(a, n), e[s.slotIndex] || (e[s.slotIndex] = {}), e[s.slotIndex][s.attachment] = s.deformData;
            }
        }, {
            key: "getAnimNum",
            value: function() {
                return this._templet.getAnimationCount();
            }
        }, {
            key: "getAniNameByIndex",
            value: function(t) {
                return this._templet.getAniNameByIndex(t);
            }
        }, {
            key: "getSlotByName",
            value: function(t) {
                return this._boneSlotDic[t];
            }
        }, {
            key: "showSkinByName",
            value: function(t) {
                var e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
                this.showSkinByIndex(this._templet.getSkinIndexByName(t), e);
            }
        }, {
            key: "showSkinByIndex",
            value: function(t) {
                for (var e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i = 0; i < this._boneSlotArray.length; i++) this._boneSlotArray[i].showSlotData(null, e);
                if (this._templet.showSkinByIndex(this._boneSlotDic, t, e)) {
                    var a = this._templet.skinDataArray[t];
                    this._skinIndex = t, this._skinName = a.name;
                }
                this._clearCache();
            }
        }, {
            key: "showSlotSkinByIndex",
            value: function(t, e) {
                if (0 != this._aniMode) {
                    var i = this.getSlotByName(t);
                    i && i.showDisplayByIndex(e), this._clearCache();
                }
            }
        }, {
            key: "showSlotSkinByName",
            value: function(t, e) {
                if (0 != this._aniMode) {
                    var i = this.getSlotByName(t);
                    i && i.showDisplayByName(e), this._clearCache();
                }
            }
        }, {
            key: "replaceSlotSkinName",
            value: function(t, e, i) {
                if (0 != this._aniMode) {
                    var a = this.getSlotByName(t);
                    a && a.replaceDisplayByName(e, i), this._clearCache();
                }
            }
        }, {
            key: "replaceSlotSkinByIndex",
            value: function(t, e, i) {
                if (0 != this._aniMode) {
                    var a = this.getSlotByName(t);
                    a && a.replaceDisplayByIndex(e, i), this._clearCache();
                }
            }
        }, {
            key: "setSlotSkin",
            value: function(t, e) {
                if (0 != this._aniMode) {
                    var i = this.getSlotByName(t);
                    i && i.replaceSkin(e), this._clearCache();
                }
            }
        }, {
            key: "_clearCache",
            value: function() {
                if (1 == this._aniMode) for (var t = 0, e = this._graphicsCache.length; t < e; t++) {
                    for (var i = 0, a = this._graphicsCache[t].length; i < a; i++) {
                        var r = this._graphicsCache[t][i];
                        r && r != this.graphics && v.recycle(r);
                    }
                    this._graphicsCache[t].length = 0;
                }
            }
        }, {
            key: "play",
            value: function(t, e) {
                var i = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2], r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0, s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0, n = !(arguments.length > 5 && void 0 !== arguments[5]) || arguments[5], h = !(arguments.length > 6 && void 0 !== arguments[6]) || arguments[6];
                this._playAudio = h, this._indexControl = !1;
                var l, o = -1;
                if (l = e ? 2147483647 : 0, "string" == typeof t) for (var u = 0, c = this._templet.getAnimationCount(); u < c; u++) {
                    var d = this._templet.getAnimation(u);
                    if (d && t == d.name) {
                        o = u;
                        break;
                    }
                } else o = t;
                o > -1 && o < this.getAnimNum() && (this._aniClipIndex = o, (i || this._pause || this._currAniIndex != o) && (this._currAniIndex = o, 
                this._curOriginalData = new Float32Array(this._templet.getTotalkeyframesLength(o)), 
                this._drawOrder = null, this._eventIndex = 0, this._player.play(o, this._player.playbackRate, l, r, s), 
                n && this._templet.showSkinByIndex(this._boneSlotDic, this._skinIndex), this._pause && (this._pause = !1, 
                this._lastTime = a.ILaya.Browser.now(), this.timer.frameLoop(1, this, this._update, null, !0)), 
                this._update()));
            }
        }, {
            key: "stop",
            value: function() {
                this._pause || (this._pause = !0, this._player && this._player.stop(!0), this._soundChannelArr.length > 0 && this._onAniSoundStoped(!0), 
                this.timer.clear(this, this._update));
            }
        }, {
            key: "playbackRate",
            value: function(t) {
                this._player && (this._player.playbackRate = t);
            }
        }, {
            key: "paused",
            value: function() {
                if (!this._pause) {
                    if (this._pause = !0, this._player && (this._player.paused = !0), this._soundChannelArr.length > 0) for (var t, e = this._soundChannelArr.length, i = 0; i < e; i++) (t = this._soundChannelArr[i]).isStopped || t.pause();
                    this.timer.clear(this, this._update);
                }
            }
        }, {
            key: "resume",
            value: function() {
                if (this._indexControl = !1, this._pause) {
                    if (this._pause = !1, this._player && (this._player.paused = !1), this._soundChannelArr.length > 0) for (var t, e = this._soundChannelArr.length, i = 0; i < e; i++) (t = this._soundChannelArr[i]).audioBuffer && t.resume();
                    this._lastTime = a.ILaya.Browser.now(), this.timer.frameLoop(1, this, this._update, null, !0);
                }
            }
        }, {
            key: "_getGrahicsDataWithCache",
            value: function(t, e) {
                return this._graphicsCache[t][e];
            }
        }, {
            key: "_setGrahicsDataWithCache",
            value: function(t, e, i) {
                this._graphicsCache[t][e] = i;
            }
        }, {
            key: "destroy",
            value: function() {
                var t = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
                (0, i.default)((0, r.default)(u.prototype), "destroy", this).call(this, t), this._templet._removeReference(1), 
                this._templet = null, this._player && this._player.offAll(), this._player = null, 
                this._curOriginalData = null, this._boneMatrixArray.length = 0, this._lastTime = 0, 
                this.timer.clear(this, this._update), this._soundChannelArr.length > 0 && this._onAniSoundStoped(!0);
            }
        }, {
            key: "url",
            get: function() {
                return this._aniPath;
            },
            set: function(t) {
                this.load(t);
            }
        }, {
            key: "index",
            get: function() {
                return this._index;
            },
            set: function(t) {
                this.player && (this._index = t, this._player.currentTime = 1e3 * this._index / this._player.cacheFrameRate, 
                this._indexControl = !0, (this._aniClipIndex < 0 || this._aniClipIndex >= this.getAnimNum()) && (this._aniClipIndex = 0, 
                this._currAniIndex = 0, this._curOriginalData = new Float32Array(this._templet.getTotalkeyframesLength(this._currAniIndex)), 
                this._drawOrder = null, this._eventIndex = 0), this._update(!1));
            }
        }, {
            key: "total",
            get: function() {
                return this._templet && this._player ? this._total = Math.floor(this._templet.getAniDuration(this._player.currentAnimationClipIndex) / 1e3 * this._player.cacheFrameRate) : this._total = -1, 
                this._total;
            }
        }, {
            key: "player",
            get: function() {
                return this._player;
            }
        }, {
            key: "templet",
            get: function() {
                return this._templet;
            }
        } ]), u;
    }(a.Sprite);
    E.useSimpleMeshInCanvas = !1, o.Skeleton = E, a.ILaya.regClass(E), a.ClassUtils.regClass("laya.ani.bone.Skeleton", E), 
    a.ClassUtils.regClass("Laya.Skeleton", E);
    var R = function t() {
        (0, h.default)(this, t), this.slotArr = [];
    }, N = function() {
        function t() {
            (0, h.default)(this, t);
        }
        return (0, n.default)(t, [ {
            key: "createTexture",
            value: function(t) {
                return this.texture || (this.texture = new a.Texture(t.bitmap, this.uvs), this.uvs[0] > this.uvs[4] && this.uvs[1] > this.uvs[5] ? (this.texture.width = t.height, 
                this.texture.height = t.width, this.texture.offsetX = -t.offsetX, this.texture.offsetY = -t.offsetY, 
                this.texture.sourceWidth = t.sourceHeight, this.texture.sourceHeight = t.sourceWidth) : (this.texture.width = t.width, 
                this.texture.height = t.height, this.texture.offsetX = -t.offsetX, this.texture.offsetY = -t.offsetY, 
                this.texture.sourceWidth = t.sourceWidth, this.texture.sourceHeight = t.sourceHeight)), 
                this.texture;
            }
        }, {
            key: "destory",
            value: function() {
                this.texture && this.texture.destroy();
            }
        } ]), t;
    }(), O = function() {
        function t() {
            (0, h.default)(this, t), this.displayArr = [];
        }
        return (0, n.default)(t, [ {
            key: "getDisplayByName",
            value: function(t) {
                for (var e = 0, i = this.displayArr.length; e < i; e++) if (this.displayArr[e].attachmentName == t) return e;
                return -1;
            }
        } ]), t;
    }(), V = function t() {
        (0, h.default)(this, t), this.boneIndexs = [];
    }, Y = function(t) {
        (0, s.default)(o, t);
        var e = l(o);
        function o() {
            var t;
            return (0, h.default)(this, o), (t = e.apply(this, arguments))._graphicsCache = [], 
            t.srcBoneMatrixArr = [], t.ikArr = [], t.tfArr = [], t.pathArr = [], t.boneSlotDic = {}, 
            t.bindBoneBoneSlotDic = {}, t.boneSlotArray = [], t.skinDataArray = [], t.skinDic = {}, 
            t.subTextureDic = {}, t.isParseFail = !1, t.drawOrderAniArr = [], t.eventAniArr = [], 
            t.attachmentNames = null, t.deformAniArr = [], t.skinSlotDisplayDataArr = [], t._isParseAudio = !1, 
            t._isDestroyed = !1, t._rate = 30, t.isParserComplete = !1, t.aniSectionDic = {}, 
            t._textureDic = {}, t.mBoneArr = [], t;
        }
        return (0, n.default)(o, [ {
            key: "loadAni",
            value: function(t) {
                this._skBufferUrl = t, a.ILaya.loader.load(t, a.Handler.create(this, this.onComplete), null, a.ILaya.Loader.BUFFER);
            }
        }, {
            key: "onComplete",
            value: function() {
                if (this._isDestroyed) this.destroy(); else {
                    var t = a.ILaya.Loader.getRes(this._skBufferUrl);
                    t ? (this._path = this._skBufferUrl.slice(0, this._skBufferUrl.lastIndexOf("/")) + "/", 
                    this.parseData(null, t)) : this.event(a.Event.ERROR, "load failed:" + this._skBufferUrl);
                }
            }
        }, {
            key: "parseData",
            value: function(t, e) {
                var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 30;
                if (!this._path) {
                    var a = this._relativeUrl || this.url;
                    if (a) {
                        var r = a.lastIndexOf("/");
                        this._path = r > 0 ? a.slice(0, r) + "/" : "";
                    }
                }
                this._mainTexture = t, this._rate = i, this.parse(e);
            }
        }, {
            key: "buildArmature",
            value: function() {
                var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
                return new E(this, t);
            }
        }, {
            key: "parse",
            value: function(t) {
                (0, i.default)((0, r.default)(o.prototype), "parse", this).call(this, t), this.event(a.Event.LOADED, this), 
                this._aniVersion === o.LAYA_ANIMATION_VISION ? this._isParseAudio = !0 : this._aniVersion != o.LAYA_ANIMATION_160_VISION && console.log("[Error] 版本不一致，请使用IDE版本配套的重新导出" + this._aniVersion + "->" + o.LAYA_ANIMATION_VISION), 
                this._mainTexture ? this._parsePublicExtData() : this._parseTexturePath();
            }
        }, {
            key: "_parseTexturePath",
            value: function() {
                if (this._isDestroyed) this.destroy(); else {
                    var t = 0;
                    this._loadList = [];
                    var e, i = new a.Byte(this.getPublicExtData()), r = i.getInt32(), s = i.readUTFString(), n = s.split("\n");
                    for (t = 0; t < r; t++) e = this._path + n[2 * t], s = n[2 * t + 1], i.getFloat32(), 
                    i.getFloat32(), i.getFloat32(), i.getFloat32(), i.getFloat32(), i.getFloat32(), 
                    i.getFloat32(), i.getFloat32(), -1 == this._loadList.indexOf(e) && this._loadList.push(e);
                    a.ILaya.loader.load(this._loadList, a.Handler.create(this, this._textureComplete));
                }
            }
        }, {
            key: "_textureComplete",
            value: function() {
                for (var t, e = 0, i = this._loadList.length; e < i; e++) t = this._loadList[e], 
                this._textureDic[t] = a.ILaya.Loader.getRes(t);
                this._parsePublicExtData();
            }
        }, {
            key: "_parsePublicExtData",
            value: function() {
                var t, e = 0, i = 0, r = 0, s = 0, n = 0;
                for (e = 0, n = this.getAnimationCount(); e < n; e++) this._graphicsCache.push([]);
                t = "Dragon" != this._aniClassName;
                var h, l, o = new a.Byte(this.getPublicExtData()), u = 0, c = 0, d = 0, _ = 0, p = 0, f = 0, y = 0, m = 0, g = 0, v = o.getInt32(), D = o.readUTFString(), k = D.split("\n");
                for (e = 0; e < v; e++) {
                    if (h = this._mainTexture, l = this._path + k[2 * e], D = k[2 * e + 1], null == this._mainTexture && (h = this._textureDic[l]), 
                    !h) return this.event(a.Event.ERROR, this), void (this.isParseFail = !0);
                    u = o.getFloat32(), c = o.getFloat32(), d = o.getFloat32(), _ = o.getFloat32(), 
                    g = o.getFloat32(), p = isNaN(g) ? 0 : g, g = o.getFloat32(), f = isNaN(g) ? 0 : g, 
                    g = o.getFloat32(), y = isNaN(g) ? d : g, g = o.getFloat32(), m = isNaN(g) ? _ : g, 
                    this.subTextureDic[D] = a.Texture.create(h, u, c, d, _, -p, -f, y, m);
                }
                this._mainTexture = h;
                var I, w, L, B, E, Y = o.getUint16();
                for (e = 0; e < Y; e++) (I = []).push(o.getUint16()), I.push(o.getUint16()), I.push(o.getUint16()), 
                I.push(o.getUint16()), this.aniSectionDic[e] = I;
                var K, X = o.getInt16(), W = {};
                for (e = 0; e < X; e++) w = new M(), 0 == e ? K = w : w.root = K, w.d = t ? -1 : 1, 
                B = o.readUTFString(), E = o.readUTFString(), w.length = o.getFloat32(), 1 == o.getByte() && (w.inheritRotation = !1), 
                1 == o.getByte() && (w.inheritScale = !1), w.name = B, E && ((L = W[E]) ? L.addChild(w) : this.mRootBone = w), 
                W[B] = w, this.mBoneArr.push(w);
                this.tMatrixDataLen = o.getUint16();
                var q, z, G = o.getUint16(), H = Math.floor(G / this.tMatrixDataLen), Q = this.srcBoneMatrixArr;
                for (e = 0; e < H; e++) (q = new x()).scX = o.getFloat32(), q.skX = o.getFloat32(), 
                q.skY = o.getFloat32(), q.scY = o.getFloat32(), q.x = o.getFloat32(), q.y = o.getFloat32(), 
                8 === this.tMatrixDataLen && (q.skewX = o.getFloat32(), q.skewY = o.getFloat32()), 
                Q.push(q), (w = this.mBoneArr[e]).transform = q;
                var Z, j, J = o.getUint16();
                for (e = 0; e < J; e++) {
                    for (z = new P(), Z = o.getUint16(), i = 0; i < Z; i++) z.boneNames.push(o.readUTFString()), 
                    z.boneIndexs.push(o.getInt16());
                    z.name = o.readUTFString(), z.targetBoneName = o.readUTFString(), z.targetBoneIndex = o.getInt16(), 
                    z.bendDirection = o.getFloat32(), z.mix = o.getFloat32(), z.isSpine = t, this.ikArr.push(z);
                }
                var $, tt, et = o.getUint16();
                for (e = 0; e < et; e++) {
                    for (j = new V(), $ = o.getUint16(), i = 0; i < $; i++) j.boneIndexs.push(o.getInt16());
                    j.name = o.getUTFString(), j.targetIndex = o.getInt16(), j.rotateMix = o.getFloat32(), 
                    j.translateMix = o.getFloat32(), j.scaleMix = o.getFloat32(), j.shearMix = o.getFloat32(), 
                    j.offsetRotation = o.getFloat32(), j.offsetX = o.getFloat32(), j.offsetY = o.getFloat32(), 
                    j.offsetScaleX = o.getFloat32(), j.offsetScaleY = o.getFloat32(), j.offsetShearY = o.getFloat32(), 
                    this.tfArr.push(j);
                }
                var it, at, rt, st, nt, ht, lt, ot, ut, ct, dt = o.getUint16();
                for (e = 0; e < dt; e++) {
                    for ((tt = new U()).name = o.readUTFString(), it = o.getUint16(), i = 0; i < it; i++) tt.bones.push(o.getInt16());
                    tt.target = o.readUTFString(), tt.positionMode = o.readUTFString(), tt.spacingMode = o.readUTFString(), 
                    tt.rotateMode = o.readUTFString(), tt.offsetRotation = o.getFloat32(), tt.position = o.getFloat32(), 
                    tt.spacing = o.getFloat32(), tt.rotateMix = o.getFloat32(), tt.translateMix = o.getFloat32(), 
                    this.pathArr.push(tt);
                }
                var _t, pt = o.getInt16();
                for (e = 0; e < pt; e++) {
                    var ft = o.getUint8(), yt = {};
                    this.deformAniArr.push(yt);
                    for (var mt = 0; mt < ft; mt++) for ((lt = new T()).skinName = o.getUTFString(), 
                    yt[lt.skinName] = lt, at = o.getInt16(), i = 0; i < at; i++) for (ot = new S(), 
                    lt.deformSlotDataList.push(ot), rt = o.getInt16(), r = 0; r < rt; r++) for (ut = new b(), 
                    ot.deformSlotDisplayList.push(ut), ut.slotIndex = o.getInt16(), ut.attachment = o.getUTFString(), 
                    st = o.getInt16(), s = 0; s < st; s++) for (1 == o.getByte() ? ut.tweenKeyList.push(!0) : ut.tweenKeyList.push(!1), 
                    nt = o.getFloat32(), ut.timeList.push(nt), ct = [], ut.vectices.push(ct), ht = o.getInt16(), 
                    n = 0; n < ht; n++) ct.push(o.getFloat32());
                }
                var gt, vt, xt, Mt, Dt = o.getInt16();
                for (e = 0; e < Dt; e++) {
                    for (gt = o.getInt16(), _t = [], i = 0; i < gt; i++) {
                        for ((vt = new C()).time = o.getFloat32(), xt = o.getInt16(), r = 0; r < xt; r++) vt.drawOrder.push(o.getInt16());
                        _t.push(vt);
                    }
                    this.drawOrderAniArr.push(_t);
                }
                var kt, It, At = o.getInt16();
                for (e = 0; e < At; e++) {
                    for (kt = o.getInt16(), Mt = [], i = 0; i < kt; i++) (It = new F()).name = o.getUTFString(), 
                    this._isParseAudio && (It.audioValue = o.getUTFString()), It.intValue = o.getInt32(), 
                    It.floatValue = o.getFloat32(), It.stringValue = o.getUTFString(), It.time = o.getFloat32(), 
                    Mt.push(It);
                    this.eventAniArr.push(Mt);
                }
                var Tt = o.getInt16();
                if (Tt > 0) for (this.attachmentNames = [], e = 0; e < Tt; e++) this.attachmentNames.push(o.getUTFString());
                var St, bt, Ct = o.getInt16();
                for (e = 0; e < Ct; e++) (St = new A()).name = o.readUTFString(), St.parent = o.readUTFString(), 
                St.attachmentName = o.readUTFString(), St.srcDisplayIndex = St.displayIndex = o.getInt16(), 
                St.templet = this, this.boneSlotDic[St.name] = St, null == (bt = this.bindBoneBoneSlotDic[St.parent]) && (this.bindBoneBoneSlotDic[St.parent] = bt = []), 
                bt.push(St), this.boneSlotArray.push(St);
                var Ft, wt, Pt, Lt, Ut, Bt, Et, Rt, Nt, Ot, Vt = o.readUTFString().split("\n"), Yt = 0, Kt = o.getUint8();
                for (e = 0; e < Kt; e++) {
                    for ((Ft = new R()).name = Vt[Yt++], Lt = o.getUint8(), i = 0; i < Lt; i++) {
                        for ((wt = new O()).name = Vt[Yt++], St = this.boneSlotDic[wt.name], Ut = o.getUint8(), 
                        r = 0; r < Ut; r++) {
                            if (Pt = new N(), this.skinSlotDisplayDataArr.push(Pt), Pt.name = Vt[Yt++], Pt.attachmentName = Vt[Yt++], 
                            Pt.transform = new x(), Pt.transform.scX = o.getFloat32(), Pt.transform.skX = o.getFloat32(), 
                            Pt.transform.skY = o.getFloat32(), Pt.transform.scY = o.getFloat32(), Pt.transform.x = o.getFloat32(), 
                            Pt.transform.y = o.getFloat32(), wt.displayArr.push(Pt), Pt.width = o.getFloat32(), 
                            Pt.height = o.getFloat32(), Pt.type = o.getUint8(), Pt.verLen = o.getUint16(), (X = o.getUint16()) > 0) for (Pt.bones = [], 
                            s = 0; s < X; s++) {
                                var Xt = o.getUint16();
                                Pt.bones.push(Xt);
                            }
                            if ((Bt = o.getUint16()) > 0) for (Pt.uvs = [], s = 0; s < Bt; s++) Pt.uvs.push(o.getFloat32());
                            if ((Et = o.getUint16()) > 0) for (Pt.weights = [], s = 0; s < Et; s++) Pt.weights.push(o.getFloat32());
                            if ((Rt = o.getUint16()) > 0) for (Pt.triangles = [], s = 0; s < Rt; s++) Pt.triangles.push(o.getUint16());
                            if ((Nt = o.getUint16()) > 0) for (Pt.vertices = [], s = 0; s < Nt; s++) Pt.vertices.push(o.getFloat32());
                            if ((Ot = o.getUint16()) > 0) for (Pt.lengths = [], s = 0; s < Ot; s++) Pt.lengths.push(o.getFloat32());
                        }
                        Ft.slotArr.push(wt);
                    }
                    this.skinDic[Ft.name] = Ft, this.skinDataArray.push(Ft);
                }
                1 == o.getUint8() ? (this.yReverseMatrix = new a.Matrix(1, 0, 0, -1, 0, 0), K && K.setTempMatrix(this.yReverseMatrix)) : K && K.setTempMatrix(new a.Matrix()), 
                this.showSkinByIndex(this.boneSlotDic, 0), this.isParserComplete = !0, this.event(a.Event.COMPLETE, this);
            }
        }, {
            key: "getTexture",
            value: function(t) {
                var e = this.subTextureDic[t];
                return e || (e = this.subTextureDic[t.substr(0, t.length - 1)]), null == e ? this._mainTexture : e;
            }
        }, {
            key: "showSkinByIndex",
            value: function(t, e) {
                var i = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
                if (e < 0 && e >= this.skinDataArray.length) return !1;
                var a, r, s, n, h = this.skinDataArray[e];
                if (h) {
                    for (a = 0, r = h.slotArr.length; a < r; a++) (n = h.slotArr[a]) && (s = t[n.name]) && (s.showSlotData(n, i), 
                    i && "undefined" != s.attachmentName && "null" != s.attachmentName ? s.showDisplayByName(s.attachmentName) : s.showDisplayByIndex(s.displayIndex));
                    return !0;
                }
                return !1;
            }
        }, {
            key: "getSkinIndexByName",
            value: function(t) {
                for (var e = 0, i = this.skinDataArray.length; e < i; e++) if (this.skinDataArray[e].name == t) return e;
                return -1;
            }
        }, {
            key: "getGrahicsDataWithCache",
            value: function(t, e) {
                return this._graphicsCache[t] && this._graphicsCache[t][e] ? this._graphicsCache[t][e] : null;
            }
        }, {
            key: "_setCreateURL",
            value: function(t) {
                this._skBufferUrl = this._relativeUrl = t, (0, i.default)((0, r.default)(o.prototype), "_setCreateURL", this).call(this, t);
            }
        }, {
            key: "setGrahicsDataWithCache",
            value: function(t, e, i) {
                this._graphicsCache[t][e] = i;
            }
        }, {
            key: "deleteAniData",
            value: function(t) {
                if (this._anis[t]) {
                    var e = this._anis[t];
                    e.bone3DMap = null, e.nodes = null;
                }
            }
        }, {
            key: "destroy",
            value: function() {
                var t;
                for (t in this._isDestroyed = !0, this.subTextureDic) t && this.subTextureDic[t].destroy();
                for (t in this._textureDic) t && this._textureDic[t].destroy();
                for (var e = 0, s = this.skinSlotDisplayDataArr.length; e < s; e++) this.skinSlotDisplayDataArr[e].destory();
                this.skinSlotDisplayDataArr.length = 0, this._relativeUrl && delete o.TEMPLET_DICTIONARY[this._relativeUrl], 
                (0, i.default)((0, r.default)(o.prototype), "destroy", this).call(this), a.ILaya.loader.clearRes(this._skBufferUrl);
            }
        }, {
            key: "getAniNameByIndex",
            value: function(t) {
                var e = this.getAnimation(t);
                return e ? e.name : null;
            }
        }, {
            key: "rate",
            get: function() {
                return this._rate;
            },
            set: function(t) {
                this._rate = t;
            }
        } ]), o;
    }(g);
    Y.LAYA_ANIMATION_160_VISION = "LAYAANIMATION:1.6.0", Y.LAYA_ANIMATION_VISION = "LAYAANIMATION:1.7.0", 
    o.Templet = Y;
    var K = function(t) {
        (0, s.default)(u, t);
        var o = l(u);
        function u() {
            var t, i = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
            return (0, h.default)(this, u), (t = o.call(this))._start = 0, t._Pos = 0, t._ended = !0, 
            t._loadedImage = {}, t._endFrame = -1, t.interval = 30, t._ids = {}, t._idOfSprite = [], 
            t._reset(), t._playing = !1, t._parentMovieClip = i, i ? (t._isRoot = !1, t._movieClipList = i._movieClipList, 
            t._movieClipList.push((0, e.default)(t))) : (t._movieClipList = [ (0, e.default)(t) ], 
            t._isRoot = !0, t._setBitUp(a.Const.DISPLAY)), t;
        }
        return (0, n.default)(u, [ {
            key: "destroy",
            value: function() {
                var t = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
                this._clear(), (0, i.default)((0, r.default)(u.prototype), "destroy", this).call(this, t);
            }
        }, {
            key: "_setDisplay",
            value: function(t) {
                (0, i.default)((0, r.default)(u.prototype), "_setDisplay", this).call(this, t), 
                this._isRoot && this._onDisplay(t);
            }
        }, {
            key: "_onDisplay",
            value: function(t) {
                t ? this.timer.loop(this.interval, this, this.updates, null, !0) : this.timer.clear(this, this.updates);
            }
        }, {
            key: "updates",
            value: function() {
                var t, e;
                if (!this._parentMovieClip) for (e = this._movieClipList.length, t = 0; t < e; t++) this._movieClipList[t] && this._movieClipList[t]._update();
            }
        }, {
            key: "addLabel",
            value: function(t, e) {
                this._labels || (this._labels = {}), this._labels[e] = t;
            }
        }, {
            key: "removeLabel",
            value: function(t) {
                if (t) {
                    if (!this._labels) for (var e in this._labels) if (this._labels[e] === t) {
                        delete this._labels[e];
                        break;
                    }
                } else this._labels = null;
            }
        }, {
            key: "_update",
            value: function() {
                if (this._data && this._playing) {
                    if (this._playIndex++, this._playIndex >= this._count) {
                        if (!this.loop) return this._playIndex--, void this.stop();
                        this._playIndex = 0;
                    }
                    if (this._parseFrame(this._playIndex), this._labels && this._labels[this._playIndex] && this.event(a.Event.LABEL, this._labels[this._playIndex]), 
                    -1 != this._endFrame && this._endFrame == this._playIndex) {
                        if (this._endFrame = -1, null != this._completeHandler) {
                            var t = this._completeHandler;
                            this._completeHandler = null, t.run();
                        }
                        this.stop();
                    }
                }
            }
        }, {
            key: "stop",
            value: function() {
                this._playing = !1;
            }
        }, {
            key: "gotoAndStop",
            value: function(t) {
                this.index = t, this.stop();
            }
        }, {
            key: "_clear",
            value: function() {
                if (this.stop(), this._idOfSprite.length = 0, !this._parentMovieClip) {
                    var t, e;
                    for (this.timer.clear(this, this.updates), e = this._movieClipList.length, t = 0; t < e; t++) this._movieClipList[t] != this && this._movieClipList[t]._clear();
                    this._movieClipList.length = 0;
                }
                var i;
                for (i in this._atlasPath && a.ILaya.Loader.clearRes(this._atlasPath), this._loadedImage) this._loadedImage[i] && (a.ILaya.Loader.clearRes(i), 
                this._loadedImage[i] = !1);
                this.removeChildren(), this.graphics = null, this._parentMovieClip = null;
            }
        }, {
            key: "play",
            value: function() {
                var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
                this.loop = e, this._playing = !0, this._data && this._displayFrame(t);
            }
        }, {
            key: "_displayFrame",
            value: function() {
                var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : -1;
                -1 != t && (this._curIndex > t && this._reset(), this._parseFrame(t));
            }
        }, {
            key: "_reset",
            value: function() {
                var t = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
                t && 1 != this._curIndex && this.removeChildren(), this._preIndex = this._curIndex = -1, 
                this._Pos = this._start;
            }
        }, {
            key: "_parseFrame",
            value: function(t) {
                var e, i, r, s, n, h, l = !1, o = this._idOfSprite, c = this._data;
                for (this._ended && this._reset(), c.pos = this._Pos, this._ended = !1, this._playIndex = t, 
                this._curIndex > t && t < this._preIndex && (this._reset(!0), c.pos = this._Pos); this._curIndex <= t && !this._ended; ) switch (c.getUint16()) {
                  case 12:
                    if (r = c.getUint16(), s = this._ids[c.getUint16()], this._Pos = c.pos, c.pos = s, 
                    0 == (n = c.getUint8())) {
                        var d = c.getUint16();
                        if (!(i = o[r])) {
                            i = o[r] = new a.Sprite();
                            var _ = new a.Sprite();
                            _.loadImage(this.basePath + d + ".png"), this._loadedImage[this.basePath + d + ".png"] = !0, 
                            i.addChild(_), _.size(c.getFloat32(), c.getFloat32());
                            var p = c._getMatrix();
                            _.transform = p;
                        }
                        i.alpha = 1;
                    } else 1 == n && ((e = o[r]) || (o[r] = e = new u(this), e.interval = this.interval, 
                    e._ids = this._ids, e.basePath = this.basePath, e._setData(c, s), e._initState(), 
                    e.play(0)), e.alpha = 1);
                    c.pos = this._Pos;
                    break;

                  case 3:
                    var f = o[c.getUint16()];
                    f && (this.addChild(f), f.zOrder = c.getUint16(), l = !0);
                    break;

                  case 4:
                    (f = o[c.getUint16()]) && f.removeSelf();
                    break;

                  case 5:
                    o[c.getUint16()][u._ValueList[c.getUint16()]] = c.getFloat32();
                    break;

                  case 6:
                    o[c.getUint16()].visible = c.getUint8() > 0;
                    break;

                  case 7:
                    var y = (i = o[c.getUint16()]).transform || a.Matrix.create();
                    y.setTo(c.getFloat32(), c.getFloat32(), c.getFloat32(), c.getFloat32(), c.getFloat32(), c.getFloat32()), 
                    i.transform = y;
                    break;

                  case 8:
                    o[c.getUint16()].setPos(c.getFloat32(), c.getFloat32());
                    break;

                  case 9:
                    o[c.getUint16()].setSize(c.getFloat32(), c.getFloat32());
                    break;

                  case 10:
                    o[c.getUint16()].alpha = c.getFloat32();
                    break;

                  case 11:
                    o[c.getUint16()].setScale(c.getFloat32(), c.getFloat32());
                    break;

                  case 98:
                    h = c.getString(), this.event(h), "stop" == h && this.stop();
                    break;

                  case 99:
                    this._curIndex = c.getUint16(), l && this.updateZOrder();
                    break;

                  case 100:
                    this._count = this._curIndex + 1, this._ended = !0, this._playing && (this.event(a.Event.FRAME), 
                    this.event(a.Event.END), this.event(a.Event.COMPLETE)), this._reset(!1);
                }
                this._playing && !this._ended && this.event(a.Event.FRAME), this._Pos = c.pos;
            }
        }, {
            key: "_setData",
            value: function(t, e) {
                this._data = t, this._start = e + 3;
            }
        }, {
            key: "load",
            value: function(t) {
                var e, i = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
                this._url = t, i && (this._atlasPath = r || t.split(".swf")[0] + ".json"), this.stop(), 
                this._clear(), this._movieClipList = [ this ], e = [ {
                    url: t,
                    type: a.ILaya.Loader.BUFFER
                } ], this._atlasPath && e.push({
                    url: this._atlasPath,
                    type: a.ILaya.Loader.ATLAS
                }), a.ILaya.loader.load(e, a.Handler.create(this, this._onLoaded));
            }
        }, {
            key: "_onLoaded",
            value: function() {
                var t;
                (t = a.ILaya.Loader.getRes(this._url)) ? !this._atlasPath || a.ILaya.Loader.getAtlas(this._atlasPath) ? (this.basePath = this._atlasPath ? a.ILaya.Loader.getAtlas(this._atlasPath).dir : this._url.split(".swf")[0] + "/image/", 
                this._initData(t)) : this.event(a.Event.ERROR, "Atlas not find") : this.event(a.Event.ERROR, "file not find");
            }
        }, {
            key: "_initState",
            value: function() {
                this._reset(), this._ended = !1;
                var t = this._playing;
                for (this._playing = !1, this._curIndex = 0; !this._ended; ) this._parseFrame(++this._curIndex);
                this._playing = t;
            }
        }, {
            key: "_initData",
            value: function(t) {
                this._data = new a.Byte(t);
                var e, i = this._data.getUint16();
                for (e = 0; e < i; e++) this._ids[this._data.getInt16()] = this._data.getInt32();
                this.interval = 1e3 / this._data.getUint16(), this._setData(this._data, this._ids[32767]), 
                this._initState(), this.play(0), this.event(a.Event.LOADED), this._parentMovieClip || this.timer.loop(this.interval, this, this.updates, null, !0);
            }
        }, {
            key: "playTo",
            value: function(t, e) {
                var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
                this._completeHandler = i, this._endFrame = e, this.play(t, !1);
            }
        }, {
            key: "index",
            get: function() {
                return this._playIndex;
            },
            set: function(t) {
                this._playIndex = t, this._data && this._displayFrame(this._playIndex), this._labels && this._labels[t] && this.event(a.Event.LABEL, this._labels[t]);
            }
        }, {
            key: "count",
            get: function() {
                return this._count;
            }
        }, {
            key: "playing",
            get: function() {
                return this._playing;
            }
        }, {
            key: "url",
            set: function(t) {
                this.load(t);
            }
        } ]), u;
    }(a.Sprite);
    K._ValueList = [ "x", "y", "width", "height", "scaleX", "scaleY", "rotation", "alpha" ], 
    t.AnimationContent = u, t.AnimationNodeContent = c, t.AnimationParser01 = _, t.AnimationParser02 = p, 
    t.AnimationPlayer = y, t.AnimationState = f, t.AnimationTemplet = g, t.BezierLerp = m, 
    t.Bone = M, t.BoneSlot = A, t.DeformAniData = T, t.DeformSlotData = S, t.DeformSlotDisplayData = b, 
    t.DrawOrderData = C, t.EventData = F, t.GraphicsAni = v, t.IAniLib = o, t.IkConstraint = w, 
    t.IkConstraintData = P, t.KeyFramesContent = d, t.MeshData = k, t.MovieClip = K, 
    t.PathConstraint = L, t.PathConstraintData = U, t.Skeleton = E, t.SkinData = R, 
    t.SkinMeshForGraphic = I, t.SkinSlotDisplayData = N, t.SlotData = O, t.Templet = Y, 
    t.TfConstraint = B, t.TfConstraintData = V, t.Transform = x, t.UVTools = D;
}(window.Laya = window.Laya || {}, Laya);