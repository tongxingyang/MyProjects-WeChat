var e = require("../../@babel/runtime/helpers/possibleConstructorReturn"), t = require("../../@babel/runtime/helpers/assertThisInitialized"), n = require("../../@babel/runtime/helpers/get"), i = require("../../@babel/runtime/helpers/getPrototypeOf"), s = require("../../@babel/runtime/helpers/classCallCheck"), a = require("../../@babel/runtime/helpers/createClass"), r = require("../../@babel/runtime/helpers/inherits"), l = require("../../@babel/runtime/helpers/createSuper");

!function(o, h) {
    var u = function(e) {
        r(n, e);
        var t = l(n);
        function n(e) {
            return s(this, n), t.call(this, e);
        }
        return a(n, [ {
            key: "getImage",
            value: function() {
                return {
                    width: this.sourceWidth,
                    height: this.sourceHeight
                };
            }
        }, {
            key: "setFilters",
            value: function(e, t) {}
        }, {
            key: "setWraps",
            value: function(e, t) {}
        } ]), n;
    }(h.Texture), p = function(e) {
        r(n, e);
        var t = l(n);
        function n() {
            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "", i = arguments.length > 1 ? arguments[1] : void 0, a = arguments.length > 2 ? arguments[2] : void 0;
            return s(this, n), t.call(this, function(e, t) {
                return a[t] = new u(e.bitmap);
            }, e, i);
        }
        return n;
    }(spine.AssetManager), c = spine.Color, d = spine.SkeletonClipping, m = spine.Vector2, v = spine.Utils, y = spine.RegionAttachment, f = spine.MeshAttachment, k = spine.ClippingAttachment, g = function e(t, n, i) {
        s(this, e), this.vertices = t, this.numVertices = n, this.numFloats = i;
    }, _ = function() {
        function e() {
            var t = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
            s(this, e), this.vertexEffect = null, this.tempColor = new c(), this.tempColor2 = new c(), 
            this.vertexSize = 8, this.twoColorTint = !1, this.renderable = new g(null, 0, 0), 
            this.clipper = new d(), this.temp = new m(), this.temp2 = new m(), this.temp3 = new c(), 
            this.temp4 = new c(), this.twoColorTint = t, t && (this.vertexSize += 4), this.vertices = v.newFloatArray(1024 * this.vertexSize);
        }
        return a(e, [ {
            key: "draw",
            value: function(t) {
                var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : -1, i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : -1, s = arguments.length > 3 ? arguments[3] : void 0, a = arguments.length > 4 ? arguments[4] : void 0, r = this.clipper, l = this.premultipliedAlpha, o = this.temp, u = this.temp2, p = this.temp3, c = this.temp4, d = this.renderable, m = null, g = null, _ = t.drawOrder, S = null, A = t.color, x = !1;
                -1 == n && (x = !0);
                for (var b = 0, w = _.length; b < w; b++) {
                    var E = r.isClipping() ? 2 : 8, C = _[b];
                    if (n >= 0 && n == C.data.index && (x = !0), x) {
                        i >= 0 && i == C.data.index && (x = !1);
                        var D = void 0, T = C.getAttachment();
                        if (T instanceof y) {
                            var B = T;
                            d.vertices = this.vertices, d.numVertices = 4, d.numFloats = E << 2, B.computeWorldVertices(C.bone, d.vertices, 0, E), 
                            g = e.QUAD_TRIANGLES, m = B.uvs, D = a[B.region.renderObject.page.name], S = B.color;
                        } else {
                            if (!(T instanceof f)) {
                                if (T instanceof k) {
                                    var M = T;
                                    r.clipStart(C, M);
                                    continue;
                                }
                                r.clipEndWithSlot(C);
                                continue;
                            }
                            var I = T;
                            d.vertices = this.vertices, d.numVertices = I.worldVerticesLength >> 1, d.numFloats = d.numVertices * E, 
                            d.numFloats > d.vertices.length && (d.vertices = this.vertices = v.newFloatArray(d.numFloats)), 
                            I.computeWorldVertices(C, 0, I.worldVerticesLength, d.vertices, 0, E), g = I.triangles, 
                            D = a[I.region.renderObject.page.name], m = I.uvs, S = I.color;
                        }
                        if (null != D) {
                            var N = C.color, L = this.tempColor;
                            L.r = A.r * N.r * S.r, L.g = A.g * N.g * S.g, L.b = A.b * N.b * S.b, L.a = A.a * N.a * S.a, 
                            l && (L.r *= L.a, L.g *= L.a, L.b *= L.a);
                            var P = C.data.blendMode;
                            if (r.isClipping()) {
                                r.clipTriangles(d.vertices, d.numFloats, g, g.length, m, L, null, !1);
                                var O = new Float32Array(r.clippedVertices), R = r.clippedTriangles, V = [], U = [], F = [];
                                if (null != this.vertexEffect) for (var j = this.vertexEffect, W = O, q = 0, J = O.length; q < J; q += 8) o.x = W[q], 
                                o.y = W[q + 1], p.set(W[q + 2], W[q + 3], W[q + 4], W[q + 5]), u.x = W[q + 6], u.y = W[q + 7], 
                                c.set(0, 0, 0, 0), j.transform(o, u, p, c), W[q] = o.x, W[q + 1] = o.y, W[q + 2] = p.r, 
                                W[q + 3] = p.g, W[q + 4] = p.b, W[q + 5] = p.a, W[q + 6] = u.x, W[q + 7] = u.y, 
                                V.push(W[q], -W[q + 1]), F.push(W[q + 2], W[q + 3], W[q + 4], W[q + 5]), U.push(W[q + 6], W[q + 7]); else for (var z = 0; Number.isFinite(O[z + 6]) && Number.isFinite(O[z + 7]); ) V.push(O[z]), 
                                V.push(-O[z + 1]), F.push(O[z + 2]), F.push(O[z + 3]), F.push(O[z + 4]), F.push(O[z + 5]), 
                                U.push(O[z + 6]), U.push(O[z + 7]), z += this.vertexSize;
                                var K = void 0, G = null, H = null;
                                switch (P) {
                                  case 1:
                                    K = "light";
                                    break;

                                  case 2:
                                    K = "multiply";
                                    break;

                                  case 3:
                                    K = "screen";
                                    break;

                                  default:
                                    K = "normal";
                                }
                                H = (255 << 24) + 255 * F[0] | 0 + (255 * F[1] << 8) + (255 * F[2] << 16), s.graphics.drawTriangles(D, 0, 0, V, U, new Uint16Array(R), h.Matrix.EMPTY, F[3], G, K, H);
                            } else {
                                var Q = d.vertices, Y = [], X = [], Z = [];
                                if (null != this.vertexEffect) for (var $ = this.vertexEffect, ee = 0, te = 0, ne = d.numFloats; ee < ne; ee += 8, 
                                te += 2) o.x = Q[ee], o.y = Q[ee + 1], u.x = m[te], u.y = m[te + 1], p.setFromColor(L), 
                                c.set(0, 0, 0, 0), $.transform(o, u, p, c), Q[ee] = o.x, Q[ee + 1] = o.y, Q[ee + 2] = p.r, 
                                Q[ee + 3] = p.g, Q[ee + 4] = p.b, Q[ee + 5] = p.a, Q[ee + 6] = u.x, Q[ee + 7] = u.y, 
                                Y.push(Q[ee], -Q[ee + 1]), Z.push(Q[ee + 2], Q[ee + 3], Q[ee + 4], Q[ee + 5]), X.push(Q[ee + 6], Q[ee + 7]); else for (var ie = 2, se = 0, ae = d.numFloats; ie < ae; ie += 8, 
                                se += 2) Q[ie] = L.r, Q[ie + 1] = L.g, Q[ie + 2] = L.b, Q[ie + 3] = L.a, Q[ie + 4] = m[se], 
                                Q[ie + 5] = m[se + 1], Y.push(Q[ie - 2], -Q[ie - 1]), Z.push(Q[ie], Q[ie + 1], Q[ie + 2], Q[ie + 3]), 
                                X.push(Q[ie + 4], Q[ie + 5]);
                                var re = void 0, le = null, oe = null;
                                switch (P) {
                                  case 1:
                                    re = "light";
                                    break;

                                  case 2:
                                    re = "multiply";
                                    break;

                                  case 3:
                                    re = "screen";
                                    break;

                                  default:
                                    re = "normal";
                                }
                                oe = (255 << 24) + 255 * Z[0] | 0 + (255 * Z[1] << 8) + (255 * Z[2] << 16), s.graphics.drawTriangles(D, 0, 0, Y, X, new Uint16Array(g), h.Matrix.EMPTY, Z[3], le, re, oe);
                            }
                        }
                        r.clipEndWithSlot(C);
                    } else r.clipEndWithSlot(C);
                }
                r.clipEnd();
            }
        } ]), e;
    }();
    _.QUAD_TRIANGLES = [ 0, 1, 2, 2, 3, 0 ];
    var S = spine.TimeKeeper, A = spine.Skeleton, x = spine.AnimationState, b = spine.AnimationStateData, w = function(e) {
        r(u, e);
        var o = l(u);
        function u() {
            var e, n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
            return s(this, u), (e = o.call(this)).currentPlayTime = 0, e._pause = !0, e._currAniName = null, 
            e._playbackRate = 1, e._playAudio = !0, e._soundChannelArr = [], e.trackIndex = 0, 
            n && e.init(n), e._ins = t(e), e;
        }
        return a(u, [ {
            key: "init",
            value: function(e) {
                var t = this;
                this._templet = e, this._templet._addReference(1), this.skeleton = new A(this._templet.skeletonData), 
                this.stateData = new b(this.skeleton.data), this.state = new x(this.stateData), 
                this.skeletonRenderer = new _(!1), this.timeKeeper = new S(), this.skeletonRenderer.premultipliedAlpha = this._templet.spinePremultipliedAlpha, 
                this.state.addListener({
                    start: function(e) {},
                    interrupt: function(e) {},
                    end: function(e) {},
                    dispose: function(e) {},
                    complete: function(e) {
                        e.loop ? t.event(h.Event.COMPLETE) : (t._currAniName = null, t.event(h.Event.STOPPED));
                    },
                    event: function(n, i) {
                        var s, a = {
                            audioValue: i.data.audioPath,
                            audioPath: i.data.audioPath,
                            floatValue: i.floatValue,
                            intValue: i.intValue,
                            name: i.data.name,
                            stringValue: i.stringValue,
                            time: 1e3 * i.time,
                            balance: i.balance,
                            volume: i.volume
                        };
                        t.event(h.Event.LABEL, a), t._playAudio && a.audioValue && (s = h.SoundManager.playSound(e._textureDic.root + a.audioValue, 1, h.Handler.create(t, t._onAniSoundStoped), null, (1e3 * t.currentPlayTime - a.time) / 1e3), 
                        h.SoundManager.playbackRate = t._playbackRate, s && t._soundChannelArr.push(s));
                    }
                });
            }
        }, {
            key: "play",
            value: function(e, t) {
                var n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2], i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0, s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0, a = !(arguments.length > 6 && void 0 !== arguments[6]) || arguments[6];
                this._playAudio = a, s /= 1e3;
                var r = e;
                if ((i /= 1e3) < 0 || s < 0) throw new Error("SpineSkeleton: start and end must large than zero.");
                if (0 !== s && i > s) throw new Error("SpineSkeleton: start must less than end.");
                if ("number" == typeof r && (r = this.getAniNameByIndex(e)), n || this._pause || this._currAniName != r) {
                    this._currAniName = r, this.state.setAnimation(this.trackIndex, r, t);
                    var l = this.state.getCurrent(this.trackIndex);
                    l.animationStart = i, s && s < l.animationEnd && (l.animationEnd = s);
                    var o = l.animation.duration;
                    this._duration = o, this._playStart = i, this._playEnd = s <= o ? s : o, this._pause && (this._pause = !1, 
                    this.timer.frameLoop(1, this, this._update, null, !0)), this._update();
                }
            }
        }, {
            key: "_update",
            value: function() {
                this.timeKeeper.update();
                var e = this.timeKeeper.delta * this._playbackRate, t = this.state.getCurrent(this.trackIndex);
                this.state.update(e), this.state.apply(this.skeleton);
                var n = t.animationLast;
                this.currentPlayTime = Math.max(0, n), this.state && this.skeleton && (this.skeleton.updateWorldTransform(), 
                this._ins.graphics.clear(), this.skeletonRenderer.draw(this.skeleton, -1, -1, this._ins, this._templet._textureDic));
            }
        }, {
            key: "getAnimNum",
            value: function() {
                return this._templet.skeletonData.animations.length;
            }
        }, {
            key: "getAniNameByIndex",
            value: function(e) {
                return this._templet.getAniNameByIndex(e);
            }
        }, {
            key: "getSlotByName",
            value: function(e) {
                return this.skeleton.findSlot(e);
            }
        }, {
            key: "playbackRate",
            value: function(e) {
                this._playbackRate = e;
            }
        }, {
            key: "showSkinByName",
            value: function(e) {
                this.showSkinByIndex(this._templet.getSkinIndexByName(e));
            }
        }, {
            key: "showSkinByIndex",
            value: function(e) {
                var t = this.skeleton.data.skins[e];
                this.skeleton.setSkin(t), this.skeleton.setSlotsToSetupPose();
            }
        }, {
            key: "stop",
            value: function() {
                this._pause || (this._pause = !0, this._currAniName = null, this.timer.clear(this, this._update), 
                this.state.update(-this.currentPlayTime), this.currentPlayTime = 0, this.event(h.Event.STOPPED), 
                this._soundChannelArr.length > 0 && this._onAniSoundStoped(!0));
            }
        }, {
            key: "paused",
            value: function() {
                if (!this._pause && (this._pause = !0, this.timer.clear(this, this._update), this.event(h.Event.PAUSED), 
                this._soundChannelArr.length > 0)) for (var e, t = this._soundChannelArr.length, n = 0; n < t; n++) (e = this._soundChannelArr[n]).isStopped || e.pause();
            }
        }, {
            key: "resume",
            value: function() {
                if (this._pause && (this._pause = !1, this.timer.frameLoop(1, this, this._update, null, !0), 
                this._soundChannelArr.length > 0)) for (var e, t = this._soundChannelArr.length, n = 0; n < t; n++) (e = this._soundChannelArr[n]).audioBuffer && e.resume();
            }
        }, {
            key: "_onAniSoundStoped",
            value: function(e) {
                for (var t, n = this._soundChannelArr.length, i = 0; i < n; i++) ((t = this._soundChannelArr[i]).isStopped || e) && (!t.isStopped && t.stop(), 
                this._soundChannelArr.splice(i, 1), n--, i--);
            }
        }, {
            key: "destroy",
            value: function() {
                var e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
                n(i(u.prototype), "destroy", this).call(this, e), this._templet._removeReference(1), 
                this._templet = null, this.timeKeeper = null, this.skeleton = null, this.state.clearListeners(), 
                this.state = null, this.skeletonRenderer = null, this.timer.clear(this, this._update), 
                this._soundChannelArr.length > 0 && this._onAniSoundStoped(!0);
            }
        }, {
            key: "templet",
            get: function() {
                return this._templet;
            }
        }, {
            key: "addAnimation",
            value: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                n /= 1e3;
                var i = e;
                "number" == typeof i && (i = this.getAniNameByIndex(i)), this._currAniName = i, 
                this.state.addAnimation(this.trackIndex, i, t, n);
            }
        }, {
            key: "setMix",
            value: function(e, t, n) {
                n /= 1e3;
                var i = e;
                "number" == typeof i && (i = this.getAniNameByIndex(i));
                var s = t;
                "number" == typeof s && (s = this.getAniNameByIndex(s)), this.stateData.setMix(i, s, n);
            }
        }, {
            key: "getBoneByName",
            value: function(e) {
                return this.skeleton.findBone(e);
            }
        }, {
            key: "getSkeleton",
            value: function() {
                return this.skeleton;
            }
        }, {
            key: "setSlotAttachment",
            value: function(e, t) {
                this.skeleton.setAttachment(e, t);
            }
        }, {
            key: "currentTime",
            set: function(e) {
                if (this._currAniName && this._templet) {
                    if ((e /= 1e3) < this._playStart || this._playEnd && e > this._playEnd || e > this._duration) throw new Error("AnimationPlayer: value must large than playStartTime,small than playEndTime.");
                    this.state.update(e - this.currentPlayTime), this.currentPlayTime = e;
                }
            }
        }, {
            key: "playState",
            get: function() {
                return this._currAniName ? this._pause ? u.paused : u.playing : u.stopped;
            }
        } ]), u;
    }(h.Sprite);
    w.stopped = 0, w.paused = 1, w.playing = 2, h.ILaya.regClass(w), h.ClassUtils.regClass("laya.layaspine.SpineSkeleton", w), 
    h.ClassUtils.regClass("Laya.SpineSkeleton", w);
    var E, C, D = function(e) {
        r(o, e);
        var t = l(o);
        function o() {
            var e;
            return s(this, o), (e = t.call(this))._isDestroyed = !1, e._textureDic = {}, e._layaPremultipliedAlpha = !0, 
            e._spinePremultipliedAlpha = !1, e;
        }
        return a(o, [ {
            key: "templet",
            get: function() {
                return this._templet;
            },
            set: function(e) {
                this._templet = e;
            }
        }, {
            key: "isDestroyed",
            get: function() {
                return this._isDestroyed;
            },
            set: function(e) {
                this._isDestroyed = e;
            }
        }, {
            key: "spinePremultipliedAlpha",
            get: function() {
                return this._spinePremultipliedAlpha;
            },
            set: function(e) {
                this._spinePremultipliedAlpha = e;
            }
        }, {
            key: "buildArmature",
            value: function() {
                return new w(this);
            }
        }, {
            key: "getAniNameByIndex",
            value: function(e) {
                var t = this.skeletonData.animations[e];
                return t ? t.name : null;
            }
        }, {
            key: "getSkinIndexByName",
            value: function(e) {
                for (var t = this.skeletonData.skins, n = 0, i = t.length; n < i; n++) if (t[n].name == e) return n;
                return -1;
            }
        }, {
            key: "destroy",
            value: function() {
                var e;
                for (e in this.isDestroyed = !0, this._textureDic) "root" != e && e && this._textureDic[e].destroy();
                n(i(o.prototype), "destroy", this).call(this);
            }
        } ]), o;
    }(h.Resource), T = spine.AssetManager, B = spine.AtlasAttachmentLoader, M = spine.SkeletonJson, I = spine.SkeletonBinary, N = function(e) {
        r(o, e);
        var t = l(o);
        function o() {
            var e;
            return s(this, o), (e = t.call(this))._textureDic = {}, e;
        }
        return a(o, [ {
            key: "loadAni",
            value: function(e) {
                var t = e.lastIndexOf("/") + 1, n = e.slice(0, t), i = (e = e.slice(t)).replace(".json", ".atlas").replace(".skel", ".atlas");
                this._textureDic.root = n, this.clientId = n, this.atlasUrl = i, this.jsonOrSkelUrl = e, 
                this.assetManager = new T(this._textureLoader.bind(this), n), this.assetManager.loadTextureAtlas(i), 
                e.endsWith(".skel") ? this.assetManager.loadBinary(e) : this.assetManager.loadText(e), 
                h.Laya.timer.frameOnce(1, this, this.loop);
            }
        }, {
            key: "_textureLoader",
            value: function(e) {
                var t = e.url.replace(this.clientId, "");
                return this._textureDic[t] = new u(e.bitmap);
            }
        }, {
            key: "loop",
            value: function() {
                this.assetManager.isLoadingComplete() ? this.parseSpineAni() : this.assetManager.hasErrors() ? this.event(h.Event.ERROR, "load failed:" + this.assetManager.getErrors()) : h.Laya.timer.frameOnce(1, this, this.loop);
            }
        }, {
            key: "parseSpineAni",
            value: function() {
                if (this.isDestroyed) this.destroy(); else {
                    var e = this.assetManager.get(this.atlasUrl), t = new B(e);
                    this.jsonOrSkelUrl.endsWith(".skel") ? (this.skeletonBinary = new I(t), this.skeletonData = this.skeletonBinary.readSkeletonData(this.assetManager.get(this.jsonOrSkelUrl))) : (this.skeletonJson = new M(t), 
                    this.skeletonData = this.skeletonJson.readSkeletonData(this.assetManager.get(this.jsonOrSkelUrl))), 
                    this.event(h.Event.COMPLETE, this);
                }
            }
        }, {
            key: "buildArmature",
            value: function() {
                return n(i(o.prototype), "buildArmature", this).call(this);
            }
        }, {
            key: "getAniNameByIndex",
            value: function(e) {
                return n(i(o.prototype), "getAniNameByIndex", this).call(this, e);
            }
        }, {
            key: "getSkinIndexByName",
            value: function(e) {
                return n(i(o.prototype), "getSkinIndexByName", this).call(this, e);
            }
        }, {
            key: "destroy",
            value: function() {
                n(i(o.prototype), "destroy", this).call(this);
            }
        } ]), o;
    }(D), L = spine.AtlasAttachmentLoader, P = spine.SkeletonJson, O = spine.SkeletonBinary, R = function(e) {
        r(o, e);
        var t = l(o);
        function o() {
            var e;
            return s(this, o), (e = t.call(this))._textureDic = {}, e;
        }
        return a(o, [ {
            key: "loadAni",
            value: function(e) {
                var t = e.lastIndexOf("/") + 1, n = e.slice(0, t), i = (e = e.slice(t)).replace(".json", ".atlas").replace(".skel", ".atlas");
                this._textureDic.root = n, this.pathPrefix = n, this.atlasUrl = i, this.jsonOrSkelUrl = e, 
                this.assetManager = new p(n, new spine.Downloader(), this._textureDic), this.assetManager.loadTextureAtlas(i), 
                e.endsWith(".skel") ? this.assetManager.loadBinary(e) : this.assetManager.loadJson(e), 
                h.Laya.timer.frameOnce(1, this, this.loop);
            }
        }, {
            key: "loop",
            value: function() {
                this.assetManager.isLoadingComplete() ? this.parseSpineAni() : this.assetManager.hasErrors() ? this.event(h.Event.ERROR, "load failed:" + this.assetManager.getErrors()) : h.Laya.timer.frameOnce(1, this, this.loop);
            }
        }, {
            key: "parseSpineAni",
            value: function() {
                if (this.isDestroyed) this.destroy(); else {
                    var e = this.assetManager.get(this.atlasUrl), t = new L(e);
                    this.jsonOrSkelUrl.endsWith(".skel") ? (this.skeletonBinary = new O(t), this.skeletonData = this.skeletonBinary.readSkeletonData(this.assetManager.get(this.jsonOrSkelUrl))) : (this.skeletonJson = new P(t), 
                    this.skeletonData = this.skeletonJson.readSkeletonData(this.assetManager.get(this.jsonOrSkelUrl))), 
                    this.event(h.Event.COMPLETE, this);
                }
            }
        }, {
            key: "buildArmature",
            value: function() {
                return n(i(o.prototype), "buildArmature", this).call(this);
            }
        }, {
            key: "getAniNameByIndex",
            value: function(e) {
                return n(i(o.prototype), "getAniNameByIndex", this).call(this, e);
            }
        }, {
            key: "getSkinIndexByName",
            value: function(e) {
                return n(i(o.prototype), "getSkinIndexByName", this).call(this, e);
            }
        }, {
            key: "destroy",
            value: function() {
                n(i(o.prototype), "destroy", this).call(this);
            }
        } ]), o;
    }(D);
    (E = o.SpineVersion || (o.SpineVersion = {})).v3_7 = "v3_7", E.v3_8 = "v3_8", E.v4_0 = "v4_0", 
    (C = o.SpineFormat || (o.SpineFormat = {})).json = "json", C.binary = "binary", 
    o.SpineAssetManager = p, o.SpineGLTexture = u, o.SpineSkeleton = w, o.SpineSkeletonRenderer = _, 
    o.SpineTemplet = function(t) {
        r(i, t);
        var n = l(i);
        function i(t) {
            var a, r;
            if (s(this, i), a = n.call(this), t === o.SpineVersion.v3_7 || t === o.SpineVersion.v3_8) r = new N(); else {
                if (t !== o.SpineVersion.v4_0) throw new Error("传入参数错误，请与服务提供商联系");
                r = new R();
            }
            return e(a, r);
        }
        return a(i, [ {
            key: "loadAni",
            value: function(e) {}
        }, {
            key: "buildArmature",
            value: function() {
                return null;
            }
        }, {
            key: "getAniNameByIndex",
            value: function(e) {
                return null;
            }
        }, {
            key: "getSkinIndexByName",
            value: function(e) {
                return null;
            }
        }, {
            key: "destroy",
            value: function() {}
        } ]), i;
    }(D), o.SpineTempletBase = D, o.SpineTemplet_3_x = N, o.SpineTemplet_4_0 = R;
}(window.Laya = window.Laya || {}, Laya);