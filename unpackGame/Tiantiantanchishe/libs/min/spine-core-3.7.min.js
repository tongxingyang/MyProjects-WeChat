var t, e, a, n = require("../../@babel/runtime/helpers/inherits"), i = require("../../@babel/runtime/helpers/createSuper"), r = require("../../@babel/runtime/helpers/classCallCheck"), s = require("../../@babel/runtime/helpers/createClass");

!function(t) {
    var e, a, o, l = function() {
        function t(e, a, n) {
            if (r(this, t), null == e) throw new Error("name cannot be null.");
            if (null == a) throw new Error("timelines cannot be null.");
            this.name = e, this.timelines = a, this.duration = n;
        }
        return s(t, [ {
            key: "apply",
            value: function(t, e, a, n, i, r, s, o) {
                if (null == t) throw new Error("skeleton cannot be null.");
                n && 0 != this.duration && (a %= this.duration, e > 0 && (e %= this.duration));
                for (var l = this.timelines, h = 0, u = l.length; h < u; h++) l[h].apply(t, e, a, i, r, s, o);
            }
        } ], [ {
            key: "binarySearch",
            value: function(t, e) {
                var a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1, n = 0, i = t.length / a - 2;
                if (0 == i) return a;
                for (var r = i >>> 1; ;) {
                    if (t[(r + 1) * a] <= e ? n = r + 1 : i = r, n == i) return (n + 1) * a;
                    r = n + i >>> 1;
                }
            }
        }, {
            key: "linearSearch",
            value: function(t, e, a) {
                for (var n = 0, i = t.length - a; n <= i; n += a) if (t[n] > e) return n;
                return -1;
            }
        } ]), t;
    }();
    t.Animation = l, function(t) {
        t[t.setup = 0] = "setup", t[t.first = 1] = "first", t[t.replace = 2] = "replace", 
        t[t.add = 3] = "add";
    }(e = t.MixBlend || (t.MixBlend = {})), function(t) {
        t[t.in = 0] = "in", t[t.out = 1] = "out";
    }(a = t.MixDirection || (t.MixDirection = {})), function(t) {
        t[t.rotate = 0] = "rotate", t[t.translate = 1] = "translate", t[t.scale = 2] = "scale", 
        t[t.shear = 3] = "shear", t[t.attachment = 4] = "attachment", t[t.color = 5] = "color", 
        t[t.deform = 6] = "deform", t[t.event = 7] = "event", t[t.drawOrder = 8] = "drawOrder", 
        t[t.ikConstraint = 9] = "ikConstraint", t[t.transformConstraint = 10] = "transformConstraint", 
        t[t.pathConstraintPosition = 11] = "pathConstraintPosition", t[t.pathConstraintSpacing = 12] = "pathConstraintSpacing", 
        t[t.pathConstraintMix = 13] = "pathConstraintMix", t[t.twoColor = 14] = "twoColor";
    }(o = t.TimelineType || (t.TimelineType = {}));
    var h = function() {
        function e(a) {
            if (r(this, e), a <= 0) throw new Error("frameCount must be > 0: " + a);
            this.curves = t.Utils.newFloatArray((a - 1) * e.BEZIER_SIZE);
        }
        return s(e, [ {
            key: "getFrameCount",
            value: function() {
                return this.curves.length / e.BEZIER_SIZE + 1;
            }
        }, {
            key: "setLinear",
            value: function(t) {
                this.curves[t * e.BEZIER_SIZE] = e.LINEAR;
            }
        }, {
            key: "setStepped",
            value: function(t) {
                this.curves[t * e.BEZIER_SIZE] = e.STEPPED;
            }
        }, {
            key: "getCurveType",
            value: function(t) {
                var a = t * e.BEZIER_SIZE;
                if (a == this.curves.length) return e.LINEAR;
                var n = this.curves[a];
                return n == e.LINEAR ? e.LINEAR : n == e.STEPPED ? e.STEPPED : e.BEZIER;
            }
        }, {
            key: "setCurve",
            value: function(t, a, n, i, r) {
                var s = .03 * (2 * -a + i), o = .03 * (2 * -n + r), l = .006 * (3 * (a - i) + 1), h = .006 * (3 * (n - r) + 1), u = 2 * s + l, c = 2 * o + h, f = .3 * a + s + .16666667 * l, d = .3 * n + o + .16666667 * h, v = t * e.BEZIER_SIZE, m = this.curves;
                m[v++] = e.BEZIER;
                for (var g = f, p = d, y = v + e.BEZIER_SIZE - 1; v < y; v += 2) m[v] = g, m[v + 1] = p, 
                f += u, d += c, u += l, c += h, g += f, p += d;
            }
        }, {
            key: "getCurvePercent",
            value: function(a, n) {
                n = t.MathUtils.clamp(n, 0, 1);
                var i = this.curves, r = a * e.BEZIER_SIZE, s = i[r];
                if (s == e.LINEAR) return n;
                if (s == e.STEPPED) return 0;
                for (var o = 0, l = ++r, h = r + e.BEZIER_SIZE - 1; r < h; r += 2) if ((o = i[r]) >= n) {
                    var u = void 0, c = void 0;
                    return r == l ? (u = 0, c = 0) : (u = i[r - 2], c = i[r - 1]), c + (i[r + 1] - c) * (n - u) / (o - u);
                }
                var f = i[r - 1];
                return f + (1 - f) * (n - o) / (1 - o);
            }
        } ]), e;
    }();
    h.LINEAR = 0, h.STEPPED = 1, h.BEZIER = 2, h.BEZIER_SIZE = 19, t.CurveTimeline = h;
    var u = function(a) {
        n(u, a);
        var h = i(u);
        function u(e) {
            var a;
            return r(this, u), (a = h.call(this, e)).frames = t.Utils.newFloatArray(e << 1), 
            a;
        }
        return s(u, [ {
            key: "getPropertyId",
            value: function() {
                return (o.rotate << 24) + this.boneIndex;
            }
        }, {
            key: "setFrame",
            value: function(t, e, a) {
                t <<= 1, this.frames[t] = e, this.frames[t + u.ROTATION] = a;
            }
        }, {
            key: "apply",
            value: function(t, a, n, i, r, s, o) {
                var h = this.frames, c = t.bones[this.boneIndex];
                if (n < h[0]) switch (s) {
                  case e.setup:
                    return void (c.rotation = c.data.rotation);

                  case e.first:
                    var f = c.data.rotation - c.rotation;
                    c.rotation += (f - 360 * (16384 - (16384.499999999996 - f / 360 | 0))) * r;
                } else if (n >= h[h.length - u.ENTRIES]) {
                    var d = h[h.length + u.PREV_ROTATION];
                    switch (s) {
                      case e.setup:
                        c.rotation = c.data.rotation + d * r;
                        break;

                      case e.first:
                      case e.replace:
                        d += c.data.rotation - c.rotation, d -= 360 * (16384 - (16384.499999999996 - d / 360 | 0));

                      case e.add:
                        c.rotation += d * r;
                    }
                } else {
                    var v = l.binarySearch(h, n, u.ENTRIES), m = h[v + u.PREV_ROTATION], g = h[v], p = this.getCurvePercent((v >> 1) - 1, 1 - (n - g) / (h[v + u.PREV_TIME] - g)), y = h[v + u.ROTATION] - m;
                    switch (y = m + (y - 360 * (16384 - (16384.499999999996 - y / 360 | 0))) * p, s) {
                      case e.setup:
                        c.rotation = c.data.rotation + (y - 360 * (16384 - (16384.499999999996 - y / 360 | 0))) * r;
                        break;

                      case e.first:
                      case e.replace:
                        y += c.data.rotation - c.rotation;

                      case e.add:
                        c.rotation += (y - 360 * (16384 - (16384.499999999996 - y / 360 | 0))) * r;
                    }
                }
            }
        } ]), u;
    }(h);
    u.ENTRIES = 2, u.PREV_TIME = -2, u.PREV_ROTATION = -1, u.ROTATION = 1, t.RotateTimeline = u;
    var c = function(a) {
        n(u, a);
        var h = i(u);
        function u(e) {
            var a;
            return r(this, u), (a = h.call(this, e)).frames = t.Utils.newFloatArray(e * u.ENTRIES), 
            a;
        }
        return s(u, [ {
            key: "getPropertyId",
            value: function() {
                return (o.translate << 24) + this.boneIndex;
            }
        }, {
            key: "setFrame",
            value: function(t, e, a, n) {
                t *= u.ENTRIES, this.frames[t] = e, this.frames[t + u.X] = a, this.frames[t + u.Y] = n;
            }
        }, {
            key: "apply",
            value: function(t, a, n, i, r, s, o) {
                var h = this.frames, c = t.bones[this.boneIndex];
                if (n < h[0]) switch (s) {
                  case e.setup:
                    return c.x = c.data.x, void (c.y = c.data.y);

                  case e.first:
                    c.x += (c.data.x - c.x) * r, c.y += (c.data.y - c.y) * r;
                } else {
                    var f = 0, d = 0;
                    if (n >= h[h.length - u.ENTRIES]) f = h[h.length + u.PREV_X], d = h[h.length + u.PREV_Y]; else {
                        var v = l.binarySearch(h, n, u.ENTRIES);
                        f = h[v + u.PREV_X], d = h[v + u.PREV_Y];
                        var m = h[v], g = this.getCurvePercent(v / u.ENTRIES - 1, 1 - (n - m) / (h[v + u.PREV_TIME] - m));
                        f += (h[v + u.X] - f) * g, d += (h[v + u.Y] - d) * g;
                    }
                    switch (s) {
                      case e.setup:
                        c.x = c.data.x + f * r, c.y = c.data.y + d * r;
                        break;

                      case e.first:
                      case e.replace:
                        c.x += (c.data.x + f - c.x) * r, c.y += (c.data.y + d - c.y) * r;
                        break;

                      case e.add:
                        c.x += f * r, c.y += d * r;
                    }
                }
            }
        } ]), u;
    }(h);
    c.ENTRIES = 3, c.PREV_TIME = -3, c.PREV_X = -2, c.PREV_Y = -1, c.X = 1, c.Y = 2, 
    t.TranslateTimeline = c;
    var f = function(h) {
        n(c, h);
        var u = i(c);
        function c(t) {
            return r(this, c), u.call(this, t);
        }
        return s(c, [ {
            key: "getPropertyId",
            value: function() {
                return (o.scale << 24) + this.boneIndex;
            }
        }, {
            key: "apply",
            value: function(n, i, r, s, o, h, u) {
                var f = this.frames, d = n.bones[this.boneIndex];
                if (r < f[0]) switch (h) {
                  case e.setup:
                    return d.scaleX = d.data.scaleX, void (d.scaleY = d.data.scaleY);

                  case e.first:
                    d.scaleX += (d.data.scaleX - d.scaleX) * o, d.scaleY += (d.data.scaleY - d.scaleY) * o;
                } else {
                    var v = 0, m = 0;
                    if (r >= f[f.length - c.ENTRIES]) v = f[f.length + c.PREV_X] * d.data.scaleX, m = f[f.length + c.PREV_Y] * d.data.scaleY; else {
                        var g = l.binarySearch(f, r, c.ENTRIES);
                        v = f[g + c.PREV_X], m = f[g + c.PREV_Y];
                        var p = f[g], y = this.getCurvePercent(g / c.ENTRIES - 1, 1 - (r - p) / (f[g + c.PREV_TIME] - p));
                        v = (v + (f[g + c.X] - v) * y) * d.data.scaleX, m = (m + (f[g + c.Y] - m) * y) * d.data.scaleY;
                    }
                    if (1 == o) h == e.add ? (d.scaleX += v - d.data.scaleX, d.scaleY += m - d.data.scaleY) : (d.scaleX = v, 
                    d.scaleY = m); else {
                        var M = 0, x = 0;
                        if (u == a.out) switch (h) {
                          case e.setup:
                            M = d.data.scaleX, x = d.data.scaleY, d.scaleX = M + (Math.abs(v) * t.MathUtils.signum(M) - M) * o, 
                            d.scaleY = x + (Math.abs(m) * t.MathUtils.signum(x) - x) * o;
                            break;

                          case e.first:
                          case e.replace:
                            M = d.scaleX, x = d.scaleY, d.scaleX = M + (Math.abs(v) * t.MathUtils.signum(M) - M) * o, 
                            d.scaleY = x + (Math.abs(m) * t.MathUtils.signum(x) - x) * o;
                            break;

                          case e.add:
                            M = d.scaleX, x = d.scaleY, d.scaleX = M + (Math.abs(v) * t.MathUtils.signum(M) - d.data.scaleX) * o, 
                            d.scaleY = x + (Math.abs(m) * t.MathUtils.signum(x) - d.data.scaleY) * o;
                        } else switch (h) {
                          case e.setup:
                            M = Math.abs(d.data.scaleX) * t.MathUtils.signum(v), x = Math.abs(d.data.scaleY) * t.MathUtils.signum(m), 
                            d.scaleX = M + (v - M) * o, d.scaleY = x + (m - x) * o;
                            break;

                          case e.first:
                          case e.replace:
                            M = Math.abs(d.scaleX) * t.MathUtils.signum(v), x = Math.abs(d.scaleY) * t.MathUtils.signum(m), 
                            d.scaleX = M + (v - M) * o, d.scaleY = x + (m - x) * o;
                            break;

                          case e.add:
                            M = t.MathUtils.signum(v), x = t.MathUtils.signum(m), d.scaleX = Math.abs(d.scaleX) * M + (v - Math.abs(d.data.scaleX) * M) * o, 
                            d.scaleY = Math.abs(d.scaleY) * x + (m - Math.abs(d.data.scaleY) * x) * o;
                        }
                    }
                }
            }
        } ]), c;
    }(c);
    t.ScaleTimeline = f;
    var d = function(t) {
        n(h, t);
        var a = i(h);
        function h(t) {
            return r(this, h), a.call(this, t);
        }
        return s(h, [ {
            key: "getPropertyId",
            value: function() {
                return (o.shear << 24) + this.boneIndex;
            }
        }, {
            key: "apply",
            value: function(t, a, n, i, r, s, o) {
                var u = this.frames, c = t.bones[this.boneIndex];
                if (n < u[0]) switch (s) {
                  case e.setup:
                    return c.shearX = c.data.shearX, void (c.shearY = c.data.shearY);

                  case e.first:
                    c.shearX += (c.data.shearX - c.shearX) * r, c.shearY += (c.data.shearY - c.shearY) * r;
                } else {
                    var f = 0, d = 0;
                    if (n >= u[u.length - h.ENTRIES]) f = u[u.length + h.PREV_X], d = u[u.length + h.PREV_Y]; else {
                        var v = l.binarySearch(u, n, h.ENTRIES);
                        f = u[v + h.PREV_X], d = u[v + h.PREV_Y];
                        var m = u[v], g = this.getCurvePercent(v / h.ENTRIES - 1, 1 - (n - m) / (u[v + h.PREV_TIME] - m));
                        f += (u[v + h.X] - f) * g, d += (u[v + h.Y] - d) * g;
                    }
                    switch (s) {
                      case e.setup:
                        c.shearX = c.data.shearX + f * r, c.shearY = c.data.shearY + d * r;
                        break;

                      case e.first:
                      case e.replace:
                        c.shearX += (c.data.shearX + f - c.shearX) * r, c.shearY += (c.data.shearY + d - c.shearY) * r;
                        break;

                      case e.add:
                        c.shearX += f * r, c.shearY += d * r;
                    }
                }
            }
        } ]), h;
    }(c);
    t.ShearTimeline = d;
    var v = function(a) {
        n(u, a);
        var h = i(u);
        function u(e) {
            var a;
            return r(this, u), (a = h.call(this, e)).frames = t.Utils.newFloatArray(e * u.ENTRIES), 
            a;
        }
        return s(u, [ {
            key: "getPropertyId",
            value: function() {
                return (o.color << 24) + this.slotIndex;
            }
        }, {
            key: "setFrame",
            value: function(t, e, a, n, i, r) {
                t *= u.ENTRIES, this.frames[t] = e, this.frames[t + u.R] = a, this.frames[t + u.G] = n, 
                this.frames[t + u.B] = i, this.frames[t + u.A] = r;
            }
        }, {
            key: "apply",
            value: function(t, a, n, i, r, s, o) {
                var h = t.slots[this.slotIndex], c = this.frames;
                if (n < c[0]) switch (s) {
                  case e.setup:
                    return void h.color.setFromColor(h.data.color);

                  case e.first:
                    var f = h.color, d = h.data.color;
                    f.add((d.r - f.r) * r, (d.g - f.g) * r, (d.b - f.b) * r, (d.a - f.a) * r);
                } else {
                    var v = 0, m = 0, g = 0, p = 0;
                    if (n >= c[c.length - u.ENTRIES]) {
                        var y = c.length;
                        v = c[y + u.PREV_R], m = c[y + u.PREV_G], g = c[y + u.PREV_B], p = c[y + u.PREV_A];
                    } else {
                        var M = l.binarySearch(c, n, u.ENTRIES);
                        v = c[M + u.PREV_R], m = c[M + u.PREV_G], g = c[M + u.PREV_B], p = c[M + u.PREV_A];
                        var x = c[M], w = this.getCurvePercent(M / u.ENTRIES - 1, 1 - (n - x) / (c[M + u.PREV_TIME] - x));
                        v += (c[M + u.R] - v) * w, m += (c[M + u.G] - m) * w, g += (c[M + u.B] - g) * w, 
                        p += (c[M + u.A] - p) * w;
                    }
                    if (1 == r) h.color.set(v, m, g, p); else {
                        var E = h.color;
                        s == e.setup && E.setFromColor(h.data.color), E.add((v - E.r) * r, (m - E.g) * r, (g - E.b) * r, (p - E.a) * r);
                    }
                }
            }
        } ]), u;
    }(h);
    v.ENTRIES = 5, v.PREV_TIME = -5, v.PREV_R = -4, v.PREV_G = -3, v.PREV_B = -2, v.PREV_A = -1, 
    v.R = 1, v.G = 2, v.B = 3, v.A = 4, t.ColorTimeline = v;
    var m = function(a) {
        n(u, a);
        var h = i(u);
        function u(e) {
            var a;
            return r(this, u), (a = h.call(this, e)).frames = t.Utils.newFloatArray(e * u.ENTRIES), 
            a;
        }
        return s(u, [ {
            key: "getPropertyId",
            value: function() {
                return (o.twoColor << 24) + this.slotIndex;
            }
        }, {
            key: "setFrame",
            value: function(t, e, a, n, i, r, s, o, l) {
                t *= u.ENTRIES, this.frames[t] = e, this.frames[t + u.R] = a, this.frames[t + u.G] = n, 
                this.frames[t + u.B] = i, this.frames[t + u.A] = r, this.frames[t + u.R2] = s, this.frames[t + u.G2] = o, 
                this.frames[t + u.B2] = l;
            }
        }, {
            key: "apply",
            value: function(t, a, n, i, r, s, o) {
                var h = t.slots[this.slotIndex], c = this.frames;
                if (n < c[0]) switch (s) {
                  case e.setup:
                    return h.color.setFromColor(h.data.color), void h.darkColor.setFromColor(h.data.darkColor);

                  case e.first:
                    var f = h.color, d = h.darkColor, v = h.data.color, m = h.data.darkColor;
                    f.add((v.r - f.r) * r, (v.g - f.g) * r, (v.b - f.b) * r, (v.a - f.a) * r), d.add((m.r - d.r) * r, (m.g - d.g) * r, (m.b - d.b) * r, 0);
                } else {
                    var g = 0, p = 0, y = 0, M = 0, x = 0, w = 0, E = 0;
                    if (n >= c[c.length - u.ENTRIES]) {
                        var k = c.length;
                        g = c[k + u.PREV_R], p = c[k + u.PREV_G], y = c[k + u.PREV_B], M = c[k + u.PREV_A], 
                        x = c[k + u.PREV_R2], w = c[k + u.PREV_G2], E = c[k + u.PREV_B2];
                    } else {
                        var T = l.binarySearch(c, n, u.ENTRIES);
                        g = c[T + u.PREV_R], p = c[T + u.PREV_G], y = c[T + u.PREV_B], M = c[T + u.PREV_A], 
                        x = c[T + u.PREV_R2], w = c[T + u.PREV_G2], E = c[T + u.PREV_B2];
                        var b = c[T], A = this.getCurvePercent(T / u.ENTRIES - 1, 1 - (n - b) / (c[T + u.PREV_TIME] - b));
                        g += (c[T + u.R] - g) * A, p += (c[T + u.G] - p) * A, y += (c[T + u.B] - y) * A, 
                        M += (c[T + u.A] - M) * A, x += (c[T + u.R2] - x) * A, w += (c[T + u.G2] - w) * A, 
                        E += (c[T + u.B2] - E) * A;
                    }
                    if (1 == r) h.color.set(g, p, y, M), h.darkColor.set(x, w, E, 1); else {
                        var R = h.color, S = h.darkColor;
                        s == e.setup && (R.setFromColor(h.data.color), S.setFromColor(h.data.darkColor)), 
                        R.add((g - R.r) * r, (p - R.g) * r, (y - R.b) * r, (M - R.a) * r), S.add((x - S.r) * r, (w - S.g) * r, (E - S.b) * r, 0);
                    }
                }
            }
        } ]), u;
    }(h);
    m.ENTRIES = 8, m.PREV_TIME = -8, m.PREV_R = -7, m.PREV_G = -6, m.PREV_B = -5, m.PREV_A = -4, 
    m.PREV_R2 = -3, m.PREV_G2 = -2, m.PREV_B2 = -1, m.R = 1, m.G = 2, m.B = 3, m.A = 4, 
    m.R2 = 5, m.G2 = 6, m.B2 = 7, t.TwoColorTimeline = m, t.AttachmentTimeline = function() {
        function n(e) {
            r(this, n), this.frames = t.Utils.newFloatArray(e), this.attachmentNames = new Array(e);
        }
        return s(n, [ {
            key: "getPropertyId",
            value: function() {
                return (o.attachment << 24) + this.slotIndex;
            }
        }, {
            key: "getFrameCount",
            value: function() {
                return this.frames.length;
            }
        }, {
            key: "setFrame",
            value: function(t, e, a) {
                this.frames[t] = e, this.attachmentNames[t] = a;
            }
        }, {
            key: "apply",
            value: function(t, n, i, r, s, o, h) {
                var u = t.slots[this.slotIndex];
                if (h != a.out || o != e.setup) {
                    var c = this.frames;
                    if (i < c[0]) {
                        if (o == e.setup || o == e.first) {
                            var f = u.data.attachmentName;
                            u.setAttachment(null == f ? null : t.getAttachment(this.slotIndex, f));
                        }
                    } else {
                        var d;
                        d = i >= c[c.length - 1] ? c.length - 1 : l.binarySearch(c, i, 1) - 1;
                        var v = this.attachmentNames[d];
                        t.slots[this.slotIndex].setAttachment(null == v ? null : t.getAttachment(this.slotIndex, v));
                    }
                } else {
                    var m = u.data.attachmentName;
                    u.setAttachment(null == m ? null : t.getAttachment(this.slotIndex, m));
                }
            }
        } ]), n;
    }();
    var g = null;
    t.DeformTimeline = function(a) {
        n(u, a);
        var h = i(u);
        function u(e) {
            var a;
            return r(this, u), (a = h.call(this, e)).frames = t.Utils.newFloatArray(e), a.frameVertices = new Array(e), 
            null == g && (g = t.Utils.newFloatArray(64)), a;
        }
        return s(u, [ {
            key: "getPropertyId",
            value: function() {
                return (o.deform << 27) + +this.attachment.id + this.slotIndex;
            }
        }, {
            key: "setFrame",
            value: function(t, e, a) {
                this.frames[t] = e, this.frameVertices[t] = a;
            }
        }, {
            key: "apply",
            value: function(a, n, i, r, s, o, h) {
                var u = a.slots[this.slotIndex], c = u.getAttachment();
                if (c instanceof t.VertexAttachment && c.applyDeform(this.attachment)) {
                    var f = u.attachmentVertices;
                    0 == f.length && (o = e.setup);
                    var d = this.frameVertices, v = d[0].length, m = this.frames;
                    if (i < m[0]) {
                        var g = c;
                        switch (o) {
                          case e.setup:
                            return void (f.length = 0);

                          case e.first:
                            if (1 == s) {
                                f.length = 0;
                                break;
                            }
                            var p = t.Utils.setArraySize(f, v);
                            if (null == g.bones) for (var y = g.vertices, M = 0; M < v; M++) p[M] += (y[M] - p[M]) * s; else for (s = 1 - s, 
                            M = 0; M < v; M++) p[M] *= s;
                        }
                    } else {
                        var x = t.Utils.setArraySize(f, v);
                        if (i >= m[m.length - 1]) {
                            var w = d[m.length - 1];
                            if (1 == s) if (o == e.add) {
                                var E = c;
                                if (null == E.bones) for (var k = E.vertices, T = 0; T < v; T++) x[T] += w[T] - k[T]; else for (var b = 0; b < v; b++) x[b] += w[b];
                            } else t.Utils.arrayCopy(w, 0, x, 0, v); else switch (o) {
                              case e.setup:
                                var A = c;
                                if (null == A.bones) for (var R = A.vertices, S = 0; S < v; S++) {
                                    var I = R[S];
                                    x[S] = I + (w[S] - I) * s;
                                } else for (var P = 0; P < v; P++) x[P] = w[P] * s;
                                break;

                              case e.first:
                              case e.replace:
                                for (var C = 0; C < v; C++) x[C] += (w[C] - x[C]) * s;

                              case e.add:
                                var V = c;
                                if (null == V.bones) for (var N = V.vertices, Y = 0; Y < v; Y++) x[Y] += (w[Y] - N[Y]) * s; else for (var X = 0; X < v; X++) x[X] += w[X] * s;
                            }
                        } else {
                            var U = l.binarySearch(m, i), L = d[U - 1], D = d[U], F = m[U], _ = this.getCurvePercent(U - 1, 1 - (i - F) / (m[U - 1] - F));
                            if (1 == s) if (o == e.add) {
                                var O = c;
                                if (null == O.bones) for (var B = O.vertices, W = 0; W < v; W++) {
                                    var q = L[W];
                                    x[W] += q + (D[W] - q) * _ - B[W];
                                } else for (var H = 0; H < v; H++) {
                                    var G = L[H];
                                    x[H] += G + (D[H] - G) * _;
                                }
                            } else for (var j = 0; j < v; j++) {
                                var z = L[j];
                                x[j] = z + (D[j] - z) * _;
                            } else switch (o) {
                              case e.setup:
                                var Z = c;
                                if (null == Z.bones) for (var J = Z.vertices, Q = 0; Q < v; Q++) {
                                    var K = L[Q], $ = J[Q];
                                    x[Q] = $ + (K + (D[Q] - K) * _ - $) * s;
                                } else for (var tt = 0; tt < v; tt++) {
                                    var et = L[tt];
                                    x[tt] = (et + (D[tt] - et) * _) * s;
                                }
                                break;

                              case e.first:
                              case e.replace:
                                for (var at = 0; at < v; at++) {
                                    var nt = L[at];
                                    x[at] += (nt + (D[at] - nt) * _ - x[at]) * s;
                                }
                                break;

                              case e.add:
                                var it = c;
                                if (null == it.bones) for (var rt = it.vertices, st = 0; st < v; st++) {
                                    var ot = L[st];
                                    x[st] += (ot + (D[st] - ot) * _ - rt[st]) * s;
                                } else for (var lt = 0; lt < v; lt++) {
                                    var ht = L[lt];
                                    x[lt] += (ht + (D[lt] - ht) * _) * s;
                                }
                            }
                        }
                    }
                }
            }
        } ]), u;
    }(h), t.EventTimeline = function() {
        function e(a) {
            r(this, e), this.frames = t.Utils.newFloatArray(a), this.events = new Array(a);
        }
        return s(e, [ {
            key: "getPropertyId",
            value: function() {
                return o.event << 24;
            }
        }, {
            key: "getFrameCount",
            value: function() {
                return this.frames.length;
            }
        }, {
            key: "setFrame",
            value: function(t, e) {
                this.frames[t] = e.time, this.events[t] = e;
            }
        }, {
            key: "apply",
            value: function(t, e, a, n, i, r, s) {
                if (null != n) {
                    var o = this.frames, h = this.frames.length;
                    if (e > a) this.apply(t, e, Number.MAX_VALUE, n, i, r, s), e = -1; else if (e >= o[h - 1]) return;
                    if (!(a < o[0])) {
                        var u = 0;
                        if (e < o[0]) u = 0; else for (var c = o[u = l.binarySearch(o, e)]; u > 0 && o[u - 1] == c; ) u--;
                        for (;u < h && a >= o[u]; u++) n.push(this.events[u]);
                    }
                }
            }
        } ]), e;
    }(), t.DrawOrderTimeline = function() {
        function n(e) {
            r(this, n), this.frames = t.Utils.newFloatArray(e), this.drawOrders = new Array(e);
        }
        return s(n, [ {
            key: "getPropertyId",
            value: function() {
                return o.drawOrder << 24;
            }
        }, {
            key: "getFrameCount",
            value: function() {
                return this.frames.length;
            }
        }, {
            key: "setFrame",
            value: function(t, e, a) {
                this.frames[t] = e, this.drawOrders[t] = a;
            }
        }, {
            key: "apply",
            value: function(n, i, r, s, o, h, u) {
                var c = n.drawOrder, f = n.slots;
                if (u != a.out || h != e.setup) {
                    var d = this.frames;
                    if (r < d[0]) h != e.setup && h != e.first || t.Utils.arrayCopy(n.slots, 0, n.drawOrder, 0, n.slots.length); else {
                        var v;
                        v = r >= d[d.length - 1] ? d.length - 1 : l.binarySearch(d, r) - 1;
                        var m = this.drawOrders[v];
                        if (null == m) t.Utils.arrayCopy(f, 0, c, 0, f.length); else for (var g = 0, p = m.length; g < p; g++) c[g] = f[m[g]];
                    }
                } else t.Utils.arrayCopy(n.slots, 0, n.drawOrder, 0, n.slots.length);
            }
        } ]), n;
    }();
    var p = function(h) {
        n(c, h);
        var u = i(c);
        function c(e) {
            var a;
            return r(this, c), (a = u.call(this, e)).frames = t.Utils.newFloatArray(e * c.ENTRIES), 
            a;
        }
        return s(c, [ {
            key: "getPropertyId",
            value: function() {
                return (o.ikConstraint << 24) + this.ikConstraintIndex;
            }
        }, {
            key: "setFrame",
            value: function(t, e, a, n, i, r) {
                t *= c.ENTRIES, this.frames[t] = e, this.frames[t + c.MIX] = a, this.frames[t + c.BEND_DIRECTION] = n, 
                this.frames[t + c.COMPRESS] = i ? 1 : 0, this.frames[t + c.STRETCH] = r ? 1 : 0;
            }
        }, {
            key: "apply",
            value: function(t, n, i, r, s, o, h) {
                var u = this.frames, f = t.ikConstraints[this.ikConstraintIndex];
                if (i < u[0]) switch (o) {
                  case e.setup:
                    return f.mix = f.data.mix, f.bendDirection = f.data.bendDirection, f.compress = f.data.compress, 
                    void (f.stretch = f.data.stretch);

                  case e.first:
                    f.mix += (f.data.mix - f.mix) * s, f.bendDirection = f.data.bendDirection, f.compress = f.data.compress, 
                    f.stretch = f.data.stretch;
                } else if (i >= u[u.length - c.ENTRIES]) o == e.setup ? (f.mix = f.data.mix + (u[u.length + c.PREV_MIX] - f.data.mix) * s, 
                h == a.out ? (f.bendDirection = f.data.bendDirection, f.compress = f.data.compress, 
                f.stretch = f.data.stretch) : (f.bendDirection = u[u.length + c.PREV_BEND_DIRECTION], 
                f.compress = 0 != u[u.length + c.PREV_COMPRESS], f.stretch = 0 != u[u.length + c.PREV_STRETCH])) : (f.mix += (u[u.length + c.PREV_MIX] - f.mix) * s, 
                h == a.in && (f.bendDirection = u[u.length + c.PREV_BEND_DIRECTION], f.compress = 0 != u[u.length + c.PREV_COMPRESS], 
                f.stretch = 0 != u[u.length + c.PREV_STRETCH])); else {
                    var d = l.binarySearch(u, i, c.ENTRIES), v = u[d + c.PREV_MIX], m = u[d], g = this.getCurvePercent(d / c.ENTRIES - 1, 1 - (i - m) / (u[d + c.PREV_TIME] - m));
                    o == e.setup ? (f.mix = f.data.mix + (v + (u[d + c.MIX] - v) * g - f.data.mix) * s, 
                    h == a.out ? (f.bendDirection = f.data.bendDirection, f.compress = f.data.compress, 
                    f.stretch = f.data.stretch) : (f.bendDirection = u[d + c.PREV_BEND_DIRECTION], f.compress = 0 != u[d + c.PREV_COMPRESS], 
                    f.stretch = 0 != u[d + c.PREV_STRETCH])) : (f.mix += (v + (u[d + c.MIX] - v) * g - f.mix) * s, 
                    h == a.in && (f.bendDirection = u[d + c.PREV_BEND_DIRECTION], f.compress = 0 != u[d + c.PREV_COMPRESS], 
                    f.stretch = 0 != u[d + c.PREV_STRETCH]));
                }
            }
        } ]), c;
    }(h);
    p.ENTRIES = 5, p.PREV_TIME = -5, p.PREV_MIX = -4, p.PREV_BEND_DIRECTION = -3, p.PREV_COMPRESS = -2, 
    p.PREV_STRETCH = -1, p.MIX = 1, p.BEND_DIRECTION = 2, p.COMPRESS = 3, p.STRETCH = 4, 
    t.IkConstraintTimeline = p;
    var y = function(a) {
        n(u, a);
        var h = i(u);
        function u(e) {
            var a;
            return r(this, u), (a = h.call(this, e)).frames = t.Utils.newFloatArray(e * u.ENTRIES), 
            a;
        }
        return s(u, [ {
            key: "getPropertyId",
            value: function() {
                return (o.transformConstraint << 24) + this.transformConstraintIndex;
            }
        }, {
            key: "setFrame",
            value: function(t, e, a, n, i, r) {
                t *= u.ENTRIES, this.frames[t] = e, this.frames[t + u.ROTATE] = a, this.frames[t + u.TRANSLATE] = n, 
                this.frames[t + u.SCALE] = i, this.frames[t + u.SHEAR] = r;
            }
        }, {
            key: "apply",
            value: function(t, a, n, i, r, s, o) {
                var h = this.frames, c = t.transformConstraints[this.transformConstraintIndex];
                if (n < h[0]) {
                    var f = c.data;
                    switch (s) {
                      case e.setup:
                        return c.rotateMix = f.rotateMix, c.translateMix = f.translateMix, c.scaleMix = f.scaleMix, 
                        void (c.shearMix = f.shearMix);

                      case e.first:
                        c.rotateMix += (f.rotateMix - c.rotateMix) * r, c.translateMix += (f.translateMix - c.translateMix) * r, 
                        c.scaleMix += (f.scaleMix - c.scaleMix) * r, c.shearMix += (f.shearMix - c.shearMix) * r;
                    }
                } else {
                    var d = 0, v = 0, m = 0, g = 0;
                    if (n >= h[h.length - u.ENTRIES]) {
                        var p = h.length;
                        d = h[p + u.PREV_ROTATE], v = h[p + u.PREV_TRANSLATE], m = h[p + u.PREV_SCALE], 
                        g = h[p + u.PREV_SHEAR];
                    } else {
                        var y = l.binarySearch(h, n, u.ENTRIES);
                        d = h[y + u.PREV_ROTATE], v = h[y + u.PREV_TRANSLATE], m = h[y + u.PREV_SCALE], 
                        g = h[y + u.PREV_SHEAR];
                        var M = h[y], x = this.getCurvePercent(y / u.ENTRIES - 1, 1 - (n - M) / (h[y + u.PREV_TIME] - M));
                        d += (h[y + u.ROTATE] - d) * x, v += (h[y + u.TRANSLATE] - v) * x, m += (h[y + u.SCALE] - m) * x, 
                        g += (h[y + u.SHEAR] - g) * x;
                    }
                    if (s == e.setup) {
                        var w = c.data;
                        c.rotateMix = w.rotateMix + (d - w.rotateMix) * r, c.translateMix = w.translateMix + (v - w.translateMix) * r, 
                        c.scaleMix = w.scaleMix + (m - w.scaleMix) * r, c.shearMix = w.shearMix + (g - w.shearMix) * r;
                    } else c.rotateMix += (d - c.rotateMix) * r, c.translateMix += (v - c.translateMix) * r, 
                    c.scaleMix += (m - c.scaleMix) * r, c.shearMix += (g - c.shearMix) * r;
                }
            }
        } ]), u;
    }(h);
    y.ENTRIES = 5, y.PREV_TIME = -5, y.PREV_ROTATE = -4, y.PREV_TRANSLATE = -3, y.PREV_SCALE = -2, 
    y.PREV_SHEAR = -1, y.ROTATE = 1, y.TRANSLATE = 2, y.SCALE = 3, y.SHEAR = 4, t.TransformConstraintTimeline = y;
    var M = function(a) {
        n(u, a);
        var h = i(u);
        function u(e) {
            var a;
            return r(this, u), (a = h.call(this, e)).frames = t.Utils.newFloatArray(e * u.ENTRIES), 
            a;
        }
        return s(u, [ {
            key: "getPropertyId",
            value: function() {
                return (o.pathConstraintPosition << 24) + this.pathConstraintIndex;
            }
        }, {
            key: "setFrame",
            value: function(t, e, a) {
                t *= u.ENTRIES, this.frames[t] = e, this.frames[t + u.VALUE] = a;
            }
        }, {
            key: "apply",
            value: function(t, a, n, i, r, s, o) {
                var h = this.frames, c = t.pathConstraints[this.pathConstraintIndex];
                if (n < h[0]) switch (s) {
                  case e.setup:
                    return void (c.position = c.data.position);

                  case e.first:
                    c.position += (c.data.position - c.position) * r;
                } else {
                    var f = 0;
                    if (n >= h[h.length - u.ENTRIES]) f = h[h.length + u.PREV_VALUE]; else {
                        var d = l.binarySearch(h, n, u.ENTRIES);
                        f = h[d + u.PREV_VALUE];
                        var v = h[d], m = this.getCurvePercent(d / u.ENTRIES - 1, 1 - (n - v) / (h[d + u.PREV_TIME] - v));
                        f += (h[d + u.VALUE] - f) * m;
                    }
                    s == e.setup ? c.position = c.data.position + (f - c.data.position) * r : c.position += (f - c.position) * r;
                }
            }
        } ]), u;
    }(h);
    M.ENTRIES = 2, M.PREV_TIME = -2, M.PREV_VALUE = -1, M.VALUE = 1, t.PathConstraintPositionTimeline = M;
    var x = function(t) {
        n(h, t);
        var a = i(h);
        function h(t) {
            return r(this, h), a.call(this, t);
        }
        return s(h, [ {
            key: "getPropertyId",
            value: function() {
                return (o.pathConstraintSpacing << 24) + this.pathConstraintIndex;
            }
        }, {
            key: "apply",
            value: function(t, a, n, i, r, s, o) {
                var u = this.frames, c = t.pathConstraints[this.pathConstraintIndex];
                if (n < u[0]) switch (s) {
                  case e.setup:
                    return void (c.spacing = c.data.spacing);

                  case e.first:
                    c.spacing += (c.data.spacing - c.spacing) * r;
                } else {
                    var f = 0;
                    if (n >= u[u.length - h.ENTRIES]) f = u[u.length + h.PREV_VALUE]; else {
                        var d = l.binarySearch(u, n, h.ENTRIES);
                        f = u[d + h.PREV_VALUE];
                        var v = u[d], m = this.getCurvePercent(d / h.ENTRIES - 1, 1 - (n - v) / (u[d + h.PREV_TIME] - v));
                        f += (u[d + h.VALUE] - f) * m;
                    }
                    s == e.setup ? c.spacing = c.data.spacing + (f - c.data.spacing) * r : c.spacing += (f - c.spacing) * r;
                }
            }
        } ]), h;
    }(M);
    t.PathConstraintSpacingTimeline = x;
    var w = function(a) {
        n(u, a);
        var h = i(u);
        function u(e) {
            var a;
            return r(this, u), (a = h.call(this, e)).frames = t.Utils.newFloatArray(e * u.ENTRIES), 
            a;
        }
        return s(u, [ {
            key: "getPropertyId",
            value: function() {
                return (o.pathConstraintMix << 24) + this.pathConstraintIndex;
            }
        }, {
            key: "setFrame",
            value: function(t, e, a, n) {
                t *= u.ENTRIES, this.frames[t] = e, this.frames[t + u.ROTATE] = a, this.frames[t + u.TRANSLATE] = n;
            }
        }, {
            key: "apply",
            value: function(t, a, n, i, r, s, o) {
                var h = this.frames, c = t.pathConstraints[this.pathConstraintIndex];
                if (n < h[0]) switch (s) {
                  case e.setup:
                    return c.rotateMix = c.data.rotateMix, void (c.translateMix = c.data.translateMix);

                  case e.first:
                    c.rotateMix += (c.data.rotateMix - c.rotateMix) * r, c.translateMix += (c.data.translateMix - c.translateMix) * r;
                } else {
                    var f = 0, d = 0;
                    if (n >= h[h.length - u.ENTRIES]) f = h[h.length + u.PREV_ROTATE], d = h[h.length + u.PREV_TRANSLATE]; else {
                        var v = l.binarySearch(h, n, u.ENTRIES);
                        f = h[v + u.PREV_ROTATE], d = h[v + u.PREV_TRANSLATE];
                        var m = h[v], g = this.getCurvePercent(v / u.ENTRIES - 1, 1 - (n - m) / (h[v + u.PREV_TIME] - m));
                        f += (h[v + u.ROTATE] - f) * g, d += (h[v + u.TRANSLATE] - d) * g;
                    }
                    s == e.setup ? (c.rotateMix = c.data.rotateMix + (f - c.data.rotateMix) * r, c.translateMix = c.data.translateMix + (d - c.data.translateMix) * r) : (c.rotateMix += (f - c.rotateMix) * r, 
                    c.translateMix += (d - c.translateMix) * r);
                }
            }
        } ]), u;
    }(h);
    w.ENTRIES = 3, w.PREV_TIME = -3, w.PREV_ROTATE = -2, w.PREV_TRANSLATE = -1, w.ROTATE = 1, 
    w.TRANSLATE = 2, t.PathConstraintMixTimeline = w;
}(t || (t = {})), function(t) {
    var e = function() {
        function e(n) {
            r(this, e), this.tracks = new Array(), this.events = new Array(), this.listeners = new Array(), 
            this.queue = new i(this), this.propertyIDs = new t.IntSet(), this.animationsChanged = !1, 
            this.timeScale = 1, this.trackEntryPool = new t.Pool(function() {
                return new a();
            }), this.data = n;
        }
        return s(e, [ {
            key: "update",
            value: function(t) {
                t *= this.timeScale;
                for (var e = this.tracks, a = 0, n = e.length; a < n; a++) {
                    var i = e[a];
                    if (null != i) {
                        i.animationLast = i.nextAnimationLast, i.trackLast = i.nextTrackLast;
                        var r = t * i.timeScale;
                        if (i.delay > 0) {
                            if (i.delay -= r, i.delay > 0) continue;
                            r = -i.delay, i.delay = 0;
                        }
                        var s = i.next;
                        if (null != s) {
                            var o = i.trackLast - s.delay;
                            if (o >= 0) {
                                for (s.delay = 0, s.trackTime = 0 == i.timeScale ? 0 : (o / i.timeScale + t) * s.timeScale, 
                                i.trackTime += r, this.setCurrent(a, s, !0); null != s.mixingFrom; ) s.mixTime += t, 
                                s = s.mixingFrom;
                                continue;
                            }
                        } else if (i.trackLast >= i.trackEnd && null == i.mixingFrom) {
                            e[a] = null, this.queue.end(i), this.disposeNext(i);
                            continue;
                        }
                        if (null != i.mixingFrom && this.updateMixingFrom(i, t)) {
                            var l = i.mixingFrom;
                            for (i.mixingFrom = null, null != l && (l.mixingTo = null); null != l; ) this.queue.end(l), 
                            l = l.mixingFrom;
                        }
                        i.trackTime += r;
                    }
                }
                this.queue.drain();
            }
        }, {
            key: "updateMixingFrom",
            value: function(t, e) {
                var a = t.mixingFrom;
                if (null == a) return !0;
                var n = this.updateMixingFrom(a, e);
                return a.animationLast = a.nextAnimationLast, a.trackLast = a.nextTrackLast, t.mixTime > 0 && t.mixTime >= t.mixDuration ? (0 != a.totalAlpha && 0 != t.mixDuration || (t.mixingFrom = a.mixingFrom, 
                null != a.mixingFrom && (a.mixingFrom.mixingTo = t), t.interruptAlpha = a.interruptAlpha, 
                this.queue.end(a)), n) : (a.trackTime += e * a.timeScale, t.mixTime += e, !1);
            }
        }, {
            key: "apply",
            value: function(a) {
                if (null == a) throw new Error("skeleton cannot be null.");
                this.animationsChanged && this._animationsChanged();
                for (var n = this.events, i = this.tracks, r = !1, s = 0, o = i.length; s < o; s++) {
                    var l = i[s];
                    if (!(null == l || l.delay > 0)) {
                        r = !0;
                        var h = 0 == s ? t.MixBlend.first : l.mixBlend, u = l.alpha;
                        null != l.mixingFrom ? u *= this.applyMixingFrom(l, a, h) : l.trackTime >= l.trackEnd && null == l.next && (u = 0);
                        var c = l.animationLast, f = l.getAnimationTime(), d = l.animation.timelines.length, v = l.animation.timelines;
                        if (0 == s && 1 == u || h == t.MixBlend.add) for (var m = 0; m < d; m++) v[m].apply(a, c, f, n, u, h, t.MixDirection.in); else {
                            var g = l.timelineMode, p = 0 == l.timelinesRotation.length;
                            p && t.Utils.setArraySize(l.timelinesRotation, d << 1, null);
                            for (var y = l.timelinesRotation, M = 0; M < d; M++) {
                                var x = v[M], w = g[M] == e.SUBSEQUENT ? h : t.MixBlend.setup;
                                x instanceof t.RotateTimeline ? this.applyRotateTimeline(x, a, f, u, w, y, M << 1, p) : (t.Utils.webkit602BugfixHelper(u, h), 
                                x.apply(a, c, f, n, u, w, t.MixDirection.in));
                            }
                        }
                        this.queueEvents(l, f), n.length = 0, l.nextAnimationLast = f, l.nextTrackLast = l.trackTime;
                    }
                }
                return this.queue.drain(), r;
            }
        }, {
            key: "applyMixingFrom",
            value: function(a, n, i) {
                var r = a.mixingFrom;
                null != r.mixingFrom && this.applyMixingFrom(r, n, i);
                var s = 0;
                0 == a.mixDuration ? (s = 1, i == t.MixBlend.first && (i = t.MixBlend.setup)) : ((s = a.mixTime / a.mixDuration) > 1 && (s = 1), 
                i != t.MixBlend.first && (i = r.mixBlend));
                var o = s < r.eventThreshold ? this.events : null, l = s < r.attachmentThreshold, h = s < r.drawOrderThreshold, u = r.animationLast, c = r.getAnimationTime(), f = r.animation.timelines.length, d = r.animation.timelines, v = r.alpha * a.interruptAlpha, m = v * (1 - s);
                if (i == t.MixBlend.add) for (var g = 0; g < f; g++) d[g].apply(n, u, c, o, m, i, t.MixDirection.out); else {
                    r.timelineMode;
                    var p = r.timelineHoldMix, y = 0 == r.timelinesRotation.length;
                    y && t.Utils.setArraySize(r.timelinesRotation, f << 1, null);
                    var M = r.timelinesRotation;
                    r.totalAlpha = 0;
                    for (var x = 0; x < f; x++) {
                        var w = void 0, E = d[x], k = t.MixDirection.out, T = 0;
                        switch (a[x]) {
                          case e.SUBSEQUENT:
                            if (!l && E instanceof t.AttachmentTimeline) continue;
                            if (!h && E instanceof t.DrawOrderTimeline) continue;
                            w = i, T = m;
                            break;

                          case e.FIRST:
                            w = t.MixBlend.setup, T = m;
                            break;

                          case e.HOLD:
                            w = t.MixBlend.setup, T = v;
                            break;

                          default:
                            w = t.MixBlend.setup;
                            var b = p[x];
                            T = v * Math.max(0, 1 - b.mixTime / b.mixDuration);
                        }
                        r.totalAlpha += T, E instanceof t.RotateTimeline ? this.applyRotateTimeline(E, n, c, T, w, M, x << 1, y) : (t.Utils.webkit602BugfixHelper(T, i), 
                        w == t.MixBlend.setup && (E instanceof t.AttachmentTimeline ? l && (k = t.MixDirection.out) : E instanceof t.DrawOrderTimeline && h && (k = t.MixDirection.out)), 
                        E.apply(n, u, c, o, T, w, k));
                    }
                }
                return a.mixDuration > 0 && this.queueEvents(r, c), this.events.length = 0, r.nextAnimationLast = c, 
                r.nextTrackLast = r.trackTime, s;
            }
        }, {
            key: "applyRotateTimeline",
            value: function(e, a, n, i, r, s, o, l) {
                if (l && (s[o] = 0), 1 != i) {
                    var h = e, u = h.frames, c = a.bones[h.boneIndex], f = 0, d = 0;
                    if (n < u[0]) switch (r) {
                      case t.MixBlend.setup:
                        c.rotation = c.data.rotation;

                      default:
                        return;

                      case t.MixBlend.first:
                        f = c.rotation, d = c.data.rotation;
                    } else if (f = r == t.MixBlend.setup ? c.data.rotation : c.rotation, n >= u[u.length - t.RotateTimeline.ENTRIES]) d = c.data.rotation + u[u.length + t.RotateTimeline.PREV_ROTATION]; else {
                        var v = t.Animation.binarySearch(u, n, t.RotateTimeline.ENTRIES), m = u[v + t.RotateTimeline.PREV_ROTATION], g = u[v], p = h.getCurvePercent((v >> 1) - 1, 1 - (n - g) / (u[v + t.RotateTimeline.PREV_TIME] - g));
                        d = u[v + t.RotateTimeline.ROTATION] - m, d = m + (d -= 360 * (16384 - (16384.499999999996 - d / 360 | 0))) * p + c.data.rotation, 
                        d -= 360 * (16384 - (16384.499999999996 - d / 360 | 0));
                    }
                    var y = 0, M = d - f;
                    if (0 == (M -= 360 * (16384 - (16384.499999999996 - M / 360 | 0)))) y = s[o]; else {
                        var x = 0, w = 0;
                        l ? (x = 0, w = M) : (x = s[o], w = s[o + 1]);
                        var E = M > 0, k = x >= 0;
                        t.MathUtils.signum(w) != t.MathUtils.signum(M) && Math.abs(w) <= 90 && (Math.abs(x) > 180 && (x += 360 * t.MathUtils.signum(x)), 
                        k = E), y = M + x - x % 360, k != E && (y += 360 * t.MathUtils.signum(x)), s[o] = y;
                    }
                    s[o + 1] = M, f += y * i, c.rotation = f - 360 * (16384 - (16384.499999999996 - f / 360 | 0));
                } else e.apply(a, 0, n, null, 1, r, t.MixDirection.in);
            }
        }, {
            key: "queueEvents",
            value: function(t, e) {
                for (var a = t.animationStart, n = t.animationEnd, i = n - a, r = t.trackLast % i, s = this.events, o = 0, l = s.length; o < l; o++) {
                    var h = s[o];
                    if (h.time < r) break;
                    h.time > n || this.queue.event(t, h);
                }
                for ((t.loop ? 0 == i || r > t.trackTime % i : e >= n && t.animationLast < n) && this.queue.complete(t); o < l; o++) s[o].time < a || this.queue.event(t, s[o]);
            }
        }, {
            key: "clearTracks",
            value: function() {
                var t = this.queue.drainDisabled;
                this.queue.drainDisabled = !0;
                for (var e = 0, a = this.tracks.length; e < a; e++) this.clearTrack(e);
                this.tracks.length = 0, this.queue.drainDisabled = t, this.queue.drain();
            }
        }, {
            key: "clearTrack",
            value: function(t) {
                if (!(t >= this.tracks.length)) {
                    var e = this.tracks[t];
                    if (null != e) {
                        this.queue.end(e), this.disposeNext(e);
                        for (var a = e; ;) {
                            var n = a.mixingFrom;
                            if (null == n) break;
                            this.queue.end(n), a.mixingFrom = null, a.mixingTo = null, a = n;
                        }
                        this.tracks[e.trackIndex] = null, this.queue.drain();
                    }
                }
            }
        }, {
            key: "setCurrent",
            value: function(t, e, a) {
                var n = this.expandToIndex(t);
                this.tracks[t] = e, null != n && (a && this.queue.interrupt(n), e.mixingFrom = n, 
                n.mixingTo = e, e.mixTime = 0, null != n.mixingFrom && n.mixDuration > 0 && (e.interruptAlpha *= Math.min(1, n.mixTime / n.mixDuration)), 
                n.timelinesRotation.length = 0), this.queue.start(e);
            }
        }, {
            key: "setAnimation",
            value: function(t, e, a) {
                var n = this.data.skeletonData.findAnimation(e);
                if (null == n) throw new Error("Animation not found: " + e);
                return this.setAnimationWith(t, n, a);
            }
        }, {
            key: "setAnimationWith",
            value: function(t, e, a) {
                if (null == e) throw new Error("animation cannot be null.");
                var n = !0, i = this.expandToIndex(t);
                null != i && (-1 == i.nextTrackLast ? (this.tracks[t] = i.mixingFrom, this.queue.interrupt(i), 
                this.queue.end(i), this.disposeNext(i), i = i.mixingFrom, n = !1) : this.disposeNext(i));
                var r = this.trackEntry(t, e, a, i);
                return this.setCurrent(t, r, n), this.queue.drain(), r;
            }
        }, {
            key: "addAnimation",
            value: function(t, e, a, n) {
                var i = this.data.skeletonData.findAnimation(e);
                if (null == i) throw new Error("Animation not found: " + e);
                return this.addAnimationWith(t, i, a, n);
            }
        }, {
            key: "addAnimationWith",
            value: function(t, e, a, n) {
                if (null == e) throw new Error("animation cannot be null.");
                var i = this.expandToIndex(t);
                if (null != i) for (;null != i.next; ) i = i.next;
                var r = this.trackEntry(t, e, a, i);
                if (null == i) this.setCurrent(t, r, !0), this.queue.drain(); else if (i.next = r, 
                n <= 0) {
                    var s = i.animationEnd - i.animationStart;
                    0 != s ? (i.loop ? n += s * (1 + (i.trackTime / s | 0)) : n += Math.max(s, i.trackTime), 
                    n -= this.data.getMix(i.animation, e)) : n = i.trackTime;
                }
                return r.delay = n, r;
            }
        }, {
            key: "setEmptyAnimation",
            value: function(t, a) {
                var n = this.setAnimationWith(t, e.emptyAnimation, !1);
                return n.mixDuration = a, n.trackEnd = a, n;
            }
        }, {
            key: "addEmptyAnimation",
            value: function(t, a, n) {
                n <= 0 && (n -= a);
                var i = this.addAnimationWith(t, e.emptyAnimation, !1, n);
                return i.mixDuration = a, i.trackEnd = a, i;
            }
        }, {
            key: "setEmptyAnimations",
            value: function(t) {
                var e = this.queue.drainDisabled;
                this.queue.drainDisabled = !0;
                for (var a = 0, n = this.tracks.length; a < n; a++) {
                    var i = this.tracks[a];
                    null != i && this.setEmptyAnimation(i.trackIndex, t);
                }
                this.queue.drainDisabled = e, this.queue.drain();
            }
        }, {
            key: "expandToIndex",
            value: function(e) {
                return e < this.tracks.length ? this.tracks[e] : (t.Utils.ensureArrayCapacity(this.tracks, e + 1, null), 
                this.tracks.length = e + 1, null);
            }
        }, {
            key: "trackEntry",
            value: function(t, e, a, n) {
                var i = this.trackEntryPool.obtain();
                return i.trackIndex = t, i.animation = e, i.loop = a, i.holdPrevious = !1, i.eventThreshold = 0, 
                i.attachmentThreshold = 0, i.drawOrderThreshold = 0, i.animationStart = 0, i.animationEnd = e.duration, 
                i.animationLast = -1, i.nextAnimationLast = -1, i.delay = 0, i.trackTime = 0, i.trackLast = -1, 
                i.nextTrackLast = -1, i.trackEnd = Number.MAX_VALUE, i.timeScale = 1, i.alpha = 1, 
                i.interruptAlpha = 1, i.mixTime = 0, i.mixDuration = null == n ? 0 : this.data.getMix(n.animation, e), 
                i;
            }
        }, {
            key: "disposeNext",
            value: function(t) {
                for (var e = t.next; null != e; ) this.queue.dispose(e), e = e.next;
                t.next = null;
            }
        }, {
            key: "_animationsChanged",
            value: function() {
                this.animationsChanged = !1, this.propertyIDs.clear();
                for (var e = 0, a = this.tracks.length; e < a; e++) {
                    var n = this.tracks[e];
                    if (null != n) {
                        for (;null != n.mixingFrom; ) n = n.mixingFrom;
                        do {
                            null != n.mixingFrom && n.mixBlend == t.MixBlend.add || this.setTimelineModes(n), 
                            n = n.mixingTo;
                        } while (null != n);
                    }
                }
            }
        }, {
            key: "setTimelineModes",
            value: function(a) {
                var n = a.mixingTo, i = a.animation.timelines, r = a.animation.timelines.length, s = t.Utils.setArraySize(a.timelineMode, r);
                a.timelineHoldMix.length = 0;
                var o = t.Utils.setArraySize(a.timelineHoldMix, r), l = this.propertyIDs;
                if (null != n && n.holdPrevious) for (var h = 0; h < r; h++) l.add(i[h].getPropertyId()), 
                s[h] = e.HOLD; else t: for (var u = 0; u < r; u++) {
                    var c = i[u].getPropertyId();
                    if (l.add(c)) if (null != n && this.hasTimeline(n, c)) {
                        for (var f = n.mixingTo; null != f; f = f.mixingTo) if (!this.hasTimeline(f, c)) {
                            if (a.mixDuration > 0) {
                                s[u] = e.HOLD_MIX, o[u] = f;
                                continue t;
                            }
                            break;
                        }
                        s[u] = e.HOLD;
                    } else s[u] = e.FIRST; else s[u] = e.SUBSEQUENT;
                }
            }
        }, {
            key: "hasTimeline",
            value: function(t, e) {
                for (var a = t.animation.timelines, n = 0, i = a.length; n < i; n++) if (a[n].getPropertyId() == e) return !0;
                return !1;
            }
        }, {
            key: "getCurrent",
            value: function(t) {
                return t >= this.tracks.length ? null : this.tracks[t];
            }
        }, {
            key: "addListener",
            value: function(t) {
                if (null == t) throw new Error("listener cannot be null.");
                this.listeners.push(t);
            }
        }, {
            key: "removeListener",
            value: function(t) {
                var e = this.listeners.indexOf(t);
                e >= 0 && this.listeners.splice(e, 1);
            }
        }, {
            key: "clearListeners",
            value: function() {
                this.listeners.length = 0;
            }
        }, {
            key: "clearListenerNotifications",
            value: function() {
                this.queue.clear();
            }
        } ]), e;
    }();
    e.emptyAnimation = new t.Animation("<empty>", [], 0), e.SUBSEQUENT = 0, e.FIRST = 1, 
    e.HOLD = 2, e.HOLD_MIX = 3, t.AnimationState = e;
    var a = function() {
        function e() {
            r(this, e), this.mixBlend = t.MixBlend.replace, this.timelineMode = new Array(), 
            this.timelineHoldMix = new Array(), this.timelinesRotation = new Array();
        }
        return s(e, [ {
            key: "reset",
            value: function() {
                this.next = null, this.mixingFrom = null, this.mixingTo = null, this.animation = null, 
                this.listener = null, this.timelineMode.length = 0, this.timelineHoldMix.length = 0, 
                this.timelinesRotation.length = 0;
            }
        }, {
            key: "getAnimationTime",
            value: function() {
                if (this.loop) {
                    var t = this.animationEnd - this.animationStart;
                    return 0 == t ? this.animationStart : this.trackTime % t + this.animationStart;
                }
                return Math.min(this.trackTime + this.animationStart, this.animationEnd);
            }
        }, {
            key: "setAnimationLast",
            value: function(t) {
                this.animationLast = t, this.nextAnimationLast = t;
            }
        }, {
            key: "isComplete",
            value: function() {
                return this.trackTime >= this.animationEnd - this.animationStart;
            }
        }, {
            key: "resetRotationDirections",
            value: function() {
                this.timelinesRotation.length = 0;
            }
        } ]), e;
    }();
    t.TrackEntry = a;
    var n, i = function() {
        function t(e) {
            r(this, t), this.objects = [], this.drainDisabled = !1, this.animState = e;
        }
        return s(t, [ {
            key: "start",
            value: function(t) {
                this.objects.push(n.start), this.objects.push(t), this.animState.animationsChanged = !0;
            }
        }, {
            key: "interrupt",
            value: function(t) {
                this.objects.push(n.interrupt), this.objects.push(t);
            }
        }, {
            key: "end",
            value: function(t) {
                this.objects.push(n.end), this.objects.push(t), this.animState.animationsChanged = !0;
            }
        }, {
            key: "dispose",
            value: function(t) {
                this.objects.push(n.dispose), this.objects.push(t);
            }
        }, {
            key: "complete",
            value: function(t) {
                this.objects.push(n.complete), this.objects.push(t);
            }
        }, {
            key: "event",
            value: function(t, e) {
                this.objects.push(n.event), this.objects.push(t), this.objects.push(e);
            }
        }, {
            key: "drain",
            value: function() {
                if (!this.drainDisabled) {
                    this.drainDisabled = !0;
                    for (var e = this.objects, a = this.animState.listeners, i = 0; i < e.length; i += 2) {
                        e[i];
                        var r = e[i + 1];
                        switch (t) {
                          case n.start:
                            null != r.listener && r.listener.start && r.listener.start(r);
                            for (var s = 0; s < a.length; s++) a[s].start && a[s].start(r);
                            break;

                          case n.interrupt:
                            null != r.listener && r.listener.interrupt && r.listener.interrupt(r);
                            for (var o = 0; o < a.length; o++) a[o].interrupt && a[o].interrupt(r);
                            break;

                          case n.end:
                            null != r.listener && r.listener.end && r.listener.end(r);
                            for (var l = 0; l < a.length; l++) a[l].end && a[l].end(r);

                          case n.dispose:
                            null != r.listener && r.listener.dispose && r.listener.dispose(r);
                            for (var h = 0; h < a.length; h++) a[h].dispose && a[h].dispose(r);
                            this.animState.trackEntryPool.free(r);
                            break;

                          case n.complete:
                            null != r.listener && r.listener.complete && r.listener.complete(r);
                            for (var u = 0; u < a.length; u++) a[u].complete && a[u].complete(r);
                            break;

                          case n.event:
                            var c = e[2 + i++];
                            null != r.listener && r.listener.event && r.listener.event(r, c);
                            for (var f = 0; f < a.length; f++) a[f].event && a[f].event(r, c);
                        }
                    }
                    this.clear(), this.drainDisabled = !1;
                }
            }
        }, {
            key: "clear",
            value: function() {
                this.objects.length = 0;
            }
        } ]), t;
    }();
    t.EventQueue = i, function(t) {
        t[t.start = 0] = "start", t[t.interrupt = 1] = "interrupt", t[t.end = 2] = "end", 
        t[t.dispose = 3] = "dispose", t[t.complete = 4] = "complete", t[t.event = 5] = "event";
    }(n = t.EventType || (t.EventType = {})), t.AnimationStateAdapter2 = function() {
        function t() {
            r(this, t);
        }
        return s(t, [ {
            key: "start",
            value: function(t) {}
        }, {
            key: "interrupt",
            value: function(t) {}
        }, {
            key: "end",
            value: function(t) {}
        }, {
            key: "dispose",
            value: function(t) {}
        }, {
            key: "complete",
            value: function(t) {}
        }, {
            key: "event",
            value: function(t, e) {}
        } ]), t;
    }();
}(t || (t = {})), (t || (t = {})).AnimationStateData = function() {
    function t(e) {
        if (r(this, t), this.animationToMixTime = {}, this.defaultMix = 0, null == e) throw new Error("skeletonData cannot be null.");
        this.skeletonData = e;
    }
    return s(t, [ {
        key: "setMix",
        value: function(t, e, a) {
            var n = this.skeletonData.findAnimation(t);
            if (null == n) throw new Error("Animation not found: " + t);
            var i = this.skeletonData.findAnimation(e);
            if (null == i) throw new Error("Animation not found: " + e);
            this.setMixWith(n, i, a);
        }
    }, {
        key: "setMixWith",
        value: function(t, e, a) {
            if (null == t) throw new Error("from cannot be null.");
            if (null == e) throw new Error("to cannot be null.");
            var n = t.name + "." + e.name;
            this.animationToMixTime[n] = a;
        }
    }, {
        key: "getMix",
        value: function(t, e) {
            var a = t.name + "." + e.name, n = this.animationToMixTime[a];
            return void 0 === n ? this.defaultMix : n;
        }
    } ]), t;
}(), e = t || (t = {}), a = function() {
    function t(e) {
        var a = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "";
        r(this, t), this.assets = {}, this.errors = {}, this.toLoad = 0, this.loaded = 0, 
        this.textureLoader = e, this.pathPrefix = a;
    }
    return s(t, [ {
        key: "loadText",
        value: function(e) {
            var a = this, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
            e = this.pathPrefix + e, this.toLoad++, t.downloadText(e, function(t) {
                a.assets[e] = t, n && n(e, t), a.toLoad--, a.loaded++;
            }, function(t, n) {
                a.errors[e] = "Couldn't load text ".concat(e, ": status ").concat(status, ", ").concat(n), 
                i && i(e, "Couldn't load text ".concat(e, ": status ").concat(status, ", ").concat(n)), 
                a.toLoad--, a.loaded++;
            });
        }
    }, {
        key: "loadTexture",
        value: function(t) {
            var e = this, a = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
            t = this.pathPrefix + t, this.toLoad++;
            var i = Laya.Laya ? Laya.Laya : Laya;
            i.loader.load([ {
                type: i.Loader.IMAGE,
                url: t
            } ], i.Handler.create(this, function(r) {
                if (r) {
                    var s = e.textureLoader(i.loader.getRes(t));
                    e.assets[t] = s, e.toLoad--, e.loaded++, a && a(t, s);
                } else e.errors[t] = "Couldn't load image " + t, e.toLoad--, e.loaded++, n && n(t, "Couldn't load image " + t);
            }));
        }
    }, {
        key: "loadTextureData",
        value: function(t, e) {
            var a = this, n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;
            t = this.pathPrefix + t, this.toLoad++;
            var r = new Image();
            r.onload = function(e) {
                var i = a.textureLoader(r);
                a.assets[t] = i, a.toLoad--, a.loaded++, n && n(t, r);
            }, r.onerror = function(e) {
                a.errors[t] = "Couldn't load image " + t, a.toLoad--, a.loaded++, i && i(t, "Couldn't load image " + t);
            }, r.src = e;
        }
    }, {
        key: "loadTextureAtlas",
        value: function(a) {
            var n = this, i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, s = a.lastIndexOf("/") >= 0 ? a.substring(0, a.lastIndexOf("/")) : "";
            a = this.pathPrefix + a, this.toLoad++, t.downloadText(a, function(t) {
                var o = {
                    count: 0
                }, l = new Array();
                try {
                    new e.TextureAtlas(t, function(t) {
                        l.push("" == s ? t : s + "/" + t);
                        var a = document.createElement("img");
                        return new e.FakeTexture(a);
                    });
                } catch (t) {
                    t = VM2_INTERNAL_STATE_DO_NOT_USE_OR_PROGRAM_WILL_FAIL.handleException(t);
                    var h = t;
                    return n.errors[a] = "Couldn't load texture atlas ".concat(a, ": ").concat(h.message), 
                    r && r(a, "Couldn't load texture atlas ".concat(a, ": ").concat(h.message)), n.toLoad--, 
                    void n.loaded++;
                }
                for (var u = function() {
                    var h = f[c], u = !1;
                    n.loadTexture(h, function(h, c) {
                        if (o.count++, o.count == l.length) if (u) n.errors[a] = "Couldn't load texture atlas page ".concat(h, "} of atlas ").concat(a), 
                        r && r(a, "Couldn't load texture atlas page ".concat(h, " of atlas ").concat(a)), 
                        n.toLoad--, n.loaded++; else try {
                            var f = new e.TextureAtlas(t, function(t) {
                                return n.get("" == s ? t : s + "/" + t);
                            });
                            n.assets[a] = f, i && i(a, f), n.toLoad--, n.loaded++;
                        } catch (t) {
                            t = VM2_INTERNAL_STATE_DO_NOT_USE_OR_PROGRAM_WILL_FAIL.handleException(t);
                            var d = t;
                            n.errors[a] = "Couldn't load texture atlas ".concat(a, ": ").concat(d.message), 
                            r && r(a, "Couldn't load texture atlas ".concat(a, ": ").concat(d.message)), n.toLoad--, 
                            n.loaded++;
                        }
                    }, function(t, e) {
                        u = !0, o.count++, o.count == l.length && (n.errors[a] = "Couldn't load texture atlas page ".concat(t, "} of atlas ").concat(a), 
                        r && r(a, "Couldn't load texture atlas page ".concat(t, " of atlas ").concat(a)), 
                        n.toLoad--, n.loaded++);
                    });
                }, c = 0, f = l; c < f.length; c++) u();
            }, function(t, e) {
                n.errors[a] = "Couldn't load texture atlas ".concat(a, ": status ").concat(status, ", ").concat(e), 
                r && r(a, "Couldn't load texture atlas ".concat(a, ": status ").concat(status, ", ").concat(e)), 
                n.toLoad--, n.loaded++;
            });
        }
    }, {
        key: "get",
        value: function(t) {
            return t = this.pathPrefix + t, this.assets[t];
        }
    }, {
        key: "remove",
        value: function(t) {
            t = this.pathPrefix + t;
            var e = this.assets[t];
            e.dispose && e.dispose(), this.assets[t] = null;
        }
    }, {
        key: "removeAll",
        value: function() {
            for (var t in this.assets) {
                var e = this.assets[t];
                e.dispose && e.dispose();
            }
            this.assets = {};
        }
    }, {
        key: "isLoadingComplete",
        value: function() {
            return 0 == this.toLoad;
        }
    }, {
        key: "getToLoad",
        value: function() {
            return this.toLoad;
        }
    }, {
        key: "getLoaded",
        value: function() {
            return this.loaded;
        }
    }, {
        key: "dispose",
        value: function() {
            this.removeAll();
        }
    }, {
        key: "hasErrors",
        value: function() {
            return Object.keys(this.errors).length > 0;
        }
    }, {
        key: "getErrors",
        value: function() {
            return this.errors;
        }
    } ], [ {
        key: "downloadText",
        value: function(t, e, a) {
            var n = Laya.Laya ? Laya.Laya : Laya;
            n.loader.load([ {
                type: n.Loader.TEXT,
                url: t
            } ], n.Handler.create(this, function(i) {
                i ? e(n.loader.getRes(t)) : a(400, "download text error: " + t);
            }));
        }
    }, {
        key: "downloadBinary",
        value: function(t, e, a) {
            var n = Laya.Laya ? Laya.Laya : Laya;
            n.loader.load([ {
                type: n.Loader.BUFFER,
                url: t
            } ], n.Handler.create(this, function(i) {
                i ? e(new Uint8Array(n.loader.getRes(t))) : a(400, "download binary error: " + t);
            }));
        }
    } ]), t;
}(), e.AssetManager = a, function(t) {
    t.AtlasAttachmentLoader = function() {
        function e(t) {
            r(this, e), this.atlas = t;
        }
        return s(e, [ {
            key: "newRegionAttachment",
            value: function(e, a, n) {
                var i = this.atlas.findRegion(n);
                if (null == i) throw new Error("Region not found in atlas: " + n + " (region attachment: " + a + ")");
                i.renderObject = i;
                var r = new t.RegionAttachment(a);
                return r.setRegion(i), r;
            }
        }, {
            key: "newMeshAttachment",
            value: function(e, a, n) {
                var i = this.atlas.findRegion(n);
                if (null == i) throw new Error("Region not found in atlas: " + n + " (mesh attachment: " + a + ")");
                i.renderObject = i;
                var r = new t.MeshAttachment(a);
                return r.region = i, r;
            }
        }, {
            key: "newBoundingBoxAttachment",
            value: function(e, a) {
                return new t.BoundingBoxAttachment(a);
            }
        }, {
            key: "newPathAttachment",
            value: function(e, a) {
                return new t.PathAttachment(a);
            }
        }, {
            key: "newPointAttachment",
            value: function(e, a) {
                return new t.PointAttachment(a);
            }
        }, {
            key: "newClippingAttachment",
            value: function(e, a) {
                return new t.ClippingAttachment(a);
            }
        } ]), e;
    }();
}(t || (t = {})), function(t) {
    !function(t) {
        t[t.Normal = 0] = "Normal", t[t.Additive = 1] = "Additive", t[t.Multiply = 2] = "Multiply", 
        t[t.Screen = 3] = "Screen";
    }(t.BlendMode || (t.BlendMode = {}));
}(t || (t = {})), function(t) {
    t.Bone = function() {
        function e(t, a, n) {
            if (r(this, e), this.children = new Array(), this.x = 0, this.y = 0, this.rotation = 0, 
            this.scaleX = 0, this.scaleY = 0, this.shearX = 0, this.shearY = 0, this.ax = 0, 
            this.ay = 0, this.arotation = 0, this.ascaleX = 0, this.ascaleY = 0, this.ashearX = 0, 
            this.ashearY = 0, this.appliedValid = !1, this.a = 0, this.b = 0, this.worldX = 0, 
            this.c = 0, this.d = 0, this.worldY = 0, this.sorted = !1, null == t) throw new Error("data cannot be null.");
            if (null == a) throw new Error("skeleton cannot be null.");
            this.data = t, this.skeleton = a, this.parent = n, this.setToSetupPose();
        }
        return s(e, [ {
            key: "update",
            value: function() {
                this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);
            }
        }, {
            key: "updateWorldTransform",
            value: function() {
                this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);
            }
        }, {
            key: "updateWorldTransformWith",
            value: function(e, a, n, i, r, s, o) {
                this.ax = e, this.ay = a, this.arotation = n, this.ascaleX = i, this.ascaleY = r, 
                this.ashearX = s, this.ashearY = o, this.appliedValid = !0;
                var l = this.parent;
                if (null == l) {
                    var h = this.skeleton, u = n + 90 + o, c = h.scaleX, f = h.scaleY;
                    return this.a = t.MathUtils.cosDeg(n + s) * i * c, this.b = t.MathUtils.cosDeg(u) * r * c, 
                    this.c = t.MathUtils.sinDeg(n + s) * i * f, this.d = t.MathUtils.sinDeg(u) * r * f, 
                    this.worldX = e * c + h.x, void (this.worldY = a * f + h.y);
                }
                var d = l.a, v = l.b, m = l.c, g = l.d;
                switch (this.worldX = d * e + v * a + l.worldX, this.worldY = m * e + g * a + l.worldY, 
                this.data.transformMode) {
                  case t.TransformMode.Normal:
                    var p = n + 90 + o, y = t.MathUtils.cosDeg(n + s) * i, M = t.MathUtils.cosDeg(p) * r, x = t.MathUtils.sinDeg(n + s) * i, w = t.MathUtils.sinDeg(p) * r;
                    return this.a = d * y + v * x, this.b = d * M + v * w, this.c = m * y + g * x, void (this.d = m * M + g * w);

                  case t.TransformMode.OnlyTranslation:
                    var E = n + 90 + o;
                    this.a = t.MathUtils.cosDeg(n + s) * i, this.b = t.MathUtils.cosDeg(E) * r, this.c = t.MathUtils.sinDeg(n + s) * i, 
                    this.d = t.MathUtils.sinDeg(E) * r;
                    break;

                  case t.TransformMode.NoRotationOrReflection:
                    var k = d * d + m * m, T = 0;
                    k > 1e-4 ? (v = m * (k = Math.abs(d * g - v * m) / k), g = d * k, T = Math.atan2(m, d) * t.MathUtils.radDeg) : (d = 0, 
                    m = 0, T = 90 - Math.atan2(g, v) * t.MathUtils.radDeg);
                    var b = n + s - T, A = n + o - T + 90, R = t.MathUtils.cosDeg(b) * i, S = t.MathUtils.cosDeg(A) * r, I = t.MathUtils.sinDeg(b) * i, P = t.MathUtils.sinDeg(A) * r;
                    this.a = d * R - v * I, this.b = d * S - v * P, this.c = m * R + g * I, this.d = m * S + g * P;
                    break;

                  case t.TransformMode.NoScale:
                  case t.TransformMode.NoScaleOrReflection:
                    var C = t.MathUtils.cosDeg(n), V = t.MathUtils.sinDeg(n), N = (d * C + v * V) / this.skeleton.scaleX, Y = (m * C + g * V) / this.skeleton.scaleY, X = Math.sqrt(N * N + Y * Y);
                    X > 1e-5 && (X = 1 / X), N *= X, Y *= X, X = Math.sqrt(N * N + Y * Y), this.data.transformMode == t.TransformMode.NoScale && d * g - v * m < 0 != (this.skeleton.scaleX < 0 != this.skeleton.scaleY < 0) && (X = -X);
                    var U = Math.PI / 2 + Math.atan2(Y, N), L = Math.cos(U) * X, D = Math.sin(U) * X, F = t.MathUtils.cosDeg(s) * i, _ = t.MathUtils.cosDeg(90 + o) * r, O = t.MathUtils.sinDeg(s) * i, B = t.MathUtils.sinDeg(90 + o) * r;
                    this.a = N * F + L * O, this.b = N * _ + L * B, this.c = Y * F + D * O, this.d = Y * _ + D * B;
                }
                this.a *= this.skeleton.scaleX, this.b *= this.skeleton.scaleX, this.c *= this.skeleton.scaleY, 
                this.d *= this.skeleton.scaleY;
            }
        }, {
            key: "setToSetupPose",
            value: function() {
                var t = this.data;
                this.x = t.x, this.y = t.y, this.rotation = t.rotation, this.scaleX = t.scaleX, 
                this.scaleY = t.scaleY, this.shearX = t.shearX, this.shearY = t.shearY;
            }
        }, {
            key: "getWorldRotationX",
            value: function() {
                return Math.atan2(this.c, this.a) * t.MathUtils.radDeg;
            }
        }, {
            key: "getWorldRotationY",
            value: function() {
                return Math.atan2(this.d, this.b) * t.MathUtils.radDeg;
            }
        }, {
            key: "getWorldScaleX",
            value: function() {
                return Math.sqrt(this.a * this.a + this.c * this.c);
            }
        }, {
            key: "getWorldScaleY",
            value: function() {
                return Math.sqrt(this.b * this.b + this.d * this.d);
            }
        }, {
            key: "updateAppliedTransform",
            value: function() {
                this.appliedValid = !0;
                var e = this.parent;
                if (null == e) return this.ax = this.worldX, this.ay = this.worldY, this.arotation = Math.atan2(this.c, this.a) * t.MathUtils.radDeg, 
                this.ascaleX = Math.sqrt(this.a * this.a + this.c * this.c), this.ascaleY = Math.sqrt(this.b * this.b + this.d * this.d), 
                this.ashearX = 0, void (this.ashearY = Math.atan2(this.a * this.b + this.c * this.d, this.a * this.d - this.b * this.c) * t.MathUtils.radDeg);
                var a = e.a, n = e.b, i = e.c, r = e.d, s = 1 / (a * r - n * i), o = this.worldX - e.worldX, l = this.worldY - e.worldY;
                this.ax = o * r * s - l * n * s, this.ay = l * a * s - o * i * s;
                var h = s * r, u = s * a, c = s * n, f = s * i, d = h * this.a - c * this.c, v = h * this.b - c * this.d, m = u * this.c - f * this.a, g = u * this.d - f * this.b;
                if (this.ashearX = 0, this.ascaleX = Math.sqrt(d * d + m * m), this.ascaleX > 1e-4) {
                    var p = d * g - v * m;
                    this.ascaleY = p / this.ascaleX, this.ashearY = Math.atan2(d * v + m * g, p) * t.MathUtils.radDeg, 
                    this.arotation = Math.atan2(m, d) * t.MathUtils.radDeg;
                } else this.ascaleX = 0, this.ascaleY = Math.sqrt(v * v + g * g), this.ashearY = 0, 
                this.arotation = 90 - Math.atan2(g, v) * t.MathUtils.radDeg;
            }
        }, {
            key: "worldToLocal",
            value: function(t) {
                var e = this.a, a = this.b, n = this.c, i = this.d, r = 1 / (e * i - a * n), s = t.x - this.worldX, o = t.y - this.worldY;
                return t.x = s * i * r - o * a * r, t.y = o * e * r - s * n * r, t;
            }
        }, {
            key: "localToWorld",
            value: function(t) {
                var e = t.x, a = t.y;
                return t.x = e * this.a + a * this.b + this.worldX, t.y = e * this.c + a * this.d + this.worldY, 
                t;
            }
        }, {
            key: "worldToLocalRotation",
            value: function(e) {
                var a = t.MathUtils.sinDeg(e), n = t.MathUtils.cosDeg(e);
                return Math.atan2(this.a * a - this.c * n, this.d * n - this.b * a) * t.MathUtils.radDeg + this.rotation - this.shearX;
            }
        }, {
            key: "localToWorldRotation",
            value: function(e) {
                e -= this.rotation - this.shearX;
                var a = t.MathUtils.sinDeg(e), n = t.MathUtils.cosDeg(e);
                return Math.atan2(n * this.c + a * this.d, n * this.a + a * this.b) * t.MathUtils.radDeg;
            }
        }, {
            key: "rotateWorld",
            value: function(e) {
                var a = this.a, n = this.b, i = this.c, r = this.d, s = t.MathUtils.cosDeg(e), o = t.MathUtils.sinDeg(e);
                this.a = s * a - o * i, this.b = s * n - o * r, this.c = o * a + s * i, this.d = o * n + s * r, 
                this.appliedValid = !1;
            }
        } ]), e;
    }();
}(t || (t = {})), function(t) {
    var e;
    t.BoneData = function() {
        return function t(a, n, i) {
            if (r(this, t), this.x = 0, this.y = 0, this.rotation = 0, this.scaleX = 1, this.scaleY = 1, 
            this.shearX = 0, this.shearY = 0, this.transformMode = e.Normal, a < 0) throw new Error("index must be >= 0.");
            if (null == n) throw new Error("name cannot be null.");
            this.index = a, this.name = n, this.parent = i;
        };
    }(), function(t) {
        t[t.Normal = 0] = "Normal", t[t.OnlyTranslation = 1] = "OnlyTranslation", t[t.NoRotationOrReflection = 2] = "NoRotationOrReflection", 
        t[t.NoScale = 3] = "NoScale", t[t.NoScaleOrReflection = 4] = "NoScaleOrReflection";
    }(e = t.TransformMode || (t.TransformMode = {}));
}(t || (t = {})), (t || (t = {})).Event = function() {
    return function t(e, a) {
        if (r(this, t), null == a) throw new Error("data cannot be null.");
        this.time = e, this.data = a;
    };
}(), (t || (t = {})).EventData = function() {
    return function t(e) {
        r(this, t), this.name = e;
    };
}(), function(t) {
    t.IkConstraint = function() {
        function e(t, a) {
            if (r(this, e), this.bendDirection = 0, this.compress = !1, this.stretch = !1, this.mix = 1, 
            null == t) throw new Error("data cannot be null.");
            if (null == a) throw new Error("skeleton cannot be null.");
            this.data = t, this.mix = t.mix, this.bendDirection = t.bendDirection, this.compress = t.compress, 
            this.stretch = t.stretch, this.bones = new Array();
            for (var n = 0; n < t.bones.length; n++) this.bones.push(a.findBone(t.bones[n].name));
            this.target = a.findBone(t.target.name);
        }
        return s(e, [ {
            key: "getOrder",
            value: function() {
                return this.data.order;
            }
        }, {
            key: "apply",
            value: function() {
                this.update();
            }
        }, {
            key: "update",
            value: function() {
                var t = this.target, e = this.bones;
                switch (e.length) {
                  case 1:
                    this.apply1(e[0], t.worldX, t.worldY, this.compress, this.stretch, this.data.uniform, this.mix);
                    break;

                  case 2:
                    this.apply2(e[0], e[1], t.worldX, t.worldY, this.bendDirection, this.stretch, this.mix);
                }
            }
        }, {
            key: "apply1",
            value: function(e, a, n, i, r, s, o) {
                e.appliedValid || e.updateAppliedTransform();
                var l = e.parent, h = 1 / (l.a * l.d - l.b * l.c), u = a - l.worldX, c = n - l.worldY, f = (u * l.d - c * l.b) * h - e.ax, d = (c * l.a - u * l.c) * h - e.ay, v = Math.atan2(d, f) * t.MathUtils.radDeg - e.ashearX - e.arotation;
                e.ascaleX < 0 && (v += 180), v > 180 ? v -= 360 : v < -180 && (v += 360);
                var m = e.ascaleX, g = e.ascaleY;
                if (i || r) {
                    var p = e.data.length * m, y = Math.sqrt(f * f + d * d);
                    if (i && y < p || r && y > p && p > 1e-4) {
                        var M = (y / p - 1) * o + 1;
                        m *= M, s && (g *= M);
                    }
                }
                e.updateWorldTransformWith(e.ax, e.ay, e.arotation + v * o, m, g, e.ashearX, e.ashearY);
            }
        }, {
            key: "apply2",
            value: function(e, a, n, i, r, s, o) {
                if (0 != o) {
                    e.appliedValid || e.updateAppliedTransform(), a.appliedValid || a.updateAppliedTransform();
                    var l = e.ax, h = e.ay, u = e.ascaleX, c = u, f = e.ascaleY, d = a.ascaleX, v = 0, m = 0, g = 0;
                    u < 0 ? (u = -u, v = 180, g = -1) : (v = 0, g = 1), f < 0 && (f = -f, g = -g), d < 0 ? (d = -d, 
                    m = 180) : m = 0;
                    var p = a.ax, y = 0, M = 0, x = 0, w = e.a, E = e.b, k = e.c, T = e.d, b = Math.abs(u - f) <= 1e-4;
                    b ? (M = w * p + E * (y = a.ay) + e.worldX, x = k * p + T * y + e.worldY) : (y = 0, 
                    M = w * p + e.worldX, x = k * p + e.worldY);
                    var A = e.parent;
                    w = A.a, E = A.b, k = A.c;
                    var R = 1 / (w * (T = A.d) - E * k), S = n - A.worldX, I = i - A.worldY, P = (S * T - I * E) * R - l, C = (I * w - S * k) * R - h, V = P * P + C * C, N = ((S = M - A.worldX) * T - (I = x - A.worldY) * E) * R - l, Y = (I * w - S * k) * R - h, X = Math.sqrt(N * N + Y * Y), U = a.data.length * d, L = 0, D = 0;
                    t: if (b) {
                        var F = (V - X * X - (U *= u) * U) / (2 * X * U);
                        F < -1 ? F = -1 : F > 1 && (F = 1, s && X + U > 1e-4 && (c *= (Math.sqrt(V) / (X + U) - 1) * o + 1)), 
                        D = Math.acos(F) * r, w = X + U * F, E = U * Math.sin(D), L = Math.atan2(C * w - P * E, P * w + C * E);
                    } else {
                        var _ = (w = u * U) * w, O = (E = f * U) * E, B = Math.atan2(C, P), W = -2 * O * X, q = O - _;
                        if ((T = W * W - 4 * q * (k = O * X * X + _ * V - _ * O)) >= 0) {
                            var H = Math.sqrt(T);
                            W < 0 && (H = -H);
                            var G = (H = -(W + H) / 2) / q, j = k / H, z = Math.abs(G) < Math.abs(j) ? G : j;
                            if (z * z <= V) {
                                I = Math.sqrt(V - z * z) * r, L = B - Math.atan2(I, z), D = Math.atan2(I / f, (z - X) / u);
                                break t;
                            }
                        }
                        var Z = t.MathUtils.PI, J = X - w, Q = J * J, K = 0, $ = 0, tt = X + w, et = tt * tt, at = 0;
                        (k = -w * X / (_ - O)) >= -1 && k <= 1 && (k = Math.acos(k), (T = (S = w * Math.cos(k) + X) * S + (I = E * Math.sin(k)) * I) < Q && (Z = k, 
                        Q = T, J = S, K = I), T > et && ($ = k, et = T, tt = S, at = I)), V <= (Q + et) / 2 ? (L = B - Math.atan2(K * r, J), 
                        D = Z * r) : (L = B - Math.atan2(at * r, tt), D = $ * r);
                    }
                    var nt = Math.atan2(y, p) * g, it = e.arotation;
                    (L = (L - nt) * t.MathUtils.radDeg + v - it) > 180 ? L -= 360 : L < -180 && (L += 360), 
                    e.updateWorldTransformWith(l, h, it + L * o, c, e.ascaleY, 0, 0), it = a.arotation, 
                    (D = ((D + nt) * t.MathUtils.radDeg - a.ashearX) * g + m - it) > 180 ? D -= 360 : D < -180 && (D += 360), 
                    a.updateWorldTransformWith(p, y, it + D * o, a.ascaleX, a.ascaleY, a.ashearX, a.ashearY);
                } else a.updateWorldTransform();
            }
        } ]), e;
    }();
}(t || (t = {})), (t || (t = {})).IkConstraintData = function() {
    return function t(e) {
        r(this, t), this.order = 0, this.bones = new Array(), this.bendDirection = 1, this.compress = !1, 
        this.stretch = !1, this.uniform = !1, this.mix = 1, this.name = e;
    };
}(), function(t) {
    var e = function() {
        function e(t, a) {
            if (r(this, e), this.position = 0, this.spacing = 0, this.rotateMix = 0, this.translateMix = 0, 
            this.spaces = new Array(), this.positions = new Array(), this.world = new Array(), 
            this.curves = new Array(), this.lengths = new Array(), this.segments = new Array(), 
            null == t) throw new Error("data cannot be null.");
            if (null == a) throw new Error("skeleton cannot be null.");
            this.data = t, this.bones = new Array();
            for (var n = 0, i = t.bones.length; n < i; n++) this.bones.push(a.findBone(t.bones[n].name));
            this.target = a.findSlot(t.target.name), this.position = t.position, this.spacing = t.spacing, 
            this.rotateMix = t.rotateMix, this.translateMix = t.translateMix;
        }
        return s(e, [ {
            key: "apply",
            value: function() {
                this.update();
            }
        }, {
            key: "update",
            value: function() {
                var a = this.target.getAttachment();
                if (a instanceof t.PathAttachment) {
                    var n = this.rotateMix, i = this.translateMix, r = n > 0;
                    if (i > 0 || r) {
                        var s = this.data, o = s.spacingMode == t.SpacingMode.Percent, l = s.rotateMode, h = l == t.RotateMode.Tangent, u = l == t.RotateMode.ChainScale, c = this.bones.length, f = h ? c : c + 1, d = this.bones, v = t.Utils.setArraySize(this.spaces, f), m = null, g = this.spacing;
                        if (u || !o) {
                            u && (m = t.Utils.setArraySize(this.lengths, c));
                            for (var p = s.spacingMode == t.SpacingMode.Length, y = 0, M = f - 1; y < M; ) {
                                var x = d[y], w = x.data.length;
                                if (w < e.epsilon) u && (m[y] = 0), v[++y] = 0; else if (o) {
                                    if (u) {
                                        var E = w * x.a, k = w * x.c, T = Math.sqrt(E * E + k * k);
                                        m[y] = T;
                                    }
                                    v[++y] = g;
                                } else {
                                    var b = w * x.a, A = w * x.c, R = Math.sqrt(b * b + A * A);
                                    u && (m[y] = R), v[++y] = (p ? w + g : g) * R / w;
                                }
                            }
                        } else for (var S = 1; S < f; S++) v[S] = g;
                        var I = this.computeWorldPositions(a, f, h, s.positionMode == t.PositionMode.Percent, o), P = I[0], C = I[1], V = s.offsetRotation, N = !1;
                        if (0 == V) N = l == t.RotateMode.Chain; else {
                            N = !1;
                            var Y = this.target.bone;
                            V *= Y.a * Y.d - Y.b * Y.c > 0 ? t.MathUtils.degRad : -t.MathUtils.degRad;
                        }
                        for (var X = 0, U = 3; X < c; X++, U += 3) {
                            var L = d[X];
                            L.worldX += (P - L.worldX) * i, L.worldY += (C - L.worldY) * i;
                            var D = I[U], F = I[U + 1], _ = D - P, O = F - C;
                            if (u) {
                                var B = m[X];
                                if (0 != B) {
                                    var W = (Math.sqrt(_ * _ + O * O) / B - 1) * n + 1;
                                    L.a *= W, L.c *= W;
                                }
                            }
                            if (P = D, C = F, r) {
                                var q = L.a, H = L.b, G = L.c, j = L.d, z = 0, Z = 0, J = 0;
                                if (z = h ? I[U - 1] : 0 == v[X + 1] ? I[U + 2] : Math.atan2(O, _), z -= Math.atan2(G, q), 
                                N) {
                                    Z = Math.cos(z), J = Math.sin(z);
                                    var Q = L.data.length;
                                    P += (Q * (Z * q - J * G) - _) * n, C += (Q * (J * q + Z * G) - O) * n;
                                } else z += V;
                                z > t.MathUtils.PI ? z -= t.MathUtils.PI2 : z < -t.MathUtils.PI && (z += t.MathUtils.PI2), 
                                z *= n, Z = Math.cos(z), J = Math.sin(z), L.a = Z * q - J * G, L.b = Z * H - J * j, 
                                L.c = J * q + Z * G, L.d = J * H + Z * j;
                            }
                            L.appliedValid = !1;
                        }
                    }
                }
            }
        }, {
            key: "computeWorldPositions",
            value: function(a, n, i, r, s) {
                var o = this.target, l = this.position, h = this.spaces, u = t.Utils.setArraySize(this.positions, 3 * n + 2), c = null, f = a.closed, d = a.worldVerticesLength, v = d / 6, m = e.NONE;
                if (!a.constantSpeed) {
                    var g = a.lengths, p = g[v -= f ? 1 : 2];
                    if (r && (l *= p), s) for (var y = 1; y < n; y++) h[y] *= p;
                    c = t.Utils.setArraySize(this.world, 8);
                    for (var M = 0, x = 0, w = 0; M < n; M++, x += 3) {
                        var E = h[M], k = l += E;
                        if (f) (k %= p) < 0 && (k += p), w = 0; else {
                            if (k < 0) {
                                m != e.BEFORE && (m = e.BEFORE, a.computeWorldVertices(o, 2, 4, c, 0, 2)), this.addBeforePosition(k, c, 0, u, x);
                                continue;
                            }
                            if (k > p) {
                                m != e.AFTER && (m = e.AFTER, a.computeWorldVertices(o, d - 6, 4, c, 0, 2)), this.addAfterPosition(k - p, c, 0, u, x);
                                continue;
                            }
                        }
                        for (;;w++) {
                            var T = g[w];
                            if (!(k > T)) {
                                if (0 == w) k /= T; else {
                                    var b = g[w - 1];
                                    k = (k - b) / (T - b);
                                }
                                break;
                            }
                        }
                        w != m && (m = w, f && w == v ? (a.computeWorldVertices(o, d - 4, 4, c, 0, 2), a.computeWorldVertices(o, 0, 4, c, 4, 2)) : a.computeWorldVertices(o, 6 * w + 2, 8, c, 0, 2)), 
                        this.addCurvePosition(k, c[0], c[1], c[2], c[3], c[4], c[5], c[6], c[7], u, x, i || M > 0 && 0 == E);
                    }
                    return u;
                }
                f ? (d += 2, c = t.Utils.setArraySize(this.world, d), a.computeWorldVertices(o, 2, d - 4, c, 0, 2), 
                a.computeWorldVertices(o, 0, 2, c, d - 4, 2), c[d - 2] = c[0], c[d - 1] = c[1]) : (v--, 
                d -= 4, c = t.Utils.setArraySize(this.world, d), a.computeWorldVertices(o, 2, d, c, 0, 2));
                for (var A = t.Utils.setArraySize(this.curves, v), R = 0, S = c[0], I = c[1], P = 0, C = 0, V = 0, N = 0, Y = 0, X = 0, U = 0, L = 0, D = 0, F = 0, _ = 0, O = 0, B = 0, W = 0, q = 0, H = 2; q < v; q++, 
                H += 6) P = c[H], C = c[H + 1], V = c[H + 2], N = c[H + 3], _ = 2 * (U = .1875 * (S - 2 * P + V)) + (D = .09375 * (3 * (P - V) - S + (Y = c[H + 4]))), 
                O = 2 * (L = .1875 * (I - 2 * C + N)) + (F = .09375 * (3 * (C - N) - I + (X = c[H + 5]))), 
                B = .75 * (P - S) + U + .16666667 * D, W = .75 * (C - I) + L + .16666667 * F, R += Math.sqrt(B * B + W * W), 
                B += _, W += O, _ += D, O += F, R += Math.sqrt(B * B + W * W), B += _, W += O, R += Math.sqrt(B * B + W * W), 
                B += _ + D, W += O + F, R += Math.sqrt(B * B + W * W), A[q] = R, S = Y, I = X;
                if (l *= r ? R : R / a.lengths[v - 1], s) for (var G = 1; G < n; G++) h[G] *= R;
                for (var j = this.segments, z = 0, Z = 0, J = 0, Q = 0, K = 0; Z < n; Z++, J += 3) {
                    var $ = h[Z], tt = l += $;
                    if (f) (tt %= R) < 0 && (tt += R), Q = 0; else {
                        if (tt < 0) {
                            this.addBeforePosition(tt, c, 0, u, J);
                            continue;
                        }
                        if (tt > R) {
                            this.addAfterPosition(tt - R, c, d - 4, u, J);
                            continue;
                        }
                    }
                    for (;;Q++) {
                        var et = A[Q];
                        if (!(tt > et)) {
                            if (0 == Q) tt /= et; else {
                                var at = A[Q - 1];
                                tt = (tt - at) / (et - at);
                            }
                            break;
                        }
                    }
                    if (Q != m) {
                        m = Q;
                        var nt = 6 * Q;
                        for (S = c[nt], I = c[nt + 1], P = c[nt + 2], C = c[nt + 3], V = c[nt + 4], N = c[nt + 5], 
                        _ = 2 * (U = .03 * (S - 2 * P + V)) + (D = .006 * (3 * (P - V) - S + (Y = c[nt + 6]))), 
                        O = 2 * (L = .03 * (I - 2 * C + N)) + (F = .006 * (3 * (C - N) - I + (X = c[nt + 7]))), 
                        B = .3 * (P - S) + U + .16666667 * D, W = .3 * (C - I) + L + .16666667 * F, z = Math.sqrt(B * B + W * W), 
                        j[0] = z, nt = 1; nt < 8; nt++) B += _, W += O, _ += D, O += F, z += Math.sqrt(B * B + W * W), 
                        j[nt] = z;
                        B += _, W += O, z += Math.sqrt(B * B + W * W), j[8] = z, B += _ + D, W += O + F, 
                        z += Math.sqrt(B * B + W * W), j[9] = z, K = 0;
                    }
                    for (tt *= z; ;K++) {
                        var it = j[K];
                        if (!(tt > it)) {
                            if (0 == K) tt /= it; else {
                                var rt = j[K - 1];
                                tt = K + (tt - rt) / (it - rt);
                            }
                            break;
                        }
                    }
                    this.addCurvePosition(.1 * tt, S, I, P, C, V, N, Y, X, u, J, i || Z > 0 && 0 == $);
                }
                return u;
            }
        }, {
            key: "addBeforePosition",
            value: function(t, e, a, n, i) {
                var r = e[a], s = e[a + 1], o = e[a + 2] - r, l = e[a + 3] - s, h = Math.atan2(l, o);
                n[i] = r + t * Math.cos(h), n[i + 1] = s + t * Math.sin(h), n[i + 2] = h;
            }
        }, {
            key: "addAfterPosition",
            value: function(t, e, a, n, i) {
                var r = e[a + 2], s = e[a + 3], o = r - e[a], l = s - e[a + 1], h = Math.atan2(l, o);
                n[i] = r + t * Math.cos(h), n[i + 1] = s + t * Math.sin(h), n[i + 2] = h;
            }
        }, {
            key: "addCurvePosition",
            value: function(t, e, a, n, i, r, s, o, l, h, u, c) {
                if (0 == t || isNaN(t)) return h[u] = e, h[u + 1] = a, void (h[u + 2] = Math.atan2(i - a, n - e));
                var f = t * t, d = f * t, v = 1 - t, m = v * v, g = m * v, p = v * t, y = 3 * p, M = v * y, x = y * t, w = e * g + n * M + r * x + o * d, E = a * g + i * M + s * x + l * d;
                h[u] = w, h[u + 1] = E, c && (h[u + 2] = t < .001 ? Math.atan2(i - a, n - e) : Math.atan2(E - (a * m + i * p * 2 + s * f), w - (e * m + n * p * 2 + r * f)));
            }
        }, {
            key: "getOrder",
            value: function() {
                return this.data.order;
            }
        } ]), e;
    }();
    e.NONE = -1, e.BEFORE = -2, e.AFTER = -3, e.epsilon = 1e-5, t.PathConstraint = e;
}(t || (t = {})), function(t) {
    t.PathConstraintData = function() {
        return function t(e) {
            r(this, t), this.order = 0, this.bones = new Array(), this.name = e;
        };
    }(), function(t) {
        t[t.Fixed = 0] = "Fixed", t[t.Percent = 1] = "Percent";
    }(t.PositionMode || (t.PositionMode = {})), function(t) {
        t[t.Length = 0] = "Length", t[t.Fixed = 1] = "Fixed", t[t.Percent = 2] = "Percent";
    }(t.SpacingMode || (t.SpacingMode = {})), function(t) {
        t[t.Tangent = 0] = "Tangent", t[t.Chain = 1] = "Chain", t[t.ChainScale = 2] = "ChainScale";
    }(t.RotateMode || (t.RotateMode = {}));
}(t || (t = {})), function(t) {
    var e = function() {
        function t(e) {
            r(this, t), this.toLoad = new Array(), this.assets = {}, this.clientId = e;
        }
        return s(t, [ {
            key: "loaded",
            value: function() {
                var t = 0;
                for (var e in this.assets) t++;
                return t;
            }
        } ]), t;
    }();
    t.SharedAssetManager = function() {
        function t() {
            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
            r(this, t), this.clientAssets = {}, this.queuedAssets = {}, this.rawAssets = {}, 
            this.errors = {}, this.pathPrefix = e;
        }
        return s(t, [ {
            key: "queueAsset",
            value: function(t, a, n) {
                var i = this.clientAssets[t];
                return null == i && (i = new e(t), this.clientAssets[t] = i), null !== a && (i.textureLoader = a), 
                i.toLoad.push(n), this.queuedAssets[n] !== n && (this.queuedAssets[n] = n, !0);
            }
        }, {
            key: "loadText",
            value: function(t, e) {
                var a = this;
                if (e = this.pathPrefix + e, this.queueAsset(t, null, e)) {
                    var n = new XMLHttpRequest();
                    n.onreadystatechange = function() {
                        n.readyState == XMLHttpRequest.DONE && (n.status >= 200 && n.status < 300 ? a.rawAssets[e] = n.responseText : a.errors[e] = "Couldn't load text ".concat(e, ": status ").concat(n.status, ", ").concat(n.responseText));
                    }, n.open("GET", e, !0), n.send();
                }
            }
        }, {
            key: "loadJson",
            value: function(t, e) {
                var a = this;
                if (e = this.pathPrefix + e, this.queueAsset(t, null, e)) {
                    var n = new XMLHttpRequest();
                    n.onreadystatechange = function() {
                        n.readyState == XMLHttpRequest.DONE && (n.status >= 200 && n.status < 300 ? a.rawAssets[e] = JSON.parse(n.responseText) : a.errors[e] = "Couldn't load text ".concat(e, ": status ").concat(n.status, ", ").concat(n.responseText));
                    }, n.open("GET", e, !0), n.send();
                }
            }
        }, {
            key: "loadTexture",
            value: function(t, e, a) {
                var n = this;
                if (a = this.pathPrefix + a, this.queueAsset(t, e, a)) {
                    var i = new Image();
                    i.src = a, i.crossOrigin = "anonymous", i.onload = function(t) {
                        n.rawAssets[a] = i;
                    }, i.onerror = function(t) {
                        n.errors[a] = "Couldn't load image " + a;
                    };
                }
            }
        }, {
            key: "get",
            value: function(t, e) {
                e = this.pathPrefix + e;
                var a = this.clientAssets[t];
                return null == a || a.assets[e];
            }
        }, {
            key: "updateClientAssets",
            value: function(t) {
                for (var e = 0; e < t.toLoad.length; e++) {
                    var a = t.toLoad[e];
                    if (null == t.assets[a]) {
                        var n = this.rawAssets[a];
                        if (null == n) continue;
                        n instanceof HTMLImageElement ? t.assets[a] = t.textureLoader(n) : t.assets[a] = n;
                    }
                }
            }
        }, {
            key: "isLoadingComplete",
            value: function(t) {
                var e = this.clientAssets[t];
                return null == e || (this.updateClientAssets(e), e.toLoad.length == e.loaded());
            }
        }, {
            key: "dispose",
            value: function() {}
        }, {
            key: "hasErrors",
            value: function() {
                return Object.keys(this.errors).length > 0;
            }
        }, {
            key: "getErrors",
            value: function() {
                return this.errors;
            }
        } ]), t;
    }();
}(t || (t = {})), function(t) {
    t.Skeleton = function() {
        function e(a) {
            if (r(this, e), this._updateCache = new Array(), this.updateCacheReset = new Array(), 
            this.time = 0, this.scaleX = 1, this.scaleY = 1, this.x = 0, this.y = 0, null == a) throw new Error("data cannot be null.");
            this.data = a, this.bones = new Array();
            for (var n = 0; n < a.bones.length; n++) {
                var i = void 0, s = a.bones[n];
                if (null == s.parent) i = new t.Bone(s, this, null); else {
                    var o = this.bones[s.parent.index];
                    i = new t.Bone(s, this, o), o.children.push(i);
                }
                this.bones.push(i);
            }
            this.slots = new Array(), this.drawOrder = new Array();
            for (var l = 0; l < a.slots.length; l++) {
                var h = a.slots[l], u = this.bones[h.boneData.index], c = new t.Slot(h, u);
                this.slots.push(c), this.drawOrder.push(c);
            }
            this.ikConstraints = new Array();
            for (var f = 0; f < a.ikConstraints.length; f++) {
                var d = a.ikConstraints[f];
                this.ikConstraints.push(new t.IkConstraint(d, this));
            }
            this.transformConstraints = new Array();
            for (var v = 0; v < a.transformConstraints.length; v++) {
                var m = a.transformConstraints[v];
                this.transformConstraints.push(new t.TransformConstraint(m, this));
            }
            this.pathConstraints = new Array();
            for (var g = 0; g < a.pathConstraints.length; g++) {
                var p = a.pathConstraints[g];
                this.pathConstraints.push(new t.PathConstraint(p, this));
            }
            this.color = new t.Color(1, 1, 1, 1), this.updateCache();
        }
        return s(e, [ {
            key: "updateCache",
            value: function() {
                this._updateCache.length = 0, this.updateCacheReset.length = 0;
                for (var t = this.bones, e = 0, a = t.length; e < a; e++) t[e].sorted = !1;
                var n = this.ikConstraints, i = this.transformConstraints, r = this.pathConstraints, s = n.length, o = i.length, l = r.length, h = s + o + l;
                t: for (var u = 0; u < h; u++) {
                    for (var c = 0; c < s; c++) {
                        var f = n[c];
                        if (f.data.order == u) {
                            this.sortIkConstraint(f);
                            continue t;
                        }
                    }
                    for (var d = 0; d < o; d++) {
                        var v = i[d];
                        if (v.data.order == u) {
                            this.sortTransformConstraint(v);
                            continue t;
                        }
                    }
                    for (var m = 0; m < l; m++) {
                        var g = r[m];
                        if (g.data.order == u) {
                            this.sortPathConstraint(g);
                            continue t;
                        }
                    }
                }
                for (var p = 0, y = t.length; p < y; p++) this.sortBone(t[p]);
            }
        }, {
            key: "sortIkConstraint",
            value: function(t) {
                var e = t.target;
                this.sortBone(e);
                var a = t.bones, n = a[0];
                if (this.sortBone(n), a.length > 1) {
                    var i = a[a.length - 1];
                    this._updateCache.indexOf(i) > -1 || this.updateCacheReset.push(i);
                }
                this._updateCache.push(t), this.sortReset(n.children), a[a.length - 1].sorted = !0;
            }
        }, {
            key: "sortPathConstraint",
            value: function(e) {
                var a = e.target, n = a.data.index, i = a.bone;
                null != this.skin && this.sortPathConstraintAttachment(this.skin, n, i), null != this.data.defaultSkin && this.data.defaultSkin != this.skin && this.sortPathConstraintAttachment(this.data.defaultSkin, n, i);
                for (var r = 0, s = this.data.skins.length; r < s; r++) this.sortPathConstraintAttachment(this.data.skins[r], n, i);
                var o = a.getAttachment();
                o instanceof t.PathAttachment && this.sortPathConstraintAttachmentWith(o, i);
                for (var l = e.bones, h = l.length, u = 0; u < h; u++) this.sortBone(l[u]);
                this._updateCache.push(e);
                for (var c = 0; c < h; c++) this.sortReset(l[c].children);
                for (var f = 0; f < h; f++) l[f].sorted = !0;
            }
        }, {
            key: "sortTransformConstraint",
            value: function(t) {
                this.sortBone(t.target);
                var e = t.bones, a = e.length;
                if (t.data.local) for (var n = 0; n < a; n++) {
                    var i = e[n];
                    this.sortBone(i.parent), this._updateCache.indexOf(i) > -1 || this.updateCacheReset.push(i);
                } else for (var r = 0; r < a; r++) this.sortBone(e[r]);
                this._updateCache.push(t);
                for (var s = 0; s < a; s++) this.sortReset(e[s].children);
                for (var o = 0; o < a; o++) e[o].sorted = !0;
            }
        }, {
            key: "sortPathConstraintAttachment",
            value: function(t, e, a) {
                var n = t.attachments[e];
                if (n) for (var i in n) this.sortPathConstraintAttachmentWith(n[i], a);
            }
        }, {
            key: "sortPathConstraintAttachmentWith",
            value: function(e, a) {
                if (e instanceof t.PathAttachment) {
                    var n = e.bones;
                    if (null == n) this.sortBone(a); else for (var i = this.bones, r = 0; r < n.length; ) for (var s = n[r++], o = r + s; r < o; r++) {
                        var l = n[r];
                        this.sortBone(i[l]);
                    }
                }
            }
        }, {
            key: "sortBone",
            value: function(t) {
                if (!t.sorted) {
                    var e = t.parent;
                    null != e && this.sortBone(e), t.sorted = !0, this._updateCache.push(t);
                }
            }
        }, {
            key: "sortReset",
            value: function(t) {
                for (var e = 0, a = t.length; e < a; e++) {
                    var n = t[e];
                    n.sorted && this.sortReset(n.children), n.sorted = !1;
                }
            }
        }, {
            key: "updateWorldTransform",
            value: function() {
                for (var t = this.updateCacheReset, e = 0, a = t.length; e < a; e++) {
                    var n = t[e];
                    n.ax = n.x, n.ay = n.y, n.arotation = n.rotation, n.ascaleX = n.scaleX, n.ascaleY = n.scaleY, 
                    n.ashearX = n.shearX, n.ashearY = n.shearY, n.appliedValid = !0;
                }
                for (var i = this._updateCache, r = 0, s = i.length; r < s; r++) i[r].update();
            }
        }, {
            key: "setToSetupPose",
            value: function() {
                this.setBonesToSetupPose(), this.setSlotsToSetupPose();
            }
        }, {
            key: "setBonesToSetupPose",
            value: function() {
                for (var t = this.bones, e = 0, a = t.length; e < a; e++) t[e].setToSetupPose();
                for (var n = this.ikConstraints, i = 0, r = n.length; i < r; i++) {
                    var s = n[i];
                    s.mix = s.data.mix, s.bendDirection = s.data.bendDirection, s.compress = s.data.compress, 
                    s.stretch = s.data.stretch;
                }
                for (var o = this.transformConstraints, l = 0, h = o.length; l < h; l++) {
                    var u = o[l], c = u.data;
                    u.rotateMix = c.rotateMix, u.translateMix = c.translateMix, u.scaleMix = c.scaleMix, 
                    u.shearMix = c.shearMix;
                }
                for (var f = this.pathConstraints, d = 0, v = f.length; d < v; d++) {
                    var m = f[d], g = m.data;
                    m.position = g.position, m.spacing = g.spacing, m.rotateMix = g.rotateMix, m.translateMix = g.translateMix;
                }
            }
        }, {
            key: "setSlotsToSetupPose",
            value: function() {
                var e = this.slots;
                t.Utils.arrayCopy(e, 0, this.drawOrder, 0, e.length);
                for (var a = 0, n = e.length; a < n; a++) e[a].setToSetupPose();
            }
        }, {
            key: "getRootBone",
            value: function() {
                return 0 == this.bones.length ? null : this.bones[0];
            }
        }, {
            key: "findBone",
            value: function(t) {
                if (null == t) throw new Error("boneName cannot be null.");
                for (var e = this.bones, a = 0, n = e.length; a < n; a++) {
                    var i = e[a];
                    if (i.data.name == t) return i;
                }
                return null;
            }
        }, {
            key: "findBoneIndex",
            value: function(t) {
                if (null == t) throw new Error("boneName cannot be null.");
                for (var e = this.bones, a = 0, n = e.length; a < n; a++) if (e[a].data.name == t) return a;
                return -1;
            }
        }, {
            key: "findSlot",
            value: function(t) {
                if (null == t) throw new Error("slotName cannot be null.");
                for (var e = this.slots, a = 0, n = e.length; a < n; a++) {
                    var i = e[a];
                    if (i.data.name == t) return i;
                }
                return null;
            }
        }, {
            key: "findSlotIndex",
            value: function(t) {
                if (null == t) throw new Error("slotName cannot be null.");
                for (var e = this.slots, a = 0, n = e.length; a < n; a++) if (e[a].data.name == t) return a;
                return -1;
            }
        }, {
            key: "setSkinByName",
            value: function(t) {
                var e = this.data.findSkin(t);
                if (null == e) throw new Error("Skin not found: " + t);
                this.setSkin(e);
            }
        }, {
            key: "setSkin",
            value: function(t) {
                if (null != t) if (null != this.skin) t.attachAll(this, this.skin); else for (var e = this.slots, a = 0, n = e.length; a < n; a++) {
                    var i = e[a], r = i.data.attachmentName;
                    if (null != r) {
                        var s = t.getAttachment(a, r);
                        null != s && i.setAttachment(s);
                    }
                }
                this.skin = t;
            }
        }, {
            key: "getAttachmentByName",
            value: function(t, e) {
                return this.getAttachment(this.data.findSlotIndex(t), e);
            }
        }, {
            key: "getAttachment",
            value: function(t, e) {
                if (null == e) throw new Error("attachmentName cannot be null.");
                if (null != this.skin) {
                    var a = this.skin.getAttachment(t, e);
                    if (null != a) return a;
                }
                return null != this.data.defaultSkin ? this.data.defaultSkin.getAttachment(t, e) : null;
            }
        }, {
            key: "setAttachment",
            value: function(t, e) {
                if (null == t) throw new Error("slotName cannot be null.");
                for (var a = this.slots, n = 0, i = a.length; n < i; n++) {
                    var r = a[n];
                    if (r.data.name == t) {
                        var s = null;
                        if (null != e && null == (s = this.getAttachment(n, e))) throw new Error("Attachment not found: " + e + ", for slot: " + t);
                        return void r.setAttachment(s);
                    }
                }
                throw new Error("Slot not found: " + t);
            }
        }, {
            key: "findIkConstraint",
            value: function(t) {
                if (null == t) throw new Error("constraintName cannot be null.");
                for (var e = this.ikConstraints, a = 0, n = e.length; a < n; a++) {
                    var i = e[a];
                    if (i.data.name == t) return i;
                }
                return null;
            }
        }, {
            key: "findTransformConstraint",
            value: function(t) {
                if (null == t) throw new Error("constraintName cannot be null.");
                for (var e = this.transformConstraints, a = 0, n = e.length; a < n; a++) {
                    var i = e[a];
                    if (i.data.name == t) return i;
                }
                return null;
            }
        }, {
            key: "findPathConstraint",
            value: function(t) {
                if (null == t) throw new Error("constraintName cannot be null.");
                for (var e = this.pathConstraints, a = 0, n = e.length; a < n; a++) {
                    var i = e[a];
                    if (i.data.name == t) return i;
                }
                return null;
            }
        }, {
            key: "getBounds",
            value: function(e, a) {
                var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : new Array(2);
                if (null == e) throw new Error("offset cannot be null.");
                if (null == a) throw new Error("size cannot be null.");
                for (var i = this.drawOrder, r = Number.POSITIVE_INFINITY, s = Number.POSITIVE_INFINITY, o = Number.NEGATIVE_INFINITY, l = Number.NEGATIVE_INFINITY, h = 0, u = i.length; h < u; h++) {
                    var c = i[h], f = 0, d = null, v = c.getAttachment();
                    if (v instanceof t.RegionAttachment) f = 8, d = t.Utils.setArraySize(n, f, 0), v.computeWorldVertices(c.bone, d, 0, 2); else if (v instanceof t.MeshAttachment) {
                        var m = v;
                        f = m.worldVerticesLength, d = t.Utils.setArraySize(n, f, 0), m.computeWorldVertices(c, 0, f, d, 0, 2);
                    }
                    if (null != d) for (var g = 0, p = d.length; g < p; g += 2) {
                        var y = d[g], M = d[g + 1];
                        r = Math.min(r, y), s = Math.min(s, M), o = Math.max(o, y), l = Math.max(l, M);
                    }
                }
                e.set(r, s), a.set(o - r, l - s);
            }
        }, {
            key: "update",
            value: function(t) {
                this.time += t;
            }
        } ]), e;
    }();
}(t || (t = {})), function(t) {
    t.SkeletonBounds = function() {
        function e() {
            r(this, e), this.minX = 0, this.minY = 0, this.maxX = 0, this.maxY = 0, this.boundingBoxes = new Array(), 
            this.polygons = new Array(), this.polygonPool = new t.Pool(function() {
                return t.Utils.newFloatArray(16);
            });
        }
        return s(e, [ {
            key: "update",
            value: function(e, a) {
                if (null == e) throw new Error("skeleton cannot be null.");
                var n = this.boundingBoxes, i = this.polygons, r = this.polygonPool, s = e.slots, o = s.length;
                n.length = 0, r.freeAll(i), i.length = 0;
                for (var l = 0; l < o; l++) {
                    var h = s[l], u = h.getAttachment();
                    if (u instanceof t.BoundingBoxAttachment) {
                        var c = u;
                        n.push(c);
                        var f = r.obtain();
                        f.length != c.worldVerticesLength && (f = t.Utils.newFloatArray(c.worldVerticesLength)), 
                        i.push(f), c.computeWorldVertices(h, 0, c.worldVerticesLength, f, 0, 2);
                    }
                }
                a ? this.aabbCompute() : (this.minX = Number.POSITIVE_INFINITY, this.minY = Number.POSITIVE_INFINITY, 
                this.maxX = Number.NEGATIVE_INFINITY, this.maxY = Number.NEGATIVE_INFINITY);
            }
        }, {
            key: "aabbCompute",
            value: function() {
                for (var t = Number.POSITIVE_INFINITY, e = Number.POSITIVE_INFINITY, a = Number.NEGATIVE_INFINITY, n = Number.NEGATIVE_INFINITY, i = this.polygons, r = 0, s = i.length; r < s; r++) for (var o = i[r], l = o, h = 0, u = o.length; h < u; h += 2) {
                    var c = l[h], f = l[h + 1];
                    t = Math.min(t, c), e = Math.min(e, f), a = Math.max(a, c), n = Math.max(n, f);
                }
                this.minX = t, this.minY = e, this.maxX = a, this.maxY = n;
            }
        }, {
            key: "aabbContainsPoint",
            value: function(t, e) {
                return t >= this.minX && t <= this.maxX && e >= this.minY && e <= this.maxY;
            }
        }, {
            key: "aabbIntersectsSegment",
            value: function(t, e, a, n) {
                var i = this.minX, r = this.minY, s = this.maxX, o = this.maxY;
                if (t <= i && a <= i || e <= r && n <= r || t >= s && a >= s || e >= o && n >= o) return !1;
                var l = (n - e) / (a - t), h = l * (i - t) + e;
                if (h > r && h < o) return !0;
                if ((h = l * (s - t) + e) > r && h < o) return !0;
                var u = (r - e) / l + t;
                return u > i && u < s || (u = (o - e) / l + t) > i && u < s;
            }
        }, {
            key: "aabbIntersectsSkeleton",
            value: function(t) {
                return this.minX < t.maxX && this.maxX > t.minX && this.minY < t.maxY && this.maxY > t.minY;
            }
        }, {
            key: "containsPoint",
            value: function(t, e) {
                for (var a = this.polygons, n = 0, i = a.length; n < i; n++) if (this.containsPointPolygon(a[n], t, e)) return this.boundingBoxes[n];
                return null;
            }
        }, {
            key: "containsPointPolygon",
            value: function(t, e, a) {
                for (var n = t, i = t.length, r = i - 2, s = !1, o = 0; o < i; o += 2) {
                    var l = n[o + 1], h = n[r + 1];
                    if (l < a && h >= a || h < a && l >= a) {
                        var u = n[o];
                        u + (a - l) / (h - l) * (n[r] - u) < e && (s = !s);
                    }
                    r = o;
                }
                return s;
            }
        }, {
            key: "intersectsSegment",
            value: function(t, e, a, n) {
                for (var i = this.polygons, r = 0, s = i.length; r < s; r++) if (this.intersectsSegmentPolygon(i[r], t, e, a, n)) return this.boundingBoxes[r];
                return null;
            }
        }, {
            key: "intersectsSegmentPolygon",
            value: function(t, e, a, n, i) {
                for (var r = t, s = t.length, o = e - n, l = a - i, h = e * i - a * n, u = r[s - 2], c = r[s - 1], f = 0; f < s; f += 2) {
                    var d = r[f], v = r[f + 1], m = u * v - c * d, g = u - d, p = c - v, y = o * p - l * g, M = (h * g - o * m) / y;
                    if ((M >= u && M <= d || M >= d && M <= u) && (M >= e && M <= n || M >= n && M <= e)) {
                        var x = (h * p - l * m) / y;
                        if ((x >= c && x <= v || x >= v && x <= c) && (x >= a && x <= i || x >= i && x <= a)) return !0;
                    }
                    u = d, c = v;
                }
                return !1;
            }
        }, {
            key: "getPolygon",
            value: function(t) {
                if (null == t) throw new Error("boundingBox cannot be null.");
                var e = this.boundingBoxes.indexOf(t);
                return -1 == e ? null : this.polygons[e];
            }
        }, {
            key: "getWidth",
            value: function() {
                return this.maxX - this.minX;
            }
        }, {
            key: "getHeight",
            value: function() {
                return this.maxY - this.minY;
            }
        } ]), e;
    }();
}(t || (t = {})), function(t) {
    var e = function() {
        function e() {
            r(this, e), this.triangulator = new t.Triangulator(), this.clippingPolygon = new Array(), 
            this.clipOutput = new Array(), this.clippedVertices = new Array(), this.clippedTriangles = new Array(), 
            this.scratch = new Array();
        }
        return s(e, [ {
            key: "clipStart",
            value: function(a, n) {
                if (null != this.clipAttachment) return 0;
                this.clipAttachment = n;
                var i = n.worldVerticesLength, r = t.Utils.setArraySize(this.clippingPolygon, i);
                n.computeWorldVertices(a, 0, i, r, 0, 2);
                var s = this.clippingPolygon;
                e.makeClockwise(s);
                for (var o = this.clippingPolygons = this.triangulator.decompose(s, this.triangulator.triangulate(s)), l = 0, h = o.length; l < h; l++) {
                    var u = o[l];
                    e.makeClockwise(u), u.push(u[0]), u.push(u[1]);
                }
                return o.length;
            }
        }, {
            key: "clipEndWithSlot",
            value: function(t) {
                null != this.clipAttachment && this.clipAttachment.endSlot == t.data && this.clipEnd();
            }
        }, {
            key: "clipEnd",
            value: function() {
                null != this.clipAttachment && (this.clipAttachment = null, this.clippingPolygons = null, 
                this.clippedVertices.length = 0, this.clippedTriangles.length = 0, this.clippingPolygon.length = 0);
            }
        }, {
            key: "isClipping",
            value: function() {
                return null != this.clipAttachment;
            }
        }, {
            key: "clipTriangles",
            value: function(e, a, n, i, r, s, o, l) {
                var h = this.clipOutput, u = this.clippedVertices, c = this.clippedTriangles, f = this.clippingPolygons, d = this.clippingPolygons.length, v = l ? 12 : 8, m = 0;
                u.length = 0, c.length = 0;
                t: for (var g = 0; g < i; g += 3) for (var p = n[g] << 1, y = e[p], M = e[p + 1], x = r[p], w = r[p + 1], E = e[p = n[g + 1] << 1], k = e[p + 1], T = r[p], b = r[p + 1], A = e[p = n[g + 2] << 1], R = e[p + 1], S = r[p], I = r[p + 1], P = 0; P < d; P++) {
                    var C = u.length;
                    if (!this.clip(y, M, E, k, A, R, f[P], h)) {
                        var V = t.Utils.setArraySize(u, C + 3 * v);
                        V[C] = y, V[C + 1] = M, V[C + 2] = s.r, V[C + 3] = s.g, V[C + 4] = s.b, V[C + 5] = s.a, 
                        l ? (V[C + 6] = x, V[C + 7] = w, V[C + 8] = o.r, V[C + 9] = o.g, V[C + 10] = o.b, 
                        V[C + 11] = o.a, V[C + 12] = E, V[C + 13] = k, V[C + 14] = s.r, V[C + 15] = s.g, 
                        V[C + 16] = s.b, V[C + 17] = s.a, V[C + 18] = T, V[C + 19] = b, V[C + 20] = o.r, 
                        V[C + 21] = o.g, V[C + 22] = o.b, V[C + 23] = o.a, V[C + 24] = A, V[C + 25] = R, 
                        V[C + 26] = s.r, V[C + 27] = s.g, V[C + 28] = s.b, V[C + 29] = s.a, V[C + 30] = S, 
                        V[C + 31] = I, V[C + 32] = o.r, V[C + 33] = o.g, V[C + 34] = o.b, V[C + 35] = o.a) : (V[C + 6] = x, 
                        V[C + 7] = w, V[C + 8] = E, V[C + 9] = k, V[C + 10] = s.r, V[C + 11] = s.g, V[C + 12] = s.b, 
                        V[C + 13] = s.a, V[C + 14] = T, V[C + 15] = b, V[C + 16] = A, V[C + 17] = R, V[C + 18] = s.r, 
                        V[C + 19] = s.g, V[C + 20] = s.b, V[C + 21] = s.a, V[C + 22] = S, V[C + 23] = I), 
                        C = c.length;
                        var N = t.Utils.setArraySize(c, C + 3);
                        N[C] = m, N[C + 1] = m + 1, N[C + 2] = m + 2, m += 3;
                        continue t;
                    }
                    var Y = h.length;
                    if (0 != Y) {
                        for (var X = k - R, U = A - E, L = y - A, D = R - M, F = 1 / (X * L + U * (M - R)), _ = Y >> 1, O = this.clipOutput, B = t.Utils.setArraySize(u, C + _ * v), W = 0; W < Y; W += 2) {
                            var q = O[W], H = O[W + 1];
                            B[C] = q, B[C + 1] = H, B[C + 2] = s.r, B[C + 3] = s.g, B[C + 4] = s.b, B[C + 5] = s.a;
                            var G = q - A, j = H - R, z = (X * G + U * j) * F, Z = (D * G + L * j) * F, J = 1 - z - Z;
                            B[C + 6] = x * z + T * Z + S * J, B[C + 7] = w * z + b * Z + I * J, l && (B[C + 8] = o.r, 
                            B[C + 9] = o.g, B[C + 10] = o.b, B[C + 11] = o.a), C += v;
                        }
                        C = c.length;
                        var Q = t.Utils.setArraySize(c, C + 3 * (_ - 2));
                        _--;
                        for (var K = 1; K < _; K++) Q[C] = m, Q[C + 1] = m + K, Q[C + 2] = m + K + 1, C += 3;
                        m += _ + 1;
                    }
                }
            }
        }, {
            key: "clip",
            value: function(t, e, a, n, i, r, s, o) {
                var l = o, h = !1, u = null;
                s.length % 4 >= 2 ? (u = o, o = this.scratch) : u = this.scratch, u.length = 0, 
                u.push(t), u.push(e), u.push(a), u.push(n), u.push(i), u.push(r), u.push(t), u.push(e), 
                o.length = 0;
                for (var c = s, f = s.length - 4, d = 0; ;d += 2) {
                    for (var v = c[d], m = c[d + 1], g = c[d + 2], p = c[d + 3], y = v - g, M = m - p, x = u, w = u.length - 2, E = o.length, k = 0; k < w; k += 2) {
                        var T = x[k], b = x[k + 1], A = x[k + 2], R = x[k + 3], S = y * (R - p) - M * (A - g) > 0;
                        if (y * (b - p) - M * (T - g) > 0) {
                            if (S) {
                                o.push(A), o.push(R);
                                continue;
                            }
                            var I = R - b, P = A - T, C = I * (g - v) - P * (p - m);
                            if (Math.abs(C) > 1e-6) {
                                var V = (P * (m - b) - I * (v - T)) / C;
                                o.push(v + (g - v) * V), o.push(m + (p - m) * V);
                            } else o.push(v), o.push(m);
                        } else if (S) {
                            var N = R - b, Y = A - T, X = N * (g - v) - Y * (p - m);
                            if (Math.abs(X) > 1e-6) {
                                var U = (Y * (m - b) - N * (v - T)) / X;
                                o.push(v + (g - v) * U), o.push(m + (p - m) * U);
                            } else o.push(v), o.push(m);
                            o.push(A), o.push(R);
                        }
                        h = !0;
                    }
                    if (E == o.length) return l.length = 0, !0;
                    if (o.push(o[0]), o.push(o[1]), d == f) break;
                    var L = o;
                    (o = u).length = 0, u = L;
                }
                if (l != o) {
                    l.length = 0;
                    for (var D = 0, F = o.length - 2; D < F; D++) l[D] = o[D];
                } else l.length = l.length - 2;
                return h;
            }
        } ], [ {
            key: "makeClockwise",
            value: function(t) {
                for (var e = t, a = t.length, n = e[a - 2] * e[1] - e[0] * e[a - 1], i = 0, r = 0, s = 0, o = 0, l = a - 3; o < l; o += 2) i = e[o], 
                r = e[o + 1], s = e[o + 2], n += i * e[o + 3] - s * r;
                if (!(n < 0)) for (var h = 0, u = a - 2, c = a >> 1; h < c; h += 2) {
                    var f = e[h], d = e[h + 1], v = u - h;
                    e[h] = e[v], e[h + 1] = e[v + 1], e[v] = f, e[v + 1] = d;
                }
            }
        } ]), e;
    }();
    t.SkeletonClipping = e;
}(t || (t = {})), (t || (t = {})).SkeletonData = function() {
    function t() {
        r(this, t), this.bones = new Array(), this.slots = new Array(), this.skins = new Array(), 
        this.events = new Array(), this.animations = new Array(), this.ikConstraints = new Array(), 
        this.transformConstraints = new Array(), this.pathConstraints = new Array(), this.fps = 0;
    }
    return s(t, [ {
        key: "findBone",
        value: function(t) {
            if (null == t) throw new Error("boneName cannot be null.");
            for (var e = this.bones, a = 0, n = e.length; a < n; a++) {
                var i = e[a];
                if (i.name == t) return i;
            }
            return null;
        }
    }, {
        key: "findBoneIndex",
        value: function(t) {
            if (null == t) throw new Error("boneName cannot be null.");
            for (var e = this.bones, a = 0, n = e.length; a < n; a++) if (e[a].name == t) return a;
            return -1;
        }
    }, {
        key: "findSlot",
        value: function(t) {
            if (null == t) throw new Error("slotName cannot be null.");
            for (var e = this.slots, a = 0, n = e.length; a < n; a++) {
                var i = e[a];
                if (i.name == t) return i;
            }
            return null;
        }
    }, {
        key: "findSlotIndex",
        value: function(t) {
            if (null == t) throw new Error("slotName cannot be null.");
            for (var e = this.slots, a = 0, n = e.length; a < n; a++) if (e[a].name == t) return a;
            return -1;
        }
    }, {
        key: "findSkin",
        value: function(t) {
            if (null == t) throw new Error("skinName cannot be null.");
            for (var e = this.skins, a = 0, n = e.length; a < n; a++) {
                var i = e[a];
                if (i.name == t) return i;
            }
            return null;
        }
    }, {
        key: "findEvent",
        value: function(t) {
            if (null == t) throw new Error("eventDataName cannot be null.");
            for (var e = this.events, a = 0, n = e.length; a < n; a++) {
                var i = e[a];
                if (i.name == t) return i;
            }
            return null;
        }
    }, {
        key: "findAnimation",
        value: function(t) {
            if (null == t) throw new Error("animationName cannot be null.");
            for (var e = this.animations, a = 0, n = e.length; a < n; a++) {
                var i = e[a];
                if (i.name == t) return i;
            }
            return null;
        }
    }, {
        key: "findIkConstraint",
        value: function(t) {
            if (null == t) throw new Error("constraintName cannot be null.");
            for (var e = this.ikConstraints, a = 0, n = e.length; a < n; a++) {
                var i = e[a];
                if (i.name == t) return i;
            }
            return null;
        }
    }, {
        key: "findTransformConstraint",
        value: function(t) {
            if (null == t) throw new Error("constraintName cannot be null.");
            for (var e = this.transformConstraints, a = 0, n = e.length; a < n; a++) {
                var i = e[a];
                if (i.name == t) return i;
            }
            return null;
        }
    }, {
        key: "findPathConstraint",
        value: function(t) {
            if (null == t) throw new Error("constraintName cannot be null.");
            for (var e = this.pathConstraints, a = 0, n = e.length; a < n; a++) {
                var i = e[a];
                if (i.name == t) return i;
            }
            return null;
        }
    }, {
        key: "findPathConstraintIndex",
        value: function(t) {
            if (null == t) throw new Error("pathConstraintName cannot be null.");
            for (var e = this.pathConstraints, a = 0, n = e.length; a < n; a++) if (e[a].name == t) return a;
            return -1;
        }
    } ]), t;
}(), function(t) {
    var e = function() {
        function e(t) {
            r(this, e), this.scale = 1, this.linkedMeshes = new Array(), this.attachmentLoader = t;
        }
        return s(e, [ {
            key: "readSkeletonData",
            value: function(a) {
                var n = this.scale, i = new t.SkeletonData(), r = "string" == typeof a ? JSON.parse(a) : a, s = r.skeleton;
                if (null != s && (i.hash = s.hash, i.version = s.spine, i.width = s.width, i.height = s.height, 
                i.fps = s.fps, i.imagesPath = s.images), r.bones) for (var o = 0; o < r.bones.length; o++) {
                    var l = r.bones[o], h = null, u = this.getValue(l, "parent", null);
                    if (null != u && null == (h = i.findBone(u))) throw new Error("Parent bone not found: " + u);
                    var c = new t.BoneData(i.bones.length, l.name, h);
                    c.length = this.getValue(l, "length", 0) * n, c.x = this.getValue(l, "x", 0) * n, 
                    c.y = this.getValue(l, "y", 0) * n, c.rotation = this.getValue(l, "rotation", 0), 
                    c.scaleX = this.getValue(l, "scaleX", 1), c.scaleY = this.getValue(l, "scaleY", 1), 
                    c.shearX = this.getValue(l, "shearX", 0), c.shearY = this.getValue(l, "shearY", 0), 
                    c.transformMode = e.transformModeFromString(this.getValue(l, "transform", "normal")), 
                    i.bones.push(c);
                }
                if (r.slots) for (var f = 0; f < r.slots.length; f++) {
                    var d = r.slots[f], v = d.name, m = d.bone, g = i.findBone(m);
                    if (null == g) throw new Error("Slot bone not found: " + m);
                    var p = new t.SlotData(i.slots.length, v, g), y = this.getValue(d, "color", null);
                    null != y && p.color.setFromString(y);
                    var M = this.getValue(d, "dark", null);
                    null != M && (p.darkColor = new t.Color(1, 1, 1, 1), p.darkColor.setFromString(M)), 
                    p.attachmentName = this.getValue(d, "attachment", null), p.blendMode = e.blendModeFromString(this.getValue(d, "blend", "normal")), 
                    i.slots.push(p);
                }
                if (r.ik) for (var x = 0; x < r.ik.length; x++) {
                    var w = r.ik[x], E = new t.IkConstraintData(w.name);
                    E.order = this.getValue(w, "order", 0);
                    for (var k = 0; k < w.bones.length; k++) {
                        var T = w.bones[k], b = i.findBone(T);
                        if (null == b) throw new Error("IK bone not found: " + T);
                        E.bones.push(b);
                    }
                    var A = w.target;
                    if (E.target = i.findBone(A), null == E.target) throw new Error("IK target bone not found: " + A);
                    E.mix = this.getValue(w, "mix", 1), E.bendDirection = this.getValue(w, "bendPositive", !0) ? 1 : -1, 
                    E.compress = this.getValue(w, "compress", !1), E.stretch = this.getValue(w, "stretch", !1), 
                    E.uniform = this.getValue(w, "uniform", !1), i.ikConstraints.push(E);
                }
                if (r.transform) for (var R = 0; R < r.transform.length; R++) {
                    var S = r.transform[R], I = new t.TransformConstraintData(S.name);
                    I.order = this.getValue(S, "order", 0);
                    for (var P = 0; P < S.bones.length; P++) {
                        var C = S.bones[P], V = i.findBone(C);
                        if (null == V) throw new Error("Transform constraint bone not found: " + C);
                        I.bones.push(V);
                    }
                    var N = S.target;
                    if (I.target = i.findBone(N), null == I.target) throw new Error("Transform constraint target bone not found: " + N);
                    I.local = this.getValue(S, "local", !1), I.relative = this.getValue(S, "relative", !1), 
                    I.offsetRotation = this.getValue(S, "rotation", 0), I.offsetX = this.getValue(S, "x", 0) * n, 
                    I.offsetY = this.getValue(S, "y", 0) * n, I.offsetScaleX = this.getValue(S, "scaleX", 0), 
                    I.offsetScaleY = this.getValue(S, "scaleY", 0), I.offsetShearY = this.getValue(S, "shearY", 0), 
                    I.rotateMix = this.getValue(S, "rotateMix", 1), I.translateMix = this.getValue(S, "translateMix", 1), 
                    I.scaleMix = this.getValue(S, "scaleMix", 1), I.shearMix = this.getValue(S, "shearMix", 1), 
                    i.transformConstraints.push(I);
                }
                if (r.path) for (var Y = 0; Y < r.path.length; Y++) {
                    var X = r.path[Y], U = new t.PathConstraintData(X.name);
                    U.order = this.getValue(X, "order", 0);
                    for (var L = 0; L < X.bones.length; L++) {
                        var D = X.bones[L], F = i.findBone(D);
                        if (null == F) throw new Error("Transform constraint bone not found: " + D);
                        U.bones.push(F);
                    }
                    var _ = X.target;
                    if (U.target = i.findSlot(_), null == U.target) throw new Error("Path target slot not found: " + _);
                    U.positionMode = e.positionModeFromString(this.getValue(X, "positionMode", "percent")), 
                    U.spacingMode = e.spacingModeFromString(this.getValue(X, "spacingMode", "length")), 
                    U.rotateMode = e.rotateModeFromString(this.getValue(X, "rotateMode", "tangent")), 
                    U.offsetRotation = this.getValue(X, "rotation", 0), U.position = this.getValue(X, "position", 0), 
                    U.positionMode == t.PositionMode.Fixed && (U.position *= n), U.spacing = this.getValue(X, "spacing", 0), 
                    U.spacingMode != t.SpacingMode.Length && U.spacingMode != t.SpacingMode.Fixed || (U.spacing *= n), 
                    U.rotateMix = this.getValue(X, "rotateMix", 1), U.translateMix = this.getValue(X, "translateMix", 1), 
                    i.pathConstraints.push(U);
                }
                if (r.skins) for (var O in r.skins) {
                    var B = r.skins[O], W = new t.Skin(O);
                    for (var q in B) {
                        var H = i.findSlotIndex(q);
                        if (-1 == H) throw new Error("Slot not found: " + q);
                        var G = B[q];
                        for (var j in G) {
                            var z = this.readAttachment(G[j], W, H, j, i);
                            null != z && W.addAttachment(H, j, z);
                        }
                    }
                    i.skins.push(W), "default" == W.name && (i.defaultSkin = W);
                }
                for (var Z = 0, J = this.linkedMeshes.length; Z < J; Z++) {
                    var Q = this.linkedMeshes[Z], K = null == Q.skin ? i.defaultSkin : i.findSkin(Q.skin);
                    if (null == K) throw new Error("Skin not found: " + Q.skin);
                    var $ = K.getAttachment(Q.slotIndex, Q.parent);
                    if (null == $) throw new Error("Parent mesh not found: " + Q.parent);
                    Q.mesh.setParentMesh($), Q.mesh.updateUVs();
                }
                if (this.linkedMeshes.length = 0, r.events) for (var tt in r.events) {
                    var et = r.events[tt], at = new t.EventData(tt);
                    at.intValue = this.getValue(et, "int", 0), at.floatValue = this.getValue(et, "float", 0), 
                    at.stringValue = this.getValue(et, "string", ""), at.audioPath = this.getValue(et, "audio", null), 
                    null != at.audioPath && (at.volume = this.getValue(et, "volume", 1), at.balance = this.getValue(et, "balance", 0)), 
                    i.events.push(at);
                }
                if (r.animations) for (var nt in r.animations) {
                    var it = r.animations[nt];
                    this.readAnimation(it, nt, i);
                }
                return i;
            }
        }, {
            key: "readAttachment",
            value: function(e, n, i, r, s) {
                var o = this.scale;
                switch (r = this.getValue(e, "name", r), this.getValue(e, "type", "region")) {
                  case "region":
                    var l = this.getValue(e, "path", r), h = this.attachmentLoader.newRegionAttachment(n, r, l);
                    if (null == h) return null;
                    h.path = l, h.x = this.getValue(e, "x", 0) * o, h.y = this.getValue(e, "y", 0) * o, 
                    h.scaleX = this.getValue(e, "scaleX", 1), h.scaleY = this.getValue(e, "scaleY", 1), 
                    h.rotation = this.getValue(e, "rotation", 0), h.width = e.width * o, h.height = e.height * o;
                    var u = this.getValue(e, "color", null);
                    return null != u && h.color.setFromString(u), h.updateOffset(), h;

                  case "boundingbox":
                    var c = this.attachmentLoader.newBoundingBoxAttachment(n, r);
                    if (null == c) return null;
                    this.readVertices(e, c, e.vertexCount << 1);
                    var f = this.getValue(e, "color", null);
                    return null != f && c.color.setFromString(f), c;

                  case "mesh":
                  case "linkedmesh":
                    var d = this.getValue(e, "path", r), v = this.attachmentLoader.newMeshAttachment(n, r, d);
                    if (null == v) return null;
                    v.path = d;
                    var m = this.getValue(e, "color", null);
                    null != m && v.color.setFromString(m);
                    var g = this.getValue(e, "parent", null);
                    if (null != g) return v.inheritDeform = this.getValue(e, "deform", !0), this.linkedMeshes.push(new a(v, this.getValue(e, "skin", null), i, g)), 
                    v;
                    var p = e.uvs;
                    return this.readVertices(e, v, p.length), v.triangles = e.triangles, v.regionUVs = p, 
                    v.updateUVs(), v.hullLength = 2 * this.getValue(e, "hull", 0), v;

                  case "path":
                    var y = this.attachmentLoader.newPathAttachment(n, r);
                    if (null == y) return null;
                    y.closed = this.getValue(e, "closed", !1), y.constantSpeed = this.getValue(e, "constantSpeed", !0);
                    var M = e.vertexCount;
                    this.readVertices(e, y, M << 1);
                    for (var x = t.Utils.newArray(M / 3, 0), w = 0; w < e.lengths.length; w++) x[w] = e.lengths[w] * o;
                    y.lengths = x;
                    var E = this.getValue(e, "color", null);
                    return null != E && y.color.setFromString(E), y;

                  case "point":
                    var k = this.attachmentLoader.newPointAttachment(n, r);
                    if (null == k) return null;
                    k.x = this.getValue(e, "x", 0) * o, k.y = this.getValue(e, "y", 0) * o, k.rotation = this.getValue(e, "rotation", 0);
                    var T = this.getValue(e, "color", null);
                    return null != T && k.color.setFromString(T), k;

                  case "clipping":
                    var b = this.attachmentLoader.newClippingAttachment(n, r);
                    if (null == b) return null;
                    var A = this.getValue(e, "end", null);
                    if (null != A) {
                        var R = s.findSlot(A);
                        if (null == R) throw new Error("Clipping end slot not found: " + A);
                        b.endSlot = R;
                    }
                    var S = e.vertexCount;
                    this.readVertices(e, b, S << 1);
                    var I = this.getValue(e, "color", null);
                    return null != I && b.color.setFromString(I), b;
                }
                return null;
            }
        }, {
            key: "readVertices",
            value: function(e, a, n) {
                var i = this.scale;
                a.worldVerticesLength = n;
                var r = e.vertices;
                if (n != r.length) {
                    for (var s = new Array(), o = new Array(), l = 0, h = r.length; l < h; ) {
                        var u = r[l++];
                        o.push(u);
                        for (var c = l + 4 * u; l < c; l += 4) o.push(r[l]), s.push(r[l + 1] * i), s.push(r[l + 2] * i), 
                        s.push(r[l + 3]);
                    }
                    a.bones = o, a.vertices = t.Utils.toFloatArray(s);
                } else {
                    var f = t.Utils.toFloatArray(r);
                    if (1 != i) for (var d = 0, v = r.length; d < v; d++) f[d] *= i;
                    a.vertices = f;
                }
            }
        }, {
            key: "readAnimation",
            value: function(e, a, n) {
                var i = this.scale, r = new Array(), s = 0;
                if (e.slots) for (var o in e.slots) {
                    var l = e.slots[o], h = n.findSlotIndex(o);
                    if (-1 == h) throw new Error("Slot not found: " + o);
                    for (var u in l) {
                        var c = l[u];
                        if ("attachment" == u) {
                            var f = new t.AttachmentTimeline(c.length);
                            f.slotIndex = h;
                            for (var d = 0, v = 0; v < c.length; v++) {
                                var m = c[v];
                                f.setFrame(d++, m.time, m.name);
                            }
                            r.push(f), s = Math.max(s, f.frames[f.getFrameCount() - 1]);
                        } else if ("color" == u) {
                            var g = new t.ColorTimeline(c.length);
                            g.slotIndex = h;
                            for (var p = 0, y = 0; y < c.length; y++) {
                                var M = c[y], x = new t.Color();
                                x.setFromString(M.color), g.setFrame(p, M.time, x.r, x.g, x.b, x.a), this.readCurve(M, g, p), 
                                p++;
                            }
                            r.push(g), s = Math.max(s, g.frames[(g.getFrameCount() - 1) * t.ColorTimeline.ENTRIES]);
                        } else {
                            if ("twoColor" != u) throw new Error("Invalid timeline type for a slot: " + u + " (" + o + ")");
                            var w = new t.TwoColorTimeline(c.length);
                            w.slotIndex = h;
                            for (var E = 0, k = 0; k < c.length; k++) {
                                var T = c[k], b = new t.Color(), A = new t.Color();
                                b.setFromString(T.light), A.setFromString(T.dark), w.setFrame(E, T.time, b.r, b.g, b.b, b.a, A.r, A.g, A.b), 
                                this.readCurve(T, w, E), E++;
                            }
                            r.push(w), s = Math.max(s, w.frames[(w.getFrameCount() - 1) * t.TwoColorTimeline.ENTRIES]);
                        }
                    }
                }
                if (e.bones) for (var R in e.bones) {
                    var S = e.bones[R], I = n.findBoneIndex(R);
                    if (-1 == I) throw new Error("Bone not found: " + R);
                    for (var P in S) {
                        var C = S[P];
                        if ("rotate" === P) {
                            var V = new t.RotateTimeline(C.length);
                            V.boneIndex = I;
                            for (var N = 0, Y = 0; Y < C.length; Y++) {
                                var X = C[Y];
                                V.setFrame(N, X.time, X.angle), this.readCurve(X, V, N), N++;
                            }
                            r.push(V), s = Math.max(s, V.frames[(V.getFrameCount() - 1) * t.RotateTimeline.ENTRIES]);
                        } else {
                            if ("translate" !== P && "scale" !== P && "shear" !== P) throw new Error("Invalid timeline type for a bone: " + P + " (" + R + ")");
                            var U = null, L = 1;
                            "scale" === P ? U = new t.ScaleTimeline(C.length) : "shear" === P ? U = new t.ShearTimeline(C.length) : (U = new t.TranslateTimeline(C.length), 
                            L = i), U.boneIndex = I;
                            for (var D = 0, F = 0; F < C.length; F++) {
                                var _ = C[F], O = this.getValue(_, "x", 0), B = this.getValue(_, "y", 0);
                                U.setFrame(D, _.time, O * L, B * L), this.readCurve(_, U, D), D++;
                            }
                            r.push(U), s = Math.max(s, U.frames[(U.getFrameCount() - 1) * t.TranslateTimeline.ENTRIES]);
                        }
                    }
                }
                if (e.ik) for (var W in e.ik) {
                    var q = e.ik[W], H = n.findIkConstraint(W), G = new t.IkConstraintTimeline(q.length);
                    G.ikConstraintIndex = n.ikConstraints.indexOf(H);
                    for (var j = 0, z = 0; z < q.length; z++) {
                        var Z = q[z];
                        G.setFrame(j, Z.time, this.getValue(Z, "mix", 1), this.getValue(Z, "bendPositive", !0) ? 1 : -1, this.getValue(Z, "compress", !1), this.getValue(Z, "stretch", !1)), 
                        this.readCurve(Z, G, j), j++;
                    }
                    r.push(G), s = Math.max(s, G.frames[(G.getFrameCount() - 1) * t.IkConstraintTimeline.ENTRIES]);
                }
                if (e.transform) for (var J in e.transform) {
                    var Q = e.transform[J], K = n.findTransformConstraint(J), $ = new t.TransformConstraintTimeline(Q.length);
                    $.transformConstraintIndex = n.transformConstraints.indexOf(K);
                    for (var tt = 0, et = 0; et < Q.length; et++) {
                        var at = Q[et];
                        $.setFrame(tt, at.time, this.getValue(at, "rotateMix", 1), this.getValue(at, "translateMix", 1), this.getValue(at, "scaleMix", 1), this.getValue(at, "shearMix", 1)), 
                        this.readCurve(at, $, tt), tt++;
                    }
                    r.push($), s = Math.max(s, $.frames[($.getFrameCount() - 1) * t.TransformConstraintTimeline.ENTRIES]);
                }
                if (e.paths) for (var nt in e.paths) {
                    var it = e.paths[nt], rt = n.findPathConstraintIndex(nt);
                    if (-1 == rt) throw new Error("Path constraint not found: " + nt);
                    var st = n.pathConstraints[rt];
                    for (var ot in it) {
                        var lt = it[ot];
                        if ("position" === ot || "spacing" === ot) {
                            var ht = null, ut = 1;
                            "spacing" === ot ? (ht = new t.PathConstraintSpacingTimeline(lt.length), st.spacingMode != t.SpacingMode.Length && st.spacingMode != t.SpacingMode.Fixed || (ut = i)) : (ht = new t.PathConstraintPositionTimeline(lt.length), 
                            st.positionMode == t.PositionMode.Fixed && (ut = i)), ht.pathConstraintIndex = rt;
                            for (var ct = 0, ft = 0; ft < lt.length; ft++) {
                                var dt = lt[ft];
                                ht.setFrame(ct, dt.time, this.getValue(dt, ot, 0) * ut), this.readCurve(dt, ht, ct), 
                                ct++;
                            }
                            r.push(ht), s = Math.max(s, ht.frames[(ht.getFrameCount() - 1) * t.PathConstraintPositionTimeline.ENTRIES]);
                        } else if ("mix" === ot) {
                            var vt = new t.PathConstraintMixTimeline(lt.length);
                            vt.pathConstraintIndex = rt;
                            for (var mt = 0, gt = 0; gt < lt.length; gt++) {
                                var pt = lt[gt];
                                vt.setFrame(mt, pt.time, this.getValue(pt, "rotateMix", 1), this.getValue(pt, "translateMix", 1)), 
                                this.readCurve(pt, vt, mt), mt++;
                            }
                            r.push(vt), s = Math.max(s, vt.frames[(vt.getFrameCount() - 1) * t.PathConstraintMixTimeline.ENTRIES]);
                        }
                    }
                }
                if (e.deform) for (var yt in e.deform) {
                    var Mt = e.deform[yt], xt = n.findSkin(yt);
                    if (null == xt) throw new Error("Skin not found: " + yt);
                    for (var wt in Mt) {
                        var Et = Mt[wt], kt = n.findSlotIndex(wt);
                        if (-1 == kt) throw new Error("Slot not found: " + Et.name);
                        for (var Tt in Et) {
                            var bt = Et[Tt], At = xt.getAttachment(kt, Tt);
                            if (null == At) throw new Error("Deform attachment not found: " + bt.name);
                            var Rt = null != At.bones, St = At.vertices, It = Rt ? St.length / 3 * 2 : St.length, Pt = new t.DeformTimeline(bt.length);
                            Pt.slotIndex = kt, Pt.attachment = At;
                            for (var Ct = 0, Vt = 0; Vt < bt.length; Vt++) {
                                var Nt = void 0, Yt = bt[Vt], Xt = this.getValue(Yt, "vertices", null);
                                if (null == Xt) Nt = Rt ? t.Utils.newFloatArray(It) : St; else {
                                    Nt = t.Utils.newFloatArray(It);
                                    var Ut = this.getValue(Yt, "offset", 0);
                                    if (t.Utils.arrayCopy(Xt, 0, Nt, Ut, Xt.length), 1 != i) for (var Lt = Ut, Dt = Lt + Xt.length; Lt < Dt; Lt++) Nt[Lt] *= i;
                                    if (!Rt) for (var Ft = 0; Ft < It; Ft++) Nt[Ft] += St[Ft];
                                }
                                Pt.setFrame(Ct, Yt.time, Nt), this.readCurve(Yt, Pt, Ct), Ct++;
                            }
                            r.push(Pt), s = Math.max(s, Pt.frames[Pt.getFrameCount() - 1]);
                        }
                    }
                }
                var _t = e.drawOrder;
                if (null == _t && (_t = e.draworder), null != _t) {
                    for (var Ot = new t.DrawOrderTimeline(_t.length), Bt = n.slots.length, Wt = 0, qt = 0; qt < _t.length; qt++) {
                        var Ht = _t[qt], Gt = null, jt = this.getValue(Ht, "offsets", null);
                        if (null != jt) {
                            Gt = t.Utils.newArray(Bt, -1);
                            for (var zt = t.Utils.newArray(Bt - jt.length, 0), Zt = 0, Jt = 0, Qt = 0; Qt < jt.length; Qt++) {
                                var Kt = jt[Qt], $t = n.findSlotIndex(Kt.slot);
                                if (-1 == $t) throw new Error("Slot not found: " + Kt.slot);
                                for (;Zt != $t; ) zt[Jt++] = Zt++;
                                Gt[Zt + Kt.offset] = Zt++;
                            }
                            for (;Zt < Bt; ) zt[Jt++] = Zt++;
                            for (var te = Bt - 1; te >= 0; te--) -1 == Gt[te] && (Gt[te] = zt[--Jt]);
                        }
                        Ot.setFrame(Wt++, Ht.time, Gt);
                    }
                    r.push(Ot), s = Math.max(s, Ot.frames[Ot.getFrameCount() - 1]);
                }
                if (e.events) {
                    for (var ee = new t.EventTimeline(e.events.length), ae = 0, ne = 0; ne < e.events.length; ne++) {
                        var ie = e.events[ne], re = n.findEvent(ie.name);
                        if (null == re) throw new Error("Event not found: " + ie.name);
                        var se = new t.Event(t.Utils.toSinglePrecision(ie.time), re);
                        se.intValue = this.getValue(ie, "int", re.intValue), se.floatValue = this.getValue(ie, "float", re.floatValue), 
                        se.stringValue = this.getValue(ie, "string", re.stringValue), null != se.data.audioPath && (se.volume = this.getValue(ie, "volume", 1), 
                        se.balance = this.getValue(ie, "balance", 0)), ee.setFrame(ae++, se);
                    }
                    r.push(ee), s = Math.max(s, ee.frames[ee.getFrameCount() - 1]);
                }
                if (isNaN(s)) throw new Error("Error while parsing animation, duration is NaN");
                n.animations.push(new t.Animation(a, r, s));
            }
        }, {
            key: "readCurve",
            value: function(t, e, a) {
                if (t.curve) if ("stepped" === t.curve) e.setStepped(a); else if ("[object Array]" === Object.prototype.toString.call(t.curve)) {
                    var n = t.curve;
                    e.setCurve(a, n[0], n[1], n[2], n[3]);
                }
            }
        }, {
            key: "getValue",
            value: function(t, e, a) {
                return void 0 !== t[e] ? t[e] : a;
            }
        } ], [ {
            key: "blendModeFromString",
            value: function(e) {
                if ("normal" == (e = e.toLowerCase())) return t.BlendMode.Normal;
                if ("additive" == e) return t.BlendMode.Additive;
                if ("multiply" == e) return t.BlendMode.Multiply;
                if ("screen" == e) return t.BlendMode.Screen;
                throw new Error("Unknown blend mode: " + e);
            }
        }, {
            key: "positionModeFromString",
            value: function(e) {
                if ("fixed" == (e = e.toLowerCase())) return t.PositionMode.Fixed;
                if ("percent" == e) return t.PositionMode.Percent;
                throw new Error("Unknown position mode: " + e);
            }
        }, {
            key: "spacingModeFromString",
            value: function(e) {
                if ("length" == (e = e.toLowerCase())) return t.SpacingMode.Length;
                if ("fixed" == e) return t.SpacingMode.Fixed;
                if ("percent" == e) return t.SpacingMode.Percent;
                throw new Error("Unknown position mode: " + e);
            }
        }, {
            key: "rotateModeFromString",
            value: function(e) {
                if ("tangent" == (e = e.toLowerCase())) return t.RotateMode.Tangent;
                if ("chain" == e) return t.RotateMode.Chain;
                if ("chainscale" == e) return t.RotateMode.ChainScale;
                throw new Error("Unknown rotate mode: " + e);
            }
        }, {
            key: "transformModeFromString",
            value: function(e) {
                if ("normal" == (e = e.toLowerCase())) return t.TransformMode.Normal;
                if ("onlytranslation" == e) return t.TransformMode.OnlyTranslation;
                if ("norotationorreflection" == e) return t.TransformMode.NoRotationOrReflection;
                if ("noscale" == e) return t.TransformMode.NoScale;
                if ("noscaleorreflection" == e) return t.TransformMode.NoScaleOrReflection;
                throw new Error("Unknown transform mode: " + e);
            }
        } ]), e;
    }();
    t.SkeletonJson = e;
    var a = function t(e, a, n, i) {
        r(this, t), this.mesh = e, this.skin = a, this.slotIndex = n, this.parent = i;
    };
}(t || (t = {})), (t || (t = {})).Skin = function() {
    function t(e) {
        if (r(this, t), this.attachments = new Array(), null == e) throw new Error("name cannot be null.");
        this.name = e;
    }
    return s(t, [ {
        key: "addAttachment",
        value: function(t, e, a) {
            if (null == a) throw new Error("attachment cannot be null.");
            var n = this.attachments;
            t >= n.length && (n.length = t + 1), n[t] || (n[t] = {}), n[t][e] = a;
        }
    }, {
        key: "getAttachment",
        value: function(t, e) {
            var a = this.attachments[t];
            return a ? a[e] : null;
        }
    }, {
        key: "attachAll",
        value: function(t, e) {
            for (var a = 0, n = 0; n < t.slots.length; n++) {
                var i = t.slots[n], r = i.getAttachment();
                if (r && a < e.attachments.length) {
                    var s = e.attachments[a];
                    for (var o in s) if (r == s[o]) {
                        var l = this.getAttachment(a, o);
                        null != l && i.setAttachment(l);
                        break;
                    }
                }
                a++;
            }
        }
    } ]), t;
}(), function(t) {
    t.Slot = function() {
        function e(a, n) {
            if (r(this, e), this.attachmentVertices = new Array(), null == a) throw new Error("data cannot be null.");
            if (null == n) throw new Error("bone cannot be null.");
            this.data = a, this.bone = n, this.color = new t.Color(), this.darkColor = null == a.darkColor ? null : new t.Color(), 
            this.setToSetupPose();
        }
        return s(e, [ {
            key: "getAttachment",
            value: function() {
                return this.attachment;
            }
        }, {
            key: "setAttachment",
            value: function(t) {
                this.attachment != t && (this.attachment = t, this.attachmentTime = this.bone.skeleton.time, 
                this.attachmentVertices.length = 0);
            }
        }, {
            key: "setAttachmentTime",
            value: function(t) {
                this.attachmentTime = this.bone.skeleton.time - t;
            }
        }, {
            key: "getAttachmentTime",
            value: function() {
                return this.bone.skeleton.time - this.attachmentTime;
            }
        }, {
            key: "setToSetupPose",
            value: function() {
                this.color.setFromColor(this.data.color), null != this.darkColor && this.darkColor.setFromColor(this.data.darkColor), 
                null == this.data.attachmentName ? this.attachment = null : (this.attachment = null, 
                this.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName)));
            }
        } ]), e;
    }();
}(t || (t = {})), function(t) {
    t.SlotData = function() {
        return function e(a, n, i) {
            if (r(this, e), this.color = new t.Color(1, 1, 1, 1), a < 0) throw new Error("index must be >= 0.");
            if (null == n) throw new Error("name cannot be null.");
            if (null == i) throw new Error("boneData cannot be null.");
            this.index = a, this.name = n, this.boneData = i;
        };
    }();
}(t || (t = {})), function(t) {
    var e, a, o = function() {
        function t(e) {
            r(this, t), this._image = e;
        }
        return s(t, [ {
            key: "getImage",
            value: function() {
                return this._image;
            }
        } ], [ {
            key: "filterFromString",
            value: function(t) {
                switch (t.toLowerCase()) {
                  case "nearest":
                    return e.Nearest;

                  case "linear":
                    return e.Linear;

                  case "mipmap":
                    return e.MipMap;

                  case "mipmapnearestnearest":
                    return e.MipMapNearestNearest;

                  case "mipmaplinearnearest":
                    return e.MipMapLinearNearest;

                  case "mipmapnearestlinear":
                    return e.MipMapNearestLinear;

                  case "mipmaplinearlinear":
                    return e.MipMapLinearLinear;

                  default:
                    throw new Error("Unknown texture filter " + t);
                }
            }
        }, {
            key: "wrapFromString",
            value: function(t) {
                switch (t.toLowerCase()) {
                  case "mirroredtepeat":
                    return a.MirroredRepeat;

                  case "clamptoedge":
                    return a.ClampToEdge;

                  case "repeat":
                    return a.Repeat;

                  default:
                    throw new Error("Unknown texture wrap " + t);
                }
            }
        } ]), t;
    }();
    t.Texture = o, function(t) {
        t[t.Nearest = 9728] = "Nearest", t[t.Linear = 9729] = "Linear", t[t.MipMap = 9987] = "MipMap", 
        t[t.MipMapNearestNearest = 9984] = "MipMapNearestNearest", t[t.MipMapLinearNearest = 9985] = "MipMapLinearNearest", 
        t[t.MipMapNearestLinear = 9986] = "MipMapNearestLinear", t[t.MipMapLinearLinear = 9987] = "MipMapLinearLinear";
    }(e = t.TextureFilter || (t.TextureFilter = {})), function(t) {
        t[t.MirroredRepeat = 33648] = "MirroredRepeat", t[t.ClampToEdge = 33071] = "ClampToEdge", 
        t[t.Repeat = 10497] = "Repeat";
    }(a = t.TextureWrap || (t.TextureWrap = {})), t.TextureRegion = function() {
        return function t() {
            r(this, t), this.u = 0, this.v = 0, this.u2 = 0, this.v2 = 0, this.width = 0, this.height = 0, 
            this.rotate = !1, this.offsetX = 0, this.offsetY = 0, this.originalWidth = 0, this.originalHeight = 0;
        };
    }(), t.FakeTexture = function(t) {
        n(a, t);
        var e = i(a);
        function a() {
            return r(this, a), e.apply(this, arguments);
        }
        return s(a, [ {
            key: "setFilters",
            value: function(t, e) {}
        }, {
            key: "setWraps",
            value: function(t, e) {}
        }, {
            key: "dispose",
            value: function() {}
        } ]), a;
    }(o);
}(t || (t = {})), function(t) {
    t.TextureAtlas = function() {
        function n(t, e) {
            r(this, n), this.pages = new Array(), this.regions = new Array(), this.load(t, e);
        }
        return s(n, [ {
            key: "load",
            value: function(n, i) {
                if (null == i) throw new Error("textureLoader cannot be null.");
                for (var r = new e(n), s = new Array(4), l = null; ;) {
                    var h = r.readLine();
                    if (null == h) break;
                    if (0 == (h = h.trim()).length) l = null; else if (l) {
                        var u = new o();
                        u.name = h, u.page = l, u.rotate = "true" == r.readValue(), r.readTuple(s);
                        var c = parseInt(s[0]), f = parseInt(s[1]);
                        r.readTuple(s);
                        var d = parseInt(s[0]), v = parseInt(s[1]);
                        u.u = c / l.width, u.v = f / l.height, u.rotate ? (u.u2 = (c + v) / l.width, u.v2 = (f + d) / l.height) : (u.u2 = (c + d) / l.width, 
                        u.v2 = (f + v) / l.height), u.x = c, u.y = f, u.width = Math.abs(d), u.height = Math.abs(v), 
                        4 == r.readTuple(s) && 4 == r.readTuple(s) && r.readTuple(s), u.originalWidth = parseInt(s[0]), 
                        u.originalHeight = parseInt(s[1]), r.readTuple(s), u.offsetX = parseInt(s[0]), u.offsetY = parseInt(s[1]), 
                        u.index = parseInt(r.readValue()), u.texture = l.texture, this.regions.push(u);
                    } else {
                        (l = new a()).name = h, 2 == r.readTuple(s) && (l.width = parseInt(s[0]), l.height = parseInt(s[1]), 
                        r.readTuple(s)), r.readTuple(s), l.minFilter = t.Texture.filterFromString(s[0]), 
                        l.magFilter = t.Texture.filterFromString(s[1]);
                        var m = r.readValue();
                        l.uWrap = t.TextureWrap.ClampToEdge, l.vWrap = t.TextureWrap.ClampToEdge, "x" == m ? l.uWrap = t.TextureWrap.Repeat : "y" == m ? l.vWrap = t.TextureWrap.Repeat : "xy" == m && (l.uWrap = l.vWrap = t.TextureWrap.Repeat), 
                        l.texture = i(h), l.texture.setFilters(l.minFilter, l.magFilter), l.texture.setWraps(l.uWrap, l.vWrap), 
                        l.width = l.texture.getImage().width, l.height = l.texture.getImage().height, this.pages.push(l);
                    }
                }
            }
        }, {
            key: "findRegion",
            value: function(t) {
                for (var e = 0; e < this.regions.length; e++) if (this.regions[e].name == t) return this.regions[e];
                return null;
            }
        }, {
            key: "dispose",
            value: function() {
                for (var t = 0; t < this.pages.length; t++) this.pages[t].texture.dispose();
            }
        } ]), n;
    }();
    var e = function() {
        function t(e) {
            r(this, t), this.index = 0, this.lines = e.split(/\r\n|\r|\n/);
        }
        return s(t, [ {
            key: "readLine",
            value: function() {
                return this.index >= this.lines.length ? null : this.lines[this.index++];
            }
        }, {
            key: "readValue",
            value: function() {
                var t = this.readLine(), e = t.indexOf(":");
                if (-1 == e) throw new Error("Invalid line: " + t);
                return t.substring(e + 1).trim();
            }
        }, {
            key: "readTuple",
            value: function(t) {
                var e = this.readLine(), a = e.indexOf(":");
                if (-1 == a) throw new Error("Invalid line: " + e);
                for (var n = 0, i = a + 1; n < 3; n++) {
                    var r = e.indexOf(",", i);
                    if (-1 == r) break;
                    t[n] = e.substr(i, r - i).trim(), i = r + 1;
                }
                return t[n] = e.substring(i).trim(), n + 1;
            }
        } ]), t;
    }(), a = function t() {
        r(this, t);
    };
    t.TextureAtlasPage = a;
    var o = function(t) {
        n(a, t);
        var e = i(a);
        function a() {
            return r(this, a), e.apply(this, arguments);
        }
        return a;
    }(t.TextureRegion);
    t.TextureAtlasRegion = o;
}(t || (t = {})), function(t) {
    t.TransformConstraint = function() {
        function e(a, n) {
            if (r(this, e), this.rotateMix = 0, this.translateMix = 0, this.scaleMix = 0, this.shearMix = 0, 
            this.temp = new t.Vector2(), null == a) throw new Error("data cannot be null.");
            if (null == n) throw new Error("skeleton cannot be null.");
            this.data = a, this.rotateMix = a.rotateMix, this.translateMix = a.translateMix, 
            this.scaleMix = a.scaleMix, this.shearMix = a.shearMix, this.bones = new Array();
            for (var i = 0; i < a.bones.length; i++) this.bones.push(n.findBone(a.bones[i].name));
            this.target = n.findBone(a.target.name);
        }
        return s(e, [ {
            key: "apply",
            value: function() {
                this.update();
            }
        }, {
            key: "update",
            value: function() {
                this.data.local ? this.data.relative ? this.applyRelativeLocal() : this.applyAbsoluteLocal() : this.data.relative ? this.applyRelativeWorld() : this.applyAbsoluteWorld();
            }
        }, {
            key: "applyAbsoluteWorld",
            value: function() {
                for (var e = this.rotateMix, a = this.translateMix, n = this.scaleMix, i = this.shearMix, r = this.target, s = r.a, o = r.b, l = r.c, h = r.d, u = s * h - o * l > 0 ? t.MathUtils.degRad : -t.MathUtils.degRad, c = this.data.offsetRotation * u, f = this.data.offsetShearY * u, d = this.bones, v = 0, m = d.length; v < m; v++) {
                    var g = d[v], p = !1;
                    if (0 != e) {
                        var y = g.a, M = g.b, x = g.c, w = g.d, E = Math.atan2(l, s) - Math.atan2(x, y) + c;
                        E > t.MathUtils.PI ? E -= t.MathUtils.PI2 : E < -t.MathUtils.PI && (E += t.MathUtils.PI2), 
                        E *= e;
                        var k = Math.cos(E), T = Math.sin(E);
                        g.a = k * y - T * x, g.b = k * M - T * w, g.c = T * y + k * x, g.d = T * M + k * w, 
                        p = !0;
                    }
                    if (0 != a) {
                        var b = this.temp;
                        r.localToWorld(b.set(this.data.offsetX, this.data.offsetY)), g.worldX += (b.x - g.worldX) * a, 
                        g.worldY += (b.y - g.worldY) * a, p = !0;
                    }
                    if (n > 0) {
                        var A = Math.sqrt(g.a * g.a + g.c * g.c), R = Math.sqrt(s * s + l * l);
                        A > 1e-5 && (A = (A + (R - A + this.data.offsetScaleX) * n) / A), g.a *= A, g.c *= A, 
                        A = Math.sqrt(g.b * g.b + g.d * g.d), R = Math.sqrt(o * o + h * h), A > 1e-5 && (A = (A + (R - A + this.data.offsetScaleY) * n) / A), 
                        g.b *= A, g.d *= A, p = !0;
                    }
                    if (i > 0) {
                        var S = g.b, I = g.d, P = Math.atan2(I, S), C = Math.atan2(h, o) - Math.atan2(l, s) - (P - Math.atan2(g.c, g.a));
                        C > t.MathUtils.PI ? C -= t.MathUtils.PI2 : C < -t.MathUtils.PI && (C += t.MathUtils.PI2), 
                        C = P + (C + f) * i;
                        var V = Math.sqrt(S * S + I * I);
                        g.b = Math.cos(C) * V, g.d = Math.sin(C) * V, p = !0;
                    }
                    p && (g.appliedValid = !1);
                }
            }
        }, {
            key: "applyRelativeWorld",
            value: function() {
                for (var e = this.rotateMix, a = this.translateMix, n = this.scaleMix, i = this.shearMix, r = this.target, s = r.a, o = r.b, l = r.c, h = r.d, u = s * h - o * l > 0 ? t.MathUtils.degRad : -t.MathUtils.degRad, c = this.data.offsetRotation * u, f = this.data.offsetShearY * u, d = this.bones, v = 0, m = d.length; v < m; v++) {
                    var g = d[v], p = !1;
                    if (0 != e) {
                        var y = g.a, M = g.b, x = g.c, w = g.d, E = Math.atan2(l, s) + c;
                        E > t.MathUtils.PI ? E -= t.MathUtils.PI2 : E < -t.MathUtils.PI && (E += t.MathUtils.PI2), 
                        E *= e;
                        var k = Math.cos(E), T = Math.sin(E);
                        g.a = k * y - T * x, g.b = k * M - T * w, g.c = T * y + k * x, g.d = T * M + k * w, 
                        p = !0;
                    }
                    if (0 != a) {
                        var b = this.temp;
                        r.localToWorld(b.set(this.data.offsetX, this.data.offsetY)), g.worldX += b.x * a, 
                        g.worldY += b.y * a, p = !0;
                    }
                    if (n > 0) {
                        var A = (Math.sqrt(s * s + l * l) - 1 + this.data.offsetScaleX) * n + 1;
                        g.a *= A, g.c *= A, A = (Math.sqrt(o * o + h * h) - 1 + this.data.offsetScaleY) * n + 1, 
                        g.b *= A, g.d *= A, p = !0;
                    }
                    if (i > 0) {
                        var R = Math.atan2(h, o) - Math.atan2(l, s);
                        R > t.MathUtils.PI ? R -= t.MathUtils.PI2 : R < -t.MathUtils.PI && (R += t.MathUtils.PI2);
                        var S = g.b, I = g.d;
                        R = Math.atan2(I, S) + (R - t.MathUtils.PI / 2 + f) * i;
                        var P = Math.sqrt(S * S + I * I);
                        g.b = Math.cos(R) * P, g.d = Math.sin(R) * P, p = !0;
                    }
                    p && (g.appliedValid = !1);
                }
            }
        }, {
            key: "applyAbsoluteLocal",
            value: function() {
                var t = this.rotateMix, e = this.translateMix, a = this.scaleMix, n = this.shearMix, i = this.target;
                i.appliedValid || i.updateAppliedTransform();
                for (var r = this.bones, s = 0, o = r.length; s < o; s++) {
                    var l = r[s];
                    l.appliedValid || l.updateAppliedTransform();
                    var h = l.arotation;
                    if (0 != t) {
                        var u = i.arotation - h + this.data.offsetRotation;
                        h += (u -= 360 * (16384 - (16384.499999999996 - u / 360 | 0))) * t;
                    }
                    var c = l.ax, f = l.ay;
                    0 != e && (c += (i.ax - c + this.data.offsetX) * e, f += (i.ay - f + this.data.offsetY) * e);
                    var d = l.ascaleX, v = l.ascaleY;
                    0 != a && (d > 1e-5 && (d = (d + (i.ascaleX - d + this.data.offsetScaleX) * a) / d), 
                    v > 1e-5 && (v = (v + (i.ascaleY - v + this.data.offsetScaleY) * a) / v));
                    var m = l.ashearY;
                    if (0 != n) {
                        var g = i.ashearY - m + this.data.offsetShearY;
                        g -= 360 * (16384 - (16384.499999999996 - g / 360 | 0)), l.shearY += g * n;
                    }
                    l.updateWorldTransformWith(c, f, h, d, v, l.ashearX, m);
                }
            }
        }, {
            key: "applyRelativeLocal",
            value: function() {
                var t = this.rotateMix, e = this.translateMix, a = this.scaleMix, n = this.shearMix, i = this.target;
                i.appliedValid || i.updateAppliedTransform();
                for (var r = this.bones, s = 0, o = r.length; s < o; s++) {
                    var l = r[s];
                    l.appliedValid || l.updateAppliedTransform();
                    var h = l.arotation;
                    0 != t && (h += (i.arotation + this.data.offsetRotation) * t);
                    var u = l.ax, c = l.ay;
                    0 != e && (u += (i.ax + this.data.offsetX) * e, c += (i.ay + this.data.offsetY) * e);
                    var f = l.ascaleX, d = l.ascaleY;
                    0 != a && (f > 1e-5 && (f *= (i.ascaleX - 1 + this.data.offsetScaleX) * a + 1), 
                    d > 1e-5 && (d *= (i.ascaleY - 1 + this.data.offsetScaleY) * a + 1));
                    var v = l.ashearY;
                    0 != n && (v += (i.ashearY + this.data.offsetShearY) * n), l.updateWorldTransformWith(u, c, h, f, d, l.ashearX, v);
                }
            }
        }, {
            key: "getOrder",
            value: function() {
                return this.data.order;
            }
        } ]), e;
    }();
}(t || (t = {})), (t || (t = {})).TransformConstraintData = function() {
    return function t(e) {
        if (r(this, t), this.order = 0, this.bones = new Array(), this.rotateMix = 0, this.translateMix = 0, 
        this.scaleMix = 0, this.shearMix = 0, this.offsetRotation = 0, this.offsetX = 0, 
        this.offsetY = 0, this.offsetScaleX = 0, this.offsetScaleY = 0, this.offsetShearY = 0, 
        this.relative = !1, this.local = !1, null == e) throw new Error("name cannot be null.");
        this.name = e;
    };
}(), function(t) {
    var e = function() {
        function e() {
            r(this, e), this.convexPolygons = new Array(), this.convexPolygonsIndices = new Array(), 
            this.indicesArray = new Array(), this.isConcaveArray = new Array(), this.triangles = new Array(), 
            this.polygonPool = new t.Pool(function() {
                return new Array();
            }), this.polygonIndicesPool = new t.Pool(function() {
                return new Array();
            });
        }
        return s(e, [ {
            key: "triangulate",
            value: function(t) {
                var a = t, n = t.length >> 1, i = this.indicesArray;
                i.length = 0;
                for (var r = 0; r < n; r++) i[r] = r;
                var s = this.isConcaveArray;
                s.length = 0;
                for (var o = 0, l = n; o < l; ++o) s[o] = e.isConcave(o, n, a, i);
                var h = this.triangles;
                for (h.length = 0; n > 3; ) {
                    for (var u = n - 1, c = 0, f = 1; ;) {
                        t: if (!s[c]) {
                            for (var d = i[u] << 1, v = i[c] << 1, m = i[f] << 1, g = a[d], p = a[d + 1], y = a[v], M = a[v + 1], x = a[m], w = a[m + 1], E = (f + 1) % n; E != u; E = (E + 1) % n) if (s[E]) {
                                var k = i[E] << 1, T = a[k], b = a[k + 1];
                                if (e.positiveArea(x, w, g, p, T, b) && e.positiveArea(g, p, y, M, T, b) && e.positiveArea(y, M, x, w, T, b)) break t;
                            }
                            break;
                        }
                        if (0 == f) {
                            do {
                                if (!s[c]) break;
                                c--;
                            } while (c > 0);
                            break;
                        }
                        u = c, c = f, f = (f + 1) % n;
                    }
                    h.push(i[(n + c - 1) % n]), h.push(i[c]), h.push(i[(c + 1) % n]), i.splice(c, 1), 
                    s.splice(c, 1);
                    var A = (--n + c - 1) % n, R = c == n ? 0 : c;
                    s[A] = e.isConcave(A, n, a, i), s[R] = e.isConcave(R, n, a, i);
                }
                return 3 == n && (h.push(i[2]), h.push(i[0]), h.push(i[1])), h;
            }
        }, {
            key: "decompose",
            value: function(t, a) {
                var n = t, i = this.convexPolygons;
                this.polygonPool.freeAll(i), i.length = 0;
                var r = this.convexPolygonsIndices;
                this.polygonIndicesPool.freeAll(r), r.length = 0;
                var s = this.polygonIndicesPool.obtain();
                s.length = 0;
                var o = this.polygonPool.obtain();
                o.length = 0;
                for (var l = -1, h = 0, u = 0, c = a.length; u < c; u += 3) {
                    var f = a[u] << 1, d = a[u + 1] << 1, v = a[u + 2] << 1, m = n[f], g = n[f + 1], p = n[d], y = n[d + 1], M = n[v], x = n[v + 1], w = !1;
                    if (l == f) {
                        var E = o.length - 4, k = e.winding(o[E], o[E + 1], o[E + 2], o[E + 3], M, x), T = e.winding(M, x, o[0], o[1], o[2], o[3]);
                        k == h && T == h && (o.push(M), o.push(x), s.push(v), w = !0);
                    }
                    w || (o.length > 0 ? (i.push(o), r.push(s)) : (this.polygonPool.free(o), this.polygonIndicesPool.free(s)), 
                    (o = this.polygonPool.obtain()).length = 0, o.push(m), o.push(g), o.push(p), o.push(y), 
                    o.push(M), o.push(x), (s = this.polygonIndicesPool.obtain()).length = 0, s.push(f), 
                    s.push(d), s.push(v), h = e.winding(m, g, p, y, M, x), l = f);
                }
                o.length > 0 && (i.push(o), r.push(s));
                for (var b = 0, A = i.length; b < A; b++) if (0 != (s = r[b]).length) for (var R = s[0], S = s[s.length - 1], I = (o = i[b]).length - 4, P = o[I], C = o[I + 1], V = o[I + 2], N = o[I + 3], Y = o[0], X = o[1], U = o[2], L = o[3], D = e.winding(P, C, V, N, Y, X), F = 0; F < A; F++) if (F != b) {
                    var _ = r[F];
                    if (3 == _.length) {
                        var O = _[0], B = _[1], W = _[2], q = i[F], H = q[q.length - 2], G = q[q.length - 1];
                        if (O == R && B == S) {
                            var j = e.winding(P, C, V, N, H, G), z = e.winding(H, G, Y, X, U, L);
                            j == D && z == D && (q.length = 0, _.length = 0, o.push(H), o.push(G), s.push(W), 
                            P = V, C = N, V = H, N = G, F = 0);
                        }
                    }
                }
                for (var Z = i.length - 1; Z >= 0; Z--) 0 == (o = i[Z]).length && (i.splice(Z, 1), 
                this.polygonPool.free(o), s = r[Z], r.splice(Z, 1), this.polygonIndicesPool.free(s));
                return i;
            }
        } ], [ {
            key: "isConcave",
            value: function(t, e, a, n) {
                var i = n[(e + t - 1) % e] << 1, r = n[t] << 1, s = n[(t + 1) % e] << 1;
                return !this.positiveArea(a[i], a[i + 1], a[r], a[r + 1], a[s], a[s + 1]);
            }
        }, {
            key: "positiveArea",
            value: function(t, e, a, n, i, r) {
                return t * (r - n) + a * (e - r) + i * (n - e) >= 0;
            }
        }, {
            key: "winding",
            value: function(t, e, a, n, i, r) {
                var s = a - t, o = n - e;
                return i * o - r * s + s * e - t * o >= 0 ? 1 : -1;
            }
        } ]), e;
    }();
    t.Triangulator = e;
}(t || (t = {})), function(t) {
    t.IntSet = function() {
        function t() {
            r(this, t), this.array = new Array();
        }
        return s(t, [ {
            key: "add",
            value: function(t) {
                var e = this.contains(t);
                return this.array[0 | t] = 0 | t, !e;
            }
        }, {
            key: "contains",
            value: function(t) {
                return null != this.array[0 | t];
            }
        }, {
            key: "remove",
            value: function(t) {
                this.array[0 | t] = void 0;
            }
        }, {
            key: "clear",
            value: function() {
                this.array.length = 0;
            }
        } ]), t;
    }();
    var e = function() {
        function t() {
            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, a = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0;
            r(this, t), this.r = e, this.g = a, this.b = n, this.a = i;
        }
        return s(t, [ {
            key: "set",
            value: function(t, e, a, n) {
                return this.r = t, this.g = e, this.b = a, this.a = n, this.clamp(), this;
            }
        }, {
            key: "setFromColor",
            value: function(t) {
                return this.r = t.r, this.g = t.g, this.b = t.b, this.a = t.a, this;
            }
        }, {
            key: "setFromString",
            value: function(t) {
                return t = "#" == t.charAt(0) ? t.substr(1) : t, this.r = parseInt(t.substr(0, 2), 16) / 255, 
                this.g = parseInt(t.substr(2, 2), 16) / 255, this.b = parseInt(t.substr(4, 2), 16) / 255, 
                this.a = (8 != t.length ? 255 : parseInt(t.substr(6, 2), 16)) / 255, this;
            }
        }, {
            key: "add",
            value: function(t, e, a, n) {
                return this.r += t, this.g += e, this.b += a, this.a += n, this.clamp(), this;
            }
        }, {
            key: "clamp",
            value: function() {
                return this.r < 0 ? this.r = 0 : this.r > 1 && (this.r = 1), this.g < 0 ? this.g = 0 : this.g > 1 && (this.g = 1), 
                this.b < 0 ? this.b = 0 : this.b > 1 && (this.b = 1), this.a < 0 ? this.a = 0 : this.a > 1 && (this.a = 1), 
                this;
            }
        } ]), t;
    }();
    e.WHITE = new e(1, 1, 1, 1), e.RED = new e(1, 0, 0, 1), e.GREEN = new e(0, 1, 0, 1), 
    e.BLUE = new e(0, 0, 1, 1), e.MAGENTA = new e(1, 0, 1, 1), t.Color = e;
    var a = function() {
        function t() {
            r(this, t);
        }
        return s(t, null, [ {
            key: "clamp",
            value: function(t, e, a) {
                return t < e ? e : t > a ? a : t;
            }
        }, {
            key: "cosDeg",
            value: function(e) {
                return Math.cos(e * t.degRad);
            }
        }, {
            key: "sinDeg",
            value: function(e) {
                return Math.sin(e * t.degRad);
            }
        }, {
            key: "signum",
            value: function(t) {
                return t > 0 ? 1 : t < 0 ? -1 : 0;
            }
        }, {
            key: "toInt",
            value: function(t) {
                return t > 0 ? Math.floor(t) : Math.ceil(t);
            }
        }, {
            key: "cbrt",
            value: function(t) {
                var e = Math.pow(Math.abs(t), 1 / 3);
                return t < 0 ? -e : e;
            }
        }, {
            key: "randomTriangular",
            value: function(e, a) {
                return t.randomTriangularWith(e, a, .5 * (e + a));
            }
        }, {
            key: "randomTriangularWith",
            value: function(t, e, a) {
                var n = Math.random(), i = e - t;
                return n <= (a - t) / i ? t + Math.sqrt(n * i * (a - t)) : e - Math.sqrt((1 - n) * i * (e - a));
            }
        } ]), t;
    }();
    a.PI = 3.1415927, a.PI2 = 2 * a.PI, a.radiansToDegrees = 180 / a.PI, a.radDeg = a.radiansToDegrees, 
    a.degreesToRadians = a.PI / 180, a.degRad = a.degreesToRadians, t.MathUtils = a;
    var o = function() {
        function t() {
            r(this, t);
        }
        return s(t, [ {
            key: "apply",
            value: function(t, e, a) {
                return t + (e - t) * this.applyInternal(a);
            }
        } ]), t;
    }();
    t.Interpolation = o;
    var l = function(t) {
        n(a, t);
        var e = i(a);
        function a(t) {
            var n;
            return r(this, a), (n = e.call(this)).power = 2, n.power = t, n;
        }
        return s(a, [ {
            key: "applyInternal",
            value: function(t) {
                return t <= .5 ? Math.pow(2 * t, this.power) / 2 : Math.pow(2 * (t - 1), this.power) / (this.power % 2 == 0 ? -2 : 2) + 1;
            }
        } ]), a;
    }(o);
    t.Pow = l, t.PowOut = function(t) {
        n(a, t);
        var e = i(a);
        function a(t) {
            return r(this, a), e.call(this, t);
        }
        return s(a, [ {
            key: "applyInternal",
            value: function(t) {
                return Math.pow(t - 1, this.power) * (this.power % 2 == 0 ? -1 : 1) + 1;
            }
        } ]), a;
    }(l);
    var h = function() {
        function t() {
            r(this, t);
        }
        return s(t, null, [ {
            key: "arrayCopy",
            value: function(t, e, a, n, i) {
                for (var r = e, s = n; r < e + i; r++, s++) a[s] = t[r];
            }
        }, {
            key: "setArraySize",
            value: function(t, e) {
                var a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, n = t.length;
                if (n == e) return t;
                if (t.length = e, n < e) for (var i = n; i < e; i++) t[i] = a;
                return t;
            }
        }, {
            key: "ensureArrayCapacity",
            value: function(e, a) {
                var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                return e.length >= a ? e : t.setArraySize(e, a, n);
            }
        }, {
            key: "newArray",
            value: function(t, e) {
                for (var a = new Array(t), n = 0; n < t; n++) a[n] = e;
                return a;
            }
        }, {
            key: "newFloatArray",
            value: function(e) {
                if (t.SUPPORTS_TYPED_ARRAYS) return new Float32Array(e);
                for (var a = new Array(e), n = 0; n < a.length; n++) a[n] = 0;
                return a;
            }
        }, {
            key: "newShortArray",
            value: function(e) {
                if (t.SUPPORTS_TYPED_ARRAYS) return new Int16Array(e);
                for (var a = new Array(e), n = 0; n < a.length; n++) a[n] = 0;
                return a;
            }
        }, {
            key: "toFloatArray",
            value: function(e) {
                return t.SUPPORTS_TYPED_ARRAYS ? new Float32Array(e) : e;
            }
        }, {
            key: "toSinglePrecision",
            value: function(e) {
                return t.SUPPORTS_TYPED_ARRAYS ? Math.fround(e) : e;
            }
        }, {
            key: "webkit602BugfixHelper",
            value: function(t, e) {}
        } ]), t;
    }();
    h.SUPPORTS_TYPED_ARRAYS = "undefined" != typeof Float32Array, t.Utils = h, t.DebugUtils = function() {
        function t() {
            r(this, t);
        }
        return s(t, null, [ {
            key: "logBones",
            value: function(t) {
                for (var e = 0; e < t.bones.length; e++) {
                    var a = t.bones[e];
                    console.log(a.data.name + ", " + a.a + ", " + a.b + ", " + a.c + ", " + a.d + ", " + a.worldX + ", " + a.worldY);
                }
            }
        } ]), t;
    }(), t.Pool = function() {
        function t(e) {
            r(this, t), this.items = new Array(), this.instantiator = e;
        }
        return s(t, [ {
            key: "obtain",
            value: function() {
                return this.items.length > 0 ? this.items.pop() : this.instantiator();
            }
        }, {
            key: "free",
            value: function(t) {
                t.reset && t.reset(), this.items.push(t);
            }
        }, {
            key: "freeAll",
            value: function(t) {
                for (var e = 0; e < t.length; e++) t[e].reset && t[e].reset(), this.items[e] = t[e];
            }
        }, {
            key: "clear",
            value: function() {
                this.items.length = 0;
            }
        } ]), t;
    }(), t.Vector2 = function() {
        function t() {
            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, a = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
            r(this, t), this.x = e, this.y = a;
        }
        return s(t, [ {
            key: "set",
            value: function(t, e) {
                return this.x = t, this.y = e, this;
            }
        }, {
            key: "length",
            value: function() {
                var t = this.x, e = this.y;
                return Math.sqrt(t * t + e * e);
            }
        }, {
            key: "normalize",
            value: function() {
                var t = this.length();
                return 0 != t && (this.x /= t, this.y /= t), this;
            }
        } ]), t;
    }(), t.TimeKeeper = function() {
        function t() {
            r(this, t), this.maxDelta = .064, this.framesPerSecond = 0, this.delta = 0, this.totalTime = 0, 
            this.lastTime = Date.now() / 1e3, this.frameCount = 0, this.frameTime = 0;
        }
        return s(t, [ {
            key: "update",
            value: function() {
                var t = Date.now() / 1e3;
                this.delta = t - this.lastTime, this.frameTime += this.delta, this.totalTime += this.delta, 
                this.delta > this.maxDelta && (this.delta = this.maxDelta), this.lastTime = t, this.frameCount++, 
                this.frameTime > 1 && (this.framesPerSecond = this.frameCount / this.frameTime, 
                this.frameTime = 0, this.frameCount = 0);
            }
        } ]), t;
    }(), t.WindowedMean = function() {
        function t() {
            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 32;
            r(this, t), this.addedValues = 0, this.lastValue = 0, this.mean = 0, this.dirty = !0, 
            this.values = new Array(e);
        }
        return s(t, [ {
            key: "hasEnoughData",
            value: function() {
                return this.addedValues >= this.values.length;
            }
        }, {
            key: "addValue",
            value: function(t) {
                this.addedValues < this.values.length && this.addedValues++, this.values[this.lastValue++] = t, 
                this.lastValue > this.values.length - 1 && (this.lastValue = 0), this.dirty = !0;
            }
        }, {
            key: "getMean",
            value: function() {
                if (this.hasEnoughData()) {
                    if (this.dirty) {
                        for (var t = 0, e = 0; e < this.values.length; e++) t += this.values[e];
                        this.mean = t / this.values.length, this.dirty = !1;
                    }
                    return this.mean;
                }
                return 0;
            }
        } ]), t;
    }();
}(t || (t = {})), function() {
    var t;
    Math.fround || (Math.fround = (t = new Float32Array(1), function(e) {
        return t[0] = e, t[0];
    }));
}(), function(t) {
    var e = function t(e) {
        if (r(this, t), null == e) throw new Error("name cannot be null.");
        this.name = e;
    };
    t.Attachment = e;
    var a = function(t) {
        n(a, t);
        var e = i(a);
        function a(t) {
            var n;
            return r(this, a), (n = e.call(this, t)).id = (65535 & a.nextID++) << 11, n.worldVerticesLength = 0, 
            n;
        }
        return s(a, [ {
            key: "computeWorldVertices",
            value: function(t, e, a, n, i, r) {
                a = i + (a >> 1) * r;
                var s = t.bone.skeleton, o = t.attachmentVertices, l = this.vertices, h = this.bones;
                if (null != h) {
                    for (var u = 0, c = 0, f = 0; f < e; f += 2) {
                        var d = h[u];
                        u += d + 1, c += d;
                    }
                    var v = s.bones;
                    if (0 == o.length) for (var m = i, g = 3 * c; m < a; m += r) {
                        var p = 0, y = 0, M = h[u++];
                        for (M += u; u < M; u++, g += 3) {
                            var x = v[h[u]], w = l[g], E = l[g + 1], k = l[g + 2];
                            p += (w * x.a + E * x.b + x.worldX) * k, y += (w * x.c + E * x.d + x.worldY) * k;
                        }
                        n[m] = p, n[m + 1] = y;
                    } else for (var T = o, b = i, A = 3 * c, R = c << 1; b < a; b += r) {
                        var S = 0, I = 0, P = h[u++];
                        for (P += u; u < P; u++, A += 3, R += 2) {
                            var C = v[h[u]], V = l[A] + T[R], N = l[A + 1] + T[R + 1], Y = l[A + 2];
                            S += (V * C.a + N * C.b + C.worldX) * Y, I += (V * C.c + N * C.d + C.worldY) * Y;
                        }
                        n[b] = S, n[b + 1] = I;
                    }
                } else {
                    o.length > 0 && (l = o);
                    for (var X = t.bone, U = X.worldX, L = X.worldY, D = X.a, F = X.b, _ = X.c, O = X.d, B = e, W = i; W < a; B += 2, 
                    W += r) {
                        var q = l[B], H = l[B + 1];
                        n[W] = q * D + H * F + U, n[W + 1] = q * _ + H * O + L;
                    }
                }
            }
        }, {
            key: "applyDeform",
            value: function(t) {
                return this == t;
            }
        } ]), a;
    }(e);
    a.nextID = 0, t.VertexAttachment = a;
}(t || (t = {})), function(t) {
    !function(t) {
        t[t.Region = 0] = "Region", t[t.BoundingBox = 1] = "BoundingBox", t[t.Mesh = 2] = "Mesh", 
        t[t.LinkedMesh = 3] = "LinkedMesh", t[t.Path = 4] = "Path", t[t.Point = 5] = "Point";
    }(t.AttachmentType || (t.AttachmentType = {}));
}(t || (t = {})), function(t) {
    var e = function(e) {
        n(s, e);
        var a = i(s);
        function s(e) {
            var n;
            return r(this, s), (n = a.call(this, e)).color = new t.Color(1, 1, 1, 1), n;
        }
        return s;
    }(t.VertexAttachment);
    t.BoundingBoxAttachment = e;
}(t || (t = {})), function(t) {
    var e = function(e) {
        n(s, e);
        var a = i(s);
        function s(e) {
            var n;
            return r(this, s), (n = a.call(this, e)).color = new t.Color(.2275, .2275, .8078, 1), 
            n;
        }
        return s;
    }(t.VertexAttachment);
    t.ClippingAttachment = e;
}(t || (t = {})), function(t) {
    var e = function(e) {
        n(o, e);
        var a = i(o);
        function o(e) {
            var n;
            return r(this, o), (n = a.call(this, e)).color = new t.Color(1, 1, 1, 1), n.inheritDeform = !1, 
            n.tempColor = new t.Color(0, 0, 0, 0), n;
        }
        return s(o, [ {
            key: "updateUVs",
            value: function() {
                var e = this.regionUVs;
                null != this.uvs && this.uvs.length == e.length || (this.uvs = t.Utils.newFloatArray(e.length));
                var a = this.uvs, n = 0, i = 0, r = 0, s = 0;
                if (this.region instanceof t.TextureAtlasRegion) {
                    var o = this.region, l = o.texture.getImage().width, h = o.texture.getImage().height;
                    if (o.rotate) {
                        n = o.u - (o.originalHeight - o.offsetY - o.height) / l, i = o.v - (o.originalWidth - o.offsetX - o.width) / h, 
                        r = o.originalHeight / l, s = o.originalWidth / h;
                        for (var u = 0, c = a.length; u < c; u += 2) a[u] = n + e[u + 1] * r, a[u + 1] = i + s - e[u] * s;
                        return;
                    }
                    n = o.u - o.offsetX / l, i = o.v - (o.originalHeight - o.offsetY - o.height) / h, 
                    r = o.originalWidth / l, s = o.originalHeight / h;
                } else null == this.region ? (n = i = 0, r = s = 1) : (n = this.region.u, i = this.region.v, 
                r = this.region.u2 - n, s = this.region.v2 - i);
                for (var f = 0, d = a.length; f < d; f += 2) a[f] = n + e[f] * r, a[f + 1] = i + e[f + 1] * s;
            }
        }, {
            key: "applyDeform",
            value: function(t) {
                return this == t || this.inheritDeform && this.parentMesh == t;
            }
        }, {
            key: "getParentMesh",
            value: function() {
                return this.parentMesh;
            }
        }, {
            key: "setParentMesh",
            value: function(t) {
                this.parentMesh = t, null != t && (this.bones = t.bones, this.vertices = t.vertices, 
                this.worldVerticesLength = t.worldVerticesLength, this.regionUVs = t.regionUVs, 
                this.triangles = t.triangles, this.hullLength = t.hullLength, this.worldVerticesLength = t.worldVerticesLength);
            }
        } ]), o;
    }(t.VertexAttachment);
    t.MeshAttachment = e;
}(t || (t = {})), function(t) {
    var e = function(e) {
        n(s, e);
        var a = i(s);
        function s(e) {
            var n;
            return r(this, s), (n = a.call(this, e)).closed = !1, n.constantSpeed = !1, n.color = new t.Color(1, 1, 1, 1), 
            n;
        }
        return s;
    }(t.VertexAttachment);
    t.PathAttachment = e;
}(t || (t = {})), function(t) {
    var e = function(e) {
        n(o, e);
        var a = i(o);
        function o(e) {
            var n;
            return r(this, o), (n = a.call(this, e)).color = new t.Color(.38, .94, 0, 1), n;
        }
        return s(o, [ {
            key: "computeWorldPosition",
            value: function(t, e) {
                return e.x = this.x * t.a + this.y * t.b + t.worldX, e.y = this.x * t.c + this.y * t.d + t.worldY, 
                e;
            }
        }, {
            key: "computeWorldRotation",
            value: function(e) {
                var a = t.MathUtils.cosDeg(this.rotation), n = t.MathUtils.sinDeg(this.rotation), i = a * e.a + n * e.b, r = a * e.c + n * e.d;
                return Math.atan2(r, i) * t.MathUtils.radDeg;
            }
        } ]), o;
    }(t.VertexAttachment);
    t.PointAttachment = e;
}(t || (t = {})), function(t) {
    var e = function(e) {
        n(o, e);
        var a = i(o);
        function o(e) {
            var n;
            return r(this, o), (n = a.call(this, e)).x = 0, n.y = 0, n.scaleX = 1, n.scaleY = 1, 
            n.rotation = 0, n.width = 0, n.height = 0, n.color = new t.Color(1, 1, 1, 1), n.offset = t.Utils.newFloatArray(8), 
            n.uvs = t.Utils.newFloatArray(8), n.tempColor = new t.Color(1, 1, 1, 1), n;
        }
        return s(o, [ {
            key: "updateOffset",
            value: function() {
                var t = this.width / this.region.originalWidth * this.scaleX, e = this.height / this.region.originalHeight * this.scaleY, a = -this.width / 2 * this.scaleX + this.region.offsetX * t, n = -this.height / 2 * this.scaleY + this.region.offsetY * e, i = a + this.region.width * t, r = n + this.region.height * e, s = this.rotation * Math.PI / 180, l = Math.cos(s), h = Math.sin(s), u = a * l + this.x, c = a * h, f = n * l + this.y, d = n * h, v = i * l + this.x, m = i * h, g = r * l + this.y, p = r * h, y = this.offset;
                y[o.OX1] = u - d, y[o.OY1] = f + c, y[o.OX2] = u - p, y[o.OY2] = g + c, y[o.OX3] = v - p, 
                y[o.OY3] = g + m, y[o.OX4] = v - d, y[o.OY4] = f + m;
            }
        }, {
            key: "setRegion",
            value: function(t) {
                this.region = t;
                var e = this.uvs;
                t.rotate ? (e[2] = t.u, e[3] = t.v2, e[4] = t.u, e[5] = t.v, e[6] = t.u2, e[7] = t.v, 
                e[0] = t.u2, e[1] = t.v2) : (e[0] = t.u, e[1] = t.v2, e[2] = t.u, e[3] = t.v, e[4] = t.u2, 
                e[5] = t.v, e[6] = t.u2, e[7] = t.v2);
            }
        }, {
            key: "computeWorldVertices",
            value: function(t, e, a, n) {
                var i = this.offset, r = t.worldX, s = t.worldY, l = t.a, h = t.b, u = t.c, c = t.d, f = 0, d = 0;
                f = i[o.OX1], d = i[o.OY1], e[a] = f * l + d * h + r, e[a + 1] = f * u + d * c + s, 
                a += n, f = i[o.OX2], d = i[o.OY2], e[a] = f * l + d * h + r, e[a + 1] = f * u + d * c + s, 
                a += n, f = i[o.OX3], d = i[o.OY3], e[a] = f * l + d * h + r, e[a + 1] = f * u + d * c + s, 
                a += n, f = i[o.OX4], d = i[o.OY4], e[a] = f * l + d * h + r, e[a + 1] = f * u + d * c + s;
            }
        } ]), o;
    }(t.Attachment);
    e.OX1 = 0, e.OY1 = 1, e.OX2 = 2, e.OY2 = 3, e.OX3 = 4, e.OY3 = 5, e.OX4 = 6, e.OY4 = 7, 
    e.X1 = 0, e.Y1 = 1, e.C1R = 2, e.C1G = 3, e.C1B = 4, e.C1A = 5, e.U1 = 6, e.V1 = 7, 
    e.X2 = 8, e.Y2 = 9, e.C2R = 10, e.C2G = 11, e.C2B = 12, e.C2A = 13, e.U2 = 14, e.V2 = 15, 
    e.X3 = 16, e.Y3 = 17, e.C3R = 18, e.C3G = 19, e.C3B = 20, e.C3A = 21, e.U3 = 22, 
    e.V3 = 23, e.X4 = 24, e.Y4 = 25, e.C4R = 26, e.C4G = 27, e.C4B = 28, e.C4A = 29, 
    e.U4 = 30, e.V4 = 31, t.RegionAttachment = e;
}(t || (t = {})), function(t) {
    t.JitterEffect = function() {
        function e(t, a) {
            r(this, e), this.jitterX = 0, this.jitterY = 0, this.jitterX = t, this.jitterY = a;
        }
        return s(e, [ {
            key: "begin",
            value: function(t) {}
        }, {
            key: "transform",
            value: function(e, a, n, i) {
                e.x += t.MathUtils.randomTriangular(-this.jitterX, this.jitterY), e.y += t.MathUtils.randomTriangular(-this.jitterX, this.jitterY);
            }
        }, {
            key: "end",
            value: function() {}
        } ]), e;
    }();
}(t || (t = {})), function(t) {
    var e = function() {
        function e(t) {
            r(this, e), this.centerX = 0, this.centerY = 0, this.radius = 0, this.angle = 0, 
            this.worldX = 0, this.worldY = 0, this.radius = t;
        }
        return s(e, [ {
            key: "begin",
            value: function(t) {
                this.worldX = t.x + this.centerX, this.worldY = t.y + this.centerY;
            }
        }, {
            key: "transform",
            value: function(a, n, i, r) {
                var s = this.angle * t.MathUtils.degreesToRadians, o = a.x - this.worldX, l = a.y - this.worldY, h = Math.sqrt(o * o + l * l);
                if (h < this.radius) {
                    var u = e.interpolation.apply(0, s, (this.radius - h) / this.radius), c = Math.cos(u), f = Math.sin(u);
                    a.x = c * o - f * l + this.worldX, a.y = f * o + c * l + this.worldY;
                }
            }
        }, {
            key: "end",
            value: function() {}
        } ]), e;
    }();
    e.interpolation = new t.PowOut(2), t.SwirlEffect = e;
}(t || (t = {})), window.spine = t;